{"ast":null,"code":"/** @license React v16.13.1\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react-dom'), require('react')) : typeof define === 'function' && define.amd ? define(['react-dom', 'react'], factory) : (global = global || self, global.ReactDOMUnstableNativeDependencies = factory(global.ReactDOM, global.React));\n})(this, function (ReactDOM, React) {\n  'use strict';\n\n  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.\n  // Current owner and dispatcher used to share the same ref,\n  // but PR #14548 split them out to better support the react-debug-tools package.\n\n  if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n    ReactSharedInternals.ReactCurrentDispatcher = {\n      current: null\n    };\n  }\n\n  if (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n    ReactSharedInternals.ReactCurrentBatchConfig = {\n      suspense: null\n    };\n  } // by calls to these methods by a Babel plugin.\n  //\n  // In PROD (or in packages without access to React internals),\n  // they are left as they are instead.\n\n\n  function warn(format) {\n    {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n\n  function error(format) {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n\n  function printWarning(level, format, args) {\n    // When changing this logic, you might want to also\n    // update consoleWithStackDev.www.js as well.\n    {\n      var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n\n      if (!hasExistingStack) {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n      }\n\n      var argsWithFormat = args.map(function (item) {\n        return '' + item;\n      }); // Careful: RN currently depends on this prefix\n\n      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n      // breaks IE9: https://github.com/facebook/react/issues/13610\n      // eslint-disable-next-line react-internal/no-production-logging\n\n      Function.prototype.apply.call(console[level], console, argsWithFormat);\n\n      try {\n        // --- Welcome to debugging React ---\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        var argIndex = 0;\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n        throw new Error(message);\n      } catch (x) {}\n    }\n  }\n\n  {\n    // In DEV mode, we swap out invokeGuardedCallback for a special version\n    // that plays more nicely with the browser's DevTools. The idea is to preserve\n    // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n    // functions in invokeGuardedCallback, and the production version of\n    // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n    // like caught exceptions, and the DevTools won't pause unless the developer\n    // takes the extra step of enabling pause on caught exceptions. This is\n    // unintuitive, though, because even though React has caught the error, from\n    // the developer's perspective, the error is uncaught.\n    //\n    // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n    // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n    // DOM node, and call the user-provided callback from inside an event handler\n    // for that fake event. If the callback throws, the error is \"captured\" using\n    // a global event handler. But because the error happens in a different\n    // event loop context, it does not interrupt the normal program flow.\n    // Effectively, this gives us try-catch behavior without actually using\n    // try-catch. Neat!\n    // Check that the browser supports the APIs we need to implement our special\n    // DEV version of invokeGuardedCallback\n    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n      var fakeNode = document.createElement('react');\n    }\n  }\n  var getFiberCurrentPropsFromNode = null;\n  var getInstanceFromNode = null;\n  var getNodeFromInstance = null;\n\n  function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n    getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n    getInstanceFromNode = getInstanceFromNodeImpl;\n    getNodeFromInstance = getNodeFromInstanceImpl;\n    {\n      if (!getNodeFromInstance || !getInstanceFromNode) {\n        error('EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n      }\n    }\n  }\n\n  var validateEventDispatches;\n  {\n    validateEventDispatches = function (event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      var listenersIsArr = Array.isArray(dispatchListeners);\n      var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n      var instancesIsArr = Array.isArray(dispatchInstances);\n      var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n      if (instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {\n        error('EventPluginUtils: Invalid `event`.');\n      }\n    };\n  }\n  /**\n   * Standard/simple iteration through an event's collected dispatches, but stops\n   * at the first dispatch execution returning true, and returns that id.\n   *\n   * @return {?string} id of the first dispatch execution who's listener returns\n   * true, or null if no listener returned true.\n   */\n\n  function executeDispatchesInOrderStopAtTrueImpl(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n    {\n      validateEventDispatches(event);\n    }\n\n    if (Array.isArray(dispatchListeners)) {\n      for (var i = 0; i < dispatchListeners.length; i++) {\n        if (event.isPropagationStopped()) {\n          break;\n        } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n        if (dispatchListeners[i](event, dispatchInstances[i])) {\n          return dispatchInstances[i];\n        }\n      }\n    } else if (dispatchListeners) {\n      if (dispatchListeners(event, dispatchInstances)) {\n        return dispatchInstances;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @see executeDispatchesInOrderStopAtTrueImpl\n   */\n\n\n  function executeDispatchesInOrderStopAtTrue(event) {\n    var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n    event._dispatchInstances = null;\n    event._dispatchListeners = null;\n    return ret;\n  }\n  /**\n   * Execution of a \"direct\" dispatch - there must be at most one dispatch\n   * accumulated on the event or it is considered an error. It doesn't really make\n   * sense for an event with multiple dispatches (bubbled) to keep track of the\n   * return values at each dispatch execution, but it does tend to make sense when\n   * dealing with \"direct\" dispatches.\n   *\n   * @return {*} The return value of executing the single dispatch.\n   */\n\n\n  function executeDirectDispatch(event) {\n    {\n      validateEventDispatches(event);\n    }\n    var dispatchListener = event._dispatchListeners;\n    var dispatchInstance = event._dispatchInstances;\n\n    if (!!Array.isArray(dispatchListener)) {\n      {\n        throw Error(\"executeDirectDispatch(...): Invalid `event`.\");\n      }\n    }\n\n    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n    var res = dispatchListener ? dispatchListener(event) : null;\n    event.currentTarget = null;\n    event._dispatchListeners = null;\n    event._dispatchInstances = null;\n    return res;\n  }\n  /**\n   * @param {SyntheticEvent} event\n   * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n   */\n\n\n  function hasDispatches(event) {\n    return !!event._dispatchListeners;\n  }\n\n  var HostComponent = 5;\n\n  function getParent(inst) {\n    do {\n      inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n      // That is depending on if we want nested subtrees (layers) to bubble\n      // events to their parent. We could also go through parentNode on the\n      // host node but that wouldn't work for React Native and doesn't let us\n      // do the portal feature.\n    } while (inst && inst.tag !== HostComponent);\n\n    if (inst) {\n      return inst;\n    }\n\n    return null;\n  }\n  /**\n   * Return the lowest common ancestor of A and B, or null if they are in\n   * different trees.\n   */\n\n\n  function getLowestCommonAncestor(instA, instB) {\n    var depthA = 0;\n\n    for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n      depthA++;\n    }\n\n    var depthB = 0;\n\n    for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n      depthB++;\n    } // If A is deeper, crawl up.\n\n\n    while (depthA - depthB > 0) {\n      instA = getParent(instA);\n      depthA--;\n    } // If B is deeper, crawl up.\n\n\n    while (depthB - depthA > 0) {\n      instB = getParent(instB);\n      depthB--;\n    } // Walk in lockstep until we find a match.\n\n\n    var depth = depthA;\n\n    while (depth--) {\n      if (instA === instB || instA === instB.alternate) {\n        return instA;\n      }\n\n      instA = getParent(instA);\n      instB = getParent(instB);\n    }\n\n    return null;\n  }\n  /**\n   * Return if A is an ancestor of B.\n   */\n\n\n  function isAncestor(instA, instB) {\n    while (instB) {\n      if (instA === instB || instA === instB.alternate) {\n        return true;\n      }\n\n      instB = getParent(instB);\n    }\n\n    return false;\n  }\n  /**\n   * Return the parent instance of the passed-in instance.\n   */\n\n\n  function getParentInstance(inst) {\n    return getParent(inst);\n  }\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   */\n\n\n  function traverseTwoPhase(inst, fn, arg) {\n    var path = [];\n\n    while (inst) {\n      path.push(inst);\n      inst = getParent(inst);\n    }\n\n    var i;\n\n    for (i = path.length; i-- > 0;) {\n      fn(path[i], 'captured', arg);\n    }\n\n    for (i = 0; i < path.length; i++) {\n      fn(path[i], 'bubbled', arg);\n    }\n  }\n\n  function isInteractive(tag) {\n    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n  }\n\n  function shouldPreventMouseEvent(name, type, props) {\n    switch (name) {\n      case 'onClick':\n      case 'onClickCapture':\n      case 'onDoubleClick':\n      case 'onDoubleClickCapture':\n      case 'onMouseDown':\n      case 'onMouseDownCapture':\n      case 'onMouseMove':\n      case 'onMouseMoveCapture':\n      case 'onMouseUp':\n      case 'onMouseUpCapture':\n      case 'onMouseEnter':\n        return !!(props.disabled && isInteractive(type));\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * @param {object} inst The instance, which is the source of events.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n\n\n  function getListener(inst, registrationName) {\n    var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n    // live here; needs to be moved to a better place soon\n\n    var stateNode = inst.stateNode;\n\n    if (!stateNode) {\n      // Work in progress (ex: onload events in incremental mode).\n      return null;\n    }\n\n    var props = getFiberCurrentPropsFromNode(stateNode);\n\n    if (!props) {\n      // Work in progress.\n      return null;\n    }\n\n    listener = props[registrationName];\n\n    if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n      return null;\n    }\n\n    if (!(!listener || typeof listener === 'function')) {\n      {\n        throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n      }\n    }\n\n    return listener;\n  }\n  /**\n   * Accumulates items that must not be null or undefined into the first one. This\n   * is used to conserve memory by avoiding array allocations, and thus sacrifices\n   * API cleanness. Since `current` can be null before being passed in and not\n   * null after this function, make sure to assign it back to `current`:\n   *\n   * `a = accumulateInto(a, b);`\n   *\n   * This API should be sparingly used. Try `accumulate` for something cleaner.\n   *\n   * @return {*|array<*>} An accumulation of items.\n   */\n\n\n  function accumulateInto(current, next) {\n    if (!(next != null)) {\n      {\n        throw Error(\"accumulateInto(...): Accumulated items must not be null or undefined.\");\n      }\n    }\n\n    if (current == null) {\n      return next;\n    } // Both are not empty. Warning: Never call x.concat(y) when you are not\n    // certain that x is an Array (x could be a string with concat method).\n\n\n    if (Array.isArray(current)) {\n      if (Array.isArray(next)) {\n        current.push.apply(current, next);\n        return current;\n      }\n\n      current.push(next);\n      return current;\n    }\n\n    if (Array.isArray(next)) {\n      // A bit too dangerous to mutate `next`.\n      return [current].concat(next);\n    }\n\n    return [current, next];\n  }\n  /**\n   * @param {array} arr an \"accumulation\" of items which is either an Array or\n   * a single item. Useful when paired with the `accumulate` module. This is a\n   * simple utility that allows us to reason about a collection of items, but\n   * handling the case when there is exactly one item (and we do not need to\n   * allocate an array).\n   * @param {function} cb Callback invoked with each element or a collection.\n   * @param {?} [scope] Scope used as `this` in a callback.\n   */\n\n\n  function forEachAccumulated(arr, cb, scope) {\n    if (Array.isArray(arr)) {\n      arr.forEach(cb, scope);\n    } else if (arr) {\n      cb.call(scope, arr);\n    }\n  }\n  /**\n   * Some event types have a notion of different registration names for different\n   * \"phases\" of propagation. This finds listeners by a given phase.\n   */\n\n\n  function listenerAtPhase(inst, event, propagationPhase) {\n    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n    return getListener(inst, registrationName);\n  }\n  /**\n   * A small set of propagation patterns, each of which will accept a small amount\n   * of information, and generate a set of \"dispatch ready event objects\" - which\n   * are sets of events that have already been annotated with a set of dispatched\n   * listener functions/ids. The API is designed this way to discourage these\n   * propagation strategies from actually executing the dispatches, since we\n   * always want to collect the entire set of dispatches before executing even a\n   * single one.\n   */\n\n  /**\n   * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n   * here, allows us to not have to bind or create functions for each event.\n   * Mutating the event's members allows us to not have to create a wrapping\n   * \"dispatch\" object that pairs the event with the listener.\n   */\n\n\n  function accumulateDirectionalDispatches(inst, phase, event) {\n    {\n      if (!inst) {\n        error('Dispatching inst must not be null');\n      }\n    }\n    var listener = listenerAtPhase(inst, event, phase);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n  /**\n   * Collect dispatches (must be entirely collected before dispatching - see unit\n   * tests). Lazily allocate the array to conserve memory.  We must loop through\n   * each event and perform the traversal for each one. We cannot perform a\n   * single traversal for the entire collection of events because each event may\n   * have a different target.\n   */\n\n\n  function accumulateTwoPhaseDispatchesSingle(event) {\n    if (event && event.dispatchConfig.phasedRegistrationNames) {\n      traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n    }\n  }\n  /**\n   * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n   */\n\n\n  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n    if (event && event.dispatchConfig.phasedRegistrationNames) {\n      var targetInst = event._targetInst;\n      var parentInst = targetInst ? getParentInstance(targetInst) : null;\n      traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n    }\n  }\n  /**\n   * Accumulates without regard to direction, does not look for phased\n   * registration names. Same as `accumulateDirectDispatchesSingle` but without\n   * requiring that the `dispatchMarker` be the same as the dispatched ID.\n   */\n\n\n  function accumulateDispatches(inst, ignoredDirection, event) {\n    if (inst && event && event.dispatchConfig.registrationName) {\n      var registrationName = event.dispatchConfig.registrationName;\n      var listener = getListener(inst, registrationName);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n  }\n  /**\n   * Accumulates dispatches on an `SyntheticEvent`, but only for the\n   * `dispatchMarker`.\n   * @param {SyntheticEvent} event\n   */\n\n\n  function accumulateDirectDispatchesSingle(event) {\n    if (event && event.dispatchConfig.registrationName) {\n      accumulateDispatches(event._targetInst, null, event);\n    }\n  }\n\n  function accumulateTwoPhaseDispatches(events) {\n    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n  }\n\n  function accumulateTwoPhaseDispatchesSkipTarget(events) {\n    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n  }\n\n  function accumulateDirectDispatches(events) {\n    forEachAccumulated(events, accumulateDirectDispatchesSingle);\n  }\n\n  var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  var _assign = ReactInternals.assign;\n  var EVENT_POOL_SIZE = 10;\n  /**\n   * @interface Event\n   * @see http://www.w3.org/TR/DOM-Level-3-Events/\n   */\n\n  var EventInterface = {\n    type: null,\n    target: null,\n    // currentTarget is set when dispatching; no use in copying it here\n    currentTarget: function () {\n      return null;\n    },\n    eventPhase: null,\n    bubbles: null,\n    cancelable: null,\n    timeStamp: function (event) {\n      return event.timeStamp || Date.now();\n    },\n    defaultPrevented: null,\n    isTrusted: null\n  };\n\n  function functionThatReturnsTrue() {\n    return true;\n  }\n\n  function functionThatReturnsFalse() {\n    return false;\n  }\n  /**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   *\n   * @param {object} dispatchConfig Configuration used to dispatch this event.\n   * @param {*} targetInst Marker identifying the event target.\n   * @param {object} nativeEvent Native browser event.\n   * @param {DOMEventTarget} nativeEventTarget Target node.\n   */\n\n\n  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n    {\n      // these have a getter/setter for warnings\n      delete this.nativeEvent;\n      delete this.preventDefault;\n      delete this.stopPropagation;\n      delete this.isDefaultPrevented;\n      delete this.isPropagationStopped;\n    }\n    this.dispatchConfig = dispatchConfig;\n    this._targetInst = targetInst;\n    this.nativeEvent = nativeEvent;\n    var Interface = this.constructor.Interface;\n\n    for (var propName in Interface) {\n      if (!Interface.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      {\n        delete this[propName]; // this has a getter/setter for warnings\n      }\n      var normalize = Interface[propName];\n\n      if (normalize) {\n        this[propName] = normalize(nativeEvent);\n      } else {\n        if (propName === 'target') {\n          this.target = nativeEventTarget;\n        } else {\n          this[propName] = nativeEvent[propName];\n        }\n      }\n    }\n\n    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n    if (defaultPrevented) {\n      this.isDefaultPrevented = functionThatReturnsTrue;\n    } else {\n      this.isDefaultPrevented = functionThatReturnsFalse;\n    }\n\n    this.isPropagationStopped = functionThatReturnsFalse;\n    return this;\n  }\n\n  _assign(SyntheticEvent.prototype, {\n    preventDefault: function () {\n      this.defaultPrevented = true;\n      var event = this.nativeEvent;\n\n      if (!event) {\n        return;\n      }\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      } else if (typeof event.returnValue !== 'unknown') {\n        event.returnValue = false;\n      }\n\n      this.isDefaultPrevented = functionThatReturnsTrue;\n    },\n    stopPropagation: function () {\n      var event = this.nativeEvent;\n\n      if (!event) {\n        return;\n      }\n\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      } else if (typeof event.cancelBubble !== 'unknown') {\n        // The ChangeEventPlugin registers a \"propertychange\" event for\n        // IE. This event does not support bubbling or cancelling, and\n        // any references to cancelBubble throw \"Member not found\".  A\n        // typeof check of \"unknown\" circumvents this issue (and is also\n        // IE specific).\n        event.cancelBubble = true;\n      }\n\n      this.isPropagationStopped = functionThatReturnsTrue;\n    },\n\n    /**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */\n    persist: function () {\n      this.isPersistent = functionThatReturnsTrue;\n    },\n\n    /**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */\n    isPersistent: functionThatReturnsFalse,\n\n    /**\n     * `PooledClass` looks for `destructor` on each instance it releases.\n     */\n    destructor: function () {\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        {\n          Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n        }\n      }\n\n      this.dispatchConfig = null;\n      this._targetInst = null;\n      this.nativeEvent = null;\n      this.isDefaultPrevented = functionThatReturnsFalse;\n      this.isPropagationStopped = functionThatReturnsFalse;\n      this._dispatchListeners = null;\n      this._dispatchInstances = null;\n      {\n        Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n        Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n        Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n        Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n        Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n      }\n    }\n  });\n\n  SyntheticEvent.Interface = EventInterface;\n  /**\n   * Helper to reduce boilerplate when creating subclasses.\n   */\n\n  SyntheticEvent.extend = function (Interface) {\n    var Super = this;\n\n    var E = function () {};\n\n    E.prototype = Super.prototype;\n    var prototype = new E();\n\n    function Class() {\n      return Super.apply(this, arguments);\n    }\n\n    _assign(prototype, Class.prototype);\n\n    Class.prototype = prototype;\n    Class.prototype.constructor = Class;\n    Class.Interface = _assign({}, Super.Interface, Interface);\n    Class.extend = Super.extend;\n    addEventPoolingTo(Class);\n    return Class;\n  };\n\n  addEventPoolingTo(SyntheticEvent);\n  /**\n   * Helper to nullify syntheticEvent instance properties when destructing\n   *\n   * @param {String} propName\n   * @param {?object} getVal\n   * @return {object} defineProperty object\n   */\n\n  function getPooledWarningPropertyDefinition(propName, getVal) {\n    var isFunction = typeof getVal === 'function';\n    return {\n      configurable: true,\n      set: set,\n      get: get\n    };\n\n    function set(val) {\n      var action = isFunction ? 'setting the method' : 'setting the property';\n      warn(action, 'This is effectively a no-op');\n      return val;\n    }\n\n    function get() {\n      var action = isFunction ? 'accessing the method' : 'accessing the property';\n      var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n      warn(action, result);\n      return getVal;\n    }\n\n    function warn(action, result) {\n      {\n        error(\"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n      }\n    }\n  }\n\n  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n    var EventConstructor = this;\n\n    if (EventConstructor.eventPool.length) {\n      var instance = EventConstructor.eventPool.pop();\n      EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n      return instance;\n    }\n\n    return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n  }\n\n  function releasePooledEvent(event) {\n    var EventConstructor = this;\n\n    if (!(event instanceof EventConstructor)) {\n      {\n        throw Error(\"Trying to release an event instance into a pool of a different type.\");\n      }\n    }\n\n    event.destructor();\n\n    if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n      EventConstructor.eventPool.push(event);\n    }\n  }\n\n  function addEventPoolingTo(EventConstructor) {\n    EventConstructor.eventPool = [];\n    EventConstructor.getPooled = getPooledEvent;\n    EventConstructor.release = releasePooledEvent;\n  }\n  /**\n   * `touchHistory` isn't actually on the native event, but putting it in the\n   * interface will ensure that it is cleaned up when pooled/destroyed. The\n   * `ResponderEventPlugin` will populate it appropriately.\n   */\n\n\n  var ResponderSyntheticEvent = SyntheticEvent.extend({\n    touchHistory: function (nativeEvent) {\n      return null; // Actually doesn't even look at the native event.\n    }\n  }); // Note: ideally these would be imported from DOMTopLevelEventTypes,\n  // but our build system currently doesn't let us do that from a fork.\n\n  var TOP_TOUCH_START = 'touchstart';\n  var TOP_TOUCH_MOVE = 'touchmove';\n  var TOP_TOUCH_END = 'touchend';\n  var TOP_TOUCH_CANCEL = 'touchcancel';\n  var TOP_SCROLL = 'scroll';\n  var TOP_SELECTION_CHANGE = 'selectionchange';\n  var TOP_MOUSE_DOWN = 'mousedown';\n  var TOP_MOUSE_MOVE = 'mousemove';\n  var TOP_MOUSE_UP = 'mouseup';\n\n  function isStartish(topLevelType) {\n    return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n  }\n\n  function isMoveish(topLevelType) {\n    return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n  }\n\n  function isEndish(topLevelType) {\n    return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n  }\n\n  var startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\n  var moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\n  var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n  /**\n   * Tracks the position and time of each active touch by `touch.identifier`. We\n   * should typically only see IDs in the range of 1-20 because IDs get recycled\n   * when touches end and start again.\n   */\n\n  var MAX_TOUCH_BANK = 20;\n  var touchBank = [];\n  var touchHistory = {\n    touchBank: touchBank,\n    numberActiveTouches: 0,\n    // If there is only one active touch, we remember its location. This prevents\n    // us having to loop through all of the touches all the time in the most\n    // common case.\n    indexOfSingleActiveTouch: -1,\n    mostRecentTimeStamp: 0\n  };\n\n  function timestampForTouch(touch) {\n    // The legacy internal implementation provides \"timeStamp\", which has been\n    // renamed to \"timestamp\". Let both work for now while we iron it out\n    // TODO (evv): rename timeStamp to timestamp in internal code\n    return touch.timeStamp || touch.timestamp;\n  }\n  /**\n   * TODO: Instead of making gestures recompute filtered velocity, we could\n   * include a built in velocity computation that can be reused globally.\n   */\n\n\n  function createTouchRecord(touch) {\n    return {\n      touchActive: true,\n      startPageX: touch.pageX,\n      startPageY: touch.pageY,\n      startTimeStamp: timestampForTouch(touch),\n      currentPageX: touch.pageX,\n      currentPageY: touch.pageY,\n      currentTimeStamp: timestampForTouch(touch),\n      previousPageX: touch.pageX,\n      previousPageY: touch.pageY,\n      previousTimeStamp: timestampForTouch(touch)\n    };\n  }\n\n  function resetTouchRecord(touchRecord, touch) {\n    touchRecord.touchActive = true;\n    touchRecord.startPageX = touch.pageX;\n    touchRecord.startPageY = touch.pageY;\n    touchRecord.startTimeStamp = timestampForTouch(touch);\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchRecord.previousPageX = touch.pageX;\n    touchRecord.previousPageY = touch.pageY;\n    touchRecord.previousTimeStamp = timestampForTouch(touch);\n  }\n\n  function getTouchIdentifier(_ref) {\n    var identifier = _ref.identifier;\n\n    if (!(identifier != null)) {\n      {\n        throw Error(\"Touch object is missing identifier.\");\n      }\n    }\n\n    {\n      if (identifier > MAX_TOUCH_BANK) {\n        error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n      }\n    }\n    return identifier;\n  }\n\n  function recordTouchStart(touch) {\n    var identifier = getTouchIdentifier(touch);\n    var touchRecord = touchBank[identifier];\n\n    if (touchRecord) {\n      resetTouchRecord(touchRecord, touch);\n    } else {\n      touchBank[identifier] = createTouchRecord(touch);\n    }\n\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  }\n\n  function recordTouchMove(touch) {\n    var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n    if (touchRecord) {\n      touchRecord.touchActive = true;\n      touchRecord.previousPageX = touchRecord.currentPageX;\n      touchRecord.previousPageY = touchRecord.currentPageY;\n      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    } else {\n      {\n        warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n  }\n\n  function recordTouchEnd(touch) {\n    var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n    if (touchRecord) {\n      touchRecord.touchActive = false;\n      touchRecord.previousPageX = touchRecord.currentPageX;\n      touchRecord.previousPageY = touchRecord.currentPageY;\n      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    } else {\n      {\n        warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n  }\n\n  function printTouch(touch) {\n    return JSON.stringify({\n      identifier: touch.identifier,\n      pageX: touch.pageX,\n      pageY: touch.pageY,\n      timestamp: timestampForTouch(touch)\n    });\n  }\n\n  function printTouchBank() {\n    var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n    if (touchBank.length > MAX_TOUCH_BANK) {\n      printed += ' (original size: ' + touchBank.length + ')';\n    }\n\n    return printed;\n  }\n\n  var ResponderTouchHistoryStore = {\n    recordTouchTrack: function (topLevelType, nativeEvent) {\n      if (isMoveish(topLevelType)) {\n        nativeEvent.changedTouches.forEach(recordTouchMove);\n      } else if (isStartish(topLevelType)) {\n        nativeEvent.changedTouches.forEach(recordTouchStart);\n        touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n        if (touchHistory.numberActiveTouches === 1) {\n          touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n        }\n      } else if (isEndish(topLevelType)) {\n        nativeEvent.changedTouches.forEach(recordTouchEnd);\n        touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n        if (touchHistory.numberActiveTouches === 1) {\n          for (var i = 0; i < touchBank.length; i++) {\n            var touchTrackToCheck = touchBank[i];\n\n            if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n              touchHistory.indexOfSingleActiveTouch = i;\n              break;\n            }\n          }\n\n          {\n            var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n            if (activeRecord == null || !activeRecord.touchActive) {\n              error('Cannot find single active touch.');\n            }\n          }\n        }\n      }\n    },\n    touchHistory: touchHistory\n  };\n  /**\n   * Accumulates items that must not be null or undefined.\n   *\n   * This is used to conserve memory by avoiding array allocations.\n   *\n   * @return {*|array<*>} An accumulation of items.\n   */\n\n  function accumulate(current, next) {\n    if (!(next != null)) {\n      {\n        throw Error(\"accumulate(...): Accumulated items must not be null or undefined.\");\n      }\n    }\n\n    if (current == null) {\n      return next;\n    } // Both are not empty. Warning: Never call x.concat(y) when you are not\n    // certain that x is an Array (x could be a string with concat method).\n\n\n    if (Array.isArray(current)) {\n      return current.concat(next);\n    }\n\n    if (Array.isArray(next)) {\n      return [current].concat(next);\n    }\n\n    return [current, next];\n  }\n  /**\n   * Instance of element that should respond to touch/move types of interactions,\n   * as indicated explicitly by relevant callbacks.\n   */\n\n\n  var responderInst = null;\n  /**\n   * Count of current touches. A textInput should become responder iff the\n   * selection changes while there is a touch on the screen.\n   */\n\n  var trackedTouchCount = 0;\n\n  var changeResponder = function (nextResponderInst, blockHostResponder) {\n    var oldResponderInst = responderInst;\n    responderInst = nextResponderInst;\n\n    if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n      ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n    }\n  };\n\n  var eventTypes = {\n    /**\n     * On a `touchStart`/`mouseDown`, is it desired that this element become the\n     * responder?\n     */\n    startShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onStartShouldSetResponder',\n        captured: 'onStartShouldSetResponderCapture'\n      },\n      dependencies: startDependencies\n    },\n\n    /**\n     * On a `scroll`, is it desired that this element become the responder? This\n     * is usually not needed, but should be used to retroactively infer that a\n     * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n     * a touch start will be immediately followed by a scroll event if the view is\n     * currently scrolling.\n     *\n     * TODO: This shouldn't bubble.\n     */\n    scrollShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onScrollShouldSetResponder',\n        captured: 'onScrollShouldSetResponderCapture'\n      },\n      dependencies: [TOP_SCROLL]\n    },\n\n    /**\n     * On text selection change, should this element become the responder? This\n     * is needed for text inputs or other views with native selection, so the\n     * JS view can claim the responder.\n     *\n     * TODO: This shouldn't bubble.\n     */\n    selectionChangeShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onSelectionChangeShouldSetResponder',\n        captured: 'onSelectionChangeShouldSetResponderCapture'\n      },\n      dependencies: [TOP_SELECTION_CHANGE]\n    },\n\n    /**\n     * On a `touchMove`/`mouseMove`, is it desired that this element become the\n     * responder?\n     */\n    moveShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onMoveShouldSetResponder',\n        captured: 'onMoveShouldSetResponderCapture'\n      },\n      dependencies: moveDependencies\n    },\n\n    /**\n     * Direct responder events dispatched directly to responder. Do not bubble.\n     */\n    responderStart: {\n      registrationName: 'onResponderStart',\n      dependencies: startDependencies\n    },\n    responderMove: {\n      registrationName: 'onResponderMove',\n      dependencies: moveDependencies\n    },\n    responderEnd: {\n      registrationName: 'onResponderEnd',\n      dependencies: endDependencies\n    },\n    responderRelease: {\n      registrationName: 'onResponderRelease',\n      dependencies: endDependencies\n    },\n    responderTerminationRequest: {\n      registrationName: 'onResponderTerminationRequest',\n      dependencies: []\n    },\n    responderGrant: {\n      registrationName: 'onResponderGrant',\n      dependencies: []\n    },\n    responderReject: {\n      registrationName: 'onResponderReject',\n      dependencies: []\n    },\n    responderTerminate: {\n      registrationName: 'onResponderTerminate',\n      dependencies: []\n    }\n  };\n  /**\n   *\n   * Responder System:\n   * ----------------\n   *\n   * - A global, solitary \"interaction lock\" on a view.\n   * - If a node becomes the responder, it should convey visual feedback\n   *   immediately to indicate so, either by highlighting or moving accordingly.\n   * - To be the responder means, that touches are exclusively important to that\n   *   responder view, and no other view.\n   * - While touches are still occurring, the responder lock can be transferred to\n   *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n   *   the current responder).\n   *\n   * Responder being granted:\n   * ------------------------\n   *\n   * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n   * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n   *   the \"appropriate place\".\n   * - If nothing is currently the responder, the \"appropriate place\" is the\n   *   initiating event's `targetID`.\n   * - If something *is* already the responder, the \"appropriate place\" is the\n   *   first common ancestor of the event target and the current `responderInst`.\n   * - Some negotiation happens: See the timing diagram below.\n   * - Scrolled views automatically become responder. The reasoning is that a\n   *   platform scroll view that isn't built on top of the responder system has\n   *   began scrolling, and the active responder must now be notified that the\n   *   interaction is no longer locked to it - the system has taken over.\n   *\n   * - Responder being released:\n   *   As soon as no more touches that *started* inside of descendants of the\n   *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n   *   current responder, and the responder lock is released.\n   *\n   * TODO:\n   * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n   *   determines if the responder lock should remain.\n   * - If a view shouldn't \"remain\" the responder, any active touches should by\n   *   default be considered \"dead\" and do not influence future negotiations or\n   *   bubble paths. It should be as if those touches do not exist.\n   * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n   *  after one out of many touches ended. For translate-y, usually the view\n   *  doesn't wish to \"remain\" responder after one of many touches end.\n   * - Consider building this on top of a `stopPropagation` model similar to\n   *   `W3C` events.\n   * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n   *   not `onResponderTerminationRequest` returns `true` or `false`.\n   *\n   */\n\n  /*                                             Negotiation Performed\n                                               +-----------------------+\n                                              /                         \\\n  Process low level events to    +     Current Responder      +   wantsResponderID\n  determine who to perform negot-|   (if any exists at all)   |\n  iation/transition              | Otherwise just pass through|\n  -------------------------------+----------------------------+------------------+\n  Bubble to find first ID        |                            |\n  to return true:wantsResponderID|                            |\n                                 |                            |\n       +-------------+           |                            |\n       | onTouchStart|           |                            |\n       +------+------+     none  |                            |\n              |            return|                            |\n  +-----------v-------------+true| +------------------------+ |\n  |onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n  +-----------+-------------+    | +------------------------+ |          |\n              |                  |                            | +--------+-------+\n              | returned true for|       false:REJECT +-------->|onResponderReject\n              | wantsResponderID |                    |       | +----------------+\n              | (now attempt     | +------------------+-----+ |\n              |  handoff)        | |   onResponder          | |\n              +------------------->|      TerminationRequest| |\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |         true:GRANT +-------->|onResponderGrant|\n                                 |                            | +--------+-------+\n                                 | +------------------------+ |          |\n                                 | |   onResponderTerminate |<-----------+\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |                    +-------->|onResponderStart|\n                                 |                            | +----------------+\n  Bubble to find first ID        |                            |\n  to return true:wantsResponderID|                            |\n                                 |                            |\n       +-------------+           |                            |\n       | onTouchMove |           |                            |\n       +------+------+     none  |                            |\n              |            return|                            |\n  +-----------v-------------+true| +------------------------+ |\n  |onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n  +-----------+-------------+    | +------------------------+ |          |\n              |                  |                            | +--------+-------+\n              | returned true for|       false:REJECT +-------->|onResponderRejec|\n              | wantsResponderID |                    |       | +----------------+\n              | (now attempt     | +------------------+-----+ |\n              |  handoff)        | |   onResponder          | |\n              +------------------->|      TerminationRequest| |\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |         true:GRANT +-------->|onResponderGrant|\n                                 |                            | +--------+-------+\n                                 | +------------------------+ |          |\n                                 | |   onResponderTerminate |<-----------+\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |                    +-------->|onResponderMove |\n                                 |                            | +----------------+\n                                 |                            |\n                                 |                            |\n        Some active touch started|                            |\n        inside current responder | +------------------------+ |\n        +------------------------->|      onResponderEnd    | |\n        |                        | +------------------------+ |\n    +---+---------+              |                            |\n    | onTouchEnd  |              |                            |\n    +---+---------+              |                            |\n        |                        | +------------------------+ |\n        +------------------------->|     onResponderEnd     | |\n        No active touches started| +-----------+------------+ |\n        inside current responder |             |              |\n                                 |             v              |\n                                 | +------------------------+ |\n                                 | |    onResponderRelease  | |\n                                 | +------------------------+ |\n                                 |                            |\n                                 +                            + */\n\n  /**\n   * A note about event ordering in the `EventPluginRegistry`.\n   *\n   * Suppose plugins are injected in the following order:\n   *\n   * `[R, S, C]`\n   *\n   * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n   * `onClick` etc) and `R` is `ResponderEventPlugin`.\n   *\n   * \"Deferred-Dispatched Events\":\n   *\n   * - The current event plugin system will traverse the list of injected plugins,\n   *   in order, and extract events by collecting the plugin's return value of\n   *   `extractEvents()`.\n   * - These events that are returned from `extractEvents` are \"deferred\n   *   dispatched events\".\n   * - When returned from `extractEvents`, deferred-dispatched events contain an\n   *   \"accumulation\" of deferred dispatches.\n   * - These deferred dispatches are accumulated/collected before they are\n   *   returned, but processed at a later time by the `EventPluginRegistry` (hence the\n   *   name deferred).\n   *\n   * In the process of returning their deferred-dispatched events, event plugins\n   * themselves can dispatch events on-demand without returning them from\n   * `extractEvents`. Plugins might want to do this, so that they can use event\n   * dispatching as a tool that helps them decide which events should be extracted\n   * in the first place.\n   *\n   * \"On-Demand-Dispatched Events\":\n   *\n   * - On-demand-dispatched events are not returned from `extractEvents`.\n   * - On-demand-dispatched events are dispatched during the process of returning\n   *   the deferred-dispatched events.\n   * - They should not have side effects.\n   * - They should be avoided, and/or eventually be replaced with another\n   *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n   *   extraction.\n   *\n   * Therefore, the sequence of event dispatches becomes:\n   *\n   * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n   * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n   * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n   * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n   * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n   * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n   *\n   * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n   * on-demand dispatch returns `true` (and some other details are satisfied) the\n   * `onResponderGrant` deferred dispatched event is returned from\n   * `extractEvents`. The sequence of dispatch executions in this case\n   * will appear as follows:\n   *\n   * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n   * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)\n   * - `touchStart`              (`EventPluginRegistry` dispatches as usual)\n   * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)\n   */\n\n  function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.\n\n    var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n    // (deepest ID) if it happens to be the current responder. The reasoning:\n    // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n    // the responder.\n\n    var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n    var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n    shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n    if (skipOverBubbleShouldSetFrom) {\n      accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n    } else {\n      accumulateTwoPhaseDispatches(shouldSetEvent);\n    }\n\n    var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n    if (!shouldSetEvent.isPersistent()) {\n      shouldSetEvent.constructor.release(shouldSetEvent);\n    }\n\n    if (!wantsResponderInst || wantsResponderInst === responderInst) {\n      return null;\n    }\n\n    var extracted;\n    var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n    grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(grantEvent);\n    var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n    if (responderInst) {\n      var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n      terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminationRequestEvent);\n      var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n      if (!terminationRequestEvent.isPersistent()) {\n        terminationRequestEvent.constructor.release(terminationRequestEvent);\n      }\n\n      if (shouldSwitch) {\n        var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n        terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminateEvent);\n        extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      } else {\n        var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n        rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(rejectEvent);\n        extracted = accumulate(extracted, rejectEvent);\n      }\n    } else {\n      extracted = accumulate(extracted, grantEvent);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    }\n\n    return extracted;\n  }\n  /**\n   * A transfer is a negotiation between a currently set responder and the next\n   * element to claim responder status. Any start event could trigger a transfer\n   * of responderInst. Any move event could trigger a transfer.\n   *\n   * @param {string} topLevelType Record from `BrowserEventConstants`.\n   * @return {boolean} True if a transfer of responder could possibly occur.\n   */\n\n\n  function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n    return topLevelInst && ( // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n  }\n  /**\n   * Returns whether or not this touch end event makes it such that there are no\n   * longer any touches that started inside of the current `responderInst`.\n   *\n   * @param {NativeEvent} nativeEvent Native touch end event.\n   * @return {boolean} Whether or not this touch end event ends the responder.\n   */\n\n\n  function noResponderTouches(nativeEvent) {\n    var touches = nativeEvent.touches;\n\n    if (!touches || touches.length === 0) {\n      return true;\n    }\n\n    for (var i = 0; i < touches.length; i++) {\n      var activeTouch = touches[i];\n      var target = activeTouch.target;\n\n      if (target !== null && target !== undefined && target !== 0) {\n        // Is the original touch location inside of the current responder?\n        var targetInst = getInstanceFromNode(target);\n\n        if (isAncestor(responderInst, targetInst)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  var ResponderEventPlugin = {\n    /* For unit testing only */\n    _getResponder: function () {\n      return responderInst;\n    },\n    eventTypes: eventTypes,\n\n    /**\n     * We must be resilient to `targetInst` being `null` on `touchMove` or\n     * `touchEnd`. On certain platforms, this means that a native scroll has\n     * assumed control and the original touch targets are destroyed.\n     */\n    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n      if (isStartish(topLevelType)) {\n        trackedTouchCount += 1;\n      } else if (isEndish(topLevelType)) {\n        if (trackedTouchCount >= 0) {\n          trackedTouchCount -= 1;\n        } else {\n          {\n            warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n          }\n          return null;\n        }\n      }\n\n      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n      var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null; // Responder may or may not have transferred on a new touch start/move.\n      // Regardless, whoever is the responder after any potential transfer, we\n      // direct all touch start/move/ends to them in the form of\n      // `onResponderMove/Start/End`. These will be called for *every* additional\n      // finger that move/start/end, dispatched directly to whoever is the\n      // current responder at that moment, until the responder is \"released\".\n      //\n      // These multiple individual change touch events are are always bookended\n      // by `onResponderGrant`, and one of\n      // (`onResponderRelease/onResponderTerminate`).\n\n      var isResponderTouchStart = responderInst && isStartish(topLevelType);\n      var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n      var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n      var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n      if (incrementalTouch) {\n        var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n        gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(gesture);\n        extracted = accumulate(extracted, gesture);\n      }\n\n      var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n      var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n      var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n      if (finalTouch) {\n        var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n        finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(finalEvent);\n        extracted = accumulate(extracted, finalEvent);\n        changeResponder(null);\n      }\n\n      return extracted;\n    },\n    GlobalResponderHandler: null,\n    injection: {\n      /**\n       * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n       * Object that handles any change in responder. Use this to inject\n       * integration with an existing touch handling system etc.\n       */\n      injectGlobalResponderHandler: function (GlobalResponderHandler) {\n        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n      }\n    }\n  }; // Keep in sync with ReactDOM.js, ReactTestUtils.js, and ReactTestUtilsAct.js:\n\n  var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events,\n      getInstanceFromNode$1 = _ReactDOM$__SECRET_IN[0],\n      getNodeFromInstance$1 = _ReactDOM$__SECRET_IN[1],\n      getFiberCurrentPropsFromNode$1 = _ReactDOM$__SECRET_IN[2],\n      injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n  setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\n  var ReactDOMUnstableNativeDependencies = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ResponderEventPlugin: ResponderEventPlugin,\n    ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n    injectEventPluginsByName: injectEventPluginsByName\n  });\n  var unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n  return unstableNativeDependencies;\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/react-dom/umd/react-dom-unstable-native-dependencies.development.js"],"names":["global","factory","exports","module","require","define","amd","self","ReactDOMUnstableNativeDependencies","ReactDOM","React","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","hasOwnProperty","ReactCurrentDispatcher","current","ReactCurrentBatchConfig","suspense","warn","format","_len","arguments","length","args","Array","_key","printWarning","error","_len2","_key2","level","hasExistingStack","indexOf","ReactDebugCurrentFrame","stack","getStackAddendum","concat","argsWithFormat","map","item","unshift","Function","prototype","apply","call","console","argIndex","message","replace","Error","x","window","dispatchEvent","document","createEvent","fakeNode","createElement","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","validateEventDispatches","event","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatchesInOrderStopAtTrueImpl","i","isPropagationStopped","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","currentTarget","res","hasDispatches","HostComponent","getParent","inst","return","tag","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","push","isInteractive","shouldPreventMouseEvent","name","type","props","disabled","getListener","registrationName","listener","stateNode","accumulateInto","next","forEachAccumulated","arr","cb","scope","forEach","listenerAtPhase","propagationPhase","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","ReactInternals","_assign","assign","EVENT_POOL_SIZE","EventInterface","target","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","nativeEvent","nativeEventTarget","preventDefault","stopPropagation","isDefaultPrevented","Interface","constructor","propName","normalize","returnValue","cancelBubble","persist","isPersistent","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","getVal","isFunction","configurable","set","get","val","action","result","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","release","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","TOP_MOUSE_DOWN","TOP_MOUSE_MOVE","TOP_MOUSE_UP","isStartish","topLevelType","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes","startShouldSetResponder","bubbled","captured","dependencies","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","undefined","_getResponder","extractEvents","eventSystemFlags","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injection","injectGlobalResponderHandler","_ReactDOM$__SECRET_IN","Events","getInstanceFromNode$1","getNodeFromInstance$1","getFiberCurrentPropsFromNode$1","injectEventPluginsByName","freeze","__proto__","unstableNativeDependencies"],"mappings":"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","sourcesContent":["/** @license React v16.13.1\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react-dom'), require('react')) :\n  typeof define === 'function' && define.amd ? define(['react-dom', 'react'], factory) :\n  (global = global || self, global.ReactDOMUnstableNativeDependencies = factory(global.ReactDOM, global.React));\n}(this, (function (ReactDOM, React) { 'use strict';\n\n  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.\n  // Current owner and dispatcher used to share the same ref,\n  // but PR #14548 split them out to better support the react-debug-tools package.\n\n  if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n    ReactSharedInternals.ReactCurrentDispatcher = {\n      current: null\n    };\n  }\n\n  if (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n    ReactSharedInternals.ReactCurrentBatchConfig = {\n      suspense: null\n    };\n  }\n\n  // by calls to these methods by a Babel plugin.\n  //\n  // In PROD (or in packages without access to React internals),\n  // they are left as they are instead.\n\n  function warn(format) {\n    {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n  function error(format) {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n\n  function printWarning(level, format, args) {\n    // When changing this logic, you might want to also\n    // update consoleWithStackDev.www.js as well.\n    {\n      var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n\n      if (!hasExistingStack) {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        }\n      }\n\n      var argsWithFormat = args.map(function (item) {\n        return '' + item;\n      }); // Careful: RN currently depends on this prefix\n\n      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n      // breaks IE9: https://github.com/facebook/react/issues/13610\n      // eslint-disable-next-line react-internal/no-production-logging\n\n      Function.prototype.apply.call(console[level], console, argsWithFormat);\n\n      try {\n        // --- Welcome to debugging React ---\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        var argIndex = 0;\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n        throw new Error(message);\n      } catch (x) {}\n    }\n  }\n\n  {\n    // In DEV mode, we swap out invokeGuardedCallback for a special version\n    // that plays more nicely with the browser's DevTools. The idea is to preserve\n    // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n    // functions in invokeGuardedCallback, and the production version of\n    // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n    // like caught exceptions, and the DevTools won't pause unless the developer\n    // takes the extra step of enabling pause on caught exceptions. This is\n    // unintuitive, though, because even though React has caught the error, from\n    // the developer's perspective, the error is uncaught.\n    //\n    // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n    // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n    // DOM node, and call the user-provided callback from inside an event handler\n    // for that fake event. If the callback throws, the error is \"captured\" using\n    // a global event handler. But because the error happens in a different\n    // event loop context, it does not interrupt the normal program flow.\n    // Effectively, this gives us try-catch behavior without actually using\n    // try-catch. Neat!\n    // Check that the browser supports the APIs we need to implement our special\n    // DEV version of invokeGuardedCallback\n    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n      var fakeNode = document.createElement('react');\n    }\n  }\n\n  var getFiberCurrentPropsFromNode = null;\n  var getInstanceFromNode = null;\n  var getNodeFromInstance = null;\n  function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n    getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n    getInstanceFromNode = getInstanceFromNodeImpl;\n    getNodeFromInstance = getNodeFromInstanceImpl;\n\n    {\n      if (!getNodeFromInstance || !getInstanceFromNode) {\n        error('EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n      }\n    }\n  }\n  var validateEventDispatches;\n\n  {\n    validateEventDispatches = function (event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      var listenersIsArr = Array.isArray(dispatchListeners);\n      var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n      var instancesIsArr = Array.isArray(dispatchInstances);\n      var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n      if (instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {\n        error('EventPluginUtils: Invalid `event`.');\n      }\n    };\n  }\n  /**\n   * Standard/simple iteration through an event's collected dispatches, but stops\n   * at the first dispatch execution returning true, and returns that id.\n   *\n   * @return {?string} id of the first dispatch execution who's listener returns\n   * true, or null if no listener returned true.\n   */\n\n  function executeDispatchesInOrderStopAtTrueImpl(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    {\n      validateEventDispatches(event);\n    }\n\n    if (Array.isArray(dispatchListeners)) {\n      for (var i = 0; i < dispatchListeners.length; i++) {\n        if (event.isPropagationStopped()) {\n          break;\n        } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n        if (dispatchListeners[i](event, dispatchInstances[i])) {\n          return dispatchInstances[i];\n        }\n      }\n    } else if (dispatchListeners) {\n      if (dispatchListeners(event, dispatchInstances)) {\n        return dispatchInstances;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @see executeDispatchesInOrderStopAtTrueImpl\n   */\n\n\n  function executeDispatchesInOrderStopAtTrue(event) {\n    var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n    event._dispatchInstances = null;\n    event._dispatchListeners = null;\n    return ret;\n  }\n  /**\n   * Execution of a \"direct\" dispatch - there must be at most one dispatch\n   * accumulated on the event or it is considered an error. It doesn't really make\n   * sense for an event with multiple dispatches (bubbled) to keep track of the\n   * return values at each dispatch execution, but it does tend to make sense when\n   * dealing with \"direct\" dispatches.\n   *\n   * @return {*} The return value of executing the single dispatch.\n   */\n\n  function executeDirectDispatch(event) {\n    {\n      validateEventDispatches(event);\n    }\n\n    var dispatchListener = event._dispatchListeners;\n    var dispatchInstance = event._dispatchInstances;\n\n    if (!!Array.isArray(dispatchListener)) {\n      {\n        throw Error( \"executeDirectDispatch(...): Invalid `event`.\" );\n      }\n    }\n\n    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n    var res = dispatchListener ? dispatchListener(event) : null;\n    event.currentTarget = null;\n    event._dispatchListeners = null;\n    event._dispatchInstances = null;\n    return res;\n  }\n  /**\n   * @param {SyntheticEvent} event\n   * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n   */\n\n  function hasDispatches(event) {\n    return !!event._dispatchListeners;\n  }\n\n  var HostComponent = 5;\n\n  function getParent(inst) {\n    do {\n      inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n      // That is depending on if we want nested subtrees (layers) to bubble\n      // events to their parent. We could also go through parentNode on the\n      // host node but that wouldn't work for React Native and doesn't let us\n      // do the portal feature.\n    } while (inst && inst.tag !== HostComponent);\n\n    if (inst) {\n      return inst;\n    }\n\n    return null;\n  }\n  /**\n   * Return the lowest common ancestor of A and B, or null if they are in\n   * different trees.\n   */\n\n\n  function getLowestCommonAncestor(instA, instB) {\n    var depthA = 0;\n\n    for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n      depthA++;\n    }\n\n    var depthB = 0;\n\n    for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n      depthB++;\n    } // If A is deeper, crawl up.\n\n\n    while (depthA - depthB > 0) {\n      instA = getParent(instA);\n      depthA--;\n    } // If B is deeper, crawl up.\n\n\n    while (depthB - depthA > 0) {\n      instB = getParent(instB);\n      depthB--;\n    } // Walk in lockstep until we find a match.\n\n\n    var depth = depthA;\n\n    while (depth--) {\n      if (instA === instB || instA === instB.alternate) {\n        return instA;\n      }\n\n      instA = getParent(instA);\n      instB = getParent(instB);\n    }\n\n    return null;\n  }\n  /**\n   * Return if A is an ancestor of B.\n   */\n\n  function isAncestor(instA, instB) {\n    while (instB) {\n      if (instA === instB || instA === instB.alternate) {\n        return true;\n      }\n\n      instB = getParent(instB);\n    }\n\n    return false;\n  }\n  /**\n   * Return the parent instance of the passed-in instance.\n   */\n\n  function getParentInstance(inst) {\n    return getParent(inst);\n  }\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   */\n\n  function traverseTwoPhase(inst, fn, arg) {\n    var path = [];\n\n    while (inst) {\n      path.push(inst);\n      inst = getParent(inst);\n    }\n\n    var i;\n\n    for (i = path.length; i-- > 0;) {\n      fn(path[i], 'captured', arg);\n    }\n\n    for (i = 0; i < path.length; i++) {\n      fn(path[i], 'bubbled', arg);\n    }\n  }\n\n  function isInteractive(tag) {\n    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n  }\n\n  function shouldPreventMouseEvent(name, type, props) {\n    switch (name) {\n      case 'onClick':\n      case 'onClickCapture':\n      case 'onDoubleClick':\n      case 'onDoubleClickCapture':\n      case 'onMouseDown':\n      case 'onMouseDownCapture':\n      case 'onMouseMove':\n      case 'onMouseMoveCapture':\n      case 'onMouseUp':\n      case 'onMouseUpCapture':\n      case 'onMouseEnter':\n        return !!(props.disabled && isInteractive(type));\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * @param {object} inst The instance, which is the source of events.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n\n\n  function getListener(inst, registrationName) {\n    var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n    // live here; needs to be moved to a better place soon\n\n    var stateNode = inst.stateNode;\n\n    if (!stateNode) {\n      // Work in progress (ex: onload events in incremental mode).\n      return null;\n    }\n\n    var props = getFiberCurrentPropsFromNode(stateNode);\n\n    if (!props) {\n      // Work in progress.\n      return null;\n    }\n\n    listener = props[registrationName];\n\n    if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n      return null;\n    }\n\n    if (!(!listener || typeof listener === 'function')) {\n      {\n        throw Error( \"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\" );\n      }\n    }\n\n    return listener;\n  }\n\n  /**\n   * Accumulates items that must not be null or undefined into the first one. This\n   * is used to conserve memory by avoiding array allocations, and thus sacrifices\n   * API cleanness. Since `current` can be null before being passed in and not\n   * null after this function, make sure to assign it back to `current`:\n   *\n   * `a = accumulateInto(a, b);`\n   *\n   * This API should be sparingly used. Try `accumulate` for something cleaner.\n   *\n   * @return {*|array<*>} An accumulation of items.\n   */\n\n  function accumulateInto(current, next) {\n    if (!(next != null)) {\n      {\n        throw Error( \"accumulateInto(...): Accumulated items must not be null or undefined.\" );\n      }\n    }\n\n    if (current == null) {\n      return next;\n    } // Both are not empty. Warning: Never call x.concat(y) when you are not\n    // certain that x is an Array (x could be a string with concat method).\n\n\n    if (Array.isArray(current)) {\n      if (Array.isArray(next)) {\n        current.push.apply(current, next);\n        return current;\n      }\n\n      current.push(next);\n      return current;\n    }\n\n    if (Array.isArray(next)) {\n      // A bit too dangerous to mutate `next`.\n      return [current].concat(next);\n    }\n\n    return [current, next];\n  }\n\n  /**\n   * @param {array} arr an \"accumulation\" of items which is either an Array or\n   * a single item. Useful when paired with the `accumulate` module. This is a\n   * simple utility that allows us to reason about a collection of items, but\n   * handling the case when there is exactly one item (and we do not need to\n   * allocate an array).\n   * @param {function} cb Callback invoked with each element or a collection.\n   * @param {?} [scope] Scope used as `this` in a callback.\n   */\n  function forEachAccumulated(arr, cb, scope) {\n    if (Array.isArray(arr)) {\n      arr.forEach(cb, scope);\n    } else if (arr) {\n      cb.call(scope, arr);\n    }\n  }\n\n  /**\n   * Some event types have a notion of different registration names for different\n   * \"phases\" of propagation. This finds listeners by a given phase.\n   */\n  function listenerAtPhase(inst, event, propagationPhase) {\n    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n    return getListener(inst, registrationName);\n  }\n  /**\n   * A small set of propagation patterns, each of which will accept a small amount\n   * of information, and generate a set of \"dispatch ready event objects\" - which\n   * are sets of events that have already been annotated with a set of dispatched\n   * listener functions/ids. The API is designed this way to discourage these\n   * propagation strategies from actually executing the dispatches, since we\n   * always want to collect the entire set of dispatches before executing even a\n   * single one.\n   */\n\n  /**\n   * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n   * here, allows us to not have to bind or create functions for each event.\n   * Mutating the event's members allows us to not have to create a wrapping\n   * \"dispatch\" object that pairs the event with the listener.\n   */\n\n\n  function accumulateDirectionalDispatches(inst, phase, event) {\n    {\n      if (!inst) {\n        error('Dispatching inst must not be null');\n      }\n    }\n\n    var listener = listenerAtPhase(inst, event, phase);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n  /**\n   * Collect dispatches (must be entirely collected before dispatching - see unit\n   * tests). Lazily allocate the array to conserve memory.  We must loop through\n   * each event and perform the traversal for each one. We cannot perform a\n   * single traversal for the entire collection of events because each event may\n   * have a different target.\n   */\n\n\n  function accumulateTwoPhaseDispatchesSingle(event) {\n    if (event && event.dispatchConfig.phasedRegistrationNames) {\n      traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n    }\n  }\n  /**\n   * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n   */\n\n\n  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n    if (event && event.dispatchConfig.phasedRegistrationNames) {\n      var targetInst = event._targetInst;\n      var parentInst = targetInst ? getParentInstance(targetInst) : null;\n      traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n    }\n  }\n  /**\n   * Accumulates without regard to direction, does not look for phased\n   * registration names. Same as `accumulateDirectDispatchesSingle` but without\n   * requiring that the `dispatchMarker` be the same as the dispatched ID.\n   */\n\n\n  function accumulateDispatches(inst, ignoredDirection, event) {\n    if (inst && event && event.dispatchConfig.registrationName) {\n      var registrationName = event.dispatchConfig.registrationName;\n      var listener = getListener(inst, registrationName);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n  }\n  /**\n   * Accumulates dispatches on an `SyntheticEvent`, but only for the\n   * `dispatchMarker`.\n   * @param {SyntheticEvent} event\n   */\n\n\n  function accumulateDirectDispatchesSingle(event) {\n    if (event && event.dispatchConfig.registrationName) {\n      accumulateDispatches(event._targetInst, null, event);\n    }\n  }\n\n  function accumulateTwoPhaseDispatches(events) {\n    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n  }\n  function accumulateTwoPhaseDispatchesSkipTarget(events) {\n    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n  }\n  function accumulateDirectDispatches(events) {\n    forEachAccumulated(events, accumulateDirectDispatchesSingle);\n  }\n\n  var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  var _assign = ReactInternals.assign;\n\n  var EVENT_POOL_SIZE = 10;\n  /**\n   * @interface Event\n   * @see http://www.w3.org/TR/DOM-Level-3-Events/\n   */\n\n  var EventInterface = {\n    type: null,\n    target: null,\n    // currentTarget is set when dispatching; no use in copying it here\n    currentTarget: function () {\n      return null;\n    },\n    eventPhase: null,\n    bubbles: null,\n    cancelable: null,\n    timeStamp: function (event) {\n      return event.timeStamp || Date.now();\n    },\n    defaultPrevented: null,\n    isTrusted: null\n  };\n\n  function functionThatReturnsTrue() {\n    return true;\n  }\n\n  function functionThatReturnsFalse() {\n    return false;\n  }\n  /**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   *\n   * @param {object} dispatchConfig Configuration used to dispatch this event.\n   * @param {*} targetInst Marker identifying the event target.\n   * @param {object} nativeEvent Native browser event.\n   * @param {DOMEventTarget} nativeEventTarget Target node.\n   */\n\n\n  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n    {\n      // these have a getter/setter for warnings\n      delete this.nativeEvent;\n      delete this.preventDefault;\n      delete this.stopPropagation;\n      delete this.isDefaultPrevented;\n      delete this.isPropagationStopped;\n    }\n\n    this.dispatchConfig = dispatchConfig;\n    this._targetInst = targetInst;\n    this.nativeEvent = nativeEvent;\n    var Interface = this.constructor.Interface;\n\n    for (var propName in Interface) {\n      if (!Interface.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      {\n        delete this[propName]; // this has a getter/setter for warnings\n      }\n\n      var normalize = Interface[propName];\n\n      if (normalize) {\n        this[propName] = normalize(nativeEvent);\n      } else {\n        if (propName === 'target') {\n          this.target = nativeEventTarget;\n        } else {\n          this[propName] = nativeEvent[propName];\n        }\n      }\n    }\n\n    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n    if (defaultPrevented) {\n      this.isDefaultPrevented = functionThatReturnsTrue;\n    } else {\n      this.isDefaultPrevented = functionThatReturnsFalse;\n    }\n\n    this.isPropagationStopped = functionThatReturnsFalse;\n    return this;\n  }\n\n  _assign(SyntheticEvent.prototype, {\n    preventDefault: function () {\n      this.defaultPrevented = true;\n      var event = this.nativeEvent;\n\n      if (!event) {\n        return;\n      }\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      } else if (typeof event.returnValue !== 'unknown') {\n        event.returnValue = false;\n      }\n\n      this.isDefaultPrevented = functionThatReturnsTrue;\n    },\n    stopPropagation: function () {\n      var event = this.nativeEvent;\n\n      if (!event) {\n        return;\n      }\n\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      } else if (typeof event.cancelBubble !== 'unknown') {\n        // The ChangeEventPlugin registers a \"propertychange\" event for\n        // IE. This event does not support bubbling or cancelling, and\n        // any references to cancelBubble throw \"Member not found\".  A\n        // typeof check of \"unknown\" circumvents this issue (and is also\n        // IE specific).\n        event.cancelBubble = true;\n      }\n\n      this.isPropagationStopped = functionThatReturnsTrue;\n    },\n\n    /**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */\n    persist: function () {\n      this.isPersistent = functionThatReturnsTrue;\n    },\n\n    /**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */\n    isPersistent: functionThatReturnsFalse,\n\n    /**\n     * `PooledClass` looks for `destructor` on each instance it releases.\n     */\n    destructor: function () {\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        {\n          Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n        }\n      }\n\n      this.dispatchConfig = null;\n      this._targetInst = null;\n      this.nativeEvent = null;\n      this.isDefaultPrevented = functionThatReturnsFalse;\n      this.isPropagationStopped = functionThatReturnsFalse;\n      this._dispatchListeners = null;\n      this._dispatchInstances = null;\n\n      {\n        Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n        Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n        Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n        Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n        Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n      }\n    }\n  });\n\n  SyntheticEvent.Interface = EventInterface;\n  /**\n   * Helper to reduce boilerplate when creating subclasses.\n   */\n\n  SyntheticEvent.extend = function (Interface) {\n    var Super = this;\n\n    var E = function () {};\n\n    E.prototype = Super.prototype;\n    var prototype = new E();\n\n    function Class() {\n      return Super.apply(this, arguments);\n    }\n\n    _assign(prototype, Class.prototype);\n\n    Class.prototype = prototype;\n    Class.prototype.constructor = Class;\n    Class.Interface = _assign({}, Super.Interface, Interface);\n    Class.extend = Super.extend;\n    addEventPoolingTo(Class);\n    return Class;\n  };\n\n  addEventPoolingTo(SyntheticEvent);\n  /**\n   * Helper to nullify syntheticEvent instance properties when destructing\n   *\n   * @param {String} propName\n   * @param {?object} getVal\n   * @return {object} defineProperty object\n   */\n\n  function getPooledWarningPropertyDefinition(propName, getVal) {\n    var isFunction = typeof getVal === 'function';\n    return {\n      configurable: true,\n      set: set,\n      get: get\n    };\n\n    function set(val) {\n      var action = isFunction ? 'setting the method' : 'setting the property';\n      warn(action, 'This is effectively a no-op');\n      return val;\n    }\n\n    function get() {\n      var action = isFunction ? 'accessing the method' : 'accessing the property';\n      var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n      warn(action, result);\n      return getVal;\n    }\n\n    function warn(action, result) {\n      {\n        error(\"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n      }\n    }\n  }\n\n  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n    var EventConstructor = this;\n\n    if (EventConstructor.eventPool.length) {\n      var instance = EventConstructor.eventPool.pop();\n      EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n      return instance;\n    }\n\n    return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n  }\n\n  function releasePooledEvent(event) {\n    var EventConstructor = this;\n\n    if (!(event instanceof EventConstructor)) {\n      {\n        throw Error( \"Trying to release an event instance into a pool of a different type.\" );\n      }\n    }\n\n    event.destructor();\n\n    if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n      EventConstructor.eventPool.push(event);\n    }\n  }\n\n  function addEventPoolingTo(EventConstructor) {\n    EventConstructor.eventPool = [];\n    EventConstructor.getPooled = getPooledEvent;\n    EventConstructor.release = releasePooledEvent;\n  }\n\n  /**\n   * `touchHistory` isn't actually on the native event, but putting it in the\n   * interface will ensure that it is cleaned up when pooled/destroyed. The\n   * `ResponderEventPlugin` will populate it appropriately.\n   */\n\n  var ResponderSyntheticEvent = SyntheticEvent.extend({\n    touchHistory: function (nativeEvent) {\n      return null; // Actually doesn't even look at the native event.\n    }\n  });\n\n  // Note: ideally these would be imported from DOMTopLevelEventTypes,\n  // but our build system currently doesn't let us do that from a fork.\n  var TOP_TOUCH_START = 'touchstart';\n  var TOP_TOUCH_MOVE = 'touchmove';\n  var TOP_TOUCH_END = 'touchend';\n  var TOP_TOUCH_CANCEL = 'touchcancel';\n  var TOP_SCROLL = 'scroll';\n  var TOP_SELECTION_CHANGE = 'selectionchange';\n  var TOP_MOUSE_DOWN = 'mousedown';\n  var TOP_MOUSE_MOVE = 'mousemove';\n  var TOP_MOUSE_UP = 'mouseup';\n  function isStartish(topLevelType) {\n    return topLevelType === TOP_TOUCH_START || topLevelType === TOP_MOUSE_DOWN;\n  }\n  function isMoveish(topLevelType) {\n    return topLevelType === TOP_TOUCH_MOVE || topLevelType === TOP_MOUSE_MOVE;\n  }\n  function isEndish(topLevelType) {\n    return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL || topLevelType === TOP_MOUSE_UP;\n  }\n  var startDependencies = [TOP_TOUCH_START, TOP_MOUSE_DOWN];\n  var moveDependencies = [TOP_TOUCH_MOVE, TOP_MOUSE_MOVE];\n  var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_MOUSE_UP];\n\n  /**\n   * Tracks the position and time of each active touch by `touch.identifier`. We\n   * should typically only see IDs in the range of 1-20 because IDs get recycled\n   * when touches end and start again.\n   */\n\n  var MAX_TOUCH_BANK = 20;\n  var touchBank = [];\n  var touchHistory = {\n    touchBank: touchBank,\n    numberActiveTouches: 0,\n    // If there is only one active touch, we remember its location. This prevents\n    // us having to loop through all of the touches all the time in the most\n    // common case.\n    indexOfSingleActiveTouch: -1,\n    mostRecentTimeStamp: 0\n  };\n\n  function timestampForTouch(touch) {\n    // The legacy internal implementation provides \"timeStamp\", which has been\n    // renamed to \"timestamp\". Let both work for now while we iron it out\n    // TODO (evv): rename timeStamp to timestamp in internal code\n    return touch.timeStamp || touch.timestamp;\n  }\n  /**\n   * TODO: Instead of making gestures recompute filtered velocity, we could\n   * include a built in velocity computation that can be reused globally.\n   */\n\n\n  function createTouchRecord(touch) {\n    return {\n      touchActive: true,\n      startPageX: touch.pageX,\n      startPageY: touch.pageY,\n      startTimeStamp: timestampForTouch(touch),\n      currentPageX: touch.pageX,\n      currentPageY: touch.pageY,\n      currentTimeStamp: timestampForTouch(touch),\n      previousPageX: touch.pageX,\n      previousPageY: touch.pageY,\n      previousTimeStamp: timestampForTouch(touch)\n    };\n  }\n\n  function resetTouchRecord(touchRecord, touch) {\n    touchRecord.touchActive = true;\n    touchRecord.startPageX = touch.pageX;\n    touchRecord.startPageY = touch.pageY;\n    touchRecord.startTimeStamp = timestampForTouch(touch);\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchRecord.previousPageX = touch.pageX;\n    touchRecord.previousPageY = touch.pageY;\n    touchRecord.previousTimeStamp = timestampForTouch(touch);\n  }\n\n  function getTouchIdentifier(_ref) {\n    var identifier = _ref.identifier;\n\n    if (!(identifier != null)) {\n      {\n        throw Error( \"Touch object is missing identifier.\" );\n      }\n    }\n\n    {\n      if (identifier > MAX_TOUCH_BANK) {\n        error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n      }\n    }\n\n    return identifier;\n  }\n\n  function recordTouchStart(touch) {\n    var identifier = getTouchIdentifier(touch);\n    var touchRecord = touchBank[identifier];\n\n    if (touchRecord) {\n      resetTouchRecord(touchRecord, touch);\n    } else {\n      touchBank[identifier] = createTouchRecord(touch);\n    }\n\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  }\n\n  function recordTouchMove(touch) {\n    var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n    if (touchRecord) {\n      touchRecord.touchActive = true;\n      touchRecord.previousPageX = touchRecord.currentPageX;\n      touchRecord.previousPageY = touchRecord.currentPageY;\n      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    } else {\n      {\n        warn('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n  }\n\n  function recordTouchEnd(touch) {\n    var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n    if (touchRecord) {\n      touchRecord.touchActive = false;\n      touchRecord.previousPageX = touchRecord.currentPageX;\n      touchRecord.previousPageY = touchRecord.currentPageY;\n      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    } else {\n      {\n        warn('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n' + 'Touch Bank: %s', printTouch(touch), printTouchBank());\n      }\n    }\n  }\n\n  function printTouch(touch) {\n    return JSON.stringify({\n      identifier: touch.identifier,\n      pageX: touch.pageX,\n      pageY: touch.pageY,\n      timestamp: timestampForTouch(touch)\n    });\n  }\n\n  function printTouchBank() {\n    var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n    if (touchBank.length > MAX_TOUCH_BANK) {\n      printed += ' (original size: ' + touchBank.length + ')';\n    }\n\n    return printed;\n  }\n\n  var ResponderTouchHistoryStore = {\n    recordTouchTrack: function (topLevelType, nativeEvent) {\n      if (isMoveish(topLevelType)) {\n        nativeEvent.changedTouches.forEach(recordTouchMove);\n      } else if (isStartish(topLevelType)) {\n        nativeEvent.changedTouches.forEach(recordTouchStart);\n        touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n        if (touchHistory.numberActiveTouches === 1) {\n          touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n        }\n      } else if (isEndish(topLevelType)) {\n        nativeEvent.changedTouches.forEach(recordTouchEnd);\n        touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n        if (touchHistory.numberActiveTouches === 1) {\n          for (var i = 0; i < touchBank.length; i++) {\n            var touchTrackToCheck = touchBank[i];\n\n            if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n              touchHistory.indexOfSingleActiveTouch = i;\n              break;\n            }\n          }\n\n          {\n            var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n            if (activeRecord == null || !activeRecord.touchActive) {\n              error('Cannot find single active touch.');\n            }\n          }\n        }\n      }\n    },\n    touchHistory: touchHistory\n  };\n\n  /**\n   * Accumulates items that must not be null or undefined.\n   *\n   * This is used to conserve memory by avoiding array allocations.\n   *\n   * @return {*|array<*>} An accumulation of items.\n   */\n\n  function accumulate(current, next) {\n    if (!(next != null)) {\n      {\n        throw Error( \"accumulate(...): Accumulated items must not be null or undefined.\" );\n      }\n    }\n\n    if (current == null) {\n      return next;\n    } // Both are not empty. Warning: Never call x.concat(y) when you are not\n    // certain that x is an Array (x could be a string with concat method).\n\n\n    if (Array.isArray(current)) {\n      return current.concat(next);\n    }\n\n    if (Array.isArray(next)) {\n      return [current].concat(next);\n    }\n\n    return [current, next];\n  }\n\n  /**\n   * Instance of element that should respond to touch/move types of interactions,\n   * as indicated explicitly by relevant callbacks.\n   */\n\n  var responderInst = null;\n  /**\n   * Count of current touches. A textInput should become responder iff the\n   * selection changes while there is a touch on the screen.\n   */\n\n  var trackedTouchCount = 0;\n\n  var changeResponder = function (nextResponderInst, blockHostResponder) {\n    var oldResponderInst = responderInst;\n    responderInst = nextResponderInst;\n\n    if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n      ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n    }\n  };\n\n  var eventTypes = {\n    /**\n     * On a `touchStart`/`mouseDown`, is it desired that this element become the\n     * responder?\n     */\n    startShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onStartShouldSetResponder',\n        captured: 'onStartShouldSetResponderCapture'\n      },\n      dependencies: startDependencies\n    },\n\n    /**\n     * On a `scroll`, is it desired that this element become the responder? This\n     * is usually not needed, but should be used to retroactively infer that a\n     * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n     * a touch start will be immediately followed by a scroll event if the view is\n     * currently scrolling.\n     *\n     * TODO: This shouldn't bubble.\n     */\n    scrollShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onScrollShouldSetResponder',\n        captured: 'onScrollShouldSetResponderCapture'\n      },\n      dependencies: [TOP_SCROLL]\n    },\n\n    /**\n     * On text selection change, should this element become the responder? This\n     * is needed for text inputs or other views with native selection, so the\n     * JS view can claim the responder.\n     *\n     * TODO: This shouldn't bubble.\n     */\n    selectionChangeShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onSelectionChangeShouldSetResponder',\n        captured: 'onSelectionChangeShouldSetResponderCapture'\n      },\n      dependencies: [TOP_SELECTION_CHANGE]\n    },\n\n    /**\n     * On a `touchMove`/`mouseMove`, is it desired that this element become the\n     * responder?\n     */\n    moveShouldSetResponder: {\n      phasedRegistrationNames: {\n        bubbled: 'onMoveShouldSetResponder',\n        captured: 'onMoveShouldSetResponderCapture'\n      },\n      dependencies: moveDependencies\n    },\n\n    /**\n     * Direct responder events dispatched directly to responder. Do not bubble.\n     */\n    responderStart: {\n      registrationName: 'onResponderStart',\n      dependencies: startDependencies\n    },\n    responderMove: {\n      registrationName: 'onResponderMove',\n      dependencies: moveDependencies\n    },\n    responderEnd: {\n      registrationName: 'onResponderEnd',\n      dependencies: endDependencies\n    },\n    responderRelease: {\n      registrationName: 'onResponderRelease',\n      dependencies: endDependencies\n    },\n    responderTerminationRequest: {\n      registrationName: 'onResponderTerminationRequest',\n      dependencies: []\n    },\n    responderGrant: {\n      registrationName: 'onResponderGrant',\n      dependencies: []\n    },\n    responderReject: {\n      registrationName: 'onResponderReject',\n      dependencies: []\n    },\n    responderTerminate: {\n      registrationName: 'onResponderTerminate',\n      dependencies: []\n    }\n  };\n  /**\n   *\n   * Responder System:\n   * ----------------\n   *\n   * - A global, solitary \"interaction lock\" on a view.\n   * - If a node becomes the responder, it should convey visual feedback\n   *   immediately to indicate so, either by highlighting or moving accordingly.\n   * - To be the responder means, that touches are exclusively important to that\n   *   responder view, and no other view.\n   * - While touches are still occurring, the responder lock can be transferred to\n   *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n   *   the current responder).\n   *\n   * Responder being granted:\n   * ------------------------\n   *\n   * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n   * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n   *   the \"appropriate place\".\n   * - If nothing is currently the responder, the \"appropriate place\" is the\n   *   initiating event's `targetID`.\n   * - If something *is* already the responder, the \"appropriate place\" is the\n   *   first common ancestor of the event target and the current `responderInst`.\n   * - Some negotiation happens: See the timing diagram below.\n   * - Scrolled views automatically become responder. The reasoning is that a\n   *   platform scroll view that isn't built on top of the responder system has\n   *   began scrolling, and the active responder must now be notified that the\n   *   interaction is no longer locked to it - the system has taken over.\n   *\n   * - Responder being released:\n   *   As soon as no more touches that *started* inside of descendants of the\n   *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n   *   current responder, and the responder lock is released.\n   *\n   * TODO:\n   * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n   *   determines if the responder lock should remain.\n   * - If a view shouldn't \"remain\" the responder, any active touches should by\n   *   default be considered \"dead\" and do not influence future negotiations or\n   *   bubble paths. It should be as if those touches do not exist.\n   * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n   *  after one out of many touches ended. For translate-y, usually the view\n   *  doesn't wish to \"remain\" responder after one of many touches end.\n   * - Consider building this on top of a `stopPropagation` model similar to\n   *   `W3C` events.\n   * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n   *   not `onResponderTerminationRequest` returns `true` or `false`.\n   *\n   */\n\n  /*                                             Negotiation Performed\n                                               +-----------------------+\n                                              /                         \\\n  Process low level events to    +     Current Responder      +   wantsResponderID\n  determine who to perform negot-|   (if any exists at all)   |\n  iation/transition              | Otherwise just pass through|\n  -------------------------------+----------------------------+------------------+\n  Bubble to find first ID        |                            |\n  to return true:wantsResponderID|                            |\n                                 |                            |\n       +-------------+           |                            |\n       | onTouchStart|           |                            |\n       +------+------+     none  |                            |\n              |            return|                            |\n  +-----------v-------------+true| +------------------------+ |\n  |onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n  +-----------+-------------+    | +------------------------+ |          |\n              |                  |                            | +--------+-------+\n              | returned true for|       false:REJECT +-------->|onResponderReject\n              | wantsResponderID |                    |       | +----------------+\n              | (now attempt     | +------------------+-----+ |\n              |  handoff)        | |   onResponder          | |\n              +------------------->|      TerminationRequest| |\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |         true:GRANT +-------->|onResponderGrant|\n                                 |                            | +--------+-------+\n                                 | +------------------------+ |          |\n                                 | |   onResponderTerminate |<-----------+\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |                    +-------->|onResponderStart|\n                                 |                            | +----------------+\n  Bubble to find first ID        |                            |\n  to return true:wantsResponderID|                            |\n                                 |                            |\n       +-------------+           |                            |\n       | onTouchMove |           |                            |\n       +------+------+     none  |                            |\n              |            return|                            |\n  +-----------v-------------+true| +------------------------+ |\n  |onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n  +-----------+-------------+    | +------------------------+ |          |\n              |                  |                            | +--------+-------+\n              | returned true for|       false:REJECT +-------->|onResponderRejec|\n              | wantsResponderID |                    |       | +----------------+\n              | (now attempt     | +------------------+-----+ |\n              |  handoff)        | |   onResponder          | |\n              +------------------->|      TerminationRequest| |\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |         true:GRANT +-------->|onResponderGrant|\n                                 |                            | +--------+-------+\n                                 | +------------------------+ |          |\n                                 | |   onResponderTerminate |<-----------+\n                                 | +------------------+-----+ |\n                                 |                    |       | +----------------+\n                                 |                    +-------->|onResponderMove |\n                                 |                            | +----------------+\n                                 |                            |\n                                 |                            |\n        Some active touch started|                            |\n        inside current responder | +------------------------+ |\n        +------------------------->|      onResponderEnd    | |\n        |                        | +------------------------+ |\n    +---+---------+              |                            |\n    | onTouchEnd  |              |                            |\n    +---+---------+              |                            |\n        |                        | +------------------------+ |\n        +------------------------->|     onResponderEnd     | |\n        No active touches started| +-----------+------------+ |\n        inside current responder |             |              |\n                                 |             v              |\n                                 | +------------------------+ |\n                                 | |    onResponderRelease  | |\n                                 | +------------------------+ |\n                                 |                            |\n                                 +                            + */\n\n  /**\n   * A note about event ordering in the `EventPluginRegistry`.\n   *\n   * Suppose plugins are injected in the following order:\n   *\n   * `[R, S, C]`\n   *\n   * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n   * `onClick` etc) and `R` is `ResponderEventPlugin`.\n   *\n   * \"Deferred-Dispatched Events\":\n   *\n   * - The current event plugin system will traverse the list of injected plugins,\n   *   in order, and extract events by collecting the plugin's return value of\n   *   `extractEvents()`.\n   * - These events that are returned from `extractEvents` are \"deferred\n   *   dispatched events\".\n   * - When returned from `extractEvents`, deferred-dispatched events contain an\n   *   \"accumulation\" of deferred dispatches.\n   * - These deferred dispatches are accumulated/collected before they are\n   *   returned, but processed at a later time by the `EventPluginRegistry` (hence the\n   *   name deferred).\n   *\n   * In the process of returning their deferred-dispatched events, event plugins\n   * themselves can dispatch events on-demand without returning them from\n   * `extractEvents`. Plugins might want to do this, so that they can use event\n   * dispatching as a tool that helps them decide which events should be extracted\n   * in the first place.\n   *\n   * \"On-Demand-Dispatched Events\":\n   *\n   * - On-demand-dispatched events are not returned from `extractEvents`.\n   * - On-demand-dispatched events are dispatched during the process of returning\n   *   the deferred-dispatched events.\n   * - They should not have side effects.\n   * - They should be avoided, and/or eventually be replaced with another\n   *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n   *   extraction.\n   *\n   * Therefore, the sequence of event dispatches becomes:\n   *\n   * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n   * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n   * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n   * - `R`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n   * - `S`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n   * - `C`s extracted events (if any)   (dispatched by `EventPluginRegistry`)\n   *\n   * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n   * on-demand dispatch returns `true` (and some other details are satisfied) the\n   * `onResponderGrant` deferred dispatched event is returned from\n   * `extractEvents`. The sequence of dispatch executions in this case\n   * will appear as follows:\n   *\n   * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n   * - `touchStartCapture`       (`EventPluginRegistry` dispatches as usual)\n   * - `touchStart`              (`EventPluginRegistry` dispatches as usual)\n   * - `responderGrant/Reject`   (`EventPluginRegistry` dispatches as usual)\n   */\n\n  function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder; // TODO: stop one short of the current responder.\n\n    var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst); // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n    // (deepest ID) if it happens to be the current responder. The reasoning:\n    // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n    // the responder.\n\n    var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n    var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n    shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n    if (skipOverBubbleShouldSetFrom) {\n      accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n    } else {\n      accumulateTwoPhaseDispatches(shouldSetEvent);\n    }\n\n    var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n    if (!shouldSetEvent.isPersistent()) {\n      shouldSetEvent.constructor.release(shouldSetEvent);\n    }\n\n    if (!wantsResponderInst || wantsResponderInst === responderInst) {\n      return null;\n    }\n\n    var extracted;\n    var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n    grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(grantEvent);\n    var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n    if (responderInst) {\n      var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n      terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminationRequestEvent);\n      var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n      if (!terminationRequestEvent.isPersistent()) {\n        terminationRequestEvent.constructor.release(terminationRequestEvent);\n      }\n\n      if (shouldSwitch) {\n        var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n        terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminateEvent);\n        extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      } else {\n        var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n        rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(rejectEvent);\n        extracted = accumulate(extracted, rejectEvent);\n      }\n    } else {\n      extracted = accumulate(extracted, grantEvent);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    }\n\n    return extracted;\n  }\n  /**\n   * A transfer is a negotiation between a currently set responder and the next\n   * element to claim responder status. Any start event could trigger a transfer\n   * of responderInst. Any move event could trigger a transfer.\n   *\n   * @param {string} topLevelType Record from `BrowserEventConstants`.\n   * @return {boolean} True if a transfer of responder could possibly occur.\n   */\n\n\n  function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n    return topLevelInst && ( // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n  }\n  /**\n   * Returns whether or not this touch end event makes it such that there are no\n   * longer any touches that started inside of the current `responderInst`.\n   *\n   * @param {NativeEvent} nativeEvent Native touch end event.\n   * @return {boolean} Whether or not this touch end event ends the responder.\n   */\n\n\n  function noResponderTouches(nativeEvent) {\n    var touches = nativeEvent.touches;\n\n    if (!touches || touches.length === 0) {\n      return true;\n    }\n\n    for (var i = 0; i < touches.length; i++) {\n      var activeTouch = touches[i];\n      var target = activeTouch.target;\n\n      if (target !== null && target !== undefined && target !== 0) {\n        // Is the original touch location inside of the current responder?\n        var targetInst = getInstanceFromNode(target);\n\n        if (isAncestor(responderInst, targetInst)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  var ResponderEventPlugin = {\n    /* For unit testing only */\n    _getResponder: function () {\n      return responderInst;\n    },\n    eventTypes: eventTypes,\n\n    /**\n     * We must be resilient to `targetInst` being `null` on `touchMove` or\n     * `touchEnd`. On certain platforms, this means that a native scroll has\n     * assumed control and the original touch targets are destroyed.\n     */\n    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n      if (isStartish(topLevelType)) {\n        trackedTouchCount += 1;\n      } else if (isEndish(topLevelType)) {\n        if (trackedTouchCount >= 0) {\n          trackedTouchCount -= 1;\n        } else {\n          {\n            warn('Ended a touch event which was not counted in `trackedTouchCount`.');\n          }\n\n          return null;\n        }\n      }\n\n      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n      var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null; // Responder may or may not have transferred on a new touch start/move.\n      // Regardless, whoever is the responder after any potential transfer, we\n      // direct all touch start/move/ends to them in the form of\n      // `onResponderMove/Start/End`. These will be called for *every* additional\n      // finger that move/start/end, dispatched directly to whoever is the\n      // current responder at that moment, until the responder is \"released\".\n      //\n      // These multiple individual change touch events are are always bookended\n      // by `onResponderGrant`, and one of\n      // (`onResponderRelease/onResponderTerminate`).\n\n      var isResponderTouchStart = responderInst && isStartish(topLevelType);\n      var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n      var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n      var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n      if (incrementalTouch) {\n        var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n        gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(gesture);\n        extracted = accumulate(extracted, gesture);\n      }\n\n      var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n      var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n      var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n\n      if (finalTouch) {\n        var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n        finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(finalEvent);\n        extracted = accumulate(extracted, finalEvent);\n        changeResponder(null);\n      }\n\n      return extracted;\n    },\n    GlobalResponderHandler: null,\n    injection: {\n      /**\n       * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n       * Object that handles any change in responder. Use this to inject\n       * integration with an existing touch handling system etc.\n       */\n      injectGlobalResponderHandler: function (GlobalResponderHandler) {\n        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n      }\n    }\n  };\n\n  // Keep in sync with ReactDOM.js, ReactTestUtils.js, and ReactTestUtilsAct.js:\n\n  var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events,\n      getInstanceFromNode$1 = _ReactDOM$__SECRET_IN[0],\n      getNodeFromInstance$1 = _ReactDOM$__SECRET_IN[1],\n      getFiberCurrentPropsFromNode$1 = _ReactDOM$__SECRET_IN[2],\n      injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n  setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\n\n  var ReactDOMUnstableNativeDependencies = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ResponderEventPlugin: ResponderEventPlugin,\n    ResponderTouchHistoryStore: ResponderTouchHistoryStore,\n    injectEventPluginsByName: injectEventPluginsByName\n  });\n\n  var unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n\n  return unstableNativeDependencies;\n\n})));\n"]},"metadata":{},"sourceType":"script"}