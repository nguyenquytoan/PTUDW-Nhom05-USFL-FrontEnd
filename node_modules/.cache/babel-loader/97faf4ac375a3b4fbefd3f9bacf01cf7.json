{"ast":null,"code":"'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function _transform() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function _stripBom() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _cli = require('./cli');\n\nvar _args = require('./cli/args');\n\nvar _helpers = require('./helpers');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\n\nconst NODE_MODULES = _path().default.sep + 'node_modules' + _path().default.sep;\n\nconst getModuleNameMapper = config => {\n  if (Array.isArray(config.moduleNameMapper) && config.moduleNameMapper.length) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex)\n    }));\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\n/* eslint-disable-next-line no-redeclare */\n\nclass Runtime {\n  constructor(config, environment, resolver, cacheFS, coverageOptions) {\n    _defineProperty(this, '_cacheFS', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_coverageOptions', void 0);\n\n    _defineProperty(this, '_currentlyExecutingModulePath', void 0);\n\n    _defineProperty(this, '_environment', void 0);\n\n    _defineProperty(this, '_explicitShouldMock', void 0);\n\n    _defineProperty(this, '_internalModuleRegistry', void 0);\n\n    _defineProperty(this, '_isCurrentlyExecutingManualMock', void 0);\n\n    _defineProperty(this, '_mockFactories', void 0);\n\n    _defineProperty(this, '_mockMetaDataCache', void 0);\n\n    _defineProperty(this, '_mockRegistry', void 0);\n\n    _defineProperty(this, '_isolatedMockRegistry', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_isolatedModuleRegistry', void 0);\n\n    _defineProperty(this, '_moduleRegistry', void 0);\n\n    _defineProperty(this, '_needsCoverageMapped', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_shouldAutoMock', void 0);\n\n    _defineProperty(this, '_shouldMockModuleCache', void 0);\n\n    _defineProperty(this, '_shouldUnmockTransitiveDependenciesCache', void 0);\n\n    _defineProperty(this, '_sourceMapRegistry', void 0);\n\n    _defineProperty(this, '_scriptTransformer', void 0);\n\n    _defineProperty(this, '_transitiveShouldMock', void 0);\n\n    _defineProperty(this, '_unmockList', void 0);\n\n    _defineProperty(this, '_virtualMocks', void 0);\n\n    this._cacheFS = cacheFS || Object.create(null);\n    this._config = config;\n    this._coverageOptions = coverageOptions || {\n      changedFiles: undefined,\n      collectCoverage: false,\n      collectCoverageFrom: [],\n      collectCoverageOnlyFrom: null\n    };\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = Object.create(null);\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mockFactories = Object.create(null);\n    this._mockRegistry = new Map(); // during setup, this cannot be null (and it's fine to explode if it is)\n\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._needsCoverageMapped = new Set();\n    this._resolver = resolver;\n    this._scriptTransformer = new (_transform().ScriptTransformer)(config);\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = Object.create(null);\n    this._virtualMocks = Object.create(null);\n    this._mockMetaDataCache = Object.create(null);\n    this._shouldMockModuleCache = Object.create(null);\n    this._shouldUnmockTransitiveDependenciesCache = Object.create(null);\n    this._transitiveShouldMock = Object.create(null);\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(config.unmockedModulePathPatterns.join('|'));\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    if (config.automock) {\n      config.setupFiles.forEach(filePath => {\n        if (filePath && filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(this._virtualMocks, filePath);\n\n          this._transitiveShouldMock[moduleID] = false;\n        }\n      });\n    }\n\n    this.resetModules();\n\n    if (config.setupFiles.length) {\n      for (let i = 0; i < config.setupFiles.length; i++) {\n        this.requireModule(config.setupFiles[i]);\n      }\n    }\n  } // TODO: Make this `static shouldInstrument = shouldInstrument;` after https://github.com/facebook/jest/issues/7846\n\n\n  static shouldInstrument(filename, options, config) {\n    return (0, _transform().shouldInstrument)(filename, options, config);\n  }\n\n  static createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    return instance.build().then(hasteMap => ({\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n    }), error => {\n      throw error;\n    });\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [...config.modulePathIgnorePatterns, ...(options && options.watch ? config.watchPathIgnorePatterns : []), config.cacheDirectory.startsWith(config.rootDir + _path().default.sep) && config.cacheDirectory].filter(Boolean);\n    const ignorePattern = ignorePatternParts.length > 0 ? new RegExp(ignorePatternParts.join('|')) : undefined;\n    return new (_jestHasteMap().default)({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options && options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      extensions: [_jestSnapshot().default.EXTENSION].concat(config.moduleFileExtensions),\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      ignorePattern,\n      maxWorkers: options && options.maxWorkers || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(_path().default.sep + '__mocks__' + _path().default.sep),\n      name: config.name,\n      platforms: config.haste.platforms || ['ios', 'android'],\n      providesModuleNodeModules: config.haste.providesModuleNodeModules,\n      resetCache: options && options.resetCache,\n      retainAllFiles: false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options && options.watchman,\n      watch: options && options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve().default)(moduleMap, {\n      browser: config.browser,\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => '.' + extension),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static runCLI(args, info) {\n    return (0, _cli.run)(args, info);\n  }\n\n  static getCLIOptions() {\n    return _args.options;\n  }\n\n  requireModule(from, moduleName, options, isRequireActual) {\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock = moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if ((!options || !options.isInternalModule) && !isRequireActual && !moduleResource && manualMock && manualMock !== this._isCurrentlyExecutingManualMock && this._explicitShouldMock[moduleID] !== false) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(moduleName);\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let moduleRegistry;\n\n    if (!options || !options.isInternalModule) {\n      if (this._moduleRegistry.get(modulePath) || !this._isolatedModuleRegistry) {\n        moduleRegistry = this._moduleRegistry;\n      } else {\n        moduleRegistry = this._isolatedModuleRegistry;\n      }\n    } else {\n      moduleRegistry = this._internalModuleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    this._loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry);\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    return this.requireModule(from, to, {\n      isInternalModule: true\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    if (this._isolatedMockRegistry && this._isolatedMockRegistry.get(moduleID)) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.get(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (moduleID in this._mockFactories) {\n      const module = this._mockFactories[moduleID]();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath;\n\n    if (manualMockOrStub) {\n      modulePath = this._resolveModule(from, manualMockOrStub);\n    } else {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let isManualMock = manualMockOrStub && !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = _path().default.dirname(modulePath);\n\n      const moduleFileName = _path().default.basename(modulePath);\n\n      const potentialManualMock = _path().default.join(moduleDir, '__mocks__', moduleFileName);\n\n      if (_gracefulFs().default.existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false\n      };\n\n      this._loadModule(localModule, from, moduleName, modulePath, undefined, mockRegistry);\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry) {\n    if (_path().default.extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(_gracefulFs().default.readFileSync(modulePath, 'utf8'));\n\n      const transformedFile = this._scriptTransformer.transformJson(modulePath, this._getFullTransformationOptions(options), text);\n\n      localModule.exports = this._environment.global.JSON.parse(transformedFile);\n    } else if (_path().default.extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions(options) {\n    return _objectSpread({}, options, {\n      changedFiles: this._coverageOptions.changedFiles,\n      collectCoverage: this._coverageOptions.collectCoverage,\n      collectCoverageFrom: this._coverageOptions.collectCoverageFrom,\n      collectCoverageOnlyFrom: this._coverageOptions.collectCoverageOnlyFrom,\n      extraGlobals: this._config.extraGlobals || []\n    });\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    try {\n      if (this._shouldMock(from, moduleName)) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        const appendedMessage = (0, _helpers.findSiblingsWithFileExtension)(this._config.moduleFileExtensions, from, moduleName);\n\n        if (appendedMessage) {\n          e.message += appendedMessage;\n        }\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error('isolateModules cannot be nested inside another isolateModules.');\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n    fn();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n  }\n\n  resetModules() {\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if ((typeof globalMock === 'object' && globalMock !== null || typeof globalMock === 'function') && globalMock._isMockFunction === true) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(this._environment.global.__coverage__);\n  }\n\n  getSourceMapInfo(coveredFiles) {\n    return Object.keys(this._sourceMapRegistry).reduce((result, sourcePath) => {\n      if (coveredFiles.has(sourcePath) && this._needsCoverageMapped.has(sourcePath) && _gracefulFs().default.existsSync(this._sourceMapRegistry[sourcePath])) {\n        result[sourcePath] = this._sourceMapRegistry[sourcePath];\n      }\n\n      return result;\n    }, {});\n  }\n\n  getSourceMaps() {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks[mockPath] = true;\n    }\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    this._explicitShouldMock[moduleID] = true;\n    this._mockFactories[moduleID] = mockFactory;\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  _resolveModule(from, to) {\n    return to ? this._resolver.resolveModule(from, to) : from;\n  }\n\n  _requireResolve(from, moduleName, options = {}) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve must be a string. Received null or undefined.');\n    }\n\n    const paths = options.paths;\n\n    if (paths) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          const p = _step.value;\n\n          const absolutePath = _path().default.resolve(from, '..', p);\n\n          const module = this._resolver.resolveModuleFromDirIfExists(absolutePath, moduleName, // required to also resolve files without leading './' directly in the path\n          {\n            paths: [absolutePath]\n          });\n\n          if (module) {\n            return module;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      throw new Error(`Cannot resolve module '${moduleName}' from paths ['${paths.join(\"', '\")}'] from ${from}`);\n    }\n\n    try {\n      return this._resolveModule(from, moduleName);\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve.paths must be a string. Received null or undefined.');\n    }\n\n    if (!moduleName.length) {\n      throw new Error('The first argument to require.resolve.paths must not be the empty string.');\n    }\n\n    if (moduleName[0] === '.') {\n      return [_path().default.resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(_path().default.resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const filename = localModule.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n\n    const dirname = _path().default.dirname(filename);\n\n    localModule.children = [];\n    Object.defineProperty(localModule, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n\n    });\n    localModule.paths = this._resolver.getModulePaths(dirname);\n    Object.defineProperty(localModule, 'require', {\n      value: this._createRequireImplementation(localModule, options)\n    });\n    const extraGlobals = this._config.extraGlobals || [];\n\n    const transformedFile = this._scriptTransformer.transform(filename, this._getFullTransformationOptions(options), this._cacheFS[filename]);\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry[filename] = transformedFile.sourceMapPath;\n\n      if (transformedFile.mapCoverage) {\n        this._needsCoverageMapped.add(filename);\n      }\n    }\n\n    const runScript = this._environment.runScript(transformedFile.script);\n\n    if (runScript === null) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1;\n      return;\n    } //Wrapper\n\n\n    runScript[_transform().ScriptTransformer.EVAL_RESULT_VARIABLE].call(localModule.exports, localModule, // module object\n    localModule.exports, // module exports\n    localModule.require, // require implementation\n    dirname, // __dirname\n    filename, // __filename\n    this._environment.global, // global object\n    this._createJestObjectFor(filename, localModule.require), // jest object\n    ...extraGlobals.map(globalVariable => {\n      if (this._environment.global[globalVariable]) {\n        return this._environment.global[globalVariable];\n      }\n\n      throw new Error(`You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`);\n    }));\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  _requireCoreModule(moduleName) {\n    if (moduleName === 'process') {\n      return this._environment.global.process;\n    }\n\n    return require(moduleName);\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath = this._resolver.resolveStubModuleName(from, moduleName) || this._resolveModule(from, moduleName);\n\n    if (!(modulePath in this._mockMetaDataCache)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache[modulePath] = this._moduleMocker.getMetadata({}) || {}; // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(`Failed to get mock metadata: ${modulePath}\\n\\n` + `See: https://jestjs.io/docs/manual-mocks.html#content`);\n      }\n\n      this._mockMetaDataCache[modulePath] = mockMetadata;\n    }\n\n    return this._moduleMocker.generateFromMetadata(this._mockMetaDataCache[modulePath]);\n  }\n\n  _shouldMock(from, moduleName) {\n    const explicitShouldMock = this._explicitShouldMock;\n\n    const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n    const key = from + _path().default.delimiter + moduleID;\n\n    if (moduleID in explicitShouldMock) {\n      return explicitShouldMock[moduleID];\n    }\n\n    if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache[key]) {\n      return false;\n    }\n\n    if (moduleID in this._shouldMockModuleCache) {\n      return this._shouldMockModuleCache[moduleID];\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveModule(from, moduleName);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache[moduleID] = true;\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache[moduleID] = false;\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n\n    const currentModuleID = this._resolver.getModuleID(this._virtualMocks, from);\n\n    if (this._transitiveShouldMock[currentModuleID] === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock[currentModuleID] === false)) {\n      this._transitiveShouldMock[moduleID] = false;\n      this._shouldUnmockTransitiveDependenciesCache[key] = true;\n      return false;\n    }\n\n    return this._shouldMockModuleCache[moduleID] = true;\n  }\n\n  _createRequireImplementation(from, options) {\n    // TODO: somehow avoid having to type the arguments - they should come from `NodeRequire/LocalModuleRequire.resolve`\n    const resolve = (moduleName, options) => this._requireResolve(from.filename, moduleName, options);\n\n    resolve.paths = moduleName => this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = options && options.isInternalModule ? moduleName => this.requireInternalModule(from.filename, moduleName) : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.cache = Object.create(null);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.requireActual = this.requireActual.bind(this, from.filename);\n    moduleRequire.requireMock = this.requireMock.bind(this, from.filename);\n    moduleRequire.resolve = resolve;\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n\n      get() {\n        let mainModule = from.parent;\n\n        while (mainModule && mainModule.parent && mainModule.id !== mainModule.parent.id) {\n          mainModule = mainModule.parent;\n        }\n\n        return mainModule;\n      }\n\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from, localRequire) {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n      this._explicitShouldMock[moduleID] = false;\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n      this._explicitShouldMock[moduleID] = false;\n      this._transitiveShouldMock[moduleID] = false;\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(this._virtualMocks, from, moduleName);\n\n      this._explicitShouldMock[moduleID] = true;\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const useFakeTimers = () => {\n      _getFakeTimers().useFakeTimers();\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const setTimeout = timeout => {\n      if (this._environment.global.jasmine) {\n        this._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout;\n      } else {\n        // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/24587\n        this._environment.global[testTimeoutSymbol] = timeout;\n      }\n\n      return jestObject;\n    };\n\n    const retryTimes = numTestRetries => {\n      // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/24587\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (!this._environment.fakeTimers) {\n        this._logFormattedReferenceError('You are trying to access a property or method of the Jest environment after it has been torn down.');\n\n        process.exitCode = 1;\n      } // We've logged a user message above, so it doesn't matter if we return `null` here\n\n\n      return this._environment.fakeTimers;\n    };\n\n    const jestObject = {\n      addMatchers: matchers => this._environment.global.jasmine.addMatchers(matchers),\n      advanceTimersByTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps => _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      requireActual: localRequire.requireActual,\n      requireMock: localRequire.requireMock,\n      resetAllMocks,\n      resetModuleRegistry: resetModules,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => _getFakeTimers().runAllImmediates(),\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      runTimersToTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setTimeout,\n      spyOn,\n      unmock,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const originalStack = new ReferenceError(errorMessage).stack.split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n    .filter(line => line.indexOf(__filename) === -1).join('\\n');\n\n    const _separateMessageFromS = (0, _jestMessageUtil().separateMessageFromStack)(originalStack),\n          message = _separateMessageFromS.message,\n          stack = _separateMessageFromS.stack;\n\n    console.error(`\\n${message}\\n` + (0, _jestMessageUtil().formatStackTrace)(stack, this._config, {\n      noStackTrace: false\n    }));\n  }\n\n}\n\n_defineProperty(Runtime, 'ScriptTransformer', void 0);\n\nRuntime.ScriptTransformer = _transform().ScriptTransformer;\nmodule.exports = Runtime;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-runtime/build/index.js"],"names":["_path","data","_interopRequireDefault","require","_jestHasteMap","_jestMessageUtil","_jestResolve","_jestUtil","_jestRegexUtil","_jestSnapshot","_transform","_gracefulFs","_stripBom","_cli","_args","_helpers","obj","__esModule","default","_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","value","defineProperty","configurable","writable","testTimeoutSymbol","Symbol","for","retryTimesSymbol","NODE_MODULES","sep","getModuleNameMapper","config","Array","isArray","moduleNameMapper","map","regex","moduleName","RegExp","unmockRegExpCache","WeakMap","Runtime","constructor","environment","resolver","cacheFS","coverageOptions","_cacheFS","create","_config","_coverageOptions","changedFiles","undefined","collectCoverage","collectCoverageFrom","collectCoverageOnlyFrom","_currentlyExecutingModulePath","_environment","_explicitShouldMock","_internalModuleRegistry","Map","_isCurrentlyExecutingManualMock","_mockFactories","_mockRegistry","_moduleMocker","moduleMocker","_isolatedModuleRegistry","_isolatedMockRegistry","_moduleRegistry","_needsCoverageMapped","Set","_resolver","_scriptTransformer","ScriptTransformer","_shouldAutoMock","automock","_sourceMapRegistry","_virtualMocks","_mockMetaDataCache","_shouldMockModuleCache","_shouldUnmockTransitiveDependenciesCache","_transitiveShouldMock","_unmockList","get","unmockedModulePathPatterns","join","set","setupFiles","filePath","includes","moduleID","getModuleID","resetModules","requireModule","shouldInstrument","filename","options","createContext","createDirectory","cacheDirectory","instance","createHasteMap","console","maxWorkers","resetCache","cache","watch","watchman","build","then","hasteMap","hasteFS","moduleMap","createResolver","error","ignorePatternParts","modulePathIgnorePatterns","watchPathIgnorePatterns","startsWith","rootDir","Boolean","ignorePattern","computeSha1","haste","dependencyExtractor","extensions","EXTENSION","moduleFileExtensions","hasteImplModulePath","mocksPattern","escapePathForRegex","name","platforms","providesModuleNodeModules","retainAllFiles","roots","throwOnModuleCollision","useWatchman","browser","defaultPlatform","extension","hasCoreModules","moduleDirectories","modulePaths","runCLI","args","info","run","getCLIOptions","from","isRequireActual","modulePath","moduleResource","getModule","manualMock","getMockModule","isInternalModule","isCoreModule","_requireCoreModule","_resolveModule","moduleRegistry","module","exports","localModule","children","id","loaded","_loadModule","requireInternalModule","to","requireActual","requireMock","mockRegistry","manualMockOrStub","isManualMock","resolveStubModuleName","moduleDir","dirname","moduleFileName","basename","potentialManualMock","existsSync","_generateMock","extname","text","readFileSync","transformedFile","transformJson","_getFullTransformationOptions","global","JSON","parse","fromPath","_execModule","extraGlobals","requireModuleOrMock","_shouldMock","e","code","appendedMessage","findSiblingsWithFileExtension","message","isolateModules","fn","Error","clear","envGlobal","globalMock","_isMockFunction","mockClear","fakeTimers","clearAllTimers","getAllCoverageInfoCopy","deepCyclicCopy","__coverage__","getSourceMapInfo","coveredFiles","reduce","result","sourcePath","has","getSourceMaps","setMock","mockFactory","virtual","mockPath","getModulePath","restoreAllMocks","resetAllMocks","clearAllMocks","resolveModule","_requireResolve","paths","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","iterator","_step","next","done","p","absolutePath","resolve","resolveModuleFromDirIfExists","err","return","_requireResolvePaths","getModulePaths","lastExecutingModulePath","origCurrExecutingManualMock","_createRequireImplementation","transform","sourceMapPath","mapCoverage","add","runScript","script","_logFormattedReferenceError","process","exitCode","EVAL_RESULT_VARIABLE","call","_createJestObjectFor","globalVariable","getMetadata","origMockRegistry","origModuleRegistry","moduleExports","mockMetadata","generateFromMetadata","explicitShouldMock","delimiter","test","currentModuleID","moduleRequire","bind","mainModule","parent","localRequire","disableAutomock","jestObject","enableAutomock","unmock","deepUnmock","mock","setMockFactory","useFakeTimers","_getFakeTimers","useRealTimers","spyOn","setTimeout","timeout","jasmine","_DEFAULT_TIMEOUT_INTERVAL","retryTimes","numTestRetries","addMatchers","matchers","advanceTimersByTime","msToRun","advanceTimersToNextTimer","steps","autoMockOff","autoMockOn","doMock","dontMock","genMockFromModule","getTimerCount","isMockFunction","resetModuleRegistry","runAllImmediates","runAllTicks","runAllTimers","runOnlyPendingTimers","runTimersToTime","errorMessage","originalStack","ReferenceError","stack","split","line","indexOf","__filename","_separateMessageFromS","separateMessageFromStack","formatStackTrace","noStackTrace"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function _transform() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function _stripBom() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _cli = require('./cli');\n\nvar _args = require('./cli/args');\n\nvar _helpers = require('./helpers');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\n\nconst NODE_MODULES = _path().default.sep + 'node_modules' + _path().default.sep;\n\nconst getModuleNameMapper = config => {\n  if (\n    Array.isArray(config.moduleNameMapper) &&\n    config.moduleNameMapper.length\n  ) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex)\n    }));\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\n/* eslint-disable-next-line no-redeclare */\n\nclass Runtime {\n  constructor(config, environment, resolver, cacheFS, coverageOptions) {\n    _defineProperty(this, '_cacheFS', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_coverageOptions', void 0);\n\n    _defineProperty(this, '_currentlyExecutingModulePath', void 0);\n\n    _defineProperty(this, '_environment', void 0);\n\n    _defineProperty(this, '_explicitShouldMock', void 0);\n\n    _defineProperty(this, '_internalModuleRegistry', void 0);\n\n    _defineProperty(this, '_isCurrentlyExecutingManualMock', void 0);\n\n    _defineProperty(this, '_mockFactories', void 0);\n\n    _defineProperty(this, '_mockMetaDataCache', void 0);\n\n    _defineProperty(this, '_mockRegistry', void 0);\n\n    _defineProperty(this, '_isolatedMockRegistry', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_isolatedModuleRegistry', void 0);\n\n    _defineProperty(this, '_moduleRegistry', void 0);\n\n    _defineProperty(this, '_needsCoverageMapped', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_shouldAutoMock', void 0);\n\n    _defineProperty(this, '_shouldMockModuleCache', void 0);\n\n    _defineProperty(this, '_shouldUnmockTransitiveDependenciesCache', void 0);\n\n    _defineProperty(this, '_sourceMapRegistry', void 0);\n\n    _defineProperty(this, '_scriptTransformer', void 0);\n\n    _defineProperty(this, '_transitiveShouldMock', void 0);\n\n    _defineProperty(this, '_unmockList', void 0);\n\n    _defineProperty(this, '_virtualMocks', void 0);\n\n    this._cacheFS = cacheFS || Object.create(null);\n    this._config = config;\n    this._coverageOptions = coverageOptions || {\n      changedFiles: undefined,\n      collectCoverage: false,\n      collectCoverageFrom: [],\n      collectCoverageOnlyFrom: null\n    };\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = Object.create(null);\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mockFactories = Object.create(null);\n    this._mockRegistry = new Map(); // during setup, this cannot be null (and it's fine to explode if it is)\n\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._needsCoverageMapped = new Set();\n    this._resolver = resolver;\n    this._scriptTransformer = new (_transform()).ScriptTransformer(config);\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = Object.create(null);\n    this._virtualMocks = Object.create(null);\n    this._mockMetaDataCache = Object.create(null);\n    this._shouldMockModuleCache = Object.create(null);\n    this._shouldUnmockTransitiveDependenciesCache = Object.create(null);\n    this._transitiveShouldMock = Object.create(null);\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(\n        config.unmockedModulePathPatterns.join('|')\n      );\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    if (config.automock) {\n      config.setupFiles.forEach(filePath => {\n        if (filePath && filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(\n            this._virtualMocks,\n            filePath\n          );\n\n          this._transitiveShouldMock[moduleID] = false;\n        }\n      });\n    }\n\n    this.resetModules();\n\n    if (config.setupFiles.length) {\n      for (let i = 0; i < config.setupFiles.length; i++) {\n        this.requireModule(config.setupFiles[i]);\n      }\n    }\n  } // TODO: Make this `static shouldInstrument = shouldInstrument;` after https://github.com/facebook/jest/issues/7846\n\n  static shouldInstrument(filename, options, config) {\n    return (0, _transform().shouldInstrument)(filename, options, config);\n  }\n\n  static createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    return instance.build().then(\n      hasteMap => ({\n        config,\n        hasteFS: hasteMap.hasteFS,\n        moduleMap: hasteMap.moduleMap,\n        resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n      }),\n      error => {\n        throw error;\n      }\n    );\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [\n      ...config.modulePathIgnorePatterns,\n      ...(options && options.watch ? config.watchPathIgnorePatterns : []),\n      config.cacheDirectory.startsWith(config.rootDir + _path().default.sep) &&\n        config.cacheDirectory\n    ].filter(Boolean);\n    const ignorePattern =\n      ignorePatternParts.length > 0\n        ? new RegExp(ignorePatternParts.join('|'))\n        : undefined;\n    return new (_jestHasteMap()).default({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options && options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      extensions: [_jestSnapshot().default.EXTENSION].concat(\n        config.moduleFileExtensions\n      ),\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      ignorePattern,\n      maxWorkers: (options && options.maxWorkers) || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(\n        _path().default.sep + '__mocks__' + _path().default.sep\n      ),\n      name: config.name,\n      platforms: config.haste.platforms || ['ios', 'android'],\n      providesModuleNodeModules: config.haste.providesModuleNodeModules,\n      resetCache: options && options.resetCache,\n      retainAllFiles: false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options && options.watchman,\n      watch: options && options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve()).default(moduleMap, {\n      browser: config.browser,\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => '.' + extension),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static runCLI(args, info) {\n    return (0, _cli.run)(args, info);\n  }\n\n  static getCLIOptions() {\n    return _args.options;\n  }\n\n  requireModule(from, moduleName, options, isRequireActual) {\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName\n    );\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock =\n      moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if (\n      (!options || !options.isInternalModule) &&\n      !isRequireActual &&\n      !moduleResource &&\n      manualMock &&\n      manualMock !== this._isCurrentlyExecutingManualMock &&\n      this._explicitShouldMock[moduleID] !== false\n    ) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(moduleName);\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let moduleRegistry;\n\n    if (!options || !options.isInternalModule) {\n      if (\n        this._moduleRegistry.get(modulePath) ||\n        !this._isolatedModuleRegistry\n      ) {\n        moduleRegistry = this._moduleRegistry;\n      } else {\n        moduleRegistry = this._isolatedModuleRegistry;\n      }\n    } else {\n      moduleRegistry = this._internalModuleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    this._loadModule(\n      localModule,\n      from,\n      moduleName,\n      modulePath,\n      options,\n      moduleRegistry\n    );\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    return this.requireModule(from, to, {\n      isInternalModule: true\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName\n    );\n\n    if (\n      this._isolatedMockRegistry &&\n      this._isolatedMockRegistry.get(moduleID)\n    ) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.get(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (moduleID in this._mockFactories) {\n      const module = this._mockFactories[moduleID]();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath;\n\n    if (manualMockOrStub) {\n      modulePath = this._resolveModule(from, manualMockOrStub);\n    } else {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let isManualMock =\n      manualMockOrStub &&\n      !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = _path().default.dirname(modulePath);\n\n      const moduleFileName = _path().default.basename(modulePath);\n\n      const potentialManualMock = _path().default.join(\n        moduleDir,\n        '__mocks__',\n        moduleFileName\n      );\n\n      if (_gracefulFs().default.existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false\n      };\n\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        undefined,\n        mockRegistry\n      );\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(\n    localModule,\n    from,\n    moduleName,\n    modulePath,\n    options,\n    moduleRegistry\n  ) {\n    if (_path().default.extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(\n        _gracefulFs().default.readFileSync(modulePath, 'utf8')\n      );\n\n      const transformedFile = this._scriptTransformer.transformJson(\n        modulePath,\n        this._getFullTransformationOptions(options),\n        text\n      );\n\n      localModule.exports = this._environment.global.JSON.parse(\n        transformedFile\n      );\n    } else if (_path().default.extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions(options) {\n    return _objectSpread({}, options, {\n      changedFiles: this._coverageOptions.changedFiles,\n      collectCoverage: this._coverageOptions.collectCoverage,\n      collectCoverageFrom: this._coverageOptions.collectCoverageFrom,\n      collectCoverageOnlyFrom: this._coverageOptions.collectCoverageOnlyFrom,\n      extraGlobals: this._config.extraGlobals || []\n    });\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    try {\n      if (this._shouldMock(from, moduleName)) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        const appendedMessage = (0, _helpers.findSiblingsWithFileExtension)(\n          this._config.moduleFileExtensions,\n          from,\n          moduleName\n        );\n\n        if (appendedMessage) {\n          e.message += appendedMessage;\n        }\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error(\n        'isolateModules cannot be nested inside another isolateModules.'\n      );\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n    fn();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n  }\n\n  resetModules() {\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if (\n            ((typeof globalMock === 'object' && globalMock !== null) ||\n              typeof globalMock === 'function') &&\n            globalMock._isMockFunction === true\n          ) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(\n      this._environment.global.__coverage__\n    );\n  }\n\n  getSourceMapInfo(coveredFiles) {\n    return Object.keys(this._sourceMapRegistry).reduce((result, sourcePath) => {\n      if (\n        coveredFiles.has(sourcePath) &&\n        this._needsCoverageMapped.has(sourcePath) &&\n        _gracefulFs().default.existsSync(this._sourceMapRegistry[sourcePath])\n      ) {\n        result[sourcePath] = this._sourceMapRegistry[sourcePath];\n      }\n\n      return result;\n    }, {});\n  }\n\n  getSourceMaps() {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options && options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks[mockPath] = true;\n    }\n\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName\n    );\n\n    this._explicitShouldMock[moduleID] = true;\n    this._mockFactories[moduleID] = mockFactory;\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  _resolveModule(from, to) {\n    return to ? this._resolver.resolveModule(from, to) : from;\n  }\n\n  _requireResolve(from, moduleName, options = {}) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve must be a string. Received null or undefined.'\n      );\n    }\n\n    const paths = options.paths;\n\n    if (paths) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (\n          var _iterator = paths[Symbol.iterator](), _step;\n          !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n          _iteratorNormalCompletion = true\n        ) {\n          const p = _step.value;\n\n          const absolutePath = _path().default.resolve(from, '..', p);\n\n          const module = this._resolver.resolveModuleFromDirIfExists(\n            absolutePath,\n            moduleName, // required to also resolve files without leading './' directly in the path\n            {\n              paths: [absolutePath]\n            }\n          );\n\n          if (module) {\n            return module;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      throw new Error(\n        `Cannot resolve module '${moduleName}' from paths ['${paths.join(\n          \"', '\"\n        )}'] from ${from}`\n      );\n    }\n\n    try {\n      return this._resolveModule(from, moduleName);\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve.paths must be a string. Received null or undefined.'\n      );\n    }\n\n    if (!moduleName.length) {\n      throw new Error(\n        'The first argument to require.resolve.paths must not be the empty string.'\n      );\n    }\n\n    if (moduleName[0] === '.') {\n      return [_path().default.resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(_path().default.resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const filename = localModule.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n\n    const dirname = _path().default.dirname(filename);\n\n    localModule.children = [];\n    Object.defineProperty(localModule, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n    });\n    localModule.paths = this._resolver.getModulePaths(dirname);\n    Object.defineProperty(localModule, 'require', {\n      value: this._createRequireImplementation(localModule, options)\n    });\n    const extraGlobals = this._config.extraGlobals || [];\n\n    const transformedFile = this._scriptTransformer.transform(\n      filename,\n      this._getFullTransformationOptions(options),\n      this._cacheFS[filename]\n    );\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry[filename] = transformedFile.sourceMapPath;\n\n      if (transformedFile.mapCoverage) {\n        this._needsCoverageMapped.add(filename);\n      }\n    }\n\n    const runScript = this._environment.runScript(transformedFile.script);\n\n    if (runScript === null) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.'\n      );\n\n      process.exitCode = 1;\n      return;\n    } //Wrapper\n\n    runScript[_transform().ScriptTransformer.EVAL_RESULT_VARIABLE].call(\n      localModule.exports,\n      localModule, // module object\n      localModule.exports, // module exports\n      localModule.require, // require implementation\n      dirname, // __dirname\n      filename, // __filename\n      this._environment.global, // global object\n      this._createJestObjectFor(filename, localModule.require), // jest object\n      ...extraGlobals.map(globalVariable => {\n        if (this._environment.global[globalVariable]) {\n          return this._environment.global[globalVariable];\n        }\n\n        throw new Error(\n          `You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`\n        );\n      })\n    );\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  _requireCoreModule(moduleName) {\n    if (moduleName === 'process') {\n      return this._environment.global.process;\n    }\n\n    return require(moduleName);\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath =\n      this._resolver.resolveStubModuleName(from, moduleName) ||\n      this._resolveModule(from, moduleName);\n\n    if (!(modulePath in this._mockMetaDataCache)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache[modulePath] =\n        this._moduleMocker.getMetadata({}) || {}; // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(\n          `Failed to get mock metadata: ${modulePath}\\n\\n` +\n            `See: https://jestjs.io/docs/manual-mocks.html#content`\n        );\n      }\n\n      this._mockMetaDataCache[modulePath] = mockMetadata;\n    }\n\n    return this._moduleMocker.generateFromMetadata(\n      this._mockMetaDataCache[modulePath]\n    );\n  }\n\n  _shouldMock(from, moduleName) {\n    const explicitShouldMock = this._explicitShouldMock;\n\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName\n    );\n\n    const key = from + _path().default.delimiter + moduleID;\n\n    if (moduleID in explicitShouldMock) {\n      return explicitShouldMock[moduleID];\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache[key]\n    ) {\n      return false;\n    }\n\n    if (moduleID in this._shouldMockModuleCache) {\n      return this._shouldMockModuleCache[moduleID];\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveModule(from, moduleName);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache[moduleID] = true;\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache[moduleID] = false;\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n    const currentModuleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from\n    );\n\n    if (\n      this._transitiveShouldMock[currentModuleID] === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock[currentModuleID] === false))\n    ) {\n      this._transitiveShouldMock[moduleID] = false;\n      this._shouldUnmockTransitiveDependenciesCache[key] = true;\n      return false;\n    }\n\n    return (this._shouldMockModuleCache[moduleID] = true);\n  }\n\n  _createRequireImplementation(from, options) {\n    // TODO: somehow avoid having to type the arguments - they should come from `NodeRequire/LocalModuleRequire.resolve`\n    const resolve = (moduleName, options) =>\n      this._requireResolve(from.filename, moduleName, options);\n\n    resolve.paths = moduleName =>\n      this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire =\n      options && options.isInternalModule\n        ? moduleName => this.requireInternalModule(from.filename, moduleName)\n        : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.cache = Object.create(null);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.requireActual = this.requireActual.bind(this, from.filename);\n    moduleRequire.requireMock = this.requireMock.bind(this, from.filename);\n    moduleRequire.resolve = resolve;\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n\n      get() {\n        let mainModule = from.parent;\n\n        while (\n          mainModule &&\n          mainModule.parent &&\n          mainModule.id !== mainModule.parent.id\n        ) {\n          mainModule = mainModule.parent;\n        }\n\n        return mainModule;\n      }\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from, localRequire) {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName\n      );\n\n      this._explicitShouldMock[moduleID] = false;\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName\n      );\n\n      this._explicitShouldMock[moduleID] = false;\n      this._transitiveShouldMock[moduleID] = false;\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName\n      );\n\n      this._explicitShouldMock[moduleID] = true;\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const useFakeTimers = () => {\n      _getFakeTimers().useFakeTimers();\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const setTimeout = timeout => {\n      if (this._environment.global.jasmine) {\n        this._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout;\n      } else {\n        // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/24587\n        this._environment.global[testTimeoutSymbol] = timeout;\n      }\n\n      return jestObject;\n    };\n\n    const retryTimes = numTestRetries => {\n      // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/24587\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (!this._environment.fakeTimers) {\n        this._logFormattedReferenceError(\n          'You are trying to access a property or method of the Jest environment after it has been torn down.'\n        );\n\n        process.exitCode = 1;\n      } // We've logged a user message above, so it doesn't matter if we return `null` here\n\n      return this._environment.fakeTimers;\n    };\n\n    const jestObject = {\n      addMatchers: matchers =>\n        this._environment.global.jasmine.addMatchers(matchers),\n      advanceTimersByTime: msToRun =>\n        _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps =>\n        _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      requireActual: localRequire.requireActual,\n      requireMock: localRequire.requireMock,\n      resetAllMocks,\n      resetModuleRegistry: resetModules,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => _getFakeTimers().runAllImmediates(),\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      runTimersToTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setTimeout,\n      spyOn,\n      unmock,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const originalStack = new ReferenceError(errorMessage).stack\n      .split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n      .filter(line => line.indexOf(__filename) === -1)\n      .join('\\n');\n\n    const _separateMessageFromS = (0,\n      _jestMessageUtil().separateMessageFromStack)(originalStack),\n      message = _separateMessageFromS.message,\n      stack = _separateMessageFromS.stack;\n\n    console.error(\n      `\\n${message}\\n` +\n        (0, _jestMessageUtil().formatStackTrace)(stack, this._config, {\n          noStackTrace: false\n        })\n    );\n  }\n}\n\n_defineProperty(Runtime, 'ScriptTransformer', void 0);\n\nRuntime.ScriptTransformer = _transform().ScriptTransformer;\nmodule.exports = Runtime;\n"]},"metadata":{},"sourceType":"script"}