{"ast":null,"code":"'use strict';\n\nfunction _worker_threads() {\n  const data = require('worker_threads');\n\n  _worker_threads = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _types() {\n  const data = require('../types');\n\n  _types = function () {\n    return data;\n  };\n\n  return data;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types().CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types().CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types().CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError('Unexpected request from parent process: ' + request[0]);\n  }\n};\n\n_worker_threads().parentPort.on('message', messageListener);\n\nfunction reportSuccess(result) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  _worker_threads().parentPort.postMessage([_types().PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types().PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types().PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  _worker_threads().parentPort.postMessage([type, error.constructor && error.constructor.name, error.message, error.stack, typeof error === 'object' ? { ...error\n  } : error]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  // Clean up open handles so the worker ideally exits gracefully\n  _worker_threads().parentPort.removeListener('message', messageListener);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (result && typeof result.then === 'function') {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/terser-webpack-plugin/node_modules/jest-worker/build/workers/threadChild.js"],"names":["_worker_threads","data","require","_types","file","setupArgs","initialized","messageListener","request","CHILD_MESSAGE_INITIALIZE","init","CHILD_MESSAGE_CALL","call","execMethod","CHILD_MESSAGE_END","end","TypeError","parentPort","on","reportSuccess","result","isMainThread","Error","postMessage","PARENT_MESSAGE_OK","reportClientError","error","reportError","PARENT_MESSAGE_CLIENT_ERROR","reportInitializeError","PARENT_MESSAGE_SETUP_ERROR","type","constructor","name","message","stack","main","teardown","exitProcess","execFunction","removeListener","method","args","fn","__esModule","execHelper","setup","ctx","onResult","onError","apply","err","then"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _worker_threads() {\n  const data = require('worker_threads');\n\n  _worker_threads = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _types() {\n  const data = require('../types');\n\n  _types = function () {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types().CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types().CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types().CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError(\n        'Unexpected request from parent process: ' + request[0]\n      );\n  }\n};\n\n_worker_threads().parentPort.on('message', messageListener);\n\nfunction reportSuccess(result) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  _worker_threads().parentPort.postMessage([\n    _types().PARENT_MESSAGE_OK,\n    result\n  ]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types().PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types().PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (_worker_threads().isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  _worker_threads().parentPort.postMessage([\n    type,\n    error.constructor && error.constructor.name,\n    error.message,\n    error.stack,\n    typeof error === 'object' ? {...error} : error\n  ]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  // Clean up open handles so the worker ideally exits gracefully\n  _worker_threads().parentPort.removeListener('message', messageListener);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (result && typeof result.then === 'function') {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}