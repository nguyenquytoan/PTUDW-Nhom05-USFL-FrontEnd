{"ast":null,"code":"import postcss from 'postcss';\nimport valueParser from 'postcss-values-parser';\nvar index = postcss.plugin('postcss-color-hex-alpha', opts => {\n  // whether to preserve the original hexa\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n  return root => {\n    // for each declaration with a hexa\n    root.walkDecls(decl => {\n      if (hasAlphaHex(decl)) {\n        // replace instances of hexa with rgba()\n        const ast = valueParser(decl.value).parse();\n        walk(ast, node => {\n          if (isAlphaHex(node)) {\n            node.replaceWith(hexa2rgba(node));\n          }\n        }); // conditionally update the declaration\n\n        const modifiedValue = String(ast);\n\n        if (decl.value !== modifiedValue) {\n          if (preserve) {\n            decl.cloneBefore({\n              value: modifiedValue\n            });\n          } else {\n            decl.value = modifiedValue;\n          }\n        }\n      }\n    });\n  };\n}); // match any hexa\n\nconst alphaHexRegExp = /#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)\\b/; // whether a node has a hexa\n\nconst hasAlphaHex = node => alphaHexRegExp.test(node.value); // match an exact hexa\n\n\nconst alphaHexValueRegExp = /^#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)$/; // walk all nodes in a value\n\nconst walk = (node, fn) => {\n  if (Object(node.nodes).length) {\n    node.nodes.slice().forEach(child => {\n      fn(child);\n      walk(child, fn);\n    });\n  }\n}; // decimal precision\n\n\nconst alphaDecimalPrecision = 100000; // match a hexa node\n\nconst isAlphaHex = node => node.type === 'word' && alphaHexValueRegExp.test(node.value);\n\nconst hexa2rgba = node => {\n  // hex is the node value\n  const hex = node.value; // conditionally expand a hex\n\n  const hex8 = `0x${hex.length === 5 ? hex.slice(1).replace(/[0-9A-f]/g, '$&$&') : hex.slice(1)}`; // extract the red, blue, green, and alpha values from the hex\n\n  const _ref = [parseInt(hex8.slice(2, 4), 16), parseInt(hex8.slice(4, 6), 16), parseInt(hex8.slice(6, 8), 16), Math.round(parseInt(hex8.slice(8, 10), 16) / 255 * alphaDecimalPrecision) / alphaDecimalPrecision],\n        r = _ref[0],\n        g = _ref[1],\n        b = _ref[2],\n        a = _ref[3]; // return a new rgba function, preserving the whitespace of the original node\n\n  const rgbaFunc = valueParser.func({\n    value: 'rgba',\n    raws: Object.assign({}, node.raws)\n  });\n  rgbaFunc.append(valueParser.paren({\n    value: '('\n  }));\n  rgbaFunc.append(valueParser.number({\n    value: r\n  }));\n  rgbaFunc.append(valueParser.comma({\n    value: ','\n  }));\n  rgbaFunc.append(valueParser.number({\n    value: g\n  }));\n  rgbaFunc.append(valueParser.comma({\n    value: ','\n  }));\n  rgbaFunc.append(valueParser.number({\n    value: b\n  }));\n  rgbaFunc.append(valueParser.comma({\n    value: ','\n  }));\n  rgbaFunc.append(valueParser.number({\n    value: a\n  }));\n  rgbaFunc.append(valueParser.paren({\n    value: ')'\n  }));\n  return rgbaFunc;\n};\n\nexport default index;","map":{"version":3,"sources":["index.js"],"names":["opts","preserve","Object","Boolean","root","decl","hasAlphaHex","ast","valueParser","walk","node","isAlphaHex","hexa2rgba","modifiedValue","String","value","alphaHexRegExp","alphaHexValueRegExp","child","fn","alphaDecimalPrecision","hex","hex8","r","g","b","a","parseInt","Math","rgbaFunc","raws"],"mappings":"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","sourcesContent":["import postcss from 'postcss';\nimport valueParser from 'postcss-values-parser';\n\nexport default postcss.plugin('postcss-color-hex-alpha', opts => {\n\t// whether to preserve the original hexa\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n\n\treturn root => {\n\t\t// for each declaration with a hexa\n\t\troot.walkDecls(decl => {\n\t\t\tif (hasAlphaHex(decl)) {\n\t\t\t\t// replace instances of hexa with rgba()\n\t\t\t\tconst ast = valueParser(decl.value).parse();\n\n\t\t\t\twalk(ast, node => {\n\t\t\t\t\tif (isAlphaHex(node)) {\n\t\t\t\t\t\tnode.replaceWith(hexa2rgba(node));\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// conditionally update the declaration\n\t\t\t\tconst modifiedValue = String(ast);\n\n\t\t\t\tif (decl.value !== modifiedValue) {\n\t\t\t\t\tif (preserve) {\n\t\t\t\t\t\tdecl.cloneBefore({ value: modifiedValue });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdecl.value = modifiedValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\n// match any hexa\nconst alphaHexRegExp = /#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)\\b/;\n\n// whether a node has a hexa\nconst hasAlphaHex = node => alphaHexRegExp.test(node.value);\n\n// match an exact hexa\nconst alphaHexValueRegExp = /^#([0-9A-Fa-f]{4}(?:[0-9A-Fa-f]{4})?)$/;\n\n// walk all nodes in a value\nconst walk = (node, fn) => {\n\tif (Object(node.nodes).length) {\n\t\tnode.nodes.slice().forEach(child => {\n\t\t\tfn(child);\n\n\t\t\twalk(child, fn);\n\t\t});\n\t}\n};\n\n// decimal precision\nconst alphaDecimalPrecision = 100000;\n\n// match a hexa node\nconst isAlphaHex = node => node.type === 'word' && alphaHexValueRegExp.test(node.value);\n\nconst hexa2rgba = node => {\n\t// hex is the node value\n\tconst hex = node.value;\n\n\t// conditionally expand a hex\n\tconst hex8 = `0x${hex.length === 5 ? hex.slice(1).replace(/[0-9A-f]/g, '$&$&') : hex.slice(1)}`;\n\n\t// extract the red, blue, green, and alpha values from the hex\n\tconst [r, g, b, a] = [\n\t\tparseInt(hex8.slice(2, 4), 16),\n\t\tparseInt(hex8.slice(4, 6), 16),\n\t\tparseInt(hex8.slice(6, 8), 16),\n\t\tMath.round(parseInt(hex8.slice(8, 10), 16) / 255 * alphaDecimalPrecision) / alphaDecimalPrecision\n\t];\n\n\t// return a new rgba function, preserving the whitespace of the original node\n\tconst rgbaFunc = valueParser.func({ value: 'rgba', raws: Object.assign({}, node.raws) });\n\n\trgbaFunc.append(valueParser.paren({ value: '(' }));\n\trgbaFunc.append(valueParser.number({ value: r }));\n\trgbaFunc.append(valueParser.comma({ value: ',' }));\n\trgbaFunc.append(valueParser.number({ value: g }));\n\trgbaFunc.append(valueParser.comma({ value: ',' }));\n\trgbaFunc.append(valueParser.number({ value: b }));\n\trgbaFunc.append(valueParser.comma({ value: ',' }));\n\trgbaFunc.append(valueParser.number({ value: a }));\n\trgbaFunc.append(valueParser.paren({ value: ')' }));\n\n\treturn rgbaFunc;\n};\n"]},"metadata":{},"sourceType":"module"}