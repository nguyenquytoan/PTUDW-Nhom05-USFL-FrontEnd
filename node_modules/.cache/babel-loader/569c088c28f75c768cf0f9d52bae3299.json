{"ast":null,"code":"'use strict';\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\n\n\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  var offset = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\n\n\nfunction _mask(source, mask, output, offset, length) {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\n\n\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\n\n\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\n\n\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  var buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\n\n\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = require('bufferutil');\n\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n  module.exports = {\n    concat,\n\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bu.mask(source, mask, output, offset, length);\n    },\n\n    toArrayBuffer,\n    toBuffer,\n\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bu.unmask(buffer, mask);\n    }\n\n  };\n} catch (e)\n/* istanbul ignore next */\n{\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-environment-jsdom-fourteen/node_modules/ws/lib/buffer-util.js"],"names":["EMPTY_BUFFER","require","concat","list","totalLength","length","target","Buffer","allocUnsafe","offset","i","buf","copy","_mask","source","mask","output","_unmask","buffer","toArrayBuffer","byteLength","slice","byteOffset","toBuffer","data","readOnly","isBuffer","ArrayBuffer","from","isView","viewToBuffer","view","bufferUtil","bu","BufferUtil","module","exports","unmask","e"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  var offset = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  var buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = require('bufferutil');\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n"]},"metadata":{},"sourceType":"script"}