{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { DBWrapper } from 'workbox-core/_private/DBWrapper.mjs';\nimport { deleteDatabase } from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = unNormalizedUrl => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n  return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\n\n\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: event => this._handleUpgrade(event)\n    });\n  }\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n\n\n  _handleUpgrade(event) {\n    const db = event.target.result; // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n      keyPath: 'id'\n    }); // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n\n    objStore.createIndex('cacheName', 'cacheName', {\n      unique: false\n    });\n    objStore.createIndex('timestamp', 'timestamp', {\n      unique: false\n    }); // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n\n    deleteDatabase(this._cacheName);\n  }\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n\n\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url)\n    });\n  }\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n\n\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n\n\n  async expireEntries(minTimestamp, maxCount) {\n    const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n      const store = txn.objectStore(OBJECT_STORE_NAME);\n      const entriesToDelete = [];\n      let entriesNotDeletedCount = 0;\n\n      store.index('timestamp').openCursor(null, 'prev').onsuccess = ({\n        target\n      }) => {\n        const cursor = target.result;\n\n        if (cursor) {\n          const result = cursor.value; // TODO(philipwalton): once we can use a multi-key index, we\n          // won't have to check `cacheName` here.\n\n          if (result.cacheName === this._cacheName) {\n            // Delete an entry if it's older than the max age or\n            // if we already have the max number allowed.\n            if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n              // TODO(philipwalton): we should be able to delete the\n              // entry right here, but doing so causes an iteration\n              // bug in Safari stable (fixed in TP). Instead we can\n              // store the keys of the entries to delete, and then\n              // delete the separate transactions.\n              // https://github.com/GoogleChrome/workbox/issues/1978\n              // cursor.delete();\n              // We only need to return the URL, not the whole entry.\n              entriesToDelete.push(cursor.value);\n            } else {\n              entriesNotDeletedCount++;\n            }\n          }\n\n          cursor.continue();\n        } else {\n          done(entriesToDelete);\n        }\n      };\n    }); // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n\n    const urlsDeleted = [];\n\n    for (const entry of entriesToDelete) {\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n\n\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n\n}\n\nexport { CacheTimestampsModel };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-expiration/models/CacheTimestampsModel.mjs"],"names":["DBWrapper","deleteDatabase","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","URL","location","hash","href","CacheTimestampsModel","constructor","cacheName","_cacheName","_db","onupgradeneeded","event","_handleUpgrade","db","target","result","objStore","createObjectStore","keyPath","createIndex","unique","setTimestamp","timestamp","put","id","_getId","getTimestamp","entry","get","expireEntries","minTimestamp","maxCount","entriesToDelete","transaction","txn","done","store","objectStore","entriesNotDeletedCount","index","openCursor","onsuccess","cursor","value","push","continue","urlsDeleted","delete"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const entriesToDelete = await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesToDelete = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      // TODO(philipwalton): we should be able to delete the\n                      // entry right here, but doing so causes an iteration\n                      // bug in Safari stable (fixed in TP). Instead we can\n                      // store the keys of the entries to delete, and then\n                      // delete the separate transactions.\n                      // https://github.com/GoogleChrome/workbox/issues/1978\n                      // cursor.delete();\n\n                      // We only need to return the URL, not the whole entry.\n                      entriesToDelete.push(cursor.value);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesToDelete);\n                }\n              };\n        });\n\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n"]},"metadata":{},"sourceType":"module"}