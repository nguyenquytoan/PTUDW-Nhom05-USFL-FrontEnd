{"ast":null,"code":"/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\n\nconst validator = new RegExpValidator({\n  ecmaVersion: 2018\n});\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowConstructorFlags: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let allowedFlags = null;\n\n    if (options && options.allowConstructorFlags) {\n      const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n      if (temp) {\n        allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n      }\n    }\n    /**\n     * Check if node is a string\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if its a string\n     * @private\n     */\n\n\n    function isString(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\n     * Check syntax error in a given pattern.\n     * @param {string} pattern The RegExp pattern to validate.\n     * @param {boolean} uFlag The Unicode flag.\n     * @returns {string|null} The syntax error.\n     */\n\n\n    function validateRegExpPattern(pattern, uFlag) {\n      try {\n        validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n        return null;\n      } catch (err) {\n        return err.message;\n      }\n    }\n    /**\n     * Check syntax error in a given flags.\n     * @param {string} flags The RegExp flags to validate.\n     * @returns {string|null} The syntax error.\n     */\n\n\n    function validateRegExpFlags(flags) {\n      try {\n        validator.validateFlags(flags);\n        return null;\n      } catch (err) {\n        return `Invalid flags supplied to RegExp constructor '${flags}'`;\n      }\n    }\n\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n          return;\n        }\n\n        const pattern = node.arguments[0].value;\n        let flags = isString(node.arguments[1]) ? node.arguments[1].value : \"\";\n\n        if (allowedFlags) {\n          flags = flags.replace(allowedFlags, \"\");\n        } // If flags are unknown, check both are errored or not.\n\n\n        const message = validateRegExpFlags(flags) || (flags ? validateRegExpPattern(pattern, flags.indexOf(\"u\") !== -1) : validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false));\n\n        if (message) {\n          context.report({\n            node,\n            message: \"{{message}}.\",\n            data: {\n              message\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-invalid-regexp.js"],"names":["RegExpValidator","require","validator","ecmaVersion","validFlags","undefined1","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowConstructorFlags","items","additionalProperties","create","context","options","allowedFlags","temp","join","replace","RegExp","isString","node","value","validateRegExpPattern","pattern","uFlag","validatePattern","err","message","validateRegExpFlags","flags","validateFlags","callee","name","arguments","indexOf","report","data"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,eAA3C;;AACA,MAAME,SAAS,GAAG,IAAIF,eAAJ,CAAoB;AAAEG,EAAAA,WAAW,EAAE;AAAf,CAApB,CAAlB;AACA,MAAMC,UAAU,GAAG,YAAnB;AACA,MAAMC,UAAU,GAAG,KAAK,CAAxB,C,CAEA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,SADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,sEADX;AAEFC,MAAAA,QAAQ,EAAE,iBAFR;AAGFC,MAAAA,WAAW,EAAE,IAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,CAAC;AACLN,MAAAA,IAAI,EAAE,QADD;AAELO,MAAAA,UAAU,EAAE;AACRC,QAAAA,qBAAqB,EAAE;AACnBR,UAAAA,IAAI,EAAE,OADa;AAEnBS,UAAAA,KAAK,EAAE;AACHT,YAAAA,IAAI,EAAE;AADH;AAFY;AADf,OAFP;AAULU,MAAAA,oBAAoB,EAAE;AAVjB,KAAD;AAVN,GADO;;AAyBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ,UAAMC,OAAO,GAAGD,OAAO,CAACC,OAAR,CAAgB,CAAhB,CAAhB;AACA,QAAIC,YAAY,GAAG,IAAnB;;AAEA,QAAID,OAAO,IAAIA,OAAO,CAACL,qBAAvB,EAA8C;AAC1C,YAAMO,IAAI,GAAGF,OAAO,CAACL,qBAAR,CAA8BQ,IAA9B,CAAmC,EAAnC,EAAuCC,OAAvC,CAA+CtB,UAA/C,EAA2D,EAA3D,CAAb;;AAEA,UAAIoB,IAAJ,EAAU;AACND,QAAAA,YAAY,GAAG,IAAII,MAAJ,CAAY,IAAGH,IAAK,GAApB,EAAwB,KAAxB,CAAf;AACH;AACJ;AAED;;;;;;;;AAMA,aAASI,QAAT,CAAkBC,IAAlB,EAAwB;AACpB,aAAOA,IAAI,IAAIA,IAAI,CAACpB,IAAL,KAAc,SAAtB,IAAmC,OAAOoB,IAAI,CAACC,KAAZ,KAAsB,QAAhE;AACH;AAED;;;;;;;;AAMA,aAASC,qBAAT,CAA+BC,OAA/B,EAAwCC,KAAxC,EAA+C;AAC3C,UAAI;AACA/B,QAAAA,SAAS,CAACgC,eAAV,CAA0BF,OAA1B,EAAmC3B,UAAnC,EAA+CA,UAA/C,EAA2D4B,KAA3D;AACA,eAAO,IAAP;AACH,OAHD,CAGE,OAAOE,GAAP,EAAY;AACV,eAAOA,GAAG,CAACC,OAAX;AACH;AACJ;AAED;;;;;;;AAKA,aAASC,mBAAT,CAA6BC,KAA7B,EAAoC;AAChC,UAAI;AACApC,QAAAA,SAAS,CAACqC,aAAV,CAAwBD,KAAxB;AACA,eAAO,IAAP;AACH,OAHD,CAGE,OAAOH,GAAP,EAAY;AACV,eAAQ,iDAAgDG,KAAM,GAA9D;AACH;AACJ;;AAED,WAAO;AACH,sCAAgCT,IAAhC,EAAsC;AAClC,YAAIA,IAAI,CAACW,MAAL,CAAY/B,IAAZ,KAAqB,YAArB,IAAqCoB,IAAI,CAACW,MAAL,CAAYC,IAAZ,KAAqB,QAA1D,IAAsE,CAACb,QAAQ,CAACC,IAAI,CAACa,SAAL,CAAe,CAAf,CAAD,CAAnF,EAAwG;AACpG;AACH;;AACD,cAAMV,OAAO,GAAGH,IAAI,CAACa,SAAL,CAAe,CAAf,EAAkBZ,KAAlC;AACA,YAAIQ,KAAK,GAAGV,QAAQ,CAACC,IAAI,CAACa,SAAL,CAAe,CAAf,CAAD,CAAR,GAA8Bb,IAAI,CAACa,SAAL,CAAe,CAAf,EAAkBZ,KAAhD,GAAwD,EAApE;;AAEA,YAAIP,YAAJ,EAAkB;AACde,UAAAA,KAAK,GAAGA,KAAK,CAACZ,OAAN,CAAcH,YAAd,EAA4B,EAA5B,CAAR;AACH,SATiC,CAWlC;;;AACA,cAAMa,OAAO,GAAGC,mBAAmB,CAACC,KAAD,CAAnB,KACZA,KAAK,GACCP,qBAAqB,CAACC,OAAD,EAAUM,KAAK,CAACK,OAAN,CAAc,GAAd,MAAuB,CAAC,CAAlC,CADtB,GAECZ,qBAAqB,CAACC,OAAD,EAAU,IAAV,CAArB,IAAwCD,qBAAqB,CAACC,OAAD,EAAU,KAAV,CAHvD,CAAhB;;AAMA,YAAII,OAAJ,EAAa;AACTf,UAAAA,OAAO,CAACuB,MAAR,CAAe;AACXf,YAAAA,IADW;AAEXO,YAAAA,OAAO,EAAE,cAFE;AAGXS,YAAAA,IAAI,EAAE;AAAET,cAAAA;AAAF;AAHK,WAAf;AAKH;AACJ;;AA1BE,KAAP;AA4BH;;AAzGY,CAAjB","sourcesContent":["/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst validator = new RegExpValidator({ ecmaVersion: 2018 });\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = null;\n\n        if (options && options.allowConstructorFlags) {\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n            if (temp) {\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {boolean} uFlag The Unicode flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, uFlag) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string} flags The RegExp flags to validate.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags) {\n            try {\n                validator.validateFlags(flags);\n                return null;\n            } catch (err) {\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\n            }\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n                    return;\n                }\n                const pattern = node.arguments[0].value;\n                let flags = isString(node.arguments[1]) ? node.arguments[1].value : \"\";\n\n                if (allowedFlags) {\n                    flags = flags.replace(allowedFlags, \"\");\n                }\n\n                // If flags are unknown, check both are errored or not.\n                const message = validateRegExpFlags(flags) || (\n                    flags\n                        ? validateRegExpPattern(pattern, flags.indexOf(\"u\") !== -1)\n                        : validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)\n                );\n\n                if (message) {\n                    context.report({\n                        node,\n                        message: \"{{message}}.\",\n                        data: { message }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}