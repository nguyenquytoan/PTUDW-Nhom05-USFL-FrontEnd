{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.cacheableResponse = function (t) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:cacheable-response:4.3.1\"] && _();\n  } catch (t) {}\n\n  class s {\n    constructor(t = {}) {\n      this.t = t.statuses, this.s = t.headers;\n    }\n\n    isResponseCacheable(t) {\n      let s = !0;\n      return this.t && (s = this.t.includes(t.status)), this.s && s && (s = Object.keys(this.s).some(s => t.headers.get(s) === this.s[s])), s;\n    }\n\n  }\n\n  return t.CacheableResponse = s, t.Plugin = class {\n    constructor(t) {\n      this.i = new s(t);\n    }\n\n    cacheWillUpdate({\n      response: t\n    }) {\n      return this.i.isResponseCacheable(t) ? t : null;\n    }\n\n  }, t;\n}({});","map":{"version":3,"sources":["../_version.mjs","../CacheableResponse.mjs","../Plugin.mjs"],"names":["self","_","e","CacheableResponse","constructor","config","_statuses","statuses","_headers","headers","isResponseCacheable","response","cacheable","this","includes","status","Object","keys","some","headerName","get","_cacheableResponse","cacheWillUpdate"],"mappings":";;;AAAA,MAAA;AAAIA,IAAAA,IAAAA,CAAK,kCAALA,CAAAA,IAA0CC,CAAAA,EAA1CD;AAA8C,GAAlD,CAAkD,OAAME,CAAN,EAAMA,CCsBxD;;AAAA,QAAMC,CAAN,CAAMA;AAeJC,IAAAA,WAAAA,CAAYC,CAAAA,GAAS,EAArBD,EAAqB;AAAA,WA6BdE,CA7Bc,GA6BFD,CAAAA,CAAOE,QA7BL,EA6BKA,KACnBC,CADmBD,GACRF,CAAAA,CAAOI,OA9BJ;AA0CrBC;;AAAAA,IAAAA,mBAAAA,CAAoBC,CAApBD,EAAoBC;AAAAA,UAUdC,CAAAA,GAAAA,CAAY,CAVED;AAUF,aAEZE,KAAKP,CAALO,KACFD,CAAAA,GAAYC,KAAKP,CAALO,CAAeC,QAAfD,CAAwBF,CAAAA,CAASI,MAAjCF,CADVA,GAIAA,KAAKL,CAALK,IAAiBD,CAAjBC,KACFD,CAAAA,GAAYI,MAAAA,CAAOC,IAAPD,CAAYH,KAAKL,CAAjBQ,EAA2BE,IAA3BF,CAAiCG,CAAAA,IACpCR,CAAAA,CAASF,OAATE,CAAiBS,GAAjBT,CAAqBQ,CAArBR,MAAqCE,KAAKL,CAALK,CAAcM,CAAdN,CADlCG,CADVH,CAJAA,EA2CGD,CA7CS;AA6CTA;;AAhHLT;;AAgHKS,SAAAA,CAAAA,CAAAA,iBAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GCpHX,MAAA;AAeER,IAAAA,WAAAA,CAAYC,CAAZD,EAAYC;AAAAA,WACLgB,CADKhB,GACgB,IAAIF,CAAJ,CAAsBE,CAAtB,CADhBA;AAUZiB;;AAAAA,IAAAA,eAAAA,CAAAA;AAAgBX,MAAAA,QAAAA,EAACA;AAAjBW,KAAAA,EAAiBX;AAAAA,aACXE,KAAKQ,CAALR,CAAwBH,mBAAxBG,CAA4CF,CAA5CE,IACKF,CADLE,GAGG,IAJQF;AAIR;;AA7BX,GDoHWC,ECvFA,CDuFAA;ACvFA,C,CAAA,E","sourcesContent":["try{self['workbox:cacheable-response:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport './_version.mjs';\n\n/**\n * This class allows you to set up rules determining what\n * status codes and/or headers need to be present in order for a\n * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n * to be considered cacheable.\n *\n * @memberof workbox.cacheableResponse\n */\nclass CacheableResponse {\n  /**\n   * To construct a new CacheableResponse instance you must provide at least\n   * one of the `config` properties.\n   *\n   * If both `statuses` and `headers` are specified, then both conditions must\n   * be met for the `Response` to be considered cacheable.\n   *\n   * @param {Object} config\n   * @param {Array<number>} [config.statuses] One or more status codes that a\n   * `Response` can have and be considered cacheable.\n   * @param {Object<string,string>} [config.headers] A mapping of header names\n   * and expected values that a `Response` can have and be considered cacheable.\n   * If multiple headers are provided, only one needs to be present.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.statuses || config.headers)) {\n        throw new WorkboxError('statuses-or-headers-required', {\n          moduleName: 'workbox-cacheable-response',\n          className: 'CacheableResponse',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.statuses) {\n        assert.isArray(config.statuses, {\n          moduleName: 'workbox-cacheable-response',\n          className: 'CacheableResponse',\n          funcName: 'constructor',\n          paramName: 'config.statuses',\n        });\n      }\n\n      if (config.headers) {\n        assert.isType(config.headers, 'object', {\n          moduleName: 'workbox-cacheable-response',\n          className: 'CacheableResponse',\n          funcName: 'constructor',\n          paramName: 'config.headers',\n        });\n      }\n    }\n\n    this._statuses = config.statuses;\n    this._headers = config.headers;\n  }\n\n  /**\n   * Checks a response to see whether it's cacheable or not, based on this\n   * object's configuration.\n   *\n   * @param {Response} response The response whose cacheability is being\n   * checked.\n   * @return {boolean} `true` if the `Response` is cacheable, and `false`\n   * otherwise.\n   */\n  isResponseCacheable(response) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(response, Response, {\n        moduleName: 'workbox-cacheable-response',\n        className: 'CacheableResponse',\n        funcName: 'isResponseCacheable',\n        paramName: 'response',\n      });\n    }\n\n    let cacheable = true;\n\n    if (this._statuses) {\n      cacheable = this._statuses.includes(response.status);\n    }\n\n    if (this._headers && cacheable) {\n      cacheable = Object.keys(this._headers).some((headerName) => {\n        return response.headers.get(headerName) === this._headers[headerName];\n      });\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!cacheable) {\n        logger.groupCollapsed(`The request for ` +\n          `'${getFriendlyURL(response.url)}' returned a response that does ` +\n          `not meet the criteria for being cached.`);\n\n        logger.groupCollapsed(`View cacheability criteria here.`);\n        logger.log(`Cacheable statuses: ` +\n          JSON.stringify(this._statuses));\n        logger.log(`Cacheable headers: ` +\n          JSON.stringify(this._headers, null, 2));\n        logger.groupEnd();\n\n        const logFriendlyHeaders = {};\n        response.headers.forEach((value, key) => {\n          logFriendlyHeaders[key] = value;\n        });\n\n        logger.groupCollapsed(`View response status and headers here.`);\n        logger.log(`Response status: ` + response.status);\n        logger.log(`Response headers: ` +\n          JSON.stringify(logFriendlyHeaders, null, 2));\n        logger.groupEnd();\n\n        logger.groupCollapsed(`View full response details here.`);\n        logger.log(response.headers);\n        logger.log(response);\n        logger.groupEnd();\n\n        logger.groupEnd();\n      }\n    }\n\n    return cacheable;\n  }\n}\n\nexport {CacheableResponse};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheableResponse} from './CacheableResponse.mjs';\nimport './_version.mjs';\n\n/**\n * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n * easier to add in cacheability checks to requests made via Workbox's built-in\n * strategies.\n *\n * @memberof workbox.cacheableResponse\n */\nclass Plugin {\n  /**\n   * To construct a new cacheable response Plugin instance you must provide at\n   * least one of the `config` properties.\n   *\n   * If both `statuses` and `headers` are specified, then both conditions must\n   * be met for the `Response` to be considered cacheable.\n   *\n   * @param {Object} config\n   * @param {Array<number>} [config.statuses] One or more status codes that a\n   * `Response` can have and be considered cacheable.\n   * @param {Object<string,string>} [config.headers] A mapping of header names\n   * and expected values that a `Response` can have and be considered cacheable.\n   * If multiple headers are provided, only one needs to be present.\n   */\n  constructor(config) {\n    this._cacheableResponse = new CacheableResponse(config);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {boolean}\n   * @private\n   */\n  cacheWillUpdate({response}) {\n    if (this._cacheableResponse.isResponseCacheable(response)) {\n      return response;\n    }\n    return null;\n  }\n}\n\nexport {Plugin};\n"]},"metadata":{},"sourceType":"script"}