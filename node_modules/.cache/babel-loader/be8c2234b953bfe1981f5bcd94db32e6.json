{"ast":null,"code":"/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get location should be reported by AST node.\n * @param {ASTNode} node AST Node.\n * @returns {Location} Location information.\n */\n\n\nfunction getLocation(node) {\n  return {\n    start: node.params[0].loc.start,\n    end: node.params[node.params.length - 1].loc.end\n  };\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around arrow function arguments\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-parens\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }, {\n      type: \"object\",\n      properties: {\n        requireForBlockBody: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedParens: \"Unexpected parentheses around single function argument.\",\n      expectedParens: \"Expected parentheses around arrow function argument.\",\n      unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n      expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n    }\n  },\n\n  create(context) {\n    const asNeeded = context.options[0] === \"as-needed\";\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines whether a arrow function argument end with `)`\n     * @param {ASTNode} node The arrow function node.\n     * @returns {void}\n     */\n\n    function parens(node) {\n      const isAsync = node.async;\n      const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);\n      /**\n       * Remove the parenthesis around a parameter\n       * @param {Fixer} fixer Fixer\n       * @returns {string} fixed parameter\n       */\n\n      function fixParamsWithParenthesis(fixer) {\n        const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n        /*\n         * ES8 allows Trailing commas in function parameter lists and calls\n         * https://github.com/eslint/eslint/issues/8834\n         */\n\n        const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);\n        const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n        const shouldAddSpaceForAsync = asyncToken && asyncToken.range[1] === firstTokenOfParam.range[0];\n        return fixer.replaceTextRange([firstTokenOfParam.range[0], closingParenToken.range[1]], `${shouldAddSpaceForAsync ? \" \" : \"\"}${paramToken.value}`);\n      } // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n\n\n      if (requireForBlockBody && node.params.length === 1 && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && node.body.type !== \"BlockStatement\" && !node.returnType) {\n        if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            node,\n            messageId: \"unexpectedParensInline\",\n            loc: getLocation(node),\n            fix: fixParamsWithParenthesis\n          });\n        }\n\n        return;\n      }\n\n      if (requireForBlockBody && node.body.type === \"BlockStatement\") {\n        if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            node,\n            messageId: \"expectedParensBlock\",\n            loc: getLocation(node),\n\n            fix(fixer) {\n              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n            }\n\n          });\n        }\n\n        return;\n      } // \"as-needed\": x => x\n\n\n      if (asNeeded && node.params.length === 1 && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.returnType) {\n        if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            node,\n            messageId: \"unexpectedParens\",\n            loc: getLocation(node),\n            fix: fixParamsWithParenthesis\n          });\n        }\n\n        return;\n      }\n\n      if (firstTokenOfParam.type === \"Identifier\") {\n        const after = sourceCode.getTokenAfter(firstTokenOfParam); // (x) => x\n\n        if (after.value !== \")\") {\n          context.report({\n            node,\n            messageId: \"expectedParens\",\n            loc: getLocation(node),\n\n            fix(fixer) {\n              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: parens\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/arrow-parens.js"],"names":["astUtils","require","getLocation","node","start","params","loc","end","length","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","requireForBlockBody","default","additionalProperties","messages","unexpectedParens","expectedParens","unexpectedParensInline","expectedParensBlock","create","context","asNeeded","options","sourceCode","getSourceCode","parens","isAsync","async","firstTokenOfParam","getFirstToken","fixParamsWithParenthesis","fixer","paramToken","getTokenAfter","closingParenToken","isClosingParenToken","asyncToken","getTokenBefore","shouldAddSpaceForAsync","range","replaceTextRange","value","typeAnnotation","body","returnType","isOpeningParenToken","report","messageId","fix","replaceText","after","ArrowFunctionExpression"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;;;;;;;AAKA,SAASC,WAAT,CAAqBC,IAArB,EAA2B;AACvB,SAAO;AACHC,IAAAA,KAAK,EAAED,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAeC,GAAf,CAAmBF,KADvB;AAEHG,IAAAA,GAAG,EAAEJ,IAAI,CAACE,MAAL,CAAYF,IAAI,CAACE,MAAL,CAAYG,MAAZ,GAAqB,CAAjC,EAAoCF,GAApC,CAAwCC;AAF1C,GAAP;AAIH,C,CAED;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,qDADX;AAEFC,MAAAA,QAAQ,EAAE,cAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,OAAO,EAAE,MAVP;AAYFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,WAAX;AADV,KADI,EAIJ;AACIR,MAAAA,IAAI,EAAE,QADV;AAEIS,MAAAA,UAAU,EAAE;AACRC,QAAAA,mBAAmB,EAAE;AACjBV,UAAAA,IAAI,EAAE,SADW;AAEjBW,UAAAA,OAAO,EAAE;AAFQ;AADb,OAFhB;AAQIC,MAAAA,oBAAoB,EAAE;AAR1B,KAJI,CAZN;AA4BFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,gBAAgB,EAAE,yDADZ;AAENC,MAAAA,cAAc,EAAE,sDAFV;AAINC,MAAAA,sBAAsB,EAAE,4FAJlB;AAKNC,MAAAA,mBAAmB,EAAE;AALf;AA5BR,GADO;;AAsCbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,QAAQ,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,MAAuB,WAAxC;AACA,UAAMX,mBAAmB,GAAGU,QAAQ,IAAID,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAZ,IAAkCF,OAAO,CAACE,OAAR,CAAgB,CAAhB,EAAmBX,mBAAnB,KAA2C,IAAzG;AAEA,UAAMY,UAAU,GAAGH,OAAO,CAACI,aAAR,EAAnB;AAEA;;;;;;AAKA,aAASC,MAAT,CAAgBjC,IAAhB,EAAsB;AAClB,YAAMkC,OAAO,GAAGlC,IAAI,CAACmC,KAArB;AACA,YAAMC,iBAAiB,GAAGL,UAAU,CAACM,aAAX,CAAyBrC,IAAzB,EAA+BkC,OAAO,GAAG,CAAH,GAAO,CAA7C,CAA1B;AAEA;;;;;;AAKA,eAASI,wBAAT,CAAkCC,KAAlC,EAAyC;AACrC,cAAMC,UAAU,GAAGT,UAAU,CAACU,aAAX,CAAyBL,iBAAzB,CAAnB;AAEA;;;;;AAIA,cAAMM,iBAAiB,GAAGX,UAAU,CAACU,aAAX,CAAyBD,UAAzB,EAAqC3C,QAAQ,CAAC8C,mBAA9C,CAA1B;AACA,cAAMC,UAAU,GAAGV,OAAO,GAAGH,UAAU,CAACc,cAAX,CAA0BT,iBAA1B,CAAH,GAAkD,IAA5E;AACA,cAAMU,sBAAsB,GAAGF,UAAU,IAAKA,UAAU,CAACG,KAAX,CAAiB,CAAjB,MAAwBX,iBAAiB,CAACW,KAAlB,CAAwB,CAAxB,CAAtE;AAEA,eAAOR,KAAK,CAACS,gBAAN,CAAuB,CAC1BZ,iBAAiB,CAACW,KAAlB,CAAwB,CAAxB,CAD0B,EAE1BL,iBAAiB,CAACK,KAAlB,CAAwB,CAAxB,CAF0B,CAAvB,EAGH,GAAED,sBAAsB,GAAG,GAAH,GAAS,EAAG,GAAEN,UAAU,CAACS,KAAM,EAHpD,CAAP;AAIH,OAxBiB,CA0BlB;;;AACA,UACI9B,mBAAmB,IACnBnB,IAAI,CAACE,MAAL,CAAYG,MAAZ,KAAuB,CADvB,IAEAL,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAeO,IAAf,KAAwB,YAFxB,IAGA,CAACT,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAegD,cAHhB,IAIAlD,IAAI,CAACmD,IAAL,CAAU1C,IAAV,KAAmB,gBAJnB,IAKA,CAACT,IAAI,CAACoD,UANV,EAOE;AACE,YAAIvD,QAAQ,CAACwD,mBAAT,CAA6BjB,iBAA7B,CAAJ,EAAqD;AACjDR,UAAAA,OAAO,CAAC0B,MAAR,CAAe;AACXtD,YAAAA,IADW;AAEXuD,YAAAA,SAAS,EAAE,wBAFA;AAGXpD,YAAAA,GAAG,EAAEJ,WAAW,CAACC,IAAD,CAHL;AAIXwD,YAAAA,GAAG,EAAElB;AAJM,WAAf;AAMH;;AACD;AACH;;AAED,UACInB,mBAAmB,IACnBnB,IAAI,CAACmD,IAAL,CAAU1C,IAAV,KAAmB,gBAFvB,EAGE;AACE,YAAI,CAACZ,QAAQ,CAACwD,mBAAT,CAA6BjB,iBAA7B,CAAL,EAAsD;AAClDR,UAAAA,OAAO,CAAC0B,MAAR,CAAe;AACXtD,YAAAA,IADW;AAEXuD,YAAAA,SAAS,EAAE,qBAFA;AAGXpD,YAAAA,GAAG,EAAEJ,WAAW,CAACC,IAAD,CAHL;;AAIXwD,YAAAA,GAAG,CAACjB,KAAD,EAAQ;AACP,qBAAOA,KAAK,CAACkB,WAAN,CAAkBrB,iBAAlB,EAAsC,IAAGA,iBAAiB,CAACa,KAAM,GAAjE,CAAP;AACH;;AANU,WAAf;AAQH;;AACD;AACH,OA7DiB,CA+DlB;;;AACA,UAAIpB,QAAQ,IACR7B,IAAI,CAACE,MAAL,CAAYG,MAAZ,KAAuB,CADvB,IAEAL,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAeO,IAAf,KAAwB,YAFxB,IAGA,CAACT,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAegD,cAHhB,IAIA,CAAClD,IAAI,CAACoD,UAJV,EAKE;AACE,YAAIvD,QAAQ,CAACwD,mBAAT,CAA6BjB,iBAA7B,CAAJ,EAAqD;AACjDR,UAAAA,OAAO,CAAC0B,MAAR,CAAe;AACXtD,YAAAA,IADW;AAEXuD,YAAAA,SAAS,EAAE,kBAFA;AAGXpD,YAAAA,GAAG,EAAEJ,WAAW,CAACC,IAAD,CAHL;AAIXwD,YAAAA,GAAG,EAAElB;AAJM,WAAf;AAMH;;AACD;AACH;;AAED,UAAIF,iBAAiB,CAAC3B,IAAlB,KAA2B,YAA/B,EAA6C;AACzC,cAAMiD,KAAK,GAAG3B,UAAU,CAACU,aAAX,CAAyBL,iBAAzB,CAAd,CADyC,CAGzC;;AACA,YAAIsB,KAAK,CAACT,KAAN,KAAgB,GAApB,EAAyB;AACrBrB,UAAAA,OAAO,CAAC0B,MAAR,CAAe;AACXtD,YAAAA,IADW;AAEXuD,YAAAA,SAAS,EAAE,gBAFA;AAGXpD,YAAAA,GAAG,EAAEJ,WAAW,CAACC,IAAD,CAHL;;AAIXwD,YAAAA,GAAG,CAACjB,KAAD,EAAQ;AACP,qBAAOA,KAAK,CAACkB,WAAN,CAAkBrB,iBAAlB,EAAsC,IAAGA,iBAAiB,CAACa,KAAM,GAAjE,CAAP;AACH;;AANU,WAAf;AAQH;AACJ;AACJ;;AAED,WAAO;AACHU,MAAAA,uBAAuB,EAAE1B;AADtB,KAAP;AAGH;;AAtJY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get location should be reported by AST node.\n * @param {ASTNode} node AST Node.\n * @returns {Location} Location information.\n */\nfunction getLocation(node) {\n    return {\n        start: node.params[0].loc.start,\n        end: node.params[node.params.length - 1].loc.end\n    };\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around arrow function arguments\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\n            expectedParens: \"Expected parentheses around arrow function argument.\",\n\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n        }\n    },\n\n    create(context) {\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether a arrow function argument end with `)`\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function parens(node) {\n            const isAsync = node.async;\n            const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);\n\n            /**\n             * Remove the parenthesis around a parameter\n             * @param {Fixer} fixer Fixer\n             * @returns {string} fixed parameter\n             */\n            function fixParamsWithParenthesis(fixer) {\n                const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n\n                /*\n                 * ES8 allows Trailing commas in function parameter lists and calls\n                 * https://github.com/eslint/eslint/issues/8834\n                 */\n                const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);\n                const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n                const shouldAddSpaceForAsync = asyncToken && (asyncToken.range[1] === firstTokenOfParam.range[0]);\n\n                return fixer.replaceTextRange([\n                    firstTokenOfParam.range[0],\n                    closingParenToken.range[1]\n                ], `${shouldAddSpaceForAsync ? \" \" : \"\"}${paramToken.value}`);\n            }\n\n            // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n            if (\n                requireForBlockBody &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                node.body.type !== \"BlockStatement\" &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedParensInline\",\n                        loc: getLocation(node),\n                        fix: fixParamsWithParenthesis\n                    });\n                }\n                return;\n            }\n\n            if (\n                requireForBlockBody &&\n                node.body.type === \"BlockStatement\"\n            ) {\n                if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        messageId: \"expectedParensBlock\",\n                        loc: getLocation(node),\n                        fix(fixer) {\n                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n                        }\n                    });\n                }\n                return;\n            }\n\n            // \"as-needed\": x => x\n            if (asNeeded &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedParens\",\n                        loc: getLocation(node),\n                        fix: fixParamsWithParenthesis\n                    });\n                }\n                return;\n            }\n\n            if (firstTokenOfParam.type === \"Identifier\") {\n                const after = sourceCode.getTokenAfter(firstTokenOfParam);\n\n                // (x) => x\n                if (after.value !== \")\") {\n                    context.report({\n                        node,\n                        messageId: \"expectedParens\",\n                        loc: getLocation(node),\n                        fix(fixer) {\n                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: parens\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}