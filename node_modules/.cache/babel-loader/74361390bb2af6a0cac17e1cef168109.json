{"ast":null,"code":"/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary nested blocks\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-lone-blocks\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    // A stack of lone blocks to be checked for block-level bindings\n    const loneBlocks = [];\n    let ruleDef;\n    /**\n     * Reports a node as invalid.\n     * @param {ASTNode} node The node to be reported.\n     * @returns {void}\n     */\n\n    function report(node) {\n      const message = node.parent.type === \"BlockStatement\" ? \"Nested block is redundant.\" : \"Block is redundant.\";\n      context.report({\n        node,\n        message\n      });\n    }\n    /**\n     * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} True if the node is a lone block.\n     */\n\n\n    function isLoneBlock(node) {\n      return node.parent.type === \"BlockStatement\" || node.parent.type === \"Program\" || // Don't report blocks in switch cases if the block is the only statement of the case.\n      node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n    }\n    /**\n     * Checks the enclosing block of the current node for block-level bindings,\n     * and \"marks it\" as valid if any.\n     * @returns {void}\n     */\n\n\n    function markLoneBlock() {\n      if (loneBlocks.length === 0) {\n        return;\n      }\n\n      const block = context.getAncestors().pop();\n\n      if (loneBlocks[loneBlocks.length - 1] === block) {\n        loneBlocks.pop();\n      }\n    } // Default rule definition: report all lone blocks\n\n\n    ruleDef = {\n      BlockStatement(node) {\n        if (isLoneBlock(node)) {\n          report(node);\n        }\n      }\n\n    }; // ES6: report blocks without block-level bindings, or that's only child of another block\n\n    if (context.parserOptions.ecmaVersion >= 6) {\n      ruleDef = {\n        BlockStatement(node) {\n          if (isLoneBlock(node)) {\n            loneBlocks.push(node);\n          }\n        },\n\n        \"BlockStatement:exit\"(node) {\n          if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n            loneBlocks.pop();\n            report(node);\n          } else if (node.parent.type === \"BlockStatement\" && node.parent.body.length === 1) {\n            report(node);\n          }\n        }\n\n      };\n\n      ruleDef.VariableDeclaration = function (node) {\n        if (node.kind === \"let\" || node.kind === \"const\") {\n          markLoneBlock();\n        }\n      };\n\n      ruleDef.FunctionDeclaration = function () {\n        if (context.getScope().isStrict) {\n          markLoneBlock();\n        }\n      };\n\n      ruleDef.ClassDeclaration = markLoneBlock;\n    }\n\n    return ruleDef;\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-lone-blocks.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","create","context","loneBlocks","ruleDef","report","node","message","parent","isLoneBlock","consequent","length","markLoneBlock","block","getAncestors","pop","BlockStatement","parserOptions","ecmaVersion","push","body","VariableDeclaration","kind","FunctionDeclaration","getScope","isStrict","ClassDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary nested blocks\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-lone-blocks\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node The node to be reported.\n         * @returns {void}\n         */\n        function report(node) {\n            const message = node.parent.type === \"BlockStatement\" ? \"Nested block is redundant.\" : \"Block is redundant.\";\n\n            context.report({ node, message });\n        }\n\n        /**\n         * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n         */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @returns {void}\n         */\n        function markLoneBlock() {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = context.getAncestors().pop();\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings, or that's only child of another block\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    } else if (\n                        node.parent.type === \"BlockStatement\" &&\n                        node.parent.body.length === 1\n                    ) {\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function() {\n                if (context.getScope().isStrict) {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}