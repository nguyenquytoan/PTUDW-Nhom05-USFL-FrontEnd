{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.mjs';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\n\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange; // If this is null, it means the database isn't open.\n\n    this._db = null;\n  }\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   *\n   * @private\n   */\n\n\n  get db() {\n    return this._db;\n  }\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n\n\n  async open() {\n    if (this._db) return;\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n      const openRequest = indexedDB.open(this._name, this._version);\n\n      openRequest.onerror = () => reject(openRequest.error);\n\n      openRequest.onupgradeneeded = evt => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n\n      openRequest.onsuccess = ({\n        target\n      }) => {\n        const db = target.result;\n\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n\n\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {\n      query,\n      count\n    });\n  }\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(storeName, {\n      query,\n      count,\n      includeKeys: true\n    })).map(({\n      key\n    }) => key);\n  }\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAllMatching(storeName, {\n    index,\n    query = null,\n    // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({\n        target\n      }) => {\n        const cursor = target.result;\n\n        if (cursor) {\n          const {\n            primaryKey,\n            key,\n            value\n          } = cursor;\n          results.push(includeKeys ? {\n            primaryKey,\n            key,\n            value\n          } : value);\n\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n\n\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n\n      txn.onabort = ({\n        target\n      }) => reject(target.error);\n\n      txn.oncomplete = () => resolve();\n\n      callback(txn, value => resolve(value));\n    });\n  }\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n\n\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({\n        target\n      }) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @private\n   */\n\n\n  _onversionchange() {\n    this.close();\n  }\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n\n\n  close() {\n    if (this._db) {\n      this._db.close();\n\n      this._db = null;\n    }\n  }\n\n} // Exposed to let users modify the default timeout on a per-instance\n// or global basis.\n\nDBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete']\n};\n\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function (storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-core/_private/DBWrapper.mjs"],"names":["DBWrapper","constructor","name","version","onupgradeneeded","onversionchange","_onversionchange","_name","_version","_onupgradeneeded","_db","db","open","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","onerror","error","evt","transaction","abort","target","result","close","onsuccess","bind","getKey","storeName","query","getAllKeys","getAll","count","getAllMatching","includeKeys","map","key","index","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","value","push","length","continue","storeNames","type","callback","onabort","oncomplete","_call","method","args","prototype","methodsToWrap","mode","methods","Object","entries","IDBObjectStore"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   *\n   * @private\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @private\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}