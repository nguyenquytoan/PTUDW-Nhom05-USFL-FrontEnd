{"ast":null,"code":"import { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\nconst O = {};\nconst isIRI = true; //RFC 3986\n\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"'); //RFC 6068\n\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\"; //%d33-90 / %d94-126\n\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str) {\n  const decStr = pctDecChars(str);\n  return !decStr.match(UNRESERVED) ? str : decStr;\n}\n\nconst handler = {\n  scheme: \"mailto\",\n  parse: function (components, options) {\n    const mailtoComponents = components;\n    const to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n    mailtoComponents.path = undefined;\n\n    if (mailtoComponents.query) {\n      let unknownHeaders = false;\n      const headers = {};\n      const hfields = mailtoComponents.query.split(\"&\");\n\n      for (let x = 0, xl = hfields.length; x < xl; ++x) {\n        const hfield = hfields[x].split(\"=\");\n\n        switch (hfield[0]) {\n          case \"to\":\n            const toAddrs = hfield[1].split(\",\");\n\n            for (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n              to.push(toAddrs[x]);\n            }\n\n            break;\n\n          case \"subject\":\n            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n            break;\n\n          case \"body\":\n            mailtoComponents.body = unescapeComponent(hfield[1], options);\n            break;\n\n          default:\n            unknownHeaders = true;\n            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n            break;\n        }\n      }\n\n      if (unknownHeaders) mailtoComponents.headers = headers;\n    }\n\n    mailtoComponents.query = undefined;\n\n    for (let x = 0, xl = to.length; x < xl; ++x) {\n      const addr = to[x].split(\"@\");\n      addr[0] = unescapeComponent(addr[0]);\n\n      if (!options.unicodeSupport) {\n        //convert Unicode IDN -> ASCII IDN\n        try {\n          addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n        } catch (e) {\n          mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n        }\n      } else {\n        addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n      }\n\n      to[x] = addr.join(\"@\");\n    }\n\n    return mailtoComponents;\n  },\n  serialize: function (mailtoComponents, options) {\n    const components = mailtoComponents;\n    const to = toArray(mailtoComponents.to);\n\n    if (to) {\n      for (let x = 0, xl = to.length; x < xl; ++x) {\n        const toAddr = String(to[x]);\n        const atIdx = toAddr.lastIndexOf(\"@\");\n        const localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n        let domain = toAddr.slice(atIdx + 1); //convert IDN via punycode\n\n        try {\n          domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n        } catch (e) {\n          components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n        }\n\n        to[x] = localPart + \"@\" + domain;\n      }\n\n      components.path = to.join(\",\");\n    }\n\n    const headers = mailtoComponents.headers = mailtoComponents.headers || {};\n    if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n    if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n    const fields = [];\n\n    for (const name in headers) {\n      if (headers[name] !== O[name]) {\n        fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n      }\n    }\n\n    if (fields.length) {\n      components.query = fields.join(\"&\");\n    }\n\n    return components;\n  }\n};\nexport default handler;","map":{"version":3,"sources":["../../../src/schemes/mailto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\nconst O = {};\nconst isIRI = true;\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\"; //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\nfunction decodeUnreserved(str) {\n    const decStr = pctDecChars(str);\n    return (!decStr.match(UNRESERVED) ? str : decStr);\n}\nconst handler = {\n    scheme: \"mailto\",\n    parse: function (components, options) {\n        const mailtoComponents = components;\n        const to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            let unknownHeaders = false;\n            const headers = {};\n            const hfields = mailtoComponents.query.split(\"&\");\n            for (let x = 0, xl = hfields.length; x < xl; ++x) {\n                const hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        const toAddrs = hfield[1].split(\",\");\n                        for (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n                            to.push(toAddrs[x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders)\n                mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (let x = 0, xl = to.length; x < xl; ++x) {\n            const addr = to[x].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                }\n                catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[x] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function (mailtoComponents, options) {\n        const components = mailtoComponents;\n        const to = toArray(mailtoComponents.to);\n        if (to) {\n            for (let x = 0, xl = to.length; x < xl; ++x) {\n                const toAddr = String(to[x]);\n                const atIdx = toAddr.lastIndexOf(\"@\");\n                const localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                let domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n                }\n                catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        const headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject)\n            headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body)\n            headers[\"body\"] = mailtoComponents.body;\n        const fields = [];\n        for (const name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n                    \"=\" +\n                    headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\nexport default handler;\n//# sourceMappingURL=mailto.js.map"]},"metadata":{},"sourceType":"module"}