{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxFlow = _interopRequireDefault(require(\"@babel/plugin-syntax-flow\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n  let skipStrip = false;\n  const {\n    requireDirective = false,\n    allowDeclareFields = false\n  } = opts;\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: _pluginSyntaxFlow.default,\n    visitor: {\n      Program(path, {\n        file: {\n          ast: {\n            comments\n          }\n        }\n      }) {\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({\n          importKind\n        }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(path) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\"A @flow directive is required when using Flow annotations with \" + \"the `requireDirective` option.\");\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const {\n              node\n            } = child;\n\n            if (!allowDeclareFields && node.declare) {\n              throw child.buildCodeFrameError(`The 'declare' modifier is only allowed when the ` + `'allowDeclareFields' option of ` + `@babel/plugin-transform-flow-strip-types or ` + `@babel/preset-flow is enabled.`);\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else if (!allowDeclareFields && !node.value && !node.decorators) {\n              child.remove();\n            } else {\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern({\n        node\n      }) {\n        if (skipStrip) return;\n        node.left.optional = false;\n      },\n\n      Function({\n        node\n      }) {\n        if (skipStrip) return;\n\n        for (let i = 0; i < node.params.length; i++) {\n          const param = node.params[i];\n          param.optional = false;\n\n          if (param.type === \"AssignmentPattern\") {\n            param.left.optional = false;\n          }\n        }\n\n        node.predicate = null;\n      },\n\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTypeCastExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      CallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      OptionalCallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      NewExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@babel/plugin-transform-flow-strip-types/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxFlow","_interopRequireDefault","_core","obj","__esModule","_default","declare","api","opts","assertVersion","FLOW_DIRECTIVE","skipStrip","requireDirective","allowDeclareFields","name","inherits","visitor","Program","path","file","ast","comments","directiveFound","comment","test","replace","trim","ignore","ImportDeclaration","node","specifiers","length","typeCount","forEach","importKind","remove","Flow","buildCodeFrameError","ClassPrivateProperty","typeAnnotation","Class","implements","get","child","isClassProperty","decorators","variance","AssignmentPattern","left","optional","Function","i","params","param","type","predicate","TypeCastExpression","expression","types","isTypeCastExpression","replaceWith","CallExpression","typeArguments","OptionalCallExpression","NewExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxFlow = _interopRequireDefault(require(\"@babel/plugin-syntax-flow\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n  let skipStrip = false;\n  const {\n    requireDirective = false,\n    allowDeclareFields = false\n  } = opts;\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: _pluginSyntaxFlow.default,\n    visitor: {\n      Program(path, {\n        file: {\n          ast: {\n            comments\n          }\n        }\n      }) {\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({\n          importKind\n        }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(path) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\"A @flow directive is required when using Flow annotations with \" + \"the `requireDirective` option.\");\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const {\n              node\n            } = child;\n\n            if (!allowDeclareFields && node.declare) {\n              throw child.buildCodeFrameError(`The 'declare' modifier is only allowed when the ` + `'allowDeclareFields' option of ` + `@babel/plugin-transform-flow-strip-types or ` + `@babel/preset-flow is enabled.`);\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else if (!allowDeclareFields && !node.value && !node.decorators) {\n              child.remove();\n            } else {\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern({\n        node\n      }) {\n        if (skipStrip) return;\n        node.left.optional = false;\n      },\n\n      Function({\n        node\n      }) {\n        if (skipStrip) return;\n\n        for (let i = 0; i < node.params.length; i++) {\n          const param = node.params[i];\n          param.optional = false;\n\n          if (param.type === \"AssignmentPattern\") {\n            param.left.optional = false;\n          }\n        }\n\n        node.predicate = null;\n      },\n\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTypeCastExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      CallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      OptionalCallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      NewExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}