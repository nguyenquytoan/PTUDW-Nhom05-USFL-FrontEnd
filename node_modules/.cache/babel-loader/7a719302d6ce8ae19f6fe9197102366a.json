{"ast":null,"code":"const Minipass = require('minipass');\n\nconst EE = require('events');\n\nconst isStream = s => s && s instanceof EE && (typeof s.pipe === 'function' || // readable\ntypeof s.write === 'function' && typeof s.end === 'function' // writable\n);\n\nconst _head = Symbol('_head');\n\nconst _tail = Symbol('_tail');\n\nconst _linkStreams = Symbol('_linkStreams');\n\nconst _setHead = Symbol('_setHead');\n\nconst _setTail = Symbol('_setTail');\n\nconst _onError = Symbol('_onError');\n\nconst _onData = Symbol('_onData');\n\nconst _onEnd = Symbol('_onEnd');\n\nconst _onDrain = Symbol('_onDrain');\n\nconst _streams = Symbol('_streams');\n\nclass Pipeline extends Minipass {\n  constructor(opts, ...streams) {\n    if (isStream(opts)) {\n      streams.unshift(opts);\n      opts = {};\n    }\n\n    super(opts);\n    this[_streams] = [];\n    if (streams.length) this.push(...streams);\n  }\n\n  [_linkStreams](streams) {\n    // reduce takes (left,right), and we return right to make it the\n    // new left value.\n    return streams.reduce((src, dest) => {\n      src.on('error', er => dest.emit('error', er));\n      src.pipe(dest);\n      return dest;\n    });\n  }\n\n  push(...streams) {\n    this[_streams].push(...streams);\n\n    if (this[_tail]) streams.unshift(this[_tail]);\n\n    const linkRet = this[_linkStreams](streams);\n\n    this[_setTail](linkRet);\n\n    if (!this[_head]) this[_setHead](streams[0]);\n  }\n\n  unshift(...streams) {\n    this[_streams].unshift(...streams);\n\n    if (this[_head]) streams.push(this[_head]);\n\n    const linkRet = this[_linkStreams](streams);\n\n    this[_setHead](streams[0]);\n\n    if (!this[_tail]) this[_setTail](linkRet);\n  }\n\n  destroy(er) {\n    // set fire to the whole thing.\n    this[_streams].forEach(s => typeof s.destroy === 'function' && s.destroy());\n\n    return super.destroy(er);\n  } // readable interface -> tail\n\n\n  [_setTail](stream) {\n    this[_tail] = stream;\n    stream.on('error', er => this[_onError](stream, er));\n    stream.on('data', chunk => this[_onData](stream, chunk));\n    stream.on('end', () => this[_onEnd](stream));\n    stream.on('finish', () => this[_onEnd](stream));\n  } // errors proxied down the pipeline\n  // they're considered part of the \"read\" interface\n\n\n  [_onError](stream, er) {\n    if (stream === this[_tail]) this.emit('error', er);\n  }\n\n  [_onData](stream, chunk) {\n    if (stream === this[_tail]) super.write(chunk);\n  }\n\n  [_onEnd](stream) {\n    if (stream === this[_tail]) super.end();\n  }\n\n  pause() {\n    super.pause();\n    return this[_tail] && this[_tail].pause && this[_tail].pause();\n  } // NB: Minipass calls its internal private [RESUME] method during\n  // pipe drains, to avoid hazards where stream.resume() is overridden.\n  // Thus, we need to listen to the resume *event*, not override the\n  // resume() method, and proxy *that* to the tail.\n\n\n  emit(ev, ...args) {\n    if (ev === 'resume' && this[_tail] && this[_tail].resume) this[_tail].resume();\n    return super.emit(ev, ...args);\n  } // writable interface -> head\n\n\n  [_setHead](stream) {\n    this[_head] = stream;\n    stream.on('drain', () => this[_onDrain](stream));\n  }\n\n  [_onDrain](stream) {\n    if (stream === this[_head]) this.emit('drain');\n  }\n\n  write(chunk, enc, cb) {\n    return this[_head].write(chunk, enc, cb) && this.flowing;\n  }\n\n  end(chunk, enc, cb) {\n    this[_head].end(chunk, enc, cb);\n\n    return this;\n  }\n\n}\n\nmodule.exports = Pipeline;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/minipass-pipeline/index.js"],"names":["Minipass","require","EE","isStream","s","pipe","write","end","_head","Symbol","_tail","_linkStreams","_setHead","_setTail","_onError","_onData","_onEnd","_onDrain","_streams","Pipeline","constructor","opts","streams","unshift","length","push","reduce","src","dest","on","er","emit","linkRet","destroy","forEach","stream","chunk","pause","ev","args","resume","enc","cb","flowing","module","exports"],"mappings":"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","sourcesContent":["const Minipass = require('minipass')\nconst EE = require('events')\nconst isStream = s => s && s instanceof EE && (\n  typeof s.pipe === 'function' || // readable\n  (typeof s.write === 'function' && typeof s.end === 'function') // writable\n)\n\nconst _head = Symbol('_head')\nconst _tail = Symbol('_tail')\nconst _linkStreams = Symbol('_linkStreams')\nconst _setHead = Symbol('_setHead')\nconst _setTail = Symbol('_setTail')\nconst _onError = Symbol('_onError')\nconst _onData = Symbol('_onData')\nconst _onEnd = Symbol('_onEnd')\nconst _onDrain = Symbol('_onDrain')\nconst _streams = Symbol('_streams')\nclass Pipeline extends Minipass {\n  constructor (opts, ...streams) {\n    if (isStream(opts)) {\n      streams.unshift(opts)\n      opts = {}\n    }\n\n    super(opts)\n    this[_streams] = []\n    if (streams.length)\n      this.push(...streams)\n  }\n\n  [_linkStreams] (streams) {\n    // reduce takes (left,right), and we return right to make it the\n    // new left value.\n    return streams.reduce((src, dest) => {\n      src.on('error', er => dest.emit('error', er))\n      src.pipe(dest)\n      return dest\n    })\n  }\n\n  push (...streams) {\n    this[_streams].push(...streams)\n    if (this[_tail])\n      streams.unshift(this[_tail])\n\n    const linkRet = this[_linkStreams](streams)\n\n    this[_setTail](linkRet)\n    if (!this[_head])\n      this[_setHead](streams[0])\n  }\n\n  unshift (...streams) {\n    this[_streams].unshift(...streams)\n    if (this[_head])\n      streams.push(this[_head])\n\n    const linkRet = this[_linkStreams](streams)\n    this[_setHead](streams[0])\n    if (!this[_tail])\n      this[_setTail](linkRet)\n  }\n\n  destroy (er) {\n    // set fire to the whole thing.\n    this[_streams].forEach(s =>\n      typeof s.destroy === 'function' && s.destroy())\n    return super.destroy(er)\n  }\n\n  // readable interface -> tail\n  [_setTail] (stream) {\n    this[_tail] = stream\n    stream.on('error', er => this[_onError](stream, er))\n    stream.on('data', chunk => this[_onData](stream, chunk))\n    stream.on('end', () => this[_onEnd](stream))\n    stream.on('finish', () => this[_onEnd](stream))\n  }\n\n  // errors proxied down the pipeline\n  // they're considered part of the \"read\" interface\n  [_onError] (stream, er) {\n    if (stream === this[_tail])\n      this.emit('error', er)\n  }\n  [_onData] (stream, chunk) {\n    if (stream === this[_tail])\n      super.write(chunk)\n  }\n  [_onEnd] (stream) {\n    if (stream === this[_tail])\n      super.end()\n  }\n  pause () {\n    super.pause()\n    return this[_tail] && this[_tail].pause && this[_tail].pause()\n  }\n\n  // NB: Minipass calls its internal private [RESUME] method during\n  // pipe drains, to avoid hazards where stream.resume() is overridden.\n  // Thus, we need to listen to the resume *event*, not override the\n  // resume() method, and proxy *that* to the tail.\n  emit (ev, ...args) {\n    if (ev === 'resume' && this[_tail] && this[_tail].resume)\n      this[_tail].resume()\n    return super.emit(ev, ...args)\n  }\n\n  // writable interface -> head\n  [_setHead] (stream) {\n    this[_head] = stream\n    stream.on('drain', () => this[_onDrain](stream))\n  }\n  [_onDrain] (stream) {\n    if (stream === this[_head])\n      this.emit('drain')\n  }\n  write (chunk, enc, cb) {\n    return this[_head].write(chunk, enc, cb) && this.flowing\n  }\n  end (chunk, enc, cb) {\n    this[_head].end(chunk, enc, cb)\n    return this\n  }\n}\n\nmodule.exports = Pipeline\n"]},"metadata":{},"sourceType":"script"}