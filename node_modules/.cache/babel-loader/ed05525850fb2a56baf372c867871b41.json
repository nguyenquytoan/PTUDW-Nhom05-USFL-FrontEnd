{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require identifiers to match a specified regular expression\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-match\"\n    },\n    schema: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        properties: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyDeclarations: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        }\n      }\n    }],\n    messages: {\n      notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n    const pattern = context.options[0] || \"^.+$\",\n          regexp = new RegExp(pattern, \"u\");\n    const options = context.options[1] || {},\n          properties = !!options.properties,\n          onlyDeclarations = !!options.onlyDeclarations,\n          ignoreDestructuring = !!options.ignoreDestructuring; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n\n    const reported = new Map();\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n    const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n    const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n    /**\n     * Checks if a string matches the provided pattern\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is a match\n     * @private\n     */\n\n    function isInvalid(name) {\n      return !regexp.test(name);\n    }\n    /**\n     * Checks if a parent of a node is an ObjectPattern.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} if the node is inside an ObjectPattern\n     * @private\n     */\n\n\n    function isInsideObjectPattern(node) {\n      let {\n        parent\n      } = node;\n\n      while (parent) {\n        if (parent.type === \"ObjectPattern\") {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Verifies if we should report an error or not based on the effective\n     * parent node and the identifier name.\n     * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n     * @param {string} name The identifier name of the identifier node\n     * @returns {boolean} whether an error should be reported or not\n     */\n\n\n    function shouldReport(effectiveParent, name) {\n      return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n    }\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node) {\n      if (!reported.has(node)) {\n        context.report({\n          node,\n          messageId: \"notMatch\",\n          data: {\n            name: node.name,\n            pattern\n          }\n        });\n        reported.set(node, true);\n      }\n    }\n\n    return {\n      Identifier(node) {\n        const name = node.name,\n              parent = node.parent,\n              effectiveParent = parent.type === \"MemberExpression\" ? parent.parent : parent;\n\n        if (parent.type === \"MemberExpression\") {\n          if (!properties) {\n            return;\n          } // Always check object names\n\n\n          if (parent.object.type === \"Identifier\" && parent.object.name === name) {\n            if (isInvalid(name)) {\n              report(node);\n            } // Report AssignmentExpressions left side's assigned variable id\n\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name) {\n            if (isInvalid(name)) {\n              report(node);\n            } // Report AssignmentExpressions only if they are the left side of the assignment\n\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n            if (isInvalid(name)) {\n              report(node);\n            }\n          }\n          /*\n           * Properties have their own rules, and\n           * AssignmentPattern nodes can be treated like Properties:\n           * e.g.: const { no_camelcased = false } = bar;\n           */\n\n        } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n          if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n            if (parent.shorthand && parent.value.left && isInvalid(name)) {\n              report(node);\n            }\n\n            const assignmentKeyEqualsValue = parent.key.name === parent.value.name; // prevent checking righthand side of destructured object\n\n            if (!assignmentKeyEqualsValue && parent.key === node) {\n              return;\n            }\n\n            const valueIsInvalid = parent.value.name && isInvalid(name); // ignore destructuring if the option is set, unless a new identifier is created\n\n            if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          } // never check properties or always ignore destructuring\n\n\n          if (!properties || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          } // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n\n\n          if (parent.right !== node && shouldReport(effectiveParent, name)) {\n            report(node);\n          } // Check if it's an import specifier\n\n        } else if (IMPORT_TYPES.has(parent.type)) {\n          // Report only if the local imported identifier is invalid\n          if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n            report(node);\n          } // Report anything that is invalid that isn't a CallExpression\n\n        } else if (shouldReport(effectiveParent, name)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/id-match.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","default","onlyDeclarations","ignoreDestructuring","messages","notMatch","create","context","pattern","options","regexp","RegExp","reported","Map","ALLOWED_PARENT_TYPES","Set","DECLARATION_TYPES","IMPORT_TYPES","isInvalid","name","test","isInsideObjectPattern","node","parent","shouldReport","effectiveParent","has","report","messageId","data","set","Identifier","object","left","property","right","shorthand","value","assignmentKeyEqualsValue","key","valueIsInvalid","local"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require identifiers to match a specified regular expression\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-match\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyDeclarations: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                }\n            }\n        ],\n        messages: {\n            notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Options\n        //--------------------------------------------------------------------------\n        const pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern, \"u\");\n\n        const options = context.options[1] || {},\n            properties = !!options.properties,\n            onlyDeclarations = !!options.onlyDeclarations,\n            ignoreDestructuring = !!options.ignoreDestructuring;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = new Map();\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n        const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n        const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let { parent } = node;\n\n            while (parent) {\n                if (parent.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) &&\n                !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reported.has(node)) {\n                context.report({\n                    node,\n                    messageId: \"notMatch\",\n                    data: {\n                        name: node.name,\n                        pattern\n                    }\n                });\n                reported.set(node, true);\n            }\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!properties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions left side's assigned variable id\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n\n                    if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n                        if (parent.shorthand && parent.value.left && isInvalid(name)) {\n\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n                        // prevent checking righthand side of destructured object\n                        if (!assignmentKeyEqualsValue && parent.key === node) {\n                            return;\n                        }\n\n                        const valueIsInvalid = parent.value.name && isInvalid(name);\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // never check properties or always ignore destructuring\n                    if (!properties || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (parent.right !== node && shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if (IMPORT_TYPES.has(parent.type)) {\n\n                    // Report only if the local imported identifier is invalid\n                    if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is invalid that isn't a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}