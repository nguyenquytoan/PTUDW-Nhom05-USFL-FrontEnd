{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nvar utils = require('./utils');\n\nvar del = require('./del');\n\nvar writeJSON = utils.writeJSON;\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, './.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n    me.load(fName, dir);\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n    var keys = Object.keys(me._visited); // no keys visited for either get or set value\n\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    var me = this;\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me.removeCacheFile();\n  }\n};\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\n  * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n  * cache storage.\n  *\n  * @method create\n  * @param docId {String} the id of the cache, would also be used as the name of the file cache\n  * @param [cacheDir] {String} directory for the cache entry\n  * @returns {cache} cache instance\n  */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, './.cache/', docId);\n    return del(filePath);\n  },\n\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, './.cache/');\n    return del(filePath);\n  }\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/flat-cache/cache.js"],"names":["path","require","fs","utils","del","writeJSON","cache","load","docId","cacheDir","me","_visited","_persisted","_pathToFile","resolve","__dirname","existsSync","tryParse","loadFile","pathToFile","dir","dirname","fName","basename","all","keys","Object","setKey","key","value","removeKey","getKey","_prune","obj","length","forEach","save","noPrune","removeCacheFile","destroy","module","exports","create","createFromFile","filePath","clearCacheById","clearAll"],"mappings":"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","sourcesContent":["var path = require( 'path' );\nvar fs = require( 'fs' );\nvar utils = require( './utils' );\nvar del = require( './del' );\nvar writeJSON = utils.writeJSON;\n\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function ( docId, cacheDir ) {\n    var me = this;\n\n    me._visited = { };\n    me._persisted = { };\n    me._pathToFile = cacheDir ? path.resolve( cacheDir, docId ) : path.resolve( __dirname, './.cache/', docId );\n\n    if ( fs.existsSync( me._pathToFile ) ) {\n      me._persisted = utils.tryParse( me._pathToFile, { } );\n    }\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function ( pathToFile ) {\n    var me = this;\n    var dir = path.dirname( pathToFile );\n    var fName = path.basename( pathToFile );\n\n    me.load( fName, dir );\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n\n  keys: function () {\n    return Object.keys( this._persisted );\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function ( key, value ) {\n    this._visited[ key ] = true;\n    this._persisted[ key ] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function ( key ) {\n    delete this._visited[ key ]; // esfmt-ignore-line\n    delete this._persisted[ key ]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function ( key ) {\n    this._visited[ key ] = true;\n    return this._persisted[ key ];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = { };\n\n    var keys = Object.keys( me._visited );\n\n    // no keys visited for either get or set value\n    if ( keys.length === 0 ) {\n      return;\n    }\n\n    keys.forEach( function ( key ) {\n      obj[ key ] = me._persisted[ key ];\n    } );\n\n    me._visited = { };\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function ( noPrune ) {\n    var me = this;\n\n    (!noPrune) && me._prune();\n    writeJSON( me._pathToFile, me._persisted );\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del( this._pathToFile );\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = { };\n    me._persisted = { };\n\n    me.removeCacheFile();\n  }\n};\n\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function ( docId, cacheDir ) {\n    return this.create( docId, cacheDir );\n  },\n\n  /**\n  * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n  * cache storage.\n  *\n  * @method create\n  * @param docId {String} the id of the cache, would also be used as the name of the file cache\n  * @param [cacheDir] {String} directory for the cache entry\n  * @returns {cache} cache instance\n  */\n  create: function ( docId, cacheDir ) {\n    var obj = Object.create( cache );\n    obj.load( docId, cacheDir );\n    return obj;\n  },\n\n  createFromFile: function ( filePath ) {\n    var obj = Object.create( cache );\n    obj.loadFile( filePath );\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function ( docId, cacheDir ) {\n    var filePath = cacheDir ? path.resolve( cacheDir, docId ) : path.resolve( __dirname, './.cache/', docId );\n    return del( filePath );\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function ( cacheDir ) {\n    var filePath = cacheDir ? path.resolve( cacheDir ) : path.resolve( __dirname, './.cache/' );\n    return del( filePath );\n  }\n};\n"]},"metadata":{},"sourceType":"script"}