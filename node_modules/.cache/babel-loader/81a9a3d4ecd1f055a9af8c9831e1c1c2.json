{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\n\n\nfunction checkMetaProperty(node, metaName, propertyName) {\n  return node.meta.name === metaName && node.property.name === propertyName;\n}\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\n\n\nfunction getVariableOfArguments(scope) {\n  const variables = scope.variables;\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n\n    if (variable.name === \"arguments\") {\n      /*\n       * If there was a parameter which is named \"arguments\", the\n       * implicit \"arguments\" is not defined.\n       * So does fast return with null.\n       */\n      return variable.identifiers.length === 0 ? variable : null;\n    }\n  }\n  /* istanbul ignore next */\n\n\n  return null;\n}\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\n\n\nfunction getCallbackInfo(node) {\n  const retv = {\n    isCallback: false,\n    isLexicalThis: false\n  };\n  let currentNode = node;\n  let parent = node.parent;\n\n  while (currentNode) {\n    switch (parent.type) {\n      // Checks parents recursively.\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n        break;\n      // Checks whether the parent node is `.bind(this)` call.\n\n      case \"MemberExpression\":\n        if (parent.object === currentNode && !parent.property.computed && parent.property.type === \"Identifier\" && parent.property.name === \"bind\" && parent.parent.type === \"CallExpression\" && parent.parent.callee === parent) {\n          retv.isLexicalThis = parent.parent.arguments.length === 1 && parent.parent.arguments[0].type === \"ThisExpression\";\n          parent = parent.parent;\n        } else {\n          return retv;\n        }\n\n        break;\n      // Checks whether the node is a callback.\n\n      case \"CallExpression\":\n      case \"NewExpression\":\n        if (parent.callee !== currentNode) {\n          retv.isCallback = true;\n        }\n\n        return retv;\n\n      default:\n        return retv;\n    }\n\n    currentNode = parent;\n    parent = parent.parent;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"unreachable\");\n}\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\n\n\nfunction hasDuplicateParams(paramsList) {\n  return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require using arrow functions for callbacks\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowNamedFunctions: {\n          type: \"boolean\",\n          default: false\n        },\n        allowUnboundThis: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n\n    const allowNamedFunctions = options.allowNamedFunctions;\n    const sourceCode = context.getSourceCode();\n    /*\n     * {Array<{this: boolean, super: boolean, meta: boolean}>}\n     * - this - A flag which shows there are one or more ThisExpression.\n     * - super - A flag which shows there are one or more Super.\n     * - meta - A flag which shows there are one or more MethProperty.\n     */\n\n    let stack = [];\n    /**\n     * Pushes new function scope with all `false` flags.\n     * @returns {void}\n     */\n\n    function enterScope() {\n      stack.push({\n        this: false,\n        super: false,\n        meta: false\n      });\n    }\n    /**\n     * Pops a function scope from the stack.\n     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n     */\n\n\n    function exitScope() {\n      return stack.pop();\n    }\n\n    return {\n      // Reset internal state.\n      Program() {\n        stack = [];\n      },\n\n      // If there are below, it cannot replace with arrow functions merely.\n      ThisExpression() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.this = true;\n        }\n      },\n\n      Super() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.super = true;\n        }\n      },\n\n      MetaProperty(node) {\n        const info = stack[stack.length - 1];\n\n        if (info && checkMetaProperty(node, \"new\", \"target\")) {\n          info.meta = true;\n        }\n      },\n\n      // To skip nested scopes.\n      FunctionDeclaration: enterScope,\n      \"FunctionDeclaration:exit\": exitScope,\n      // Main.\n      FunctionExpression: enterScope,\n\n      \"FunctionExpression:exit\"(node) {\n        const scopeInfo = exitScope(); // Skip named function expressions\n\n        if (allowNamedFunctions && node.id && node.id.name) {\n          return;\n        } // Skip generators.\n\n\n        if (node.generator) {\n          return;\n        } // Skip recursive functions.\n\n\n        const nameVar = context.getDeclaredVariables(node)[0];\n\n        if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n          return;\n        } // Skip if it's using arguments.\n\n\n        const variable = getVariableOfArguments(context.getScope());\n\n        if (variable && variable.references.length > 0) {\n          return;\n        } // Reports if it's a callback which can replace with arrows.\n\n\n        const callbackInfo = getCallbackInfo(node);\n\n        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {\n          context.report({\n            node,\n            message: \"Unexpected function expression.\",\n\n            fix(fixer) {\n              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {\n                /*\n                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                 * is no way to determine what `this` should be, so don't perform any fixes.\n                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                 */\n                return null;\n              }\n\n              const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);\n              const paramsRightParen = sourceCode.getTokenBefore(node.body);\n              const asyncKeyword = node.async ? \"async \" : \"\";\n              const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);\n              const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;\n              /*\n               * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.\n               * Otherwise, just replace the arrow function itself.\n               */\n\n              const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n              /*\n               * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n               * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n               * though `foo || function() {}` is valid.\n               */\n\n              const needsParens = replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\";\n              const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;\n              return fixer.replaceText(replacedNode, replacementText);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-arrow-callback.js"],"names":["isFunctionName","variable","defs","type","checkMetaProperty","node","metaName","propertyName","meta","name","property","getVariableOfArguments","scope","variables","i","length","identifiers","getCallbackInfo","retv","isCallback","isLexicalThis","currentNode","parent","object","computed","callee","arguments","Error","hasDuplicateParams","paramsList","every","param","Set","map","size","module","exports","docs","description","category","recommended","url","schema","properties","allowNamedFunctions","default","allowUnboundThis","additionalProperties","fixable","create","context","options","sourceCode","getSourceCode","stack","enterScope","push","this","super","exitScope","pop","Program","ThisExpression","info","Super","MetaProperty","FunctionDeclaration","FunctionExpression","scopeInfo","id","generator","nameVar","getDeclaredVariables","references","getScope","callbackInfo","report","message","fix","fixer","params","paramsLeftParen","getTokenBefore","body","paramsRightParen","asyncKeyword","async","paramsFullText","text","slice","range","arrowFunctionText","getText","replacedNode","needsParens","replacementText","replaceText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let currentNode = node;\n    let parent = node.parent;\n\n    while (currentNode) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (parent.object === currentNode &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\" &&\n                    parent.parent.type === \"CallExpression\" &&\n                    parent.parent.callee === parent\n                ) {\n                    retv.isLexicalThis = (\n                        parent.parent.arguments.length === 1 &&\n                        parent.parent.arguments[0].type === \"ThisExpression\"\n                    );\n                    parent = parent.parent;\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== currentNode) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        currentNode = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using arrow functions for callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        message: \"Unexpected function expression.\",\n                        fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                /*\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                 */\n                                return null;\n                            }\n\n                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);\n                            const paramsRightParen = sourceCode.getTokenBefore(node.body);\n                            const asyncKeyword = node.async ? \"async \" : \"\";\n                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);\n                            const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;\n\n                            /*\n                             * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.\n                             * Otherwise, just replace the arrow function itself.\n                             */\n                            const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            const needsParens = replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\";\n                            const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;\n\n                            return fixer.replaceText(replacedNode, replacementText);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}