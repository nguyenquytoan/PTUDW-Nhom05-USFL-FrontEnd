{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar valueParser = _interopDefault(require('postcss-values-parser'));\n\nvar fs = _interopDefault(require('fs'));\n\nvar path = _interopDefault(require('path'));\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar convertColors = require('@csstools/convert-colors');\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction getCustomProperties(root, opts) {\n  // initialize custom selectors\n  const customPropertiesFromHtmlElement = {};\n  const customPropertiesFromRootPsuedo = {}; // for each html or :root rule\n\n  root.nodes.slice().forEach(rule => {\n    const customPropertiesObject = isHtmlRule(rule) ? customPropertiesFromHtmlElement : isRootRule(rule) ? customPropertiesFromRootPsuedo : null; // for each custom property\n\n    if (customPropertiesObject) {\n      rule.nodes.slice().forEach(decl => {\n        if (isCustomDecl(decl)) {\n          const prop = decl.prop; // write the parsed value to the custom property\n\n          customPropertiesObject[prop] = valueParser(decl.value).parse(); // conditionally remove the custom property declaration\n\n          if (!opts.preserve) {\n            decl.remove();\n          }\n        }\n      }); // conditionally remove the empty html or :root rule\n\n      if (!opts.preserve && isEmptyParent(rule)) {\n        rule.remove();\n      }\n    }\n  }); // return all custom properties, preferring :root properties over html properties\n\n  return _objectSpread({}, customPropertiesFromHtmlElement, customPropertiesFromRootPsuedo);\n} // match html and :root rules\n\n\nconst htmlSelectorRegExp = /^html$/i;\nconst rootSelectorRegExp = /^:root$/i;\nconst customPropertyRegExp = /^--[A-z][\\w-]*$/; // whether the node is an html or :root rule\n\nconst isHtmlRule = node => node.type === 'rule' && htmlSelectorRegExp.test(node.selector) && Object(node.nodes).length;\n\nconst isRootRule = node => node.type === 'rule' && rootSelectorRegExp.test(node.selector) && Object(node.nodes).length; // whether the node is an custom property\n\n\nconst isCustomDecl = node => node.type === 'decl' && customPropertyRegExp.test(node.prop); // whether the node is a parent without children\n\n\nconst isEmptyParent = node => Object(node.nodes).length === 0;\n/* Import Custom Properties from CSS AST\n/* ========================================================================== */\n\n\nfunction importCustomPropertiesFromCSSAST(root) {\n  return getCustomProperties(root, {\n    preserve: true\n  });\n}\n/* Import Custom Properties from CSS File\n/* ========================================================================== */\n\n\nfunction importCustomPropertiesFromCSSFile(_x) {\n  return _importCustomPropertiesFromCSSFile.apply(this, arguments);\n}\n/* Import Custom Properties from Object\n/* ========================================================================== */\n\n\nfunction _importCustomPropertiesFromCSSFile() {\n  _importCustomPropertiesFromCSSFile = _asyncToGenerator(function* (from) {\n    const css = yield readFile(from);\n    const root = postcss.parse(css, {\n      from\n    });\n    return importCustomPropertiesFromCSSAST(root);\n  });\n  return _importCustomPropertiesFromCSSFile.apply(this, arguments);\n}\n\nfunction importCustomPropertiesFromObject(object) {\n  const customProperties = Object.assign({}, Object(object).customProperties || Object(object)['custom-properties']);\n\n  for (const prop in customProperties) {\n    customProperties[prop] = valueParser(customProperties[prop]).parse();\n  }\n\n  return customProperties;\n}\n/* Import Custom Properties from JSON file\n/* ========================================================================== */\n\n\nfunction importCustomPropertiesFromJSONFile(_x2) {\n  return _importCustomPropertiesFromJSONFile.apply(this, arguments);\n}\n/* Import Custom Properties from JS file\n/* ========================================================================== */\n\n\nfunction _importCustomPropertiesFromJSONFile() {\n  _importCustomPropertiesFromJSONFile = _asyncToGenerator(function* (from) {\n    const object = yield readJSON(from);\n    return importCustomPropertiesFromObject(object);\n  });\n  return _importCustomPropertiesFromJSONFile.apply(this, arguments);\n}\n\nfunction importCustomPropertiesFromJSFile(_x3) {\n  return _importCustomPropertiesFromJSFile.apply(this, arguments);\n}\n/* Import Custom Properties from Sources\n/* ========================================================================== */\n\n\nfunction _importCustomPropertiesFromJSFile() {\n  _importCustomPropertiesFromJSFile = _asyncToGenerator(function* (from) {\n    const object = yield Promise.resolve(require(from));\n    return importCustomPropertiesFromObject(object);\n  });\n  return _importCustomPropertiesFromJSFile.apply(this, arguments);\n}\n\nfunction importCustomPropertiesFromSources(sources) {\n  return sources.map(source => {\n    if (source instanceof Promise) {\n      return source;\n    } else if (source instanceof Function) {\n      return source();\n    } // read the source as an object\n\n\n    const opts = source === Object(source) ? source : {\n      from: String(source)\n    }; // skip objects with Custom Properties\n\n    if (opts.customProperties || opts['custom-properties']) {\n      return opts;\n    } // source pathname\n\n\n    const from = path.resolve(String(opts.from || '')); // type of file being read from\n\n    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n    return {\n      type,\n      from\n    };\n  }).reduce( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (customProperties, source) {\n      const _ref2 = yield source,\n            type = _ref2.type,\n            from = _ref2.from;\n\n      if (type === 'ast') {\n        return Object.assign(yield customProperties, importCustomPropertiesFromCSSAST(from));\n      }\n\n      if (type === 'css') {\n        return Object.assign(yield customProperties, yield importCustomPropertiesFromCSSFile(from));\n      }\n\n      if (type === 'js') {\n        return Object.assign(yield customProperties, yield importCustomPropertiesFromJSFile(from));\n      }\n\n      if (type === 'json') {\n        return Object.assign(yield customProperties, yield importCustomPropertiesFromJSONFile(from));\n      }\n\n      return Object.assign(yield customProperties, yield importCustomPropertiesFromObject(yield source));\n    });\n\n    return function (_x4, _x5) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {});\n}\n/* Helper utilities\n/* ========================================================================== */\n\n\nconst readFile = from => new Promise((resolve, reject) => {\n  fs.readFile(from, 'utf8', (error, result) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst readJSON = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (from) {\n    return JSON.parse(yield readFile(from));\n  });\n\n  return function readJSON(_x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/* Convert Degree to Hue Degree\n/* ========================================================================== */\n\n\nfunction convertDtoD(deg) {\n  return deg % 360;\n}\n/* Convert Gradian to Hue Degree\n/* ========================================================================== */\n\n\nfunction convertGtoD(grad) {\n  return grad * 0.9 % 360;\n}\n/* Convert Radian to Hue Degree\n/* ========================================================================== */\n\n\nfunction convertRtoD(rad) {\n  return rad * 180 / Math.PI % 360;\n}\n/* Convert Turn to Hue Degree\n/* ========================================================================== */\n\n\nfunction convertTtoD(turn) {\n  return turn * 360 % 360;\n}\n/* Convert a Name to Red/Green/Blue\n/* ========================================================================== */\n\n\nfunction convertNtoRGB(name) {\n  const names = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    transparent: [0, 0, 0],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  };\n  return names[name] && names[name].map(c => c / 2.55);\n}\n/* Convert a Hex to Red/Green/Blue\n/* ========================================================================== */\n\n\nfunction convertHtoRGB(hex) {\n  // #<hex-color>{3,4,6,8}\n  const _slice = (hex.match(hexColorMatch) || []).slice(1),\n        _slice2 = _slicedToArray(_slice, 8),\n        r = _slice2[0],\n        g = _slice2[1],\n        b = _slice2[2],\n        a = _slice2[3],\n        rr = _slice2[4],\n        gg = _slice2[5],\n        bb = _slice2[6],\n        aa = _slice2[7];\n\n  if (rr !== undefined || r !== undefined) {\n    const red = rr !== undefined ? parseInt(rr, 16) : r !== undefined ? parseInt(r + r, 16) : 0;\n    const green = gg !== undefined ? parseInt(gg, 16) : g !== undefined ? parseInt(g + g, 16) : 0;\n    const blue = bb !== undefined ? parseInt(bb, 16) : b !== undefined ? parseInt(b + b, 16) : 0;\n    const alpha = aa !== undefined ? parseInt(aa, 16) : a !== undefined ? parseInt(a + a, 16) : 255;\n    return [red, green, blue, alpha].map(c => c / 2.55);\n  }\n\n  return undefined;\n}\n\nconst hexColorMatch = /^#(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i;\n\nclass Color {\n  constructor(color) {\n    this.color = Object(Object(color).color || color);\n    this.color.colorspace = this.color.colorspace ? this.color.colorspace : 'red' in color && 'green' in color && 'blue' in color ? 'rgb' : 'hue' in color && 'saturation' in color && 'lightness' in color ? 'hsl' : 'hue' in color && 'whiteness' in color && 'blackness' in color ? 'hwb' : 'unknown';\n\n    if (color.colorspace === 'rgb') {\n      this.color.hue = convertColors.rgb2hue(color.red, color.green, color.blue, color.hue || 0);\n    }\n  }\n\n  alpha(alpha) {\n    const color = this.color;\n    return alpha === undefined ? color.alpha : new Color(assign(color, {\n      alpha\n    }));\n  }\n\n  blackness(blackness) {\n    const hwb = color2hwb(this.color);\n    return blackness === undefined ? hwb.blackness : new Color(assign(hwb, {\n      blackness\n    }));\n  }\n\n  blend(color, percentage, colorspace = 'rgb') {\n    const base = this.color;\n    return new Color(blend(base, color, percentage, colorspace));\n  }\n\n  blenda(color, percentage, colorspace = 'rgb') {\n    const base = this.color;\n    return new Color(blend(base, color, percentage, colorspace, true));\n  }\n\n  blue(blue) {\n    const rgb = color2rgb(this.color);\n    return blue === undefined ? rgb.blue : new Color(assign(rgb, {\n      blue\n    }));\n  }\n\n  contrast(percentage) {\n    const base = this.color;\n    return new Color(contrast(base, percentage));\n  }\n\n  green(green) {\n    const rgb = color2rgb(this.color);\n    return green === undefined ? rgb.green : new Color(assign(rgb, {\n      green\n    }));\n  }\n\n  hue(hue) {\n    const hsl = color2hsl(this.color);\n    return hue === undefined ? hsl.hue : new Color(assign(hsl, {\n      hue\n    }));\n  }\n\n  lightness(lightness) {\n    const hsl = color2hsl(this.color);\n    return lightness === undefined ? hsl.lightness : new Color(assign(hsl, {\n      lightness\n    }));\n  }\n\n  red(red) {\n    const rgb = color2rgb(this.color);\n    return red === undefined ? rgb.red : new Color(assign(rgb, {\n      red\n    }));\n  }\n\n  rgb(red, green, blue) {\n    const rgb = color2rgb(this.color);\n    return new Color(assign(rgb, {\n      red,\n      green,\n      blue\n    }));\n  }\n\n  saturation(saturation) {\n    const hsl = color2hsl(this.color);\n    return saturation === undefined ? hsl.saturation : new Color(assign(hsl, {\n      saturation\n    }));\n  }\n\n  shade(percentage) {\n    const hwb = color2hwb(this.color);\n    const shade = {\n      hue: 0,\n      whiteness: 0,\n      blackness: 100,\n      colorspace: 'hwb'\n    };\n    const colorspace = 'rgb';\n    return percentage === undefined ? hwb.blackness : new Color(blend(hwb, shade, percentage, colorspace));\n  }\n\n  tint(percentage) {\n    const hwb = color2hwb(this.color);\n    const tint = {\n      hue: 0,\n      whiteness: 100,\n      blackness: 0,\n      colorspace: 'hwb'\n    };\n    const colorspace = 'rgb';\n    return percentage === undefined ? hwb.blackness : new Color(blend(hwb, tint, percentage, colorspace));\n  }\n\n  whiteness(whiteness) {\n    const hwb = color2hwb(this.color);\n    return whiteness === undefined ? hwb.whiteness : new Color(assign(hwb, {\n      whiteness\n    }));\n  }\n\n  toHSL() {\n    return color2hslString(this.color);\n  }\n\n  toHWB() {\n    return color2hwbString(this.color);\n  }\n\n  toLegacy() {\n    return color2legacyString(this.color);\n  }\n\n  toRGB() {\n    return color2rgbString(this.color);\n  }\n\n  toRGBLegacy() {\n    return color2rgbLegacyString(this.color);\n  }\n\n  toString() {\n    return color2string(this.color);\n  }\n\n}\n/* Blending\n/* ========================================================================== */\n\n\nfunction blend(base, color, percentage, colorspace, isBlendingAlpha) {\n  const addition = percentage / 100;\n  const subtraction = 1 - addition;\n\n  if (colorspace === 'hsl') {\n    const _color2hsl = color2hsl(base),\n          h1 = _color2hsl.hue,\n          s1 = _color2hsl.saturation,\n          l1 = _color2hsl.lightness,\n          a1 = _color2hsl.alpha;\n\n    const _color2hsl2 = color2hsl(color),\n          h2 = _color2hsl2.hue,\n          s2 = _color2hsl2.saturation,\n          l2 = _color2hsl2.lightness,\n          a2 = _color2hsl2.alpha;\n\n    const hue = h1 * subtraction + h2 * addition,\n          saturation = s1 * subtraction + s2 * addition,\n          lightness = l1 * subtraction + l2 * addition,\n          alpha = isBlendingAlpha ? a1 * subtraction + a2 * addition : a1;\n    return {\n      hue,\n      saturation,\n      lightness,\n      alpha,\n      colorspace: 'hsl'\n    };\n  } else if (colorspace === 'hwb') {\n    const _color2hwb = color2hwb(base),\n          h1 = _color2hwb.hue,\n          w1 = _color2hwb.whiteness,\n          b1 = _color2hwb.blackness,\n          a1 = _color2hwb.alpha;\n\n    const _color2hwb2 = color2hwb(color),\n          h2 = _color2hwb2.hue,\n          w2 = _color2hwb2.whiteness,\n          b2 = _color2hwb2.blackness,\n          a2 = _color2hwb2.alpha;\n\n    const hue = h1 * subtraction + h2 * addition,\n          whiteness = w1 * subtraction + w2 * addition,\n          blackness = b1 * subtraction + b2 * addition,\n          alpha = isBlendingAlpha ? a1 * subtraction + a2 * addition : a1;\n    return {\n      hue,\n      whiteness,\n      blackness,\n      alpha,\n      colorspace: 'hwb'\n    };\n  } else {\n    const _color2rgb = color2rgb(base),\n          r1 = _color2rgb.red,\n          g1 = _color2rgb.green,\n          b1 = _color2rgb.blue,\n          a1 = _color2rgb.alpha;\n\n    const _color2rgb2 = color2rgb(color),\n          r2 = _color2rgb2.red,\n          g2 = _color2rgb2.green,\n          b2 = _color2rgb2.blue,\n          a2 = _color2rgb2.alpha;\n\n    const red = r1 * subtraction + r2 * addition,\n          green = g1 * subtraction + g2 * addition,\n          blue = b1 * subtraction + b2 * addition,\n          alpha = isBlendingAlpha ? a1 * subtraction + a2 * addition : a1;\n    return {\n      red,\n      green,\n      blue,\n      alpha,\n      colorspace: 'rgb'\n    };\n  }\n}\n/* Assign channels to a new instance of a base color\n/* ========================================================================== */\n\n\nfunction assign(base, channels) {\n  const color = Object.assign({}, base);\n  Object.keys(channels).forEach(channel => {\n    // detect channel\n    const isHue = channel === 'hue';\n    const isRGB = !isHue && blueGreenRedMatch.test(channel); // normalized value of the channel\n\n    const value = normalize(channels[channel], channel); // assign channel to new object\n\n    color[channel] = value;\n\n    if (isRGB) {\n      // conditionally preserve the hue\n      color.hue = convertColors.rgb2hue(color.red, color.green, color.blue, base.hue || 0);\n    }\n  });\n  return color;\n}\n\nfunction normalize(value, channel) {\n  // detect channel\n  const isHue = channel === 'hue'; // value limitations\n\n  const min = 0;\n  const max = isHue ? 360 : 100;\n  const normalizedValue = Math.min(Math.max(isHue ? value % 360 : value, min), max);\n  return normalizedValue;\n}\n/* Convert colors\n/* ========================================================================== */\n\n\nfunction color2rgb(color) {\n  const _ref = color.colorspace === 'hsl' ? convertColors.hsl2rgb(color.hue, color.saturation, color.lightness) : color.colorspace === 'hwb' ? convertColors.hwb2rgb(color.hue, color.whiteness, color.blackness) : [color.red, color.green, color.blue],\n        _ref2 = _slicedToArray(_ref, 3),\n        red = _ref2[0],\n        green = _ref2[1],\n        blue = _ref2[2];\n\n  return {\n    red,\n    green,\n    blue,\n    hue: color.hue,\n    alpha: color.alpha,\n    colorspace: 'rgb'\n  };\n}\n\nfunction color2hsl(color) {\n  const _ref3 = color.colorspace === 'rgb' ? convertColors.rgb2hsl(color.red, color.green, color.blue, color.hue) : color.colorspace === 'hwb' ? convertColors.hwb2hsl(color.hue, color.whiteness, color.blackness) : [color.hue, color.saturation, color.lightness],\n        _ref4 = _slicedToArray(_ref3, 3),\n        hue = _ref4[0],\n        saturation = _ref4[1],\n        lightness = _ref4[2];\n\n  return {\n    hue,\n    saturation,\n    lightness,\n    alpha: color.alpha,\n    colorspace: 'hsl'\n  };\n}\n\nfunction color2hwb(color) {\n  const _ref5 = color.colorspace === 'rgb' ? convertColors.rgb2hwb(color.red, color.green, color.blue, color.hue) : color.colorspace === 'hsl' ? convertColors.hsl2hwb(color.hue, color.saturation, color.lightness) : [color.hue, color.whiteness, color.blackness],\n        _ref6 = _slicedToArray(_ref5, 3),\n        hue = _ref6[0],\n        whiteness = _ref6[1],\n        blackness = _ref6[2];\n\n  return {\n    hue,\n    whiteness,\n    blackness,\n    alpha: color.alpha,\n    colorspace: 'hwb'\n  };\n}\n/* Contrast functions\n/* ========================================================================== */\n\n\nfunction contrast(color, percentage) {\n  // https://drafts.csswg.org/css-color/#contrast-adjuster\n  const hwb = color2hwb(color);\n  const rgb = color2rgb(color); // compute the luminance of the color.\n\n  const luminance = rgb2luminance(rgb.red, rgb.green, rgb.blue); // the maximum-contrast color, if it is less than .5\n\n  const maxContrastColor = luminance < 0.5 // hwb(X, 100%, 0%), where X is the hue angle of the color\n  ? {\n    hue: hwb.hue,\n    whiteness: 100,\n    blackness: 0,\n    alpha: hwb.alpha,\n    colorspace: 'hwb' // otherwise, hwb(X, 0%, 100%), where X is the hue angle of the color\n\n  } : {\n    hue: hwb.hue,\n    whiteness: 0,\n    blackness: 100,\n    alpha: hwb.alpha,\n    colorspace: 'hwb'\n  }; // contrast ratio\n\n  const contrastRatio = colors2contrast(color, maxContrastColor);\n  const minContrastColor = contrastRatio > 4.5 // the color with the smallest contrast ratio with the base color that is greater than 4.5\n  ? colors2contrastRatioColor(hwb, maxContrastColor) // otherwise, the maximum-contrast color\n  : maxContrastColor; // color(maximum-contrast blend(minimum-contrast <percentage> hwb)));\n\n  return blend(maxContrastColor, minContrastColor, percentage, 'hwb', false);\n}\n\nfunction colors2contrast(color1, color2) {\n  // https://drafts.csswg.org/css-color/#contrast-ratio\n  const rgb1 = color2rgb(color1);\n  const rgb2 = color2rgb(color2);\n  const l1 = rgb2luminance(rgb1.red, rgb1.green, rgb1.blue);\n  const l2 = rgb2luminance(rgb2.red, rgb2.green, rgb2.blue);\n  return l1 > l2 // if l1 is the relative luminance of the lighter of the colors\n  ? (l1 + 0.05) / (l2 + 0.05) // otherwise, if l2 is the relative luminance of the lighter of the colors\n  : (l2 + 0.05) / (l1 + 0.05);\n}\n\nfunction rgb2luminance(red, green, blue) {\n  const _ref7 = [channel2luminance(red), channel2luminance(green), channel2luminance(blue)],\n        redLuminance = _ref7[0],\n        greenLuminance = _ref7[1],\n        blueLuminance = _ref7[2]; // https://drafts.csswg.org/css-color/#luminance\n\n  const luminance = 0.2126 * redLuminance + 0.7152 * greenLuminance + 0.0722 * blueLuminance;\n  return luminance;\n}\n\nfunction channel2luminance(value) {\n  // https://drafts.csswg.org/css-color/#luminance\n  const luminance = value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);\n  return luminance;\n} // return the smallest contrast ratio from a color and a maximum contrast (credit: @thetalecrafter)\n\n\nfunction colors2contrastRatioColor(hwb, maxHWB) {\n  const modifiedHWB = Object.assign({}, hwb); // values to be used for linear interpolations in HWB space\n\n  let minW = hwb.whiteness;\n  let minB = hwb.blackness;\n  let maxW = maxHWB.whiteness;\n  let maxB = maxHWB.blackness; // find the color with the smallest contrast ratio with the base color that is greater than 4.5\n\n  while (Math.abs(minW - maxW) > 100 || Math.abs(minB - maxB) > 100) {\n    const midW = Math.round((maxW + minW) / 2);\n    const midB = Math.round((maxB + minB) / 2);\n    modifiedHWB.whiteness = midW;\n    modifiedHWB.blackness = midB;\n\n    if (colors2contrast(modifiedHWB, hwb) > 4.5) {\n      maxW = midW;\n      maxB = midB;\n    } else {\n      minW = midW;\n      minB = midB;\n    }\n  }\n\n  return modifiedHWB;\n}\n/* Match\n/* ========================================================================== */\n\n\nconst blueGreenRedMatch = /^(blue|green|red)$/i;\n/* Stringifiers\n/* ========================================================================== */\n\nfunction color2string(color) {\n  return color.colorspace === 'hsl' ? color2hslString(color) : color.colorspace === 'hwb' ? color2hwbString(color) : color2rgbString(color);\n}\n\nfunction color2hslString(color) {\n  const hsl = color2hsl(color);\n  const isOpaque = hsl.alpha === 100;\n  const hue = hsl.hue;\n  const saturation = Math.round(hsl.saturation * 10000000000) / 10000000000;\n  const lightness = Math.round(hsl.lightness * 10000000000) / 10000000000;\n  const alpha = Math.round(hsl.alpha * 10000000000) / 10000000000;\n  return `hsl(${hue} ${saturation}% ${lightness}%${isOpaque ? '' : ` / ${alpha}%`})`;\n}\n\nfunction color2hwbString(color) {\n  const hwb = color2hwb(color);\n  const isOpaque = hwb.alpha === 100;\n  const hue = hwb.hue;\n  const whiteness = Math.round(hwb.whiteness * 10000000000) / 10000000000;\n  const blackness = Math.round(hwb.blackness * 10000000000) / 10000000000;\n  const alpha = Math.round(hwb.alpha * 10000000000) / 10000000000;\n  return `hwb(${hue} ${whiteness}% ${blackness}%${isOpaque ? '' : ` / ${alpha}%`})`;\n}\n\nfunction color2rgbString(color) {\n  const rgb = color2rgb(color);\n  const isOpaque = rgb.alpha === 100;\n  const red = Math.round(rgb.red * 10000000000) / 10000000000;\n  const green = Math.round(rgb.green * 10000000000) / 10000000000;\n  const blue = Math.round(rgb.blue * 10000000000) / 10000000000;\n  const alpha = Math.round(rgb.alpha * 10000000000) / 10000000000;\n  return `rgb(${red}% ${green}% ${blue}%${isOpaque ? '' : ` / ${alpha}%`})`;\n}\n\nfunction color2legacyString(color) {\n  return color.colorspace === 'hsl' ? color2hslLegacyString(color) : color2rgbLegacyString(color);\n}\n\nfunction color2rgbLegacyString(color) {\n  const rgb = color2rgb(color);\n  const isOpaque = rgb.alpha === 100;\n  const name = isOpaque ? 'rgb' : 'rgba';\n  const red = Math.round(rgb.red * 255 / 100);\n  const green = Math.round(rgb.green * 255 / 100);\n  const blue = Math.round(rgb.blue * 255 / 100);\n  const alpha = Math.round(rgb.alpha / 100 * 10000000000) / 10000000000;\n  return `${name}(${red}, ${green}, ${blue}${isOpaque ? '' : `, ${alpha}`})`;\n}\n\nfunction color2hslLegacyString(color) {\n  const hsl = color2hsl(color);\n  const isOpaque = hsl.alpha === 100;\n  const name = isOpaque ? 'hsl' : 'hsla';\n  const hue = hsl.hue;\n  const saturation = Math.round(hsl.saturation * 10000000000) / 10000000000;\n  const lightness = Math.round(hsl.lightness * 10000000000) / 10000000000;\n  const alpha = Math.round(hsl.alpha / 100 * 10000000000) / 10000000000;\n  return `${name}(${hue}, ${saturation}%, ${lightness}%${isOpaque ? '' : `, ${alpha}`})`;\n}\n\nfunction manageUnresolved(node, opts, word, message) {\n  if ('warn' === opts.unresolved) {\n    opts.decl.warn(opts.result, message, {\n      word\n    });\n  } else if ('ignore' !== opts.unresolved) {\n    throw opts.decl.error(message, {\n      word\n    });\n  }\n}\n/* Transform AST\n/* ========================================================================== */\n\n\nfunction transformAST(node, opts) {\n  node.nodes.slice(0).forEach(child => {\n    if (isColorModFunction(child)) {\n      // transform any variables within the color-mod() function\n      if (opts.transformVars) {\n        transformVariables(child, opts);\n      } // transform any color-mod() functions\n\n\n      const color = transformColorModFunction(child, opts);\n\n      if (color) {\n        // update the color-mod() function with the transformed value\n        child.replaceWith(valueParser.word({\n          raws: child.raws,\n          value: opts.stringifier(color)\n        }));\n      }\n    } else if (child.nodes && Object(child.nodes).length) {\n      transformAST(child, opts);\n    }\n  });\n}\n/* Transform <var> functions\n/* ========================================================================== */\n\n\nfunction transformVariables(node, opts) {\n  walk(node, child => {\n    if (isVariable(child)) {\n      // get the custom property and fallback value from var()\n      const _transformArgsByParam = transformArgsByParams(child, [// <value> , [ <fallback> ]?\n      [transformWord, isComma, transformNode]]),\n            _transformArgsByParam2 = _slicedToArray(_transformArgsByParam, 2),\n            prop = _transformArgsByParam2[0],\n            fallbackNode = _transformArgsByParam2[1]; // if the custom property is known\n\n\n      if (prop in opts.customProperties) {\n        let customPropertyValue = opts.customProperties[prop]; // follow custom properties referencing custom properties\n\n        if (looseVarMatch.test(customPropertyValue)) {\n          const rootChildAST = customPropertyValue.clone();\n          transformVariables(rootChildAST, opts);\n          customPropertyValue = rootChildAST;\n        } // replace var() with the custom property value\n\n\n        if (customPropertyValue.nodes.length === 1 && customPropertyValue.nodes[0].nodes.length) {\n          customPropertyValue.nodes[0].nodes.forEach(customPropertyChild => {\n            child.parent.insertBefore(child, customPropertyChild);\n          });\n        }\n\n        child.remove();\n      } else if (fallbackNode && fallbackNode.nodes.length === 1 && fallbackNode.nodes[0].nodes.length) {\n        // otherwise, replace var() with the fallback value\n        transformVariables(fallbackNode, opts);\n        child.replaceWith(...fallbackNode.nodes[0].nodes[0]);\n      }\n    }\n  });\n}\n/* Transform <color> functions\n/* ========================================================================== */\n\n\nfunction transformColor(node, opts) {\n  if (isRGBFunction(node)) {\n    return transformRGBFunction(node, opts);\n  } else if (isHSLFunction(node)) {\n    return transformHSLFunction(node, opts);\n  } else if (isHWBFunction(node)) {\n    return transformHWBFunction(node, opts);\n  } else if (isColorModFunction(node)) {\n    return transformColorModFunction(node, opts);\n  } else if (isHexColor(node)) {\n    return transformHexColor(node, opts);\n  } else if (isNamedColor(node)) {\n    return transformNamedColor(node, opts);\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a color`);\n  }\n} // return a transformed rgb/rgba color function\n\n\nfunction transformRGBFunction(node, opts) {\n  const _transformArgsByParam3 = transformArgsByParams(node, [// <percentage> <percentage> <percentage> [ , <alpha-value> ]?\n  [transformPercentage, transformPercentage, transformPercentage, isSlash, transformAlpha], // <number> <number> <number> [ , <alpha-value> ]?\n  [transformRGBNumber, transformRGBNumber, transformRGBNumber, isSlash, transformAlpha], // <percentage> , <percentage> , <percentage> [ , <alpha-value> ]?\n  [transformPercentage, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha], // <number> , <number> , <number> [ , <alpha-value> ]?\n  [transformRGBNumber, isComma, transformRGBNumber, isComma, transformRGBNumber, isComma, transformAlpha]]),\n        _transformArgsByParam4 = _slicedToArray(_transformArgsByParam3, 4),\n        red = _transformArgsByParam4[0],\n        green = _transformArgsByParam4[1],\n        blue = _transformArgsByParam4[2],\n        _transformArgsByParam5 = _transformArgsByParam4[3],\n        alpha = _transformArgsByParam5 === void 0 ? 100 : _transformArgsByParam5;\n\n  if (red !== undefined) {\n    const color = new Color({\n      red,\n      green,\n      blue,\n      alpha,\n      colorspace: 'rgb'\n    });\n    return color;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid rgb() function`);\n  }\n} // return a transformed hsl/hsla color function\n\n\nfunction transformHSLFunction(node, opts) {\n  const _transformArgsByParam6 = transformArgsByParams(node, [// <hue> <percentage> <percentage> [ / <alpha-value> ]?\n  [transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha], // <hue> , <percentage> , <percentage> [ , <alpha-value> ]?\n  [transformHue, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha]]),\n        _transformArgsByParam7 = _slicedToArray(_transformArgsByParam6, 4),\n        hue = _transformArgsByParam7[0],\n        saturation = _transformArgsByParam7[1],\n        lightness = _transformArgsByParam7[2],\n        _transformArgsByParam8 = _transformArgsByParam7[3],\n        alpha = _transformArgsByParam8 === void 0 ? 100 : _transformArgsByParam8;\n\n  if (lightness !== undefined) {\n    const color = new Color({\n      hue,\n      saturation,\n      lightness,\n      alpha,\n      colorspace: 'hsl'\n    });\n    return color;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid hsl() function`);\n  }\n} // return a transformed hwb color function\n\n\nfunction transformHWBFunction(node, opts) {\n  const _transformArgsByParam9 = transformArgsByParams(node, [// <hue> <percentage> <percentage> [ / <alpha-value> ]?\n  [transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha]]),\n        _transformArgsByParam10 = _slicedToArray(_transformArgsByParam9, 4),\n        hue = _transformArgsByParam10[0],\n        whiteness = _transformArgsByParam10[1],\n        blackness = _transformArgsByParam10[2],\n        _transformArgsByParam11 = _transformArgsByParam10[3],\n        alpha = _transformArgsByParam11 === void 0 ? 100 : _transformArgsByParam11;\n\n  if (blackness !== undefined) {\n    const color = new Color({\n      hue,\n      whiteness,\n      blackness,\n      alpha,\n      colorspace: 'hwb'\n    });\n    return color;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid hwb() function`);\n  }\n} // return a transformed color-mod color function\n\n\nfunction transformColorModFunction(node, opts) {\n  // [ <color> | <hue> ] <color-adjuster>*\n  const _ref = (node.nodes || []).slice(1, -1) || [],\n        _ref2 = _toArray(_ref),\n        colorOrHueNode = _ref2[0],\n        adjusterNodes = _ref2.slice(1);\n\n  if (colorOrHueNode !== undefined) {\n    const color = isHue(colorOrHueNode) ? new Color({\n      hue: transformHue(colorOrHueNode, opts),\n      saturation: 100,\n      lightness: 50,\n      alpha: 100,\n      colorspace: 'hsl'\n    }) : transformColor(colorOrHueNode, opts);\n\n    if (color) {\n      const adjustedColor = transformColorByAdjusters(color, adjusterNodes, opts);\n      return adjustedColor;\n    } else {\n      return manageUnresolved(node, opts, node.value, `Expected a valid color`);\n    }\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid color-mod() function`);\n  }\n} // return a transformed hex color\n\n\nfunction transformHexColor(node, opts) {\n  if (hexColorMatch$1.test(node.value)) {\n    // #<hex-color>{3,4,6,8}\n    const _convertHtoRGB = convertHtoRGB(node.value),\n          _convertHtoRGB2 = _slicedToArray(_convertHtoRGB, 4),\n          red = _convertHtoRGB2[0],\n          green = _convertHtoRGB2[1],\n          blue = _convertHtoRGB2[2],\n          alpha = _convertHtoRGB2[3];\n\n    const color = new Color({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    return color;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid hex color`);\n  }\n} // return a transformed named-color\n\n\nfunction transformNamedColor(node, opts) {\n  if (isNamedColor(node)) {\n    // <named-color>\n    const _convertNtoRGB = convertNtoRGB(node.value),\n          _convertNtoRGB2 = _slicedToArray(_convertNtoRGB, 3),\n          red = _convertNtoRGB2[0],\n          green = _convertNtoRGB2[1],\n          blue = _convertNtoRGB2[2];\n\n    const color = new Color({\n      red,\n      green,\n      blue,\n      alpha: 100,\n      colorspace: 'rgb'\n    });\n    return color;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid named-color`);\n  }\n}\n/* Transform <color-adjuster> functions\n/* ========================================================================== */\n// return a transformed color using adjustments\n\n\nfunction transformColorByAdjusters(color, adjusterNodes, opts) {\n  const adjustedColor = adjusterNodes.reduce((base, node) => {\n    if (isAlphaBlueGreenRedAdjuster(node)) {\n      return transformAlphaBlueGreenRedAdjuster(base, node, opts);\n    } else if (isRGBAdjuster(node)) {\n      return transformRGBAdjuster(base, node, opts);\n    } else if (isHueAdjuster(node)) {\n      return transformHueAdjuster(base, node, opts);\n    } else if (isBlacknessLightnessSaturationWhitenessAdjuster(node)) {\n      return transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts);\n    } else if (isShadeTintAdjuster(node)) {\n      return transformShadeTintAdjuster(base, node, opts);\n    } else if (isBlendAdjuster(node)) {\n      return transformBlendAdjuster(base, node, node.value === 'blenda', opts);\n    } else if (isContrastAdjuster(node)) {\n      return transformContrastAdjuster(base, node, opts);\n    } else {\n      manageUnresolved(node, opts, node.value, `Expected a valid color adjuster`);\n      return base;\n    }\n  }, color);\n  return adjustedColor;\n} // return a transformed color using a/alpha/blue/green/red adjustments\n\n\nfunction transformAlphaBlueGreenRedAdjuster(base, node, opts) {\n  const _transformArgsByParam12 = transformArgsByParams(node, alphaMatch.test(node.value) // a/alpha adjustments\n  ? [// [ + | - ] <alpha-value>\n  [transformMinusPlusOperator, transformAlpha], // * <percentage>\n  [transformTimesOperator, transformPercentage], // <alpha-value>\n  [transformAlpha]] // blue/green/red adjustments\n  : [// [ + | - ] <percentage>\n  [transformMinusPlusOperator, transformPercentage], // [ + | - ] <number>\n  [transformMinusPlusOperator, transformRGBNumber], // * <percentage>\n  [transformTimesOperator, transformPercentage], // <percentage>\n  [transformPercentage], // <number>\n  [transformRGBNumber]]),\n        _transformArgsByParam13 = _slicedToArray(_transformArgsByParam12, 2),\n        operatorOrValue = _transformArgsByParam13[0],\n        adjustment = _transformArgsByParam13[1];\n\n  if (operatorOrValue !== undefined) {\n    // normalized channel name\n    const channel = node.value.toLowerCase().replace(alphaMatch, 'alpha');\n    const existingValue = base[channel]();\n    const modifiedValue = adjustment !== undefined ? operatorOrValue === '+' ? existingValue + Number(adjustment) : operatorOrValue === '-' ? existingValue - Number(adjustment) : operatorOrValue === '*' ? existingValue * Number(adjustment) : Number(adjustment) : Number(operatorOrValue);\n    const modifiedColor = base[channel](modifiedValue);\n    return modifiedColor;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid modifier()`);\n  }\n} // return a transformed color using an rgb adjustment\n\n\nfunction transformRGBAdjuster(base, node, opts) {\n  const _transformArgsByParam14 = transformArgsByParams(node, [// [ + | - ] <percentage> <percentage> <percentage>\n  [transformMinusPlusOperator, transformPercentage, transformPercentage, transformPercentage], // [ + | - ] <number> <number> <number>\n  [transformMinusPlusOperator, transformRGBNumber, transformRGBNumber, transformRGBNumber], // [ + | - ] <hash-token>\n  [transformMinusPlusOperator, transformHexColor], // [ * ] <percentage>\n  [transformTimesOperator, transformPercentage]]),\n        _transformArgsByParam15 = _slicedToArray(_transformArgsByParam14, 4),\n        arg1 = _transformArgsByParam15[0],\n        arg2 = _transformArgsByParam15[1],\n        arg3 = _transformArgsByParam15[2],\n        arg4 = _transformArgsByParam15[3];\n\n  if (arg2 !== undefined && arg2.color) {\n    const modifiedColor = base.rgb(arg1 === '+' ? base.red() + arg2.red() : base.red() - arg2.red(), arg1 === '+' ? base.green() + arg2.green() : base.green() - arg2.green(), arg1 === '+' ? base.blue() + arg2.blue() : base.blue() - arg2.blue());\n    return modifiedColor;\n  } else if (arg1 !== undefined && minusPlusMatch.test(arg1)) {\n    const modifiedColor = base.rgb(arg1 === '+' ? base.red() + arg2 : base.red() - arg2, arg1 === '+' ? base.green() + arg3 : base.green() - arg3, arg1 === '+' ? base.blue() + arg4 : base.blue() - arg4);\n    return modifiedColor;\n  } else if (arg1 !== undefined && arg2 !== undefined) {\n    const modifiedColor = base.rgb(base.red() * arg2, base.green() * arg2, base.blue() * arg2);\n    return modifiedColor;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid rgb() adjuster`);\n  }\n} // return a transformed color using a blend/blenda adjustment\n\n\nfunction transformBlendAdjuster(base, node, isAlphaBlend, opts) {\n  const _transformArgsByParam16 = transformArgsByParams(node, [[transformColor, transformPercentage, transformColorSpace]]),\n        _transformArgsByParam17 = _slicedToArray(_transformArgsByParam16, 3),\n        color = _transformArgsByParam17[0],\n        percentage = _transformArgsByParam17[1],\n        _transformArgsByParam18 = _transformArgsByParam17[2],\n        colorspace = _transformArgsByParam18 === void 0 ? 'rgb' : _transformArgsByParam18;\n\n  if (percentage !== undefined) {\n    const modifiedColor = isAlphaBlend ? base.blenda(color.color, percentage, colorspace) : base.blend(color.color, percentage, colorspace);\n    return modifiedColor;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid blend() adjuster)`);\n  }\n} // return a transformed color using a contrast adjustment\n\n\nfunction transformContrastAdjuster(base, node, opts) {\n  const _transformArgsByParam19 = transformArgsByParams(node, [// <percentage>\n  [transformPercentage]]),\n        _transformArgsByParam20 = _slicedToArray(_transformArgsByParam19, 1),\n        percentage = _transformArgsByParam20[0];\n\n  if (percentage !== undefined) {\n    const modifiedColor = base.contrast(percentage);\n    return modifiedColor;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid contrast() adjuster)`);\n  }\n} // return a transformed color using a hue adjustment\n\n\nfunction transformHueAdjuster(base, node, opts) {\n  const _transformArgsByParam21 = transformArgsByParams(node, [// [ + | - | * ] <angle>\n  [transformMinusPlusTimesOperator, transformHue], // <angle>\n  [transformHue]]),\n        _transformArgsByParam22 = _slicedToArray(_transformArgsByParam21, 2),\n        operatorOrHue = _transformArgsByParam22[0],\n        adjustment = _transformArgsByParam22[1];\n\n  if (operatorOrHue !== undefined) {\n    const existingHue = base.hue();\n    const modifiedValue = adjustment !== undefined ? operatorOrHue === '+' ? existingHue + Number(adjustment) : operatorOrHue === '-' ? existingHue - Number(adjustment) : operatorOrHue === '*' ? existingHue * Number(adjustment) : Number(adjustment) : Number(operatorOrHue);\n    return base.hue(modifiedValue);\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid hue() function)`);\n  }\n} // [ b | blackness | l | lightness | s | saturation | w | whiteness ]( [ + | - | * ]? <percentage> )\n\n\nfunction transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts) {\n  const channel = node.value.toLowerCase().replace(/^b$/, 'blackness').replace(/^l$/, 'lightness').replace(/^s$/, 'saturation').replace(/^w$/, 'whiteness');\n\n  const _transformArgsByParam23 = transformArgsByParams(node, [[transformMinusPlusTimesOperator, transformPercentage], [transformPercentage]]),\n        _transformArgsByParam24 = _slicedToArray(_transformArgsByParam23, 2),\n        operatorOrValue = _transformArgsByParam24[0],\n        adjustment = _transformArgsByParam24[1];\n\n  if (operatorOrValue !== undefined) {\n    const existingValue = base[channel]();\n    const modifiedValue = adjustment !== undefined ? operatorOrValue === '+' ? existingValue + Number(adjustment) : operatorOrValue === '-' ? existingValue - Number(adjustment) : operatorOrValue === '*' ? existingValue * Number(adjustment) : Number(adjustment) : Number(operatorOrValue);\n    return base[channel](modifiedValue);\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid ${channel}() function)`);\n  }\n} // return a transformed color using shade/tint adjustments\n\n\nfunction transformShadeTintAdjuster(base, node, opts) {\n  const channel = node.value.toLowerCase();\n\n  const _transformArgsByParam25 = transformArgsByParams(node, [// [ shade | tint ]( <percentage> )\n  [transformPercentage]]),\n        _transformArgsByParam26 = _slicedToArray(_transformArgsByParam25, 1),\n        percentage = _transformArgsByParam26[0];\n\n  if (percentage !== undefined) {\n    const modifiedValue = Number(percentage);\n    return base[channel](modifiedValue);\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected valid ${channel}() arguments`);\n  }\n}\n/* Argument Transforms\n/* ========================================================================== */\n// return a transformed color space\n\n\nfunction transformColorSpace(node, opts) {\n  if (isColorSpace(node)) {\n    // [ hsl | hwb | rgb ]\n    return node.value;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid color space)`);\n  }\n} // return a transformed alpha value\n\n\nfunction transformAlpha(node, opts) {\n  if (isNumber(node)) {\n    // <number>\n    return node.value * 100;\n  } else if (isPercentage(node)) {\n    // <percentage>\n    return transformPercentage(node, opts);\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid alpha value)`);\n  }\n} // return a transformed rgb number\n\n\nfunction transformRGBNumber(node, opts) {\n  if (isNumber(node)) {\n    // <number>\n    return node.value / 2.55;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid RGB value)`);\n  }\n} // return a transformed hue\n\n\nfunction transformHue(node, opts) {\n  if (isHue(node)) {\n    // <hue> = <number> | <angle>\n    const unit = node.unit.toLowerCase();\n\n    if (unit === 'grad') {\n      // if <angle> = <gradian> (400 per circle)\n      return convertGtoD(node.value);\n    } else if (unit === 'rad') {\n      // if <angle> = <radian> (2π per circle)\n      return convertRtoD(node.value);\n    } else if (unit === 'turn') {\n      // if <angle> = <turn> (1 per circle)\n      return convertTtoD(node.value);\n    } else {\n      // if <angle> = [ <degree> | <number> ] (360 per circle)\n      return convertDtoD(node.value);\n    }\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid hue`);\n  }\n} // return a transformed percentage\n\n\nfunction transformPercentage(node, opts) {\n  if (isPercentage(node)) {\n    // <percentage>\n    return Number(node.value);\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid hue`);\n  }\n} // return a transformed minus-plus operator\n\n\nfunction transformMinusPlusOperator(node, opts) {\n  if (isMinusPlusOperator(node)) {\n    // [ - | + ]\n    return node.value;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a plus or minus operator`);\n  }\n} // return a transformed times operator\n\n\nfunction transformTimesOperator(node, opts) {\n  if (isTimesOperator(node)) {\n    // [ * ]\n    return node.value;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a times operator`);\n  }\n} // return a transformed minus-plus-times operator\n\n\nfunction transformMinusPlusTimesOperator(node, opts) {\n  if (isMinusPlusTimesOperator(node)) {\n    // [ - | + | * ]\n    return node.value;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a plus, minus, or times operator`);\n  }\n}\n/* Additional transforms\n/* ========================================================================== */\n\n\nfunction transformWord(node, opts) {\n  if (isWord(node)) {\n    return node.value;\n  } else {\n    return manageUnresolved(node, opts, node.value, `Expected a valid word`);\n  }\n}\n\nfunction transformNode(node) {\n  return Object(node);\n}\n/* Transform helper\n/* ========================================================================== */\n// return the first set of transformed arguments allowable by the parameters\n\n\nfunction transformArgsByParams(node, params) {\n  const nodes = (node.nodes || []).slice(1, -1);\n  const opts = {\n    unresolved: 'ignore'\n  };\n  return params.map(param => nodes.map((childNode, index) => typeof param[index] === 'function' ? param[index](childNode, opts) : undefined).filter(child => typeof child !== 'boolean')).filter(param => param.every(result => result !== undefined))[0] || [];\n}\n/* Walk helper (required because the default walker is affected by mutations)\n/* ========================================================================== */\n// run a function over each node and hen walk each child node of that node\n\n\nfunction walk(node, fn) {\n  fn(node);\n\n  if (Object(node.nodes).length) {\n    node.nodes.slice().forEach(childNode => {\n      walk(childNode, fn);\n    });\n  }\n}\n/* Variable validators\n/* ========================================================================== */\n// return whether the node is a var function\n\n\nfunction isVariable(node) {\n  // var()\n  return Object(node).type === 'func' && varMatch.test(node.value);\n}\n/* Adjustment validators\n/* ========================================================================== */\n// return whether the node is an a/alpha/blue/green/red adjuster\n\n\nfunction isAlphaBlueGreenRedAdjuster(node) {\n  // [ a(), alpha(), blue(), green(), red() ]\n  return Object(node).type === 'func' && alphaBlueGreenRedMatch.test(node.value);\n} // return whether the node is an rgb adjuster\n\n\nfunction isRGBAdjuster(node) {\n  return Object(node).type === 'func' && rgbMatch.test(node.value);\n} // return whether the node is a hue adjuster\n\n\nfunction isHueAdjuster(node) {\n  // [ h() | hue() ]\n  return Object(node).type === 'func' && hueMatch.test(node.value);\n} // return whether the node is a blackness/lightness/saturation/whiteness adjuster\n\n\nfunction isBlacknessLightnessSaturationWhitenessAdjuster(node) {\n  // [ b() | blackness() | l() | lightness() | s() | saturation() | w() | whiteness() ]\n  return Object(node).type === 'func' && blacknessLightnessSaturationWhitenessMatch.test(node.value);\n} // return whether the node is a shade/tint adjuster\n\n\nfunction isShadeTintAdjuster(node) {\n  // [ shade() | tint() ]\n  return Object(node).type === 'func' && shadeTintMatch.test(node.value);\n} // return whether the node is a blend adjuster\n\n\nfunction isBlendAdjuster(node) {\n  // [ blend(), blenda() ]\n  return Object(node).type === 'func' && blendMatch.test(node.value);\n} // return whether the node is a contrast adjuster\n\n\nfunction isContrastAdjuster(node) {\n  // [ contrast() ]\n  return Object(node).type === 'func' && contrastMatch.test(node.value);\n}\n/* Color validators\n/* ========================================================================== */\n// return whether the node is an rgb/rgba color function\n\n\nfunction isRGBFunction(node) {\n  // [ rgb(), rgba() ]\n  return Object(node).type === 'func' && rgbaMatch.test(node.value);\n} // return whether the node is an hsl color function\n\n\nfunction isHSLFunction(node) {\n  // [ hsl(), hsla() ]\n  return Object(node).type === 'func' && hslaMatch.test(node.value);\n} // return whether the node is an hwb color function\n\n\nfunction isHWBFunction(node) {\n  // hwb()\n  return Object(node).type === 'func' && hwbMatch.test(node.value);\n} // return whether the node is a color-mod function\n\n\nfunction isColorModFunction(node) {\n  // color-mod()\n  return Object(node).type === 'func' && colorModMatch.test(node.value);\n} // return whether the node is a valid named-color\n\n\nfunction isNamedColor(node) {\n  return Object(node).type === 'word' && Boolean(convertNtoRGB(node.value));\n} // return whether the node is a valid hex color\n\n\nfunction isHexColor(node) {\n  // #<hex-color>{3,4,6,8}\n  return Object(node).type === 'word' && hexColorMatch$1.test(node.value);\n} // return whether the node is a valid color space\n\n\nfunction isColorSpace(node) {\n  // [ hsl | hwb | rgb ]\n  return Object(node).type === 'word' && colorSpaceMatch.test(node.value);\n}\n/* Additional validators\n/* ========================================================================== */\n// return whether the hue value is valid\n\n\nfunction isHue(node) {\n  return Object(node).type === 'number' && hueUnitMatch.test(node.unit);\n} // return whether the comma is valid\n\n\nfunction isComma(node) {\n  return Object(node).type === 'comma';\n} // return whether the slash operator is valid\n\n\nfunction isSlash(node) {\n  return Object(node).type === 'operator' && node.value === '/';\n} // return whether the number is valid\n\n\nfunction isNumber(node) {\n  return Object(node).type === 'number' && node.unit === '';\n} // return whether the mind-plus operator is valid\n\n\nfunction isMinusPlusOperator(node) {\n  return Object(node).type === 'operator' && minusPlusMatch.test(node.value);\n} // return whether the minus-plus-times operator is valid\n\n\nfunction isMinusPlusTimesOperator(node) {\n  return Object(node).type === 'operator' && minusPlusTimesMatch.test(node.value);\n} // return whether the times operator is valid\n\n\nfunction isTimesOperator(node) {\n  return Object(node).type === 'operator' && timesMatch.test(node.value);\n} // return whether the percentage is valid\n\n\nfunction isPercentage(node) {\n  return Object(node).type === 'number' && (node.unit === '%' || node.value === '0');\n} // return whether the node is a word\n\n\nfunction isWord(node) {\n  // <word>\n  return Object(node).type === 'word';\n}\n/* Matchers\n/* ========================================================================== */\n\n\nconst alphaMatch = /^a(lpha)?$/i;\nconst alphaBlueGreenRedMatch = /^(a(lpha)?|blue|green|red)$/i;\nconst blacknessLightnessSaturationWhitenessMatch = /^(b(lackness)?|l(ightness)?|s(aturation)?|w(hiteness)?)$/i;\nconst blendMatch = /^blenda?$/i;\nconst colorModMatch = /^color-mod$/i;\nconst colorSpaceMatch = /^(hsl|hwb|rgb)$/i;\nconst contrastMatch = /^contrast$/i;\nconst hexColorMatch$1 = /^#(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i;\nconst hslaMatch = /^hsla?$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\nconst hueMatch = /^h(ue)?$/i;\nconst hwbMatch = /^hwb$/i;\nconst minusPlusMatch = /^[+-]$/;\nconst minusPlusTimesMatch = /^[*+-]$/;\nconst rgbMatch = /^rgb$/i;\nconst rgbaMatch = /^rgba?$/i;\nconst shadeTintMatch = /^(shade|tint)$/i;\nconst varMatch = /^var$/i;\nconst looseVarMatch = /(^|[^\\w-])var\\(/i;\nconst timesMatch = /^[*]$/;\nvar index = postcss.plugin('postcss-color-mod-function', opts => {\n  // how unresolved functions and arguments should be handled (default: \"throw\")\n  const unresolvedOpt = String(Object(opts).unresolved || 'throw').toLowerCase(); // how transformed colors will be produced in CSS\n\n  const stringifierOpt = Object(opts).stringifier || (color => color.toLegacy()); // sources to import custom selectors from\n\n\n  const importFrom = [].concat(Object(opts).importFrom || []); //  whether var() within color-mod() should use Custom Properties or var() fallback\n\n  const transformVarsOpt = 'transformVars' in Object(opts) ? opts.transformVars : true; // promise any custom selectors are imported\n\n  const customPropertiesPromise = importCustomPropertiesFromSources(importFrom);\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (root, result) {\n      const customProperties = Object.assign(yield customPropertiesPromise, getCustomProperties(root, {\n        preserve: true\n      }));\n      root.walkDecls(decl => {\n        const originalValue = decl.value;\n\n        if (colorModFunctionMatch.test(originalValue)) {\n          const ast = valueParser(originalValue, {\n            loose: true\n          }).parse();\n          transformAST(ast, {\n            unresolved: unresolvedOpt,\n            stringifier: stringifierOpt,\n            transformVars: transformVarsOpt,\n            decl,\n            result,\n            customProperties\n          });\n          const modifiedValue = ast.toString();\n\n          if (originalValue !== modifiedValue) {\n            decl.value = modifiedValue;\n          }\n        }\n      });\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n});\nconst colorModFunctionMatch = /(^|[^\\w-])color-mod\\(/i;\nmodule.exports = index;","map":{"version":3,"sources":["lib/get-custom-properties.js","lib/import-from.js","lib/conversions.js","lib/color.js","lib/manage-unresolved.js","lib/transform.js","index.js"],"names":["customPropertiesFromHtmlElement","customPropertiesFromRootPsuedo","root","rule","customPropertiesObject","isHtmlRule","isRootRule","decl","isCustomDecl","prop","valueParser","opts","isEmptyParent","htmlSelectorRegExp","rootSelectorRegExp","customPropertyRegExp","node","Object","getCustomProperties","preserve","importCustomPropertiesFromCSSFile","css","readFile","from","importCustomPropertiesFromCSSAST","customProperties","importCustomPropertiesFromJSONFile","object","readJSON","importCustomPropertiesFromObject","importCustomPropertiesFromJSFile","source","String","path","type","fs","reject","resolve","JSON","deg","grad","rad","Math","turn","names","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","c","r","g","b","a","rr","gg","bb","aa","hex","parseInt","alpha","hexColorMatch","constructor","color","rgb2hue","assign","blackness","hwb","color2hwb","blend","colorspace","base","blenda","rgb","color2rgb","contrast","hue","hsl","color2hsl","lightness","saturation","shade","whiteness","percentage","tint","toHSL","color2hslString","toHWB","color2hwbString","toLegacy","color2legacyString","toRGB","color2rgbString","toRGBLegacy","color2rgbLegacyString","toString","color2string","addition","subtraction","h1","s1","l1","a1","h2","s2","l2","a2","isBlendingAlpha","w1","b1","w2","b2","r1","g1","r2","g2","channel","isHue","isRGB","blueGreenRedMatch","value","normalize","channels","min","max","normalizedValue","hsl2rgb","hwb2rgb","rgb2hsl","hwb2hsl","rgb2hwb","hsl2hwb","luminance","rgb2luminance","maxContrastColor","contrastRatio","colors2contrast","minContrastColor","colors2contrastRatioColor","rgb1","rgb2","redLuminance","greenLuminance","blueLuminance","channel2luminance","modifiedHWB","minW","minB","maxW","maxHWB","maxB","midW","midB","isOpaque","color2hslLegacyString","name","word","child","isColorModFunction","transformVariables","transformColorModFunction","raws","transformAST","walk","isVariable","fallbackNode","transformArgsByParams","customPropertyValue","looseVarMatch","rootChildAST","customPropertyChild","isRGBFunction","transformRGBFunction","isHSLFunction","transformHSLFunction","isHWBFunction","transformHWBFunction","isHexColor","transformHexColor","isNamedColor","transformNamedColor","manageUnresolved","colorOrHueNode","adjusterNodes","transformHue","transformColor","adjustedColor","transformColorByAdjusters","convertHtoRGB","convertNtoRGB","isAlphaBlueGreenRedAdjuster","transformAlphaBlueGreenRedAdjuster","isRGBAdjuster","transformRGBAdjuster","isHueAdjuster","transformHueAdjuster","isBlacknessLightnessSaturationWhitenessAdjuster","transformBlacknessLightnessSaturationWhitenessAdjuster","isShadeTintAdjuster","transformShadeTintAdjuster","isBlendAdjuster","transformBlendAdjuster","isContrastAdjuster","transformContrastAdjuster","operatorOrValue","adjustment","existingValue","modifiedValue","Number","modifiedColor","arg1","arg2","arg3","arg4","minusPlusMatch","isAlphaBlend","operatorOrHue","existingHue","isColorSpace","isNumber","isPercentage","transformPercentage","unit","convertGtoD","convertRtoD","convertTtoD","convertDtoD","isMinusPlusOperator","isTimesOperator","isMinusPlusTimesOperator","isWord","nodes","unresolved","params","param","result","fn","childNode","varMatch","alphaBlueGreenRedMatch","rgbMatch","hueMatch","blacknessLightnessSaturationWhitenessMatch","shadeTintMatch","blendMatch","contrastMatch","rgbaMatch","hslaMatch","hwbMatch","colorModMatch","Boolean","colorSpaceMatch","hueUnitMatch","minusPlusTimesMatch","timesMatch","alphaMatch","unresolvedOpt","stringifierOpt","importFrom","transformVarsOpt","customPropertiesPromise","importCustomPropertiesFromSources","originalValue","colorModFunctionMatch","ast","loose","stringifier","transformVars"],"mappings":"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","sourcesContent":["import valueParser from 'postcss-values-parser';\n\n// return custom selectors from the css root, conditionally removing them\nexport default function getCustomProperties(root, opts) {\n\t// initialize custom selectors\n\tconst customPropertiesFromHtmlElement = {};\n\tconst customPropertiesFromRootPsuedo = {};\n\n\t// for each html or :root rule\n\troot.nodes.slice().forEach(rule => {\n\t\tconst customPropertiesObject = isHtmlRule(rule)\n\t\t\t? customPropertiesFromHtmlElement\n\t\t: isRootRule(rule)\n\t\t\t? customPropertiesFromRootPsuedo\n\t\t: null;\n\n\t\t// for each custom property\n\t\tif (customPropertiesObject) {\n\t\t\trule.nodes.slice().forEach(decl => {\n\t\t\t\tif (isCustomDecl(decl)) {\n\t\t\t\t\tconst { prop } = decl;\n\n\t\t\t\t\t// write the parsed value to the custom property\n\t\t\t\t\tcustomPropertiesObject[prop] = valueParser(decl.value).parse();\n\n\t\t\t\t\t// conditionally remove the custom property declaration\n\t\t\t\t\tif (!opts.preserve) {\n\t\t\t\t\t\tdecl.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// conditionally remove the empty html or :root rule\n\t\t\tif (!opts.preserve && isEmptyParent(rule)) {\n\t\t\t\trule.remove();\n\t\t\t}\n\t\t}\n\t});\n\n\t// return all custom properties, preferring :root properties over html properties\n\treturn { ...customPropertiesFromHtmlElement, ...customPropertiesFromRootPsuedo };\n}\n\n// match html and :root rules\nconst htmlSelectorRegExp = /^html$/i;\nconst rootSelectorRegExp = /^:root$/i;\nconst customPropertyRegExp = /^--[A-z][\\w-]*$/;\n\n// whether the node is an html or :root rule\nconst isHtmlRule = node => node.type === 'rule' && htmlSelectorRegExp.test(node.selector) && Object(node.nodes).length;\nconst isRootRule = node => node.type === 'rule' && rootSelectorRegExp.test(node.selector) && Object(node.nodes).length;\n\n// whether the node is an custom property\nconst isCustomDecl = node => node.type === 'decl' && customPropertyRegExp.test(node.prop);\n\n// whether the node is a parent without children\nconst isEmptyParent = node => Object(node.nodes).length === 0;\n","import fs from 'fs';\nimport path from 'path';\nimport postcss from 'postcss';\nimport getCustomProperties from './get-custom-properties';\nimport valueParser from 'postcss-values-parser';\n\n/* Import Custom Properties from CSS AST\n/* ========================================================================== */\n\nfunction importCustomPropertiesFromCSSAST(root) {\n\treturn getCustomProperties(root, { preserve: true });\n}\n\n/* Import Custom Properties from CSS File\n/* ========================================================================== */\n\nasync function importCustomPropertiesFromCSSFile(from) {\n\tconst css = await readFile(from);\n\tconst root = postcss.parse(css, { from });\n\n\treturn importCustomPropertiesFromCSSAST(root);\n}\n\n/* Import Custom Properties from Object\n/* ========================================================================== */\n\nfunction importCustomPropertiesFromObject(object) {\n\tconst customProperties = Object.assign(\n\t\t{},\n\t\tObject(object).customProperties || Object(object)['custom-properties']\n\t);\n\n\tfor (const prop in customProperties) {\n\t\tcustomProperties[prop] = valueParser(customProperties[prop]).parse();\n\t}\n\n\treturn customProperties;\n}\n\n/* Import Custom Properties from JSON file\n/* ========================================================================== */\n\nasync function importCustomPropertiesFromJSONFile(from) {\n\tconst object = await readJSON(from);\n\n\treturn importCustomPropertiesFromObject(object);\n}\n\n/* Import Custom Properties from JS file\n/* ========================================================================== */\n\nasync function importCustomPropertiesFromJSFile(from) {\n\tconst object = await import(from);\n\n\treturn importCustomPropertiesFromObject(object);\n}\n\n/* Import Custom Properties from Sources\n/* ========================================================================== */\n\nexport default function importCustomPropertiesFromSources(sources) {\n\treturn sources.map(source => {\n\t\tif (source instanceof Promise) {\n\t\t\treturn source;\n\t\t} else if (source instanceof Function) {\n\t\t\treturn source();\n\t\t}\n\n\t\t// read the source as an object\n\t\tconst opts = source === Object(source) ? source : { from: String(source) };\n\n\t\t// skip objects with Custom Properties\n\t\tif (opts.customProperties || opts['custom-properties']) {\n\t\t\treturn opts\n\t\t}\n\n\t\t// source pathname\n\t\tconst from = path.resolve(String(opts.from || ''));\n\n\t\t// type of file being read from\n\t\tconst type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n\n\t\treturn { type, from };\n\t}).reduce(async (customProperties, source) => {\n\t\tconst { type, from } = await source;\n\n\t\tif (type === 'ast') {\n\t\t\treturn Object.assign(await customProperties, importCustomPropertiesFromCSSAST(from));\n\t\t}\n\n\t\tif (type === 'css') {\n\t\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromCSSFile(from));\n\t\t}\n\n\t\tif (type === 'js') {\n\t\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromJSFile(from));\n\t\t}\n\n\t\tif (type === 'json') {\n\t\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromJSONFile(from));\n\t\t}\n\n\t\treturn Object.assign(await customProperties, await importCustomPropertiesFromObject(await source));\n\t}, {});\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst readFile = from => new Promise((resolve, reject) => {\n\tfs.readFile(from, 'utf8', (error, result) => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n});\n\nconst readJSON = async from => JSON.parse(await readFile(from));\n","/* Convert Degree to Hue Degree\n/* ========================================================================== */\n\nexport function convertDtoD(deg) {\n\treturn deg % 360;\n}\n\n/* Convert Gradian to Hue Degree\n/* ========================================================================== */\n\nexport function convertGtoD(grad) {\n\treturn grad * 0.9 % 360;\n}\n\n/* Convert Radian to Hue Degree\n/* ========================================================================== */\n\nexport function convertRtoD(rad) {\n\treturn rad * 180 / Math.PI % 360;\n}\n\n/* Convert Turn to Hue Degree\n/* ========================================================================== */\n\nexport function convertTtoD(turn) {\n\treturn turn * 360 % 360;\n}\n\n/* Convert a Name to Red/Green/Blue\n/* ========================================================================== */\n\nexport function convertNtoRGB(name) {\n\tconst names = {\n\t\taliceblue: [240, 248, 255],\n\t\tantiquewhite: [250, 235, 215],\n\t\taqua: [0, 255, 255],\n\t\taquamarine: [127, 255, 212],\n\t\tazure: [240, 255, 255],\n\t\tbeige: [245, 245, 220],\n\t\tbisque: [255, 228, 196],\n\t\tblack: [0, 0, 0],\n\t\tblanchedalmond: [255, 235, 205],\n\t\tblue: [0, 0, 255],\n\t\tblueviolet: [138, 43, 226],\n\t\tbrown: [165, 42, 42],\n\t\tburlywood: [222, 184, 135],\n\t\tcadetblue: [95, 158, 160],\n\t\tchartreuse: [127, 255, 0],\n\t\tchocolate: [210, 105, 30],\n\t\tcoral: [255, 127, 80],\n\t\tcornflowerblue: [100, 149, 237],\n\t\tcornsilk: [255, 248, 220],\n\t\tcrimson: [220, 20, 60],\n\t\tcyan: [0, 255, 255],\n\t\tdarkblue: [0, 0, 139],\n\t\tdarkcyan: [0, 139, 139],\n\t\tdarkgoldenrod: [184, 134, 11],\n\t\tdarkgray: [169, 169, 169],\n\t\tdarkgreen: [0, 100, 0],\n\t\tdarkgrey: [169, 169, 169],\n\t\tdarkkhaki: [189, 183, 107],\n\t\tdarkmagenta: [139, 0, 139],\n\t\tdarkolivegreen: [85, 107, 47],\n\t\tdarkorange: [255, 140, 0],\n\t\tdarkorchid: [153, 50, 204],\n\t\tdarkred: [139, 0, 0],\n\t\tdarksalmon: [233, 150, 122],\n\t\tdarkseagreen: [143, 188, 143],\n\t\tdarkslateblue: [72, 61, 139],\n\t\tdarkslategray: [47, 79, 79],\n\t\tdarkslategrey: [47, 79, 79],\n\t\tdarkturquoise: [0, 206, 209],\n\t\tdarkviolet: [148, 0, 211],\n\t\tdeeppink: [255, 20, 147],\n\t\tdeepskyblue: [0, 191, 255],\n\t\tdimgray: [105, 105, 105],\n\t\tdimgrey: [105, 105, 105],\n\t\tdodgerblue: [30, 144, 255],\n\t\tfirebrick: [178, 34, 34],\n\t\tfloralwhite: [255, 250, 240],\n\t\tforestgreen: [34, 139, 34],\n\t\tfuchsia: [255, 0, 255],\n\t\tgainsboro: [220, 220, 220],\n\t\tghostwhite: [248, 248, 255],\n\t\tgold: [255, 215, 0],\n\t\tgoldenrod: [218, 165, 32],\n\t\tgray: [128, 128, 128],\n\t\tgreen: [0, 128, 0],\n\t\tgreenyellow: [173, 255, 47],\n\t\tgrey: [128, 128, 128],\n\t\thoneydew: [240, 255, 240],\n\t\thotpink: [255, 105, 180],\n\t\tindianred: [205, 92, 92],\n\t\tindigo: [75, 0, 130],\n\t\tivory: [255, 255, 240],\n\t\tkhaki: [240, 230, 140],\n\t\tlavender: [230, 230, 250],\n\t\tlavenderblush: [255, 240, 245],\n\t\tlawngreen: [124, 252, 0],\n\t\tlemonchiffon: [255, 250, 205],\n\t\tlightblue: [173, 216, 230],\n\t\tlightcoral: [240, 128, 128],\n\t\tlightcyan: [224, 255, 255],\n\t\tlightgoldenrodyellow: [250, 250, 210],\n\t\tlightgray: [211, 211, 211],\n\t\tlightgreen: [144, 238, 144],\n\t\tlightgrey: [211, 211, 211],\n\t\tlightpink: [255, 182, 193],\n\t\tlightsalmon: [255, 160, 122],\n\t\tlightseagreen: [32, 178, 170],\n\t\tlightskyblue: [135, 206, 250],\n\t\tlightslategray: [119, 136, 153],\n\t\tlightslategrey: [119, 136, 153],\n\t\tlightsteelblue: [176, 196, 222],\n\t\tlightyellow: [255, 255, 224],\n\t\tlime: [0, 255, 0],\n\t\tlimegreen: [50, 205, 50],\n\t\tlinen: [250, 240, 230],\n\t\tmagenta: [255, 0, 255],\n\t\tmaroon: [128, 0, 0],\n\t\tmediumaquamarine: [102, 205, 170],\n\t\tmediumblue: [0, 0, 205],\n\t\tmediumorchid: [186, 85, 211],\n\t\tmediumpurple: [147, 112, 219],\n\t\tmediumseagreen: [60, 179, 113],\n\t\tmediumslateblue: [123, 104, 238],\n\t\tmediumspringgreen: [0, 250, 154],\n\t\tmediumturquoise: [72, 209, 204],\n\t\tmediumvioletred: [199, 21, 133],\n\t\tmidnightblue: [25, 25, 112],\n\t\tmintcream: [245, 255, 250],\n\t\tmistyrose: [255, 228, 225],\n\t\tmoccasin: [255, 228, 181],\n\t\tnavajowhite: [255, 222, 173],\n\t\tnavy: [0, 0, 128],\n\t\toldlace: [253, 245, 230],\n\t\tolive: [128, 128, 0],\n\t\tolivedrab: [107, 142, 35],\n\t\torange: [255, 165, 0],\n\t\torangered: [255, 69, 0],\n\t\torchid: [218, 112, 214],\n\t\tpalegoldenrod: [238, 232, 170],\n\t\tpalegreen: [152, 251, 152],\n\t\tpaleturquoise: [175, 238, 238],\n\t\tpalevioletred: [219, 112, 147],\n\t\tpapayawhip: [255, 239, 213],\n\t\tpeachpuff: [255, 218, 185],\n\t\tperu: [205, 133, 63],\n\t\tpink: [255, 192, 203],\n\t\tplum: [221, 160, 221],\n\t\tpowderblue: [176, 224, 230],\n\t\tpurple: [128, 0, 128],\n\t\trebeccapurple: [102, 51, 153],\n\t\tred: [255, 0, 0],\n\t\trosybrown: [188, 143, 143],\n\t\troyalblue: [65, 105, 225],\n\t\tsaddlebrown: [139, 69, 19],\n\t\tsalmon: [250, 128, 114],\n\t\tsandybrown: [244, 164, 96],\n\t\tseagreen: [46, 139, 87],\n\t\tseashell: [255, 245, 238],\n\t\tsienna: [160, 82, 45],\n\t\tsilver: [192, 192, 192],\n\t\tskyblue: [135, 206, 235],\n\t\tslateblue: [106, 90, 205],\n\t\tslategray: [112, 128, 144],\n\t\tslategrey: [112, 128, 144],\n\t\tsnow: [255, 250, 250],\n\t\tspringgreen: [0, 255, 127],\n\t\tsteelblue: [70, 130, 180],\n\t\ttan: [210, 180, 140],\n\t\tteal: [0, 128, 128],\n\t\tthistle: [216, 191, 216],\n\t\ttomato: [255, 99, 71],\n\t\ttransparent: [0, 0, 0],\n\t\tturquoise: [64, 224, 208],\n\t\tviolet: [238, 130, 238],\n\t\twheat: [245, 222, 179],\n\t\twhite: [255, 255, 255],\n\t\twhitesmoke: [245, 245, 245],\n\t\tyellow: [255, 255, 0],\n\t\tyellowgreen: [154, 205, 50]\n\t};\n\n\treturn names[name] && names[name].map(c => c / 2.55);\n}\n\n\n/* Convert a Hex to Red/Green/Blue\n/* ========================================================================== */\n\nexport function convertHtoRGB(hex) {\n\t// #<hex-color>{3,4,6,8}\n\tconst [r, g, b, a, rr, gg, bb, aa] = (hex.match(hexColorMatch) || []).slice(1);\n\n\tif (rr !== undefined || r !== undefined) {\n\t\tconst red   = rr !== undefined ? parseInt(rr, 16) : r !== undefined ? parseInt(r + r, 16) : 0;\n\t\tconst green = gg !== undefined ? parseInt(gg, 16) : g !== undefined ? parseInt(g + g, 16) : 0;\n\t\tconst blue  = bb !== undefined ? parseInt(bb, 16) : b !== undefined ? parseInt(b + b, 16) : 0;\n\t\tconst alpha = aa !== undefined ? parseInt(aa, 16) : a !== undefined ? parseInt(a + a, 16) : 255;\n\n\t\treturn [red, green, blue, alpha].map(c => c / 2.55);\n\t}\n\n\treturn undefined;\n}\n\nconst hexColorMatch = /^#(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i;\n","import { rgb2hsl, rgb2hwb, hsl2rgb, hsl2hwb, hwb2rgb, hwb2hsl, rgb2hue } from '@csstools/convert-colors';\n\nexport default class Color {\n\tconstructor(color) {\n\t\tthis.color = Object(Object(color).color || color);\n\n\t\tthis.color.colorspace = this.color.colorspace\n\t\t\t? this.color.colorspace\n\t\t: 'red' in color && 'green' in color && 'blue' in color\n\t\t\t? 'rgb'\n\t\t: 'hue' in color && 'saturation' in color && 'lightness' in color\n\t\t\t? 'hsl'\n\t\t: 'hue' in color && 'whiteness' in color && 'blackness' in color\n\t\t\t? 'hwb'\n\t\t: 'unknown';\n\n\t\tif (color.colorspace === 'rgb') {\n\t\t\tthis.color.hue = rgb2hue(color.red, color.green, color.blue, color.hue || 0);\n\t\t}\n\t}\n\n\talpha(alpha) {\n\t\tconst color = this.color;\n\n\t\treturn alpha === undefined\n\t\t\t? color.alpha\n\t\t: new Color(assign(color, { alpha }));\n\t}\n\n\tblackness(blackness) {\n\t\tconst hwb = color2hwb(this.color);\n\n\t\treturn blackness === undefined\n\t\t\t? hwb.blackness\n\t\t: new Color(assign(hwb, { blackness }));\n\t}\n\n\tblend(color, percentage, colorspace = 'rgb') {\n\t\tconst base = this.color;\n\n\t\treturn new Color(blend(base, color, percentage, colorspace));\n\t}\n\n\tblenda(color, percentage, colorspace = 'rgb') {\n\t\tconst base = this.color;\n\n\t\treturn new Color(blend(base, color, percentage, colorspace, true));\n\t}\n\n\tblue(blue) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn blue === undefined\n\t\t\t? rgb.blue\n\t\t: new Color(assign(rgb, { blue }));\n\t}\n\n\tcontrast(percentage) {\n\t\tconst base = this.color;\n\n\t\treturn new Color(contrast(base, percentage));\n\t}\n\n\tgreen(green) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn green === undefined\n\t\t\t? rgb.green\n\t\t: new Color(assign(rgb, { green }));\n\t}\n\n\thue(hue) {\n\t\tconst hsl = color2hsl(this.color);\n\n\t\treturn hue === undefined\n\t\t\t? hsl.hue\n\t\t: new Color(assign(hsl, { hue }));\n\t}\n\n\tlightness(lightness) {\n\t\tconst hsl = color2hsl(this.color);\n\n\t\treturn lightness === undefined\n\t\t\t? hsl.lightness\n\t\t: new Color(assign(hsl, { lightness }))\n\t}\n\n\tred(red) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn red === undefined\n\t\t\t? rgb.red\n\t\t: new Color(assign(rgb, { red }));\n\t}\n\n\trgb(red, green, blue) {\n\t\tconst rgb = color2rgb(this.color);\n\n\t\treturn new Color(assign(rgb, { red, green, blue }));\n\t}\n\n\tsaturation(saturation) {\n\t\tconst hsl = color2hsl(this.color);\n\n\t\treturn saturation === undefined\n\t\t\t? hsl.saturation\n\t\t: new Color(assign(hsl, { saturation }));\n\t}\n\n\tshade(percentage) {\n\t\tconst hwb = color2hwb(this.color);\n\t\tconst shade = { hue: 0, whiteness: 0, blackness: 100, colorspace: 'hwb' };\n\t\tconst colorspace = 'rgb';\n\n\t\treturn percentage === undefined\n\t\t\t? hwb.blackness\n\t\t: new Color(blend(hwb, shade, percentage, colorspace));\n\t}\n\n\ttint(percentage) {\n\t\tconst hwb = color2hwb(this.color);\n\t\tconst tint = { hue: 0, whiteness: 100, blackness: 0, colorspace: 'hwb' };\n\t\tconst colorspace = 'rgb';\n\n\t\treturn percentage === undefined\n\t\t\t? hwb.blackness\n\t\t: new Color(blend(hwb, tint, percentage, colorspace));\n\t}\n\n\twhiteness(whiteness) {\n\t\tconst hwb = color2hwb(this.color);\n\n\t\treturn whiteness === undefined\n\t\t\t? hwb.whiteness\n\t\t: new Color(assign(hwb, { whiteness }));\n\t}\n\n\ttoHSL() {\n\t\treturn color2hslString(this.color);\n\t}\n\n\ttoHWB() {\n\t\treturn color2hwbString(this.color);\n\t}\n\n\ttoLegacy() {\n\t\treturn color2legacyString(this.color);\n\t}\n\n\ttoRGB() {\n\t\treturn color2rgbString(this.color);\n\t}\n\n\ttoRGBLegacy() {\n\t\treturn color2rgbLegacyString(this.color);\n\t}\n\n\ttoString() {\n\t\treturn color2string(this.color);\n\t}\n}\n\n/* Blending\n/* ========================================================================== */\n\nfunction blend(base, color, percentage, colorspace, isBlendingAlpha) {\n\tconst addition    = percentage / 100;\n\tconst subtraction = 1 - addition;\n\n\tif (colorspace === 'hsl') {\n\t\tconst { hue: h1, saturation: s1, lightness: l1, alpha: a1 } = color2hsl(base);\n\t\tconst { hue: h2, saturation: s2, lightness: l2, alpha: a2 } = color2hsl(color);\n\n\t\tconst [hue, saturation, lightness, alpha] = [\n\t\t\th1 * subtraction + h2 * addition,\n\t\t\ts1 * subtraction + s2 * addition,\n\t\t\tl1 * subtraction + l2 * addition,\n\t\t\tisBlendingAlpha\n\t\t\t\t? a1 * subtraction + a2 * addition\n\t\t\t: a1\n\t\t];\n\n\t\treturn { hue, saturation, lightness, alpha, colorspace: 'hsl' };\n\t} else if (colorspace === 'hwb') {\n\t\tconst { hue: h1, whiteness: w1, blackness: b1, alpha: a1 } = color2hwb(base);\n\t\tconst { hue: h2, whiteness: w2, blackness: b2, alpha: a2 } = color2hwb(color);\n\n\t\tconst [hue, whiteness, blackness, alpha] = [\n\t\t\th1 * subtraction + h2 * addition,\n\t\t\tw1 * subtraction + w2 * addition,\n\t\t\tb1 * subtraction + b2 * addition,\n\t\t\tisBlendingAlpha\n\t\t\t\t? a1 * subtraction + a2 * addition\n\t\t\t: a1\n\t\t];\n\n\t\treturn { hue, whiteness, blackness, alpha, colorspace: 'hwb' };\n\t} else {\n\t\tconst { red: r1, green: g1, blue: b1, alpha: a1 } = color2rgb(base);\n\t\tconst { red: r2, green: g2, blue: b2, alpha: a2 } = color2rgb(color);\n\n\t\tconst [red, green, blue, alpha] = [\n\t\t\tr1 * subtraction + r2 * addition,\n\t\t\tg1 * subtraction + g2 * addition,\n\t\t\tb1 * subtraction + b2 * addition,\n\t\t\tisBlendingAlpha\n\t\t\t\t? a1 * subtraction + a2 * addition\n\t\t\t: a1\n\t\t];\n\n\t\treturn { red, green, blue, alpha, colorspace: 'rgb' };\n\t}\n}\n\n/* Assign channels to a new instance of a base color\n/* ========================================================================== */\n\nfunction assign(base, channels) {\n\tconst color = Object.assign({}, base);\n\n\tObject.keys(channels).forEach(\n\t\tchannel => {\n\t\t\t// detect channel\n\t\t\tconst isHue = channel === 'hue';\n\t\t\tconst isRGB = !isHue && blueGreenRedMatch.test(channel);\n\n\t\t\t// normalized value of the channel\n\t\t\tconst value = normalize(channels[channel], channel);\n\n\t\t\t// assign channel to new object\n\t\t\tcolor[channel] = value;\n\n\t\t\tif (isRGB) {\n\t\t\t\t// conditionally preserve the hue\n\t\t\t\tcolor.hue = rgb2hue(color.red, color.green, color.blue, base.hue || 0);\n\t\t\t}\n\t\t}\n\t);\n\n\treturn color;\n}\n\nfunction normalize(value, channel) {\n\t// detect channel\n\tconst isHue = channel === 'hue';\n\n\t// value limitations\n\tconst min = 0;\n\tconst max = isHue ? 360 : 100;\n\n\tconst normalizedValue = Math.min(Math.max(isHue\n\t\t? value % 360\n\t: value, min), max);\n\n\treturn normalizedValue;\n}\n\n/* Convert colors\n/* ========================================================================== */\n\nfunction color2rgb(color) {\n\tconst [ red, green, blue ] = color.colorspace === 'hsl'\n\t\t? hsl2rgb(color.hue, color.saturation, color.lightness)\n\t: color.colorspace === 'hwb'\n\t\t? hwb2rgb(color.hue, color.whiteness, color.blackness)\n\t: [ color.red, color.green, color.blue ];\n\n\treturn { red, green, blue, hue: color.hue, alpha: color.alpha, colorspace: 'rgb' };\n}\n\nfunction color2hsl(color) {\n\tconst [ hue, saturation, lightness ] = color.colorspace === 'rgb'\n\t\t? rgb2hsl(color.red, color.green, color.blue, color.hue)\n\t: color.colorspace === 'hwb'\n\t\t? hwb2hsl(color.hue, color.whiteness, color.blackness)\n\t: [ color.hue, color.saturation, color.lightness ];\n\n\treturn { hue, saturation, lightness, alpha: color.alpha, colorspace: 'hsl' };\n}\n\nfunction color2hwb(color) {\n\tconst [ hue, whiteness, blackness ] = color.colorspace === 'rgb'\n\t\t? rgb2hwb(color.red, color.green, color.blue, color.hue)\n\t: color.colorspace === 'hsl'\n\t\t? hsl2hwb(color.hue, color.saturation, color.lightness)\n\t: [ color.hue, color.whiteness, color.blackness ];\n\n\treturn { hue, whiteness, blackness, alpha: color.alpha, colorspace: 'hwb' };\n}\n\n/* Contrast functions\n/* ========================================================================== */\n\nfunction contrast(color, percentage) {\n\t// https://drafts.csswg.org/css-color/#contrast-adjuster\n\tconst hwb = color2hwb(color);\n\tconst rgb = color2rgb(color);\n\n\t// compute the luminance of the color.\n\tconst luminance = rgb2luminance(rgb.red, rgb.green, rgb.blue);\n\n\t// the maximum-contrast color, if it is less than .5\n\tconst maxContrastColor = luminance < 0.5\n\t\t// hwb(X, 100%, 0%), where X is the hue angle of the color\n\t\t? { hue: hwb.hue, whiteness: 100, blackness: 0, alpha: hwb.alpha, colorspace: 'hwb' }\n\t// otherwise, hwb(X, 0%, 100%), where X is the hue angle of the color\n\t: { hue: hwb.hue, whiteness: 0, blackness: 100, alpha: hwb.alpha, colorspace: 'hwb' };\n\n\t// contrast ratio\n\tconst contrastRatio = colors2contrast(color, maxContrastColor);\n\n\tconst minContrastColor = contrastRatio > 4.5\n\t\t// the color with the smallest contrast ratio with the base color that is greater than 4.5\n\t\t? colors2contrastRatioColor(hwb, maxContrastColor)\n\t// otherwise, the maximum-contrast color\n\t: maxContrastColor;\n\n\t// color(maximum-contrast blend(minimum-contrast <percentage> hwb)));\n\treturn blend(maxContrastColor, minContrastColor, percentage, 'hwb', false);\n}\n\nfunction colors2contrast(color1, color2) {\n\t// https://drafts.csswg.org/css-color/#contrast-ratio\n\tconst rgb1 = color2rgb(color1);\n\tconst rgb2 = color2rgb(color2);\n\tconst l1 = rgb2luminance(rgb1.red, rgb1.green, rgb1.blue);\n\tconst l2 = rgb2luminance(rgb2.red, rgb2.green, rgb2.blue);\n\n\treturn l1 > l2\n\t\t// if l1 is the relative luminance of the lighter of the colors\n\t\t? (l1 + 0.05) / (l2 + 0.05)\n\t// otherwise, if l2 is the relative luminance of the lighter of the colors\n\t: (l2 + 0.05) / (l1 + 0.05);\n}\n\nfunction rgb2luminance(red, green, blue) {\n\tconst [ redLuminance, greenLuminance, blueLuminance ] = [\n\t\tchannel2luminance(red),\n\t\tchannel2luminance(green),\n\t\tchannel2luminance(blue)\n\t];\n\n\t// https://drafts.csswg.org/css-color/#luminance\n\tconst luminance = 0.2126 * redLuminance + 0.7152 * greenLuminance + 0.0722 * blueLuminance;\n\n\treturn luminance;\n}\n\nfunction channel2luminance(value) {\n\t// https://drafts.csswg.org/css-color/#luminance\n\tconst luminance = value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) /1.055, 2.4);\n\n\treturn luminance;\n}\n\n// return the smallest contrast ratio from a color and a maximum contrast (credit: @thetalecrafter)\nfunction colors2contrastRatioColor(hwb, maxHWB) {\n\tconst modifiedHWB = Object.assign({}, hwb);\n\n\t// values to be used for linear interpolations in HWB space\n\tlet minW = hwb.whiteness;\n\tlet minB = hwb.blackness;\n\tlet maxW = maxHWB.whiteness;\n\tlet maxB = maxHWB.blackness;\n\n\t// find the color with the smallest contrast ratio with the base color that is greater than 4.5\n\twhile (Math.abs(minW - maxW) > 100 || Math.abs(minB - maxB) > 100) {\n\t\tconst midW = Math.round((maxW + minW) / 2);\n\t\tconst midB = Math.round((maxB + minB) / 2);\n\n\t\tmodifiedHWB.whiteness = midW;\n\t\tmodifiedHWB.blackness = midB;\n\n\t\tif (colors2contrast(modifiedHWB, hwb) > 4.5) {\n\t\t\tmaxW = midW;\n\t\t\tmaxB = midB;\n\t\t} else {\n\t\t\tminW = midW;\n\t\t\tminB = midB;\n\t\t}\n\t}\n\n\treturn modifiedHWB;\n}\n\n/* Match\n/* ========================================================================== */\n\nconst blueGreenRedMatch = /^(blue|green|red)$/i;\n\n/* Stringifiers\n/* ========================================================================== */\n\nfunction color2string(color) {\n\treturn color.colorspace === 'hsl'\n\t\t? color2hslString(color)\n\t: color.colorspace === 'hwb'\n\t\t? color2hwbString(color)\n\t: color2rgbString(color);\n}\n\nfunction color2hslString(color) {\n\tconst hsl        = color2hsl(color);\n\tconst isOpaque   = hsl.alpha === 100;\n\tconst hue        = hsl.hue;\n\tconst saturation = Math.round(hsl.saturation * 10000000000) / 10000000000;\n\tconst lightness  = Math.round(hsl.lightness * 10000000000) / 10000000000;\n\tconst alpha      = Math.round(hsl.alpha * 10000000000) / 10000000000;\n\n\treturn `hsl(${hue} ${saturation}% ${lightness}%${isOpaque\n\t\t? ''\n\t: ` / ${alpha}%`})`;\n}\n\nfunction color2hwbString(color) {\n\tconst hwb       = color2hwb(color);\n\tconst isOpaque  = hwb.alpha === 100;\n\tconst hue       = hwb.hue;\n\tconst whiteness = Math.round(hwb.whiteness * 10000000000) / 10000000000;\n\tconst blackness = Math.round(hwb.blackness * 10000000000) / 10000000000;\n\tconst alpha     = Math.round(hwb.alpha * 10000000000) / 10000000000;\n\n\treturn `hwb(${hue} ${whiteness}% ${blackness}%${isOpaque\n\t\t? ''\n\t: ` / ${alpha}%`})`;\n}\n\nfunction color2rgbString(color) {\n\tconst rgb      = color2rgb(color);\n\tconst isOpaque = rgb.alpha === 100;\n\tconst red      = Math.round(rgb.red * 10000000000) / 10000000000;\n\tconst green    = Math.round(rgb.green * 10000000000) / 10000000000;\n\tconst blue     = Math.round(rgb.blue * 10000000000) / 10000000000;\n\tconst alpha    = Math.round(rgb.alpha * 10000000000) / 10000000000;\n\n\treturn `rgb(${red}% ${green}% ${blue}%${isOpaque\n\t\t? ''\n\t: ` / ${alpha}%`})`;\n}\n\nfunction color2legacyString(color) {\n\treturn color.colorspace === 'hsl'\n\t\t? color2hslLegacyString(color)\n\t: color2rgbLegacyString(color);\n}\n\nfunction color2rgbLegacyString(color) {\n\tconst rgb      = color2rgb(color);\n\tconst isOpaque = rgb.alpha === 100;\n\tconst name     = isOpaque ? 'rgb' : 'rgba';\n\tconst red      = Math.round(rgb.red * 255 / 100);\n\tconst green    = Math.round(rgb.green * 255 / 100);\n\tconst blue     = Math.round(rgb.blue * 255 / 100);\n\tconst alpha    = Math.round(rgb.alpha / 100 * 10000000000) / 10000000000;\n\n\treturn `${name}(${red}, ${green}, ${blue}${isOpaque\n\t\t? ''\n\t: `, ${alpha}`})`;\n}\n\nfunction color2hslLegacyString(color) {\n\tconst hsl        = color2hsl(color);\n\tconst isOpaque   = hsl.alpha === 100;\n\tconst name       = isOpaque ? 'hsl' : 'hsla';\n\tconst hue        = hsl.hue;\n\tconst saturation = Math.round(hsl.saturation * 10000000000) / 10000000000;\n\tconst lightness  = Math.round(hsl.lightness * 10000000000) / 10000000000;\n\tconst alpha      = Math.round(hsl.alpha / 100 * 10000000000) / 10000000000;\n\n\treturn `${name}(${hue}, ${saturation}%, ${lightness}%${isOpaque\n\t\t? ''\n\t: `, ${alpha}`})`;\n}\n","export default function manageUnresolved(node, opts, word, message) {\n\tif ('warn' === opts.unresolved) {\n\t\topts.decl.warn(opts.result, message, { word });\n\t} else if ('ignore' !== opts.unresolved) {\n\t\tthrow opts.decl.error(message, { word });\n\t}\n}\n","// tooling\nimport { convertDtoD, convertGtoD, convertRtoD, convertTtoD, convertNtoRGB, convertHtoRGB } from './conversions';\nimport Color from './color';\nimport manageUnresolved from './manage-unresolved';\nimport parser from 'postcss-values-parser';\n\n/* Transform AST\n/* ========================================================================== */\n\nexport default function transformAST(node, opts) {\n\tnode.nodes.slice(0).forEach(child => {\n\t\tif (isColorModFunction(child)) {\n\t\t\t// transform any variables within the color-mod() function\n\t\t\tif (opts.transformVars) {\n\t\t\t\ttransformVariables(child, opts);\n\t\t\t}\n\n\t\t\t// transform any color-mod() functions\n\t\t\tconst color = transformColorModFunction(child, opts);\n\n\t\t\tif (color) {\n\t\t\t\t// update the color-mod() function with the transformed value\n\t\t\t\tchild.replaceWith(parser.word({\n\t\t\t\t\traws: child.raws,\n\t\t\t\t\tvalue: opts.stringifier(color)\n\t\t\t\t}));\n\t\t\t}\n\t\t} else if (child.nodes && Object(child.nodes).length) {\n\t\t\ttransformAST(child, opts);\n\t\t}\n\t});\n}\n\n/* Transform <var> functions\n/* ========================================================================== */\n\nfunction transformVariables(node, opts) {\n\twalk(node, child => {\n\t\tif (isVariable(child)) {\n\t\t\t// get the custom property and fallback value from var()\n\t\t\tconst [prop, fallbackNode] = transformArgsByParams(child, [\n\t\t\t\t// <value> , [ <fallback> ]?\n\t\t\t\t[transformWord, isComma, transformNode]\n\t\t\t]);\n\n\t\t\t// if the custom property is known\n\t\t\tif (prop in opts.customProperties) {\n\t\t\t\tlet customPropertyValue = opts.customProperties[prop];\n\n\t\t\t\t// follow custom properties referencing custom properties\n\t\t\t\tif (looseVarMatch.test(customPropertyValue)) {\n\t\t\t\t\tconst rootChildAST = customPropertyValue.clone();\n\n\t\t\t\t\ttransformVariables(rootChildAST, opts);\n\n\t\t\t\t\tcustomPropertyValue = rootChildAST;\n\t\t\t\t}\n\n\t\t\t\t// replace var() with the custom property value\n\t\t\t\tif (customPropertyValue.nodes.length === 1 && customPropertyValue.nodes[0].nodes.length) {\n\t\t\t\t\tcustomPropertyValue.nodes[0].nodes.forEach(customPropertyChild => {\n\t\t\t\t\t\tchild.parent.insertBefore(child, customPropertyChild);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tchild.remove();\n\t\t\t} else if (fallbackNode && fallbackNode.nodes.length === 1 && fallbackNode.nodes[0].nodes.length) {\n\t\t\t\t// otherwise, replace var() with the fallback value\n\t\t\t\ttransformVariables(fallbackNode, opts);\n\n\t\t\t\tchild.replaceWith(...fallbackNode.nodes[0].nodes[0]);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/* Transform <color> functions\n/* ========================================================================== */\n\nfunction transformColor(node, opts) {\n\tif (isRGBFunction(node)) {\n\t\treturn transformRGBFunction(node, opts);\n\t} else if (isHSLFunction(node)) {\n\t\treturn transformHSLFunction(node, opts);\n\t} else if (isHWBFunction(node)) {\n\t\treturn transformHWBFunction(node, opts);\n\t} else if (isColorModFunction(node)) {\n\t\treturn transformColorModFunction(node, opts);\n\t} else if (isHexColor(node)) {\n\t\treturn transformHexColor(node, opts);\n\t} else if (isNamedColor(node)) {\n\t\treturn transformNamedColor(node, opts);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a color`);\n\t}\n}\n\n// return a transformed rgb/rgba color function\nfunction transformRGBFunction(node, opts) {\n\tconst [red, green, blue, alpha = 100] = transformArgsByParams(node, [\n\t\t// <percentage> <percentage> <percentage> [ , <alpha-value> ]?\n\t\t[transformPercentage, transformPercentage, transformPercentage, isSlash, transformAlpha],\n\t\t// <number> <number> <number> [ , <alpha-value> ]?\n\t\t[transformRGBNumber, transformRGBNumber, transformRGBNumber, isSlash, transformAlpha],\n\t\t// <percentage> , <percentage> , <percentage> [ , <alpha-value> ]?\n\t\t[transformPercentage, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha],\n\t\t// <number> , <number> , <number> [ , <alpha-value> ]?\n\t\t[transformRGBNumber, isComma, transformRGBNumber, isComma, transformRGBNumber, isComma, transformAlpha]\n\t]);\n\n\tif (red !== undefined) {\n\t\tconst color = new Color({ red, green, blue, alpha, colorspace: 'rgb' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid rgb() function`);\n\t}\n}\n\n// return a transformed hsl/hsla color function\nfunction transformHSLFunction(node, opts) {\n\tconst [hue, saturation, lightness, alpha = 100] = transformArgsByParams(node, [\n\t\t// <hue> <percentage> <percentage> [ / <alpha-value> ]?\n\t\t[transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha],\n\t\t// <hue> , <percentage> , <percentage> [ , <alpha-value> ]?\n\t\t[transformHue, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha]\n\t]);\n\n\tif (lightness !== undefined) {\n\t\tconst color = new Color({ hue, saturation, lightness, alpha, colorspace: 'hsl' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hsl() function`);\n\t}\n}\n\n// return a transformed hwb color function\nfunction transformHWBFunction(node, opts) {\n\tconst [hue, whiteness, blackness, alpha = 100] = transformArgsByParams(node, [\n\t\t// <hue> <percentage> <percentage> [ / <alpha-value> ]?\n\t\t[transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha]\n\t]);\n\n\tif (blackness !== undefined) {\n\t\tconst color = new Color({ hue, whiteness, blackness, alpha, colorspace: 'hwb' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hwb() function`);\n\t}\n}\n\n// return a transformed color-mod color function\nfunction transformColorModFunction(node, opts) {\n\t// [ <color> | <hue> ] <color-adjuster>*\n\tconst [colorOrHueNode, ...adjusterNodes] = (node.nodes || []).slice(1, -1) || [];\n\n\tif (colorOrHueNode !== undefined) {\n\t\tconst color = isHue(colorOrHueNode)\n\t\t\t? new Color({\n\t\t\t\thue: transformHue(colorOrHueNode, opts),\n\t\t\t\tsaturation: 100,\n\t\t\t\tlightness: 50,\n\t\t\t\talpha: 100,\n\t\t\t\tcolorspace: 'hsl'\n\t\t\t})\n\t\t: transformColor(colorOrHueNode, opts);\n\n\t\tif (color) {\n\t\t\tconst adjustedColor = transformColorByAdjusters(color, adjusterNodes, opts);\n\n\t\t\treturn adjustedColor;\n\t\t} else {\n\t\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid color`);\n\t\t}\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid color-mod() function`);\n\t}\n}\n\n// return a transformed hex color\nfunction transformHexColor(node, opts) {\n\tif (hexColorMatch.test(node.value)) {\n\t\t// #<hex-color>{3,4,6,8}\n\t\tconst [red, green, blue, alpha] = convertHtoRGB(node.value);\n\n\t\tconst color = new Color({ red, green, blue, alpha });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hex color`);\n\t}\n}\n\n// return a transformed named-color\nfunction transformNamedColor(node, opts) {\n\tif (isNamedColor(node)) {\n\t\t// <named-color>\n\t\tconst [red, green, blue] = convertNtoRGB(node.value);\n\n\t\tconst color = new Color({ red, green, blue, alpha: 100, colorspace: 'rgb' });\n\n\t\treturn color;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid named-color`);\n\t}\n}\n\n/* Transform <color-adjuster> functions\n/* ========================================================================== */\n\n// return a transformed color using adjustments\nfunction transformColorByAdjusters(color, adjusterNodes, opts) {\n\tconst adjustedColor = adjusterNodes.reduce((base, node) => {\n\t\tif (isAlphaBlueGreenRedAdjuster(node)) {\n\t\t\treturn transformAlphaBlueGreenRedAdjuster(base, node, opts);\n\t\t} else if (isRGBAdjuster(node)) {\n\t\t\treturn transformRGBAdjuster(base, node, opts);\n\t\t} else if (isHueAdjuster(node)) {\n\t\t\treturn transformHueAdjuster(base, node, opts);\n\t\t} else if (isBlacknessLightnessSaturationWhitenessAdjuster(node)) {\n\t\t\treturn transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts);\n\t\t} else if (isShadeTintAdjuster(node)) {\n\t\t\treturn transformShadeTintAdjuster(base, node, opts);\n\t\t} else if (isBlendAdjuster(node)) {\n\t\t\treturn transformBlendAdjuster(base, node, node.value === 'blenda', opts);\n\t\t} else if (isContrastAdjuster(node)) {\n\t\t\treturn transformContrastAdjuster(base, node, opts);\n\t\t} else {\n\t\t\tmanageUnresolved(node, opts, node.value, `Expected a valid color adjuster`);\n\n\t\t\treturn base;\n\t\t}\n\t}, color);\n\n\treturn adjustedColor;\n}\n\n// return a transformed color using a/alpha/blue/green/red adjustments\nfunction transformAlphaBlueGreenRedAdjuster(base, node, opts) {\n\tconst [operatorOrValue, adjustment] = transformArgsByParams(node, alphaMatch.test(node.value)\n\t\t\t// a/alpha adjustments\n\t\t\t? [\n\t\t\t\t// [ + | - ] <alpha-value>\n\t\t\t\t[transformMinusPlusOperator, transformAlpha],\n\t\t\t\t// * <percentage>\n\t\t\t\t[transformTimesOperator, transformPercentage],\n\t\t\t\t// <alpha-value>\n\t\t\t\t[transformAlpha]\n\t\t\t]\n\t\t// blue/green/red adjustments\n\t\t: [\n\t\t\t// [ + | - ] <percentage>\n\t\t\t[transformMinusPlusOperator, transformPercentage],\n\t\t\t// [ + | - ] <number>\n\t\t\t[transformMinusPlusOperator, transformRGBNumber],\n\t\t\t// * <percentage>\n\t\t\t[transformTimesOperator, transformPercentage],\n\t\t\t// <percentage>\n\t\t\t[transformPercentage],\n\t\t\t// <number>\n\t\t\t[transformRGBNumber]\n\t\t]\n\t);\n\n\tif (operatorOrValue !== undefined) {\n\t\t// normalized channel name\n\t\tconst channel = node.value.toLowerCase().replace(alphaMatch, 'alpha');\n\n\t\tconst existingValue = base[channel]();\n\n\t\tconst modifiedValue = adjustment !== undefined\n\t\t\t? operatorOrValue === '+'\n\t\t\t\t? existingValue + Number(adjustment)\n\t\t\t: operatorOrValue === '-'\n\t\t\t\t? existingValue - Number(adjustment)\n\t\t\t: operatorOrValue === '*'\n\t\t\t\t? existingValue * Number(adjustment)\n\t\t\t: Number(adjustment)\n\t\t: Number(operatorOrValue);\n\n\t\tconst modifiedColor = base[channel](modifiedValue);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid modifier()`);\n\t}\n}\n\n// return a transformed color using an rgb adjustment\nfunction transformRGBAdjuster(base, node, opts) {\n\tconst [arg1, arg2, arg3, arg4] = transformArgsByParams(node, [\n\t\t\t// [ + | - ] <percentage> <percentage> <percentage>\n\t\t\t[transformMinusPlusOperator, transformPercentage, transformPercentage, transformPercentage],\n\t\t\t// [ + | - ] <number> <number> <number>\n\t\t\t[transformMinusPlusOperator, transformRGBNumber, transformRGBNumber, transformRGBNumber],\n\t\t\t// [ + | - ] <hash-token>\n\t\t\t[transformMinusPlusOperator, transformHexColor],\n\t\t\t// [ * ] <percentage>\n\t\t\t[transformTimesOperator, transformPercentage]\n\t\t]\n\t);\n\n\tif (arg2 !== undefined && arg2.color) {\n\t\tconst modifiedColor = base.rgb(\n\t\t\targ1 === '+'\n\t\t\t\t? base.red() + arg2.red()\n\t\t\t: base.red() - arg2.red(),\n\t\t\targ1 === '+'\n\t\t\t\t? base.green() + arg2.green()\n\t\t\t: base.green() - arg2.green(),\n\t\t\targ1 === '+'\n\t\t\t\t? base.blue() + arg2.blue()\n\t\t\t: base.blue() - arg2.blue()\n\t\t);\n\n\t\treturn modifiedColor;\n\t} else if (arg1 !== undefined && minusPlusMatch.test(arg1)) {\n\t\tconst modifiedColor = base.rgb(\n\t\t\targ1 === '+'\n\t\t\t\t? base.red() + arg2\n\t\t\t: base.red() - arg2,\n\t\t\targ1 === '+'\n\t\t\t\t? base.green() + arg3\n\t\t\t: base.green() - arg3,\n\t\t\targ1 === '+'\n\t\t\t\t? base.blue() + arg4\n\t\t\t: base.blue() - arg4\n\t\t);\n\n\t\treturn modifiedColor;\n\t} else if (arg1 !== undefined && arg2 !== undefined) {\n\t\tconst modifiedColor = base.rgb(\n\t\t\tbase.red() * arg2,\n\t\t\tbase.green() * arg2,\n\t\t\tbase.blue() * arg2\n\t\t);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid rgb() adjuster`);\n\t}\n}\n\n// return a transformed color using a blend/blenda adjustment\nfunction transformBlendAdjuster(base, node, isAlphaBlend, opts) {\n\tconst [color, percentage, colorspace = 'rgb'] = transformArgsByParams(node, [\n\t\t[transformColor, transformPercentage, transformColorSpace]\n\t]);\n\n\tif (percentage !== undefined) {\n\t\tconst modifiedColor = isAlphaBlend\n\t\t\t? base.blenda(color.color, percentage, colorspace)\n\t\t: base.blend(color.color, percentage, colorspace);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid blend() adjuster)`);\n\t}\n}\n\n// return a transformed color using a contrast adjustment\nfunction transformContrastAdjuster(base, node, opts) {\n\tconst [percentage] = transformArgsByParams(node, [\n\t\t// <percentage>\n\t\t[transformPercentage]\n\t]);\n\n\tif (percentage !== undefined) {\n\t\tconst modifiedColor = base.contrast(percentage);\n\n\t\treturn modifiedColor;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid contrast() adjuster)`);\n\t}\n}\n\n// return a transformed color using a hue adjustment\nfunction transformHueAdjuster(base, node, opts) {\n\tconst [operatorOrHue, adjustment] = transformArgsByParams(node, [\n\t\t// [ + | - | * ] <angle>\n\t\t[transformMinusPlusTimesOperator, transformHue],\n\t\t// <angle>\n\t\t[transformHue]\n\t]);\n\n\tif (operatorOrHue !== undefined) {\n\t\tconst existingHue = base.hue();\n\n\t\tconst modifiedValue = adjustment !== undefined\n\t\t\t? operatorOrHue === '+'\n\t\t\t\t? existingHue + Number(adjustment)\n\t\t\t: operatorOrHue === '-'\n\t\t\t\t? existingHue - Number(adjustment)\n\t\t\t: operatorOrHue === '*'\n\t\t\t\t? existingHue * Number(adjustment)\n\t\t\t: Number(adjustment)\n\t\t: Number(operatorOrHue);\n\n\t\treturn base.hue(modifiedValue);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hue() function)`);\n\t}\n}\n\n// [ b | blackness | l | lightness | s | saturation | w | whiteness ]( [ + | - | * ]? <percentage> )\nfunction transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts) {\n\tconst channel = node.value.toLowerCase().replace(/^b$/, 'blackness').replace(/^l$/, 'lightness').replace(/^s$/, 'saturation').replace(/^w$/, 'whiteness');\n\tconst [operatorOrValue, adjustment] = transformArgsByParams(node, [\n\t\t[transformMinusPlusTimesOperator, transformPercentage],\n\t\t[transformPercentage]\n\t]);\n\n\tif (operatorOrValue !== undefined) {\n\t\tconst existingValue = base[channel]();\n\n\t\tconst modifiedValue = adjustment !== undefined\n\t\t\t? operatorOrValue === '+'\n\t\t\t\t? existingValue + Number(adjustment)\n\t\t\t: operatorOrValue === '-'\n\t\t\t\t? existingValue - Number(adjustment)\n\t\t\t: operatorOrValue === '*'\n\t\t\t\t? existingValue * Number(adjustment)\n\t\t\t: Number(adjustment)\n\t\t: Number(operatorOrValue);\n\n\t\treturn base[channel](modifiedValue);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid ${channel}() function)`);\n\t}\n}\n\n// return a transformed color using shade/tint adjustments\nfunction transformShadeTintAdjuster(base, node, opts) {\n\tconst channel = node.value.toLowerCase();\n\tconst [percentage] = transformArgsByParams(node, [\n\t\t// [ shade | tint ]( <percentage> )\n\t\t[transformPercentage]\n\t]);\n\n\tif (percentage !== undefined) {\n\t\tconst modifiedValue = Number(percentage);\n\n\t\treturn base[channel](modifiedValue);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected valid ${channel}() arguments`);\n\t}\n}\n\n/* Argument Transforms\n/* ========================================================================== */\n\n// return a transformed color space\nfunction transformColorSpace(node, opts) {\n\tif (isColorSpace(node)) {\n\t\t// [ hsl | hwb | rgb ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid color space)`);\n\t}\n}\n\n// return a transformed alpha value\nfunction transformAlpha(node, opts) {\n\tif (isNumber(node)) {\n\t\t// <number>\n\t\treturn node.value * 100;\n\t} else if (isPercentage(node)) {\n\t\t// <percentage>\n\t\treturn transformPercentage(node, opts);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid alpha value)`);\n\t}\n}\n\n// return a transformed rgb number\nfunction transformRGBNumber(node, opts) {\n\tif (isNumber(node)) {\n\t\t// <number>\n\t\treturn node.value / 2.55;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid RGB value)`);\n\t}\n}\n\n// return a transformed hue\nfunction transformHue(node, opts) {\n\tif (isHue(node)) {\n\t\t// <hue> = <number> | <angle>\n\t\tconst unit = node.unit.toLowerCase();\n\n\t\tif (unit === 'grad') {\n\t\t\t// if <angle> = <gradian> (400 per circle)\n\t\t\treturn convertGtoD(node.value);\n\t\t} else if (unit === 'rad') {\n\t\t\t// if <angle> = <radian> (2π per circle)\n\t\t\treturn convertRtoD(node.value);\n\t\t} else if (unit === 'turn') {\n\t\t\t// if <angle> = <turn> (1 per circle)\n\t\t\treturn convertTtoD(node.value);\n\t\t} else {\n\t\t\t// if <angle> = [ <degree> | <number> ] (360 per circle)\n\t\t\treturn convertDtoD(node.value);\n\t\t}\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hue`);\n\t}\n}\n\n// return a transformed percentage\nfunction transformPercentage(node, opts) {\n\tif (isPercentage(node)) {\n\t\t// <percentage>\n\t\treturn Number(node.value);\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid hue`);\n\t}\n}\n\n// return a transformed minus-plus operator\nfunction transformMinusPlusOperator(node, opts) {\n\tif (isMinusPlusOperator(node)) {\n\t\t// [ - | + ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a plus or minus operator`);\n\t}\n}\n\n// return a transformed times operator\nfunction transformTimesOperator(node, opts) {\n\tif (isTimesOperator(node)) {\n\t\t// [ * ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a times operator`);\n\t}\n}\n\n// return a transformed minus-plus-times operator\nfunction transformMinusPlusTimesOperator(node, opts) {\n\tif (isMinusPlusTimesOperator(node)) {\n\t\t// [ - | + | * ]\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a plus, minus, or times operator`);\n\t}\n}\n\n/* Additional transforms\n/* ========================================================================== */\n\nfunction transformWord(node, opts) {\n\tif (isWord(node)) {\n\t\treturn node.value;\n\t} else {\n\t\treturn manageUnresolved(node, opts, node.value, `Expected a valid word`);\n\t}\n}\n\nfunction transformNode(node) {\n\treturn Object(node);\n}\n\n/* Transform helper\n/* ========================================================================== */\n\n// return the first set of transformed arguments allowable by the parameters\nfunction transformArgsByParams(node, params) {\n\tconst nodes = (node.nodes || []).slice(1, -1);\n\tconst opts = { unresolved: 'ignore' };\n\n\treturn params.map(param => nodes.map(\n\t\t(childNode, index) => typeof param[index] === 'function' ? param[index](childNode, opts) : undefined\n\t).filter(child => typeof child !== 'boolean')).filter(param => param.every(\n\t\tresult => result !== undefined\n\t))[0] || [];\n}\n\n/* Walk helper (required because the default walker is affected by mutations)\n/* ========================================================================== */\n\n// run a function over each node and hen walk each child node of that node\nfunction walk(node, fn) {\n\tfn(node);\n\n\tif (Object(node.nodes).length) {\n\t\tnode.nodes.slice().forEach(childNode => {\n\t\t\twalk(childNode, fn);\n\t\t});\n\t}\n}\n\n/* Variable validators\n/* ========================================================================== */\n\n// return whether the node is a var function\nfunction isVariable(node) {\n\t// var()\n\treturn Object(node).type === 'func' && varMatch.test(node.value);\n}\n\n/* Adjustment validators\n/* ========================================================================== */\n\n// return whether the node is an a/alpha/blue/green/red adjuster\nfunction isAlphaBlueGreenRedAdjuster(node) {\n\t// [ a(), alpha(), blue(), green(), red() ]\n\treturn Object(node).type === 'func' && alphaBlueGreenRedMatch.test(node.value);\n}\n\n// return whether the node is an rgb adjuster\nfunction isRGBAdjuster(node) {\n\treturn Object(node).type === 'func' && rgbMatch.test(node.value);\n}\n\n// return whether the node is a hue adjuster\nfunction isHueAdjuster(node) {\n\t// [ h() | hue() ]\n\treturn Object(node).type === 'func' && hueMatch.test(node.value);\n}\n\n// return whether the node is a blackness/lightness/saturation/whiteness adjuster\nfunction isBlacknessLightnessSaturationWhitenessAdjuster(node) {\n\t// [ b() | blackness() | l() | lightness() | s() | saturation() | w() | whiteness() ]\n\treturn Object(node).type === 'func' && blacknessLightnessSaturationWhitenessMatch.test(node.value);\n}\n\n// return whether the node is a shade/tint adjuster\nfunction isShadeTintAdjuster(node) {\n\t// [ shade() | tint() ]\n\treturn Object(node).type === 'func' && shadeTintMatch.test(node.value);\n}\n\n// return whether the node is a blend adjuster\nfunction isBlendAdjuster(node) {\n\t// [ blend(), blenda() ]\n\treturn Object(node).type === 'func' && blendMatch.test(node.value);\n}\n\n// return whether the node is a contrast adjuster\nfunction isContrastAdjuster(node) {\n\t// [ contrast() ]\n\treturn Object(node).type === 'func' && contrastMatch.test(node.value);\n}\n\n/* Color validators\n/* ========================================================================== */\n\n// return whether the node is an rgb/rgba color function\nfunction isRGBFunction(node) {\n\t// [ rgb(), rgba() ]\n\treturn Object(node).type === 'func' && rgbaMatch.test(node.value);\n}\n\n// return whether the node is an hsl color function\nfunction isHSLFunction(node) {\n\t// [ hsl(), hsla() ]\n\treturn Object(node).type === 'func' && hslaMatch.test(node.value);\n}\n\n// return whether the node is an hwb color function\nfunction isHWBFunction(node) {\n\t// hwb()\n\treturn Object(node).type === 'func' && hwbMatch.test(node.value);\n}\n\n// return whether the node is a color-mod function\nfunction isColorModFunction(node) {\n\t// color-mod()\n\treturn Object(node).type === 'func' && colorModMatch.test(node.value);\n}\n\n// return whether the node is a valid named-color\nfunction isNamedColor(node) {\n\treturn Object(node).type === 'word' && Boolean(convertNtoRGB(node.value));\n}\n\n// return whether the node is a valid hex color\nfunction isHexColor(node) {\n\t// #<hex-color>{3,4,6,8}\n\treturn Object(node).type === 'word' && hexColorMatch.test(node.value);\n}\n\n// return whether the node is a valid color space\nfunction isColorSpace(node) {\n\t// [ hsl | hwb | rgb ]\n\treturn Object(node).type === 'word' && colorSpaceMatch.test(node.value);\n}\n\n/* Additional validators\n/* ========================================================================== */\n\n// return whether the hue value is valid\nfunction isHue(node) {\n\treturn Object(node).type === 'number' && hueUnitMatch.test(node.unit);\n}\n\n// return whether the comma is valid\nfunction isComma(node) {\n\treturn Object(node).type === 'comma';\n}\n\n// return whether the slash operator is valid\nfunction isSlash(node) {\n\treturn Object(node).type === 'operator' && node.value === '/';\n}\n\n// return whether the number is valid\nfunction isNumber(node) {\n\treturn Object(node).type === 'number' && node.unit === '';\n}\n\n// return whether the mind-plus operator is valid\nfunction isMinusPlusOperator(node) {\n\treturn Object(node).type === 'operator' && minusPlusMatch.test(node.value);\n}\n\n// return whether the minus-plus-times operator is valid\nfunction isMinusPlusTimesOperator(node) {\n\treturn Object(node).type === 'operator' && minusPlusTimesMatch.test(node.value);\n}\n\n// return whether the times operator is valid\nfunction isTimesOperator(node) {\n\treturn Object(node).type === 'operator' && timesMatch.test(node.value);\n}\n\n// return whether the percentage is valid\nfunction isPercentage(node) {\n\treturn Object(node).type === 'number' && (node.unit === '%' || node.value === '0');\n}\n\n// return whether the node is a word\nfunction isWord(node) {\n\t// <word>\n\treturn Object(node).type === 'word';\n}\n\n/* Matchers\n/* ========================================================================== */\n\nconst alphaMatch = /^a(lpha)?$/i;\nconst alphaBlueGreenRedMatch = /^(a(lpha)?|blue|green|red)$/i;\nconst blacknessLightnessSaturationWhitenessMatch = /^(b(lackness)?|l(ightness)?|s(aturation)?|w(hiteness)?)$/i;\nconst blendMatch = /^blenda?$/i;\nconst colorModMatch = /^color-mod$/i;\nconst colorSpaceMatch = /^(hsl|hwb|rgb)$/i;\nconst contrastMatch = /^contrast$/i;\nconst hexColorMatch = /^#(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i;\nconst hslaMatch = /^hsla?$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\nconst hueMatch = /^h(ue)?$/i;\nconst hwbMatch = /^hwb$/i;\nconst minusPlusMatch = /^[+-]$/;\nconst minusPlusTimesMatch = /^[*+-]$/;\nconst rgbMatch = /^rgb$/i;\nconst rgbaMatch = /^rgba?$/i;\nconst shadeTintMatch = /^(shade|tint)$/i;\nconst varMatch = /^var$/i;\nconst looseVarMatch = /(^|[^\\w-])var\\(/i;\nconst timesMatch = /^[*]$/;\n","import getCustomProperties from './lib/get-custom-properties';\nimport importCustomPropertiesFromSources from './lib/import-from';\nimport parser from 'postcss-values-parser';\nimport postcss from 'postcss';\nimport transformAST from './lib/transform';\n\nexport default postcss.plugin('postcss-color-mod-function', opts => {\n\t// how unresolved functions and arguments should be handled (default: \"throw\")\n\tconst unresolvedOpt = String(Object(opts).unresolved || 'throw').toLowerCase();\n\n\t// how transformed colors will be produced in CSS\n\tconst stringifierOpt = Object(opts).stringifier || (color => color.toLegacy());\n\n\t// sources to import custom selectors from\n\tconst importFrom = [].concat(Object(opts).importFrom || []);\n\n\t//  whether var() within color-mod() should use Custom Properties or var() fallback\n\tconst transformVarsOpt = 'transformVars' in Object(opts) ? opts.transformVars : true;\n\n\t// promise any custom selectors are imported\n\tconst customPropertiesPromise = importCustomPropertiesFromSources(importFrom);\n\n\treturn async (root, result) => {\n\t\tconst customProperties = Object.assign(\n\t\t\tawait customPropertiesPromise,\n\t\t\tgetCustomProperties(root, { preserve: true })\n\t\t);\n\n\t\troot.walkDecls(decl => {\n\t\t\tconst originalValue = decl.value;\n\n\t\t\tif (colorModFunctionMatch.test(originalValue)) {\n\t\t\t\tconst ast = parser(originalValue, { loose: true }).parse();\n\n\t\t\t\ttransformAST(ast, {\n\t\t\t\t\tunresolved: unresolvedOpt,\n\t\t\t\t\tstringifier: stringifierOpt,\n\t\t\t\t\ttransformVars: transformVarsOpt,\n\t\t\t\t\tdecl,\n\t\t\t\t\tresult,\n\t\t\t\t\tcustomProperties\n\t\t\t\t});\n\n\t\t\t\tconst modifiedValue = ast.toString();\n\n\t\t\t\tif (originalValue !== modifiedValue) {\n\t\t\t\t\tdecl.value = modifiedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\nconst colorModFunctionMatch = /(^|[^\\w-])color-mod\\(/i;\n"]},"metadata":{},"sourceType":"script"}