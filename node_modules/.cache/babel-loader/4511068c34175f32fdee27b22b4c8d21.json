{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst postcss = require('postcss');\n\nconst timsort = require('timsort').sort;\n\nmodule.exports = postcss.plugin('css-declaration-sorter', function (options) {\n  return function (css) {\n    let sortOrderPath;\n    options = options || {}; // Use included sorting order if order is passed and not alphabetically\n\n    if (options.order && options.order !== 'alphabetically') {\n      sortOrderPath = path.join(__dirname, '../orders/', options.order) + '.json';\n    } else if (options.customOrder) {\n      sortOrderPath = options.customOrder;\n    } else {\n      // Fallback to the default sorting order\n      return processCss(css, 'alphabetically');\n    } // Load in the array containing the order from a JSON file\n\n\n    return new Promise(function (resolve, reject) {\n      fs.readFile(sortOrderPath, function (error, data) {\n        if (error) return reject(error);\n        resolve(data);\n      });\n    }).then(function (data) {\n      return processCss(css, JSON.parse(data));\n    });\n  };\n});\n\nfunction processCss(css, sortOrder) {\n  const comments = [];\n  const rulesCache = [];\n  css.walk(function (node) {\n    const nodes = node.nodes;\n    const type = node.type;\n\n    if (type === 'comment') {\n      // Don't do anything to root comments or the last newline comment\n      const isNewlineNode = ~node.raws.before.indexOf('\\n');\n      const lastNewlineNode = isNewlineNode && !node.next();\n      const onlyNode = !node.prev() && !node.next();\n\n      if (lastNewlineNode || onlyNode || node.parent.type === 'root') {\n        return;\n      }\n\n      if (isNewlineNode) {\n        const pairedNode = node.next() ? node.next() : node.prev().prev();\n\n        if (pairedNode) {\n          comments.unshift({\n            'comment': node,\n            'pairedNode': pairedNode,\n            'insertPosition': node.next() ? 'Before' : 'After'\n          });\n          node.remove();\n        }\n      } else {\n        const pairedNode = node.prev() ? node.prev() : node.next().next();\n\n        if (pairedNode) {\n          comments.push({\n            'comment': node,\n            'pairedNode': pairedNode,\n            'insertPosition': 'After'\n          });\n          node.remove();\n        }\n      }\n\n      return;\n    } // Add rule-like nodes to a cache so that we can remove all\n    // comment nodes before we start sorting.\n\n\n    const isRule = type === 'rule' || type === 'atrule';\n\n    if (isRule && nodes && nodes.length > 1) {\n      rulesCache.push(nodes);\n    }\n  }); // Perform a sort once all comment nodes are removed\n\n  rulesCache.forEach(function (nodes) {\n    sortCssDecls(nodes, sortOrder);\n  }); // Add comments back to the nodes they are paired with\n\n  comments.forEach(function (node) {\n    const pairedNode = node.pairedNode;\n    node.comment.remove();\n    pairedNode.parent['insert' + node.insertPosition](pairedNode, node.comment);\n  });\n} // Sort CSS declarations alphabetically or using the set sorting order\n\n\nfunction sortCssDecls(cssDecls, sortOrder) {\n  if (sortOrder === 'alphabetically') {\n    timsort(cssDecls, function (a, b) {\n      if (a.type === 'decl' && b.type === 'decl') {\n        return comparator(a.prop, b.prop);\n      } else {\n        return compareDifferentType(a, b);\n      }\n    });\n  } else {\n    timsort(cssDecls, function (a, b) {\n      if (a.type === 'decl' && b.type === 'decl') {\n        const aIndex = sortOrder.indexOf(a.prop);\n        const bIndex = sortOrder.indexOf(b.prop);\n        return comparator(aIndex, bIndex);\n      } else {\n        return compareDifferentType(a, b);\n      }\n    });\n  }\n}\n\nfunction comparator(a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\n\nfunction compareDifferentType(a, b) {\n  if (b.type === 'atrule') {\n    return 0;\n  }\n\n  return a.type === 'decl' ? -1 : b.type === 'decl' ? 1 : 0;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/css-declaration-sorter/src/index.js"],"names":["fs","require","path","postcss","timsort","sort","module","exports","plugin","options","css","sortOrderPath","order","join","__dirname","customOrder","processCss","Promise","resolve","reject","readFile","error","data","then","JSON","parse","sortOrder","comments","rulesCache","walk","node","nodes","type","isNewlineNode","raws","before","indexOf","lastNewlineNode","next","onlyNode","prev","parent","pairedNode","unshift","remove","push","isRule","length","forEach","sortCssDecls","comment","insertPosition","cssDecls","a","b","comparator","prop","compareDifferentType","aIndex","bIndex"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst postcss = require('postcss');\nconst timsort = require('timsort').sort;\n\nmodule.exports = postcss.plugin('css-declaration-sorter', function (options) {\n  return function (css) {\n    let sortOrderPath;\n\n    options = options || {};\n\n    // Use included sorting order if order is passed and not alphabetically\n    if (options.order && options.order !== 'alphabetically') {\n      sortOrderPath = path.join(__dirname, '../orders/', options.order) + '.json';\n    } else if (options.customOrder) {\n      sortOrderPath = options.customOrder;\n    } else {\n      // Fallback to the default sorting order\n      return processCss(css, 'alphabetically');\n    }\n\n    // Load in the array containing the order from a JSON file\n    return new Promise(function (resolve, reject) {\n      fs.readFile(sortOrderPath, function (error, data) {\n        if (error) return reject(error);\n        resolve(data);\n      });\n    }).then(function (data) {\n      return processCss(css, JSON.parse(data));\n    });\n  };\n});\n\nfunction processCss (css, sortOrder) {\n  const comments = [];\n  const rulesCache = [];\n\n  css.walk(function (node) {\n    const nodes = node.nodes;\n    const type = node.type;\n\n    if (type === 'comment') {\n      // Don't do anything to root comments or the last newline comment\n      const isNewlineNode = ~node.raws.before.indexOf('\\n');\n      const lastNewlineNode = isNewlineNode && !node.next();\n      const onlyNode = !node.prev() && !node.next();\n\n      if (lastNewlineNode || onlyNode || node.parent.type === 'root') {\n        return;\n      }\n\n      if (isNewlineNode) {\n        const pairedNode = node.next() ? node.next() : node.prev().prev();\n        if (pairedNode) {\n          comments.unshift({\n            'comment': node,\n            'pairedNode': pairedNode,\n            'insertPosition': node.next() ? 'Before' : 'After',\n          });\n          node.remove();\n        }\n      } else {\n        const pairedNode = node.prev() ? node.prev() : node.next().next();\n        if (pairedNode) {\n          comments.push({\n            'comment': node,\n            'pairedNode': pairedNode,\n            'insertPosition': 'After',\n          });\n          node.remove();\n        }\n      }\n      return;\n    }\n\n    // Add rule-like nodes to a cache so that we can remove all\n    // comment nodes before we start sorting.\n    const isRule = type === 'rule' || type === 'atrule';\n    if (isRule && nodes && nodes.length > 1) {\n      rulesCache.push(nodes);\n    }\n  });\n\n  // Perform a sort once all comment nodes are removed\n  rulesCache.forEach(function (nodes) {\n    sortCssDecls(nodes, sortOrder);\n  });\n\n  // Add comments back to the nodes they are paired with\n  comments.forEach(function (node) {\n    const pairedNode = node.pairedNode;\n    node.comment.remove();\n    pairedNode.parent['insert' + node.insertPosition](pairedNode, node.comment);\n  });\n}\n\n// Sort CSS declarations alphabetically or using the set sorting order\nfunction sortCssDecls (cssDecls, sortOrder) {\n  if (sortOrder === 'alphabetically') {\n    timsort(cssDecls, function (a, b) {\n      if (a.type === 'decl' && b.type === 'decl') {\n        return comparator(a.prop, b.prop);\n      } else {\n        return compareDifferentType(a, b);\n      }\n    });\n  } else {\n    timsort(cssDecls, function (a, b) {\n      if (a.type === 'decl' && b.type === 'decl') {\n        const aIndex = sortOrder.indexOf(a.prop);\n        const bIndex = sortOrder.indexOf(b.prop);\n        return comparator(aIndex, bIndex);\n      } else {\n        return compareDifferentType(a, b);\n      }\n    });\n  }\n}\n\nfunction comparator (a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\n\nfunction compareDifferentType (a, b) {\n  if (b.type === 'atrule') { return  0; }\n\n  return (a.type === 'decl') ? -1 : (b.type === 'decl') ? 1 : 0;\n}\n"]},"metadata":{},"sourceType":"script"}