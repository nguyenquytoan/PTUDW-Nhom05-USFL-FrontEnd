{"ast":null,"code":"//      \n'use strict';\n\nconst path = require('path');\n\nconst loaders = require('./loaders');\n\nconst readFile = require('./readFile');\n\nconst cacheWrapper = require('./cacheWrapper');\n\nconst getDirectory = require('./getDirectory');\n\nconst getPropertyByPath = require('./getPropertyByPath');\n\nconst MODE_SYNC = 'sync'; // An object value represents a config object.\n// null represents that the loader did not find anything relevant.\n// undefined represents that the loader found something relevant\n// but it was empty.\n\nclass Explorer {\n  constructor(options) {\n    this.loadCache = options.cache ? new Map() : null;\n    this.loadSyncCache = options.cache ? new Map() : null;\n    this.searchCache = options.cache ? new Map() : null;\n    this.searchSyncCache = options.cache ? new Map() : null;\n    this.config = options;\n    this.validateConfig();\n  }\n\n  clearLoadCache() {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n\n    if (this.loadSyncCache) {\n      this.loadSyncCache.clear();\n    }\n  }\n\n  clearSearchCache() {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n\n    if (this.searchSyncCache) {\n      this.searchSyncCache.clear();\n    }\n  }\n\n  clearCaches() {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  validateConfig() {\n    const config = this.config;\n    config.searchPlaces.forEach(place => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n\n      if (!loader) {\n        throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item \"${place}\" is invalid`);\n      }\n    });\n  }\n\n  search(searchFrom) {\n    searchFrom = searchFrom || process.cwd();\n    return getDirectory(searchFrom).then(dir => {\n      return this.searchFromDirectory(dir);\n    });\n  }\n\n  searchFromDirectory(dir) {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = () => {\n      return this.searchDirectory(absoluteDir).then(result => {\n        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n        if (nextDir) {\n          return this.searchFromDirectory(nextDir);\n        }\n\n        return this.config.transform(result);\n      });\n    };\n\n    if (this.searchCache) {\n      return cacheWrapper(this.searchCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  searchSync(searchFrom) {\n    searchFrom = searchFrom || process.cwd();\n    const dir = getDirectory.sync(searchFrom);\n    return this.searchFromDirectorySync(dir);\n  }\n\n  searchFromDirectorySync(dir) {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = () => {\n      const result = this.searchDirectorySync(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n      if (nextDir) {\n        return this.searchFromDirectorySync(nextDir);\n      }\n\n      return this.config.transform(result);\n    };\n\n    if (this.searchSyncCache) {\n      return cacheWrapper(this.searchSyncCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  searchDirectory(dir) {\n    return this.config.searchPlaces.reduce((prevResultPromise, place) => {\n      return prevResultPromise.then(prevResult => {\n        if (this.shouldSearchStopWithResult(prevResult)) {\n          return prevResult;\n        }\n\n        return this.loadSearchPlace(dir, place);\n      });\n    }, Promise.resolve(null));\n  }\n\n  searchDirectorySync(dir) {\n    let result = null;\n\n    for (const place of this.config.searchPlaces) {\n      result = this.loadSearchPlaceSync(dir, place);\n      if (this.shouldSearchStopWithResult(result)) break;\n    }\n\n    return result;\n  }\n\n  shouldSearchStopWithResult(result) {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  loadSearchPlace(dir, place) {\n    const filepath = path.join(dir, place);\n    return readFile(filepath).then(content => {\n      return this.createCosmiconfigResult(filepath, content);\n    });\n  }\n\n  loadSearchPlaceSync(dir, place) {\n    const filepath = path.join(dir, place);\n    const content = readFile.sync(filepath);\n    return this.createCosmiconfigResultSync(filepath, content);\n  }\n\n  nextDirectoryToSearch(currentDir, currentResult) {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n\n    const nextDir = nextDirUp(currentDir);\n\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n\n    return nextDir;\n  }\n\n  loadPackageProp(filepath, content) {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(parsedContent, this.config.packageProp);\n    return packagePropValue || null;\n  }\n\n  getLoaderEntryForFile(filepath) {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return {\n        sync: loader,\n        async: loader\n      };\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n    return this.config.loaders[loaderKey] || {};\n  }\n\n  getSyncLoaderForFile(filepath) {\n    const entry = this.getLoaderEntryForFile(filepath);\n\n    if (!entry.sync) {\n      throw new Error(`No sync loader specified for ${getExtensionDescription(filepath)}`);\n    }\n\n    return entry.sync;\n  }\n\n  getAsyncLoaderForFile(filepath) {\n    const entry = this.getLoaderEntryForFile(filepath);\n    const loader = entry.async || entry.sync;\n\n    if (!loader) {\n      throw new Error(`No async loader specified for ${getExtensionDescription(filepath)}`);\n    }\n\n    return loader;\n  }\n\n  loadFileContent(mode, filepath, content) {\n    if (content === null) {\n      return null;\n    }\n\n    if (content.trim() === '') {\n      return undefined;\n    }\n\n    const loader = mode === MODE_SYNC ? this.getSyncLoaderForFile(filepath) : this.getAsyncLoaderForFile(filepath);\n    return loader(filepath, content);\n  }\n\n  loadedContentToCosmiconfigResult(filepath, loadedContent) {\n    if (loadedContent === null) {\n      return null;\n    }\n\n    if (loadedContent === undefined) {\n      return {\n        filepath,\n        config: undefined,\n        isEmpty: true\n      };\n    }\n\n    return {\n      config: loadedContent,\n      filepath\n    };\n  }\n\n  createCosmiconfigResult(filepath, content) {\n    return Promise.resolve().then(() => {\n      return this.loadFileContent('async', filepath, content);\n    }).then(loaderResult => {\n      return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n    });\n  }\n\n  createCosmiconfigResultSync(filepath, content) {\n    const loaderResult = this.loadFileContent('sync', filepath, content);\n    return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n  }\n\n  validateFilePath(filepath) {\n    if (!filepath) {\n      throw new Error('load and loadSync must pass a non-empty string');\n    }\n  }\n\n  load(filepath) {\n    return Promise.resolve().then(() => {\n      this.validateFilePath(filepath);\n      const absoluteFilePath = path.resolve(process.cwd(), filepath);\n      return cacheWrapper(this.loadCache, absoluteFilePath, () => {\n        return readFile(absoluteFilePath, {\n          throwNotFound: true\n        }).then(content => {\n          return this.createCosmiconfigResult(absoluteFilePath, content);\n        }).then(this.config.transform);\n      });\n    });\n  }\n\n  loadSync(filepath) {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n    return cacheWrapper(this.loadSyncCache, absoluteFilePath, () => {\n      const content = readFile.sync(absoluteFilePath, {\n        throwNotFound: true\n      });\n      const result = this.createCosmiconfigResultSync(absoluteFilePath, content);\n      return this.config.transform(result);\n    });\n  }\n\n}\n\nmodule.exports = function createExplorer(options) {\n  const explorer = new Explorer(options);\n  return {\n    search: explorer.search.bind(explorer),\n    searchSync: explorer.searchSync.bind(explorer),\n    load: explorer.load.bind(explorer),\n    loadSync: explorer.loadSync.bind(explorer),\n    clearLoadCache: explorer.clearLoadCache.bind(explorer),\n    clearSearchCache: explorer.clearSearchCache.bind(explorer),\n    clearCaches: explorer.clearCaches.bind(explorer)\n  };\n};\n\nfunction nextDirUp(dir) {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath) {\n  const ext = path.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/cosmiconfig/dist/createExplorer.js"],"names":["path","require","loaders","readFile","cacheWrapper","getDirectory","getPropertyByPath","MODE_SYNC","Explorer","constructor","options","loadCache","cache","Map","loadSyncCache","searchCache","searchSyncCache","config","validateConfig","clearLoadCache","clear","clearSearchCache","clearCaches","searchPlaces","forEach","place","loaderKey","extname","loader","Error","getExtensionDescription","search","searchFrom","process","cwd","then","dir","searchFromDirectory","absoluteDir","resolve","run","searchDirectory","result","nextDir","nextDirectoryToSearch","transform","searchSync","sync","searchFromDirectorySync","searchDirectorySync","reduce","prevResultPromise","prevResult","shouldSearchStopWithResult","loadSearchPlace","Promise","loadSearchPlaceSync","isEmpty","ignoreEmptySearchPlaces","filepath","join","content","createCosmiconfigResult","createCosmiconfigResultSync","currentDir","currentResult","nextDirUp","stopDir","loadPackageProp","parsedContent","loadJson","packagePropValue","packageProp","getLoaderEntryForFile","basename","bind","async","getSyncLoaderForFile","entry","getAsyncLoaderForFile","loadFileContent","mode","trim","undefined","loadedContentToCosmiconfigResult","loadedContent","loaderResult","validateFilePath","load","absoluteFilePath","throwNotFound","loadSync","module","exports","createExplorer","explorer","dirname","ext"],"mappings":"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","sourcesContent":["//      \n'use strict';\n\nconst path = require('path');\nconst loaders = require('./loaders');\nconst readFile = require('./readFile');\nconst cacheWrapper = require('./cacheWrapper');\nconst getDirectory = require('./getDirectory');\nconst getPropertyByPath = require('./getPropertyByPath');\n\nconst MODE_SYNC = 'sync';\n\n// An object value represents a config object.\n// null represents that the loader did not find anything relevant.\n// undefined represents that the loader found something relevant\n// but it was empty.\n                                              \n\nclass Explorer {\n                                                      \n                                                 \n                                                        \n                                                   \n                          \n\n  constructor(options                 ) {\n    this.loadCache = options.cache ? new Map() : null;\n    this.loadSyncCache = options.cache ? new Map() : null;\n    this.searchCache = options.cache ? new Map() : null;\n    this.searchSyncCache = options.cache ? new Map() : null;\n    this.config = options;\n    this.validateConfig();\n  }\n\n  clearLoadCache() {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n    if (this.loadSyncCache) {\n      this.loadSyncCache.clear();\n    }\n  }\n\n  clearSearchCache() {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n    if (this.searchSyncCache) {\n      this.searchSyncCache.clear();\n    }\n  }\n\n  clearCaches() {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  validateConfig() {\n    const config = this.config;\n\n    config.searchPlaces.forEach(place => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n      if (!loader) {\n        throw new Error(\n          `No loader specified for ${getExtensionDescription(\n            place\n          )}, so searchPlaces item \"${place}\" is invalid`\n        );\n      }\n    });\n  }\n\n  search(searchFrom         )                             {\n    searchFrom = searchFrom || process.cwd();\n    return getDirectory(searchFrom).then(dir => {\n      return this.searchFromDirectory(dir);\n    });\n  }\n\n  searchFromDirectory(dir        )                             {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n    const run = () => {\n      return this.searchDirectory(absoluteDir).then(result => {\n        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n        if (nextDir) {\n          return this.searchFromDirectory(nextDir);\n        }\n        return this.config.transform(result);\n      });\n    };\n\n    if (this.searchCache) {\n      return cacheWrapper(this.searchCache, absoluteDir, run);\n    }\n    return run();\n  }\n\n  searchSync(searchFrom         )                    {\n    searchFrom = searchFrom || process.cwd();\n    const dir = getDirectory.sync(searchFrom);\n    return this.searchFromDirectorySync(dir);\n  }\n\n  searchFromDirectorySync(dir        )                    {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n    const run = () => {\n      const result = this.searchDirectorySync(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n      if (nextDir) {\n        return this.searchFromDirectorySync(nextDir);\n      }\n      return this.config.transform(result);\n    };\n\n    if (this.searchSyncCache) {\n      return cacheWrapper(this.searchSyncCache, absoluteDir, run);\n    }\n    return run();\n  }\n\n  searchDirectory(dir        )                             {\n    return this.config.searchPlaces.reduce((prevResultPromise, place) => {\n      return prevResultPromise.then(prevResult => {\n        if (this.shouldSearchStopWithResult(prevResult)) {\n          return prevResult;\n        }\n        return this.loadSearchPlace(dir, place);\n      });\n    }, Promise.resolve(null));\n  }\n\n  searchDirectorySync(dir        )                    {\n    let result = null;\n    for (const place of this.config.searchPlaces) {\n      result = this.loadSearchPlaceSync(dir, place);\n      if (this.shouldSearchStopWithResult(result)) break;\n    }\n    return result;\n  }\n\n  shouldSearchStopWithResult(result                   )          {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  loadSearchPlace(dir        , place        )                             {\n    const filepath = path.join(dir, place);\n    return readFile(filepath).then(content => {\n      return this.createCosmiconfigResult(filepath, content);\n    });\n  }\n\n  loadSearchPlaceSync(dir        , place        )                    {\n    const filepath = path.join(dir, place);\n    const content = readFile.sync(filepath);\n    return this.createCosmiconfigResultSync(filepath, content);\n  }\n\n  nextDirectoryToSearch(\n    currentDir        ,\n    currentResult                   \n  )          {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n    const nextDir = nextDirUp(currentDir);\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n    return nextDir;\n  }\n\n  loadPackageProp(filepath        , content        ) {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(\n      parsedContent,\n      this.config.packageProp\n    );\n    return packagePropValue || null;\n  }\n\n  getLoaderEntryForFile(filepath        )              {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return { sync: loader, async: loader };\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n    return this.config.loaders[loaderKey] || {};\n  }\n\n  getSyncLoaderForFile(filepath        )             {\n    const entry = this.getLoaderEntryForFile(filepath);\n    if (!entry.sync) {\n      throw new Error(\n        `No sync loader specified for ${getExtensionDescription(filepath)}`\n      );\n    }\n    return entry.sync;\n  }\n\n  getAsyncLoaderForFile(filepath        )              {\n    const entry = this.getLoaderEntryForFile(filepath);\n    const loader = entry.async || entry.sync;\n    if (!loader) {\n      throw new Error(\n        `No async loader specified for ${getExtensionDescription(filepath)}`\n      );\n    }\n    return loader;\n  }\n\n  loadFileContent(\n    mode                  ,\n    filepath        ,\n    content               \n  )                                                 {\n    if (content === null) {\n      return null;\n    }\n    if (content.trim() === '') {\n      return undefined;\n    }\n    const loader =\n      mode === MODE_SYNC\n        ? this.getSyncLoaderForFile(filepath)\n        : this.getAsyncLoaderForFile(filepath);\n    return loader(filepath, content);\n  }\n\n  loadedContentToCosmiconfigResult(\n    filepath        ,\n    loadedContent                   \n  )                    {\n    if (loadedContent === null) {\n      return null;\n    }\n    if (loadedContent === undefined) {\n      return { filepath, config: undefined, isEmpty: true };\n    }\n    return { config: loadedContent, filepath };\n  }\n\n  createCosmiconfigResult(\n    filepath        ,\n    content               \n  )                             {\n    return Promise.resolve()\n      .then(() => {\n        return this.loadFileContent('async', filepath, content);\n      })\n      .then(loaderResult => {\n        return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n      });\n  }\n\n  createCosmiconfigResultSync(\n    filepath        ,\n    content               \n  )                    {\n    const loaderResult = this.loadFileContent('sync', filepath, content);\n    return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n  }\n\n  validateFilePath(filepath         ) {\n    if (!filepath) {\n      throw new Error('load and loadSync must pass a non-empty string');\n    }\n  }\n\n  load(filepath        )                             {\n    return Promise.resolve().then(() => {\n      this.validateFilePath(filepath);\n      const absoluteFilePath = path.resolve(process.cwd(), filepath);\n      return cacheWrapper(this.loadCache, absoluteFilePath, () => {\n        return readFile(absoluteFilePath, { throwNotFound: true })\n          .then(content => {\n            return this.createCosmiconfigResult(absoluteFilePath, content);\n          })\n          .then(this.config.transform);\n      });\n    });\n  }\n\n  loadSync(filepath        )                    {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n    return cacheWrapper(this.loadSyncCache, absoluteFilePath, () => {\n      const content = readFile.sync(absoluteFilePath, { throwNotFound: true });\n      const result = this.createCosmiconfigResultSync(\n        absoluteFilePath,\n        content\n      );\n      return this.config.transform(result);\n    });\n  }\n}\n\nmodule.exports = function createExplorer(options                 ) {\n  const explorer = new Explorer(options);\n\n  return {\n    search: explorer.search.bind(explorer),\n    searchSync: explorer.searchSync.bind(explorer),\n    load: explorer.load.bind(explorer),\n    loadSync: explorer.loadSync.bind(explorer),\n    clearLoadCache: explorer.clearLoadCache.bind(explorer),\n    clearSearchCache: explorer.clearSearchCache.bind(explorer),\n    clearCaches: explorer.clearCaches.bind(explorer),\n  };\n};\n\nfunction nextDirUp(dir        )         {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath        )         {\n  const ext = path.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}\n"]},"metadata":{},"sourceType":"script"}