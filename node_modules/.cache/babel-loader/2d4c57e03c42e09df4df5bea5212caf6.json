{"ast":null,"code":"import postcss from 'postcss';\nimport valuesParser from 'postcss-values-parser';\nvar index = postcss.plugin('postcss-color-functional-notation', opts => {\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n  return root => {\n    root.walkDecls(decl => {\n      const originalValue = decl.value;\n\n      if (colorAnyRegExp.test(originalValue)) {\n        const valueAST = valuesParser(originalValue).parse();\n        valueAST.walkType('func', node => {\n          if (colorRegExp.test(node.value)) {\n            const children = node.nodes.slice(1, -1);\n            const isFunctionalHSL = matchFunctionalHSL(node, children);\n            const isFunctionalRGB1 = matchFunctionalRGB1(node, children);\n            const isFunctionalRGB2 = matchFunctionalRGB2(node, children);\n\n            if (isFunctionalHSL || isFunctionalRGB1 || isFunctionalRGB2) {\n              const slashNode = children[3];\n              const alphaNode = children[4];\n\n              if (alphaNode) {\n                if (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n                  alphaNode.unit = '';\n                  alphaNode.value = String(alphaNode.value / 100);\n                }\n\n                if (isHslRgb(node)) {\n                  node.value += 'a';\n                }\n              } else if (isHslaRgba(node)) {\n                node.value = node.value.slice(0, -1);\n              }\n\n              if (slashNode && isSlash(slashNode)) {\n                slashNode.replaceWith(newComma());\n              }\n\n              if (isFunctionalRGB2) {\n                children[0].unit = children[1].unit = children[2].unit = '';\n                children[0].value = String(Math.floor(children[0].value * 255 / 100));\n                children[1].value = String(Math.floor(children[1].value * 255 / 100));\n                children[2].value = String(Math.floor(children[2].value * 255 / 100));\n              }\n\n              node.nodes.splice(3, 0, [newComma()]);\n              node.nodes.splice(2, 0, [newComma()]);\n            }\n          }\n        });\n        const modifiedValue = String(valueAST);\n\n        if (modifiedValue !== originalValue) {\n          if (preserve) {\n            decl.cloneBefore({\n              value: modifiedValue\n            });\n          } else {\n            decl.value = modifiedValue;\n          }\n        }\n      }\n    });\n  };\n});\nconst alphaUnitMatch = /^%?$/i;\nconst calcFuncMatch = /^calc$/i;\nconst colorAnyRegExp = /(^|[^\\w-])(hsla?|rgba?)\\(/i;\nconst colorRegExp = /^(hsla?|rgba?)$/i;\nconst hslishRegExp = /^hsla?$/i;\nconst hslRgbFuncMatch = /^(hsl|rgb)$/i;\nconst hslaRgbaFuncMatch = /^(hsla|rgba)$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\nconst rgbishRegExp = /^rgba?$/i;\n\nconst isAlphaValue = node => isCalc(node) || node.type === 'number' && alphaUnitMatch.test(node.unit);\n\nconst isCalc = node => node.type === 'func' && calcFuncMatch.test(node.value);\n\nconst isHue = node => isCalc(node) || node.type === 'number' && hueUnitMatch.test(node.unit);\n\nconst isNumber = node => isCalc(node) || node.type === 'number' && node.unit === '';\n\nconst isPercentage = node => isCalc(node) || node.type === 'number' && (node.unit === '%' || node.unit === '' && node.value === '0');\n\nconst isHslish = node => node.type === 'func' && hslishRegExp.test(node.value);\n\nconst isHslRgb = node => node.type === 'func' && hslRgbFuncMatch.test(node.value);\n\nconst isHslaRgba = node => node.type === 'func' && hslaRgbaFuncMatch.test(node.value);\n\nconst isRgbish = node => node.type === 'func' && rgbishRegExp.test(node.value);\n\nconst isSlash = node => node.type === 'operator' && node.value === '/';\n\nconst functionalHSLMatch = [isHue, isPercentage, isPercentage, isSlash, isAlphaValue];\nconst functionalRGB1Match = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];\nconst functionalRGB2Match = [isPercentage, isPercentage, isPercentage, isSlash, isAlphaValue];\n\nconst matchFunctionalHSL = (node, children) => isHslish(node) && children.every((child, index) => typeof functionalHSLMatch[index] === 'function' && functionalHSLMatch[index](child));\n\nconst matchFunctionalRGB1 = (node, children) => isRgbish(node) && children.every((child, index) => typeof functionalRGB1Match[index] === 'function' && functionalRGB1Match[index](child));\n\nconst matchFunctionalRGB2 = (node, children) => isRgbish(node) && children.every((child, index) => typeof functionalRGB2Match[index] === 'function' && functionalRGB2Match[index](child));\n\nconst newComma = () => valuesParser.comma({\n  value: ','\n});\n\nexport default index;","map":{"version":3,"sources":["index.js"],"names":["opts","preserve","Object","Boolean","root","decl","originalValue","colorAnyRegExp","valueAST","valuesParser","node","colorRegExp","children","isFunctionalHSL","matchFunctionalHSL","isFunctionalRGB1","matchFunctionalRGB1","isFunctionalRGB2","matchFunctionalRGB2","slashNode","alphaNode","isPercentage","isCalc","String","isHslRgb","isHslaRgba","isSlash","newComma","Math","modifiedValue","value","alphaUnitMatch","calcFuncMatch","hslishRegExp","hslRgbFuncMatch","hslaRgbaFuncMatch","hueUnitMatch","rgbishRegExp","isAlphaValue","isHue","isNumber","isHslish","isRgbish","functionalHSLMatch","functionalRGB1Match","functionalRGB2Match"],"mappings":"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","sourcesContent":["import postcss from 'postcss';\nimport valuesParser from 'postcss-values-parser';\n\nexport default postcss.plugin('postcss-color-functional-notation', opts => {\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n\n\treturn root => {\n\t\troot.walkDecls(decl => {\n\t\t\tconst { value: originalValue } = decl;\n\n\t\t\tif (colorAnyRegExp.test(originalValue)) {\n\t\t\t\tconst valueAST = valuesParser(originalValue).parse();\n\n\t\t\t\tvalueAST.walkType('func', node => {\n\t\t\t\t\tif (colorRegExp.test(node.value)) {\n\t\t\t\t\t\tconst children = node.nodes.slice(1, -1);\n\t\t\t\t\t\tconst isFunctionalHSL = matchFunctionalHSL(node, children);\n\t\t\t\t\t\tconst isFunctionalRGB1 = matchFunctionalRGB1(node, children);\n\t\t\t\t\t\tconst isFunctionalRGB2 = matchFunctionalRGB2(node, children);\n\n\t\t\t\t\t\tif (isFunctionalHSL || isFunctionalRGB1 || isFunctionalRGB2) {\n\t\t\t\t\t\t\tconst slashNode = children[3];\n\t\t\t\t\t\t\tconst alphaNode = children[4];\n\n\t\t\t\t\t\t\tif (alphaNode) {\n\t\t\t\t\t\t\t\tif (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n\t\t\t\t\t\t\t\t\talphaNode.unit = '';\n\t\t\t\t\t\t\t\t\talphaNode.value = String(alphaNode.value / 100);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (isHslRgb(node)) {\n\t\t\t\t\t\t\t\t\tnode.value += 'a';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (isHslaRgba(node)) {\n\t\t\t\t\t\t\t\tnode.value = node.value.slice(0, -1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (slashNode && isSlash(slashNode)) {\n\t\t\t\t\t\t\t\tslashNode.replaceWith( newComma() );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isFunctionalRGB2) {\n\t\t\t\t\t\t\t\tchildren[0].unit = children[1].unit = children[2].unit = '';\n\n\t\t\t\t\t\t\t\tchildren[0].value = String(Math.floor(children[0].value * 255 / 100));\n\t\t\t\t\t\t\t\tchildren[1].value = String(Math.floor(children[1].value * 255 / 100));\n\t\t\t\t\t\t\t\tchildren[2].value = String(Math.floor(children[2].value * 255 / 100));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnode.nodes.splice(3, 0, [ newComma() ]);\n\t\t\t\t\t\t\tnode.nodes.splice(2, 0, [ newComma() ]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst modifiedValue = String(valueAST);\n\n\t\t\t\tif (modifiedValue !== originalValue) {\n\t\t\t\t\tif (preserve) {\n\t\t\t\t\t\tdecl.cloneBefore({ value: modifiedValue });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdecl.value = modifiedValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\nconst alphaUnitMatch = /^%?$/i;\nconst calcFuncMatch = /^calc$/i;\nconst colorAnyRegExp = /(^|[^\\w-])(hsla?|rgba?)\\(/i;\nconst colorRegExp = /^(hsla?|rgba?)$/i;\nconst hslishRegExp = /^hsla?$/i;\nconst hslRgbFuncMatch = /^(hsl|rgb)$/i;\nconst hslaRgbaFuncMatch = /^(hsla|rgba)$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\nconst rgbishRegExp = /^rgba?$/i;\nconst isAlphaValue = node => isCalc(node) || node.type === 'number' && alphaUnitMatch.test(node.unit);\nconst isCalc = node => node.type === 'func' && calcFuncMatch.test(node.value);\nconst isHue = node => isCalc(node) || node.type === 'number' && hueUnitMatch.test(node.unit);\nconst isNumber = node => isCalc(node) || node.type === 'number' && node.unit === '';\nconst isPercentage = node => isCalc(node) || node.type === 'number' && (node.unit === '%' || node.unit === '' && node.value === '0');\nconst isHslish = node => node.type === 'func' && hslishRegExp.test(node.value);\nconst isHslRgb = node => node.type === 'func' && hslRgbFuncMatch.test(node.value);\nconst isHslaRgba = node => node.type === 'func' && hslaRgbaFuncMatch.test(node.value);\nconst isRgbish = node => node.type === 'func' && rgbishRegExp.test(node.value);\nconst isSlash = node => node.type === 'operator' && node.value === '/';\nconst functionalHSLMatch = [isHue, isPercentage, isPercentage, isSlash, isAlphaValue];\nconst functionalRGB1Match = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];\nconst functionalRGB2Match = [isPercentage, isPercentage, isPercentage, isSlash, isAlphaValue];\n\nconst matchFunctionalHSL = (node, children) => isHslish(node) && children.every(\n\t(child, index) => typeof functionalHSLMatch[index] === 'function' && functionalHSLMatch[index](child)\n);\nconst matchFunctionalRGB1 = (node, children) => isRgbish(node) && children.every(\n\t(child, index) => typeof functionalRGB1Match[index] === 'function' && functionalRGB1Match[index](child)\n);\nconst matchFunctionalRGB2 = (node, children) => isRgbish(node) && children.every(\n\t(child, index) => typeof functionalRGB2Match[index] === 'function' && functionalRGB2Match[index](child)\n);\n\nconst newComma = () => valuesParser.comma({ value: ',' })\n"]},"metadata":{},"sourceType":"module"}