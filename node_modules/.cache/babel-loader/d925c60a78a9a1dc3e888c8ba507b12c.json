{"ast":null,"code":"\"use strict\";\n\nconst request = require(\"request\");\n\nconst {\n  EventEmitter\n} = require(\"events\");\n\nconst ProgressEvent = require(\"./generated/ProgressEvent\");\n\nconst fs = require(\"fs\");\n\nconst {\n  URL\n} = require(\"whatwg-url\");\n\nconst parseDataURL = require(\"data-urls\");\n\nconst DOMException = require(\"domexception\");\n\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nconst wrapCookieJarForRequest = require(\"./helpers/wrap-cookie-jar-for-request\");\n\nconst {\n  fireAnEvent\n} = require(\"./helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction mergeHeaders(lhs, rhs) {\n  const rhsParts = rhs.split(\",\");\n  const lhsParts = lhs.split(\",\");\n  return rhsParts.concat(lhsParts.filter(p => rhsParts.indexOf(p) < 0)).join(\",\");\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr[xhrSymbols.properties].error;\n  requestErrorSteps(xhr, \"error\", new DOMException(errMessage, \"NetworkError\"));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const properties = xhr[xhrSymbols.properties];\n  const flag = xhr[xhrSymbols.flag];\n  properties.readyState = xhr.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, xhr.upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n      fireAnEvent(\"loadend\", xhr.upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const properties = xhr[xhrSymbols.properties];\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  properties.status = 0;\n  properties.statusText = \"\";\n} // return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\n\n\nfunction createClient(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  const properties = xhr[xhrSymbols.properties];\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n  const {\n    requestManager\n  } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = {\n      uri: urlObj\n    };\n    const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n    const client = new EventEmitter();\n    const readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n    response.request = {\n      uri: urlObj\n    };\n    const client = new EventEmitter();\n    let buffer;\n\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {// do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    strictSSL: flag.strictSSL,\n    proxy: flag.proxy,\n    forever: true\n  };\n\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  const {\n    body\n  } = flag;\n  const hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    const preflightRequestHeaders = [];\n\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      const lcHeader = header.toLowerCase();\n\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      strictSSL: flag.strictSSL,\n      proxy: flag.proxy,\n      forever: true\n    };\n    const preflightClient = request(preflightOptions);\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      } // don't send the real request if we aren't allowed to use the headers\n\n\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n\n      const realClient = doRequest();\n      realClient.on(\"response\", res => {\n        for (const header in resp.headers) {\n          if (preflightHeaders.has(header)) {\n            res.headers[header] = Object.prototype.hasOwnProperty.call(res.headers, header) ? mergeHeaders(res.headers[header], resp.headers[header]) : resp.headers[header];\n          }\n        }\n\n        client.emit(\"response\", res);\n      });\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", () => {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", err => client.emit(\"error\", err));\n\n      client.abort = () => {\n        realClient.abort();\n      };\n    });\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-environment-jsdom-fourteen/node_modules/jsdom/lib/jsdom/living/xhr-utils.js"],"names":["request","require","EventEmitter","ProgressEvent","fs","URL","parseDataURL","DOMException","xhrSymbols","wrapCookieJarForRequest","fireAnEvent","headerListSeparatorRegexp","simpleMethods","Set","simpleHeaders","preflightHeaders","getRequestHeader","requestHeaders","header","lcHeader","toLowerCase","keys","Object","n","length","key","updateRequestHeader","newValue","mergeHeaders","lhs","rhs","rhsParts","split","lhsParts","concat","filter","p","indexOf","join","dispatchError","xhr","errMessage","properties","error","requestErrorSteps","_ownerDocument","Error","type","_defaultView","_virtualConsole","emit","validCORSHeaders","response","flag","origin","acaoStr","headers","acao","trim","acacStr","acac","withCredentials","validCORSPreflightHeaders","acahStr","acah","forbiddenHeaders","has","event","exception","readyState","DONE","send","setResponseToNetworkError","synchronous","uploadComplete","uploadListener","upload","loaded","total","lengthComputable","responseCache","responseTextCache","responseXMLCache","responseHeaders","status","statusText","createClient","urlObj","uri","href","ucMethod","method","toUpperCase","requestManager","protocol","statusCode","rawHeaders","filePath","pathname","replace","client","readableStream","createReadStream","encoding","on","chunk","err","abort","destroy","req","abortError","add","rmReq","remove","bind","process","nextTick","buffer","parsed","contentType","mimeType","toString","body","Referer","referrer","userAgent","Accept","crossOrigin","Origin","options","gzip","maxRedirects","followAllRedirects","strictSSL","proxy","forever","auth","user","pass","sendImmediately","cookieJar","jar","hasBody","undefined","formData","doRequest","form","entry","append","name","value","e","nonSimpleHeaders","preflightRequestHeaders","preflight","preflightOptions","followRedirect","pool","preflightClient","resp","realClient","res","prototype","hasOwnProperty","call","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst request = require(\"request\");\nconst { EventEmitter } = require(\"events\");\nconst ProgressEvent = require(\"./generated/ProgressEvent\");\nconst fs = require(\"fs\");\nconst { URL } = require(\"whatwg-url\");\nconst parseDataURL = require(\"data-urls\");\n\nconst DOMException = require(\"domexception\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\nconst wrapCookieJarForRequest = require(\"./helpers/wrap-cookie-jar-for-request\");\nconst { fireAnEvent } = require(\"./helpers/events\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\n  \"access-control-expose-headers\",\n  \"access-control-allow-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-allow-origin\"\n]);\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction mergeHeaders(lhs, rhs) {\n  const rhsParts = rhs.split(\",\");\n  const lhsParts = lhs.split(\",\");\n  return rhsParts.concat(lhsParts.filter(p => rhsParts.indexOf(p) < 0)).join(\",\");\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr[xhrSymbols.properties].error;\n  requestErrorSteps(xhr, \"error\", new DOMException(errMessage, \"NetworkError\"));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const properties = xhr[xhrSymbols.properties];\n  const flag = xhr[xhrSymbols.flag];\n\n  properties.readyState = xhr.DONE;\n  properties.send = false;\n\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, xhr.upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n      fireAnEvent(\"loadend\", xhr.upload, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, { loaded: 0, total: 0, lengthComputable: false });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const properties = xhr[xhrSymbols.properties];\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  properties.status = 0;\n  properties.statusText = \"\";\n}\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nfunction createClient(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  const properties = xhr[xhrSymbols.properties];\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const { requestManager } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = { uri: urlObj };\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    response.request = { uri: urlObj };\n\n    const client = new EventEmitter();\n\n    let buffer;\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = { \"content-type\": contentType };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    strictSSL: flag.strictSSL,\n    proxy: flag.proxy,\n    forever: true\n  };\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  const { body } = flag;\n  const hasBody = body !== undefined &&\n                  body !== null &&\n                  body !== \"\" &&\n                  !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = [];\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      const lcHeader = header.toLowerCase();\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n\n    flag.preflight = true;\n\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      strictSSL: flag.strictSSL,\n      proxy: flag.proxy,\n      forever: true\n    };\n\n    const preflightClient = request(preflightOptions);\n\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      }\n      // don't send the real request if we aren't allowed to use the headers\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n      const realClient = doRequest();\n      realClient.on(\"response\", res => {\n        for (const header in resp.headers) {\n          if (preflightHeaders.has(header)) {\n            res.headers[header] = Object.prototype.hasOwnProperty.call(res.headers, header) ?\n                                  mergeHeaders(res.headers[header], resp.headers[header]) :\n                                  resp.headers[header];\n          }\n        }\n        client.emit(\"response\", res);\n      });\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", () => {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", err => client.emit(\"error\", err));\n      client.abort = () => {\n        realClient.abort();\n      };\n    });\n\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;\n"]},"metadata":{},"sourceType":"script"}