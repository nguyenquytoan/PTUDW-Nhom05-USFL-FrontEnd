{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst EMPTY_OBJ = {};\nconst EMPTY_MAP = new Map();\n\nclass ModuleMap {\n  static mapToArrayRecursive(map) {\n    let arr = Array.from(map);\n\n    if (arr[0] && arr[0][1] instanceof Map) {\n      arr = arr.map(el => [el[0], this.mapToArrayRecursive(el[1])]);\n    }\n\n    return arr;\n  }\n\n  static mapFromArrayRecursive(arr) {\n    if (arr[0] && Array.isArray(arr[1])) {\n      arr = arr.map(el => [el[0], this.mapFromArrayRecursive(el[1])]);\n    }\n\n    return new Map(arr);\n  }\n\n  constructor(raw) {\n    _defineProperty(this, '_raw', void 0);\n\n    _defineProperty(this, 'json', void 0);\n\n    this._raw = raw;\n  }\n\n  getModule(name, platform, supportsNativePlatform, type) {\n    if (type == null) {\n      type = _constants.default.MODULE;\n    }\n\n    const module = this._getModuleMetadata(name, platform, !!supportsNativePlatform);\n\n    if (module && module[_constants.default.TYPE] === type) {\n      const modulePath = module[_constants.default.PATH];\n      return modulePath && fastPath.resolve(this._raw.rootDir, modulePath);\n    }\n\n    return null;\n  }\n\n  getPackage(name, platform, _supportsNativePlatform) {\n    return this.getModule(name, platform, null, _constants.default.PACKAGE);\n  }\n\n  getMockModule(name) {\n    const mockPath = this._raw.mocks.get(name) || this._raw.mocks.get(name + '/index');\n\n    return mockPath && fastPath.resolve(this._raw.rootDir, mockPath);\n  }\n\n  getRawModuleMap() {\n    return {\n      duplicates: this._raw.duplicates,\n      map: this._raw.map,\n      mocks: this._raw.mocks,\n      rootDir: this._raw.rootDir\n    };\n  }\n\n  toJSON() {\n    if (!this.json) {\n      this.json = {\n        duplicates: ModuleMap.mapToArrayRecursive(this._raw.duplicates),\n        map: Array.from(this._raw.map),\n        mocks: Array.from(this._raw.mocks),\n        rootDir: this._raw.rootDir\n      };\n    }\n\n    return this.json;\n  }\n\n  static fromJSON(serializableModuleMap) {\n    return new ModuleMap({\n      duplicates: ModuleMap.mapFromArrayRecursive(serializableModuleMap.duplicates),\n      map: new Map(serializableModuleMap.map),\n      mocks: new Map(serializableModuleMap.mocks),\n      rootDir: serializableModuleMap.rootDir\n    });\n  }\n  /**\n   * When looking up a module's data, we walk through each eligible platform for\n   * the query. For each platform, we want to check if there are known\n   * duplicates for that name+platform pair. The duplication logic normally\n   * removes elements from the `map` object, but we want to check upfront to be\n   * extra sure. If metadata exists both in the `duplicates` object and the\n   * `map`, this would be a bug.\n   */\n\n\n  _getModuleMetadata(name, platform, supportsNativePlatform) {\n    const map = this._raw.map.get(name) || EMPTY_OBJ;\n    const dupMap = this._raw.duplicates.get(name) || EMPTY_MAP;\n\n    if (platform != null) {\n      this._assertNoDuplicates(name, platform, supportsNativePlatform, dupMap.get(platform));\n\n      if (map[platform] != null) {\n        return map[platform];\n      }\n    }\n\n    if (supportsNativePlatform) {\n      this._assertNoDuplicates(name, _constants.default.NATIVE_PLATFORM, supportsNativePlatform, dupMap.get(_constants.default.NATIVE_PLATFORM));\n\n      if (map[_constants.default.NATIVE_PLATFORM]) {\n        return map[_constants.default.NATIVE_PLATFORM];\n      }\n    }\n\n    this._assertNoDuplicates(name, _constants.default.GENERIC_PLATFORM, supportsNativePlatform, dupMap.get(_constants.default.GENERIC_PLATFORM));\n\n    if (map[_constants.default.GENERIC_PLATFORM]) {\n      return map[_constants.default.GENERIC_PLATFORM];\n    }\n\n    return null;\n  }\n\n  _assertNoDuplicates(name, platform, supportsNativePlatform, relativePathSet) {\n    if (relativePathSet == null) {\n      return;\n    } // Force flow refinement\n\n\n    const previousSet = relativePathSet;\n    const duplicates = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = previousSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              relativePath = _step$value[0],\n              type = _step$value[1];\n\n        const duplicatePath = fastPath.resolve(this._raw.rootDir, relativePath);\n        duplicates.set(duplicatePath, type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    throw new DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicates);\n  }\n\n  static create(rootDir) {\n    return new ModuleMap({\n      duplicates: new Map(),\n      map: new Map(),\n      mocks: new Map(),\n      rootDir\n    });\n  }\n\n}\n\nexports.default = ModuleMap;\n\n_defineProperty(ModuleMap, 'DuplicateHasteCandidatesError', void 0);\n\nclass DuplicateHasteCandidatesError extends Error {\n  constructor(name, platform, supportsNativePlatform, duplicatesSet) {\n    const platformMessage = getPlatformMessage(platform);\n    super(`The name \\`${name}\\` was looked up in the Haste module map. It ` + `cannot be resolved, because there exists several different ` + `files, or packages, that provide a module for ` + `that particular name and platform. ${platformMessage} You must ` + `delete or blacklist files until there remains only one of these:\\n\\n` + Array.from(duplicatesSet).map(([dupFilePath, dupFileType]) => `  * \\`${dupFilePath}\\` (${getTypeMessage(dupFileType)})\\n`).sort().join(''));\n\n    _defineProperty(this, 'hasteName', void 0);\n\n    _defineProperty(this, 'platform', void 0);\n\n    _defineProperty(this, 'supportsNativePlatform', void 0);\n\n    _defineProperty(this, 'duplicatesSet', void 0);\n\n    this.hasteName = name;\n    this.platform = platform;\n    this.supportsNativePlatform = supportsNativePlatform;\n    this.duplicatesSet = duplicatesSet;\n  }\n\n}\n\nfunction getPlatformMessage(platform) {\n  if (platform === _constants.default.GENERIC_PLATFORM) {\n    return 'The platform is generic (no extension).';\n  }\n\n  return `The platform extension is \\`${platform}\\`.`;\n}\n\nfunction getTypeMessage(type) {\n  switch (type) {\n    case _constants.default.MODULE:\n      return 'module';\n\n    case _constants.default.PACKAGE:\n      return 'package';\n  }\n\n  return 'unknown';\n}\n\nModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-haste-map/build/ModuleMap.js"],"names":["Object","defineProperty","exports","value","default","fastPath","_interopRequireWildcard","require","_constants","_interopRequireDefault","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","_defineProperty","enumerable","configurable","writable","EMPTY_OBJ","EMPTY_MAP","Map","ModuleMap","mapToArrayRecursive","map","from","el","mapFromArrayRecursive","constructor","raw","_raw","getModule","name","platform","supportsNativePlatform","type","MODULE","module","_getModuleMetadata","TYPE","modulePath","PATH","resolve","rootDir","getPackage","_supportsNativePlatform","PACKAGE","getMockModule","mockPath","mocks","getRawModuleMap","duplicates","toJSON","json","fromJSON","serializableModuleMap","dupMap","_assertNoDuplicates","NATIVE_PLATFORM","GENERIC_PLATFORM","relativePathSet","previousSet","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_step$value","relativePath","duplicatePath","return","DuplicateHasteCandidatesError","create","Error","duplicatesSet","platformMessage","getPlatformMessage","dupFilePath","dupFileType","getTypeMessage","sort","join","hasteName"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,QAAQ,GAAGC,uBAAuB,CAACC,OAAO,CAAC,iBAAD,CAAR,CAAtC;;AAEA,IAAIC,UAAU,GAAGC,sBAAsB,CAACF,OAAO,CAAC,aAAD,CAAR,CAAvC;;AAEA,SAASE,sBAAT,CAAgCC,GAAhC,EAAqC;AACnC,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAACN,IAAAA,OAAO,EAAEM;AAAV,GAArC;AACD;;AAED,SAASJ,uBAAT,CAAiCI,GAAjC,EAAsC;AACpC,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AACzB,WAAOD,GAAP;AACD,GAFD,MAEO;AACL,QAAIE,MAAM,GAAG,EAAb;;AACA,QAAIF,GAAG,IAAI,IAAX,EAAiB;AACf,WAAK,IAAIG,GAAT,IAAgBH,GAAhB,EAAqB;AACnB,YAAIV,MAAM,CAACc,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,GAArC,EAA0CG,GAA1C,CAAJ,EAAoD;AAClD,cAAII,IAAI,GACNjB,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACkB,wBAAhC,GACIlB,MAAM,CAACkB,wBAAP,CAAgCR,GAAhC,EAAqCG,GAArC,CADJ,GAEI,EAHN;;AAIA,cAAII,IAAI,CAACE,GAAL,IAAYF,IAAI,CAACG,GAArB,EAA0B;AACxBpB,YAAAA,MAAM,CAACC,cAAP,CAAsBW,MAAtB,EAA8BC,GAA9B,EAAmCI,IAAnC;AACD,WAFD,MAEO;AACLL,YAAAA,MAAM,CAACC,GAAD,CAAN,GAAcH,GAAG,CAACG,GAAD,CAAjB;AACD;AACF;AACF;AACF;;AACDD,IAAAA,MAAM,CAACR,OAAP,GAAiBM,GAAjB;AACA,WAAOE,MAAP;AACD;AACF;;AAED,SAASS,cAAT,CAAwBC,GAAxB,EAA6BC,CAA7B,EAAgC;AAC9B,SACEC,eAAe,CAACF,GAAD,CAAf,IAAwBG,qBAAqB,CAACH,GAAD,EAAMC,CAAN,CAA7C,IAAyDG,gBAAgB,EAD3E;AAGD;;AAED,SAASA,gBAAT,GAA4B;AAC1B,QAAM,IAAIC,SAAJ,CAAc,sDAAd,CAAN;AACD;;AAED,SAASF,qBAAT,CAA+BH,GAA/B,EAAoCC,CAApC,EAAuC;AACrC,MAAIK,IAAI,GAAG,EAAX;AACA,MAAIC,EAAE,GAAG,IAAT;AACA,MAAIC,EAAE,GAAG,KAAT;AACA,MAAIC,EAAE,GAAGC,SAAT;;AACA,MAAI;AACF,SACE,IAAIC,EAAE,GAAGX,GAAG,CAACY,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiCC,EADnC,EAEE,EAAEP,EAAE,GAAG,CAACO,EAAE,GAAGH,EAAE,CAACI,IAAH,EAAN,EAAiBC,IAAxB,CAFF,EAGET,EAAE,GAAG,IAHP,EAIE;AACAD,MAAAA,IAAI,CAACW,IAAL,CAAUH,EAAE,CAACjC,KAAb;;AACA,UAAIoB,CAAC,IAAIK,IAAI,CAACY,MAAL,KAAgBjB,CAAzB,EAA4B;AAC7B;AACF,GATD,CASE,OAAOkB,GAAP,EAAY;AACZX,IAAAA,EAAE,GAAG,IAAL;AACAC,IAAAA,EAAE,GAAGU,GAAL;AACD,GAZD,SAYU;AACR,QAAI;AACF,UAAI,CAACZ,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiCA,EAAE,CAAC,QAAD,CAAF;AAClC,KAFD,SAEU;AACR,UAAIH,EAAJ,EAAQ,MAAMC,EAAN;AACT;AACF;;AACD,SAAOH,IAAP;AACD;;AAED,SAASJ,eAAT,CAAyBF,GAAzB,EAA8B;AAC5B,MAAIoB,KAAK,CAACC,OAAN,CAAcrB,GAAd,CAAJ,EAAwB,OAAOA,GAAP;AACzB;;AAED,SAASsB,eAAT,CAAyBlC,GAAzB,EAA8BG,GAA9B,EAAmCV,KAAnC,EAA0C;AACxC,MAAIU,GAAG,IAAIH,GAAX,EAAgB;AACdV,IAAAA,MAAM,CAACC,cAAP,CAAsBS,GAAtB,EAA2BG,GAA3B,EAAgC;AAC9BV,MAAAA,KAAK,EAAEA,KADuB;AAE9B0C,MAAAA,UAAU,EAAE,IAFkB;AAG9BC,MAAAA,YAAY,EAAE,IAHgB;AAI9BC,MAAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACLrC,IAAAA,GAAG,CAACG,GAAD,CAAH,GAAWV,KAAX;AACD;;AACD,SAAOO,GAAP;AACD;;AAED,MAAMsC,SAAS,GAAG,EAAlB;AACA,MAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;;AAEA,MAAMC,SAAN,CAAgB;AACd,SAAOC,mBAAP,CAA2BC,GAA3B,EAAgC;AAC9B,QAAI/B,GAAG,GAAGoB,KAAK,CAACY,IAAN,CAAWD,GAAX,CAAV;;AAEA,QAAI/B,GAAG,CAAC,CAAD,CAAH,IAAUA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,aAAqB4B,GAAnC,EAAwC;AACtC5B,MAAAA,GAAG,GAAGA,GAAG,CAAC+B,GAAJ,CAAQE,EAAE,IAAI,CAACA,EAAE,CAAC,CAAD,CAAH,EAAQ,KAAKH,mBAAL,CAAyBG,EAAE,CAAC,CAAD,CAA3B,CAAR,CAAd,CAAN;AACD;;AAED,WAAOjC,GAAP;AACD;;AAED,SAAOkC,qBAAP,CAA6BlC,GAA7B,EAAkC;AAChC,QAAIA,GAAG,CAAC,CAAD,CAAH,IAAUoB,KAAK,CAACC,OAAN,CAAcrB,GAAG,CAAC,CAAD,CAAjB,CAAd,EAAqC;AACnCA,MAAAA,GAAG,GAAGA,GAAG,CAAC+B,GAAJ,CAAQE,EAAE,IAAI,CAACA,EAAE,CAAC,CAAD,CAAH,EAAQ,KAAKC,qBAAL,CAA2BD,EAAE,CAAC,CAAD,CAA7B,CAAR,CAAd,CAAN;AACD;;AAED,WAAO,IAAIL,GAAJ,CAAQ5B,GAAR,CAAP;AACD;;AAEDmC,EAAAA,WAAW,CAACC,GAAD,EAAM;AACfd,IAAAA,eAAe,CAAC,IAAD,EAAO,MAAP,EAAe,KAAK,CAApB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,MAAP,EAAe,KAAK,CAApB,CAAf;;AAEA,SAAKe,IAAL,GAAYD,GAAZ;AACD;;AAEDE,EAAAA,SAAS,CAACC,IAAD,EAAOC,QAAP,EAAiBC,sBAAjB,EAAyCC,IAAzC,EAA+C;AACtD,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChBA,MAAAA,IAAI,GAAGxD,UAAU,CAACJ,OAAX,CAAmB6D,MAA1B;AACD;;AAED,UAAMC,MAAM,GAAG,KAAKC,kBAAL,CACbN,IADa,EAEbC,QAFa,EAGb,CAAC,CAACC,sBAHW,CAAf;;AAMA,QAAIG,MAAM,IAAIA,MAAM,CAAC1D,UAAU,CAACJ,OAAX,CAAmBgE,IAApB,CAAN,KAAoCJ,IAAlD,EAAwD;AACtD,YAAMK,UAAU,GAAGH,MAAM,CAAC1D,UAAU,CAACJ,OAAX,CAAmBkE,IAApB,CAAzB;AACA,aAAOD,UAAU,IAAIhE,QAAQ,CAACkE,OAAT,CAAiB,KAAKZ,IAAL,CAAUa,OAA3B,EAAoCH,UAApC,CAArB;AACD;;AAED,WAAO,IAAP;AACD;;AAEDI,EAAAA,UAAU,CAACZ,IAAD,EAAOC,QAAP,EAAiBY,uBAAjB,EAA0C;AAClD,WAAO,KAAKd,SAAL,CAAeC,IAAf,EAAqBC,QAArB,EAA+B,IAA/B,EAAqCtD,UAAU,CAACJ,OAAX,CAAmBuE,OAAxD,CAAP;AACD;;AAEDC,EAAAA,aAAa,CAACf,IAAD,EAAO;AAClB,UAAMgB,QAAQ,GACZ,KAAKlB,IAAL,CAAUmB,KAAV,CAAgB3D,GAAhB,CAAoB0C,IAApB,KAA6B,KAAKF,IAAL,CAAUmB,KAAV,CAAgB3D,GAAhB,CAAoB0C,IAAI,GAAG,QAA3B,CAD/B;;AAGA,WAAOgB,QAAQ,IAAIxE,QAAQ,CAACkE,OAAT,CAAiB,KAAKZ,IAAL,CAAUa,OAA3B,EAAoCK,QAApC,CAAnB;AACD;;AAEDE,EAAAA,eAAe,GAAG;AAChB,WAAO;AACLC,MAAAA,UAAU,EAAE,KAAKrB,IAAL,CAAUqB,UADjB;AAEL3B,MAAAA,GAAG,EAAE,KAAKM,IAAL,CAAUN,GAFV;AAGLyB,MAAAA,KAAK,EAAE,KAAKnB,IAAL,CAAUmB,KAHZ;AAILN,MAAAA,OAAO,EAAE,KAAKb,IAAL,CAAUa;AAJd,KAAP;AAMD;;AAEDS,EAAAA,MAAM,GAAG;AACP,QAAI,CAAC,KAAKC,IAAV,EAAgB;AACd,WAAKA,IAAL,GAAY;AACVF,QAAAA,UAAU,EAAE7B,SAAS,CAACC,mBAAV,CAA8B,KAAKO,IAAL,CAAUqB,UAAxC,CADF;AAEV3B,QAAAA,GAAG,EAAEX,KAAK,CAACY,IAAN,CAAW,KAAKK,IAAL,CAAUN,GAArB,CAFK;AAGVyB,QAAAA,KAAK,EAAEpC,KAAK,CAACY,IAAN,CAAW,KAAKK,IAAL,CAAUmB,KAArB,CAHG;AAIVN,QAAAA,OAAO,EAAE,KAAKb,IAAL,CAAUa;AAJT,OAAZ;AAMD;;AAED,WAAO,KAAKU,IAAZ;AACD;;AAED,SAAOC,QAAP,CAAgBC,qBAAhB,EAAuC;AACrC,WAAO,IAAIjC,SAAJ,CAAc;AACnB6B,MAAAA,UAAU,EAAE7B,SAAS,CAACK,qBAAV,CACV4B,qBAAqB,CAACJ,UADZ,CADO;AAInB3B,MAAAA,GAAG,EAAE,IAAIH,GAAJ,CAAQkC,qBAAqB,CAAC/B,GAA9B,CAJc;AAKnByB,MAAAA,KAAK,EAAE,IAAI5B,GAAJ,CAAQkC,qBAAqB,CAACN,KAA9B,CALY;AAMnBN,MAAAA,OAAO,EAAEY,qBAAqB,CAACZ;AANZ,KAAd,CAAP;AAQD;AACD;;;;;;;;;;AASAL,EAAAA,kBAAkB,CAACN,IAAD,EAAOC,QAAP,EAAiBC,sBAAjB,EAAyC;AACzD,UAAMV,GAAG,GAAG,KAAKM,IAAL,CAAUN,GAAV,CAAclC,GAAd,CAAkB0C,IAAlB,KAA2Bb,SAAvC;AACA,UAAMqC,MAAM,GAAG,KAAK1B,IAAL,CAAUqB,UAAV,CAAqB7D,GAArB,CAAyB0C,IAAzB,KAAkCZ,SAAjD;;AAEA,QAAIa,QAAQ,IAAI,IAAhB,EAAsB;AACpB,WAAKwB,mBAAL,CACEzB,IADF,EAEEC,QAFF,EAGEC,sBAHF,EAIEsB,MAAM,CAAClE,GAAP,CAAW2C,QAAX,CAJF;;AAOA,UAAIT,GAAG,CAACS,QAAD,CAAH,IAAiB,IAArB,EAA2B;AACzB,eAAOT,GAAG,CAACS,QAAD,CAAV;AACD;AACF;;AAED,QAAIC,sBAAJ,EAA4B;AAC1B,WAAKuB,mBAAL,CACEzB,IADF,EAEErD,UAAU,CAACJ,OAAX,CAAmBmF,eAFrB,EAGExB,sBAHF,EAIEsB,MAAM,CAAClE,GAAP,CAAWX,UAAU,CAACJ,OAAX,CAAmBmF,eAA9B,CAJF;;AAOA,UAAIlC,GAAG,CAAC7C,UAAU,CAACJ,OAAX,CAAmBmF,eAApB,CAAP,EAA6C;AAC3C,eAAOlC,GAAG,CAAC7C,UAAU,CAACJ,OAAX,CAAmBmF,eAApB,CAAV;AACD;AACF;;AAED,SAAKD,mBAAL,CACEzB,IADF,EAEErD,UAAU,CAACJ,OAAX,CAAmBoF,gBAFrB,EAGEzB,sBAHF,EAIEsB,MAAM,CAAClE,GAAP,CAAWX,UAAU,CAACJ,OAAX,CAAmBoF,gBAA9B,CAJF;;AAOA,QAAInC,GAAG,CAAC7C,UAAU,CAACJ,OAAX,CAAmBoF,gBAApB,CAAP,EAA8C;AAC5C,aAAOnC,GAAG,CAAC7C,UAAU,CAACJ,OAAX,CAAmBoF,gBAApB,CAAV;AACD;;AAED,WAAO,IAAP;AACD;;AAEDF,EAAAA,mBAAmB,CAACzB,IAAD,EAAOC,QAAP,EAAiBC,sBAAjB,EAAyC0B,eAAzC,EAA0D;AAC3E,QAAIA,eAAe,IAAI,IAAvB,EAA6B;AAC3B;AACD,KAH0E,CAGzE;;;AAEF,UAAMC,WAAW,GAAGD,eAApB;AACA,UAAMT,UAAU,GAAG,IAAI9B,GAAJ,EAAnB;AACA,QAAIyC,yBAAyB,GAAG,IAAhC;AACA,QAAIC,iBAAiB,GAAG,KAAxB;AACA,QAAIC,cAAc,GAAG7D,SAArB;;AAEA,QAAI;AACF,WACE,IAAI8D,SAAS,GAAGJ,WAAW,CAACxD,MAAM,CAACC,QAAR,CAAX,EAAhB,EAAgD4D,KADlD,EAEE,EAAEJ,yBAAyB,GAAG,CAACI,KAAK,GAAGD,SAAS,CAACzD,IAAV,EAAT,EAA2BC,IAAzD,CAFF,EAGEqD,yBAAyB,GAAG,IAH9B,EAIE;AACA,cAAMK,WAAW,GAAG3E,cAAc,CAAC0E,KAAK,CAAC5F,KAAP,EAAc,CAAd,CAAlC;AAAA,cACE8F,YAAY,GAAGD,WAAW,CAAC,CAAD,CAD5B;AAAA,cAEEhC,IAAI,GAAGgC,WAAW,CAAC,CAAD,CAFpB;;AAIA,cAAME,aAAa,GAAG7F,QAAQ,CAACkE,OAAT,CAAiB,KAAKZ,IAAL,CAAUa,OAA3B,EAAoCyB,YAApC,CAAtB;AACAjB,QAAAA,UAAU,CAAC5D,GAAX,CAAe8E,aAAf,EAA8BlC,IAA9B;AACD;AACF,KAbD,CAaE,OAAOvB,GAAP,EAAY;AACZmD,MAAAA,iBAAiB,GAAG,IAApB;AACAC,MAAAA,cAAc,GAAGpD,GAAjB;AACD,KAhBD,SAgBU;AACR,UAAI;AACF,YAAI,CAACkD,yBAAD,IAA8BG,SAAS,CAACK,MAAV,IAAoB,IAAtD,EAA4D;AAC1DL,UAAAA,SAAS,CAACK,MAAV;AACD;AACF,OAJD,SAIU;AACR,YAAIP,iBAAJ,EAAuB;AACrB,gBAAMC,cAAN;AACD;AACF;AACF;;AAED,UAAM,IAAIO,6BAAJ,CACJvC,IADI,EAEJC,QAFI,EAGJC,sBAHI,EAIJiB,UAJI,CAAN;AAMD;;AAED,SAAOqB,MAAP,CAAc7B,OAAd,EAAuB;AACrB,WAAO,IAAIrB,SAAJ,CAAc;AACnB6B,MAAAA,UAAU,EAAE,IAAI9B,GAAJ,EADO;AAEnBG,MAAAA,GAAG,EAAE,IAAIH,GAAJ,EAFc;AAGnB4B,MAAAA,KAAK,EAAE,IAAI5B,GAAJ,EAHY;AAInBsB,MAAAA;AAJmB,KAAd,CAAP;AAMD;;AApMa;;AAuMhBtE,OAAO,CAACE,OAAR,GAAkB+C,SAAlB;;AAEAP,eAAe,CAACO,SAAD,EAAY,+BAAZ,EAA6C,KAAK,CAAlD,CAAf;;AAEA,MAAMiD,6BAAN,SAA4CE,KAA5C,CAAkD;AAChD7C,EAAAA,WAAW,CAACI,IAAD,EAAOC,QAAP,EAAiBC,sBAAjB,EAAyCwC,aAAzC,EAAwD;AACjE,UAAMC,eAAe,GAAGC,kBAAkB,CAAC3C,QAAD,CAA1C;AACA,UACG,cAAaD,IAAK,+CAAnB,GACG,6DADH,GAEG,gDAFH,GAGG,sCAAqC2C,eAAgB,YAHxD,GAIG,sEAJH,GAKE9D,KAAK,CAACY,IAAN,CAAWiD,aAAX,EACGlD,GADH,CAEI,CAAC,CAACqD,WAAD,EAAcC,WAAd,CAAD,KACG,SAAQD,WAAY,OAAME,cAAc,CAACD,WAAD,CAAc,KAH7D,EAKGE,IALH,GAMGC,IANH,CAMQ,EANR,CANJ;;AAeAlE,IAAAA,eAAe,CAAC,IAAD,EAAO,WAAP,EAAoB,KAAK,CAAzB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,UAAP,EAAmB,KAAK,CAAxB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,wBAAP,EAAiC,KAAK,CAAtC,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwB,KAAK,CAA7B,CAAf;;AAEA,SAAKmE,SAAL,GAAiBlD,IAAjB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,sBAAL,GAA8BA,sBAA9B;AACA,SAAKwC,aAAL,GAAqBA,aAArB;AACD;;AA9B+C;;AAiClD,SAASE,kBAAT,CAA4B3C,QAA5B,EAAsC;AACpC,MAAIA,QAAQ,KAAKtD,UAAU,CAACJ,OAAX,CAAmBoF,gBAApC,EAAsD;AACpD,WAAO,yCAAP;AACD;;AAED,SAAQ,+BAA8B1B,QAAS,KAA/C;AACD;;AAED,SAAS8C,cAAT,CAAwB5C,IAAxB,EAA8B;AAC5B,UAAQA,IAAR;AACE,SAAKxD,UAAU,CAACJ,OAAX,CAAmB6D,MAAxB;AACE,aAAO,QAAP;;AAEF,SAAKzD,UAAU,CAACJ,OAAX,CAAmBuE,OAAxB;AACE,aAAO,SAAP;AALJ;;AAQA,SAAO,SAAP;AACD;;AAEDxB,SAAS,CAACiD,6BAAV,GAA0CA,6BAA1C","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc =\n            Object.defineProperty && Object.getOwnPropertyDescriptor\n              ? Object.getOwnPropertyDescriptor(obj, key)\n              : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()\n  );\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (\n      var _i = arr[Symbol.iterator](), _s;\n      !(_n = (_s = _i.next()).done);\n      _n = true\n    ) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst EMPTY_OBJ = {};\nconst EMPTY_MAP = new Map();\n\nclass ModuleMap {\n  static mapToArrayRecursive(map) {\n    let arr = Array.from(map);\n\n    if (arr[0] && arr[0][1] instanceof Map) {\n      arr = arr.map(el => [el[0], this.mapToArrayRecursive(el[1])]);\n    }\n\n    return arr;\n  }\n\n  static mapFromArrayRecursive(arr) {\n    if (arr[0] && Array.isArray(arr[1])) {\n      arr = arr.map(el => [el[0], this.mapFromArrayRecursive(el[1])]);\n    }\n\n    return new Map(arr);\n  }\n\n  constructor(raw) {\n    _defineProperty(this, '_raw', void 0);\n\n    _defineProperty(this, 'json', void 0);\n\n    this._raw = raw;\n  }\n\n  getModule(name, platform, supportsNativePlatform, type) {\n    if (type == null) {\n      type = _constants.default.MODULE;\n    }\n\n    const module = this._getModuleMetadata(\n      name,\n      platform,\n      !!supportsNativePlatform\n    );\n\n    if (module && module[_constants.default.TYPE] === type) {\n      const modulePath = module[_constants.default.PATH];\n      return modulePath && fastPath.resolve(this._raw.rootDir, modulePath);\n    }\n\n    return null;\n  }\n\n  getPackage(name, platform, _supportsNativePlatform) {\n    return this.getModule(name, platform, null, _constants.default.PACKAGE);\n  }\n\n  getMockModule(name) {\n    const mockPath =\n      this._raw.mocks.get(name) || this._raw.mocks.get(name + '/index');\n\n    return mockPath && fastPath.resolve(this._raw.rootDir, mockPath);\n  }\n\n  getRawModuleMap() {\n    return {\n      duplicates: this._raw.duplicates,\n      map: this._raw.map,\n      mocks: this._raw.mocks,\n      rootDir: this._raw.rootDir\n    };\n  }\n\n  toJSON() {\n    if (!this.json) {\n      this.json = {\n        duplicates: ModuleMap.mapToArrayRecursive(this._raw.duplicates),\n        map: Array.from(this._raw.map),\n        mocks: Array.from(this._raw.mocks),\n        rootDir: this._raw.rootDir\n      };\n    }\n\n    return this.json;\n  }\n\n  static fromJSON(serializableModuleMap) {\n    return new ModuleMap({\n      duplicates: ModuleMap.mapFromArrayRecursive(\n        serializableModuleMap.duplicates\n      ),\n      map: new Map(serializableModuleMap.map),\n      mocks: new Map(serializableModuleMap.mocks),\n      rootDir: serializableModuleMap.rootDir\n    });\n  }\n  /**\n   * When looking up a module's data, we walk through each eligible platform for\n   * the query. For each platform, we want to check if there are known\n   * duplicates for that name+platform pair. The duplication logic normally\n   * removes elements from the `map` object, but we want to check upfront to be\n   * extra sure. If metadata exists both in the `duplicates` object and the\n   * `map`, this would be a bug.\n   */\n\n  _getModuleMetadata(name, platform, supportsNativePlatform) {\n    const map = this._raw.map.get(name) || EMPTY_OBJ;\n    const dupMap = this._raw.duplicates.get(name) || EMPTY_MAP;\n\n    if (platform != null) {\n      this._assertNoDuplicates(\n        name,\n        platform,\n        supportsNativePlatform,\n        dupMap.get(platform)\n      );\n\n      if (map[platform] != null) {\n        return map[platform];\n      }\n    }\n\n    if (supportsNativePlatform) {\n      this._assertNoDuplicates(\n        name,\n        _constants.default.NATIVE_PLATFORM,\n        supportsNativePlatform,\n        dupMap.get(_constants.default.NATIVE_PLATFORM)\n      );\n\n      if (map[_constants.default.NATIVE_PLATFORM]) {\n        return map[_constants.default.NATIVE_PLATFORM];\n      }\n    }\n\n    this._assertNoDuplicates(\n      name,\n      _constants.default.GENERIC_PLATFORM,\n      supportsNativePlatform,\n      dupMap.get(_constants.default.GENERIC_PLATFORM)\n    );\n\n    if (map[_constants.default.GENERIC_PLATFORM]) {\n      return map[_constants.default.GENERIC_PLATFORM];\n    }\n\n    return null;\n  }\n\n  _assertNoDuplicates(name, platform, supportsNativePlatform, relativePathSet) {\n    if (relativePathSet == null) {\n      return;\n    } // Force flow refinement\n\n    const previousSet = relativePathSet;\n    const duplicates = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (\n        var _iterator = previousSet[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n      ) {\n        const _step$value = _slicedToArray(_step.value, 2),\n          relativePath = _step$value[0],\n          type = _step$value[1];\n\n        const duplicatePath = fastPath.resolve(this._raw.rootDir, relativePath);\n        duplicates.set(duplicatePath, type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    throw new DuplicateHasteCandidatesError(\n      name,\n      platform,\n      supportsNativePlatform,\n      duplicates\n    );\n  }\n\n  static create(rootDir) {\n    return new ModuleMap({\n      duplicates: new Map(),\n      map: new Map(),\n      mocks: new Map(),\n      rootDir\n    });\n  }\n}\n\nexports.default = ModuleMap;\n\n_defineProperty(ModuleMap, 'DuplicateHasteCandidatesError', void 0);\n\nclass DuplicateHasteCandidatesError extends Error {\n  constructor(name, platform, supportsNativePlatform, duplicatesSet) {\n    const platformMessage = getPlatformMessage(platform);\n    super(\n      `The name \\`${name}\\` was looked up in the Haste module map. It ` +\n        `cannot be resolved, because there exists several different ` +\n        `files, or packages, that provide a module for ` +\n        `that particular name and platform. ${platformMessage} You must ` +\n        `delete or blacklist files until there remains only one of these:\\n\\n` +\n        Array.from(duplicatesSet)\n          .map(\n            ([dupFilePath, dupFileType]) =>\n              `  * \\`${dupFilePath}\\` (${getTypeMessage(dupFileType)})\\n`\n          )\n          .sort()\n          .join('')\n    );\n\n    _defineProperty(this, 'hasteName', void 0);\n\n    _defineProperty(this, 'platform', void 0);\n\n    _defineProperty(this, 'supportsNativePlatform', void 0);\n\n    _defineProperty(this, 'duplicatesSet', void 0);\n\n    this.hasteName = name;\n    this.platform = platform;\n    this.supportsNativePlatform = supportsNativePlatform;\n    this.duplicatesSet = duplicatesSet;\n  }\n}\n\nfunction getPlatformMessage(platform) {\n  if (platform === _constants.default.GENERIC_PLATFORM) {\n    return 'The platform is generic (no extension).';\n  }\n\n  return `The platform extension is \\`${platform}\\`.`;\n}\n\nfunction getTypeMessage(type) {\n  switch (type) {\n    case _constants.default.MODULE:\n      return 'module';\n\n    case _constants.default.PACKAGE:\n      return 'package';\n  }\n\n  return 'unknown';\n}\n\nModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;\n"]},"metadata":{},"sourceType":"script"}