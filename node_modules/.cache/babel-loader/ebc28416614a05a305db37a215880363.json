{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.precaching = function (t, e, n, s, c) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:precaching:4.3.1\"] && _();\n  } catch (t) {}\n\n  const o = [],\n        i = {\n    get: () => o,\n\n    add(t) {\n      o.push(...t);\n    }\n\n  };\n  const a = \"__WB_REVISION__\";\n\n  function r(t) {\n    if (!t) throw new c.WorkboxError(\"add-to-cache-list-unexpected-type\", {\n      entry: t\n    });\n\n    if (\"string\" == typeof t) {\n      const e = new URL(t, location);\n      return {\n        cacheKey: e.href,\n        url: e.href\n      };\n    }\n\n    const {\n      revision: e,\n      url: n\n    } = t;\n    if (!n) throw new c.WorkboxError(\"add-to-cache-list-unexpected-type\", {\n      entry: t\n    });\n\n    if (!e) {\n      const t = new URL(n, location);\n      return {\n        cacheKey: t.href,\n        url: t.href\n      };\n    }\n\n    const s = new URL(n, location),\n          o = new URL(n, location);\n    return o.searchParams.set(a, e), {\n      cacheKey: o.href,\n      url: s.href\n    };\n  }\n\n  class l {\n    constructor(t) {\n      this.t = e.cacheNames.getPrecacheName(t), this.s = new Map();\n    }\n\n    addToCacheList(t) {\n      for (const e of t) {\n        const {\n          cacheKey: t,\n          url: n\n        } = r(e);\n        if (this.s.has(n) && this.s.get(n) !== t) throw new c.WorkboxError(\"add-to-cache-list-conflicting-entries\", {\n          firstEntry: this.s.get(n),\n          secondEntry: t\n        });\n        this.s.set(n, t);\n      }\n    }\n\n    async install({\n      event: t,\n      plugins: e\n    } = {}) {\n      const n = [],\n            s = [],\n            c = await caches.open(this.t),\n            o = await c.keys(),\n            i = new Set(o.map(t => t.url));\n\n      for (const t of this.s.values()) i.has(t) ? s.push(t) : n.push(t);\n\n      const a = n.map(n => this.o({\n        event: t,\n        plugins: e,\n        url: n\n      }));\n      return await Promise.all(a), {\n        updatedURLs: n,\n        notUpdatedURLs: s\n      };\n    }\n\n    async activate() {\n      const t = await caches.open(this.t),\n            e = await t.keys(),\n            n = new Set(this.s.values()),\n            s = [];\n\n      for (const c of e) n.has(c.url) || (await t.delete(c), s.push(c.url));\n\n      return {\n        deletedURLs: s\n      };\n    }\n\n    async o({\n      url: t,\n      event: e,\n      plugins: o\n    }) {\n      const i = new Request(t, {\n        credentials: \"same-origin\"\n      });\n      let a,\n          r = await s.fetchWrapper.fetch({\n        event: e,\n        plugins: o,\n        request: i\n      });\n\n      for (const t of o || []) \"cacheWillUpdate\" in t && (a = t.cacheWillUpdate.bind(t));\n\n      if (!(a ? a({\n        event: e,\n        request: i,\n        response: r\n      }) : r.status < 400)) throw new c.WorkboxError(\"bad-precaching-response\", {\n        url: t,\n        status: r.status\n      });\n      r.redirected && (r = await async function (t) {\n        const e = t.clone(),\n              n = \"body\" in e ? Promise.resolve(e.body) : e.blob(),\n              s = await n;\n        return new Response(s, {\n          headers: e.headers,\n          status: e.status,\n          statusText: e.statusText\n        });\n      }(r)), await n.cacheWrapper.put({\n        event: e,\n        plugins: o,\n        request: i,\n        response: r,\n        cacheName: this.t,\n        matchOptions: {\n          ignoreSearch: !0\n        }\n      });\n    }\n\n    getURLsToCacheKeys() {\n      return this.s;\n    }\n\n    getCachedURLs() {\n      return [...this.s.keys()];\n    }\n\n    getCacheKeyForURL(t) {\n      const e = new URL(t, location);\n      return this.s.get(e.href);\n    }\n\n  }\n\n  let u;\n\n  const h = () => (u || (u = new l()), u);\n\n  const d = (t, e) => {\n    const n = h().getURLsToCacheKeys();\n\n    for (const s of function* (t, {\n      ignoreURLParametersMatching: e,\n      directoryIndex: n,\n      cleanURLs: s,\n      urlManipulation: c\n    } = {}) {\n      const o = new URL(t, location);\n      o.hash = \"\", yield o.href;\n\n      const i = function (t, e) {\n        for (const n of [...t.searchParams.keys()]) e.some(t => t.test(n)) && t.searchParams.delete(n);\n\n        return t;\n      }(o, e);\n\n      if (yield i.href, n && i.pathname.endsWith(\"/\")) {\n        const t = new URL(i);\n        t.pathname += n, yield t.href;\n      }\n\n      if (s) {\n        const t = new URL(i);\n        t.pathname += \".html\", yield t.href;\n      }\n\n      if (c) {\n        const t = c({\n          url: o\n        });\n\n        for (const e of t) yield e.href;\n      }\n    }(t, e)) {\n      const t = n.get(s);\n      if (t) return t;\n    }\n  };\n\n  let w = !1;\n\n  const f = t => {\n    w || ((({\n      ignoreURLParametersMatching: t = [/^utm_/],\n      directoryIndex: n = \"index.html\",\n      cleanURLs: s = !0,\n      urlManipulation: c = null\n    } = {}) => {\n      const o = e.cacheNames.getPrecacheName();\n      addEventListener(\"fetch\", e => {\n        const i = d(e.request.url, {\n          cleanURLs: s,\n          directoryIndex: n,\n          ignoreURLParametersMatching: t,\n          urlManipulation: c\n        });\n        if (!i) return;\n        let a = caches.open(o).then(t => t.match(i)).then(t => t || fetch(i));\n        e.respondWith(a);\n      });\n    })(t), w = !0);\n  },\n        y = t => {\n    const e = h(),\n          n = i.get();\n    t.waitUntil(e.install({\n      event: t,\n      plugins: n\n    }).catch(t => {\n      throw t;\n    }));\n  },\n        p = t => {\n    const e = h(),\n          n = i.get();\n    t.waitUntil(e.activate({\n      event: t,\n      plugins: n\n    }));\n  },\n        L = t => {\n    h().addToCacheList(t), t.length > 0 && (addEventListener(\"install\", y), addEventListener(\"activate\", p));\n  };\n\n  return t.addPlugins = t => {\n    i.add(t);\n  }, t.addRoute = f, t.cleanupOutdatedCaches = () => {\n    addEventListener(\"activate\", t => {\n      const n = e.cacheNames.getPrecacheName();\n      t.waitUntil((async (t, e = \"-precache-\") => {\n        const n = (await caches.keys()).filter(n => n.includes(e) && n.includes(self.registration.scope) && n !== t);\n        return await Promise.all(n.map(t => caches.delete(t))), n;\n      })(n).then(t => {}));\n    });\n  }, t.getCacheKeyForURL = t => {\n    return h().getCacheKeyForURL(t);\n  }, t.precache = L, t.precacheAndRoute = (t, e) => {\n    L(t), f(e);\n  }, t.PrecacheController = l, t;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../utils/precachePlugins.mjs","../utils/createCacheKey.mjs","../PrecacheController.mjs","../utils/cleanRedirect.mjs","../utils/getOrCreatePrecacheController.mjs","../utils/getCacheKeyForURL.mjs","../utils/generateURLVariations.mjs","../utils/removeIgnoredSearchParams.mjs","../addRoute.mjs","../utils/addFetchListener.mjs","../precache.mjs","../addPlugins.mjs","../cleanupOutdatedCaches.mjs","../utils/deleteOutdatedCaches.mjs","../getCacheKeyForURL.mjs","../precacheAndRoute.mjs"],"names":["self","_","e","plugins","precachePlugins","get","add","newPlugins","push","REVISION_SEARCH_PARAM","createCacheKey","entry","WorkboxError","urlObject","URL","location","cacheKey","href","url","revision","originalURL","cacheKeyURL","searchParams","set","PrecacheController","constructor","cacheName","_cacheName","cacheNames","getPrecacheName","_urlsToCacheKeys","Map","addToCacheList","entries","this","has","firstEntry","secondEntry","event","urlsToPrecache","urlsAlreadyPrecached","cache","caches","open","alreadyCachedRequests","keys","alreadyCachedURLs","Set","map","request","values","precacheRequests","_addURLToCache","Promise","all","updatedURLs","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","deletedURLs","delete","Request","credentials","response","fetchWrapper","fetch","cacheWillUpdateCallback","plugin","cacheWillUpdate","bind","status","redirected","cleanRedirect","cacheWrapper","put","matchOptions","ignoreSearch","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","async","clonedResponse","clone","bodyPromise","resolve","body","blob","Response","headers","statusText","precacheController","getOrCreatePrecacheController","options","urlsToCacheKeys","possibleURL","generateURLVariations","possibleCacheKey","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","hash","urlWithoutIgnoredParams","removeIgnoredSearchParams","pathname","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","paramName","some","regExp","test","listenerAdded","addRoute","addFetchListener","addEventListener","precachedURL","responsePromise","then","match","cachedResponse","respondWith","installListener","waitUntil","install","catch","error","activateListener","activate","precache","length","deleteOutdatedCaches","cachesDeleted","currentPrecacheName","substringToFind","cacheNamesToDelete","filter","includes","registration","scope"],"mappings":"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","sourcesContent":["try{self['workbox:precaching:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst plugins = [];\n\nexport const precachePlugins = {\n  /*\n   * @return {Array}\n   * @private\n   */\n  get() {\n    return plugins;\n  },\n\n  /*\n   * @param {Array} newPlugins\n   * @private\n   */\n  add(newPlugins) {\n    plugins.push(...newPlugins);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport '../_version.mjs';\n\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  const {revision, url} = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const originalURL = new URL(url, location);\n  const cacheKeyURL = new URL(url, location);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href,\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {cleanRedirect} from './utils/cleanRedirect.mjs';\nimport {createCacheKey} from './utils/createCacheKey.mjs';\nimport {printCleanupDetails} from './utils/printCleanupDetails.mjs';\nimport {printInstallDetails} from './utils/printInstallDetails.mjs';\n\nimport './_version.mjs';\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    for (const entry of entries) {\n      const {cacheKey, url} = createCacheKey(entry);\n      if (this._urlsToCacheKeys.has(url) &&\n          this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey,\n        });\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n  async install({event, plugins} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins',\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(\n        (request) => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map((url) => {\n      return this._addURLToCache({event, plugins, url});\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {deletedURLs};\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n  async _addURLToCache({url, event, plugins}) {\n    const request = new Request(url, {credentials: 'same-origin'});\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request,\n    });\n\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n    let cacheWillUpdateCallback;\n    for (const plugin of (plugins || [])) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ?\n      // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({event, request, response}) :\n      // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400;\n\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status,\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true,\n      },\n    });\n  }\n\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n}\n\nexport {PrecacheController};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * @param {Response} response\n * @return {Response}\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport async function cleanRedirect(response) {\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back\n  // to reading the entire body into memory as a blob.\n  const bodyPromise = 'body' in clonedResponse ?\n    Promise.resolve(clonedResponse.body) :\n    clonedResponse.blob();\n\n  const body = await bodyPromise;\n\n  // new Response() is happy when passed either a stream or a Blob.\n  return new Response(body, {\n    headers: clonedResponse.headers,\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText,\n  });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {PrecacheController} from '../PrecacheController.mjs';\nimport '../_version.mjs';\n\n\nlet precacheController;\n\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './getOrCreatePrecacheController.mjs';\nimport {generateURLVariations} from './generateURLVariations.mjs';\nimport '../_version.mjs';\n\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string} Returns the URL in the cache that matches the request,\n * if possible.\n *\n * @private\n */\nexport const getCacheKeyForURL = (url, options) => {\n  const precacheController = getOrCreatePrecacheController();\n\n  const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n  for (const possibleURL of generateURLVariations(url, options)) {\n    const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n    if (possibleCacheKey) {\n      return possibleCacheKey;\n    }\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {removeIgnoredSearchParams} from './removeIgnoredSearchParams.mjs';\n\nimport '../_version.mjs';\n\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function* generateURLVariations(url, {\n  ignoreURLParametersMatching,\n  directoryIndex,\n  cleanURLs,\n  urlManipulation,\n} = {}) {\n  const urlObject = new URL(url, location);\n  urlObject.hash = '';\n  yield urlObject.href;\n\n  const urlWithoutIgnoredParams = removeIgnoredSearchParams(\n      urlObject, ignoreURLParametersMatching);\n  yield urlWithoutIgnoredParams.href;\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    const directoryURL = new URL(urlWithoutIgnoredParams);\n    directoryURL.pathname += directoryIndex;\n    yield directoryURL.href;\n  }\n\n  if (cleanURLs) {\n    const cleanURL = new URL(urlWithoutIgnoredParams);\n    cleanURL.pathname += '.html';\n    yield cleanURL.href;\n  }\n\n  if (urlManipulation) {\n    const additionalURLs = urlManipulation({url: urlObject});\n    for (const urlToAttempt of additionalURLs) {\n      yield urlToAttempt.href;\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject,\n    ignoreURLParametersMatching) {\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n\n  return urlObject;\n}\n","\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addFetchListener} from './utils/addFetchListener.mjs';\nimport './_version.mjs';\n\n\nlet listenerAdded = false;\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\nexport const addRoute = (options) => {\n  if (!listenerAdded) {\n    addFetchListener(options);\n    listenerAdded = true;\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getCacheKeyForURL} from './getCacheKeyForURL.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n */\nexport const addFetchListener = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null,\n} = {}) => {\n  const cacheName = cacheNames.getPrecacheName();\n\n  addEventListener('fetch', (event) => {\n    const precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs,\n      directoryIndex,\n      ignoreURLParametersMatching,\n      urlManipulation,\n    });\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` +\n          getFriendlyURL(event.request.url));\n      }\n      return;\n    }\n\n    let responsePromise = caches.open(cacheName).then((cache) => {\n      return cache.match(precachedURL);\n    }).then((cachedResponse) => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n\n      // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` +\n        `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n        `Falling back to the network instead.`);\n      }\n\n      return fetch(precachedURL);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then((response) => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(`Precaching is responding to: ` +\n          getFriendlyURL(event.request.url));\n        logger.log(`Serving the precached url: ${precachedURL}`);\n\n        logger.groupCollapsed(`View request details here.`);\n        logger.log(event.request);\n        logger.groupEnd();\n\n        logger.groupCollapsed(`View response details here.`);\n        logger.log(response);\n        logger.groupEnd();\n\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getOrCreatePrecacheController} from './utils/getOrCreatePrecacheController.mjs';\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\nconst installListener = (event) => {\n  const precacheController = getOrCreatePrecacheController();\n  const plugins = precachePlugins.get();\n\n  event.waitUntil(\n      precacheController.install({event, plugins})\n          .catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(`Service worker installation failed. It will ` +\n              `be retried automatically during the next navigation.`);\n            }\n            // Re-throw the error to ensure installation fails.\n            throw error;\n          })\n  );\n};\n\nconst activateListener = (event) => {\n  const precacheController = getOrCreatePrecacheController();\n  const plugins = precachePlugins.get();\n\n  event.waitUntil(precacheController.activate({event, plugins}));\n};\n\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nexport const precache = (entries) => {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.addToCacheList(entries);\n\n  if (entries.length > 0) {\n    // NOTE: these listeners will only be added once (even if the `precache()`\n    // method is called multiple times) because event listeners are implemented\n    // as a set, where each listener must be unique.\n    addEventListener('install', installListener);\n    addEventListener('activate', activateListener);\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds plugins to precaching.\n *\n * @param {Array<Object>} newPlugins\n *\n * @alias workbox.precaching.addPlugins\n */\nconst addPlugins = (newPlugins) => {\n  precachePlugins.add(newPlugins);\n};\n\nexport {addPlugins};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {deleteOutdatedCaches} from './utils/deleteOutdatedCaches.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @alias workbox.precaching.cleanupOutdatedCaches\n */\nexport const cleanupOutdatedCaches = () => {\n  addEventListener('activate', (event) => {\n    const cacheName = cacheNames.getPrecacheName();\n\n    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachesDeleted.length > 0) {\n          logger.log(`The following out-of-date precaches were cleaned up ` +\n              `automatically:`, cachesDeleted);\n        }\n      }\n    }));\n  });\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst SUBSTRING_TO_FIND = '-precache-';\n\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nconst deleteOutdatedCaches = async (\n  currentPrecacheName,\n  substringToFind = SUBSTRING_TO_FIND) => {\n  const cacheNames = await caches.keys();\n\n  const cacheNamesToDelete = cacheNames.filter((cacheName) => {\n    return cacheName.includes(substringToFind) &&\n           cacheName.includes(self.registration.scope) &&\n           cacheName !== currentPrecacheName;\n  });\n\n  await Promise.all(\n      cacheNamesToDelete.map((cacheName) => caches.delete(cacheName)));\n\n  return cacheNamesToDelete;\n};\n\nexport {deleteOutdatedCaches};\n\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './utils/getOrCreatePrecacheController.mjs';\nimport './_version.mjs';\n\n\n/**\n * Takes in a URL, and returns the corresponding URL that could be used to\n * lookup the entry in the precache.\n *\n * If a relative URL is provided, the location of the service worker file will\n * be used as the base.\n *\n * For precached entries without revision information, the cache key will be the\n * same as the original URL.\n *\n * For precached entries with revision information, the cache key will be the\n * original URL with the addition of a query parameter used for keeping track of\n * the revision info.\n *\n * @param {string} url The URL whose cache key to look up.\n * @return {string} The cache key that corresponds to that URL.\n *\n * @alias workbox.precaching.getCacheKeyForURL\n */\nexport const getCacheKeyForURL = (url) => {\n  const precacheController = getOrCreatePrecacheController();\n  return precacheController.getCacheKeyForURL(url);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addRoute} from './addRoute.mjs';\nimport {precache} from './precache.mjs';\nimport './_version.mjs';\n\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nexport const precacheAndRoute = (entries, options) => {\n  precache(entries);\n  addRoute(options);\n};\n"]},"metadata":{},"sourceType":"script"}