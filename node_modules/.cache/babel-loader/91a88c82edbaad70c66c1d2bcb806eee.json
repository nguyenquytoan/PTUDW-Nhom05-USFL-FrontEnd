{"ast":null,"code":"/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); // Operators that always result in a boolean value\n\n\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n  \"==\": \"!=\",\n  \"!=\": \"==\",\n  \"===\": \"!==\",\n  \"!==\": \"===\" // Operators like < and >= are not true inverses, since both will return false with NaN.\n\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({\n  type: \"LogicalExpression\",\n  operator: \"||\"\n}); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow ternary operators when simpler alternatives exist\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        defaultAssignment: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const defaultAssignment = options.defaultAssignment !== false;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Test if the node is a boolean literal\n     * @param {ASTNode} node The node to report.\n     * @returns {boolean} True if the its a boolean literal\n     * @private\n     */\n\n    function isBooleanLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"boolean\";\n    }\n    /**\n     * Creates an expression that represents the boolean inverse of the expression represented by the original node\n     * @param {ASTNode} node A node representing an expression\n     * @returns {string} A string representing an inverted expression\n     */\n\n\n    function invertExpression(node) {\n      if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        const text = sourceCode.getText();\n        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n      }\n\n      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({\n        type: \"UnaryExpression\"\n      })) {\n        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n      }\n\n      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n    }\n    /**\n     * Tests if a given node always evaluates to a boolean value\n     * @param {ASTNode} node An expression node\n     * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n     */\n\n\n    function isBooleanExpression(node) {\n      return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) || node.type === \"UnaryExpression\" && node.operator === \"!\";\n    }\n    /**\n     * Test if the node matches the pattern id ? id : expression\n     * @param {ASTNode} node The ConditionalExpression to check.\n     * @returns {boolean} True if the pattern is matched, and false otherwise\n     * @private\n     */\n\n\n    function matchesDefaultAssignment(node) {\n      return node.test.type === \"Identifier\" && node.consequent.type === \"Identifier\" && node.test.name === node.consequent.name;\n    }\n\n    return {\n      ConditionalExpression(node) {\n        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n          context.report({\n            node,\n            loc: node.consequent.loc.start,\n            message: \"Unnecessary use of boolean literals in conditional expression.\",\n\n            fix(fixer) {\n              if (node.consequent.value === node.alternate.value) {\n                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n              }\n\n              if (node.alternate.value) {\n                // Replace `foo() ? false : true` with `!(foo())`\n                return fixer.replaceText(node, invertExpression(node.test));\n              } // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n\n              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n            }\n\n          });\n        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n          context.report({\n            node,\n            loc: node.consequent.loc.start,\n            message: \"Unnecessary use of conditional expression for default assignment.\",\n            fix: fixer => {\n              const shouldParenthesizeAlternate = astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE && !astUtils.isParenthesised(sourceCode, node.alternate);\n              const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);\n              const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n              return fixer.replaceText(node, `${testText} || ${alternateText}`);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-unneeded-ternary.js"],"names":["astUtils","require","BOOLEAN_OPERATORS","Set","OPERATOR_INVERSES","OR_PRECEDENCE","getPrecedence","type","operator","module","exports","meta","docs","description","category","recommended","url","schema","properties","defaultAssignment","default","additionalProperties","fixable","create","context","options","sourceCode","getSourceCode","isBooleanLiteral","node","value","invertExpression","Object","prototype","hasOwnProperty","call","operatorToken","getFirstTokenBetween","left","right","token","text","getText","slice","range","getParenthesisedText","isBooleanExpression","has","matchesDefaultAssignment","test","consequent","name","ConditionalExpression","alternate","report","loc","start","message","fix","fixer","replaceText","toString","shouldParenthesizeAlternate","isParenthesised","alternateText","testText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({ type: \"LogicalExpression\", operator: \"||\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n                const text = sourceCode.getText();\n\n                return text.slice(node.range[0],\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of boolean literals in conditional expression.\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of conditional expression for default assignment.\",\n                        fix: fixer => {\n                            const shouldParenthesizeAlternate = (\n                                astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE &&\n                                !astUtils.isParenthesised(sourceCode, node.alternate)\n                            );\n                            const alternateText = shouldParenthesizeAlternate\n                                ? `(${sourceCode.getText(node.alternate)})`\n                                : astUtils.getParenthesisedText(sourceCode, node.alternate);\n                            const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n\n                            return fixer.replaceText(node, `${testText} || ${alternateText}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}