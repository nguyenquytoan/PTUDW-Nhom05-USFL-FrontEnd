{"ast":null,"code":"/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple empty lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        max: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxEOF: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxBOF: {\n          type: \"integer\",\n          minimum: 0\n        }\n      },\n      required: [\"max\"],\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    // Use options.max or 2 as default\n    let max = 2,\n        maxEOF = max,\n        maxBOF = max;\n\n    if (context.options.length) {\n      max = context.options[0].max;\n      maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n      maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n    }\n\n    const sourceCode = context.getSourceCode(); // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n\n    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n    const templateLiteralLines = new Set(); //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      TemplateLiteral(node) {\n        node.quasis.forEach(literalPart => {\n          // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n            templateLiteralLines.add(ignoredLine);\n          }\n        });\n      },\n\n      \"Program:exit\"(node) {\n        return allLines // Given a list of lines, first get a list of line numbers that are non-empty.\n        .reduce((nonEmptyLineNumbers, line, index) => {\n          if (line.trim() || templateLiteralLines.has(index + 1)) {\n            nonEmptyLineNumbers.push(index + 1);\n          }\n\n          return nonEmptyLineNumbers;\n        }, []) // Add a value at the end to allow trailing empty lines to be checked.\n        .concat(allLines.length + 1) // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n        .reduce((lastLineNumber, lineNumber) => {\n          let message, maxAllowed;\n\n          if (lastLineNumber === 0) {\n            message = \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\";\n            maxAllowed = maxBOF;\n          } else if (lineNumber === allLines.length + 1) {\n            message = \"Too many blank lines at the end of file. Max of {{max}} allowed.\";\n            maxAllowed = maxEOF;\n          } else {\n            message = \"More than {{max}} blank {{pluralizedLines}} not allowed.\";\n            maxAllowed = max;\n          }\n\n          if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n            context.report({\n              node,\n              loc: {\n                start: {\n                  line: lastLineNumber + maxAllowed + 1,\n                  column: 0\n                },\n                end: {\n                  line: lineNumber,\n                  column: 0\n                }\n              },\n              message,\n              data: {\n                max: maxAllowed,\n                pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n              },\n\n              fix(fixer) {\n                const rangeStart = sourceCode.getIndexFromLoc({\n                  line: lastLineNumber + 1,\n                  column: 0\n                });\n                /*\n                 * The end of the removal range is usually the start index of the next line.\n                 * However, at the end of the file there is no next line, so the end of the\n                 * range is just the length of the text.\n                 */\n\n                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({\n                  line: lineNumberAfterRemovedLines,\n                  column: 0\n                }) : sourceCode.text.length;\n                return fixer.removeRange([rangeStart, rangeEnd]);\n              }\n\n            });\n          }\n\n          return lineNumber;\n        }, 0);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-multiple-empty-lines.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","max","minimum","maxEOF","maxBOF","required","additionalProperties","create","context","options","length","sourceCode","getSourceCode","allLines","lines","slice","templateLiteralLines","Set","TemplateLiteral","node","quasis","forEach","literalPart","ignoredLine","loc","start","line","end","add","reduce","nonEmptyLineNumbers","index","trim","has","push","concat","lastLineNumber","lineNumber","message","maxAllowed","report","column","data","pluralizedLines","fix","fixer","rangeStart","getIndexFromLoc","lineNumberAfterRemovedLines","rangeEnd","text","removeRange"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let message, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            message = \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            message = \"Too many blank lines at the end of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            message = \"More than {{max}} blank {{pluralizedLines}} not allowed.\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: { start: { line: lastLineNumber + maxAllowed + 1, column: 0 }, end: { line: lineNumber, column: 0 } },\n                                message,\n                                data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\" },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}