{"ast":null,"code":"/* eslint-env mocha */\nimport assert from 'assert';\nimport entries from 'object.entries';\nimport fromEntries from 'object.fromentries';\nimport { getOpeningElement, setParserName, fallbackToBabylon } from '../helper';\nimport getProp from '../../src/getProp';\nconst literal = {\n  source: '<div {...{ id: \"foo\" }} />',\n  target: '<div id=\"foo\" />',\n  offset: {\n    keyOffset: -6,\n    valueOffset: -7\n  }\n};\nconst expression1 = {\n  source: '<div {...{ id }} />',\n  target: '<div id={id} />',\n  offset: {\n    keyOffset: -6,\n    valueOffset: -2\n  }\n};\nconst expression2 = {\n  source: '<div {...{ id: `foo${bar}baz` }} />',\n  // eslint-disable-line no-template-curly-in-string\n  target: '<div id={`foo${bar}baz`} />',\n  // eslint-disable-line no-template-curly-in-string\n  offset: {\n    keyOffset: -6,\n    valueOffset: -6\n  }\n};\ndescribe('getProp', () => {\n  it('should create the correct AST for literal with flow parser', () => {\n    actualTest('flow', literal);\n  });\n  it('should create the correct AST for literal with babel parser', () => {\n    actualTest('babel', literal);\n  });\n  it('should create the correct AST for expression with flow parser (1)', () => {\n    actualTest('flow', expression1);\n  });\n  it('should create the correct AST for expression with babel parser (1)', () => {\n    actualTest('babel', expression1);\n  });\n  it('should create the correct AST for expression with flow parser (2)', () => {\n    actualTest('flow', expression2);\n  });\n  it('should create the correct AST for expression with babel parser (2)', () => {\n    actualTest('babel', expression2);\n  });\n});\n\nfunction actualTest(parserName, test) {\n  setParserName(parserName);\n  const {\n    source,\n    target,\n    offset\n  } = test;\n  const sourceProps = stripConstructors(getOpeningElement(source).attributes);\n  const targetProps = stripConstructors(getOpeningElement(target).attributes);\n  const prop = 'id';\n  const sourceResult = getProp(sourceProps, prop);\n  const targetResult = getProp(targetProps, prop);\n\n  if (fallbackToBabylon && parserName === 'babel' && test === literal) {\n    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a\n    // JSXAttribute, other literals don't get this.\n    sourceResult.value.extra = null;\n  }\n\n  assert.deepStrictEqual(adjustLocations(sourceResult, offset), adjustRangeStartAndEnd(targetResult));\n}\n\nfunction adjustRangeStartAndEnd({\n  name,\n  value: {\n    expression,\n    ...value\n  },\n  ...node\n}) {\n  return { ...adjustNodeRangeStartAndEnd(node),\n    name: adjustNodeRangeStartAndEnd(name),\n    value: { ...adjustNodeRangeStartAndEnd(value),\n      ...(expression ? {\n        expression: adjustNodeRangeStartAndEndRecursively(expression)\n      } : {})\n    }\n  };\n}\n\nfunction adjustNodeRangeStartAndEnd(node) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [node.start, node.end];\n  return { ...node,\n    end,\n    range: [start, end],\n    start\n  };\n}\n\nfunction adjustNodeRangeStartAndEndRecursively(node) {\n  if (Array.isArray(node)) {\n    return node.map(adjustNodeRangeStartAndEndRecursively);\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeRangeStartAndEnd(mapValues(node, adjustNodeRangeStartAndEndRecursively));\n  }\n\n  return node;\n}\n\nfunction stripConstructors(value) {\n  return JSON.parse(JSON.stringify(value));\n}\n\nfunction adjustLocations(node, {\n  keyOffset,\n  valueOffset\n}) {\n  const hasExpression = !!node.value.expression;\n  return { ...adjustNodeLocations(node, {\n      startOffset: keyOffset,\n      endOffset: valueOffset + (hasExpression ? 1 : 0)\n    }),\n    name: adjustNodeLocations(node.name, {\n      startOffset: keyOffset,\n      endOffset: keyOffset\n    }),\n    value: { ...adjustNodeLocations(node.value, {\n        startOffset: valueOffset - (hasExpression ? 1 : 0),\n        endOffset: valueOffset + (hasExpression ? 1 : 0)\n      }),\n      ...(hasExpression ? {\n        expression: adjustLocationsRecursively(node.value.expression, {\n          startOffset: valueOffset,\n          endOffset: valueOffset\n        })\n      } : {})\n    }\n  };\n}\n\nfunction adjustNodeLocations(node, {\n  startOffset,\n  endOffset\n}) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [];\n  return { ...node,\n    end: node.end + endOffset,\n    loc: { ...node.loc,\n      start: { ...node.loc.start,\n        column: node.loc.start.column + startOffset\n      },\n      end: { ...node.loc.end,\n        column: node.loc.end.column + endOffset\n      }\n    },\n    range: [start + startOffset, end + endOffset],\n    start: node.start + startOffset\n  };\n}\n\nfunction adjustLocationsRecursively(node, {\n  startOffset,\n  endOffset\n}) {\n  if (Array.isArray(node)) {\n    return node.map(x => adjustLocationsRecursively(x, {\n      startOffset,\n      endOffset\n    }));\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeLocations(mapValues(node, x => adjustLocationsRecursively(x, {\n      startOffset,\n      endOffset\n    })), {\n      startOffset,\n      endOffset\n    });\n  }\n\n  return node;\n}\n\nfunction mapValues(o, f) {\n  return fromEntries(entries(o).map(([k, v]) => [k, f(v)]));\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsx-ast-utils/__tests__/src/getProp-parser-test.js"],"names":["assert","entries","fromEntries","getOpeningElement","setParserName","fallbackToBabylon","getProp","literal","source","target","offset","keyOffset","valueOffset","expression1","expression2","describe","it","actualTest","parserName","test","sourceProps","stripConstructors","attributes","targetProps","prop","sourceResult","targetResult","value","extra","deepStrictEqual","adjustLocations","adjustRangeStartAndEnd","name","expression","node","adjustNodeRangeStartAndEnd","adjustNodeRangeStartAndEndRecursively","loc","start","end","range","Array","isArray","map","mapValues","JSON","parse","stringify","hasExpression","adjustNodeLocations","startOffset","endOffset","adjustLocationsRecursively","column","x","o","f","k","v"],"mappings":"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","sourcesContent":["/* eslint-env mocha */\nimport assert from 'assert';\nimport entries from 'object.entries';\nimport fromEntries from 'object.fromentries';\nimport { getOpeningElement, setParserName, fallbackToBabylon } from '../helper';\nimport getProp from '../../src/getProp';\n\nconst literal = {\n  source: '<div {...{ id: \"foo\" }} />',\n  target: '<div id=\"foo\" />',\n  offset: { keyOffset: -6, valueOffset: -7 },\n};\n\nconst expression1 = {\n  source: '<div {...{ id }} />',\n  target: '<div id={id} />',\n  offset: { keyOffset: -6, valueOffset: -2 },\n};\n\nconst expression2 = {\n  source: '<div {...{ id: `foo${bar}baz` }} />', // eslint-disable-line no-template-curly-in-string\n  target: '<div id={`foo${bar}baz`} />', // eslint-disable-line no-template-curly-in-string\n  offset: { keyOffset: -6, valueOffset: -6 },\n};\n\ndescribe('getProp', () => {\n  it('should create the correct AST for literal with flow parser', () => {\n    actualTest('flow', literal);\n  });\n  it('should create the correct AST for literal with babel parser', () => {\n    actualTest('babel', literal);\n  });\n  it('should create the correct AST for expression with flow parser (1)', () => {\n    actualTest('flow', expression1);\n  });\n  it('should create the correct AST for expression with babel parser (1)', () => {\n    actualTest('babel', expression1);\n  });\n  it('should create the correct AST for expression with flow parser (2)', () => {\n    actualTest('flow', expression2);\n  });\n  it('should create the correct AST for expression with babel parser (2)', () => {\n    actualTest('babel', expression2);\n  });\n});\n\nfunction actualTest(parserName, test) {\n  setParserName(parserName);\n  const { source, target, offset } = test;\n  const sourceProps = stripConstructors(getOpeningElement(source).attributes);\n  const targetProps = stripConstructors(getOpeningElement(target).attributes);\n  const prop = 'id';\n  const sourceResult = getProp(sourceProps, prop);\n  const targetResult = getProp(targetProps, prop);\n\n  if (fallbackToBabylon && parserName === 'babel' && test === literal) {\n    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a\n    // JSXAttribute, other literals don't get this.\n    sourceResult.value.extra = null;\n  }\n\n  assert.deepStrictEqual(\n    adjustLocations(sourceResult, offset),\n    adjustRangeStartAndEnd(targetResult),\n  );\n}\n\nfunction adjustRangeStartAndEnd({ name, value: { expression, ...value }, ...node }) {\n  return {\n    ...adjustNodeRangeStartAndEnd(node),\n    name: adjustNodeRangeStartAndEnd(name),\n    value: {\n      ...adjustNodeRangeStartAndEnd(value),\n      ...(expression\n        ? { expression: adjustNodeRangeStartAndEndRecursively(expression) }\n        : {}\n      ),\n    },\n  };\n}\n\nfunction adjustNodeRangeStartAndEnd(node) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [node.start, node.end];\n  return {\n    ...node,\n    end,\n    range: [start, end],\n    start,\n  };\n}\n\nfunction adjustNodeRangeStartAndEndRecursively(node) {\n  if (Array.isArray(node)) {\n    return node.map(adjustNodeRangeStartAndEndRecursively);\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeRangeStartAndEnd(mapValues(node, adjustNodeRangeStartAndEndRecursively));\n  }\n\n  return node;\n}\n\nfunction stripConstructors(value) {\n  return JSON.parse(JSON.stringify(value));\n}\n\nfunction adjustLocations(node, { keyOffset, valueOffset }) {\n  const hasExpression = !!node.value.expression;\n  return {\n    ...adjustNodeLocations(node, {\n      startOffset: keyOffset,\n      endOffset: valueOffset + (hasExpression ? 1 : 0),\n    }),\n    name: adjustNodeLocations(node.name, { startOffset: keyOffset, endOffset: keyOffset }),\n    value: {\n      ...adjustNodeLocations(node.value, {\n        startOffset: valueOffset - (hasExpression ? 1 : 0),\n        endOffset: valueOffset + (hasExpression ? 1 : 0),\n      }),\n      ...(hasExpression\n        ? {\n          expression: adjustLocationsRecursively(\n            node.value.expression,\n            { startOffset: valueOffset, endOffset: valueOffset },\n          ),\n        }\n        : {}\n      ),\n    },\n  };\n}\n\nfunction adjustNodeLocations(node, { startOffset, endOffset }) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [];\n  return {\n    ...node,\n    end: node.end + endOffset,\n    loc: {\n      ...node.loc,\n      start: {\n        ...node.loc.start,\n        column: node.loc.start.column + startOffset,\n      },\n      end: {\n        ...node.loc.end,\n        column: node.loc.end.column + endOffset,\n      },\n    },\n    range: [start + startOffset, end + endOffset],\n    start: node.start + startOffset,\n  };\n}\n\nfunction adjustLocationsRecursively(node, { startOffset, endOffset }) {\n  if (Array.isArray(node)) {\n    return node.map((x) => adjustLocationsRecursively(x, { startOffset, endOffset }));\n  }\n  if (node && typeof node === 'object') {\n    return adjustNodeLocations(\n      mapValues(node, (x) => adjustLocationsRecursively(x, { startOffset, endOffset })),\n      { startOffset, endOffset },\n    );\n  }\n\n  return node;\n}\n\nfunction mapValues(o, f) {\n  return fromEntries(entries(o).map(([k, v]) => [k, f(v)]));\n}\n"]},"metadata":{},"sourceType":"module"}