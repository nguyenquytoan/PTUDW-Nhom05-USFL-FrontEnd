{"ast":null,"code":"var path = require('path');\n\nvar crypto = require('crypto');\n\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n\n    var flatCache = require('flat-cache');\n\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys(); // remove not found entries\n\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n\n    removeNotFoundFiles();\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: []\n        };\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n      getFileDescriptor: function (file) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return {\n            key: file,\n            notFound: true,\n            err: ex\n          };\n        }\n\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if (!meta) {\n          meta = {\n            size: cSize,\n            mtime: cTime\n          };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta\n        };\n        return nEntry;\n      },\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var contentBuffer;\n\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n\n        if (!meta) {\n          meta = {\n            hash: hash\n          };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta\n        };\n        return nEntry;\n      },\n\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n        return me.normalizeEntries(files).filter(function (entry) {\n          return entry.changed;\n        }).map(function (entry) {\n          return entry.key;\n        });\n      },\n\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        }); //normalizeEntries = nEntries;\n\n        return nEntries;\n      },\n\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, {\n          hash: hash\n        });\n        return meta;\n      },\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime()\n        });\n        return meta;\n      },\n\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n\n        if (keys.length === 0) {\n          return;\n        }\n\n        var me = this;\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n\n          try {\n            var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n        cache.save(noPrune);\n      }\n    };\n  }\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/file-entry-cache/cache.js"],"names":["path","require","crypto","module","exports","createFromFile","filePath","useChecksum","fname","basename","dir","dirname","create","cacheId","_path","fs","flatCache","cache","load","normalizedEntries","removeNotFoundFiles","cachedEntries","keys","forEach","remover","fPath","statSync","err","code","removeKey","getHash","buffer","createHash","update","digest","hasFileChanged","file","getFileDescriptor","changed","analyzeFiles","files","me","res","changedFiles","notFoundFiles","notChangedFiles","normalizeEntries","entry","push","key","notFound","fstat","ex","removeEntry","_getFileDescriptorUsingChecksum","_getFileDescriptorUsingMtimeAndSize","meta","getKey","cacheExists","cSize","size","cTime","mtime","getTime","isDifferentDate","isDifferentSize","nEntry","contentBuffer","readFileSync","isDifferent","hash","getUpdatedFiles","filter","map","nEntries","entryName","deleteCacheFile","removeCacheFile","destroy","_getMetaForFileUsingCheckSum","cacheEntry","Object","assign","_getMetaForFileUsingMtimeAndSize","stat","reconcile","noPrune","entries","length","setKey","save"],"mappings":"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","sourcesContent":["var path = require( 'path' );\nvar crypto = require( 'crypto' );\n\nmodule.exports = {\n  createFromFile: function ( filePath, useChecksum ) {\n    var fname = path.basename( filePath );\n    var dir = path.dirname( filePath );\n    return this.create( fname, dir, useChecksum );\n  },\n\n  create: function ( cacheId, _path, useChecksum ) {\n    var fs = require( 'fs' );\n    var flatCache = require( 'flat-cache' );\n    var cache = flatCache.load( cacheId, _path );\n    var normalizedEntries = { };\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys();\n      // remove not found entries\n      cachedEntries.forEach( function remover( fPath ) {\n        try {\n          fs.statSync( fPath );\n        } catch (err) {\n          if ( err.code === 'ENOENT' ) {\n            cache.removeKey( fPath );\n          }\n        }\n      } );\n    };\n\n    removeNotFoundFiles();\n\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function ( buffer ) {\n        return crypto\n          .createHash( 'md5' )\n          .update( buffer )\n          .digest( 'hex' );\n      },\n\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function ( file ) {\n        return this.getFileDescriptor( file ).changed;\n      },\n\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function ( files ) {\n        var me = this;\n        files = files || [ ];\n\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: []\n        };\n\n        me.normalizeEntries( files ).forEach( function ( entry ) {\n          if ( entry.changed ) {\n            res.changedFiles.push( entry.key );\n            return;\n          }\n          if ( entry.notFound ) {\n            res.notFoundFiles.push( entry.key );\n            return;\n          }\n          res.notChangedFiles.push( entry.key );\n        } );\n        return res;\n      },\n\n      getFileDescriptor: function ( file ) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync( file );\n        } catch (ex) {\n          this.removeEntry( file );\n          return { key: file, notFound: true, err: ex };\n        }\n\n        if ( useChecksum ) {\n          return this._getFileDescriptorUsingChecksum( file );\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize( file, fstat );\n      },\n\n      _getFileDescriptorUsingMtimeAndSize: function ( file, fstat ) {\n        var meta = cache.getKey( file );\n        var cacheExists = !!meta;\n\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if ( !meta ) {\n          meta = { size: cSize, mtime: cTime };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = normalizedEntries[ file ] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta\n        };\n\n        return nEntry;\n      },\n\n      _getFileDescriptorUsingChecksum: function ( file ) {\n        var meta = cache.getKey( file );\n        var cacheExists = !!meta;\n\n        var contentBuffer;\n        try {\n          contentBuffer = fs.readFileSync( file );\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash( contentBuffer );\n\n        if ( !meta ) {\n          meta = { hash: hash };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = normalizedEntries[ file ] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta\n        };\n\n        return nEntry;\n      },\n\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function ( files ) {\n        var me = this;\n        files = files || [ ];\n\n        return me.normalizeEntries( files ).filter( function ( entry ) {\n          return entry.changed;\n        } ).map( function ( entry ) {\n          return entry.key;\n        } );\n      },\n\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function ( files ) {\n        files = files || [ ];\n\n        var me = this;\n        var nEntries = files.map( function ( file ) {\n          return me.getFileDescriptor( file );\n        } );\n\n        //normalizeEntries = nEntries;\n        return nEntries;\n      },\n\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function ( entryName ) {\n        delete normalizedEntries[ entryName ];\n        cache.removeKey( entryName );\n      },\n\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = { };\n        cache.destroy();\n      },\n\n      _getMetaForFileUsingCheckSum: function ( cacheEntry ) {\n        var contentBuffer = fs.readFileSync( cacheEntry.key );\n        var hash = this.getHash( contentBuffer );\n        var meta = Object.assign( cacheEntry.meta, { hash: hash } );\n        return meta;\n      },\n\n      _getMetaForFileUsingMtimeAndSize: function ( cacheEntry ) {\n        var stat = fs.statSync( cacheEntry.key );\n        var meta = Object.assign( cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime()\n        } );\n        return meta;\n      },\n\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function ( noPrune ) {\n        removeNotFoundFiles();\n\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n\n        var entries = normalizedEntries;\n        var keys = Object.keys( entries );\n\n        if ( keys.length === 0 ) {\n          return;\n        }\n\n        var me = this;\n\n        keys.forEach( function ( entryName ) {\n          var cacheEntry = entries[ entryName ];\n\n          try {\n            var meta = useChecksum ? me._getMetaForFileUsingCheckSum( cacheEntry ) : me._getMetaForFileUsingMtimeAndSize( cacheEntry );\n            cache.setKey( entryName, meta );\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if ( err.code !== 'ENOENT' ) {\n              throw err;\n            }\n          }\n        } );\n\n        cache.save( noPrune );\n      }\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}