{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\n\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n  }\n\n  return {\n    functions,\n    classes,\n    variables\n  };\n}\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\n\n\nfunction isFunction(variable) {\n  return variable.defs[0].type === \"FunctionName\";\n}\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\n\n\nfunction isOuterClass(variable, reference) {\n  return variable.defs[0].type === \"ClassName\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\n\n\nfunction isOuterVariable(variable, reference) {\n  return variable.defs[0].type === \"Variable\" && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\n\n\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\n\n\nfunction isInInitializer(variable, reference) {\n  if (variable.scope !== reference.from) {\n    return false;\n  }\n\n  let node = variable.identifiers[0].parent;\n  const location = reference.identifier.range[1];\n\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of variables before they are defined\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0]);\n    /**\n     * Determines whether a given use-before-define case should be reported according to the options.\n     * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n     * @param {eslint-scope.Reference} reference The reference to the variable\n     * @returns {boolean} `true` if the usage should be reported\n     */\n\n    function isForbidden(variable, reference) {\n      if (isFunction(variable)) {\n        return options.functions;\n      }\n\n      if (isOuterClass(variable, reference)) {\n        return options.classes;\n      }\n\n      if (isOuterVariable(variable, reference)) {\n        return options.variables;\n      }\n\n      return true;\n    }\n    /**\n     * Finds and validates all variables in a given scope.\n     * @param {Scope} scope The scope object.\n     * @returns {void}\n     * @private\n     */\n\n\n    function findVariablesInScope(scope) {\n      scope.references.forEach(reference => {\n        const variable = reference.resolved;\n        /*\n         * Skips when the reference is:\n         * - initialization's.\n         * - referring to an undefined variable.\n         * - referring to a global environment variable (there're no identifiers).\n         * - located preceded by the variable (except in initializers).\n         * - allowed by options.\n         */\n\n        if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {\n          return;\n        } // Reports.\n\n\n        context.report({\n          node: reference.identifier,\n          message: \"'{{name}}' was used before it was defined.\",\n          data: reference.identifier\n        });\n      });\n      scope.childScopes.forEach(findVariablesInScope);\n    }\n\n    return {\n      Program() {\n        findVariablesInScope(context.getScope());\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-use-before-define.js"],"names":["SENTINEL_TYPE","FOR_IN_OF_TYPE","parseOptions","options","functions","classes","variables","isFunction","variable","defs","type","isOuterClass","reference","scope","variableScope","from","isOuterVariable","isInRange","node","location","range","isInInitializer","identifiers","parent","identifier","init","test","right","module","exports","meta","docs","description","category","recommended","url","schema","oneOf","enum","properties","additionalProperties","create","context","isForbidden","findVariablesInScope","references","forEach","resolved","length","report","message","data","childScopes","Program","getScope"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n         * @param {eslint-scope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                /*\n                 * Skips when the reference is:\n                 * - initialization's.\n                 * - referring to an undefined variable.\n                 * - referring to a global environment variable (there're no identifiers).\n                 * - located preceded by the variable (except in initializers).\n                 * - allowed by options.\n                 */\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    message: \"'{{name}}' was used before it was defined.\",\n                    data: reference.identifier\n                });\n            });\n\n            scope.childScopes.forEach(findVariablesInScope);\n        }\n\n        return {\n            Program() {\n                findVariablesInScope(context.getScope());\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}