{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst MODE_ALWAYS = \"always\",\n      MODE_AS_NEEDED = \"as-needed\";\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\n\nfunction isShadowed(variable) {\n  return variable.defs.length >= 1;\n}\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\n\n\nfunction isParseIntMethod(node) {\n  return node.type === \"MemberExpression\" && !node.computed && node.property.type === \"Identifier\" && node.property.name === \"parseInt\";\n}\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except numbers.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\n\n\nfunction isValidRadix(radix) {\n  return !(radix.type === \"Literal\" && typeof radix.value !== \"number\" || radix.type === \"Identifier\" && radix.name === \"undefined\");\n}\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\n\n\nfunction isDefaultRadix(radix) {\n  return radix.type === \"Literal\" && radix.value === 10;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/radix\"\n    },\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }]\n  },\n\n  create(context) {\n    const mode = context.options[0] || MODE_ALWAYS;\n    /**\n     * Checks the arguments of a given CallExpression node and reports it if it\n     * offends this rule.\n     * @param {ASTNode} node A CallExpression node to check.\n     * @returns {void}\n     */\n\n    function checkArguments(node) {\n      const args = node.arguments;\n\n      switch (args.length) {\n        case 0:\n          context.report({\n            node,\n            message: \"Missing parameters.\"\n          });\n          break;\n\n        case 1:\n          if (mode === MODE_ALWAYS) {\n            context.report({\n              node,\n              message: \"Missing radix parameter.\"\n            });\n          }\n\n          break;\n\n        default:\n          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n            context.report({\n              node,\n              message: \"Redundant radix parameter.\"\n            });\n          } else if (!isValidRadix(args[1])) {\n            context.report({\n              node,\n              message: \"Invalid radix parameter.\"\n            });\n          }\n\n          break;\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        let variable; // Check `parseInt()`\n\n        variable = astUtils.getVariableByName(scope, \"parseInt\");\n\n        if (!isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier;\n\n            if (astUtils.isCallee(node)) {\n              checkArguments(node.parent);\n            }\n          });\n        } // Check `Number.parseInt()`\n\n\n        variable = astUtils.getVariableByName(scope, \"Number\");\n\n        if (!isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier.parent;\n\n            if (isParseIntMethod(node) && astUtils.isCallee(node)) {\n              checkArguments(node.parent);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/radix.js"],"names":["astUtils","require","MODE_ALWAYS","MODE_AS_NEEDED","isShadowed","variable","defs","length","isParseIntMethod","node","type","computed","property","name","isValidRadix","radix","value","isDefaultRadix","module","exports","meta","docs","description","category","recommended","url","schema","enum","create","context","mode","options","checkArguments","args","arguments","report","message","scope","getScope","getVariableByName","references","forEach","reference","identifier","isCallee","parent"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except numbers.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && typeof radix.value !== \"number\") ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/radix\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        message: \"Missing parameters.\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            message: \"Missing radix parameter.\"\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Redundant radix parameter.\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Invalid radix parameter.\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}