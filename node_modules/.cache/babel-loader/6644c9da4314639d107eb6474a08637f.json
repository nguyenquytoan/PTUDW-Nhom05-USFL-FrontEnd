{"ast":null,"code":"/* global a2c */\n'use strict';\n\nvar rNumber = String.raw`[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*`,\n    rCommaWsp = String.raw`(?:\\s,?\\s*|,\\s*)`,\n    rNumberCommaWsp = `(${rNumber})` + rCommaWsp,\n    rFlagCommaWsp = `([01])${rCommaWsp}?`,\n    rCoordinatePair = String.raw`(${rNumber})${rCommaWsp}?(${rNumber})`,\n    rArcSeq = (rNumberCommaWsp + '?').repeat(2) + rNumberCommaWsp + rFlagCommaWsp.repeat(2) + rCoordinatePair;\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n    regCoordinateSequence = new RegExp(rNumber, 'g'),\n    regArcArgumentSequence = new RegExp(rArcSeq, 'g'),\n    regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n    transform2js = require('./_transforms').transform2js,\n    transformsMultiply = require('./_transforms').transformsMultiply,\n    transformArc = require('./_transforms').transformArc,\n    collections = require('./_collections.js'),\n    referencesProps = collections.referencesProps,\n    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n    prevCtrlPoint;\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\n\nexports.path2js = function (path) {\n  if (path.pathJS) return path.pathJS;\n  var paramsLength = {\n    // Number of parameters of every path command\n    H: 1,\n    V: 1,\n    M: 2,\n    L: 2,\n    T: 2,\n    Q: 4,\n    S: 4,\n    C: 6,\n    A: 7,\n    h: 1,\n    v: 1,\n    m: 2,\n    l: 2,\n    t: 2,\n    q: 4,\n    s: 4,\n    c: 6,\n    a: 7\n  },\n      pathData = [],\n      // JS representation of the path data\n  instruction,\n      // current instruction context\n  startMoveto = false; // splitting path string into array like ['M', '10 50', 'L', '20 30']\n\n  path.attr('d').value.split(regPathInstructions).forEach(function (data) {\n    if (!data) return;\n\n    if (!startMoveto) {\n      if (data == 'M' || data == 'm') {\n        startMoveto = true;\n      } else return;\n    } // instruction item\n\n\n    if (regPathInstructions.test(data)) {\n      instruction = data; // z - instruction w/o data\n\n      if (instruction == 'Z' || instruction == 'z') {\n        pathData.push({\n          instruction: 'z'\n        });\n      } // data item\n\n    } else {\n      /* jshint boss: true */\n      if (instruction == 'A' || instruction == 'a') {\n        var newData = [];\n\n        for (var args; args = regArcArgumentSequence.exec(data);) {\n          for (var i = 1; i < args.length; i++) {\n            newData.push(args[i]);\n          }\n        }\n\n        data = newData;\n      } else {\n        data = data.match(regCoordinateSequence);\n      }\n\n      if (!data) return;\n      data = data.map(Number); // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n      // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n\n      if (instruction == 'M' || instruction == 'm') {\n        pathData.push({\n          instruction: pathData.length == 0 ? 'M' : instruction,\n          data: data.splice(0, 2)\n        });\n        instruction = instruction == 'M' ? 'L' : 'l';\n      }\n\n      for (var pair = paramsLength[instruction]; data.length;) {\n        pathData.push({\n          instruction: instruction,\n          data: data.splice(0, pair)\n        });\n      }\n    }\n  }); // First moveto is actually absolute. Subsequent coordinates were separated above.\n\n  if (pathData.length && pathData[0].instruction == 'm') {\n    pathData[0].instruction = 'M';\n  }\n\n  path.pathJS = pathData;\n  return pathData;\n};\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\n\n\nvar relative2absolute = exports.relative2absolute = function (data) {\n  var currentPoint = [0, 0],\n      subpathPoint = [0, 0],\n      i;\n  return data.map(function (item) {\n    var instruction = item.instruction,\n        itemData = item.data && item.data.slice();\n\n    if (instruction == 'M') {\n      set(currentPoint, itemData);\n      set(subpathPoint, itemData);\n    } else if ('mlcsqt'.indexOf(instruction) > -1) {\n      for (i = 0; i < itemData.length; i++) {\n        itemData[i] += currentPoint[i % 2];\n      }\n\n      set(currentPoint, itemData);\n\n      if (instruction == 'm') {\n        set(subpathPoint, itemData);\n      }\n    } else if (instruction == 'a') {\n      itemData[5] += currentPoint[0];\n      itemData[6] += currentPoint[1];\n      set(currentPoint, itemData);\n    } else if (instruction == 'h') {\n      itemData[0] += currentPoint[0];\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'v') {\n      itemData[0] += currentPoint[1];\n      currentPoint[1] = itemData[0];\n    } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n      set(currentPoint, itemData);\n    } else if (instruction == 'H') {\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'V') {\n      currentPoint[1] = itemData[0];\n    } else if (instruction == 'z') {\n      set(currentPoint, subpathPoint);\n    }\n\n    return instruction == 'z' ? {\n      instruction: 'z'\n    } : {\n      instruction: instruction.toUpperCase(),\n      data: itemData\n    };\n  });\n};\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\n\n\nexports.applyTransforms = function (elem, path, params) {\n  // if there are no 'stroke' attr and references to other objects such as\n  // gradiends or clip-path which are also subjects to transform.\n  if (!elem.hasAttr('transform') || !elem.attr('transform').value || elem.someAttr(function (attr) {\n    return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n  })) return path;\n  var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n      stroke = elem.computedAttr('stroke'),\n      id = elem.computedAttr('id'),\n      transformPrecision = params.transformPrecision,\n      newPoint,\n      scale;\n\n  if (stroke && stroke != 'none') {\n    if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2])) return path; // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n\n    if (id) {\n      var idElem = elem,\n          hasStrokeWidth = false;\n\n      do {\n        if (idElem.hasAttr('stroke-width')) hasStrokeWidth = true;\n      } while (!idElem.hasAttr('id', id) && !hasStrokeWidth && (idElem = idElem.parentNode));\n\n      if (!hasStrokeWidth) return path;\n    }\n\n    scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n    if (scale !== 1) {\n      var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n      if (!elem.hasAttr('vector-effect') || elem.attr('vector-effect').value !== 'non-scaling-stroke') {\n        if (elem.hasAttr('stroke-width')) {\n          elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim().replace(regNumericValues, function (num) {\n            return removeLeadingZero(num * scale);\n          });\n        } else {\n          elem.addAttr({\n            name: 'stroke-width',\n            prefix: '',\n            local: 'stroke-width',\n            value: strokeWidth.replace(regNumericValues, function (num) {\n              return removeLeadingZero(num * scale);\n            })\n          });\n        }\n      }\n    }\n  } else if (id) {\n    // Stroke and stroke-width can be redefined with <use>\n    return path;\n  }\n\n  path.forEach(function (pathItem) {\n    if (pathItem.data) {\n      // h -> l\n      if (pathItem.instruction === 'h') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = 0; // v -> l\n      } else if (pathItem.instruction === 'v') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = pathItem.data[0];\n        pathItem.data[0] = 0;\n      } // if there is a translate() transform\n\n\n      if (pathItem.instruction === 'M' && (matrix.data[4] !== 0 || matrix.data[5] !== 0)) {\n        // then apply it only to the first absoluted M\n        newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n        set(pathItem.data, newPoint);\n        set(pathItem.coords, newPoint); // clear translate() data from transform matrix\n\n        matrix.data[4] = 0;\n        matrix.data[5] = 0;\n      } else {\n        if (pathItem.instruction == 'a') {\n          transformArc(pathItem.data, matrix.data); // reduce number of digits in rotation angle\n\n          if (Math.abs(pathItem.data[2]) > 80) {\n            var a = pathItem.data[0],\n                rotation = pathItem.data[2];\n            pathItem.data[0] = pathItem.data[1];\n            pathItem.data[1] = a;\n            pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n          }\n\n          newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n          pathItem.data[5] = newPoint[0];\n          pathItem.data[6] = newPoint[1];\n        } else {\n          for (var i = 0; i < pathItem.data.length; i += 2) {\n            newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n            pathItem.data[i] = newPoint[0];\n            pathItem.data[i + 1] = newPoint[1];\n          }\n        }\n\n        pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n        pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n      }\n    }\n  }); // remove transform attr\n\n  elem.removeAttr('transform');\n  return path;\n};\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\n\n\nfunction transformPoint(matrix, x, y) {\n  return [matrix[0] * x + matrix[2] * y + matrix[4], matrix[1] * x + matrix[3] * y + matrix[5]];\n}\n/**\n * Compute Cubic Bézie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\n\n\nexports.computeCubicBoundingBox = function (xa, ya, xb, yb, xc, yc, xd, yd) {\n  var minx = Number.POSITIVE_INFINITY,\n      miny = Number.POSITIVE_INFINITY,\n      maxx = Number.NEGATIVE_INFINITY,\n      maxy = Number.NEGATIVE_INFINITY,\n      ts,\n      t,\n      x,\n      y,\n      i; // X\n\n  if (xa < minx) {\n    minx = xa;\n  }\n\n  if (xa > maxx) {\n    maxx = xa;\n  }\n\n  if (xd < minx) {\n    minx = xd;\n  }\n\n  if (xd > maxx) {\n    maxx = xd;\n  }\n\n  ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n\n    if (t >= 0 && t <= 1) {\n      x = computeCubicBaseValue(t, xa, xb, xc, xd); // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (x < minx) {\n        minx = x;\n      }\n\n      if (x > maxx) {\n        maxx = x;\n      }\n    }\n  } // Y\n\n\n  if (ya < miny) {\n    miny = ya;\n  }\n\n  if (ya > maxy) {\n    maxy = ya;\n  }\n\n  if (yd < miny) {\n    miny = yd;\n  }\n\n  if (yd > maxy) {\n    maxy = yd;\n  }\n\n  ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n\n    if (t >= 0 && t <= 1) {\n      // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n      y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (y < miny) {\n        miny = y;\n      }\n\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n  }\n\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n}; // compute the value for the cubic bezier function at time=t\n\n\nfunction computeCubicBaseValue(t, a, b, c, d) {\n  var mt = 1 - t;\n  return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n} // compute the value for the first derivative of the cubic bezier function at time=t\n\n\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n  var result = [-1, -1],\n      tl = -a + 2 * b - c,\n      tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n      dn = -a + 3 * b - 3 * c + d;\n\n  if (dn !== 0) {\n    result[0] = (tl + tr) / dn;\n    result[1] = (tl - tr) / dn;\n  }\n\n  return result;\n}\n/**\n * Compute Quadratic Bézier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\n\n\nexports.computeQuadraticBoundingBox = function (xa, ya, xb, yb, xc, yc) {\n  var minx = Number.POSITIVE_INFINITY,\n      miny = Number.POSITIVE_INFINITY,\n      maxx = Number.NEGATIVE_INFINITY,\n      maxy = Number.NEGATIVE_INFINITY,\n      t,\n      x,\n      y; // X\n\n  if (xa < minx) {\n    minx = xa;\n  }\n\n  if (xa > maxx) {\n    maxx = xa;\n  }\n\n  if (xc < minx) {\n    minx = xc;\n  }\n\n  if (xc > maxx) {\n    maxx = xc;\n  }\n\n  t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n\n  if (t >= 0 && t <= 1) {\n    x = computeQuadraticBaseValue(t, xa, xb, xc); // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (x < minx) {\n      minx = x;\n    }\n\n    if (x > maxx) {\n      maxx = x;\n    }\n  } // Y\n\n\n  if (ya < miny) {\n    miny = ya;\n  }\n\n  if (ya > maxy) {\n    maxy = ya;\n  }\n\n  if (yc < miny) {\n    miny = yc;\n  }\n\n  if (yc > maxy) {\n    maxy = yc;\n  }\n\n  t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n\n  if (t >= 0 && t <= 1) {\n    // x = computeQuadraticBaseValue(t, xa, xb, xc);\n    y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (y < miny) {\n      miny = y;\n    }\n\n    if (y > maxy) {\n      maxy = y;\n    }\n  }\n\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n}; // compute the value for the quadratic bezier function at time=t\n\n\nfunction computeQuadraticBaseValue(t, a, b, c) {\n  var mt = 1 - t;\n  return mt * mt * a + 2 * mt * t * b + t * t * c;\n} // compute the value for the first derivative of the quadratic bezier function at time=t\n\n\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n  var t = -1,\n      denominator = a - 2 * b + c;\n\n  if (denominator !== 0) {\n    t = (a - b) / denominator;\n  }\n\n  return t;\n}\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\n\n\nexports.js2path = function (path, data, params) {\n  path.pathJS = data;\n\n  if (params.collapseRepeated) {\n    data = collapseRepeated(data);\n  }\n\n  path.attr('d').value = data.reduce(function (pathString, item) {\n    var strData = '';\n\n    if (item.data) {\n      strData = cleanupOutData(item.data, params, item.instruction);\n    }\n\n    return pathString += item.instruction + strData;\n  }, '');\n};\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\n\n\nfunction collapseRepeated(data) {\n  var prev, prevIndex; // copy an array and modifieds item to keep original data untouched\n\n  data = data.reduce(function (newPath, item) {\n    if (prev && item.data && item.instruction == prev.instruction) {\n      // concat previous data with current\n      if (item.instruction != 'M') {\n        prev = newPath[prevIndex] = {\n          instruction: prev.instruction,\n          data: prev.data.concat(item.data),\n          coords: item.coords,\n          base: prev.base\n        };\n      } else {\n        prev.data = item.data;\n        prev.coords = item.coords;\n      }\n    } else {\n      newPath.push(item);\n      prev = item;\n      prevIndex = newPath.length - 1;\n    }\n\n    return newPath;\n  }, []);\n  return data;\n}\n\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\n\n\nexports.intersects = function (path1, path2) {\n  if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n  // Collect points of every subpath.\n\n  var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n      points2 = relative2absolute(path2).reduce(gatherPoints, []); // Axis-aligned bounding box check.\n\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.every(function (set1) {\n    return points2.every(function (set2) {\n      return set1[set1.maxX][0] <= set2[set2.minX][0] || set2[set2.maxX][0] <= set1[set1.minX][0] || set1[set1.maxY][1] <= set2[set2.minY][1] || set2[set2.maxY][1] <= set1[set1.minY][1];\n    });\n  })) return false; // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n\n  var hullNest1 = points1.map(convexHull),\n      hullNest2 = points2.map(convexHull); // Check intersection of every subpath of the first path with every subpath of the second.\n\n  return hullNest1.some(function (hull1) {\n    if (hull1.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n          // create the initial simplex\n      direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n\n      while (true) {\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means “do nothing with paths”\n        } // add a new point\n\n\n        simplex.push(getSupport(hull1, hull2, direction)); // see if the new point was on the correct side of the origin\n\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false; // process the simplex\n\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  } // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n\n\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n        max = -Infinity,\n        value;\n\n    while ((value = dot(polygon[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.length;\n    }\n\n    return polygon[(index || polygon.length) - 1];\n  }\n};\n\nfunction processSimplex(simplex, direction) {\n  /* jshint -W004 */\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    var a = simplex[1],\n        b = simplex[0],\n        AO = minus(simplex[1]),\n        AB = sub(b, a); // AO is in the same direction as AB\n\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO); // only A remains in the simplex\n\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    var a = simplex[2],\n        // [a, b, c] = simplex\n    b = simplex[1],\n        c = simplex[0],\n        AB = sub(b, a),\n        AC = sub(c, a),\n        AO = minus(a),\n        ACB = orth(AB, AC),\n        // the vector perpendicular to AB facing away from C\n    ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else // region 7\n      return true;\n  }\n\n  return false;\n}\n\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\nfunction gatherPoints(points, item, index, path) {\n  var subPath = points.length && points[points.length - 1],\n      prev = index && path[index - 1],\n      basePoint = subPath.length && subPath[subPath.length - 1],\n      data = item.data,\n      ctrlPoint = basePoint;\n\n  switch (item.instruction) {\n    case 'M':\n      points.push(subPath = []);\n      break;\n\n    case 'H':\n      addPoint(subPath, [data[0], basePoint[1]]);\n      break;\n\n    case 'V':\n      addPoint(subPath, [basePoint[0], data[0]]);\n      break;\n\n    case 'Q':\n      addPoint(subPath, data.slice(0, 2));\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n\n      break;\n\n    case 'T':\n      if (prev.instruction == 'Q' || prev.instruction == 'T') {\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        addPoint(subPath, ctrlPoint);\n        prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n      }\n\n      break;\n\n    case 'C':\n      // Approximate quibic Bezier curve with middle points between control points\n      addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n      prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n\n      break;\n\n    case 'S':\n      if (prev.instruction == 'C' || prev.instruction == 'S') {\n        addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n      }\n\n      addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n      break;\n\n    case 'A':\n      // Convert the arc to bezier curves and use the same approximation\n      var curves = a2c.apply(0, basePoint.concat(data));\n\n      for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n        addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n        addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n        addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n        if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n      }\n\n      break;\n  } // Save final command coordinates\n\n\n  if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n  return points;\n\n  function toAbsolute(n, i) {\n    return n + basePoint[i % 2];\n  } // Writes data about the extreme points on each axle\n\n\n  function addPoint(path, point) {\n    if (!path.length || point[1] > path[path.maxY][1]) {\n      path.maxY = path.length;\n      points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n\n    if (!path.length || point[0] > path[path.maxX][0]) {\n      path.maxX = path.length;\n      points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n\n    if (!path.length || point[1] < path[path.minY][1]) {\n      path.minY = path.length;\n      points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n    }\n\n    if (!path.length || point[0] < path[path.minX][0]) {\n      path.minX = path.length;\n      points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n    }\n\n    path.push(point);\n  }\n}\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\n\n\nfunction convexHull(points) {\n  /* jshint -W004 */\n  points.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n      minY = 0,\n      bottom = 0;\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    if (points[i][1] < points[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n\n    lower.push(points[i]);\n  }\n\n  var upper = [],\n      maxY = points.length - 1,\n      top = 0;\n\n  for (var i = points.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    if (points[i][1] > points[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n\n    upper.push(points[i]);\n  } // last points are equal to starting points of the other part\n\n\n  upper.pop();\n  lower.pop();\n  var hull = lower.concat(upper);\n  hull.minX = 0; // by sorting\n\n  hull.maxX = lower.length;\n  hull.minY = bottom;\n  hull.maxY = (lower.length + top) % hull.length;\n  return hull;\n}\n\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n// jshint ignore: start\n\n\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  var _120 = Math.PI * 120 / 180,\n      rad = Math.PI / 180 * (+angle || 0),\n      res = [],\n      rotateX = function (x, y, rad) {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  },\n      rotateY = function (x, y, rad) {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n        y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx,\n        ry2 = ry * ry,\n        k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n        cx = k * rx * y / ry + (x1 + x2) / 2,\n        cy = k * -ry * x / rx + (y1 + y2) / 2,\n        f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n        f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n        x2old = x2,\n        y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n      s1 = Math.sin(f1),\n      c2 = Math.cos(f2),\n      s2 = Math.sin(f2),\n      t = Math.tan(df / 4),\n      hx = 4 / 3 * rx * t,\n      hy = 4 / 3 * ry * t,\n      m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n\n    return newres;\n  }\n} // jshint ignore: end","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/svgo/plugins/_path.js"],"names":["rNumber","String","raw","rCommaWsp","rNumberCommaWsp","rFlagCommaWsp","rCoordinatePair","rArcSeq","repeat","regPathInstructions","regCoordinateSequence","RegExp","regArcArgumentSequence","regNumericValues","transform2js","require","transformsMultiply","transformArc","collections","referencesProps","defaultStrokeWidth","attrsGroupsDefaults","presentation","cleanupOutData","removeLeadingZero","prevCtrlPoint","exports","path2js","path","pathJS","paramsLength","H","V","M","L","T","Q","S","C","A","h","v","m","l","t","q","s","c","a","pathData","instruction","startMoveto","attr","value","split","forEach","data","test","push","newData","args","exec","i","length","match","map","Number","splice","pair","relative2absolute","currentPoint","subpathPoint","item","itemData","slice","set","indexOf","toUpperCase","applyTransforms","elem","params","hasAttr","someAttr","name","matrix","stroke","computedAttr","id","transformPrecision","newPoint","scale","applyTransformsStroked","idElem","hasStrokeWidth","parentNode","Math","sqrt","toFixed","strokeWidth","attrs","trim","replace","num","addAttr","prefix","local","pathItem","transformPoint","coords","abs","rotation","base","removeAttr","x","y","computeCubicBoundingBox","xa","ya","xb","yb","xc","yc","xd","yd","minx","POSITIVE_INFINITY","miny","maxx","NEGATIVE_INFINITY","maxy","ts","computeCubicFirstDerivativeRoots","computeCubicBaseValue","b","d","mt","result","tl","tr","dn","computeQuadraticBoundingBox","computeQuadraticFirstDerivativeRoot","computeQuadraticBaseValue","denominator","js2path","collapseRepeated","reduce","pathString","strData","prev","prevIndex","newPath","concat","dest","source","intersects","path1","path2","points1","gatherPoints","points2","maxX","minX","maxY","minY","every","set1","set2","hullNest1","convexHull","hullNest2","some","hull1","hull2","simplex","getSupport","direction","minus","iterations","console","error","dot","processSimplex","sub","supportPoint","polygon","index","max","Infinity","AO","AB","orth","shift","AC","ACB","ABC","v1","v2","from","o","points","subPath","basePoint","ctrlPoint","addPoint","curves","a2c","apply","cData","toAbsolute","n","point","min","sort","lower","bottom","cross","pop","upper","top","hull","x1","y1","rx","ry","angle","large_arc_flag","sweep_flag","x2","y2","recursive","_120","PI","rad","res","rotateX","cos","sin","rotateY","rx2","ry2","k","cx","cy","f1","asin","f2","df","f2old","x2old","y2old","c1","s1","c2","s2","tan","hx","hy","newres"],"mappings":"AAAA;AACA;;AAEA,IAAIA,OAAO,GAAGC,MAAM,CAACC,GAAI,8CAAzB;AAAA,IACIC,SAAS,GAAGF,MAAM,CAACC,GAAI,kBAD3B;AAAA,IAEIE,eAAe,GAAI,IAAGJ,OAAQ,GAAZ,GAAiBG,SAFvC;AAAA,IAGIE,aAAa,GAAI,SAAQF,SAAU,GAHvC;AAAA,IAIIG,eAAe,GAAGL,MAAM,CAACC,GAAI,IAAGF,OAAQ,IAAGG,SAAU,KAAIH,OAAQ,GAJrE;AAAA,IAKIO,OAAO,GAAG,CAACH,eAAe,GAAG,GAAnB,EAAwBI,MAAxB,CAA+B,CAA/B,IAAoCJ,eAApC,GAAsDC,aAAa,CAACG,MAAd,CAAqB,CAArB,CAAtD,GAAgFF,eAL9F;;AAOA,IAAIG,mBAAmB,GAAG,6BAA1B;AAAA,IACIC,qBAAqB,GAAG,IAAIC,MAAJ,CAAWX,OAAX,EAAoB,GAApB,CAD5B;AAAA,IAEIY,sBAAsB,GAAG,IAAID,MAAJ,CAAWJ,OAAX,EAAoB,GAApB,CAF7B;AAAA,IAGIM,gBAAgB,GAAG,yCAHvB;AAAA,IAIIC,YAAY,GAAGC,OAAO,CAAC,eAAD,CAAP,CAAyBD,YAJ5C;AAAA,IAKIE,kBAAkB,GAAGD,OAAO,CAAC,eAAD,CAAP,CAAyBC,kBALlD;AAAA,IAMIC,YAAY,GAAGF,OAAO,CAAC,eAAD,CAAP,CAAyBE,YAN5C;AAAA,IAOIC,WAAW,GAAGH,OAAO,CAAC,mBAAD,CAPzB;AAAA,IAQII,eAAe,GAAGD,WAAW,CAACC,eARlC;AAAA,IASIC,kBAAkB,GAAGF,WAAW,CAACG,mBAAZ,CAAgCC,YAAhC,CAA6C,cAA7C,CATzB;AAAA,IAUIC,cAAc,GAAGR,OAAO,CAAC,mBAAD,CAAP,CAA6BQ,cAVlD;AAAA,IAWIC,iBAAiB,GAAGT,OAAO,CAAC,mBAAD,CAAP,CAA6BS,iBAXrD;AAAA,IAYIC,aAZJ;AAcA;;;;;;;;;AAOAC,OAAO,CAACC,OAAR,GAAkB,UAASC,IAAT,EAAe;AAC7B,MAAIA,IAAI,CAACC,MAAT,EAAiB,OAAOD,IAAI,CAACC,MAAZ;AAEjB,MAAIC,YAAY,GAAG;AAAE;AACbC,IAAAA,CAAC,EAAE,CADQ;AACLC,IAAAA,CAAC,EAAE,CADE;AACCC,IAAAA,CAAC,EAAE,CADJ;AACOC,IAAAA,CAAC,EAAE,CADV;AACaC,IAAAA,CAAC,EAAE,CADhB;AACmBC,IAAAA,CAAC,EAAE,CADtB;AACyBC,IAAAA,CAAC,EAAE,CAD5B;AAC+BC,IAAAA,CAAC,EAAE,CADlC;AACqCC,IAAAA,CAAC,EAAE,CADxC;AAEXC,IAAAA,CAAC,EAAE,CAFQ;AAELC,IAAAA,CAAC,EAAE,CAFE;AAECC,IAAAA,CAAC,EAAE,CAFJ;AAEOC,IAAAA,CAAC,EAAE,CAFV;AAEaC,IAAAA,CAAC,EAAE,CAFhB;AAEmBC,IAAAA,CAAC,EAAE,CAFtB;AAEyBC,IAAAA,CAAC,EAAE,CAF5B;AAE+BC,IAAAA,CAAC,EAAE,CAFlC;AAEqCC,IAAAA,CAAC,EAAE;AAFxC,GAAnB;AAAA,MAIIC,QAAQ,GAAG,EAJf;AAAA,MAIqB;AACjBC,EAAAA,WALJ;AAAA,MAKiB;AACbC,EAAAA,WAAW,GAAG,KANlB,CAH6B,CAW7B;;AACAvB,EAAAA,IAAI,CAACwB,IAAL,CAAU,GAAV,EAAeC,KAAf,CAAqBC,KAArB,CAA2B7C,mBAA3B,EAAgD8C,OAAhD,CAAwD,UAASC,IAAT,EAAe;AACnE,QAAI,CAACA,IAAL,EAAW;;AACX,QAAI,CAACL,WAAL,EAAkB;AACd,UAAIK,IAAI,IAAI,GAAR,IAAeA,IAAI,IAAI,GAA3B,EAAgC;AAC5BL,QAAAA,WAAW,GAAG,IAAd;AACH,OAFD,MAEO;AACV,KANkE,CAQnE;;;AACA,QAAI1C,mBAAmB,CAACgD,IAApB,CAAyBD,IAAzB,CAAJ,EAAoC;AAChCN,MAAAA,WAAW,GAAGM,IAAd,CADgC,CAGhC;;AACA,UAAIN,WAAW,IAAI,GAAf,IAAsBA,WAAW,IAAI,GAAzC,EAA8C;AAC1CD,QAAAA,QAAQ,CAACS,IAAT,CAAc;AACVR,UAAAA,WAAW,EAAE;AADH,SAAd;AAGH,OAR+B,CASpC;;AACC,KAVD,MAUO;AACH;AACA,UAAIA,WAAW,IAAI,GAAf,IAAsBA,WAAW,IAAI,GAAzC,EAA8C;AAC1C,YAAIS,OAAO,GAAG,EAAd;;AACA,aAAK,IAAIC,IAAT,EAAgBA,IAAI,GAAGhD,sBAAsB,CAACiD,IAAvB,CAA4BL,IAA5B,CAAvB,GAA4D;AACxD,eAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AAClCH,YAAAA,OAAO,CAACD,IAAR,CAAaE,IAAI,CAACE,CAAD,CAAjB;AACH;AACJ;;AACDN,QAAAA,IAAI,GAAGG,OAAP;AACH,OARD,MAQO;AACHH,QAAAA,IAAI,GAAGA,IAAI,CAACQ,KAAL,CAAWtD,qBAAX,CAAP;AACH;;AACD,UAAI,CAAC8C,IAAL,EAAW;AAEXA,MAAAA,IAAI,GAAGA,IAAI,CAACS,GAAL,CAASC,MAAT,CAAP,CAfG,CAgBH;AACA;;AACA,UAAIhB,WAAW,IAAI,GAAf,IAAsBA,WAAW,IAAI,GAAzC,EAA8C;AAC1CD,QAAAA,QAAQ,CAACS,IAAT,CAAc;AACVR,UAAAA,WAAW,EAAED,QAAQ,CAACc,MAAT,IAAmB,CAAnB,GAAuB,GAAvB,GAA6Bb,WADhC;AAEVM,UAAAA,IAAI,EAAEA,IAAI,CAACW,MAAL,CAAY,CAAZ,EAAe,CAAf;AAFI,SAAd;AAIAjB,QAAAA,WAAW,GAAGA,WAAW,IAAI,GAAf,GAAqB,GAArB,GAA2B,GAAzC;AACH;;AAED,WAAK,IAAIkB,IAAI,GAAGtC,YAAY,CAACoB,WAAD,CAA5B,EAA2CM,IAAI,CAACO,MAAhD,GAAyD;AACrDd,QAAAA,QAAQ,CAACS,IAAT,CAAc;AACVR,UAAAA,WAAW,EAAEA,WADH;AAEVM,UAAAA,IAAI,EAAEA,IAAI,CAACW,MAAL,CAAY,CAAZ,EAAeC,IAAf;AAFI,SAAd;AAIH;AACJ;AACJ,GApDD,EAZ6B,CAkE7B;;AACA,MAAInB,QAAQ,CAACc,MAAT,IAAmBd,QAAQ,CAAC,CAAD,CAAR,CAAYC,WAAZ,IAA2B,GAAlD,EAAuD;AACnDD,IAAAA,QAAQ,CAAC,CAAD,CAAR,CAAYC,WAAZ,GAA0B,GAA1B;AACH;;AACDtB,EAAAA,IAAI,CAACC,MAAL,GAAcoB,QAAd;AAEA,SAAOA,QAAP;AACH,CAzED;AA2EA;;;;;;;;AAMA,IAAIoB,iBAAiB,GAAG3C,OAAO,CAAC2C,iBAAR,GAA4B,UAASb,IAAT,EAAe;AAC/D,MAAIc,YAAY,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAnB;AAAA,MACIC,YAAY,GAAG,CAAC,CAAD,EAAI,CAAJ,CADnB;AAAA,MAEIT,CAFJ;AAIA,SAAON,IAAI,CAACS,GAAL,CAAS,UAASO,IAAT,EAAe;AAE3B,QAAItB,WAAW,GAAGsB,IAAI,CAACtB,WAAvB;AAAA,QACIuB,QAAQ,GAAGD,IAAI,CAAChB,IAAL,IAAagB,IAAI,CAAChB,IAAL,CAAUkB,KAAV,EAD5B;;AAGA,QAAIxB,WAAW,IAAI,GAAnB,EAAwB;AAEpByB,MAAAA,GAAG,CAACL,YAAD,EAAeG,QAAf,CAAH;AACAE,MAAAA,GAAG,CAACJ,YAAD,EAAeE,QAAf,CAAH;AAEH,KALD,MAKO,IAAI,SAASG,OAAT,CAAiB1B,WAAjB,IAAgC,CAAC,CAArC,EAAwC;AAE3C,WAAKY,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGW,QAAQ,CAACV,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AAClCW,QAAAA,QAAQ,CAACX,CAAD,CAAR,IAAeQ,YAAY,CAACR,CAAC,GAAG,CAAL,CAA3B;AACH;;AACDa,MAAAA,GAAG,CAACL,YAAD,EAAeG,QAAf,CAAH;;AAEA,UAAIvB,WAAW,IAAI,GAAnB,EAAwB;AACpByB,QAAAA,GAAG,CAACJ,YAAD,EAAeE,QAAf,CAAH;AACH;AAEJ,KAXM,MAWA,IAAIvB,WAAW,IAAI,GAAnB,EAAwB;AAE3BuB,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeH,YAAY,CAAC,CAAD,CAA3B;AACAG,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeH,YAAY,CAAC,CAAD,CAA3B;AACAK,MAAAA,GAAG,CAACL,YAAD,EAAeG,QAAf,CAAH;AAEH,KANM,MAMA,IAAIvB,WAAW,IAAI,GAAnB,EAAwB;AAE3BuB,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeH,YAAY,CAAC,CAAD,CAA3B;AACAA,MAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBG,QAAQ,CAAC,CAAD,CAA1B;AAEH,KALM,MAKA,IAAIvB,WAAW,IAAI,GAAnB,EAAwB;AAE3BuB,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeH,YAAY,CAAC,CAAD,CAA3B;AACAA,MAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBG,QAAQ,CAAC,CAAD,CAA1B;AAEH,KALM,MAKA,IAAI,WAAWG,OAAX,CAAmB1B,WAAnB,IAAkC,CAAC,CAAvC,EAA0C;AAE7CyB,MAAAA,GAAG,CAACL,YAAD,EAAeG,QAAf,CAAH;AAEH,KAJM,MAIA,IAAIvB,WAAW,IAAI,GAAnB,EAAwB;AAE3BoB,MAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBG,QAAQ,CAAC,CAAD,CAA1B;AAEH,KAJM,MAIA,IAAIvB,WAAW,IAAI,GAAnB,EAAwB;AAE3BoB,MAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBG,QAAQ,CAAC,CAAD,CAA1B;AAEH,KAJM,MAIA,IAAIvB,WAAW,IAAI,GAAnB,EAAwB;AAE3ByB,MAAAA,GAAG,CAACL,YAAD,EAAeC,YAAf,CAAH;AAEH;;AAED,WAAOrB,WAAW,IAAI,GAAf,GACH;AAAEA,MAAAA,WAAW,EAAE;AAAf,KADG,GAEH;AACIA,MAAAA,WAAW,EAAEA,WAAW,CAAC2B,WAAZ,EADjB;AAEIrB,MAAAA,IAAI,EAAEiB;AAFV,KAFJ;AAOH,GA9DM,CAAP;AA+DH,CApED;AAsEA;;;;;;;;;;AAQA/C,OAAO,CAACoD,eAAR,GAA0B,UAASC,IAAT,EAAenD,IAAf,EAAqBoD,MAArB,EAA6B;AACnD;AACA;AACA,MAAI,CAACD,IAAI,CAACE,OAAL,CAAa,WAAb,CAAD,IAA8B,CAACF,IAAI,CAAC3B,IAAL,CAAU,WAAV,EAAuBC,KAAtD,IACA0B,IAAI,CAACG,QAAL,CAAc,UAAS9B,IAAT,EAAe;AACzB,WAAO,CAACjC,eAAe,CAACyD,OAAhB,CAAwBxB,IAAI,CAAC+B,IAA7B,CAAD,IAAuC,CAAC/B,IAAI,CAACC,KAAL,CAAWuB,OAAX,CAAmB,MAAnB,CAA/C;AACH,GAFD,CADJ,EAII,OAAOhD,IAAP;AAEJ,MAAIwD,MAAM,GAAGpE,kBAAkB,CAACF,YAAY,CAACiE,IAAI,CAAC3B,IAAL,CAAU,WAAV,EAAuBC,KAAxB,CAAb,CAA/B;AAAA,MACIgC,MAAM,GAAGN,IAAI,CAACO,YAAL,CAAkB,QAAlB,CADb;AAAA,MAEIC,EAAE,GAAGR,IAAI,CAACO,YAAL,CAAkB,IAAlB,CAFT;AAAA,MAGIE,kBAAkB,GAAGR,MAAM,CAACQ,kBAHhC;AAAA,MAIIC,QAJJ;AAAA,MAIcC,KAJd;;AAMA,MAAIL,MAAM,IAAIA,MAAM,IAAI,MAAxB,EAAgC;AAC5B,QAAI,CAACL,MAAM,CAACW,sBAAR,IACA,CAACP,MAAM,CAAC5B,IAAP,CAAY,CAAZ,KAAkB4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,CAAlB,IAAoC4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,KAAkB,CAAC4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,CAAxD,MACC4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,KAAkB,CAAC4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,CAAnB,IAAqC4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,KAAkB4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,CADxD,CADJ,EAGI,OAAO5B,IAAP,CAJwB,CAM5B;;AACA,QAAI2D,EAAJ,EAAQ;AACJ,UAAIK,MAAM,GAAGb,IAAb;AAAA,UACIc,cAAc,GAAG,KADrB;;AAGA,SAAG;AACC,YAAID,MAAM,CAACX,OAAP,CAAe,cAAf,CAAJ,EAAoCY,cAAc,GAAG,IAAjB;AACvC,OAFD,QAES,CAACD,MAAM,CAACX,OAAP,CAAe,IAAf,EAAqBM,EAArB,CAAD,IAA6B,CAACM,cAA9B,KAAiDD,MAAM,GAAGA,MAAM,CAACE,UAAjE,CAFT;;AAIA,UAAI,CAACD,cAAL,EAAqB,OAAOjE,IAAP;AACxB;;AAED8D,IAAAA,KAAK,GAAG,CAACK,IAAI,CAACC,IAAL,CAAUZ,MAAM,CAAC5B,IAAP,CAAY,CAAZ,IAAiB4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,CAAjB,GAAkC4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,IAAiB4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,CAA7D,EAA6EyC,OAA7E,CAAqFT,kBAArF,CAAT;;AAEA,QAAIE,KAAK,KAAK,CAAd,EAAiB;AACb,UAAIQ,WAAW,GAAGnB,IAAI,CAACO,YAAL,CAAkB,cAAlB,KAAqClE,kBAAvD;;AAEA,UAAI,CAAC2D,IAAI,CAACE,OAAL,CAAa,eAAb,CAAD,IAAkCF,IAAI,CAAC3B,IAAL,CAAU,eAAV,EAA2BC,KAA3B,KAAqC,oBAA3E,EAAiG;AAC7F,YAAI0B,IAAI,CAACE,OAAL,CAAa,cAAb,CAAJ,EAAkC;AAC9BF,UAAAA,IAAI,CAACoB,KAAL,CAAW,cAAX,EAA2B9C,KAA3B,GAAmC0B,IAAI,CAACoB,KAAL,CAAW,cAAX,EAA2B9C,KAA3B,CAAiC+C,IAAjC,GAC9BC,OAD8B,CACtBxF,gBADsB,EACJ,UAASyF,GAAT,EAAc;AACrC,mBAAO9E,iBAAiB,CAAC8E,GAAG,GAAGZ,KAAP,CAAxB;AACH,WAH8B,CAAnC;AAIH,SALD,MAKO;AACHX,UAAAA,IAAI,CAACwB,OAAL,CAAa;AACTpB,YAAAA,IAAI,EAAE,cADG;AAETqB,YAAAA,MAAM,EAAE,EAFC;AAGTC,YAAAA,KAAK,EAAE,cAHE;AAITpD,YAAAA,KAAK,EAAE6C,WAAW,CAACG,OAAZ,CAAoBxF,gBAApB,EAAsC,UAASyF,GAAT,EAAc;AACvD,qBAAO9E,iBAAiB,CAAC8E,GAAG,GAAGZ,KAAP,CAAxB;AACH,aAFM;AAJE,WAAb;AAQH;AACJ;AACJ;AACJ,GAzCD,MAyCO,IAAIH,EAAJ,EAAQ;AAAE;AACb,WAAO3D,IAAP;AACH;;AAEDA,EAAAA,IAAI,CAAC2B,OAAL,CAAa,UAASmD,QAAT,EAAmB;AAE5B,QAAIA,QAAQ,CAAClD,IAAb,EAAmB;AAEf;AACA,UAAIkD,QAAQ,CAACxD,WAAT,KAAyB,GAA7B,EAAkC;AAE9BwD,QAAAA,QAAQ,CAACxD,WAAT,GAAuB,GAAvB;AACAwD,QAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmB,CAAnB,CAH8B,CAKlC;AACC,OAND,MAMO,IAAIkD,QAAQ,CAACxD,WAAT,KAAyB,GAA7B,EAAkC;AAErCwD,QAAAA,QAAQ,CAACxD,WAAT,GAAuB,GAAvB;AACAwD,QAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmBkD,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAnB;AACAkD,QAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmB,CAAnB;AAEH,OAfc,CAiBf;;;AACA,UAAIkD,QAAQ,CAACxD,WAAT,KAAyB,GAAzB,KACCkC,MAAM,CAAC5B,IAAP,CAAY,CAAZ,MAAmB,CAAnB,IACD4B,MAAM,CAAC5B,IAAP,CAAY,CAAZ,MAAmB,CAFnB,CAAJ,EAGE;AAEE;AACAiC,QAAAA,QAAQ,GAAGkB,cAAc,CAACvB,MAAM,CAAC5B,IAAR,EAAckD,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAd,EAAgCkD,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAhC,CAAzB;AACAmB,QAAAA,GAAG,CAAC+B,QAAQ,CAAClD,IAAV,EAAgBiC,QAAhB,CAAH;AACAd,QAAAA,GAAG,CAAC+B,QAAQ,CAACE,MAAV,EAAkBnB,QAAlB,CAAH,CALF,CAOE;;AACAL,QAAAA,MAAM,CAAC5B,IAAP,CAAY,CAAZ,IAAiB,CAAjB;AACA4B,QAAAA,MAAM,CAAC5B,IAAP,CAAY,CAAZ,IAAiB,CAAjB;AAEH,OAdD,MAcO;AAEH,YAAIkD,QAAQ,CAACxD,WAAT,IAAwB,GAA5B,EAAiC;AAE7BjC,UAAAA,YAAY,CAACyF,QAAQ,CAAClD,IAAV,EAAgB4B,MAAM,CAAC5B,IAAvB,CAAZ,CAF6B,CAI7B;;AACA,cAAIuC,IAAI,CAACc,GAAL,CAASH,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAT,IAA6B,EAAjC,EAAqC;AACjC,gBAAIR,CAAC,GAAG0D,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAR;AAAA,gBACIsD,QAAQ,GAAGJ,QAAQ,CAAClD,IAAT,CAAc,CAAd,CADf;AAEAkD,YAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmBkD,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAnB;AACAkD,YAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmBR,CAAnB;AACA0D,YAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmBsD,QAAQ,IAAIA,QAAQ,GAAG,CAAX,GAAe,CAAC,EAAhB,GAAqB,EAAzB,CAA3B;AACH;;AAEDrB,UAAAA,QAAQ,GAAGkB,cAAc,CAACvB,MAAM,CAAC5B,IAAR,EAAckD,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAd,EAAgCkD,QAAQ,CAAClD,IAAT,CAAc,CAAd,CAAhC,CAAzB;AACAkD,UAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmBiC,QAAQ,CAAC,CAAD,CAA3B;AACAiB,UAAAA,QAAQ,CAAClD,IAAT,CAAc,CAAd,IAAmBiC,QAAQ,CAAC,CAAD,CAA3B;AAEH,SAjBD,MAiBO;AAEH,eAAK,IAAI3B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4C,QAAQ,CAAClD,IAAT,CAAcO,MAAlC,EAA0CD,CAAC,IAAI,CAA/C,EAAkD;AAC9C2B,YAAAA,QAAQ,GAAGkB,cAAc,CAACvB,MAAM,CAAC5B,IAAR,EAAckD,QAAQ,CAAClD,IAAT,CAAcM,CAAd,CAAd,EAAgC4C,QAAQ,CAAClD,IAAT,CAAcM,CAAC,GAAG,CAAlB,CAAhC,CAAzB;AACA4C,YAAAA,QAAQ,CAAClD,IAAT,CAAcM,CAAd,IAAmB2B,QAAQ,CAAC,CAAD,CAA3B;AACAiB,YAAAA,QAAQ,CAAClD,IAAT,CAAcM,CAAC,GAAG,CAAlB,IAAuB2B,QAAQ,CAAC,CAAD,CAA/B;AACH;AACJ;;AAEDiB,QAAAA,QAAQ,CAACE,MAAT,CAAgB,CAAhB,IAAqBF,QAAQ,CAACK,IAAT,CAAc,CAAd,IAAmBL,QAAQ,CAAClD,IAAT,CAAckD,QAAQ,CAAClD,IAAT,CAAcO,MAAd,GAAuB,CAArC,CAAxC;AACA2C,QAAAA,QAAQ,CAACE,MAAT,CAAgB,CAAhB,IAAqBF,QAAQ,CAACK,IAAT,CAAc,CAAd,IAAmBL,QAAQ,CAAClD,IAAT,CAAckD,QAAQ,CAAClD,IAAT,CAAcO,MAAd,GAAuB,CAArC,CAAxC;AAEH;AAEJ;AAEJ,GArED,EA5DmD,CAmInD;;AACAgB,EAAAA,IAAI,CAACiC,UAAL,CAAgB,WAAhB;AAEA,SAAOpF,IAAP;AACH,CAvID;AAyIA;;;;;;;;;AAOA,SAAS+E,cAAT,CAAwBvB,MAAxB,EAAgC6B,CAAhC,EAAmCC,CAAnC,EAAsC;AAElC,SAAO,CACH9B,MAAM,CAAC,CAAD,CAAN,GAAY6B,CAAZ,GAAgB7B,MAAM,CAAC,CAAD,CAAN,GAAY8B,CAA5B,GAAgC9B,MAAM,CAAC,CAAD,CADnC,EAEHA,MAAM,CAAC,CAAD,CAAN,GAAY6B,CAAZ,GAAgB7B,MAAM,CAAC,CAAD,CAAN,GAAY8B,CAA5B,GAAgC9B,MAAM,CAAC,CAAD,CAFnC,CAAP;AAKH;AAED;;;;;;;;;;;;;;;;;;AAgBA1D,OAAO,CAACyF,uBAAR,GAAkC,UAASC,EAAT,EAAaC,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiCC,EAAjC,EAAqCC,EAArC,EAAyC;AAEvE,MAAIC,IAAI,GAAG1D,MAAM,CAAC2D,iBAAlB;AAAA,MACIC,IAAI,GAAG5D,MAAM,CAAC2D,iBADlB;AAAA,MAEIE,IAAI,GAAG7D,MAAM,CAAC8D,iBAFlB;AAAA,MAGIC,IAAI,GAAG/D,MAAM,CAAC8D,iBAHlB;AAAA,MAIIE,EAJJ;AAAA,MAKItF,CALJ;AAAA,MAMIqE,CANJ;AAAA,MAOIC,CAPJ;AAAA,MAQIpD,CARJ,CAFuE,CAYvE;;AACA,MAAIsD,EAAE,GAAGQ,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGR,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGW,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGX,EAAP;AAAY;;AAC7B,MAAIM,EAAE,GAAGE,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAEF,EAAN;AAAW;;AAC5B,MAAIA,EAAE,GAAGK,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGL,EAAP;AAAY;;AAE7BQ,EAAAA,EAAE,GAAGC,gCAAgC,CAACf,EAAD,EAAKE,EAAL,EAASE,EAAT,EAAaE,EAAb,CAArC;;AAEA,OAAK5D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGoE,EAAE,CAACnE,MAAnB,EAA2BD,CAAC,EAA5B,EAAgC;AAE5BlB,IAAAA,CAAC,GAAGsF,EAAE,CAACpE,CAAD,CAAN;;AAEA,QAAIlB,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAI,CAAnB,EAAsB;AAClBqE,MAAAA,CAAC,GAAGmB,qBAAqB,CAACxF,CAAD,EAAIwE,EAAJ,EAAQE,EAAR,EAAYE,EAAZ,EAAgBE,EAAhB,CAAzB,CADkB,CAElB;;AAEA,UAAIT,CAAC,GAAGW,IAAR,EAAc;AAAEA,QAAAA,IAAI,GAAGX,CAAP;AAAW;;AAC3B,UAAIA,CAAC,GAAGc,IAAR,EAAc;AAAEA,QAAAA,IAAI,GAAGd,CAAP;AAAW;AAC9B;AAEJ,GAhCsE,CAkCvE;;;AACA,MAAII,EAAE,GAAGS,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGT,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGY,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGZ,EAAP;AAAY;;AAC7B,MAAIM,EAAE,GAAGG,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGH,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGM,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGN,EAAP;AAAY;;AAE7BO,EAAAA,EAAE,GAAGC,gCAAgC,CAACd,EAAD,EAAKE,EAAL,EAASE,EAAT,EAAaE,EAAb,CAArC;;AAEA,OAAK7D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGoE,EAAE,CAACnE,MAAnB,EAA2BD,CAAC,EAA5B,EAAgC;AAE5BlB,IAAAA,CAAC,GAAGsF,EAAE,CAACpE,CAAD,CAAN;;AAEA,QAAIlB,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAI,CAAnB,EAAsB;AAClB;AACAsE,MAAAA,CAAC,GAAGkB,qBAAqB,CAACxF,CAAD,EAAIyE,EAAJ,EAAQE,EAAR,EAAYE,EAAZ,EAAgBE,EAAhB,CAAzB;;AAEA,UAAIT,CAAC,GAAGY,IAAR,EAAc;AAAEA,QAAAA,IAAI,GAAGZ,CAAP;AAAW;;AAC3B,UAAIA,CAAC,GAAGe,IAAR,EAAc;AAAEA,QAAAA,IAAI,GAAGf,CAAP;AAAW;AAC9B;AAEJ;;AAED,SAAO;AACHU,IAAAA,IAAI,EAAEA,IADH;AAEHE,IAAAA,IAAI,EAAEA,IAFH;AAGHC,IAAAA,IAAI,EAAEA,IAHH;AAIHE,IAAAA,IAAI,EAAEA;AAJH,GAAP;AAOH,CA/DD,C,CAiEA;;;AACA,SAASG,qBAAT,CAA+BxF,CAA/B,EAAkCI,CAAlC,EAAqCqF,CAArC,EAAwCtF,CAAxC,EAA2CuF,CAA3C,EAA8C;AAE1C,MAAIC,EAAE,GAAG,IAAI3F,CAAb;AAEA,SAAO2F,EAAE,GAAGA,EAAL,GAAUA,EAAV,GAAevF,CAAf,GAAmB,IAAIuF,EAAJ,GAASA,EAAT,GAAc3F,CAAd,GAAkByF,CAArC,GAAyC,IAAIE,EAAJ,GAAS3F,CAAT,GAAaA,CAAb,GAAiBG,CAA1D,GAA8DH,CAAC,GAAGA,CAAJ,GAAQA,CAAR,GAAY0F,CAAjF;AAEH,C,CAED;;;AACA,SAASH,gCAAT,CAA0CnF,CAA1C,EAA6CqF,CAA7C,EAAgDtF,CAAhD,EAAmDuF,CAAnD,EAAsD;AAElD,MAAIE,MAAM,GAAG,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAb;AAAA,MACIC,EAAE,GAAG,CAACzF,CAAD,GAAK,IAAIqF,CAAT,GAAatF,CADtB;AAAA,MAEI2F,EAAE,GAAG,CAAC3C,IAAI,CAACC,IAAL,CAAU,CAAChD,CAAD,IAAMD,CAAC,GAAGuF,CAAV,IAAeD,CAAC,GAAGA,CAAnB,GAAuBA,CAAC,IAAItF,CAAC,GAAGuF,CAAR,CAAxB,GAAqCvF,CAAC,GAAGA,CAAnD,CAFV;AAAA,MAGI4F,EAAE,GAAG,CAAC3F,CAAD,GAAK,IAAIqF,CAAT,GAAa,IAAItF,CAAjB,GAAqBuF,CAH9B;;AAKA,MAAIK,EAAE,KAAK,CAAX,EAAc;AACVH,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACC,EAAE,GAAGC,EAAN,IAAYC,EAAxB;AACAH,IAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAACC,EAAE,GAAGC,EAAN,IAAYC,EAAxB;AACH;;AAED,SAAOH,MAAP;AAEH;AAED;;;;;;;;;;;;;;;;AAcA9G,OAAO,CAACkH,2BAAR,GAAsC,UAASxB,EAAT,EAAaC,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6BC,EAA7B,EAAiC;AAEnE,MAAIG,IAAI,GAAG1D,MAAM,CAAC2D,iBAAlB;AAAA,MACIC,IAAI,GAAG5D,MAAM,CAAC2D,iBADlB;AAAA,MAEIE,IAAI,GAAG7D,MAAM,CAAC8D,iBAFlB;AAAA,MAGIC,IAAI,GAAG/D,MAAM,CAAC8D,iBAHlB;AAAA,MAIIpF,CAJJ;AAAA,MAKIqE,CALJ;AAAA,MAMIC,CANJ,CAFmE,CAUnE;;AACA,MAAIE,EAAE,GAAGQ,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGR,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGW,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGX,EAAP;AAAY;;AAC7B,MAAII,EAAE,GAAGI,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGJ,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGO,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGP,EAAP;AAAY;;AAE7B5E,EAAAA,CAAC,GAAGiG,mCAAmC,CAACzB,EAAD,EAAKE,EAAL,EAASE,EAAT,CAAvC;;AAEA,MAAI5E,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAI,CAAnB,EAAsB;AAClBqE,IAAAA,CAAC,GAAG6B,yBAAyB,CAAClG,CAAD,EAAIwE,EAAJ,EAAQE,EAAR,EAAYE,EAAZ,CAA7B,CADkB,CAElB;;AAEA,QAAIP,CAAC,GAAGW,IAAR,EAAc;AAAEA,MAAAA,IAAI,GAAGX,CAAP;AAAW;;AAC3B,QAAIA,CAAC,GAAGc,IAAR,EAAc;AAAEA,MAAAA,IAAI,GAAGd,CAAP;AAAW;AAC9B,GAxBkE,CA0BnE;;;AACA,MAAII,EAAE,GAAGS,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGT,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGY,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGZ,EAAP;AAAY;;AAC7B,MAAII,EAAE,GAAGK,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGL,EAAP;AAAY;;AAC7B,MAAIA,EAAE,GAAGQ,IAAT,EAAe;AAAEA,IAAAA,IAAI,GAAGR,EAAP;AAAY;;AAE7B7E,EAAAA,CAAC,GAAGiG,mCAAmC,CAACxB,EAAD,EAAKE,EAAL,EAASE,EAAT,CAAvC;;AAEA,MAAI7E,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAG,CAAlB,EAAsB;AAClB;AACAsE,IAAAA,CAAC,GAAG4B,yBAAyB,CAAClG,CAAD,EAAIyE,EAAJ,EAAQE,EAAR,EAAYE,EAAZ,CAA7B;;AAEA,QAAIP,CAAC,GAAGY,IAAR,EAAc;AAAEA,MAAAA,IAAI,GAAGZ,CAAP;AAAW;;AAC3B,QAAIA,CAAC,GAAGe,IAAR,EAAc;AAAEA,MAAAA,IAAI,GAAGf,CAAP;AAAY;AAE/B;;AAED,SAAO;AACHU,IAAAA,IAAI,EAAEA,IADH;AAEHE,IAAAA,IAAI,EAAEA,IAFH;AAGHC,IAAAA,IAAI,EAAEA,IAHH;AAIHE,IAAAA,IAAI,EAAEA;AAJH,GAAP;AAOH,CAlDD,C,CAoDA;;;AACA,SAASa,yBAAT,CAAmClG,CAAnC,EAAsCI,CAAtC,EAAyCqF,CAAzC,EAA4CtF,CAA5C,EAA+C;AAE3C,MAAIwF,EAAE,GAAG,IAAI3F,CAAb;AAEA,SAAO2F,EAAE,GAAGA,EAAL,GAAUvF,CAAV,GAAc,IAAIuF,EAAJ,GAAS3F,CAAT,GAAayF,CAA3B,GAA+BzF,CAAC,GAAGA,CAAJ,GAAQG,CAA9C;AAEH,C,CAED;;;AACA,SAAS8F,mCAAT,CAA6C7F,CAA7C,EAAgDqF,CAAhD,EAAmDtF,CAAnD,EAAsD;AAElD,MAAIH,CAAC,GAAG,CAAC,CAAT;AAAA,MACImG,WAAW,GAAG/F,CAAC,GAAG,IAAIqF,CAAR,GAAYtF,CAD9B;;AAGA,MAAIgG,WAAW,KAAK,CAApB,EAAuB;AACnBnG,IAAAA,CAAC,GAAG,CAACI,CAAC,GAAGqF,CAAL,IAAUU,WAAd;AACH;;AAED,SAAOnG,CAAP;AAEH;AAED;;;;;;;;;AAOAlB,OAAO,CAACsH,OAAR,GAAkB,UAASpH,IAAT,EAAe4B,IAAf,EAAqBwB,MAArB,EAA6B;AAE3CpD,EAAAA,IAAI,CAACC,MAAL,GAAc2B,IAAd;;AAEA,MAAIwB,MAAM,CAACiE,gBAAX,EAA6B;AACzBzF,IAAAA,IAAI,GAAGyF,gBAAgB,CAACzF,IAAD,CAAvB;AACH;;AAED5B,EAAAA,IAAI,CAACwB,IAAL,CAAU,GAAV,EAAeC,KAAf,GAAuBG,IAAI,CAAC0F,MAAL,CAAY,UAASC,UAAT,EAAqB3E,IAArB,EAA2B;AAC1D,QAAI4E,OAAO,GAAG,EAAd;;AACA,QAAI5E,IAAI,CAAChB,IAAT,EAAe;AACX4F,MAAAA,OAAO,GAAG7H,cAAc,CAACiD,IAAI,CAAChB,IAAN,EAAYwB,MAAZ,EAAoBR,IAAI,CAACtB,WAAzB,CAAxB;AACH;;AACD,WAAOiG,UAAU,IAAI3E,IAAI,CAACtB,WAAL,GAAmBkG,OAAxC;AACH,GANsB,EAMpB,EANoB,CAAvB;AAQH,CAhBD;AAkBA;;;;;;;;AAMA,SAASH,gBAAT,CAA0BzF,IAA1B,EAAgC;AAE5B,MAAI6F,IAAJ,EACIC,SADJ,CAF4B,CAK5B;;AACA9F,EAAAA,IAAI,GAAGA,IAAI,CAAC0F,MAAL,CAAY,UAASK,OAAT,EAAkB/E,IAAlB,EAAwB;AACvC,QACI6E,IAAI,IAAI7E,IAAI,CAAChB,IAAb,IACAgB,IAAI,CAACtB,WAAL,IAAoBmG,IAAI,CAACnG,WAF7B,EAGE;AACE;AACA,UAAIsB,IAAI,CAACtB,WAAL,IAAoB,GAAxB,EAA6B;AACzBmG,QAAAA,IAAI,GAAGE,OAAO,CAACD,SAAD,CAAP,GAAqB;AACxBpG,UAAAA,WAAW,EAAEmG,IAAI,CAACnG,WADM;AAExBM,UAAAA,IAAI,EAAE6F,IAAI,CAAC7F,IAAL,CAAUgG,MAAV,CAAiBhF,IAAI,CAAChB,IAAtB,CAFkB;AAGxBoD,UAAAA,MAAM,EAAEpC,IAAI,CAACoC,MAHW;AAIxBG,UAAAA,IAAI,EAAEsC,IAAI,CAACtC;AAJa,SAA5B;AAMH,OAPD,MAOO;AACHsC,QAAAA,IAAI,CAAC7F,IAAL,GAAYgB,IAAI,CAAChB,IAAjB;AACA6F,QAAAA,IAAI,CAACzC,MAAL,GAAcpC,IAAI,CAACoC,MAAnB;AACH;AACJ,KAhBD,MAgBO;AACH2C,MAAAA,OAAO,CAAC7F,IAAR,CAAac,IAAb;AACA6E,MAAAA,IAAI,GAAG7E,IAAP;AACA8E,MAAAA,SAAS,GAAGC,OAAO,CAACxF,MAAR,GAAiB,CAA7B;AACH;;AAED,WAAOwF,OAAP;AACH,GAxBM,EAwBJ,EAxBI,CAAP;AA0BA,SAAO/F,IAAP;AAEH;;AAED,SAASmB,GAAT,CAAa8E,IAAb,EAAmBC,MAAnB,EAA2B;AACvBD,EAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUC,MAAM,CAACA,MAAM,CAAC3F,MAAP,GAAgB,CAAjB,CAAhB;AACA0F,EAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUC,MAAM,CAACA,MAAM,CAAC3F,MAAP,GAAgB,CAAjB,CAAhB;AACA,SAAO0F,IAAP;AACH;AAED;;;;;;;;;;;AASA/H,OAAO,CAACiI,UAAR,GAAqB,UAASC,KAAT,EAAgBC,KAAhB,EAAuB;AACxC,MAAID,KAAK,CAAC7F,MAAN,GAAe,CAAf,IAAoB8F,KAAK,CAAC9F,MAAN,GAAe,CAAvC,EAA0C,OAAO,KAAP,CADF,CACgB;AAExD;;AACA,MAAI+F,OAAO,GAAGzF,iBAAiB,CAACuF,KAAD,CAAjB,CAAyBV,MAAzB,CAAgCa,YAAhC,EAA8C,EAA9C,CAAd;AAAA,MACIC,OAAO,GAAG3F,iBAAiB,CAACwF,KAAD,CAAjB,CAAyBX,MAAzB,CAAgCa,YAAhC,EAA8C,EAA9C,CADd,CAJwC,CAOxC;;AACA,MAAID,OAAO,CAACG,IAAR,IAAgBD,OAAO,CAACE,IAAxB,IAAgCF,OAAO,CAACC,IAAR,IAAgBH,OAAO,CAACI,IAAxD,IACAJ,OAAO,CAACK,IAAR,IAAgBH,OAAO,CAACI,IADxB,IACgCJ,OAAO,CAACG,IAAR,IAAgBL,OAAO,CAACM,IADxD,IAEAN,OAAO,CAACO,KAAR,CAAc,UAAUC,IAAV,EAAgB;AAC1B,WAAON,OAAO,CAACK,KAAR,CAAc,UAAUE,IAAV,EAAgB;AACjC,aAAOD,IAAI,CAACA,IAAI,CAACL,IAAN,CAAJ,CAAgB,CAAhB,KAAsBM,IAAI,CAACA,IAAI,CAACL,IAAN,CAAJ,CAAgB,CAAhB,CAAtB,IACHK,IAAI,CAACA,IAAI,CAACN,IAAN,CAAJ,CAAgB,CAAhB,KAAsBK,IAAI,CAACA,IAAI,CAACJ,IAAN,CAAJ,CAAgB,CAAhB,CADnB,IAEHI,IAAI,CAACA,IAAI,CAACH,IAAN,CAAJ,CAAgB,CAAhB,KAAsBI,IAAI,CAACA,IAAI,CAACH,IAAN,CAAJ,CAAgB,CAAhB,CAFnB,IAGHG,IAAI,CAACA,IAAI,CAACJ,IAAN,CAAJ,CAAgB,CAAhB,KAAsBG,IAAI,CAACA,IAAI,CAACF,IAAN,CAAJ,CAAgB,CAAhB,CAH1B;AAIH,KALM,CAAP;AAMH,GAPD,CAFJ,EAUE,OAAO,KAAP,CAlBsC,CAoBxC;;AACA,MAAII,SAAS,GAAGV,OAAO,CAAC7F,GAAR,CAAYwG,UAAZ,CAAhB;AAAA,MACIC,SAAS,GAAGV,OAAO,CAAC/F,GAAR,CAAYwG,UAAZ,CADhB,CArBwC,CAwBxC;;AACA,SAAOD,SAAS,CAACG,IAAV,CAAe,UAASC,KAAT,EAAgB;AAClC,QAAIA,KAAK,CAAC7G,MAAN,GAAe,CAAnB,EAAsB,OAAO,KAAP;AAEtB,WAAO2G,SAAS,CAACC,IAAV,CAAe,UAASE,KAAT,EAAgB;AAClC,UAAIA,KAAK,CAAC9G,MAAN,GAAe,CAAnB,EAAsB,OAAO,KAAP;AAEtB,UAAI+G,OAAO,GAAG,CAACC,UAAU,CAACH,KAAD,EAAQC,KAAR,EAAe,CAAC,CAAD,EAAI,CAAJ,CAAf,CAAX,CAAd;AAAA,UAAkD;AAC9CG,MAAAA,SAAS,GAAGC,KAAK,CAACH,OAAO,CAAC,CAAD,CAAR,CADrB,CAHkC,CAIC;;AAEnC,UAAII,UAAU,GAAG,GAAjB,CANkC,CAMZ;;AACtB,aAAO,IAAP,EAAa;AACT,YAAIA,UAAU,MAAM,CAApB,EAAuB;AACnBC,UAAAA,OAAO,CAACC,KAAR,CAAc,0DAAd;AACA,iBAAO,IAAP,CAFmB,CAEN;AAChB,SAJQ,CAKT;;;AACAN,QAAAA,OAAO,CAACpH,IAAR,CAAaqH,UAAU,CAACH,KAAD,EAAQC,KAAR,EAAeG,SAAf,CAAvB,EANS,CAOT;;AACA,YAAIK,GAAG,CAACL,SAAD,EAAYF,OAAO,CAACA,OAAO,CAAC/G,MAAR,GAAiB,CAAlB,CAAnB,CAAH,IAA+C,CAAnD,EAAsD,OAAO,KAAP,CAR7C,CAST;;AACA,YAAIuH,cAAc,CAACR,OAAD,EAAUE,SAAV,CAAlB,EAAwC,OAAO,IAAP;AAC3C;AACJ,KAnBM,CAAP;AAoBH,GAvBM,CAAP;;AAyBA,WAASD,UAAT,CAAoB/H,CAApB,EAAuBqF,CAAvB,EAA0B2C,SAA1B,EAAqC;AACjC,WAAOO,GAAG,CAACC,YAAY,CAACxI,CAAD,EAAIgI,SAAJ,CAAb,EAA6BQ,YAAY,CAACnD,CAAD,EAAI4C,KAAK,CAACD,SAAD,CAAT,CAAzC,CAAV;AACH,GApDuC,CAsDxC;AACA;AACA;;;AACA,WAASQ,YAAT,CAAsBC,OAAtB,EAA+BT,SAA/B,EAA0C;AACtC,QAAIU,KAAK,GAAGV,SAAS,CAAC,CAAD,CAAT,IAAgB,CAAhB,GACJA,SAAS,CAAC,CAAD,CAAT,GAAe,CAAf,GAAmBS,OAAO,CAACtB,IAA3B,GAAkCsB,OAAO,CAACxB,IADtC,GAEJe,SAAS,CAAC,CAAD,CAAT,GAAe,CAAf,GAAmBS,OAAO,CAACvB,IAA3B,GAAkCuB,OAAO,CAACrB,IAFlD;AAAA,QAGIuB,GAAG,GAAG,CAACC,QAHX;AAAA,QAIIvI,KAJJ;;AAKA,WAAO,CAACA,KAAK,GAAGgI,GAAG,CAACI,OAAO,CAACC,KAAD,CAAR,EAAiBV,SAAjB,CAAZ,IAA2CW,GAAlD,EAAuD;AACnDA,MAAAA,GAAG,GAAGtI,KAAN;AACAqI,MAAAA,KAAK,GAAG,EAAEA,KAAF,GAAUD,OAAO,CAAC1H,MAA1B;AACH;;AACD,WAAO0H,OAAO,CAAC,CAACC,KAAK,IAAID,OAAO,CAAC1H,MAAlB,IAA4B,CAA7B,CAAd;AACH;AACJ,CArED;;AAuEA,SAASuH,cAAT,CAAwBR,OAAxB,EAAiCE,SAAjC,EAA4C;AACxC;AAEA;AACA,MAAIF,OAAO,CAAC/G,MAAR,IAAkB,CAAtB,EAAyB;AAAE;AACvB,QAAIf,CAAC,GAAG8H,OAAO,CAAC,CAAD,CAAf;AAAA,QACIzC,CAAC,GAAGyC,OAAO,CAAC,CAAD,CADf;AAAA,QAEIe,EAAE,GAAGZ,KAAK,CAACH,OAAO,CAAC,CAAD,CAAR,CAFd;AAAA,QAGIgB,EAAE,GAAGP,GAAG,CAAClD,CAAD,EAAIrF,CAAJ,CAHZ,CADqB,CAKrB;;AACA,QAAIqI,GAAG,CAACQ,EAAD,EAAKC,EAAL,CAAH,GAAc,CAAlB,EAAqB;AACjB;AACAnH,MAAAA,GAAG,CAACqG,SAAD,EAAYe,IAAI,CAACD,EAAD,EAAK9I,CAAL,CAAhB,CAAH;AACH,KAHD,MAGO;AACH2B,MAAAA,GAAG,CAACqG,SAAD,EAAYa,EAAZ,CAAH,CADG,CAEH;;AACAf,MAAAA,OAAO,CAACkB,KAAR;AACH;AACJ,GAdD,MAcO;AAAE;AACL,QAAIhJ,CAAC,GAAG8H,OAAO,CAAC,CAAD,CAAf;AAAA,QAAoB;AAChBzC,IAAAA,CAAC,GAAGyC,OAAO,CAAC,CAAD,CADf;AAAA,QAEI/H,CAAC,GAAG+H,OAAO,CAAC,CAAD,CAFf;AAAA,QAGIgB,EAAE,GAAGP,GAAG,CAAClD,CAAD,EAAIrF,CAAJ,CAHZ;AAAA,QAIIiJ,EAAE,GAAGV,GAAG,CAACxI,CAAD,EAAIC,CAAJ,CAJZ;AAAA,QAKI6I,EAAE,GAAGZ,KAAK,CAACjI,CAAD,CALd;AAAA,QAMIkJ,GAAG,GAAGH,IAAI,CAACD,EAAD,EAAKG,EAAL,CANd;AAAA,QAMwB;AACpBE,IAAAA,GAAG,GAAGJ,IAAI,CAACE,EAAD,EAAKH,EAAL,CAPd,CADG,CAQqB;;AAExB,QAAIT,GAAG,CAACa,GAAD,EAAML,EAAN,CAAH,GAAe,CAAnB,EAAsB;AAClB,UAAIR,GAAG,CAACS,EAAD,EAAKD,EAAL,CAAH,GAAc,CAAlB,EAAqB;AAAE;AACnBlH,QAAAA,GAAG,CAACqG,SAAD,EAAYkB,GAAZ,CAAH;AACApB,QAAAA,OAAO,CAACkB,KAAR,GAFiB,CAEA;AACpB,OAHD,MAGO;AAAE;AACLrH,QAAAA,GAAG,CAACqG,SAAD,EAAYa,EAAZ,CAAH;AACAf,QAAAA,OAAO,CAAC3G,MAAR,CAAe,CAAf,EAAkB,CAAlB,EAFG,CAEmB;AACzB;AACJ,KARD,MAQO,IAAIkH,GAAG,CAACc,GAAD,EAAMN,EAAN,CAAH,GAAe,CAAnB,EAAsB;AACzB,UAAIR,GAAG,CAACY,EAAD,EAAKJ,EAAL,CAAH,GAAc,CAAlB,EAAqB;AAAE;AACnBlH,QAAAA,GAAG,CAACqG,SAAD,EAAYmB,GAAZ,CAAH;AACArB,QAAAA,OAAO,CAAC3G,MAAR,CAAe,CAAf,EAAkB,CAAlB,EAFiB,CAEK;AACzB,OAHD,MAGO;AAAE;AACLQ,QAAAA,GAAG,CAACqG,SAAD,EAAYa,EAAZ,CAAH;AACAf,QAAAA,OAAO,CAAC3G,MAAR,CAAe,CAAf,EAAkB,CAAlB,EAFG,CAEmB;AACzB;AACJ,KARM,MAQA;AACH,aAAO,IAAP;AACP;;AACD,SAAO,KAAP;AACH;;AAED,SAAS8G,KAAT,CAAexI,CAAf,EAAkB;AACd,SAAO,CAAC,CAACA,CAAC,CAAC,CAAD,CAAH,EAAQ,CAACA,CAAC,CAAC,CAAD,CAAV,CAAP;AACH;;AAED,SAAS8I,GAAT,CAAaa,EAAb,EAAiBC,EAAjB,EAAqB;AACjB,SAAO,CAACD,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAX,EAAgBD,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAA1B,CAAP;AACH;;AAED,SAAShB,GAAT,CAAae,EAAb,EAAiBC,EAAjB,EAAqB;AACjB,SAAOD,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAV,GAAgBD,EAAE,CAAC,CAAD,CAAF,GAAQC,EAAE,CAAC,CAAD,CAAjC;AACH;;AAED,SAASN,IAAT,CAActJ,CAAd,EAAiB6J,IAAjB,EAAuB;AACnB,MAAIC,CAAC,GAAG,CAAC,CAAC9J,CAAC,CAAC,CAAD,CAAH,EAAQA,CAAC,CAAC,CAAD,CAAT,CAAR;AACA,SAAO4I,GAAG,CAACkB,CAAD,EAAItB,KAAK,CAACqB,IAAD,CAAT,CAAH,GAAsB,CAAtB,GAA0BrB,KAAK,CAACsB,CAAD,CAA/B,GAAqCA,CAA5C;AACH;;AAED,SAASxC,YAAT,CAAsByC,MAAtB,EAA8BhI,IAA9B,EAAoCkH,KAApC,EAA2C9J,IAA3C,EAAiD;AAE7C,MAAI6K,OAAO,GAAGD,MAAM,CAACzI,MAAP,IAAiByI,MAAM,CAACA,MAAM,CAACzI,MAAP,GAAgB,CAAjB,CAArC;AAAA,MACIsF,IAAI,GAAGqC,KAAK,IAAI9J,IAAI,CAAC8J,KAAK,GAAG,CAAT,CADxB;AAAA,MAEIgB,SAAS,GAAGD,OAAO,CAAC1I,MAAR,IAAkB0I,OAAO,CAACA,OAAO,CAAC1I,MAAR,GAAiB,CAAlB,CAFzC;AAAA,MAGIP,IAAI,GAAGgB,IAAI,CAAChB,IAHhB;AAAA,MAIImJ,SAAS,GAAGD,SAJhB;;AAMA,UAAQlI,IAAI,CAACtB,WAAb;AACI,SAAK,GAAL;AACIsJ,MAAAA,MAAM,CAAC9I,IAAP,CAAY+I,OAAO,GAAG,EAAtB;AACA;;AACJ,SAAK,GAAL;AACIG,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAACjJ,IAAI,CAAC,CAAD,CAAL,EAAUkJ,SAAS,CAAC,CAAD,CAAnB,CAAV,CAAR;AACA;;AACJ,SAAK,GAAL;AACIE,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAACC,SAAS,CAAC,CAAD,CAAV,EAAelJ,IAAI,CAAC,CAAD,CAAnB,CAAV,CAAR;AACA;;AACJ,SAAK,GAAL;AACIoJ,MAAAA,QAAQ,CAACH,OAAD,EAAUjJ,IAAI,CAACkB,KAAL,CAAW,CAAX,EAAc,CAAd,CAAV,CAAR;AACAjD,MAAAA,aAAa,GAAG,CAAC+B,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAf,EAAoBA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlC,CAAhB,CAFJ,CAE4D;;AACxD;;AACJ,SAAK,GAAL;AACI,UAAI6F,IAAI,CAACnG,WAAL,IAAoB,GAApB,IAA2BmG,IAAI,CAACnG,WAAL,IAAoB,GAAnD,EAAwD;AACpDyJ,QAAAA,SAAS,GAAG,CAACD,SAAS,CAAC,CAAD,CAAT,GAAejL,aAAa,CAAC,CAAD,CAA7B,EAAkCiL,SAAS,CAAC,CAAD,CAAT,GAAejL,aAAa,CAAC,CAAD,CAA9D,CAAZ;AACAmL,QAAAA,QAAQ,CAACH,OAAD,EAAUE,SAAV,CAAR;AACAlL,QAAAA,aAAa,GAAG,CAAC+B,IAAI,CAAC,CAAD,CAAJ,GAAUmJ,SAAS,CAAC,CAAD,CAApB,EAAyBnJ,IAAI,CAAC,CAAD,CAAJ,GAAUmJ,SAAS,CAAC,CAAD,CAA5C,CAAhB;AACH;;AACD;;AACJ,SAAK,GAAL;AACI;AACAC,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMC,SAAS,CAAC,CAAD,CAAT,GAAelJ,IAAI,CAAC,CAAD,CAAzB,CAAD,EAAgC,MAAMkJ,SAAS,CAAC,CAAD,CAAT,GAAelJ,IAAI,CAAC,CAAD,CAAzB,CAAhC,CAAV,CAAR;AACAoJ,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMjJ,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAApB,CAAD,EAA2B,MAAMA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAApB,CAA3B,CAAV,CAAR;AACAoJ,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMjJ,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAApB,CAAD,EAA2B,MAAMA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAApB,CAA3B,CAAV,CAAR;AACA/B,MAAAA,aAAa,GAAG,CAAC+B,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAf,EAAoBA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlC,CAAhB,CALJ,CAK4D;;AACxD;;AACJ,SAAK,GAAL;AACI,UAAI6F,IAAI,CAACnG,WAAL,IAAoB,GAApB,IAA2BmG,IAAI,CAACnG,WAAL,IAAoB,GAAnD,EAAwD;AACpD0J,QAAAA,QAAQ,CAACH,OAAD,EAAU,CAACC,SAAS,CAAC,CAAD,CAAT,GAAe,KAAKjL,aAAa,CAAC,CAAD,CAAlC,EAAuCiL,SAAS,CAAC,CAAD,CAAT,GAAe,KAAKjL,aAAa,CAAC,CAAD,CAAxE,CAAV,CAAR;AACAkL,QAAAA,SAAS,GAAG,CAACD,SAAS,CAAC,CAAD,CAAT,GAAejL,aAAa,CAAC,CAAD,CAA7B,EAAkCiL,SAAS,CAAC,CAAD,CAAT,GAAejL,aAAa,CAAC,CAAD,CAA9D,CAAZ;AACH;;AACDmL,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAME,SAAS,CAAC,CAAD,CAAT,GAAenJ,IAAI,CAAC,CAAD,CAAzB,CAAD,EAAgC,MAAMmJ,SAAS,CAAC,CAAD,CAAT,GAAcnJ,IAAI,CAAC,CAAD,CAAxB,CAAhC,CAAV,CAAR;AACAoJ,MAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMjJ,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAApB,CAAD,EAA2B,MAAMA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAApB,CAA3B,CAAV,CAAR;AACA/B,MAAAA,aAAa,GAAG,CAAC+B,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAf,EAAoBA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlC,CAAhB;AACA;;AACJ,SAAK,GAAL;AACI;AACA,UAAIqJ,MAAM,GAAGC,GAAG,CAACC,KAAJ,CAAU,CAAV,EAAaL,SAAS,CAAClD,MAAV,CAAiBhG,IAAjB,CAAb,CAAb;;AACA,WAAK,IAAIwJ,KAAT,EAAgB,CAACA,KAAK,GAAGH,MAAM,CAAC1I,MAAP,CAAc,CAAd,EAAgB,CAAhB,EAAmBF,GAAnB,CAAuBgJ,UAAvB,CAAT,EAA6ClJ,MAA7D,GAAsE;AAClE6I,QAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMC,SAAS,CAAC,CAAD,CAAT,GAAeM,KAAK,CAAC,CAAD,CAA1B,CAAD,EAAiC,MAAMN,SAAS,CAAC,CAAD,CAAT,GAAeM,KAAK,CAAC,CAAD,CAA1B,CAAjC,CAAV,CAAR;AACAJ,QAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMO,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAtB,CAAD,EAA6B,MAAMA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAtB,CAA7B,CAAV,CAAR;AACAJ,QAAAA,QAAQ,CAACH,OAAD,EAAU,CAAC,MAAMO,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAtB,CAAD,EAA6B,MAAMA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAtB,CAA7B,CAAV,CAAR;AACA,YAAIH,MAAM,CAAC9I,MAAX,EAAmB6I,QAAQ,CAACH,OAAD,EAAUC,SAAS,GAAGM,KAAK,CAACtI,KAAN,CAAY,CAAC,CAAb,CAAtB,CAAR;AACtB;;AACD;AA9CR,GAR6C,CAwD7C;;;AACA,MAAIlB,IAAI,IAAIA,IAAI,CAACO,MAAL,IAAe,CAA3B,EAA8B6I,QAAQ,CAACH,OAAD,EAAUjJ,IAAI,CAACkB,KAAL,CAAW,CAAC,CAAZ,CAAV,CAAR;AAC9B,SAAO8H,MAAP;;AAEA,WAASS,UAAT,CAAoBC,CAApB,EAAuBpJ,CAAvB,EAA0B;AAAE,WAAOoJ,CAAC,GAAGR,SAAS,CAAC5I,CAAC,GAAG,CAAL,CAApB;AAA6B,GA5DZ,CA8D7C;;;AACA,WAAS8I,QAAT,CAAkBhL,IAAlB,EAAwBuL,KAAxB,EAA+B;AAC3B,QAAI,CAACvL,IAAI,CAACmC,MAAN,IAAgBoJ,KAAK,CAAC,CAAD,CAAL,GAAWvL,IAAI,CAACA,IAAI,CAACuI,IAAN,CAAJ,CAAgB,CAAhB,CAA/B,EAAmD;AAC/CvI,MAAAA,IAAI,CAACuI,IAAL,GAAYvI,IAAI,CAACmC,MAAjB;AACAyI,MAAAA,MAAM,CAACrC,IAAP,GAAcqC,MAAM,CAACzI,MAAP,GAAgBgC,IAAI,CAAC4F,GAAL,CAASwB,KAAK,CAAC,CAAD,CAAd,EAAmBX,MAAM,CAACrC,IAA1B,CAAhB,GAAkDgD,KAAK,CAAC,CAAD,CAArE;AACH;;AACD,QAAI,CAACvL,IAAI,CAACmC,MAAN,IAAgBoJ,KAAK,CAAC,CAAD,CAAL,GAAWvL,IAAI,CAACA,IAAI,CAACqI,IAAN,CAAJ,CAAgB,CAAhB,CAA/B,EAAmD;AAC/CrI,MAAAA,IAAI,CAACqI,IAAL,GAAYrI,IAAI,CAACmC,MAAjB;AACAyI,MAAAA,MAAM,CAACvC,IAAP,GAAcuC,MAAM,CAACzI,MAAP,GAAgBgC,IAAI,CAAC4F,GAAL,CAASwB,KAAK,CAAC,CAAD,CAAd,EAAmBX,MAAM,CAACvC,IAA1B,CAAhB,GAAkDkD,KAAK,CAAC,CAAD,CAArE;AACH;;AACD,QAAI,CAACvL,IAAI,CAACmC,MAAN,IAAgBoJ,KAAK,CAAC,CAAD,CAAL,GAAWvL,IAAI,CAACA,IAAI,CAACwI,IAAN,CAAJ,CAAgB,CAAhB,CAA/B,EAAmD;AAC/CxI,MAAAA,IAAI,CAACwI,IAAL,GAAYxI,IAAI,CAACmC,MAAjB;AACAyI,MAAAA,MAAM,CAACpC,IAAP,GAAcoC,MAAM,CAACzI,MAAP,GAAgBgC,IAAI,CAACqH,GAAL,CAASD,KAAK,CAAC,CAAD,CAAd,EAAmBX,MAAM,CAACpC,IAA1B,CAAhB,GAAkD+C,KAAK,CAAC,CAAD,CAArE;AACH;;AACD,QAAI,CAACvL,IAAI,CAACmC,MAAN,IAAgBoJ,KAAK,CAAC,CAAD,CAAL,GAAWvL,IAAI,CAACA,IAAI,CAACsI,IAAN,CAAJ,CAAgB,CAAhB,CAA/B,EAAmD;AAC/CtI,MAAAA,IAAI,CAACsI,IAAL,GAAYtI,IAAI,CAACmC,MAAjB;AACAyI,MAAAA,MAAM,CAACtC,IAAP,GAAcsC,MAAM,CAACzI,MAAP,GAAgBgC,IAAI,CAACqH,GAAL,CAASD,KAAK,CAAC,CAAD,CAAd,EAAmBX,MAAM,CAACtC,IAA1B,CAAhB,GAAkDiD,KAAK,CAAC,CAAD,CAArE;AACH;;AACDvL,IAAAA,IAAI,CAAC8B,IAAL,CAAUyJ,KAAV;AACH;AACJ;AAED;;;;;;;;AAMA,SAAS1C,UAAT,CAAoB+B,MAApB,EAA4B;AACxB;AAEAA,EAAAA,MAAM,CAACa,IAAP,CAAY,UAASrK,CAAT,EAAYqF,CAAZ,EAAe;AACvB,WAAOrF,CAAC,CAAC,CAAD,CAAD,IAAQqF,CAAC,CAAC,CAAD,CAAT,GAAerF,CAAC,CAAC,CAAD,CAAD,GAAOqF,CAAC,CAAC,CAAD,CAAvB,GAA6BrF,CAAC,CAAC,CAAD,CAAD,GAAOqF,CAAC,CAAC,CAAD,CAA5C;AACH,GAFD;AAIA,MAAIiF,KAAK,GAAG,EAAZ;AAAA,MACIlD,IAAI,GAAG,CADX;AAAA,MAEImD,MAAM,GAAG,CAFb;;AAGA,OAAK,IAAIzJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0I,MAAM,CAACzI,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,WAAOwJ,KAAK,CAACvJ,MAAN,IAAgB,CAAhB,IAAqByJ,KAAK,CAACF,KAAK,CAACA,KAAK,CAACvJ,MAAN,GAAe,CAAhB,CAAN,EAA0BuJ,KAAK,CAACA,KAAK,CAACvJ,MAAN,GAAe,CAAhB,CAA/B,EAAmDyI,MAAM,CAAC1I,CAAD,CAAzD,CAAL,IAAsE,CAAlG,EAAqG;AACjGwJ,MAAAA,KAAK,CAACG,GAAN;AACH;;AACD,QAAIjB,MAAM,CAAC1I,CAAD,CAAN,CAAU,CAAV,IAAe0I,MAAM,CAACpC,IAAD,CAAN,CAAa,CAAb,CAAnB,EAAoC;AAChCA,MAAAA,IAAI,GAAGtG,CAAP;AACAyJ,MAAAA,MAAM,GAAGD,KAAK,CAACvJ,MAAf;AACH;;AACDuJ,IAAAA,KAAK,CAAC5J,IAAN,CAAW8I,MAAM,CAAC1I,CAAD,CAAjB;AACH;;AAED,MAAI4J,KAAK,GAAG,EAAZ;AAAA,MACIvD,IAAI,GAAGqC,MAAM,CAACzI,MAAP,GAAgB,CAD3B;AAAA,MAEI4J,GAAG,GAAG,CAFV;;AAGA,OAAK,IAAI7J,CAAC,GAAG0I,MAAM,CAACzI,MAApB,EAA4BD,CAAC,EAA7B,GAAkC;AAC9B,WAAO4J,KAAK,CAAC3J,MAAN,IAAgB,CAAhB,IAAqByJ,KAAK,CAACE,KAAK,CAACA,KAAK,CAAC3J,MAAN,GAAe,CAAhB,CAAN,EAA0B2J,KAAK,CAACA,KAAK,CAAC3J,MAAN,GAAe,CAAhB,CAA/B,EAAmDyI,MAAM,CAAC1I,CAAD,CAAzD,CAAL,IAAsE,CAAlG,EAAqG;AACjG4J,MAAAA,KAAK,CAACD,GAAN;AACH;;AACD,QAAIjB,MAAM,CAAC1I,CAAD,CAAN,CAAU,CAAV,IAAe0I,MAAM,CAACrC,IAAD,CAAN,CAAa,CAAb,CAAnB,EAAoC;AAChCA,MAAAA,IAAI,GAAGrG,CAAP;AACA6J,MAAAA,GAAG,GAAGD,KAAK,CAAC3J,MAAZ;AACH;;AACD2J,IAAAA,KAAK,CAAChK,IAAN,CAAW8I,MAAM,CAAC1I,CAAD,CAAjB;AACH,GAjCuB,CAmCxB;;;AACA4J,EAAAA,KAAK,CAACD,GAAN;AACAH,EAAAA,KAAK,CAACG,GAAN;AAEA,MAAIG,IAAI,GAAGN,KAAK,CAAC9D,MAAN,CAAakE,KAAb,CAAX;AAEAE,EAAAA,IAAI,CAAC1D,IAAL,GAAY,CAAZ,CAzCwB,CAyCT;;AACf0D,EAAAA,IAAI,CAAC3D,IAAL,GAAYqD,KAAK,CAACvJ,MAAlB;AACA6J,EAAAA,IAAI,CAACxD,IAAL,GAAYmD,MAAZ;AACAK,EAAAA,IAAI,CAACzD,IAAL,GAAY,CAACmD,KAAK,CAACvJ,MAAN,GAAe4J,GAAhB,IAAuBC,IAAI,CAAC7J,MAAxC;AAEA,SAAO6J,IAAP;AACH;;AAED,SAASJ,KAAT,CAAejB,CAAf,EAAkBvJ,CAAlB,EAAqBqF,CAArB,EAAwB;AACpB,SAAO,CAACrF,CAAC,CAAC,CAAD,CAAD,GAAOuJ,CAAC,CAAC,CAAD,CAAT,KAAiBlE,CAAC,CAAC,CAAD,CAAD,GAAOkE,CAAC,CAAC,CAAD,CAAzB,IAAgC,CAACvJ,CAAC,CAAC,CAAD,CAAD,GAAOuJ,CAAC,CAAC,CAAD,CAAT,KAAiBlE,CAAC,CAAC,CAAD,CAAD,GAAOkE,CAAC,CAAC,CAAD,CAAzB,CAAvC;AACH;AAED;;;AAIA;;;AACA,SAASO,GAAT,CAAae,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyBC,EAAzB,EAA6BC,KAA7B,EAAoCC,cAApC,EAAoDC,UAApD,EAAgEC,EAAhE,EAAoEC,EAApE,EAAwEC,SAAxE,EAAmF;AAC/E;AACA;AACA,MAAIC,IAAI,GAAGxI,IAAI,CAACyI,EAAL,GAAU,GAAV,GAAgB,GAA3B;AAAA,MACIC,GAAG,GAAG1I,IAAI,CAACyI,EAAL,GAAU,GAAV,IAAiB,CAACP,KAAD,IAAU,CAA3B,CADV;AAAA,MAEIS,GAAG,GAAG,EAFV;AAAA,MAGIC,OAAO,GAAG,UAAS1H,CAAT,EAAYC,CAAZ,EAAeuH,GAAf,EAAoB;AAAE,WAAOxH,CAAC,GAAGlB,IAAI,CAAC6I,GAAL,CAASH,GAAT,CAAJ,GAAoBvH,CAAC,GAAGnB,IAAI,CAAC8I,GAAL,CAASJ,GAAT,CAA/B;AAA8C,GAHlF;AAAA,MAIIK,OAAO,GAAG,UAAS7H,CAAT,EAAYC,CAAZ,EAAeuH,GAAf,EAAoB;AAAE,WAAOxH,CAAC,GAAGlB,IAAI,CAAC8I,GAAL,CAASJ,GAAT,CAAJ,GAAoBvH,CAAC,GAAGnB,IAAI,CAAC6I,GAAL,CAASH,GAAT,CAA/B;AAA8C,GAJlF;;AAKA,MAAI,CAACH,SAAL,EAAgB;AACZT,IAAAA,EAAE,GAAGc,OAAO,CAACd,EAAD,EAAKC,EAAL,EAAS,CAACW,GAAV,CAAZ;AACAX,IAAAA,EAAE,GAAGgB,OAAO,CAACjB,EAAD,EAAKC,EAAL,EAAS,CAACW,GAAV,CAAZ;AACAL,IAAAA,EAAE,GAAGO,OAAO,CAACP,EAAD,EAAKC,EAAL,EAAS,CAACI,GAAV,CAAZ;AACAJ,IAAAA,EAAE,GAAGS,OAAO,CAACV,EAAD,EAAKC,EAAL,EAAS,CAACI,GAAV,CAAZ;AACA,QAAIxH,CAAC,GAAG,CAAC4G,EAAE,GAAGO,EAAN,IAAY,CAApB;AAAA,QACIlH,CAAC,GAAG,CAAC4G,EAAE,GAAGO,EAAN,IAAY,CADpB;AAEA,QAAI7L,CAAC,GAAIyE,CAAC,GAAGA,CAAL,IAAW8G,EAAE,GAAGA,EAAhB,IAAuB7G,CAAC,GAAGA,CAAL,IAAW8G,EAAE,GAAGA,EAAhB,CAA9B;;AACA,QAAIxL,CAAC,GAAG,CAAR,EAAW;AACPA,MAAAA,CAAC,GAAGuD,IAAI,CAACC,IAAL,CAAUxD,CAAV,CAAJ;AACAuL,MAAAA,EAAE,GAAGvL,CAAC,GAAGuL,EAAT;AACAC,MAAAA,EAAE,GAAGxL,CAAC,GAAGwL,EAAT;AACH;;AACD,QAAIe,GAAG,GAAGhB,EAAE,GAAGA,EAAf;AAAA,QACIiB,GAAG,GAAGhB,EAAE,GAAGA,EADf;AAAA,QAEIiB,CAAC,GAAG,CAACf,cAAc,IAAIC,UAAlB,GAA+B,CAAC,CAAhC,GAAoC,CAArC,IACApI,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACc,GAAL,CAAS,CAACkI,GAAG,GAAGC,GAAN,GAAYD,GAAG,GAAG7H,CAAN,GAAUA,CAAtB,GAA0B8H,GAAG,GAAG/H,CAAN,GAAUA,CAArC,KAA2C8H,GAAG,GAAG7H,CAAN,GAAUA,CAAV,GAAc8H,GAAG,GAAG/H,CAAN,GAAUA,CAAnE,CAAT,CAAV,CAHR;AAAA,QAIIiI,EAAE,GAAGD,CAAC,GAAGlB,EAAJ,GAAS7G,CAAT,GAAa8G,EAAb,GAAkB,CAACH,EAAE,GAAGO,EAAN,IAAY,CAJvC;AAAA,QAKIe,EAAE,GAAGF,CAAC,GAAG,CAACjB,EAAL,GAAU/G,CAAV,GAAc8G,EAAd,GAAmB,CAACD,EAAE,GAAGO,EAAN,IAAY,CALxC;AAAA,QAMIe,EAAE,GAAGrJ,IAAI,CAACsJ,IAAL,CAAU,CAAC,CAACvB,EAAE,GAAGqB,EAAN,IAAYnB,EAAb,EAAiB/H,OAAjB,CAAyB,CAAzB,CAAV,CANT;AAAA,QAOIqJ,EAAE,GAAGvJ,IAAI,CAACsJ,IAAL,CAAU,CAAC,CAAChB,EAAE,GAAGc,EAAN,IAAYnB,EAAb,EAAiB/H,OAAjB,CAAyB,CAAzB,CAAV,CAPT;AASAmJ,IAAAA,EAAE,GAAGvB,EAAE,GAAGqB,EAAL,GAAUnJ,IAAI,CAACyI,EAAL,GAAUY,EAApB,GAAyBA,EAA9B;AACAE,IAAAA,EAAE,GAAGlB,EAAE,GAAGc,EAAL,GAAUnJ,IAAI,CAACyI,EAAL,GAAUc,EAApB,GAAyBA,EAA9B;AACAF,IAAAA,EAAE,GAAG,CAAL,KAAWA,EAAE,GAAGrJ,IAAI,CAACyI,EAAL,GAAU,CAAV,GAAcY,EAA9B;AACAE,IAAAA,EAAE,GAAG,CAAL,KAAWA,EAAE,GAAGvJ,IAAI,CAACyI,EAAL,GAAU,CAAV,GAAcc,EAA9B;;AACA,QAAInB,UAAU,IAAIiB,EAAE,GAAGE,EAAvB,EAA2B;AACvBF,MAAAA,EAAE,GAAGA,EAAE,GAAGrJ,IAAI,CAACyI,EAAL,GAAU,CAApB;AACH;;AACD,QAAI,CAACL,UAAD,IAAemB,EAAE,GAAGF,EAAxB,EAA4B;AACxBE,MAAAA,EAAE,GAAGA,EAAE,GAAGvJ,IAAI,CAACyI,EAAL,GAAU,CAApB;AACH;AACJ,GAhCD,MAgCO;AACHY,IAAAA,EAAE,GAAGd,SAAS,CAAC,CAAD,CAAd;AACAgB,IAAAA,EAAE,GAAGhB,SAAS,CAAC,CAAD,CAAd;AACAY,IAAAA,EAAE,GAAGZ,SAAS,CAAC,CAAD,CAAd;AACAa,IAAAA,EAAE,GAAGb,SAAS,CAAC,CAAD,CAAd;AACH;;AACD,MAAIiB,EAAE,GAAGD,EAAE,GAAGF,EAAd;;AACA,MAAIrJ,IAAI,CAACc,GAAL,CAAS0I,EAAT,IAAehB,IAAnB,EAAyB;AACrB,QAAIiB,KAAK,GAAGF,EAAZ;AAAA,QACIG,KAAK,GAAGrB,EADZ;AAAA,QAEIsB,KAAK,GAAGrB,EAFZ;AAGAiB,IAAAA,EAAE,GAAGF,EAAE,GAAGb,IAAI,IAAIJ,UAAU,IAAImB,EAAE,GAAGF,EAAnB,GAAwB,CAAxB,GAA4B,CAAC,CAAjC,CAAd;AACAhB,IAAAA,EAAE,GAAGc,EAAE,GAAGnB,EAAE,GAAGhI,IAAI,CAAC6I,GAAL,CAASU,EAAT,CAAf;AACAjB,IAAAA,EAAE,GAAGc,EAAE,GAAGnB,EAAE,GAAGjI,IAAI,CAAC8I,GAAL,CAASS,EAAT,CAAf;AACAZ,IAAAA,GAAG,GAAG5B,GAAG,CAACsB,EAAD,EAAKC,EAAL,EAASN,EAAT,EAAaC,EAAb,EAAiBC,KAAjB,EAAwB,CAAxB,EAA2BE,UAA3B,EAAuCsB,KAAvC,EAA8CC,KAA9C,EAAqD,CAACJ,EAAD,EAAKE,KAAL,EAAYN,EAAZ,EAAgBC,EAAhB,CAArD,CAAT;AACH;;AACDI,EAAAA,EAAE,GAAGD,EAAE,GAAGF,EAAV;AACA,MAAIO,EAAE,GAAG5J,IAAI,CAAC6I,GAAL,CAASQ,EAAT,CAAT;AAAA,MACIQ,EAAE,GAAG7J,IAAI,CAAC8I,GAAL,CAASO,EAAT,CADT;AAAA,MAEIS,EAAE,GAAG9J,IAAI,CAAC6I,GAAL,CAASU,EAAT,CAFT;AAAA,MAGIQ,EAAE,GAAG/J,IAAI,CAAC8I,GAAL,CAASS,EAAT,CAHT;AAAA,MAII1M,CAAC,GAAGmD,IAAI,CAACgK,GAAL,CAASR,EAAE,GAAG,CAAd,CAJR;AAAA,MAKIS,EAAE,GAAG,IAAI,CAAJ,GAAQjC,EAAR,GAAanL,CALtB;AAAA,MAMIqN,EAAE,GAAG,IAAI,CAAJ,GAAQjC,EAAR,GAAapL,CANtB;AAAA,MAOIF,CAAC,GAAG,CACA,CAAEsN,EAAF,GAAOJ,EADP,EACWK,EAAE,GAAGN,EADhB,EAEAvB,EAAE,GAAG4B,EAAE,GAAGF,EAAV,GAAejC,EAFf,EAEmBQ,EAAE,GAAG4B,EAAE,GAAGJ,EAAV,GAAe/B,EAFlC,EAGAM,EAAE,GAAGP,EAHL,EAGSQ,EAAE,GAAGP,EAHd,CAPR;;AAYA,MAAIQ,SAAJ,EAAe;AACX,WAAO5L,CAAC,CAAC8G,MAAF,CAASkF,GAAT,CAAP;AACH,GAFD,MAEO;AACHA,IAAAA,GAAG,GAAGhM,CAAC,CAAC8G,MAAF,CAASkF,GAAT,CAAN;AACA,QAAIwB,MAAM,GAAG,EAAb;;AACA,SAAK,IAAIpM,CAAC,GAAG,CAAR,EAAWoJ,CAAC,GAAGwB,GAAG,CAAC3K,MAAxB,EAAgCD,CAAC,GAAGoJ,CAApC,EAAuCpJ,CAAC,EAAxC,EAA4C;AACxCoM,MAAAA,MAAM,CAACpM,CAAD,CAAN,GAAYA,CAAC,GAAG,CAAJ,GAAQgL,OAAO,CAACJ,GAAG,CAAC5K,CAAC,GAAG,CAAL,CAAJ,EAAa4K,GAAG,CAAC5K,CAAD,CAAhB,EAAqB2K,GAArB,CAAf,GAA2CE,OAAO,CAACD,GAAG,CAAC5K,CAAD,CAAJ,EAAS4K,GAAG,CAAC5K,CAAC,GAAG,CAAL,CAAZ,EAAqB2K,GAArB,CAA9D;AACH;;AACD,WAAOyB,MAAP;AACH;AACJ,C,CACD","sourcesContent":["/* global a2c */\n'use strict';\n\nvar rNumber = String.raw`[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*`,\n    rCommaWsp = String.raw`(?:\\s,?\\s*|,\\s*)`,\n    rNumberCommaWsp = `(${rNumber})` + rCommaWsp,\n    rFlagCommaWsp = `([01])${rCommaWsp}?`,\n    rCoordinatePair = String.raw`(${rNumber})${rCommaWsp}?(${rNumber})`,\n    rArcSeq = (rNumberCommaWsp + '?').repeat(2) + rNumberCommaWsp + rFlagCommaWsp.repeat(2) + rCoordinatePair;\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n    regCoordinateSequence = new RegExp(rNumber, 'g'),\n    regArcArgumentSequence = new RegExp(rArcSeq, 'g'),\n    regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n    transform2js = require('./_transforms').transform2js,\n    transformsMultiply = require('./_transforms').transformsMultiply,\n    transformArc = require('./_transforms').transformArc,\n    collections = require('./_collections.js'),\n    referencesProps = collections.referencesProps,\n    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n    prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.path2js = function(path) {\n    if (path.pathJS) return path.pathJS;\n\n    var paramsLength = { // Number of parameters of every path command\n            H: 1, V: 1, M: 2, L: 2, T: 2, Q: 4, S: 4, C: 6, A: 7,\n            h: 1, v: 1, m: 2, l: 2, t: 2, q: 4, s: 4, c: 6, a: 7\n        },\n        pathData = [],   // JS representation of the path data\n        instruction, // current instruction context\n        startMoveto = false;\n\n    // splitting path string into array like ['M', '10 50', 'L', '20 30']\n    path.attr('d').value.split(regPathInstructions).forEach(function(data) {\n        if (!data) return;\n        if (!startMoveto) {\n            if (data == 'M' || data == 'm') {\n                startMoveto = true;\n            } else return;\n        }\n\n        // instruction item\n        if (regPathInstructions.test(data)) {\n            instruction = data;\n\n            // z - instruction w/o data\n            if (instruction == 'Z' || instruction == 'z') {\n                pathData.push({\n                    instruction: 'z'\n                });\n            }\n        // data item\n        } else {\n            /* jshint boss: true */\n            if (instruction == 'A' || instruction == 'a') {\n                var newData = [];\n                for (var args; (args = regArcArgumentSequence.exec(data));) {\n                    for (var i = 1; i < args.length; i++) {\n                        newData.push(args[i]);\n                    }\n                }\n                data = newData;\n            } else {\n                data = data.match(regCoordinateSequence);\n            }\n            if (!data) return;\n\n            data = data.map(Number);\n            // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n            // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n            if (instruction == 'M' || instruction == 'm') {\n                pathData.push({\n                    instruction: pathData.length == 0 ? 'M' : instruction,\n                    data: data.splice(0, 2)\n                });\n                instruction = instruction == 'M' ? 'L' : 'l';\n            }\n\n            for (var pair = paramsLength[instruction]; data.length;) {\n                pathData.push({\n                    instruction: instruction,\n                    data: data.splice(0, pair)\n                });\n            }\n        }\n    });\n\n    // First moveto is actually absolute. Subsequent coordinates were separated above.\n    if (pathData.length && pathData[0].instruction == 'm') {\n        pathData[0].instruction = 'M';\n    }\n    path.pathJS = pathData;\n\n    return pathData;\n};\n\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\nvar relative2absolute = exports.relative2absolute = function(data) {\n    var currentPoint = [0, 0],\n        subpathPoint = [0, 0],\n        i;\n\n    return data.map(function(item) {\n\n        var instruction = item.instruction,\n            itemData = item.data && item.data.slice();\n\n        if (instruction == 'M') {\n\n            set(currentPoint, itemData);\n            set(subpathPoint, itemData);\n\n        } else if ('mlcsqt'.indexOf(instruction) > -1) {\n\n            for (i = 0; i < itemData.length; i++) {\n                itemData[i] += currentPoint[i % 2];\n            }\n            set(currentPoint, itemData);\n\n            if (instruction == 'm') {\n                set(subpathPoint, itemData);\n            }\n\n        } else if (instruction == 'a') {\n\n            itemData[5] += currentPoint[0];\n            itemData[6] += currentPoint[1];\n            set(currentPoint, itemData);\n\n        } else if (instruction == 'h') {\n\n            itemData[0] += currentPoint[0];\n            currentPoint[0] = itemData[0];\n\n        } else if (instruction == 'v') {\n\n            itemData[0] += currentPoint[1];\n            currentPoint[1] = itemData[0];\n\n        } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n\n            set(currentPoint, itemData);\n\n        } else if (instruction == 'H') {\n\n            currentPoint[0] = itemData[0];\n\n        } else if (instruction == 'V') {\n\n            currentPoint[1] = itemData[0];\n\n        } else if (instruction == 'z') {\n\n            set(currentPoint, subpathPoint);\n\n        }\n\n        return instruction == 'z' ?\n            { instruction: 'z' } :\n            {\n                instruction: instruction.toUpperCase(),\n                data: itemData\n            };\n\n    });\n};\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\nexports.applyTransforms = function(elem, path, params) {\n    // if there are no 'stroke' attr and references to other objects such as\n    // gradiends or clip-path which are also subjects to transform.\n    if (!elem.hasAttr('transform') || !elem.attr('transform').value ||\n        elem.someAttr(function(attr) {\n            return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n        }))\n        return path;\n\n    var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n        stroke = elem.computedAttr('stroke'),\n        id = elem.computedAttr('id'),\n        transformPrecision = params.transformPrecision,\n        newPoint, scale;\n\n    if (stroke && stroke != 'none') {\n        if (!params.applyTransformsStroked ||\n            (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) &&\n            (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))\n            return path;\n\n        // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n        if (id) {\n            var idElem = elem,\n                hasStrokeWidth = false;\n\n            do {\n                if (idElem.hasAttr('stroke-width')) hasStrokeWidth = true;\n            } while (!idElem.hasAttr('id', id) && !hasStrokeWidth && (idElem = idElem.parentNode));\n\n            if (!hasStrokeWidth) return path;\n        }\n\n        scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n        if (scale !== 1) {\n            var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n            if (!elem.hasAttr('vector-effect') || elem.attr('vector-effect').value !== 'non-scaling-stroke') {\n                if (elem.hasAttr('stroke-width')) {\n                    elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim()\n                        .replace(regNumericValues, function(num) {\n                            return removeLeadingZero(num * scale);\n                        });\n                } else {\n                    elem.addAttr({\n                        name: 'stroke-width',\n                        prefix: '',\n                        local: 'stroke-width',\n                        value: strokeWidth.replace(regNumericValues, function(num) {\n                            return removeLeadingZero(num * scale);\n                        })\n                    });\n                }\n            }\n        }\n    } else if (id) { // Stroke and stroke-width can be redefined with <use>\n        return path;\n    }\n\n    path.forEach(function(pathItem) {\n\n        if (pathItem.data) {\n\n            // h -> l\n            if (pathItem.instruction === 'h') {\n\n                pathItem.instruction = 'l';\n                pathItem.data[1] = 0;\n\n            // v -> l\n            } else if (pathItem.instruction === 'v') {\n\n                pathItem.instruction = 'l';\n                pathItem.data[1] = pathItem.data[0];\n                pathItem.data[0] = 0;\n\n            }\n\n            // if there is a translate() transform\n            if (pathItem.instruction === 'M' &&\n                (matrix.data[4] !== 0 ||\n                matrix.data[5] !== 0)\n            ) {\n\n                // then apply it only to the first absoluted M\n                newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n                set(pathItem.data, newPoint);\n                set(pathItem.coords, newPoint);\n\n                // clear translate() data from transform matrix\n                matrix.data[4] = 0;\n                matrix.data[5] = 0;\n\n            } else {\n\n                if (pathItem.instruction == 'a') {\n\n                    transformArc(pathItem.data, matrix.data);\n\n                    // reduce number of digits in rotation angle\n                    if (Math.abs(pathItem.data[2]) > 80) {\n                        var a = pathItem.data[0],\n                            rotation = pathItem.data[2];\n                        pathItem.data[0] = pathItem.data[1];\n                        pathItem.data[1] = a;\n                        pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n                    }\n\n                    newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n                    pathItem.data[5] = newPoint[0];\n                    pathItem.data[6] = newPoint[1];\n\n                } else {\n\n                    for (var i = 0; i < pathItem.data.length; i += 2) {\n                        newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n                        pathItem.data[i] = newPoint[0];\n                        pathItem.data[i + 1] = newPoint[1];\n                    }\n                }\n\n                pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n                pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n\n            }\n\n        }\n\n    });\n\n    // remove transform attr\n    elem.removeAttr('transform');\n\n    return path;\n};\n\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\nfunction transformPoint(matrix, x, y) {\n\n    return [\n        matrix[0] * x + matrix[2] * y + matrix[4],\n        matrix[1] * x + matrix[3] * y + matrix[5]\n    ];\n\n}\n\n/**\n * Compute Cubic Bézie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\nexports.computeCubicBoundingBox = function(xa, ya, xb, yb, xc, yc, xd, yd) {\n\n    var minx = Number.POSITIVE_INFINITY,\n        miny = Number.POSITIVE_INFINITY,\n        maxx = Number.NEGATIVE_INFINITY,\n        maxy = Number.NEGATIVE_INFINITY,\n        ts,\n        t,\n        x,\n        y,\n        i;\n\n    // X\n    if (xa < minx) { minx = xa; }\n    if (xa > maxx) { maxx = xa; }\n    if (xd < minx) { minx= xd; }\n    if (xd > maxx) { maxx = xd; }\n\n    ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n\n    for (i = 0; i < ts.length; i++) {\n\n        t = ts[i];\n\n        if (t >= 0 && t <= 1) {\n            x = computeCubicBaseValue(t, xa, xb, xc, xd);\n            // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n            if (x < minx) { minx = x; }\n            if (x > maxx) { maxx = x; }\n        }\n\n    }\n\n    // Y\n    if (ya < miny) { miny = ya; }\n    if (ya > maxy) { maxy = ya; }\n    if (yd < miny) { miny = yd; }\n    if (yd > maxy) { maxy = yd; }\n\n    ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n\n    for (i = 0; i < ts.length; i++) {\n\n        t = ts[i];\n\n        if (t >= 0 && t <= 1) {\n            // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n            y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n            if (y < miny) { miny = y; }\n            if (y > maxy) { maxy = y; }\n        }\n\n    }\n\n    return {\n        minx: minx,\n        miny: miny,\n        maxx: maxx,\n        maxy: maxy\n    };\n\n};\n\n// compute the value for the cubic bezier function at time=t\nfunction computeCubicBaseValue(t, a, b, c, d) {\n\n    var mt = 1 - t;\n\n    return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n\n}\n\n// compute the value for the first derivative of the cubic bezier function at time=t\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n\n    var result = [-1, -1],\n        tl = -a + 2 * b - c,\n        tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n        dn = -a + 3 * b - 3 * c + d;\n\n    if (dn !== 0) {\n        result[0] = (tl + tr) / dn;\n        result[1] = (tl - tr) / dn;\n    }\n\n    return result;\n\n}\n\n/**\n * Compute Quadratic Bézier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\nexports.computeQuadraticBoundingBox = function(xa, ya, xb, yb, xc, yc) {\n\n    var minx = Number.POSITIVE_INFINITY,\n        miny = Number.POSITIVE_INFINITY,\n        maxx = Number.NEGATIVE_INFINITY,\n        maxy = Number.NEGATIVE_INFINITY,\n        t,\n        x,\n        y;\n\n    // X\n    if (xa < minx) { minx = xa; }\n    if (xa > maxx) { maxx = xa; }\n    if (xc < minx) { minx = xc; }\n    if (xc > maxx) { maxx = xc; }\n\n    t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n\n    if (t >= 0 && t <= 1) {\n        x = computeQuadraticBaseValue(t, xa, xb, xc);\n        // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n        if (x < minx) { minx = x; }\n        if (x > maxx) { maxx = x; }\n    }\n\n    // Y\n    if (ya < miny) { miny = ya; }\n    if (ya > maxy) { maxy = ya; }\n    if (yc < miny) { miny = yc; }\n    if (yc > maxy) { maxy = yc; }\n\n    t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n\n    if (t >= 0 && t <=1 ) {\n        // x = computeQuadraticBaseValue(t, xa, xb, xc);\n        y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n        if (y < miny) { miny = y; }\n        if (y > maxy) { maxy = y ; }\n\n    }\n\n    return {\n        minx: minx,\n        miny: miny,\n        maxx: maxx,\n        maxy: maxy\n    };\n\n};\n\n// compute the value for the quadratic bezier function at time=t\nfunction computeQuadraticBaseValue(t, a, b, c) {\n\n    var mt = 1 - t;\n\n    return mt * mt * a + 2 * mt * t * b + t * t * c;\n\n}\n\n// compute the value for the first derivative of the quadratic bezier function at time=t\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n\n    var t = -1,\n        denominator = a - 2 * b + c;\n\n    if (denominator !== 0) {\n        t = (a - b) / denominator;\n    }\n\n    return t;\n\n}\n\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\nexports.js2path = function(path, data, params) {\n\n    path.pathJS = data;\n\n    if (params.collapseRepeated) {\n        data = collapseRepeated(data);\n    }\n\n    path.attr('d').value = data.reduce(function(pathString, item) {\n        var strData = '';\n        if (item.data) {\n            strData = cleanupOutData(item.data, params, item.instruction);\n        }\n        return pathString += item.instruction + strData;\n    }, '');\n\n};\n\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\nfunction collapseRepeated(data) {\n\n    var prev,\n        prevIndex;\n\n    // copy an array and modifieds item to keep original data untouched\n    data = data.reduce(function(newPath, item) {\n        if (\n            prev && item.data &&\n            item.instruction == prev.instruction\n        ) {\n            // concat previous data with current\n            if (item.instruction != 'M') {\n                prev = newPath[prevIndex] = {\n                    instruction: prev.instruction,\n                    data: prev.data.concat(item.data),\n                    coords: item.coords,\n                    base: prev.base\n                };\n            } else {\n                prev.data = item.data;\n                prev.coords = item.coords;\n            }\n        } else {\n            newPath.push(item);\n            prev = item;\n            prevIndex = newPath.length - 1;\n        }\n\n        return newPath;\n    }, []);\n\n    return data;\n\n}\n\nfunction set(dest, source) {\n    dest[0] = source[source.length - 2];\n    dest[1] = source[source.length - 1];\n    return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\nexports.intersects = function(path1, path2) {\n    if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n\n    // Collect points of every subpath.\n    var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n        points2 = relative2absolute(path2).reduce(gatherPoints, []);\n\n    // Axis-aligned bounding box check.\n    if (points1.maxX <= points2.minX || points2.maxX <= points1.minX ||\n        points1.maxY <= points2.minY || points2.maxY <= points1.minY ||\n        points1.every(function (set1) {\n            return points2.every(function (set2) {\n                return set1[set1.maxX][0] <= set2[set2.minX][0] ||\n                    set2[set2.maxX][0] <= set1[set1.minX][0] ||\n                    set1[set1.maxY][1] <= set2[set2.minY][1] ||\n                    set2[set2.maxY][1] <= set1[set1.minY][1];\n            });\n        })\n    ) return false;\n\n    // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n    var hullNest1 = points1.map(convexHull),\n        hullNest2 = points2.map(convexHull);\n\n    // Check intersection of every subpath of the first path with every subpath of the second.\n    return hullNest1.some(function(hull1) {\n        if (hull1.length < 3) return false;\n\n        return hullNest2.some(function(hull2) {\n            if (hull2.length < 3) return false;\n\n            var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n                direction = minus(simplex[0]); // set the direction to point towards the origin\n\n            var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n            while (true) {\n                if (iterations-- == 0) {\n                    console.error('Error: infinite loop while processing mergePaths plugin.');\n                    return true; // true is the safe value that means “do nothing with paths”\n                }\n                // add a new point\n                simplex.push(getSupport(hull1, hull2, direction));\n                // see if the new point was on the correct side of the origin\n                if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n                // process the simplex\n                if (processSimplex(simplex, direction)) return true;\n            }\n        });\n    });\n\n    function getSupport(a, b, direction) {\n        return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n    }\n\n    // Computes farthest polygon point in particular direction.\n    // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n    // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n    function supportPoint(polygon, direction) {\n        var index = direction[1] >= 0 ?\n                direction[0] < 0 ? polygon.maxY : polygon.maxX :\n                direction[0] < 0 ? polygon.minX : polygon.minY,\n            max = -Infinity,\n            value;\n        while ((value = dot(polygon[index], direction)) > max) {\n            max = value;\n            index = ++index % polygon.length;\n        }\n        return polygon[(index || polygon.length) - 1];\n    }\n};\n\nfunction processSimplex(simplex, direction) {\n    /* jshint -W004 */\n\n    // we only need to handle to 1-simplex and 2-simplex\n    if (simplex.length == 2) { // 1-simplex\n        var a = simplex[1],\n            b = simplex[0],\n            AO = minus(simplex[1]),\n            AB = sub(b, a);\n        // AO is in the same direction as AB\n        if (dot(AO, AB) > 0) {\n            // get the vector perpendicular to AB facing O\n            set(direction, orth(AB, a));\n        } else {\n            set(direction, AO);\n            // only A remains in the simplex\n            simplex.shift();\n        }\n    } else { // 2-simplex\n        var a = simplex[2], // [a, b, c] = simplex\n            b = simplex[1],\n            c = simplex[0],\n            AB = sub(b, a),\n            AC = sub(c, a),\n            AO = minus(a),\n            ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n            ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n        if (dot(ACB, AO) > 0) {\n            if (dot(AB, AO) > 0) { // region 4\n                set(direction, ACB);\n                simplex.shift(); // simplex = [b, a]\n            } else { // region 5\n                set(direction, AO);\n                simplex.splice(0, 2); // simplex = [a]\n            }\n        } else if (dot(ABC, AO) > 0) {\n            if (dot(AC, AO) > 0) { // region 6\n                set(direction, ABC);\n                simplex.splice(1, 1); // simplex = [c, a]\n            } else { // region 5 (again)\n                set(direction, AO);\n                simplex.splice(0, 2); // simplex = [a]\n            }\n        } else // region 7\n            return true;\n    }\n    return false;\n}\n\nfunction minus(v) {\n    return [-v[0], -v[1]];\n}\n\nfunction sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction dot(v1, v2) {\n    return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\nfunction orth(v, from) {\n    var o = [-v[1], v[0]];\n    return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\nfunction gatherPoints(points, item, index, path) {\n\n    var subPath = points.length && points[points.length - 1],\n        prev = index && path[index - 1],\n        basePoint = subPath.length && subPath[subPath.length - 1],\n        data = item.data,\n        ctrlPoint = basePoint;\n\n    switch (item.instruction) {\n        case 'M':\n            points.push(subPath = []);\n            break;\n        case 'H':\n            addPoint(subPath, [data[0], basePoint[1]]);\n            break;\n        case 'V':\n            addPoint(subPath, [basePoint[0], data[0]]);\n            break;\n        case 'Q':\n            addPoint(subPath, data.slice(0, 2));\n            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n            break;\n        case 'T':\n            if (prev.instruction == 'Q' || prev.instruction == 'T') {\n                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n                addPoint(subPath, ctrlPoint);\n                prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n            }\n            break;\n        case 'C':\n            // Approximate quibic Bezier curve with middle points between control points\n            addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n            addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n            break;\n        case 'S':\n            if (prev.instruction == 'C' || prev.instruction == 'S') {\n                addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n            }\n            addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1]+ data[1])]);\n            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n            break;\n        case 'A':\n            // Convert the arc to bezier curves and use the same approximation\n            var curves = a2c.apply(0, basePoint.concat(data));\n            for (var cData; (cData = curves.splice(0,6).map(toAbsolute)).length;) {\n                addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n                addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n                addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n                if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n            }\n            break;\n    }\n    // Save final command coordinates\n    if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n    return points;\n\n    function toAbsolute(n, i) { return n + basePoint[i % 2] }\n\n    // Writes data about the extreme points on each axle\n    function addPoint(path, point) {\n        if (!path.length || point[1] > path[path.maxY][1]) {\n            path.maxY = path.length;\n            points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n        }\n        if (!path.length || point[0] > path[path.maxX][0]) {\n            path.maxX = path.length;\n            points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n        }\n        if (!path.length || point[1] < path[path.minY][1]) {\n            path.minY = path.length;\n            points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n        }\n        if (!path.length || point[0] < path[path.minX][0]) {\n            path.minX = path.length;\n            points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n        }\n        path.push(point);\n    }\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\nfunction convexHull(points) {\n    /* jshint -W004 */\n\n    points.sort(function(a, b) {\n        return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n    });\n\n    var lower = [],\n        minY = 0,\n        bottom = 0;\n    for (var i = 0; i < points.length; i++) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n            lower.pop();\n        }\n        if (points[i][1] < points[minY][1]) {\n            minY = i;\n            bottom = lower.length;\n        }\n        lower.push(points[i]);\n    }\n\n    var upper = [],\n        maxY = points.length - 1,\n        top = 0;\n    for (var i = points.length; i--;) {\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n            upper.pop();\n        }\n        if (points[i][1] > points[maxY][1]) {\n            maxY = i;\n            top = upper.length;\n        }\n        upper.push(points[i]);\n    }\n\n    // last points are equal to starting points of the other part\n    upper.pop();\n    lower.pop();\n\n    var hull = lower.concat(upper);\n\n    hull.minX = 0; // by sorting\n    hull.maxX = lower.length;\n    hull.minY = bottom;\n    hull.maxY = (lower.length + top) % hull.length;\n\n    return hull;\n}\n\nfunction cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n\n// jshint ignore: start\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n    // for more information of where this Math came from visit:\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n    var _120 = Math.PI * 120 / 180,\n        rad = Math.PI / 180 * (+angle || 0),\n        res = [],\n        rotateX = function(x, y, rad) { return x * Math.cos(rad) - y * Math.sin(rad) },\n        rotateY = function(x, y, rad) { return x * Math.sin(rad) + y * Math.cos(rad) };\n    if (!recursive) {\n        x1 = rotateX(x1, y1, -rad);\n        y1 = rotateY(x1, y1, -rad);\n        x2 = rotateX(x2, y2, -rad);\n        y2 = rotateY(x2, y2, -rad);\n        var x = (x1 - x2) / 2,\n            y = (y1 - y2) / 2;\n        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            rx = h * rx;\n            ry = h * ry;\n        }\n        var rx2 = rx * rx,\n            ry2 = ry * ry,\n            k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n            cx = k * rx * y / ry + (x1 + x2) / 2,\n            cy = k * -ry * x / rx + (y1 + y2) / 2,\n            f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n            f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n\n        f1 = x1 < cx ? Math.PI - f1 : f1;\n        f2 = x2 < cx ? Math.PI - f2 : f2;\n        f1 < 0 && (f1 = Math.PI * 2 + f1);\n        f2 < 0 && (f2 = Math.PI * 2 + f2);\n        if (sweep_flag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweep_flag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    } else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n    }\n    var df = f2 - f1;\n    if (Math.abs(df) > _120) {\n        var f2old = f2,\n            x2old = x2,\n            y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * Math.cos(f2);\n        y2 = cy + ry * Math.sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    var c1 = Math.cos(f1),\n        s1 = Math.sin(f1),\n        c2 = Math.cos(f2),\n        s2 = Math.sin(f2),\n        t = Math.tan(df / 4),\n        hx = 4 / 3 * rx * t,\n        hy = 4 / 3 * ry * t,\n        m = [\n            - hx * s1, hy * c1,\n            x2 + hx * s2 - x1, y2 - hy * c2 - y1,\n            x2 - x1, y2 - y1\n        ];\n    if (recursive) {\n        return m.concat(res);\n    } else {\n        res = m.concat(res);\n        var newres = [];\n        for (var i = 0, n = res.length; i < n; i++) {\n            newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n        }\n        return newres;\n    }\n}\n// jshint ignore: end\n"]},"metadata":{},"sourceType":"script"}