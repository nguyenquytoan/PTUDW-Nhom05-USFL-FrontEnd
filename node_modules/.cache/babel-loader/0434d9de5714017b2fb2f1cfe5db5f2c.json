{"ast":null,"code":"/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent brace style for blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/brace-style\"\n    },\n    schema: [{\n      enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n      sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n      blockSameLine: \"Statement inside of curly braces should be on next line.\",\n      nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n      singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n      sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"1tbs\",\n          params = context.options[1] || {},\n          sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Fixes a place where a newline unexpectedly appears\n     * @param {Token} firstToken The token before the unexpected newline\n     * @param {Token} secondToken The token after the unexpected newline\n     * @returns {Function} A fixer function to remove the newlines between the tokens\n     */\n\n    function removeNewlineBetween(firstToken, secondToken) {\n      const textRange = [firstToken.range[1], secondToken.range[0]];\n      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]); // Don't do a fix if there is a comment between the tokens\n\n      if (textBetween.trim()) {\n        return null;\n      }\n\n      return fixer => fixer.replaceTextRange(textRange, \" \");\n    }\n    /**\n     * Validates a pair of curly brackets based on the user's config\n     * @param {Token} openingCurly The opening curly bracket\n     * @param {Token} closingCurly The closing curly bracket\n     * @returns {void}\n     */\n\n\n    function validateCurlyPair(openingCurly, closingCurly) {\n      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n      if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n        context.report({\n          node: openingCurly,\n          messageId: \"nextLineOpen\",\n          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n        });\n      }\n\n      if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"sameLineOpen\",\n          fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n        });\n      }\n\n      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"blockSameLine\",\n          fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n        });\n      }\n\n      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n        context.report({\n          node: closingCurly,\n          messageId: \"singleLineClose\",\n          fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n        });\n      }\n    }\n    /**\n     * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n     * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n     * @returns {void}\n     */\n\n\n    function validateCurlyBeforeKeyword(curlyToken) {\n      const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n      if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"nextLineClose\",\n          fix: removeNewlineBetween(curlyToken, keywordToken)\n        });\n      }\n\n      if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"sameLineClose\",\n          fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BlockStatement(node) {\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n        }\n      },\n\n      ClassBody(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n      },\n\n      SwitchStatement(node) {\n        const closingCurly = sourceCode.getLastToken(node);\n        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n        validateCurlyPair(openingCurly, closingCurly);\n      },\n\n      IfStatement(node) {\n        if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n          // Handle the keyword after the `if` block (before `else`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n        }\n      },\n\n      TryStatement(node) {\n        // Handle the keyword after the `try` block (before `catch` or `finally`)\n        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n        if (node.handler && node.finalizer) {\n          // Handle the keyword after the `catch` block (before `finally`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/brace-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","properties","allowSingleLine","default","additionalProperties","fixable","messages","nextLineOpen","sameLineOpen","blockSameLine","nextLineClose","singleLineClose","sameLineClose","create","context","style","options","params","sourceCode","getSourceCode","removeNewlineBetween","firstToken","secondToken","textRange","range","textBetween","text","slice","trim","fixer","replaceTextRange","validateCurlyPair","openingCurly","closingCurly","tokenBeforeOpeningCurly","getTokenBefore","tokenAfterOpeningCurly","getTokenAfter","tokenBeforeClosingCurly","singleLineException","isTokenOnSameLine","report","node","messageId","fix","insertTextBefore","insertTextAfter","validateCurlyBeforeKeyword","curlyToken","keywordToken","BlockStatement","STATEMENT_LIST_PARENTS","has","parent","getFirstToken","getLastToken","ClassBody","SwitchStatement","cases","length","IfStatement","consequent","alternate","TryStatement","block","handler","finalizer","body"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/brace-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Fixes a place where a newline unexpectedly appears\n         * @param {Token} firstToken The token before the unexpected newline\n         * @param {Token} secondToken The token after the unexpected newline\n         * @returns {Function} A fixer function to remove the newlines between the tokens\n         */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n         * Validates a pair of curly brackets based on the user's config\n         * @param {Token} openingCurly The opening curly bracket\n         * @param {Token} closingCurly The closing curly bracket\n         * @returns {void}\n         */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"nextLineOpen\",\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"sameLineOpen\",\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"blockSameLine\",\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    messageId: \"singleLineClose\",\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n         * @returns {void}\n         */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"nextLineClose\",\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"sameLineClose\",\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}