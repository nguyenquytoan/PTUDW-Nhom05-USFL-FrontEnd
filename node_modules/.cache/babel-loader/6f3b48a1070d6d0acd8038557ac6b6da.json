{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.mjs';\nimport { assert } from './assert.mjs';\nimport { getFriendlyURL } from './getFriendlyURL.mjs';\nimport { logger } from './logger.mjs';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.mjs';\nimport { pluginEvents } from '../models/pluginEvents.mjs';\nimport { pluginUtils } from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\n\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions\n} = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'write'\n  });\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url)\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` + `not be cached.`, responseToCache);\n    }\n\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n  const updatePlugins = pluginUtils.filter(plugins, pluginEvents.CACHE_DID_UPDATE);\n  let oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n    cacheName,\n    matchOptions,\n    request: effectiveRequest\n  }) : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest\n    });\n  }\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = []\n}) => {\n  const cache = await caches.open(cacheName);\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'read'\n  });\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED].call(plugin, {\n        cacheName,\n        event,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst _isResponseSafeToCache = async ({\n  request,\n  response,\n  event,\n  plugins\n}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE].call(plugin, {\n        request,\n        response: responseToCache,\n        event\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n        }\n      }\n    }\n\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst _getEffectiveRequest = async ({\n  request,\n  mode,\n  plugins\n}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n  let effectiveRequest = request;\n\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(plugin, {\n      mode,\n      request: effectiveRequest\n    });\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-core/_private/cacheWrapper.mjs"],"names":["WorkboxError","assert","getFriendlyURL","logger","executeQuotaErrorCallbacks","pluginEvents","pluginUtils","putWrapper","cacheName","request","response","event","plugins","matchOptions","process","env","NODE_ENV","method","url","effectiveRequest","_getEffectiveRequest","mode","error","responseToCache","_isResponseSafeToCache","debug","cache","caches","open","updatePlugins","filter","CACHE_DID_UPDATE","oldResponse","length","matchWrapper","put","name","plugin","call","newResponse","cachedResponse","match","CACHED_RESPONSE_WILL_BE_USED","isInstance","Response","moduleName","funcName","isReturnValueProblem","pluginsUsed","CACHE_WILL_UPDATE","status","warn","cacheKeyWillBeUsedPlugins","CACHE_KEY_WILL_BE_USED","Request","cacheWrapper"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport {executeQuotaErrorCallbacks} from './executeQuotaErrorCallbacks.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method,\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'write'});\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url),\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest,\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n      `not be cached.`, responseToCache);\n    }\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\n      null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'read'});\n\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\n        plugin, {mode, request: effectiveRequest});\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true,\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n"]},"metadata":{},"sourceType":"module"}