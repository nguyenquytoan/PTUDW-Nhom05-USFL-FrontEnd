{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _path = _interopRequireDefault(require('path'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _types = require('@babel/types');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestWriteFile = global[Symbol.for('jest-native-write-file')] || _fs.default.writeFileSync;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || _fs.default.readFileSync;\n\nconst saveInlineSnapshots = (snapshots, prettier, babelTraverse) => {\n  if (!prettier) {\n    throw new Error(`Jest: Inline Snapshots requires Prettier.\\n` + `Please ensure \"prettier\" is installed in your project.`);\n  } // Custom parser API was added in 1.5.0\n\n\n  if (_semver.default.lt(prettier.version, '1.5.0')) {\n    throw new Error(`Jest: Inline Snapshots require prettier>=1.5.0.\\n` + `Please upgrade \"prettier\".`);\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  var _arr = Object.keys(snapshotsByFile);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    const sourceFilePath = _arr[_i];\n    saveSnapshotsForFile(snapshotsByFile[sourceFilePath], sourceFilePath, prettier, babelTraverse);\n  }\n};\n\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nconst saveSnapshotsForFile = (snapshots, sourceFilePath, prettier, babelTraverse) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n\n  const config = prettier.resolveConfig ? prettier.resolveConfig.sync(sourceFilePath, {\n    editorconfig: true\n  }) : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n\n  const inferredParser = prettier.getFileInfo ? prettier.getFileInfo.sync(sourceFilePath).inferredParser : config && config.parser || simpleDetectParser(sourceFilePath); // Insert snapshots using the custom parser API. After insertion, the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation).\n\n  const newSourceFile = prettier.format(sourceFile, _objectSpread({}, config, {\n    filepath: sourceFilePath,\n    parser: createInsertionParser(snapshots, inferredParser, babelTraverse)\n  })); // Format the snapshots using the custom parser API.\n\n  const formattedNewSourceFile = prettier.format(newSourceFile, _objectSpread({}, config, {\n    filepath: sourceFilePath,\n    parser: createFormattingParser(inferredParser, babelTraverse)\n  }));\n\n  if (formattedNewSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, formattedNewSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots => snapshots.reduce((object, inlineSnapshot) => {\n  const key = createKey(inlineSnapshot);\n  return _objectSpread({}, object, {\n    [key]: (object[key] || []).concat(inlineSnapshot)\n  });\n}, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({\n  frame: {\n    line,\n    column\n  }\n}) => typeof line === 'number' && typeof column === 'number' ? `${line}:${column - 1}` : '');\nconst groupSnapshotsByFile = groupSnapshotsBy(({\n  frame: {\n    file\n  }\n}) => file);\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-identation of inline snapshots.\n\n  if (lines.length >= 2 && lines[1].startsWith(indentation.repeat(numIndents + 1))) {\n    return snapshot;\n  }\n\n  return lines.map((line, index) => {\n    if (index === 0) {\n      // First line is either a 1-line snapshot or a blank line.\n      return line;\n    } else if (index !== lines.length - 1) {\n      // Do not indent empty lines.\n      if (line === '') {\n        return line;\n      } // Not last line, indent one level deeper than expect call.\n\n\n      return indentation.repeat(numIndents + 1) + line;\n    } else {\n      // The last line should be placed on the same level as the expect call.\n      return indentation.repeat(numIndents) + line;\n    }\n  }).join('\\n');\n};\n\nconst getAst = (parsers, inferredParser, text) => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = parsers[inferredParser](text);\n\n  if (ast.type !== 'File') {\n    ast = (0, _types.file)(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n}; // This parser inserts snapshots into the AST.\n\n\nconst createInsertionParser = (snapshots, inferredParser, babelTraverse) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({\n    snapshot\n  }) => snapshot));\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({\n      node: {\n        arguments: args,\n        callee\n      }\n    }) {\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier') {\n        return;\n      }\n\n      const _callee$property$loc$ = callee.property.loc.start,\n            line = _callee$property$loc$.line,\n            column = _callee$property$loc$.column;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error('Jest: Multiple inline snapshots for the same call are not supported.');\n      }\n\n      const snapshotIndex = args.findIndex(({\n        type\n      }) => type === 'TemplateLiteral');\n      const values = snapshotsForFrame.map(({\n        snapshot\n      }) => {\n        remainingSnapshots.delete(snapshot);\n        return (0, _types.templateLiteral)([(0, _types.templateElement)({\n          raw: (0, _utils.escapeBacktickString)(snapshot)\n        })], []);\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(`Jest: Couldn't locate all inline snapshots.`);\n  }\n\n  return ast;\n}; // This parser formats snapshots to the correct indentation.\n\n\nconst createFormattingParser = (inferredParser, babelTraverse) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({\n      node: {\n        arguments: args,\n        callee\n      }\n    }) {\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || callee.property.name !== 'toMatchInlineSnapshot' || !callee.loc || callee.computed) {\n        return;\n      }\n\n      let snapshotIndex;\n      let snapshot;\n\n      for (let i = 0; i < args.length; i++) {\n        const node = args[i];\n\n        if (node.type === 'TemplateLiteral') {\n          snapshotIndex = i;\n          snapshot = node.quasis[0].value.raw;\n        }\n      }\n\n      if (snapshot === undefined || snapshotIndex === undefined) {\n        return;\n      }\n\n      const useSpaces = !options.useTabs;\n      snapshot = indent(snapshot, Math.ceil(useSpaces ? callee.loc.start.column / options.tabWidth : callee.loc.start.column / 2 // Each tab is 2 characters.\n      ), useSpaces ? ' '.repeat(options.tabWidth) : '\\t');\n      const replacementNode = (0, _types.templateLiteral)([(0, _types.templateElement)({\n        raw: snapshot\n      })], []);\n      args[snapshotIndex] = replacementNode;\n    }\n\n  });\n  return ast;\n};\n\nconst simpleDetectParser = filePath => {\n  const extname = _path.default.extname(filePath);\n\n  if (/tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babylon';\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-snapshot/build/inline_snapshots.js"],"names":["Object","defineProperty","exports","value","saveInlineSnapshots","_fs","_interopRequireDefault","require","_path","_semver","_types","_utils","obj","__esModule","default","Symbol","global","jestWriteFile","for","writeFileSync","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","jestReadFile","readFileSync","snapshots","prettier","babelTraverse","Error","lt","version","snapshotsByFile","groupSnapshotsByFile","_arr","_i","sourceFilePath","saveSnapshotsForFile","sourceFile","config","resolveConfig","sync","editorconfig","inferredParser","getFileInfo","parser","simpleDetectParser","newSourceFile","format","filepath","createInsertionParser","formattedNewSourceFile","createFormattingParser","groupSnapshotsBy","createKey","reduce","object","inlineSnapshot","groupSnapshotsByFrame","frame","line","column","file","indent","snapshot","numIndents","indentation","lines","split","startsWith","repeat","map","index","join","getAst","parsers","text","ast","type","comments","tokens","program","options","groupedSnapshots","remainingSnapshots","Set","CallExpression","node","args","callee","property","_callee$property$loc$","loc","start","snapshotsForFrame","snapshotIndex","findIndex","values","delete","templateLiteral","templateElement","raw","escapeBacktickString","replacementNode","push","size","name","computed","quasis","undefined","useSpaces","useTabs","Math","ceil","tabWidth","filePath","extname","test"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _path = _interopRequireDefault(require('path'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _types = require('@babel/types');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestWriteFile =\n  global[Symbol.for('jest-native-write-file')] || _fs.default.writeFileSync;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestReadFile =\n  global[Symbol.for('jest-native-read-file')] || _fs.default.readFileSync;\n\nconst saveInlineSnapshots = (snapshots, prettier, babelTraverse) => {\n  if (!prettier) {\n    throw new Error(\n      `Jest: Inline Snapshots requires Prettier.\\n` +\n        `Please ensure \"prettier\" is installed in your project.`\n    );\n  } // Custom parser API was added in 1.5.0\n\n  if (_semver.default.lt(prettier.version, '1.5.0')) {\n    throw new Error(\n      `Jest: Inline Snapshots require prettier>=1.5.0.\\n` +\n        `Please upgrade \"prettier\".`\n    );\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  var _arr = Object.keys(snapshotsByFile);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    const sourceFilePath = _arr[_i];\n    saveSnapshotsForFile(\n      snapshotsByFile[sourceFilePath],\n      sourceFilePath,\n      prettier,\n      babelTraverse\n    );\n  }\n};\n\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nconst saveSnapshotsForFile = (\n  snapshots,\n  sourceFilePath,\n  prettier,\n  babelTraverse\n) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n\n  const config = prettier.resolveConfig\n    ? prettier.resolveConfig.sync(sourceFilePath, {\n        editorconfig: true\n      })\n    : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n\n  const inferredParser = prettier.getFileInfo\n    ? prettier.getFileInfo.sync(sourceFilePath).inferredParser\n    : (config && config.parser) || simpleDetectParser(sourceFilePath); // Insert snapshots using the custom parser API. After insertion, the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation).\n\n  const newSourceFile = prettier.format(\n    sourceFile,\n    _objectSpread({}, config, {\n      filepath: sourceFilePath,\n      parser: createInsertionParser(snapshots, inferredParser, babelTraverse)\n    })\n  ); // Format the snapshots using the custom parser API.\n\n  const formattedNewSourceFile = prettier.format(\n    newSourceFile,\n    _objectSpread({}, config, {\n      filepath: sourceFilePath,\n      parser: createFormattingParser(inferredParser, babelTraverse)\n    })\n  );\n\n  if (formattedNewSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, formattedNewSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots =>\n  snapshots.reduce((object, inlineSnapshot) => {\n    const key = createKey(inlineSnapshot);\n    return _objectSpread({}, object, {\n      [key]: (object[key] || []).concat(inlineSnapshot)\n    });\n  }, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({frame: {line, column}}) =>\n  typeof line === 'number' && typeof column === 'number'\n    ? `${line}:${column - 1}`\n    : ''\n);\nconst groupSnapshotsByFile = groupSnapshotsBy(({frame: {file}}) => file);\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-identation of inline snapshots.\n\n  if (\n    lines.length >= 2 &&\n    lines[1].startsWith(indentation.repeat(numIndents + 1))\n  ) {\n    return snapshot;\n  }\n\n  return lines\n    .map((line, index) => {\n      if (index === 0) {\n        // First line is either a 1-line snapshot or a blank line.\n        return line;\n      } else if (index !== lines.length - 1) {\n        // Do not indent empty lines.\n        if (line === '') {\n          return line;\n        } // Not last line, indent one level deeper than expect call.\n\n        return indentation.repeat(numIndents + 1) + line;\n      } else {\n        // The last line should be placed on the same level as the expect call.\n        return indentation.repeat(numIndents) + line;\n      }\n    })\n    .join('\\n');\n};\n\nconst getAst = (parsers, inferredParser, text) => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = parsers[inferredParser](text);\n\n  if (ast.type !== 'File') {\n    ast = (0, _types.file)(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n}; // This parser inserts snapshots into the AST.\n\nconst createInsertionParser = (snapshots, inferredParser, babelTraverse) => (\n  text,\n  parsers,\n  options\n) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({snapshot}) => snapshot));\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({node: {arguments: args, callee}}) {\n      if (\n        callee.type !== 'MemberExpression' ||\n        callee.property.type !== 'Identifier'\n      ) {\n        return;\n      }\n\n      const _callee$property$loc$ = callee.property.loc.start,\n        line = _callee$property$loc$.line,\n        column = _callee$property$loc$.column;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error(\n          'Jest: Multiple inline snapshots for the same call are not supported.'\n        );\n      }\n\n      const snapshotIndex = args.findIndex(\n        ({type}) => type === 'TemplateLiteral'\n      );\n      const values = snapshotsForFrame.map(({snapshot}) => {\n        remainingSnapshots.delete(snapshot);\n        return (0, _types.templateLiteral)(\n          [\n            (0, _types.templateElement)({\n              raw: (0, _utils.escapeBacktickString)(snapshot)\n            })\n          ],\n          []\n        );\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(`Jest: Couldn't locate all inline snapshots.`);\n  }\n\n  return ast;\n}; // This parser formats snapshots to the correct indentation.\n\nconst createFormattingParser = (inferredParser, babelTraverse) => (\n  text,\n  parsers,\n  options\n) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({node: {arguments: args, callee}}) {\n      if (\n        callee.type !== 'MemberExpression' ||\n        callee.property.type !== 'Identifier' ||\n        callee.property.name !== 'toMatchInlineSnapshot' ||\n        !callee.loc ||\n        callee.computed\n      ) {\n        return;\n      }\n\n      let snapshotIndex;\n      let snapshot;\n\n      for (let i = 0; i < args.length; i++) {\n        const node = args[i];\n\n        if (node.type === 'TemplateLiteral') {\n          snapshotIndex = i;\n          snapshot = node.quasis[0].value.raw;\n        }\n      }\n\n      if (snapshot === undefined || snapshotIndex === undefined) {\n        return;\n      }\n\n      const useSpaces = !options.useTabs;\n      snapshot = indent(\n        snapshot,\n        Math.ceil(\n          useSpaces\n            ? callee.loc.start.column / options.tabWidth\n            : callee.loc.start.column / 2 // Each tab is 2 characters.\n        ),\n        useSpaces ? ' '.repeat(options.tabWidth) : '\\t'\n      );\n      const replacementNode = (0, _types.templateLiteral)(\n        [\n          (0, _types.templateElement)({\n            raw: snapshot\n          })\n        ],\n        []\n      );\n      args[snapshotIndex] = replacementNode;\n    }\n  });\n  return ast;\n};\n\nconst simpleDetectParser = filePath => {\n  const extname = _path.default.extname(filePath);\n\n  if (/tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babylon';\n};\n"]},"metadata":{},"sourceType":"script"}