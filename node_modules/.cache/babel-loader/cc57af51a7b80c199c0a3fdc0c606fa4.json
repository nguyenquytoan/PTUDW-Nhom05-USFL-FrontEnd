{"ast":null,"code":"/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after semicolons\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let requireSpaceBefore = false,\n        requireSpaceAfter = true;\n\n    if (typeof config === \"object\") {\n      requireSpaceBefore = config.before;\n      requireSpaceAfter = config.after;\n    }\n    /**\n     * Checks if a given token has leading whitespace.\n     * @param {Object} token The token to check.\n     * @returns {boolean} True if the given token has leading space, false if not.\n     */\n\n\n    function hasLeadingSpace(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n    }\n    /**\n     * Checks if a given token has trailing whitespace.\n     * @param {Object} token The token to check.\n     * @returns {boolean} True if the given token has trailing space, false if not.\n     */\n\n\n    function hasTrailingSpace(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n    }\n    /**\n     * Checks if the given token is the last token in its line.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is the last in its line.\n     */\n\n\n    function isLastTokenInCurrentLine(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n    }\n    /**\n     * Checks if the given token is the first token in its line\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is the first in its line.\n     */\n\n\n    function isFirstTokenInCurrentLine(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n    }\n    /**\n     * Checks if the next token of a given token is a closing parenthesis.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n     */\n\n\n    function isBeforeClosingParen(token) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);\n    }\n    /**\n     * Reports if the given token has invalid spacing.\n     * @param {Token} token The semicolon token to check.\n     * @param {ASTNode} node The corresponding node of the token.\n     * @returns {void}\n     */\n\n\n    function checkSemicolonSpacing(token, node) {\n      if (astUtils.isSemicolonToken(token)) {\n        const location = token.loc.start;\n\n        if (hasLeadingSpace(token)) {\n          if (!requireSpaceBefore) {\n            context.report({\n              node,\n              loc: location,\n              message: \"Unexpected whitespace before semicolon.\",\n\n              fix(fixer) {\n                const tokenBefore = sourceCode.getTokenBefore(token);\n                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n              }\n\n            });\n          }\n        } else {\n          if (requireSpaceBefore) {\n            context.report({\n              node,\n              loc: location,\n              message: \"Missing whitespace before semicolon.\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n\n            });\n          }\n        }\n\n        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n          if (hasTrailingSpace(token)) {\n            if (!requireSpaceAfter) {\n              context.report({\n                node,\n                loc: location,\n                message: \"Unexpected whitespace after semicolon.\",\n\n                fix(fixer) {\n                  const tokenAfter = sourceCode.getTokenAfter(token);\n                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n\n              });\n            }\n          } else {\n            if (requireSpaceAfter) {\n              context.report({\n                node,\n                loc: location,\n                message: \"Missing whitespace after semicolon.\",\n\n                fix(fixer) {\n                  return fixer.insertTextAfter(token, \" \");\n                }\n\n              });\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n\n    function checkNode(node) {\n      const token = sourceCode.getLastToken(node);\n      checkSemicolonSpacing(token, node);\n    }\n\n    return {\n      VariableDeclaration: checkNode,\n      ExpressionStatement: checkNode,\n      BreakStatement: checkNode,\n      ContinueStatement: checkNode,\n      DebuggerStatement: checkNode,\n      ReturnStatement: checkNode,\n      ThrowStatement: checkNode,\n      ImportDeclaration: checkNode,\n      ExportNamedDeclaration: checkNode,\n      ExportAllDeclaration: checkNode,\n      ExportDefaultDeclaration: checkNode,\n\n      ForStatement(node) {\n        if (node.init) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n        }\n\n        if (node.test) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/semi-spacing.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","before","default","after","additionalProperties","create","context","config","options","sourceCode","getSourceCode","requireSpaceBefore","requireSpaceAfter","hasLeadingSpace","token","tokenBefore","getTokenBefore","isTokenOnSameLine","isSpaceBetweenTokens","hasTrailingSpace","tokenAfter","getTokenAfter","isLastTokenInCurrentLine","isFirstTokenInCurrentLine","isBeforeClosingParen","nextToken","isClosingBraceToken","isClosingParenToken","checkSemicolonSpacing","node","isSemicolonToken","location","loc","start","report","message","fix","fixer","removeRange","range","insertTextBefore","insertTextAfter","checkNode","getLastToken","VariableDeclaration","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","ReturnStatement","ThrowStatement","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration","ExportDefaultDeclaration","ForStatement","init","test"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let requireSpaceBefore = false,\n            requireSpaceAfter = true;\n\n        if (typeof config === \"object\") {\n            requireSpaceBefore = config.before;\n            requireSpaceAfter = config.after;\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\n        }\n\n        /**\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            if (astUtils.isSemicolonToken(token)) {\n                const location = token.loc.start;\n\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Unexpected whitespace before semicolon.\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(token);\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Missing whitespace before semicolon.\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Unexpected whitespace after semicolon.\",\n                                fix(fixer) {\n                                    const tokenAfter = sourceCode.getTokenAfter(token);\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Missing whitespace after semicolon.\",\n                                fix(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            const token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration: checkNode,\n            ExportAllDeclaration: checkNode,\n            ExportDefaultDeclaration: checkNode,\n            ForStatement(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}