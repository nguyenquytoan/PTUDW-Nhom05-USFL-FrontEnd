{"ast":null,"code":"/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require destructuring from arrays and/or objects\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n    },\n    fixable: \"code\",\n    schema: [{\n      /*\n       * old support {array: Boolean, object: Boolean}\n       * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n       */\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          VariableDeclarator: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          AssignmentExpression: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          array: {\n            type: \"boolean\"\n          },\n          object: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        enforceForRenamedProperties: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const enabledTypes = context.options[0];\n    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n    let normalizedOptions = {\n      VariableDeclarator: {\n        array: true,\n        object: true\n      },\n      AssignmentExpression: {\n        array: true,\n        object: true\n      }\n    };\n\n    if (enabledTypes) {\n      normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\" ? {\n        VariableDeclarator: enabledTypes,\n        AssignmentExpression: enabledTypes\n      } : enabledTypes;\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // eslint-disable-next-line jsdoc/require-description\n\n    /**\n     * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n     * @param {string} destructuringType \"array\" or \"object\"\n     * @returns {boolean} `true` if the destructuring type should be checked for the given node\n     */\n\n\n    function shouldCheck(nodeType, destructuringType) {\n      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];\n    }\n    /**\n     * Determines if the given node is accessing an array index\n     *\n     * This is used to differentiate array index access from object property\n     * access.\n     * @param {ASTNode} node the node to evaluate\n     * @returns {boolean} whether or not the node is an integer\n     */\n\n\n    function isArrayIndexAccess(node) {\n      return Number.isInteger(node.property.value);\n    }\n    /**\n     * Report that the given node should use destructuring\n     * @param {ASTNode} reportNode the node to report\n     * @param {string} type the type of destructuring that should have been done\n     * @param {Function|null} fix the fix function or null to pass to context.report\n     * @returns {void}\n     */\n\n\n    function report(reportNode, type, fix) {\n      context.report({\n        node: reportNode,\n        message: \"Use {{type}} destructuring.\",\n        data: {\n          type\n        },\n        fix\n      });\n    }\n    /**\n     * Determines if a node should be fixed into object destructuring\n     *\n     * The fixer only fixes the simplest case of object destructuring,\n     * like: `let x = a.x`;\n     *\n     * Assignment expression is not fixed.\n     * Array destructuring is not fixed.\n     * Renamed property is not fixed.\n     * @param {ASTNode} node the the node to evaluate\n     * @returns {boolean} whether or not the node should be fixed\n     */\n\n\n    function shouldFix(node) {\n      return node.type === \"VariableDeclarator\" && node.id.type === \"Identifier\" && node.init.type === \"MemberExpression\" && node.id.name === node.init.property.name;\n    }\n    /**\n     * Fix a node into object destructuring.\n     * This function only handles the simplest case of object destructuring,\n     * see {@link shouldFix}.\n     * @param {SourceCodeFixer} fixer the fixer object\n     * @param {ASTNode} node the node to be fixed.\n     * @returns {Object} a fix for the node\n     */\n\n\n    function fixIntoObjectDestructuring(fixer, node) {\n      const rightNode = node.init;\n      const sourceCode = context.getSourceCode();\n      return fixer.replaceText(node, `{${rightNode.property.name}} = ${sourceCode.getText(rightNode.object)}`);\n    }\n    /**\n     * Check that the `prefer-destructuring` rules are followed based on the\n     * given left- and right-hand side of the assignment.\n     *\n     * Pulled out into a separate method so that VariableDeclarators and\n     * AssignmentExpressions can share the same verification logic.\n     * @param {ASTNode} leftNode the left-hand side of the assignment\n     * @param {ASTNode} rightNode the right-hand side of the assignment\n     * @param {ASTNode} reportNode the node to report the error on\n     * @returns {void}\n     */\n\n\n    function performCheck(leftNode, rightNode, reportNode) {\n      if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n        return;\n      }\n\n      if (isArrayIndexAccess(rightNode)) {\n        if (shouldCheck(reportNode.type, \"array\")) {\n          report(reportNode, \"array\", null);\n        }\n\n        return;\n      }\n\n      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;\n\n      if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n        report(reportNode, \"object\", fix);\n        return;\n      }\n\n      if (shouldCheck(reportNode.type, \"object\")) {\n        const property = rightNode.property;\n\n        if (property.type === \"Literal\" && leftNode.name === property.value || property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed) {\n          report(reportNode, \"object\", fix);\n        }\n      }\n    }\n    /**\n     * Check if a given variable declarator is coming from an property access\n     * that should be using destructuring instead\n     * @param {ASTNode} node the variable declarator to check\n     * @returns {void}\n     */\n\n\n    function checkVariableDeclarator(node) {\n      // Skip if variable is declared without assignment\n      if (!node.init) {\n        return;\n      } // We only care about member expressions past this point\n\n\n      if (node.init.type !== \"MemberExpression\") {\n        return;\n      }\n\n      performCheck(node.id, node.init, node);\n    }\n    /**\n     * Run the `prefer-destructuring` check on an AssignmentExpression\n     * @param {ASTNode} node the AssignmentExpression node\n     * @returns {void}\n     */\n\n\n    function checkAssigmentExpression(node) {\n      if (node.operator === \"=\") {\n        performCheck(node.left, node.right, node);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator: checkVariableDeclarator,\n      AssignmentExpression: checkAssigmentExpression\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-destructuring.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","properties","VariableDeclarator","array","object","additionalProperties","AssignmentExpression","enforceForRenamedProperties","create","context","enabledTypes","options","normalizedOptions","shouldCheck","nodeType","destructuringType","isArrayIndexAccess","node","Number","isInteger","property","value","report","reportNode","fix","message","data","shouldFix","id","init","name","fixIntoObjectDestructuring","fixer","rightNode","sourceCode","getSourceCode","replaceText","getText","performCheck","leftNode","computed","checkVariableDeclarator","checkAssigmentExpression","operator","left","right"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require destructuring from arrays and/or objects\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n\n                /*\n                 * old support {array: Boolean, object: Boolean}\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                 */\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @param {Function|null} fix the fix function or null to pass to context.report\n         * @returns {void}\n         */\n        function report(reportNode, type, fix) {\n            context.report({\n                node: reportNode,\n                message: \"Use {{type}} destructuring.\",\n                data: { type },\n                fix\n            });\n        }\n\n        /**\n         * Determines if a node should be fixed into object destructuring\n         *\n         * The fixer only fixes the simplest case of object destructuring,\n         * like: `let x = a.x`;\n         *\n         * Assignment expression is not fixed.\n         * Array destructuring is not fixed.\n         * Renamed property is not fixed.\n         * @param {ASTNode} node the the node to evaluate\n         * @returns {boolean} whether or not the node should be fixed\n         */\n        function shouldFix(node) {\n            return node.type === \"VariableDeclarator\" &&\n                node.id.type === \"Identifier\" &&\n                node.init.type === \"MemberExpression\" &&\n                node.id.name === node.init.property.name;\n        }\n\n        /**\n         * Fix a node into object destructuring.\n         * This function only handles the simplest case of object destructuring,\n         * see {@link shouldFix}.\n         * @param {SourceCodeFixer} fixer the fixer object\n         * @param {ASTNode} node the node to be fixed.\n         * @returns {Object} a fix for the node\n         */\n        function fixIntoObjectDestructuring(fixer, node) {\n            const rightNode = node.init;\n            const sourceCode = context.getSourceCode();\n\n            return fixer.replaceText(\n                node,\n                `{${rightNode.property.name}} = ${sourceCode.getText(rightNode.object)}`\n            );\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\", null);\n                }\n                return;\n            }\n\n            const fix = shouldFix(reportNode)\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\n                : null;\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\", fix);\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if (\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\n                ) {\n                    report(reportNode, \"object\", fix);\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssigmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssigmentExpression\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}