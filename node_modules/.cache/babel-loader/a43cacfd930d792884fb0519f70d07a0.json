{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (nodes, opts) {\n  let family = [];\n  let last = null;\n  let i, max;\n  nodes.forEach((node, index, arr) => {\n    if (node.type === 'string' || node.type === 'function') {\n      family.push(node);\n    } else if (node.type === 'word') {\n      if (!last) {\n        last = {\n          type: 'word',\n          value: ''\n        };\n        family.push(last);\n      }\n\n      last.value += node.value;\n    } else if (node.type === 'space') {\n      if (last && index !== arr.length - 1) {\n        last.value += ' ';\n      }\n    } else {\n      last = null;\n    }\n  });\n  family = family.map(node => {\n    if (node.type === 'string') {\n      const isKeyword = regexKeyword.test(node.value);\n\n      if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {\n        return (0, _postcssValueParser.stringify)(node);\n      }\n\n      let escaped = escapeIdentifierSequence(node.value);\n\n      if (escaped.length < node.value.length + 2) {\n        return escaped;\n      }\n    }\n\n    return (0, _postcssValueParser.stringify)(node);\n  });\n\n  if (opts.removeAfterKeyword) {\n    for (i = 0, max = family.length; i < max; i += 1) {\n      if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {\n        family = family.slice(0, i + 1);\n        break;\n      }\n    }\n  }\n\n  if (opts.removeDuplicates) {\n    family = uniqs(family);\n  }\n\n  return [{\n    type: 'word',\n    value: family.join()\n  }];\n};\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _uniqs = require('./uniqs');\n\nvar _uniqs2 = _interopRequireDefault(_uniqs);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst uniqs = (0, _uniqs2.default)('monospace');\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];\n\nfunction makeArray(value, length) {\n  let array = [];\n\n  while (length--) {\n    array[length] = value;\n  }\n\n  return array;\n}\n\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\nfunction escape(string, escapeForString) {\n  let counter = 0;\n  let character = null;\n  let charCode = null;\n  let value = null;\n  let output = '';\n\n  while (counter < string.length) {\n    character = string.charAt(counter++);\n    charCode = character.charCodeAt(); // \\r is already tokenized away at this point\n    // `:` can be escaped as `\\:`, but that fails in IE < 8\n\n    if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n      value = '\\\\' + charCode.toString(16) + ' ';\n    } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {\n      value = '\\\\' + character;\n    } else {\n      value = character;\n    }\n\n    output += value;\n  }\n\n  if (!escapeForString) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    }\n\n    const firstChar = string.charAt(0);\n\n    if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  return output;\n}\n\nconst regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\nfunction escapeIdentifierSequence(string) {\n  let identifiers = string.split(regexWhitespace);\n  let index = 0;\n  let result = [];\n  let escapeResult;\n\n  while (index < identifiers.length) {\n    let subString = identifiers[index++];\n\n    if (subString === '') {\n      result.push(subString);\n      continue;\n    }\n\n    escapeResult = escape(subString, false);\n\n    if (regexIdentifierCharacter.test(subString)) {\n      // the font family name part consists of allowed characters exclusively\n      if (regexInvalidIdentifier.test(subString)) {\n        // the font family name part starts with two hyphens, a digit, or a\n        // hyphen followed by a digit\n        if (index === 1) {\n          // if this is the first item\n          result.push(escapeResult);\n        } else {\n          // if it’s not the first item, we can simply escape the space\n          // between the two identifiers to merge them into a single\n          // identifier rather than escaping the start characters of the\n          // second identifier\n          result[index - 2] += '\\\\';\n          result.push(escape(subString, true));\n        }\n      } else {\n        // the font family name part doesn’t start with two hyphens, a digit,\n        // or a hyphen followed by a digit\n        result.push(escapeResult);\n      }\n    } else {\n      // the font family name part contains invalid identifier characters\n      result.push(escapeResult);\n    }\n  }\n\n  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n    const spaceCount = $2.length;\n    const escapesNeeded = Math.floor(spaceCount / 2);\n    const array = makeArray('\\\\ ', escapesNeeded);\n\n    if (spaceCount % 2) {\n      array[escapesNeeded - 1] += '\\\\ ';\n    }\n\n    return ($1 || '') + ' ' + array.join(' ');\n  }); // Escape trailing spaces unless they’re already part of an escape\n\n  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n    result = result.replace(regexTrailingSpace, '\\\\ ');\n  }\n\n  if (regexSpaceAtStart.test(result)) {\n    result = '\\\\ ' + result.slice(1);\n  }\n\n  return result;\n}\n\n;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-minify-font-values/dist/lib/minify-family.js"],"names":["Object","defineProperty","exports","value","default","nodes","opts","family","last","i","max","forEach","node","index","arr","type","push","length","map","isKeyword","regexKeyword","test","removeQuotes","slice","_postcssValueParser","stringify","escaped","escapeIdentifierSequence","removeAfterKeyword","genericFontFamilykeywords","indexOf","toLowerCase","removeDuplicates","uniqs","join","require","_uniqs","_uniqs2","_interopRequireDefault","obj","__esModule","globalKeywords","makeArray","array","regexSimpleEscapeCharacters","escape","string","escapeForString","counter","character","charCode","output","charAt","charCodeAt","toString","firstChar","RegExp","concat","regexInvalidIdentifier","regexSpaceAtStart","regexWhitespace","regexIdentifierCharacter","regexConsecutiveSpaces","regexTrailingEscape","regexTrailingSpace","identifiers","split","result","escapeResult","subString","replace","$0","$1","$2","spaceCount","escapesNeeded","Math","floor","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (nodes, opts) {\n    let family = [];\n    let last = null;\n    let i, max;\n\n    nodes.forEach((node, index, arr) => {\n        if (node.type === 'string' || node.type === 'function') {\n            family.push(node);\n        } else if (node.type === 'word') {\n            if (!last) {\n                last = { type: 'word', value: '' };\n                family.push(last);\n            }\n\n            last.value += node.value;\n        } else if (node.type === 'space') {\n            if (last && index !== arr.length - 1) {\n                last.value += ' ';\n            }\n        } else {\n            last = null;\n        }\n    });\n\n    family = family.map(node => {\n        if (node.type === 'string') {\n            const isKeyword = regexKeyword.test(node.value);\n\n            if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {\n                return (0, _postcssValueParser.stringify)(node);\n            }\n\n            let escaped = escapeIdentifierSequence(node.value);\n\n            if (escaped.length < node.value.length + 2) {\n                return escaped;\n            }\n        }\n\n        return (0, _postcssValueParser.stringify)(node);\n    });\n\n    if (opts.removeAfterKeyword) {\n        for (i = 0, max = family.length; i < max; i += 1) {\n            if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {\n                family = family.slice(0, i + 1);\n                break;\n            }\n        }\n    }\n\n    if (opts.removeDuplicates) {\n        family = uniqs(family);\n    }\n\n    return [{\n        type: 'word',\n        value: family.join()\n    }];\n};\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _uniqs = require('./uniqs');\n\nvar _uniqs2 = _interopRequireDefault(_uniqs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst uniqs = (0, _uniqs2.default)('monospace');\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];\n\nfunction makeArray(value, length) {\n    let array = [];\n    while (length--) {\n        array[length] = value;\n    }\n    return array;\n}\n\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\nfunction escape(string, escapeForString) {\n    let counter = 0;\n    let character = null;\n    let charCode = null;\n    let value = null;\n    let output = '';\n\n    while (counter < string.length) {\n        character = string.charAt(counter++);\n        charCode = character.charCodeAt();\n\n        // \\r is already tokenized away at this point\n        // `:` can be escaped as `\\:`, but that fails in IE < 8\n        if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n            value = '\\\\' + charCode.toString(16) + ' ';\n        } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {\n            value = '\\\\' + character;\n        } else {\n            value = character;\n        }\n\n        output += value;\n    }\n\n    if (!escapeForString) {\n        if (/^-[-\\d]/.test(output)) {\n            output = '\\\\-' + output.slice(1);\n        }\n\n        const firstChar = string.charAt(0);\n\n        if (/\\d/.test(firstChar)) {\n            output = '\\\\3' + firstChar + ' ' + output.slice(1);\n        }\n    }\n\n    return output;\n}\n\nconst regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\nfunction escapeIdentifierSequence(string) {\n    let identifiers = string.split(regexWhitespace);\n    let index = 0;\n    let result = [];\n    let escapeResult;\n\n    while (index < identifiers.length) {\n        let subString = identifiers[index++];\n\n        if (subString === '') {\n            result.push(subString);\n            continue;\n        }\n\n        escapeResult = escape(subString, false);\n\n        if (regexIdentifierCharacter.test(subString)) {\n            // the font family name part consists of allowed characters exclusively\n            if (regexInvalidIdentifier.test(subString)) {\n                // the font family name part starts with two hyphens, a digit, or a\n                // hyphen followed by a digit\n                if (index === 1) {\n                    // if this is the first item\n                    result.push(escapeResult);\n                } else {\n                    // if it’s not the first item, we can simply escape the space\n                    // between the two identifiers to merge them into a single\n                    // identifier rather than escaping the start characters of the\n                    // second identifier\n                    result[index - 2] += '\\\\';\n                    result.push(escape(subString, true));\n                }\n            } else {\n                // the font family name part doesn’t start with two hyphens, a digit,\n                // or a hyphen followed by a digit\n                result.push(escapeResult);\n            }\n        } else {\n            // the font family name part contains invalid identifier characters\n            result.push(escapeResult);\n        }\n    }\n\n    result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n        const spaceCount = $2.length;\n        const escapesNeeded = Math.floor(spaceCount / 2);\n        const array = makeArray('\\\\ ', escapesNeeded);\n\n        if (spaceCount % 2) {\n            array[escapesNeeded - 1] += '\\\\ ';\n        }\n\n        return ($1 || '') + ' ' + array.join(' ');\n    });\n\n    // Escape trailing spaces unless they’re already part of an escape\n    if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n        result = result.replace(regexTrailingSpace, '\\\\ ');\n    }\n\n    if (regexSpaceAtStart.test(result)) {\n        result = '\\\\ ' + result.slice(1);\n    }\n\n    return result;\n}\n\n;\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}