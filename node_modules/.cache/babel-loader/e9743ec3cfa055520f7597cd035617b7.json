{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport './_version.mjs';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {workbox.streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\n\nfunction _getReaderFromSource(source) {\n  if (source.body && source.body.getReader) {\n    return source.body.getReader();\n  }\n\n  if (source.getReader) {\n    return source.getReader();\n  } // TODO: This should be possible to do by constructing a ReadableStream, but\n  // I can't get it to work. As a hack, construct a new Response, and use the\n  // reader associated with its body.\n\n\n  return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof workbox.streams\n */\n\n\nfunction concatenate(sourcePromises) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isArray(sourcePromises, {\n      moduleName: 'workbox-streams',\n      funcName: 'concatenate',\n      paramName: 'sourcePromises'\n    });\n  }\n\n  const readerPromises = sourcePromises.map(sourcePromise => {\n    return Promise.resolve(sourcePromise).then(source => {\n      return _getReaderFromSource(source);\n    });\n  });\n  let fullyStreamedResolve;\n  let fullyStreamedReject;\n  const done = new Promise((resolve, reject) => {\n    fullyStreamedResolve = resolve;\n    fullyStreamedReject = reject;\n  });\n  let i = 0;\n  const logMessages = [];\n  const stream = new ReadableStream({\n    pull(controller) {\n      return readerPromises[i].then(reader => reader.read()).then(result => {\n        if (result.done) {\n          if (process.env.NODE_ENV !== 'production') {\n            logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n          }\n\n          i++;\n\n          if (i >= readerPromises.length) {\n            // Log all the messages in the group at once in a single group.\n            if (process.env.NODE_ENV !== 'production') {\n              logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n\n              for (const message of logMessages) {\n                if (Array.isArray(message)) {\n                  logger.log(...message);\n                } else {\n                  logger.log(message);\n                }\n              }\n\n              logger.log('Finished reading all sources.');\n              logger.groupEnd();\n            }\n\n            controller.close();\n            fullyStreamedResolve();\n            return;\n          }\n\n          return this.pull(controller);\n        } else {\n          controller.enqueue(result.value);\n        }\n      }).catch(error => {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('An error occurred:', error);\n        }\n\n        fullyStreamedReject(error);\n        throw error;\n      });\n    },\n\n    cancel() {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('The ReadableStream was cancelled.');\n      }\n\n      fullyStreamedResolve();\n    }\n\n  });\n  return {\n    done,\n    stream\n  };\n}\n\nexport { concatenate };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-streams/concatenate.mjs"],"names":["logger","assert","_getReaderFromSource","source","body","getReader","Response","concatenate","sourcePromises","process","env","NODE_ENV","isArray","moduleName","funcName","paramName","readerPromises","map","sourcePromise","Promise","resolve","then","fullyStreamedResolve","fullyStreamedReject","done","reject","i","logMessages","stream","ReadableStream","pull","controller","reader","read","result","push","length","groupCollapsed","message","Array","log","groupEnd","close","enqueue","value","catch","error","cancel","warn"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {workbox.streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n  if (source.body && source.body.getReader) {\n    return source.body.getReader();\n  }\n\n  if (source.getReader) {\n    return source.getReader();\n  }\n\n  // TODO: This should be possible to do by constructing a ReadableStream, but\n  // I can't get it to work. As a hack, construct a new Response, and use the\n  // reader associated with its body.\n  return new Response(source).body.getReader();\n}\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenate(sourcePromises) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isArray(sourcePromises, {\n      moduleName: 'workbox-streams',\n      funcName: 'concatenate',\n      paramName: 'sourcePromises',\n    });\n  }\n\n  const readerPromises = sourcePromises.map((sourcePromise) => {\n    return Promise.resolve(sourcePromise).then((source) => {\n      return _getReaderFromSource(source);\n    });\n  });\n\n  let fullyStreamedResolve;\n  let fullyStreamedReject;\n  const done = new Promise((resolve, reject) => {\n    fullyStreamedResolve = resolve;\n    fullyStreamedReject = reject;\n  });\n\n  let i = 0;\n  const logMessages = [];\n  const stream = new ReadableStream({\n    pull(controller) {\n      return readerPromises[i]\n          .then((reader) => reader.read())\n          .then((result) => {\n            if (result.done) {\n              if (process.env.NODE_ENV !== 'production') {\n                logMessages.push(['Reached the end of source:',\n                  sourcePromises[i]]);\n              }\n\n              i++;\n              if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.groupCollapsed(\n                      `Concatenating ${readerPromises.length} sources.`);\n                  for (const message of logMessages) {\n                    if (Array.isArray(message)) {\n                      logger.log(...message);\n                    } else {\n                      logger.log(message);\n                    }\n                  }\n                  logger.log('Finished reading all sources.');\n                  logger.groupEnd();\n                }\n\n                controller.close();\n                fullyStreamedResolve();\n                return;\n              }\n\n              return this.pull(controller);\n            } else {\n              controller.enqueue(result.value);\n            }\n          }).catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error('An error occurred:', error);\n            }\n            fullyStreamedReject(error);\n            throw error;\n          });\n    },\n\n    cancel() {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('The ReadableStream was cancelled.');\n      }\n\n      fullyStreamedResolve();\n    },\n  });\n\n  return {done, stream};\n}\n\nexport {concatenate};\n"]},"metadata":{},"sourceType":"module"}