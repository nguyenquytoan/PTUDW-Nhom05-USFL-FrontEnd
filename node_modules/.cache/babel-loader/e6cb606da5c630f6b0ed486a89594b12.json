{"ast":null,"code":"import postcss from 'postcss';\nimport valueParser from 'postcss-values-parser';\nvar index = postcss.plugin('postcss-double-position-gradients', opts => {\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;\n  return root => {\n    // walk every declaration\n    root.walkDecls(decl => {\n      const originalValue = decl.value; // if the declaration value contains a gradient\n\n      if (gradientFunctionRegExp.test(originalValue)) {\n        const ast = valueParser(originalValue).parse(); // walk every function in the declaration value\n\n        ast.walkFunctionNodes(fn => {\n          // if the function is a gradient\n          if (gradientFunctionNameRegExp.test(fn.value)) {\n            const nodes = fn.nodes.slice(1, -1); // walk every argument to the function\n\n            nodes.forEach((node, index) => {\n              const node1back = Object(nodes[index - 1]);\n              const node2back = Object(nodes[index - 2]);\n              const isDoublePositionLength = node2back.type && node1back.type === 'number' && node.type === 'number'; // if the argument concludes a double-position gradient\n\n              if (isDoublePositionLength) {\n                // insert the fallback colors\n                const color = node2back.clone();\n                const comma = valueParser.comma({\n                  value: ',',\n                  raws: {\n                    after: ' '\n                  }\n                });\n                fn.insertBefore(node, comma);\n                fn.insertBefore(node, color);\n              }\n            });\n          }\n        });\n        const modifiedValue = ast.toString(); // if the value has changed due to double-position gradients\n\n        if (originalValue !== modifiedValue) {\n          // add the fallback value\n          decl.cloneBefore({\n            value: modifiedValue\n          }); // conditionally remove the double-position gradient\n\n          if (!preserve) {\n            decl.remove();\n          }\n        }\n      }\n    });\n  };\n});\nconst gradientFunctionRegExp = /(repeating-)?(conic|linear|radial)-gradient\\([\\W\\w]*\\)/i;\nconst gradientFunctionNameRegExp = /^(repeating-)?(conic|linear|radial)-gradient$/i;\nexport default index;","map":{"version":3,"sources":["index.js"],"names":["opts","preserve","Object","Boolean","root","decl","originalValue","gradientFunctionRegExp","ast","valueParser","fn","gradientFunctionNameRegExp","nodes","node1back","index","node2back","isDoublePositionLength","node","color","comma","value","raws","after","modifiedValue"],"mappings":";;AAGA,IAAA,KAAA,GAAe,OAAO,CAAP,MAAA,CAAA,mCAAA,EAAoDA,IAAI,IAAI;QACpEC,QAAQ,GAAG,cAAcC,MAAM,CAApB,IAAoB,CAApB,GAA6BC,OAAO,CAACH,IAAI,CAAzC,QAAoC,CAApC,GAAjB,I;SAEOI,IAAI,IAAI;;AAEdA,IAAAA,IAAI,CAAJA,SAAAA,CAAeC,IAAI,IAAI;YACPC,aADO,GACWD,IADX,CAAA,K,CAAA,CAAA;;UAIlBE,sBAAsB,CAAtBA,IAAAA,CAAJ,aAAIA,C,EAA4C;cACzCC,GAAG,GAAGC,WAAW,CAAXA,aAAW,CAAXA,CADmC,KACnCA,E,CADmC,CAAA;;AAI/CD,QAAAA,GAAG,CAAHA,iBAAAA,CAAsBE,EAAE,IAAI;;cAEvBC,0BAA0B,CAA1BA,IAAAA,CAAgCD,EAAE,CAAtC,KAAIC,C,EAA2C;kBACxCC,KAAK,GAAGF,EAAE,CAAFA,KAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAkB,CADc,CAChCA,C,CADgC,CAAA;;AAI9CE,YAAAA,KAAK,CAALA,OAAAA,CAAc,CAAA,IAAA,EAAA,KAAA,KAAiB;oBACxBC,SAAS,GAAGX,MAAM,CAACU,KAAK,CAACE,KAAK,GAApC,CAA8B,CAAN,C;oBAClBC,SAAS,GAAGb,MAAM,CAACU,KAAK,CAACE,KAAK,GAApC,CAA8B,CAAN,C;oBAElBE,sBAAsB,GAAGD,SAAS,CAATA,IAAAA,IAAkBF,SAAS,CAATA,IAAAA,KAAlBE,QAAAA,IAAiDE,IAAI,CAAJA,IAAAA,KAJlD,Q,CAAA,CAAA;;kBAO9B,sB,EAA4B;;sBAErBC,KAAK,GAAGH,SAAS,CAAvB,KAAcA,E;sBACRI,KAAK,GAAG,WAAW,CAAX,KAAA,CAAkB;AAAEC,kBAAAA,KAAK,EAAP,GAAA;AAAcC,kBAAAA,IAAI,EAAE;AAAEC,oBAAAA,KAAK,EAAE;AAAT;AAApB,iBAAlB,C;AAEdZ,gBAAAA,EAAE,CAAFA,YAAAA,CAAAA,IAAAA,EAAAA,KAAAA;AACAA,gBAAAA,EAAE,CAAFA,YAAAA,CAAAA,IAAAA,EAAAA,KAAAA;;AAbFE,aAAAA;;AANFJ,SAAAA;cAyBMe,aAAa,GAAGf,GAAG,CA7BsB,QA6BzBA,E,CA7ByB,CAAA;;YAgC3CF,aAAa,KAAjB,a,EAAqC;;AAEpCD,UAAAA,IAAI,CAAJA,WAAAA,CAAiB;AAAEe,YAAAA,KAAK,EAAEG;AAAT,WAAjBlB,EAFoC,CAAA;;cAKhC,CAAJ,Q,EAAe;AACdA,YAAAA,IAAI,CAAJA,MAAAA;;;;AA1CJD,KAAAA;AAFD,G;AAHD,CAAe,CAAf;AAuDA,MAAMG,sBAAsB,GAA5B,yDAAA;AACA,MAAMI,0BAA0B,GAAhC,gDAAA","sourcesContent":["import postcss from 'postcss';\nimport valueParser from 'postcss-values-parser';\n\nexport default postcss.plugin('postcss-double-position-gradients', opts => {\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;\n\n\treturn root => {\n\t\t// walk every declaration\n\t\troot.walkDecls(decl => {\n\t\t\tconst { value: originalValue } = decl;\n\n\t\t\t// if the declaration value contains a gradient\n\t\t\tif (gradientFunctionRegExp.test(originalValue)) {\n\t\t\t\tconst ast = valueParser(originalValue).parse();\n\n\t\t\t\t// walk every function in the declaration value\n\t\t\t\tast.walkFunctionNodes(fn => {\n\t\t\t\t\t// if the function is a gradient\n\t\t\t\t\tif (gradientFunctionNameRegExp.test(fn.value)) {\n\t\t\t\t\t\tconst nodes = fn.nodes.slice(1, -1);\n\n\t\t\t\t\t\t// walk every argument to the function\n\t\t\t\t\t\tnodes.forEach((node, index) => {\n\t\t\t\t\t\t\tconst node1back = Object(nodes[index - 1]);\n\t\t\t\t\t\t\tconst node2back = Object(nodes[index - 2]);\n\n\t\t\t\t\t\t\tconst isDoublePositionLength = node2back.type && node1back.type === 'number' && node.type === 'number';\n\n\t\t\t\t\t\t\t// if the argument concludes a double-position gradient\n\t\t\t\t\t\t\tif (isDoublePositionLength) {\n\t\t\t\t\t\t\t\t// insert the fallback colors\n\t\t\t\t\t\t\t\tconst color = node2back.clone();\n\t\t\t\t\t\t\t\tconst comma = valueParser.comma({ value: ',', raws: { after: ' ' } });\n\n\t\t\t\t\t\t\t\tfn.insertBefore(node, comma);\n\t\t\t\t\t\t\t\tfn.insertBefore(node, color);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst modifiedValue = ast.toString();\n\n\t\t\t\t// if the value has changed due to double-position gradients\n\t\t\t\tif (originalValue !== modifiedValue) {\n\t\t\t\t\t// add the fallback value\n\t\t\t\t\tdecl.cloneBefore({ value: modifiedValue });\n\n\t\t\t\t\t// conditionally remove the double-position gradient\n\t\t\t\t\tif (!preserve) {\n\t\t\t\t\t\tdecl.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\nconst gradientFunctionRegExp = /(repeating-)?(conic|linear|radial)-gradient\\([\\W\\w]*\\)/i;\nconst gradientFunctionNameRegExp = /^(repeating-)?(conic|linear|radial)-gradient$/i;\n"]},"metadata":{},"sourceType":"module"}