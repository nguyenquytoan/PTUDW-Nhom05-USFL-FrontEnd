{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"jestMock\"] = factory();else root[\"jestMock\"] = factory();\n})(window, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = \"./packages/jest-mock/src/index.ts\");\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    {\n      /***/\n      \"./node_modules/webpack/buildin/global.js\":\n      /*!***********************************!*\\\n        !*** (webpack)/buildin/global.js ***!\n        \\***********************************/\n\n      /*! no static exports found */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        var g; // This works in non-strict mode\n\n        g = function () {\n          return this;\n        }();\n\n        try {\n          // This works if eval is allowed (see CSP)\n          g = g || new Function(\"return this\")();\n        } catch (e) {\n          // This works if the window reference is available\n          if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n        } // g can still be undefined, but nothing to do about it...\n        // We return undefined, instead of nothing here, so it's\n        // easier to handle this case. if(!global) { ...}\n\n\n        module.exports = g;\n        /***/\n      },\n\n      /***/\n      \"./packages/jest-mock/src/index.ts\":\n      /*!*****************************************!*\\\n        !*** ./packages/jest-mock/src/index.ts ***!\n        \\*****************************************/\n\n      /*! no static exports found */\n\n      /***/\n      function (module, exports, __webpack_require__) {\n        \"use strict\";\n        /* WEBPACK VAR INJECTION */\n\n        (function (global) {\n          function _typeof(obj) {\n            if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n              _typeof = function _typeof(obj) {\n                return typeof obj;\n              };\n            } else {\n              _typeof = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n              };\n            }\n\n            return _typeof(obj);\n          }\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n          /**\n           * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n           *\n           * This source code is licensed under the MIT license found in the\n           * LICENSE file in the root directory of this source tree.\n           */\n\n          /**\n           * Possible types of a MockFunctionResult.\n           * 'return': The call completed by returning normally.\n           * 'throw': The call completed by throwing a value.\n           * 'incomplete': The call has not completed yet. This is possible if you read\n           *               the  mock function result from within the mock function itself\n           *               (or a function called by the mock function).\n           */\n\n          /**\n           * Represents the result of a single call to a mock function.\n           */\n          // see https://github.com/Microsoft/TypeScript/issues/25215\n\n\n          var MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\n          var FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\n          var FUNCTION_NAME_RESERVED_REPLACE = new RegExp(FUNCTION_NAME_RESERVED_PATTERN.source, 'g');\n          var RESERVED_KEYWORDS = new Set(['arguments', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield']);\n\n          function matchArity(fn, length) {\n            var mockConstructor;\n\n            switch (length) {\n              case 1:\n                mockConstructor = function mockConstructor(_a) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 2:\n                mockConstructor = function mockConstructor(_a, _b) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 3:\n                mockConstructor = function mockConstructor(_a, _b, _c) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 4:\n                mockConstructor = function mockConstructor(_a, _b, _c, _d) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 5:\n                mockConstructor = function mockConstructor(_a, _b, _c, _d, _e) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 6:\n                mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 7:\n                mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 8:\n                mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g, _h) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              case 9:\n                mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g, _h, _i) {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n\n              default:\n                mockConstructor = function mockConstructor() {\n                  return fn.apply(this, arguments);\n                };\n\n                break;\n            }\n\n            return mockConstructor;\n          }\n\n          function getObjectType(value) {\n            return Object.prototype.toString.apply(value).slice(8, -1);\n          }\n\n          function getType(ref) {\n            var typeName = getObjectType(ref);\n\n            if (typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction') {\n              return 'function';\n            } else if (Array.isArray(ref)) {\n              return 'array';\n            } else if (typeName === 'Object') {\n              return 'object';\n            } else if (typeName === 'Number' || typeName === 'String' || typeName === 'Boolean' || typeName === 'Symbol') {\n              return 'constant';\n            } else if (typeName === 'Map' || typeName === 'WeakMap' || typeName === 'Set') {\n              return 'collection';\n            } else if (typeName === 'RegExp') {\n              return 'regexp';\n            } else if (ref === undefined) {\n              return 'undefined';\n            } else if (ref === null) {\n              return 'null';\n            } else {\n              return null;\n            }\n          }\n\n          function isReadonlyProp(object, prop) {\n            if (prop === 'arguments' || prop === 'caller' || prop === 'callee' || prop === 'name' || prop === 'length') {\n              var typeName = getObjectType(object);\n              return typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction';\n            }\n\n            if (prop === 'source' || prop === 'global' || prop === 'ignoreCase' || prop === 'multiline') {\n              return getObjectType(object) === 'RegExp';\n            }\n\n            return false;\n          }\n\n          var ModuleMockerClass = /*#__PURE__*/function () {\n            /**\n             * @see README.md\n             * @param global Global object of the test environment, used to create\n             * mocks\n             */\n            function ModuleMockerClass(global) {\n              _classCallCheck(this, ModuleMockerClass);\n\n              this._environmentGlobal = global;\n              this._mockState = new WeakMap();\n              this._mockConfigRegistry = new WeakMap();\n              this._spyState = new Set();\n              this.ModuleMocker = ModuleMockerClass;\n              this._invocationCallCounter = 1;\n            }\n\n            _createClass(ModuleMockerClass, [{\n              key: \"_getSlots\",\n              value: function _getSlots(object) {\n                if (!object) {\n                  return [];\n                }\n\n                var slots = new Set();\n                var EnvObjectProto = this._environmentGlobal.Object.prototype;\n                var EnvFunctionProto = this._environmentGlobal.Function.prototype;\n                var EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through\n                // core node modules.\n\n                var ObjectProto = Object.prototype;\n                var FunctionProto = Function.prototype;\n                var RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype\n                // are never reported as slots\n\n                while (object != null && object !== EnvObjectProto && object !== EnvFunctionProto && object !== EnvRegExpProto && object !== ObjectProto && object !== FunctionProto && object !== RegExpProto) {\n                  var ownNames = Object.getOwnPropertyNames(object);\n\n                  for (var i = 0; i < ownNames.length; i++) {\n                    var prop = ownNames[i];\n\n                    if (!isReadonlyProp(object, prop)) {\n                      var propDesc = Object.getOwnPropertyDescriptor(object, prop); // @ts-ignore Object.__esModule\n\n                      if (propDesc !== undefined && !propDesc.get || object.__esModule) {\n                        slots.add(prop);\n                      }\n                    }\n                  }\n\n                  object = Object.getPrototypeOf(object);\n                }\n\n                return Array.from(slots);\n              }\n            }, {\n              key: \"_ensureMockConfig\",\n              value: function _ensureMockConfig(f) {\n                var config = this._mockConfigRegistry.get(f);\n\n                if (!config) {\n                  config = this._defaultMockConfig();\n\n                  this._mockConfigRegistry.set(f, config);\n                }\n\n                return config;\n              }\n            }, {\n              key: \"_ensureMockState\",\n              value: function _ensureMockState(f) {\n                var state = this._mockState.get(f);\n\n                if (!state) {\n                  state = this._defaultMockState();\n\n                  this._mockState.set(f, state);\n                }\n\n                return state;\n              }\n            }, {\n              key: \"_defaultMockConfig\",\n              value: function _defaultMockConfig() {\n                return {\n                  defaultReturnValue: undefined,\n                  isReturnValueLastSet: false,\n                  mockImpl: undefined,\n                  mockName: 'jest.fn()',\n                  specificMockImpls: [],\n                  specificReturnValues: []\n                };\n              }\n            }, {\n              key: \"_defaultMockState\",\n              value: function _defaultMockState() {\n                return {\n                  calls: [],\n                  instances: [],\n                  invocationCallOrder: [],\n                  results: []\n                };\n              }\n            }, {\n              key: \"_makeComponent\",\n              value: function _makeComponent(metadata, restore) {\n                var _this2 = this;\n\n                if (metadata.type === 'object') {\n                  return new this._environmentGlobal.Object();\n                } else if (metadata.type === 'array') {\n                  return new this._environmentGlobal.Array();\n                } else if (metadata.type === 'regexp') {\n                  return new this._environmentGlobal.RegExp('');\n                } else if (metadata.type === 'constant' || metadata.type === 'collection' || metadata.type === 'null' || metadata.type === 'undefined') {\n                  return metadata.value;\n                } else if (metadata.type === 'function') {\n                  var prototype = metadata.members && metadata.members.prototype && metadata.members.prototype.members || {};\n\n                  var prototypeSlots = this._getSlots(prototype);\n\n                  var mocker = this;\n                  var mockConstructor = matchArity(function () {\n                    var _this = this,\n                        _arguments = arguments;\n\n                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                      args[_key] = arguments[_key];\n                    }\n\n                    var mockState = mocker._ensureMockState(f);\n\n                    var mockConfig = mocker._ensureMockConfig(f);\n\n                    mockState.instances.push(this);\n                    mockState.calls.push(args); // Create and record an \"incomplete\" mock result immediately upon\n                    // calling rather than waiting for the mock to return. This avoids\n                    // issues caused by recursion where results can be recorded in the\n                    // wrong order.\n\n                    var mockResult = {\n                      type: 'incomplete',\n                      value: undefined\n                    };\n                    mockState.results.push(mockResult);\n                    mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown\n\n                    var finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)\n\n                    var thrownError; // Will be set to true if the mock throws an error. The presence of a\n                    // value in `thrownError` is not a 100% reliable indicator because a\n                    // function could throw a value of undefined.\n\n                    var callDidThrowError = false;\n\n                    try {\n                      // The bulk of the implementation is wrapped in an immediately\n                      // executed arrow function so the return value of the mock function\n                      // can be easily captured and recorded, despite the many separate\n                      // return points within the logic.\n                      finalReturnValue = function () {\n                        if (_this instanceof f) {\n                          // This is probably being called as a constructor\n                          prototypeSlots.forEach(function (slot) {\n                            // Copy prototype methods to the instance to make\n                            // it easier to interact with mock instance call and\n                            // return values\n                            if (prototype[slot].type === 'function') {\n                              // @ts-ignore no index signature\n                              var protoImpl = _this[slot]; // @ts-ignore no index signature\n\n                              _this[slot] = mocker.generateFromMetadata(prototype[slot]); // @ts-ignore no index signature\n\n                              _this[slot]._protoImpl = protoImpl;\n                            }\n                          }); // Run the mock constructor implementation\n\n                          var _mockImpl = mockConfig.specificMockImpls.length ? mockConfig.specificMockImpls.shift() : mockConfig.mockImpl;\n\n                          return _mockImpl && _mockImpl.apply(_this, _arguments);\n                        }\n\n                        var returnValue = mockConfig.defaultReturnValue; // If return value is last set, either specific or default, i.e.\n                        // mockReturnValueOnce()/mockReturnValue() is called and no\n                        // mockImplementationOnce()/mockImplementation() is called after\n                        // that.\n                        // use the set return value.\n\n                        if (mockConfig.specificReturnValues.length) {\n                          return mockConfig.specificReturnValues.shift();\n                        }\n\n                        if (mockConfig.isReturnValueLastSet) {\n                          return mockConfig.defaultReturnValue;\n                        } // If mockImplementationOnce()/mockImplementation() is last set,\n                        // or specific return values are used up, use the mock\n                        // implementation.\n\n\n                        var specificMockImpl;\n\n                        if (returnValue === undefined) {\n                          specificMockImpl = mockConfig.specificMockImpls.shift();\n\n                          if (specificMockImpl === undefined) {\n                            specificMockImpl = mockConfig.mockImpl;\n                          }\n\n                          if (specificMockImpl) {\n                            return specificMockImpl.apply(_this, _arguments);\n                          }\n                        } // Otherwise use prototype implementation\n\n\n                        if (returnValue === undefined && f._protoImpl) {\n                          return f._protoImpl.apply(_this, _arguments);\n                        }\n\n                        return returnValue;\n                      }();\n                    } catch (error) {\n                      // Store the thrown error so we can record it, then re-throw it.\n                      thrownError = error;\n                      callDidThrowError = true;\n                      throw error;\n                    } finally {\n                      // Record the result of the function.\n                      // NOTE: Intentionally NOT pushing/indexing into the array of mock\n                      //       results here to avoid corrupting results data if mockClear()\n                      //       is called during the execution of the mock.\n                      mockResult.type = callDidThrowError ? 'throw' : 'return';\n                      mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n                    }\n\n                    return finalReturnValue;\n                  }, metadata.length || 0);\n\n                  var f = this._createMockFunction(metadata, mockConstructor);\n\n                  f._isMockFunction = true;\n\n                  f.getMockImplementation = function () {\n                    return _this2._ensureMockConfig(f).mockImpl;\n                  };\n\n                  if (typeof restore === 'function') {\n                    this._spyState.add(restore);\n                  }\n\n                  this._mockState.set(f, this._defaultMockState());\n\n                  this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n                  Object.defineProperty(f, 'mock', {\n                    configurable: false,\n                    enumerable: true,\n                    get: function get() {\n                      return _this2._ensureMockState(f);\n                    },\n                    set: function set(val) {\n                      return _this2._mockState.set(f, val);\n                    }\n                  });\n\n                  f.mockClear = function () {\n                    _this2._mockState.delete(f);\n\n                    return f;\n                  };\n\n                  f.mockReset = function () {\n                    f.mockClear();\n\n                    _this2._mockConfigRegistry.delete(f);\n\n                    return f;\n                  };\n\n                  f.mockRestore = function () {\n                    f.mockReset();\n                    return restore ? restore() : undefined;\n                  };\n\n                  f.mockReturnValueOnce = function (value) {\n                    // next function call will return this value or default return value\n                    var mockConfig = _this2._ensureMockConfig(f);\n\n                    mockConfig.specificReturnValues.push(value);\n                    return f;\n                  };\n\n                  f.mockResolvedValueOnce = function (value) {\n                    return f.mockImplementationOnce(function () {\n                      return Promise.resolve(value);\n                    });\n                  };\n\n                  f.mockRejectedValueOnce = function (value) {\n                    return f.mockImplementationOnce(function () {\n                      return Promise.reject(value);\n                    });\n                  };\n\n                  f.mockReturnValue = function (value) {\n                    // next function call will return specified return value or this one\n                    var mockConfig = _this2._ensureMockConfig(f);\n\n                    mockConfig.isReturnValueLastSet = true;\n                    mockConfig.defaultReturnValue = value;\n                    return f;\n                  };\n\n                  f.mockResolvedValue = function (value) {\n                    return f.mockImplementation(function () {\n                      return Promise.resolve(value);\n                    });\n                  };\n\n                  f.mockRejectedValue = function (value) {\n                    return f.mockImplementation(function () {\n                      return Promise.reject(value);\n                    });\n                  };\n\n                  f.mockImplementationOnce = function (fn) {\n                    // next function call will use this mock implementation return value\n                    // or default mock implementation return value\n                    var mockConfig = _this2._ensureMockConfig(f);\n\n                    mockConfig.isReturnValueLastSet = false;\n                    mockConfig.specificMockImpls.push(fn);\n                    return f;\n                  };\n\n                  f.mockImplementation = function (fn) {\n                    // next function call will use mock implementation return value\n                    var mockConfig = _this2._ensureMockConfig(f);\n\n                    mockConfig.isReturnValueLastSet = false;\n                    mockConfig.defaultReturnValue = undefined;\n                    mockConfig.mockImpl = fn;\n                    return f;\n                  };\n\n                  f.mockReturnThis = function () {\n                    return f.mockImplementation(function () {\n                      return this;\n                    });\n                  };\n\n                  f.mockName = function (name) {\n                    if (name) {\n                      var mockConfig = _this2._ensureMockConfig(f);\n\n                      mockConfig.mockName = name;\n                    }\n\n                    return f;\n                  };\n\n                  f.getMockName = function () {\n                    var mockConfig = _this2._ensureMockConfig(f);\n\n                    return mockConfig.mockName || 'jest.fn()';\n                  };\n\n                  if (metadata.mockImpl) {\n                    f.mockImplementation(metadata.mockImpl);\n                  }\n\n                  return f;\n                } else {\n                  var unknownType = metadata.type || 'undefined type';\n                  throw new Error('Unrecognized type ' + unknownType);\n                }\n              }\n            }, {\n              key: \"_createMockFunction\",\n              value: function _createMockFunction(metadata, mockConstructor) {\n                var name = metadata.name;\n\n                if (!name) {\n                  return mockConstructor;\n                } // Preserve `name` property of mocked function.\n\n\n                var boundFunctionPrefix = 'bound ';\n                var bindCall = ''; // if-do-while for perf reasons. The common case is for the if to fail.\n\n                if (name && name.startsWith(boundFunctionPrefix)) {\n                  do {\n                    name = name.substring(boundFunctionPrefix.length); // Call bind() just to alter the function name.\n\n                    bindCall = '.bind(null)';\n                  } while (name && name.startsWith(boundFunctionPrefix));\n                } // Special case functions named `mockConstructor` to guard for infinite\n                // loops.\n\n\n                if (name === MOCK_CONSTRUCTOR_NAME) {\n                  return mockConstructor;\n                }\n\n                if ( // It's a syntax error to define functions with a reserved keyword\n                // as name.\n                RESERVED_KEYWORDS.has(name) || // It's also a syntax error to define functions with a name that starts with a number\n                /^\\d/.test(name)) {\n                  name = '$' + name;\n                } // It's also a syntax error to define a function with a reserved character\n                // as part of it's name.\n\n\n                if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n                  name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n                }\n\n                var body = 'return function ' + name + '() {' + 'return ' + MOCK_CONSTRUCTOR_NAME + '.apply(this,arguments);' + '}' + bindCall;\n                var createConstructor = new this._environmentGlobal.Function(MOCK_CONSTRUCTOR_NAME, body);\n                return createConstructor(mockConstructor);\n              }\n            }, {\n              key: \"_generateMock\",\n              value: function _generateMock(metadata, callbacks, refs) {\n                var _this3 = this; // metadata not compatible but it's the same type, maybe problem with\n                // overloading of _makeComponent and not _generateMock?\n                // @ts-ignore\n\n\n                var mock = this._makeComponent(metadata);\n\n                if (metadata.refID != null) {\n                  refs[metadata.refID] = mock;\n                }\n\n                this._getSlots(metadata.members).forEach(function (slot) {\n                  var slotMetadata = metadata.members && metadata.members[slot] || {};\n\n                  if (slotMetadata.ref != null) {\n                    callbacks.push(function (ref) {\n                      return function () {\n                        return mock[slot] = refs[ref];\n                      };\n                    }(slotMetadata.ref));\n                  } else {\n                    mock[slot] = _this3._generateMock(slotMetadata, callbacks, refs);\n                  }\n                });\n\n                if (metadata.type !== 'undefined' && metadata.type !== 'null' && mock.prototype && _typeof(mock.prototype) === 'object') {\n                  mock.prototype.constructor = mock;\n                }\n\n                return mock;\n              }\n              /**\n               * @see README.md\n               * @param _metadata Metadata for the mock in the schema returned by the\n               * getMetadata method of this module.\n               */\n\n            }, {\n              key: \"generateFromMetadata\",\n              value: function generateFromMetadata(_metadata) {\n                var callbacks = [];\n                var refs = {};\n\n                var mock = this._generateMock(_metadata, callbacks, refs);\n\n                callbacks.forEach(function (setter) {\n                  return setter();\n                });\n                return mock;\n              }\n              /**\n               * @see README.md\n               * @param component The component for which to retrieve metadata.\n               */\n\n            }, {\n              key: \"getMetadata\",\n              value: function getMetadata(component, _refs) {\n                var _this4 = this;\n\n                var refs = _refs || new Map();\n                var ref = refs.get(component);\n\n                if (ref != null) {\n                  return {\n                    ref: ref\n                  };\n                }\n\n                var type = getType(component);\n\n                if (!type) {\n                  return null;\n                }\n\n                var metadata = {\n                  type: type\n                };\n\n                if (type === 'constant' || type === 'collection' || type === 'undefined' || type === 'null') {\n                  metadata.value = component;\n                  return metadata;\n                } else if (type === 'function') {\n                  // @ts-ignore this is a function so it has a name\n                  metadata.name = component.name; // @ts-ignore may be a mock\n\n                  if (component._isMockFunction === true) {\n                    // @ts-ignore may be a mock\n                    metadata.mockImpl = component.getMockImplementation();\n                  }\n                }\n\n                metadata.refID = refs.size;\n                refs.set(component, metadata.refID);\n                var members = null; // Leave arrays alone\n\n                if (type !== 'array') {\n                  this._getSlots(component).forEach(function (slot) {\n                    if (type === 'function' && // @ts-ignore may be a mock\n                    component._isMockFunction === true && slot.match(/^mock/)) {\n                      return;\n                    } // @ts-ignore no index signature\n\n\n                    var slotMetadata = _this4.getMetadata(component[slot], refs);\n\n                    if (slotMetadata) {\n                      if (!members) {\n                        members = {};\n                      }\n\n                      members[slot] = slotMetadata;\n                    }\n                  });\n                }\n\n                if (members) {\n                  metadata.members = members;\n                }\n\n                return metadata;\n              }\n            }, {\n              key: \"isMockFunction\",\n              value: function isMockFunction(fn) {\n                return !!fn && fn._isMockFunction === true;\n              }\n            }, {\n              key: \"fn\",\n              value: function fn(implementation) {\n                var length = implementation ? implementation.length : 0;\n\n                var fn = this._makeComponent({\n                  length: length,\n                  type: 'function'\n                });\n\n                if (implementation) {\n                  fn.mockImplementation(implementation);\n                }\n\n                return fn;\n              }\n            }, {\n              key: \"spyOn\",\n              value: function spyOn(object, methodName, accessType) {\n                if (accessType) {\n                  return this._spyOnProperty(object, methodName, accessType);\n                }\n\n                if (_typeof(object) !== 'object' && typeof object !== 'function') {\n                  throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given');\n                }\n\n                var original = object[methodName];\n\n                if (!this.isMockFunction(original)) {\n                  if (typeof original !== 'function') {\n                    throw new Error('Cannot spy the ' + methodName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');\n                  }\n\n                  var isMethodOwner = object.hasOwnProperty(methodName); // @ts-ignore overriding original method with a Mock\n\n                  object[methodName] = this._makeComponent({\n                    type: 'function'\n                  }, function () {\n                    if (isMethodOwner) {\n                      object[methodName] = original;\n                    } else {\n                      delete object[methodName];\n                    }\n                  }); // @ts-ignore original method is now a Mock\n\n                  object[methodName].mockImplementation(function () {\n                    return original.apply(this, arguments);\n                  });\n                }\n\n                return object[methodName];\n              }\n            }, {\n              key: \"_spyOnProperty\",\n              value: function _spyOnProperty(obj, propertyName) {\n                var accessType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'get';\n\n                if (_typeof(obj) !== 'object' && typeof obj !== 'function') {\n                  throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given');\n                }\n\n                if (!obj) {\n                  throw new Error('spyOn could not find an object to spy upon for ' + propertyName + '');\n                }\n\n                if (!propertyName) {\n                  throw new Error('No property name supplied');\n                }\n\n                var descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n                var proto = Object.getPrototypeOf(obj);\n\n                while (!descriptor && proto !== null) {\n                  descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n                  proto = Object.getPrototypeOf(proto);\n                }\n\n                if (!descriptor) {\n                  throw new Error(propertyName + ' property does not exist');\n                }\n\n                if (!descriptor.configurable) {\n                  throw new Error(propertyName + ' is not declared configurable');\n                }\n\n                if (!descriptor[accessType]) {\n                  throw new Error('Property ' + propertyName + ' does not have access type ' + accessType);\n                }\n\n                var original = descriptor[accessType];\n\n                if (!this.isMockFunction(original)) {\n                  if (typeof original !== 'function') {\n                    throw new Error('Cannot spy the ' + propertyName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');\n                  } // @ts-ignore: mock is assignable\n\n\n                  descriptor[accessType] = this._makeComponent({\n                    type: 'function'\n                  }, function () {\n                    // @ts-ignore: mock is assignable\n                    descriptor[accessType] = original;\n                    Object.defineProperty(obj, propertyName, descriptor);\n                  });\n                  descriptor[accessType].mockImplementation(function () {\n                    // @ts-ignore\n                    return original.apply(this, arguments);\n                  });\n                }\n\n                Object.defineProperty(obj, propertyName, descriptor);\n                return descriptor[accessType];\n              }\n            }, {\n              key: \"clearAllMocks\",\n              value: function clearAllMocks() {\n                this._mockState = new WeakMap();\n              }\n            }, {\n              key: \"resetAllMocks\",\n              value: function resetAllMocks() {\n                this._mockConfigRegistry = new WeakMap();\n                this._mockState = new WeakMap();\n              }\n            }, {\n              key: \"restoreAllMocks\",\n              value: function restoreAllMocks() {\n                this._spyState.forEach(function (restore) {\n                  return restore();\n                });\n\n                this._spyState = new Set();\n              }\n            }, {\n              key: \"_typeOf\",\n              value: function _typeOf(value) {\n                return value == null ? '' + value : _typeof(value);\n              }\n            }]);\n\n            return ModuleMockerClass;\n          }();\n          /* eslint-disable-next-line no-redeclare */\n\n\n          var JestMock = new ModuleMockerClass(global);\n          module.exports = JestMock;\n          /* WEBPACK VAR INJECTION */\n        }).call(this, __webpack_require__(\n        /*! ./../../../node_modules/webpack/buildin/global.js */\n        \"./node_modules/webpack/buildin/global.js\"));\n        /***/\n      }\n      /******/\n\n    })\n  );\n});","map":{"version":3,"sources":["webpack://jestMock/webpack/universalModuleDefinition","webpack://jestMock/webpack/bootstrap","webpack://jestMock/(webpack)/buildin/global.js","webpack://jestMock/packages/jest-mock/src/index.ts"],"names":["g","module","MOCK_CONSTRUCTOR_NAME","FUNCTION_NAME_RESERVED_PATTERN","FUNCTION_NAME_RESERVED_REPLACE","RESERVED_KEYWORDS","mockConstructor","fn","Object","typeName","getObjectType","Array","ref","prop","ModuleMockerClass","object","slots","EnvObjectProto","EnvFunctionProto","EnvRegExpProto","ObjectProto","FunctionProto","Function","RegExpProto","RegExp","ownNames","i","isReadonlyProp","propDesc","f","config","state","defaultReturnValue","isReturnValueLastSet","mockImpl","mockName","specificMockImpls","specificReturnValues","calls","instances","invocationCallOrder","results","metadata","restore","prototype","prototypeSlots","mocker","matchArity","args","mockState","mockConfig","mockResult","type","value","undefined","callDidThrowError","finalReturnValue","protoImpl","returnValue","specificMockImpl","thrownError","configurable","enumerable","get","set","Promise","unknownType","name","boundFunctionPrefix","bindCall","body","createConstructor","callbacks","refs","mock","slotMetadata","_metadata","setter","component","_refs","getType","members","slot","implementation","length","methodName","accessType","original","isMethodOwner","obj","propertyName","descriptor","proto","JestMock"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jestMock\"] = factory();\n\telse\n\t\troot[\"jestMock\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./packages/jest-mock/src/index.ts\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype Global = NodeJS.Global; // | Window  add once TS improves typings;\n\nnamespace JestMock {\n  export type ModuleMocker = ModuleMockerClass;\n  export type MockFunctionMetadataType =\n    | 'object'\n    | 'array'\n    | 'regexp'\n    | 'function'\n    | 'constant'\n    | 'collection'\n    | 'null'\n    | 'undefined';\n\n  export type MockFunctionMetadata<\n    T,\n    Y extends Array<unknown>,\n    Type = MockFunctionMetadataType\n  > = {\n    ref?: number;\n    members?: Record<string, MockFunctionMetadata<T, Y>>;\n    mockImpl?: (...args: Y) => T;\n    name?: string;\n    refID?: number;\n    type?: Type;\n    value?: T;\n    length?: number;\n  };\n}\n\n/**\n * Possible types of a MockFunctionResult.\n * 'return': The call completed by returning normally.\n * 'throw': The call completed by throwing a value.\n * 'incomplete': The call has not completed yet. This is possible if you read\n *               the  mock function result from within the mock function itself\n *               (or a function called by the mock function).\n */\ntype MockFunctionResultType = 'return' | 'throw' | 'incomplete';\n\n/**\n * Represents the result of a single call to a mock function.\n */\ntype MockFunctionResult = {\n  /**\n   * Indicates how the call completed.\n   */\n  type: MockFunctionResultType;\n  /**\n   * The value that was either thrown or returned by the function.\n   * Undefined when type === 'incomplete'.\n   */\n  value: unknown;\n};\n\ntype MockFunctionState<T, Y extends Array<unknown>> = {\n  calls: Array<Y>;\n  instances: Array<T>;\n  invocationCallOrder: Array<number>;\n  /**\n   * List of results of calls to the mock function.\n   */\n  results: Array<MockFunctionResult>;\n};\n\ntype MockFunctionConfig = {\n  isReturnValueLastSet: boolean;\n  defaultReturnValue: unknown;\n  mockImpl: Function | undefined;\n  mockName: string;\n  specificReturnValues: Array<unknown>;\n  specificMockImpls: Array<Function>;\n};\n\n// see https://github.com/Microsoft/TypeScript/issues/25215\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends (...args: Array<any>) => any ? never : K;\n}[keyof T] &\n  string;\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends (...args: Array<any>) => any ? K : never;\n}[keyof T] &\n  string;\n\ninterface Mock<T, Y extends Array<unknown> = Array<unknown>>\n  extends Function,\n    MockInstance<T, Y> {\n  new (...args: Y): T;\n  (...args: Y): T;\n}\n\ninterface SpyInstance<T, Y extends Array<unknown>> extends MockInstance<T, Y> {}\n\ninterface MockInstance<T, Y extends Array<unknown>> {\n  _isMockFunction: true;\n  _protoImpl: Function;\n  getMockName(): string;\n  getMockImplementation(): Function | undefined;\n  mock: MockFunctionState<T, Y>;\n  mockClear(): this;\n  mockReset(): this;\n  mockRestore(): void;\n  mockImplementation(fn: (...args: Y) => T): this;\n  mockImplementation(fn: () => Promise<T>): this;\n  mockImplementationOnce(fn: (...args: Y) => T): this;\n  mockImplementationOnce(fn: () => Promise<T>): this;\n  mockName(name: string): this;\n  mockReturnThis(): this;\n  mockReturnValue(value: T): this;\n  mockReturnValueOnce(value: T): this;\n  mockResolvedValue(value: T): this;\n  mockResolvedValueOnce(value: T): this;\n  mockRejectedValue(value: T): this;\n  mockRejectedValueOnce(value: T): this;\n}\n\nconst MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\n\nconst FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\nconst FUNCTION_NAME_RESERVED_REPLACE = new RegExp(\n  FUNCTION_NAME_RESERVED_PATTERN.source,\n  'g',\n);\n\nconst RESERVED_KEYWORDS = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n]);\n\nfunction matchArity(fn: Function, length: number): Function {\n  let mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function(this: unknown, _a: unknown) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 2:\n      mockConstructor = function(this: unknown, _a: unknown, _b: unknown) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 3:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 4:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 5:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 6:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 7:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n        _g: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 8:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n        _g: unknown,\n        _h: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 9:\n      mockConstructor = function(\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n        _g: unknown,\n        _h: unknown,\n        _i: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    default:\n      mockConstructor = function(this: unknown) {\n        return fn.apply(this, arguments);\n      };\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value: unknown): string {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref?: unknown): JestMock.MockFunctionMetadataType | null {\n  const typeName = getObjectType(ref);\n  if (\n    typeName === 'Function' ||\n    typeName === 'AsyncFunction' ||\n    typeName === 'GeneratorFunction'\n  ) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object') {\n    return 'object';\n  } else if (\n    typeName === 'Number' ||\n    typeName === 'String' ||\n    typeName === 'Boolean' ||\n    typeName === 'Symbol'\n  ) {\n    return 'constant';\n  } else if (\n    typeName === 'Map' ||\n    typeName === 'WeakMap' ||\n    typeName === 'Set'\n  ) {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object: any, prop: string): boolean {\n  if (\n    prop === 'arguments' ||\n    prop === 'caller' ||\n    prop === 'callee' ||\n    prop === 'name' ||\n    prop === 'length'\n  ) {\n    const typeName = getObjectType(object);\n    return (\n      typeName === 'Function' ||\n      typeName === 'AsyncFunction' ||\n      typeName === 'GeneratorFunction'\n    );\n  }\n\n  if (\n    prop === 'source' ||\n    prop === 'global' ||\n    prop === 'ignoreCase' ||\n    prop === 'multiline'\n  ) {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nclass ModuleMockerClass {\n  private _environmentGlobal: Global;\n  private _mockState: WeakMap<Mock<any, any>, MockFunctionState<any, any>>;\n  private _mockConfigRegistry: WeakMap<Function, MockFunctionConfig>;\n  private _spyState: Set<() => void>;\n  private _invocationCallCounter: number;\n  ModuleMocker: typeof ModuleMockerClass;\n\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  constructor(global: Global) {\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this.ModuleMocker = ModuleMockerClass;\n    this._invocationCallCounter = 1;\n  }\n\n  private _getSlots(object?: Record<string, any>): Array<string> {\n    if (!object) {\n      return [];\n    }\n\n    const slots = new Set<string>();\n    const EnvObjectProto = this._environmentGlobal.Object.prototype;\n    const EnvFunctionProto = this._environmentGlobal.Function.prototype;\n    const EnvRegExpProto = this._environmentGlobal.RegExp.prototype;\n\n    // Also check the builtins in the current context as they leak through\n    // core node modules.\n    const ObjectProto = Object.prototype;\n    const FunctionProto = Function.prototype;\n    const RegExpProto = RegExp.prototype;\n\n    // Properties of Object.prototype, Function.prototype and RegExp.prototype\n    // are never reported as slots\n    while (\n      object != null &&\n      object !== EnvObjectProto &&\n      object !== EnvFunctionProto &&\n      object !== EnvRegExpProto &&\n      object !== ObjectProto &&\n      object !== FunctionProto &&\n      object !== RegExpProto\n    ) {\n      const ownNames = Object.getOwnPropertyNames(object);\n\n      for (let i = 0; i < ownNames.length; i++) {\n        const prop = ownNames[i];\n\n        if (!isReadonlyProp(object, prop)) {\n          const propDesc = Object.getOwnPropertyDescriptor(object, prop);\n          // @ts-ignore Object.__esModule\n          if ((propDesc !== undefined && !propDesc.get) || object.__esModule) {\n            slots.add(prop);\n          }\n        }\n      }\n\n      object = Object.getPrototypeOf(object);\n    }\n\n    return Array.from(slots);\n  }\n\n  private _ensureMockConfig<T, Y extends Array<unknown>>(\n    f: Mock<T, Y>,\n  ): MockFunctionConfig {\n    let config = this._mockConfigRegistry.get(f);\n    if (!config) {\n      config = this._defaultMockConfig();\n      this._mockConfigRegistry.set(f, config);\n    }\n    return config;\n  }\n\n  private _ensureMockState<T, Y extends Array<unknown>>(\n    f: Mock<T, Y>,\n  ): MockFunctionState<T, Y> {\n    let state = this._mockState.get(f);\n    if (!state) {\n      state = this._defaultMockState();\n      this._mockState.set(f, state);\n    }\n    return state;\n  }\n\n  private _defaultMockConfig(): MockFunctionConfig {\n    return {\n      defaultReturnValue: undefined,\n      isReturnValueLastSet: false,\n      mockImpl: undefined,\n      mockName: 'jest.fn()',\n      specificMockImpls: [],\n      specificReturnValues: [],\n    };\n  }\n\n  private _defaultMockState<T, Y extends Array<unknown>>(): MockFunctionState<\n    T,\n    Y\n  > {\n    return {\n      calls: [],\n      instances: [],\n      invocationCallOrder: [],\n      results: [],\n    };\n  }\n\n  private _makeComponent<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y, 'object'>,\n    restore?: () => void,\n  ): Record<string, any>;\n  private _makeComponent<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y, 'array'>,\n    restore?: () => void,\n  ): Array<unknown>;\n  private _makeComponent<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y, 'regexp'>,\n    restore?: () => void,\n  ): RegExp;\n  private _makeComponent<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<\n      T,\n      Y,\n      'constant' | 'collection' | 'null' | 'undefined'\n    >,\n    restore?: () => void,\n  ): T;\n  private _makeComponent<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y, 'function'>,\n    restore?: () => void,\n  ): Mock<T, Y>;\n  private _makeComponent<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y>,\n    restore?: () => void,\n  ):\n    | Record<string, any>\n    | Array<unknown>\n    | RegExp\n    | T\n    | undefined\n    | Mock<T, Y> {\n    if (metadata.type === 'object') {\n      return new this._environmentGlobal.Object();\n    } else if (metadata.type === 'array') {\n      return new this._environmentGlobal.Array();\n    } else if (metadata.type === 'regexp') {\n      return new this._environmentGlobal.RegExp('');\n    } else if (\n      metadata.type === 'constant' ||\n      metadata.type === 'collection' ||\n      metadata.type === 'null' ||\n      metadata.type === 'undefined'\n    ) {\n      return metadata.value;\n    } else if (metadata.type === 'function') {\n      const prototype =\n        (metadata.members &&\n          metadata.members.prototype &&\n          metadata.members.prototype.members) ||\n        {};\n      const prototypeSlots = this._getSlots(prototype);\n      const mocker = this;\n      const mockConstructor = matchArity(function(this: T, ...args: Y) {\n        const mockState = mocker._ensureMockState(f);\n        const mockConfig = mocker._ensureMockConfig(f);\n        mockState.instances.push(this);\n        mockState.calls.push(args);\n        // Create and record an \"incomplete\" mock result immediately upon\n        // calling rather than waiting for the mock to return. This avoids\n        // issues caused by recursion where results can be recorded in the\n        // wrong order.\n        const mockResult: MockFunctionResult = {\n          type: 'incomplete',\n          value: undefined,\n        };\n        mockState.results.push(mockResult);\n        mockState.invocationCallOrder.push(mocker._invocationCallCounter++);\n\n        // Will be set to the return value of the mock if an error is not thrown\n        let finalReturnValue;\n        // Will be set to the error that is thrown by the mock (if it throws)\n        let thrownError;\n        // Will be set to true if the mock throws an error. The presence of a\n        // value in `thrownError` is not a 100% reliable indicator because a\n        // function could throw a value of undefined.\n        let callDidThrowError = false;\n\n        try {\n          // The bulk of the implementation is wrapped in an immediately\n          // executed arrow function so the return value of the mock function\n          // can be easily captured and recorded, despite the many separate\n          // return points within the logic.\n          finalReturnValue = (() => {\n            if (this instanceof f) {\n              // This is probably being called as a constructor\n              prototypeSlots.forEach(slot => {\n                // Copy prototype methods to the instance to make\n                // it easier to interact with mock instance call and\n                // return values\n                if (prototype[slot].type === 'function') {\n                  // @ts-ignore no index signature\n                  const protoImpl = this[slot];\n                  // @ts-ignore no index signature\n                  this[slot] = mocker.generateFromMetadata(prototype[slot]);\n                  // @ts-ignore no index signature\n                  this[slot]._protoImpl = protoImpl;\n                }\n              });\n\n              // Run the mock constructor implementation\n              const mockImpl = mockConfig.specificMockImpls.length\n                ? mockConfig.specificMockImpls.shift()\n                : mockConfig.mockImpl;\n              return mockImpl && mockImpl.apply(this, arguments);\n            }\n\n            const returnValue = mockConfig.defaultReturnValue;\n            // If return value is last set, either specific or default, i.e.\n            // mockReturnValueOnce()/mockReturnValue() is called and no\n            // mockImplementationOnce()/mockImplementation() is called after\n            // that.\n            // use the set return value.\n            if (mockConfig.specificReturnValues.length) {\n              return mockConfig.specificReturnValues.shift();\n            }\n\n            if (mockConfig.isReturnValueLastSet) {\n              return mockConfig.defaultReturnValue;\n            }\n\n            // If mockImplementationOnce()/mockImplementation() is last set,\n            // or specific return values are used up, use the mock\n            // implementation.\n            let specificMockImpl;\n            if (returnValue === undefined) {\n              specificMockImpl = mockConfig.specificMockImpls.shift();\n              if (specificMockImpl === undefined) {\n                specificMockImpl = mockConfig.mockImpl;\n              }\n              if (specificMockImpl) {\n                return specificMockImpl.apply(this, arguments);\n              }\n            }\n\n            // Otherwise use prototype implementation\n            if (returnValue === undefined && f._protoImpl) {\n              return f._protoImpl.apply(this, arguments);\n            }\n\n            return returnValue;\n          })();\n        } catch (error) {\n          // Store the thrown error so we can record it, then re-throw it.\n          thrownError = error;\n          callDidThrowError = true;\n          throw error;\n        } finally {\n          // Record the result of the function.\n          // NOTE: Intentionally NOT pushing/indexing into the array of mock\n          //       results here to avoid corrupting results data if mockClear()\n          //       is called during the execution of the mock.\n          mockResult.type = callDidThrowError ? 'throw' : 'return';\n          mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n        }\n\n        return finalReturnValue;\n      }, metadata.length || 0);\n\n      const f = (this._createMockFunction(\n        metadata,\n        mockConstructor,\n      ) as unknown) as Mock<T, Y>;\n      f._isMockFunction = true;\n      f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;\n\n      if (typeof restore === 'function') {\n        this._spyState.add(restore);\n      }\n\n      this._mockState.set(f, this._defaultMockState<T, Y>());\n      this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n      Object.defineProperty(f, 'mock', {\n        configurable: false,\n        enumerable: true,\n        get: () => this._ensureMockState(f),\n        set: val => this._mockState.set(f, val),\n      });\n\n      f.mockClear = () => {\n        this._mockState.delete(f);\n        return f;\n      };\n\n      f.mockReset = () => {\n        f.mockClear();\n        this._mockConfigRegistry.delete(f);\n        return f;\n      };\n\n      f.mockRestore = () => {\n        f.mockReset();\n        return restore ? restore() : undefined;\n      };\n\n      f.mockReturnValueOnce = (value: T) => {\n        // next function call will return this value or default return value\n        const mockConfig = this._ensureMockConfig(f);\n        mockConfig.specificReturnValues.push(value);\n        return f;\n      };\n\n      f.mockResolvedValueOnce = (value: T) =>\n        f.mockImplementationOnce(() => Promise.resolve(value));\n\n      f.mockRejectedValueOnce = (value: T) =>\n        f.mockImplementationOnce(() => Promise.reject(value));\n\n      f.mockReturnValue = (value: T) => {\n        // next function call will return specified return value or this one\n        const mockConfig = this._ensureMockConfig(f);\n        mockConfig.isReturnValueLastSet = true;\n        mockConfig.defaultReturnValue = value;\n        return f;\n      };\n\n      f.mockResolvedValue = (value: T) =>\n        f.mockImplementation(() => Promise.resolve(value));\n\n      f.mockRejectedValue = (value: T) =>\n        f.mockImplementation(() => Promise.reject(value));\n\n      f.mockImplementationOnce = (\n        fn: ((...args: Y) => T) | (() => Promise<T>),\n      ): Mock<T, Y> => {\n        // next function call will use this mock implementation return value\n        // or default mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n        mockConfig.isReturnValueLastSet = false;\n        mockConfig.specificMockImpls.push(fn);\n        return f;\n      };\n\n      f.mockImplementation = (\n        fn: ((...args: Y) => T) | (() => Promise<T>),\n      ): Mock<T, Y> => {\n        // next function call will use mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n        mockConfig.isReturnValueLastSet = false;\n        mockConfig.defaultReturnValue = undefined;\n        mockConfig.mockImpl = fn;\n        return f;\n      };\n\n      f.mockReturnThis = () =>\n        f.mockImplementation(function(this: T) {\n          return this;\n        });\n\n      f.mockName = (name: string) => {\n        if (name) {\n          const mockConfig = this._ensureMockConfig(f);\n          mockConfig.mockName = name;\n        }\n        return f;\n      };\n\n      f.getMockName = () => {\n        const mockConfig = this._ensureMockConfig(f);\n        return mockConfig.mockName || 'jest.fn()';\n      };\n\n      if (metadata.mockImpl) {\n        f.mockImplementation(metadata.mockImpl);\n      }\n\n      return f;\n    } else {\n      const unknownType = metadata.type || 'undefined type';\n      throw new Error('Unrecognized type ' + unknownType);\n    }\n  }\n\n  private _createMockFunction<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y>,\n    mockConstructor: Function,\n  ): Function {\n    let name = metadata.name;\n    if (!name) {\n      return mockConstructor;\n    }\n\n    // Preserve `name` property of mocked function.\n    const boundFunctionPrefix = 'bound ';\n    let bindCall = '';\n    // if-do-while for perf reasons. The common case is for the if to fail.\n    if (name && name.startsWith(boundFunctionPrefix)) {\n      do {\n        name = name.substring(boundFunctionPrefix.length);\n        // Call bind() just to alter the function name.\n        bindCall = '.bind(null)';\n      } while (name && name.startsWith(boundFunctionPrefix));\n    }\n\n    // Special case functions named `mockConstructor` to guard for infinite\n    // loops.\n    if (name === MOCK_CONSTRUCTOR_NAME) {\n      return mockConstructor;\n    }\n\n    if (\n      // It's a syntax error to define functions with a reserved keyword\n      // as name.\n      RESERVED_KEYWORDS.has(name) ||\n      // It's also a syntax error to define functions with a name that starts with a number\n      /^\\d/.test(name)\n    ) {\n      name = '$' + name;\n    }\n\n    // It's also a syntax error to define a function with a reserved character\n    // as part of it's name.\n    if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n      name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n    }\n\n    const body =\n      'return function ' +\n      name +\n      '() {' +\n      'return ' +\n      MOCK_CONSTRUCTOR_NAME +\n      '.apply(this,arguments);' +\n      '}' +\n      bindCall;\n    const createConstructor = new this._environmentGlobal.Function(\n      MOCK_CONSTRUCTOR_NAME,\n      body,\n    );\n\n    return createConstructor(mockConstructor);\n  }\n\n  private _generateMock<T, Y extends Array<unknown>>(\n    metadata: JestMock.MockFunctionMetadata<T, Y>,\n    callbacks: Array<Function>,\n    refs: {\n      [key: string]:\n        | Record<string, any>\n        | Array<unknown>\n        | RegExp\n        | T\n        | undefined\n        | Mock<T, Y>;\n    },\n  ): Mock<T, Y> {\n    // metadata not compatible but it's the same type, maybe problem with\n    // overloading of _makeComponent and not _generateMock?\n    // @ts-ignore\n    const mock = this._makeComponent(metadata);\n    if (metadata.refID != null) {\n      refs[metadata.refID] = mock;\n    }\n\n    this._getSlots(metadata.members).forEach(slot => {\n      const slotMetadata = (metadata.members && metadata.members[slot]) || {};\n      if (slotMetadata.ref != null) {\n        callbacks.push(\n          (function(ref) {\n            return () => (mock[slot] = refs[ref]);\n          })(slotMetadata.ref),\n        );\n      } else {\n        mock[slot] = this._generateMock(slotMetadata, callbacks, refs);\n      }\n    });\n\n    if (\n      metadata.type !== 'undefined' &&\n      metadata.type !== 'null' &&\n      mock.prototype &&\n      typeof mock.prototype === 'object'\n    ) {\n      mock.prototype.constructor = mock;\n    }\n\n    return mock;\n  }\n\n  /**\n   * @see README.md\n   * @param _metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   */\n  generateFromMetadata<T, Y extends Array<unknown>>(\n    _metadata: JestMock.MockFunctionMetadata<T, Y>,\n  ): Mock<T, Y> {\n    const callbacks: Array<Function> = [];\n    const refs = {};\n    const mock = this._generateMock(_metadata, callbacks, refs);\n    callbacks.forEach(setter => setter());\n    return mock;\n  }\n\n  /**\n   * @see README.md\n   * @param component The component for which to retrieve metadata.\n   */\n  getMetadata<T, Y extends Array<unknown>>(\n    component: T,\n    _refs?: Map<T, number>,\n  ): JestMock.MockFunctionMetadata<T, Y> | null {\n    const refs = _refs || new Map<T, number>();\n    const ref = refs.get(component);\n    if (ref != null) {\n      return {ref};\n    }\n\n    const type = getType(component);\n    if (!type) {\n      return null;\n    }\n\n    const metadata: JestMock.MockFunctionMetadata<T, Y> = {type};\n    if (\n      type === 'constant' ||\n      type === 'collection' ||\n      type === 'undefined' ||\n      type === 'null'\n    ) {\n      metadata.value = component;\n      return metadata;\n    } else if (type === 'function') {\n      // @ts-ignore this is a function so it has a name\n      metadata.name = component.name;\n      // @ts-ignore may be a mock\n      if (component._isMockFunction === true) {\n        // @ts-ignore may be a mock\n        metadata.mockImpl = component.getMockImplementation();\n      }\n    }\n\n    metadata.refID = refs.size;\n    refs.set(component, metadata.refID);\n\n    let members: {\n      [key: string]: JestMock.MockFunctionMetadata<T, Y>;\n    } | null = null;\n    // Leave arrays alone\n    if (type !== 'array') {\n      this._getSlots(component).forEach(slot => {\n        if (\n          type === 'function' &&\n          // @ts-ignore may be a mock\n          component._isMockFunction === true &&\n          slot.match(/^mock/)\n        ) {\n          return;\n        }\n        // @ts-ignore no index signature\n        const slotMetadata = this.getMetadata<T, Y>(component[slot], refs);\n        if (slotMetadata) {\n          if (!members) {\n            members = {};\n          }\n          members[slot] = slotMetadata;\n        }\n      });\n    }\n\n    if (members) {\n      metadata.members = members;\n    }\n\n    return metadata;\n  }\n\n  isMockFunction<T>(fn: any): fn is Mock<T> {\n    return !!fn && fn._isMockFunction === true;\n  }\n\n  fn<T, Y extends Array<unknown>>(\n    implementation?: (...args: Y) => T,\n  ): Mock<T, Y> {\n    const length = implementation ? implementation.length : 0;\n    const fn = this._makeComponent<T, Y>({length, type: 'function'});\n    if (implementation) {\n      fn.mockImplementation(implementation);\n    }\n    return fn;\n  }\n\n  spyOn<T extends {}, M extends NonFunctionPropertyNames<T>>(\n    object: T,\n    methodName: M,\n    accessType: 'get',\n  ): SpyInstance<T[M], []>;\n\n  spyOn<T extends {}, M extends NonFunctionPropertyNames<T>>(\n    object: T,\n    methodName: M,\n    accessType: 'set',\n  ): SpyInstance<void, [T[M]]>;\n\n  spyOn<T extends {}, M extends FunctionPropertyNames<T>>(\n    object: T,\n    methodName: M,\n  ): T[M] extends (...args: Array<any>) => any\n    ? SpyInstance<ReturnType<T[M]>, Parameters<T[M]>>\n    : never;\n\n  spyOn<T extends {}, M extends NonFunctionPropertyNames<T>>(\n    object: T,\n    methodName: M,\n    accessType?: 'get' | 'set',\n  ) {\n    if (accessType) {\n      return this._spyOnProperty(object, methodName, accessType);\n    }\n\n    if (typeof object !== 'object' && typeof object !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given',\n      );\n    }\n\n    const original = object[methodName];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            methodName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead',\n        );\n      }\n\n      const isMethodOwner = object.hasOwnProperty(methodName);\n\n      // @ts-ignore overriding original method with a Mock\n      object[methodName] = this._makeComponent({type: 'function'}, () => {\n        if (isMethodOwner) {\n          object[methodName] = original;\n        } else {\n          delete object[methodName];\n        }\n      });\n\n      // @ts-ignore original method is now a Mock\n      object[methodName].mockImplementation(function(this: unknown) {\n        return original.apply(this, arguments);\n      });\n    }\n\n    return object[methodName];\n  }\n\n  private _spyOnProperty<T extends {}, M extends NonFunctionPropertyNames<T>>(\n    obj: T,\n    propertyName: M,\n    accessType: 'get' | 'set' = 'get',\n  ): Mock<T> {\n    if (typeof obj !== 'object' && typeof obj !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given',\n      );\n    }\n\n    if (!obj) {\n      throw new Error(\n        'spyOn could not find an object to spy upon for ' + propertyName + '',\n      );\n    }\n\n    if (!propertyName) {\n      throw new Error('No property name supplied');\n    }\n\n    let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n    let proto = Object.getPrototypeOf(obj);\n\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    if (!descriptor) {\n      throw new Error(propertyName + ' property does not exist');\n    }\n\n    if (!descriptor.configurable) {\n      throw new Error(propertyName + ' is not declared configurable');\n    }\n\n    if (!descriptor[accessType]) {\n      throw new Error(\n        'Property ' + propertyName + ' does not have access type ' + accessType,\n      );\n    }\n\n    const original = descriptor[accessType];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            propertyName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead',\n        );\n      }\n\n      // @ts-ignore: mock is assignable\n      descriptor[accessType] = this._makeComponent({type: 'function'}, () => {\n        // @ts-ignore: mock is assignable\n        descriptor![accessType] = original;\n        Object.defineProperty(obj, propertyName, descriptor!);\n      });\n\n      (descriptor[accessType] as Mock<T>).mockImplementation(function(\n        this: unknown,\n      ) {\n        // @ts-ignore\n        return original.apply(this, arguments);\n      });\n    }\n\n    Object.defineProperty(obj, propertyName, descriptor);\n    return descriptor[accessType] as Mock<T>;\n  }\n\n  clearAllMocks() {\n    this._mockState = new WeakMap();\n  }\n\n  resetAllMocks() {\n    this._mockConfigRegistry = new WeakMap();\n    this._mockState = new WeakMap();\n  }\n\n  restoreAllMocks() {\n    this._spyState.forEach(restore => restore());\n    this._spyState = new Set();\n  }\n\n  private _typeOf(value: any): string {\n    return value == null ? '' + value : typeof value;\n  }\n}\n\n/* eslint-disable-next-line no-redeclare */\nconst JestMock = new ModuleMockerClass(global);\nexport = JestMock;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}