{"ast":null,"code":"/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * @param {ASTNode} node A function node to get.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\n\n\nfunction getId(node) {\n  return node.id || node;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in getters\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/getter-return\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected to return a value in {{name}}.\",\n      expectedAlways: \"Expected {{name}} to always return a value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {\n        context.report({\n          node,\n          loc: getId(node).loc.start,\n          messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n    /**\n     * Checks whether a node means a getter function.\n     * @param {ASTNode} node a node to check.\n     * @returns {boolean} if node means a getter, return true; else return false.\n     */\n\n\n    function isGetter(node) {\n      const parent = node.parent;\n\n      if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n        if (parent.kind === \"get\") {\n          return true;\n        }\n\n        if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n          // Object.defineProperty()\n          if (parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n            return true;\n          } // Object.defineProperties()\n\n\n          if (parent.parent.parent.type === \"Property\" && parent.parent.parent.parent.type === \"ObjectExpression\" && parent.parent.parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: isGetter(node),\n          node\n        };\n      },\n\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true; // if allowImplicit: false, should also check node.argument\n\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expected\",\n              data: {\n                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n              }\n            });\n          }\n        }\n      },\n\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/getter-return.js"],"names":["astUtils","require","TARGET_NODE_TYPE","isReachable","segment","reachable","getId","node","id","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","allowImplicit","default","additionalProperties","messages","expected","expectedAlways","create","context","options","funcInfo","upper","codePath","hasReturn","shouldCheck","checkLastSegment","currentSegments","some","report","loc","start","messageId","data","name","getFunctionNameWithKind","isGetter","parent","test","body","kind","getStaticPropertyName","callee","onCodePathStart","onCodePathEnd","ReturnStatement","argument"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * @param {ASTNode} node A function node to get.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getId(node) {\n    return node.id || node;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in getters\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/getter-return\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expected: \"Expected to return a value in {{name}}.\",\n            expectedAlways: \"Expected {{name}} to always return a value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getId(node).loc.start,\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks whether a node means a getter function.\n         * @param {ASTNode} node a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n                        return true;\n                    }\n\n                    // Object.defineProperties()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expected\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}