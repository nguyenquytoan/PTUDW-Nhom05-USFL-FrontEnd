{"ast":null,"code":"/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u; // `null` literal must be handled separately.\n\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce dot notation whenever possible\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-notation\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowKeywords: {\n          type: \"boolean\",\n          default: true\n        },\n        allowPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      useDot: \"[{{key}}] is better written in dot notation.\",\n      useBrackets: \".{{key}} is a syntax error.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n    const sourceCode = context.getSourceCode();\n    let allowPattern;\n\n    if (options.allowPattern) {\n      allowPattern = new RegExp(options.allowPattern, \"u\");\n    }\n    /**\n     * Check if the property is valid dot notation\n     * @param {ASTNode} node The dot notation node\n     * @param {string} value Value which is to be checked\n     * @returns {void}\n     */\n\n\n    function checkComputedProperty(node, value) {\n      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {\n        const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n        context.report({\n          node: node.property,\n          messageId: \"useDot\",\n          data: {\n            key: formattedValue\n          },\n\n          fix(fixer) {\n            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n            const rightBracket = sourceCode.getLastToken(node);\n\n            if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, {\n              includeComments: true,\n              filter: astUtils.isCommentToken\n            })) {\n              // Don't perform any fixes if there are comments inside the brackets.\n              return null;\n            }\n\n            const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);\n            const needsSpaceAfterProperty = tokenAfterProperty && rightBracket.range[1] === tokenAfterProperty.range[0] && !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);\n            const textBeforeDot = astUtils.isDecimalInteger(node.object) ? \" \" : \"\";\n            const textAfterProperty = needsSpaceAfterProperty ? \" \" : \"\";\n            return fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], `${textBeforeDot}.${value}${textAfterProperty}`);\n          }\n\n        });\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        if (node.computed && node.property.type === \"Literal\" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {\n          checkComputedProperty(node, node.property.value);\n        }\n\n        if (node.computed && node.property.type === \"TemplateLiteral\" && node.property.expressions.length === 0) {\n          checkComputedProperty(node, node.property.quasis[0].value.cooked);\n        }\n\n        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {\n          context.report({\n            node: node.property,\n            messageId: \"useBrackets\",\n            data: {\n              key: node.property.name\n            },\n\n            fix(fixer) {\n              const dot = sourceCode.getTokenBefore(node.property);\n              const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);\n\n              if (textAfterDot.trim()) {\n                // Don't perform any fixes if there are comments between the dot and the property name.\n                return null;\n              }\n\n              if (node.object.type === \"Identifier\" && node.object.name === \"let\") {\n                /*\n                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not\n                 * a MemberExpression.\n                 */\n                return null;\n              }\n\n              return fixer.replaceTextRange([dot.range[0], node.property.range[1]], `[${textAfterDot}\"${node.property.name}\"]`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/dot-notation.js"],"names":["astUtils","require","keywords","validIdentifier","literalTypesToCheck","Set","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowKeywords","default","allowPattern","additionalProperties","fixable","messages","useDot","useBrackets","create","context","options","sourceCode","getSourceCode","RegExp","checkComputedProperty","node","value","test","indexOf","String","formattedValue","property","JSON","stringify","report","messageId","data","key","fix","fixer","leftBracket","getTokenAfter","object","isOpeningBracketToken","rightBracket","getLastToken","getFirstTokenBetween","includeComments","filter","isCommentToken","tokenAfterProperty","needsSpaceAfterProperty","range","canTokensBeAdjacent","textBeforeDot","isDecimalInteger","textAfterProperty","replaceTextRange","MemberExpression","computed","has","isNullLiteral","expressions","length","quasis","cooked","name","dot","getTokenBefore","textAfterDot","text","slice","trim"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\n\n// `null` literal must be handled separately.\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-notation\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    allowPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            useDot: \"[{{key}}] is better written in dot notation.\",\n            useBrackets: \".{{key}} is a syntax error.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern, \"u\");\n        }\n\n        /**\n         * Check if the property is valid dot notation\n         * @param {ASTNode} node The dot notation node\n         * @param {string} value Value which is to be checked\n         * @returns {void}\n         */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    messageId: \"useDot\",\n                    data: {\n                        key: formattedValue\n                    },\n                    fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n\n                        if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {\n\n                            // Don't perform any fixes if there are comments inside the brackets.\n                            return null;\n                        }\n\n                        const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);\n                        const needsSpaceAfterProperty = tokenAfterProperty &&\n                            rightBracket.range[1] === tokenAfterProperty.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);\n\n                        const textBeforeDot = astUtils.isDecimalInteger(node.object) ? \" \" : \"\";\n                        const textAfterProperty = needsSpaceAfterProperty ? \" \" : \"\";\n\n                        return fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            `${textBeforeDot}.${value}${textAfterProperty}`\n                        );\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\" &&\n                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    node.property.type === \"TemplateLiteral\" &&\n                    node.property.expressions.length === 0\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        messageId: \"useBrackets\",\n                        data: {\n                            key: node.property.name\n                        },\n                        fix(fixer) {\n                            const dot = sourceCode.getTokenBefore(node.property);\n                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);\n\n                            if (textAfterDot.trim()) {\n\n                                // Don't perform any fixes if there are comments between the dot and the property name.\n                                return null;\n                            }\n\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\") {\n\n                                /*\n                                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not\n                                 * a MemberExpression.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [dot.range[0], node.property.range[1]],\n                                `[${textAfterDot}\"${node.property.name}\"]`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}