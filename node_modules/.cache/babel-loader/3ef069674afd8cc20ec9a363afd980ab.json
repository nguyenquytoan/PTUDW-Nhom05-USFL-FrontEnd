{"ast":null,"code":"/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\n\n\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\n\n\nfunction isPossibleConstructor(node) {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"ThisExpression\":\n    case \"MemberExpression\":\n    case \"CallExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"MetaProperty\":\n      return true;\n\n    case \"Identifier\":\n      return node.name !== \"undefined\";\n\n    case \"AssignmentExpression\":\n      return isPossibleConstructor(node.right);\n\n    case \"LogicalExpression\":\n      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n\n    case \"ConditionalExpression\":\n      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);\n\n    case \"SequenceExpression\":\n      {\n        const lastExpression = node.expressions[node.expressions.length - 1];\n        return isPossibleConstructor(lastExpression);\n      }\n\n    default:\n      return false;\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require `super()` calls in constructors\",\n      category: \"ECMAScript 6\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/constructor-super\"\n    },\n    schema: [],\n    messages: {\n      missingSome: \"Lacked a call of 'super()' in some code paths.\",\n      missingAll: \"Expected to call 'super()'.\",\n      duplicate: \"Unexpected duplicate 'super()'.\",\n      badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n      unexpected: \"Unexpected 'super()'.\"\n    }\n  },\n\n  create(context) {\n    /*\n     * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n     * Information for each constructor.\n     * - upper:      Information of the upper constructor.\n     * - hasExtends: A flag which shows whether own class has a valid `extends`\n     *               part.\n     * - scope:      The scope of own class.\n     * - codePath:   The code path object of the constructor.\n     */\n    let funcInfo = null;\n    /*\n     * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n     * Information for each code path segment.\n     * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n     * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n     * - validNodes:\n     */\n\n    let segInfoMap = Object.create(null);\n    /**\n     * Gets the flag which shows `super()` is called in some paths.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} The flag which shows `super()` is called in some paths\n     */\n\n    function isCalledInSomePath(segment) {\n      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n    }\n    /**\n     * Gets the flag which shows `super()` is called in all paths.\n     * @param {CodePathSegment} segment A code path segment to get.\n     * @returns {boolean} The flag which shows `super()` is called in all paths.\n     */\n\n\n    function isCalledInEveryPath(segment) {\n      /*\n       * If specific segment is the looped segment of the current segment,\n       * skip the segment.\n       * If not skipped, this never becomes true after a loop.\n       */\n      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {\n        return true;\n      }\n\n      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n    }\n\n    return {\n      /**\n       * Stacks a constructor information.\n       * @param {CodePath} codePath A code path which was started.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          // Class > ClassBody > MethodDefinition > FunctionExpression\n          const classNode = node.parent.parent.parent;\n          const superClass = classNode.superClass;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(superClass),\n            superIsConstructor: isPossibleConstructor(superClass),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            superIsConstructor: false,\n            codePath\n          };\n        }\n      },\n\n      /**\n       * Pops a constructor information.\n       * And reports if `super()` lacked.\n       * @param {CodePath} codePath A code path which was ended.\n       * @param {ASTNode} node The current node.\n       * @returns {void}\n       */\n      onCodePathEnd(codePath, node) {\n        const hasExtends = funcInfo.hasExtends; // Pop.\n\n        funcInfo = funcInfo.upper;\n\n        if (!hasExtends) {\n          return;\n        } // Reports if `super()` lacked.\n\n\n        const segments = codePath.returnedSegments;\n        const calledInEveryPaths = segments.every(isCalledInEveryPath);\n        const calledInSomePaths = segments.some(isCalledInSomePath);\n\n        if (!calledInEveryPaths) {\n          context.report({\n            messageId: calledInSomePaths ? \"missingSome\" : \"missingAll\",\n            node: node.parent\n          });\n        }\n      },\n\n      /**\n       * Initialize information of a given code path segment.\n       * @param {CodePathSegment} segment A code path segment to initialize.\n       * @returns {void}\n       */\n      onCodePathSegmentStart(segment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Initialize info.\n\n\n        const info = segInfoMap[segment.id] = {\n          calledInSomePaths: false,\n          calledInEveryPaths: false,\n          validNodes: []\n        }; // When there are previous segments, aggregates these.\n\n        const prevSegments = segment.prevSegments;\n\n        if (prevSegments.length > 0) {\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n        }\n      },\n\n      /**\n       * Update information of the code path segment when a code path was\n       * looped.\n       * @param {CodePathSegment} fromSegment The code path segment of the\n       *      end of a loop.\n       * @param {CodePathSegment} toSegment A code path segment of the head\n       *      of a loop.\n       * @returns {void}\n       */\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Update information inside of the loop.\n\n\n        const isRealLoop = toSegment.prevSegments.length >= 2;\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, segment => {\n          const info = segInfoMap[segment.id];\n          const prevSegments = segment.prevSegments; // Updates flags.\n\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath); // If flags become true anew, reports the valid nodes.\n\n          if (info.calledInSomePaths || isRealLoop) {\n            const nodes = info.validNodes;\n            info.validNodes = [];\n\n            for (let i = 0; i < nodes.length; ++i) {\n              const node = nodes[i];\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            }\n          }\n        });\n      },\n\n      /**\n       * Checks for a call of `super()`.\n       * @param {ASTNode} node A CallExpression node to check.\n       * @returns {void}\n       */\n      \"CallExpression:exit\"(node) {\n        if (!(funcInfo && funcInfo.isConstructor)) {\n          return;\n        } // Skips except `super()`.\n\n\n        if (node.callee.type !== \"Super\") {\n          return;\n        } // Reports if needed.\n\n\n        if (funcInfo.hasExtends) {\n          const segments = funcInfo.codePath.currentSegments;\n          let duplicate = false;\n          let info = null;\n\n          for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            if (segment.reachable) {\n              info = segInfoMap[segment.id];\n              duplicate = duplicate || info.calledInSomePaths;\n              info.calledInSomePaths = info.calledInEveryPaths = true;\n            }\n          }\n\n          if (info) {\n            if (duplicate) {\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            } else if (!funcInfo.superIsConstructor) {\n              context.report({\n                messageId: \"badSuper\",\n                node\n              });\n            } else {\n              info.validNodes.push(node);\n            }\n          }\n        } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n          context.report({\n            messageId: \"unexpected\",\n            node\n          });\n        }\n      },\n\n      /**\n       * Set the mark to the returned path as `super()` was called.\n       * @param {ASTNode} node A ReturnStatement node to check.\n       * @returns {void}\n       */\n      ReturnStatement(node) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Skips if no argument.\n\n\n        if (!node.argument) {\n          return;\n        } // Returning argument is a substitute of 'super()'.\n\n\n        const segments = funcInfo.codePath.currentSegments;\n\n        for (let i = 0; i < segments.length; ++i) {\n          const segment = segments[i];\n\n          if (segment.reachable) {\n            const info = segInfoMap[segment.id];\n            info.calledInSomePaths = info.calledInEveryPaths = true;\n          }\n        }\n      },\n\n      /**\n       * Resets state.\n       * @returns {void}\n       */\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/constructor-super.js"],"names":["isReachable","segment","reachable","isConstructorFunction","node","type","parent","kind","isPossibleConstructor","name","right","left","alternate","consequent","lastExpression","expressions","length","module","exports","meta","docs","description","category","recommended","url","schema","messages","missingSome","missingAll","duplicate","badSuper","unexpected","create","context","funcInfo","segInfoMap","Object","isCalledInSomePath","id","calledInSomePaths","isCalledInEveryPath","nextSegments","isLoopedPrevSegment","calledInEveryPaths","onCodePathStart","codePath","classNode","superClass","upper","isConstructor","hasExtends","Boolean","superIsConstructor","onCodePathEnd","segments","returnedSegments","every","some","report","messageId","onCodePathSegmentStart","info","validNodes","prevSegments","onCodePathSegmentLoop","fromSegment","toSegment","isRealLoop","traverseSegments","first","last","nodes","i","callee","currentSegments","push","ReturnStatement","argument"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/constructor-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\n            missingAll: \"Expected to call 'super()'.\",\n\n            duplicate: \"Unexpected duplicate 'super()'.\",\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n            unexpected: \"Unexpected 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath A code path which was ended.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        messageId: calledInSomePaths\n                            ? \"missingSome\"\n                            : \"missingAll\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    messageId: \"duplicate\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                messageId: \"duplicate\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                messageId: \"badSuper\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        messageId: \"unexpected\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}