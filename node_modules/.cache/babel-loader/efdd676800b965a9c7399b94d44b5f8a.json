{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { normalizeHandler } from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\n\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n  /**\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n\n\n  get routes() {\n    return this._routes;\n  }\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n\n\n  addFetchListener() {\n    self.addEventListener('fetch', event => {\n      const {\n        request\n      } = event;\n      const responsePromise = this.handleRequest({\n        request,\n        event\n      });\n\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n\n\n  addCacheListener() {\n    self.addEventListener('message', async event => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {\n          payload\n        } = event.data;\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({\n            request\n          });\n        }));\n        event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n\n        if (event.ports && event.ports[0]) {\n          await requestPromises;\n          event.ports[0].postMessage(true);\n        }\n      }\n    });\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n\n\n  handleRequest({\n    request,\n    event\n  }) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request'\n      });\n    }\n\n    const url = new URL(request.url, location);\n\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n      }\n\n      return;\n    }\n\n    let {\n      params,\n      route\n    } = this.findMatchingRoute({\n      url,\n      request,\n      event\n    });\n    let handler = route && route.handler;\n    let debugMessages = [];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([`Found a route to handle this request:`, route]);\n\n        if (params) {\n          debugMessages.push([`Passing the following params to the route's handler:`, params]);\n        }\n      }\n    } // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n\n\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler.`); // This is used for debugging in logs in the case of an error.\n\n        route = '[Default Handler]';\n      }\n\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach(msg => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      }); // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n      logger.groupEnd();\n    } // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n\n\n    let responsePromise;\n\n    try {\n      responsePromise = handler.handle({\n        url,\n        request,\n        event,\n        params\n      });\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch(err => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.error(`Error thrown by:`, route);\n          logger.error(err);\n          logger.groupEnd();\n        }\n\n        return this._catchHandler.handle({\n          url,\n          event,\n          err\n        });\n      });\n    }\n\n    return responsePromise;\n  }\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n\n\n  findMatchingRoute({\n    url,\n    request,\n    event\n  }) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url'\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request'\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n\n    for (const route of routes) {\n      let params;\n      let matchResult = route.match({\n        url,\n        request,\n        event\n      });\n\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = matchResult;\n        } else if (matchResult.constructor === Object && Object.keys(matchResult).length > 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = matchResult;\n        } // Return early if have a match.\n\n\n        return {\n          route,\n          params\n        };\n      }\n    } // If no match was found above, return and empty object.\n\n\n    return {};\n  }\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n\n\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n\n\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n\n\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler'\n      });\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method'\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    } // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n\n\n    this._routes.get(route.method).push(route);\n  }\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n\n\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError('unregister-route-but-not-found-with-method', {\n        method: route.method\n      });\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n\n}\n\nexport { Router };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-routing/Router.mjs"],"names":["assert","logger","WorkboxError","getFriendlyURL","normalizeHandler","Router","constructor","_routes","Map","routes","addFetchListener","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","addCacheListener","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","protocol","startsWith","params","route","findMatchingRoute","handler","debugMessages","push","_defaultHandler","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","_catchHandler","catch","error","get","method","matchResult","match","length","Object","keys","setDefaultHandler","setCatchHandler","registerRoute","isType","hasMethod","has","set","unregisterRoute","routeIndex","indexOf","splice"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\n\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n\n  /**\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    self.addEventListener('fetch', (event) => {\n      const {request} = event;\n      const responsePromise = this.handleRequest({request, event});\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    self.addEventListener('message', async (event) => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {payload} = event.data;\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({request});\n        }));\n\n        event.waitUntil(requestPromises);\n\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports && event.ports[0]) {\n          await requestPromises;\n          event.ports[0].postMessage(true);\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest({request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request',\n      });\n    }\n\n    const url = new URL(request.url, location);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\n            `Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n\n    let {params, route} = this.findMatchingRoute({url, request, event});\n    let handler = route && route.handler;\n\n    let debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([\n          `Found a route to handle this request:`, route,\n        ]);\n\n        if (params) {\n          debugMessages.push([\n            `Passing the following params to the route's handler:`, params,\n          ]);\n        }\n      }\n    }\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` +\n          `back to the default handler.`);\n\n        // This is used for debugging in logs in the case of an error.\n        route = '[Default Handler]';\n      }\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach((msg) => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n\n      // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n\n      logger.groupEnd();\n    }\n\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({url, request, event, params});\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch((err) => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` +\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.error(`Error thrown by:`, route);\n          logger.error(err);\n          logger.groupEnd();\n        }\n        return this._catchHandler.handle({url, event, err});\n      });\n    }\n\n    return responsePromise;\n  }\n\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute({url, request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request',\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      let matchResult = route.match({url, request, event});\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = matchResult;\n        } else if ((matchResult.constructor === Object &&\n            Object.keys(matchResult).length > 0)) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = matchResult;\n        }\n\n        // Return early if have a match.\n        return {route, params};\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler',\n      });\n\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method',\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError(\n          'unregister-route-but-not-found-with-method', {\n            method: route.method,\n          }\n      );\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\n\nexport {Router};\n"]},"metadata":{},"sourceType":"module"}