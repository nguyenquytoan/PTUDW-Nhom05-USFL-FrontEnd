{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport './_version.mjs';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\n\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        }); // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        }); // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n\n\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : undefined;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n    const cache = await caches.open(this._cacheName);\n\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n        urlsExpired.forEach(url => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n\n\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n\n\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n    return timestamp < expireOlderThan;\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n\n\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n\n}\n\nexport { CacheExpiration };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-expiration/CacheExpiration.mjs"],"names":["CacheTimestampsModel","WorkboxError","assert","logger","CacheExpiration","constructor","cacheName","config","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_isRunning","_rerunRequested","_maxEntries","_maxAgeSeconds","_cacheName","_timestampModel","expireEntries","minTimestamp","Date","now","undefined","urlsExpired","cache","caches","open","url","delete","length","groupCollapsed","log","forEach","groupEnd","debug","updateTimestamp","setTimestamp","isURLExpired","methodName","timestamp","getTimestamp","expireOlderThan","Infinity"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n"]},"metadata":{},"sourceType":"module"}