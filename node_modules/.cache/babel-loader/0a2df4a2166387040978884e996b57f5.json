{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst contentPath = require('./path');\n\nconst fixOwner = require('../util/fix-owner');\n\nconst fs = require('graceful-fs');\n\nconst moveFile = require('../util/move-file');\n\nconst Minipass = require('minipass');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst Flush = require('minipass-flush');\n\nconst path = require('path');\n\nconst rimraf = util.promisify(require('rimraf'));\n\nconst ssri = require('ssri');\n\nconst uniqueFilename = require('unique-filename');\n\nconst {\n  disposer\n} = require('./../util/disposer');\n\nconst fsm = require('fs-minipass');\n\nconst writeFile = util.promisify(fs.writeFile);\nmodule.exports = write;\n\nfunction write(cache, data, opts) {\n  opts = opts || {};\n\n  if (opts.algorithms && opts.algorithms.length > 1) {\n    throw new Error('opts.algorithms only supports a single algorithm for now');\n  }\n\n  if (typeof opts.size === 'number' && data.length !== opts.size) {\n    return Promise.reject(sizeError(opts.size, data.length));\n  }\n\n  const sri = ssri.fromData(data, {\n    algorithms: opts.algorithms\n  });\n\n  if (opts.integrity && !ssri.checkData(data, opts.integrity, opts)) {\n    return Promise.reject(checksumError(opts.integrity, sri));\n  }\n\n  return disposer(makeTmp(cache, opts), makeTmpDisposer, tmp => {\n    return writeFile(tmp.target, data, {\n      flag: 'wx'\n    }).then(() => moveToDestination(tmp, cache, sri, opts));\n  }).then(() => ({\n    integrity: sri,\n    size: data.length\n  }));\n}\n\nmodule.exports.stream = writeStream; // writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\n\nclass CacacheWriteStream extends Flush {\n  constructor(cache, opts) {\n    super();\n    this.opts = opts;\n    this.cache = cache;\n    this.inputStream = new Minipass();\n    this.inputStream.on('error', er => this.emit('error', er));\n    this.inputStream.on('drain', () => this.emit('drain'));\n    this.handleContentP = null;\n  }\n\n  write(chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);\n    }\n\n    return this.inputStream.write(chunk, encoding, cb);\n  }\n\n  flush(cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty');\n        e.code = 'ENODATA'; // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n\n        return Promise.reject(e).catch(cb);\n      }\n\n      this.handleContentP.then(res => {\n        res.integrity && this.emit('integrity', res.integrity);\n        res.size !== null && this.emit('size', res.size);\n        cb();\n      }, er => cb(er));\n    });\n  }\n\n}\n\nfunction writeStream(cache, opts) {\n  opts = opts || {};\n  return new CacacheWriteStream(cache, opts);\n}\n\nfunction handleContent(inputStream, cache, opts) {\n  return disposer(makeTmp(cache, opts), makeTmpDisposer, tmp => {\n    return pipeToTmp(inputStream, cache, tmp.target, opts).then(res => {\n      return moveToDestination(tmp, cache, res.integrity, opts).then(() => res);\n    });\n  });\n}\n\nfunction pipeToTmp(inputStream, cache, tmpTarget, opts) {\n  let integrity;\n  let size;\n  const hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size\n  });\n  hashStream.on('integrity', i => {\n    integrity = i;\n  });\n  hashStream.on('size', s => {\n    size = s;\n  });\n  const outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx'\n  }); // NB: this can throw if the hashStream has a problem with\n  // it, and the data is fully written.  but pipeToTmp is only\n  // called in promisory contexts where that is handled.\n\n  const pipeline = new Pipeline(inputStream, hashStream, outStream);\n  return pipeline.promise().then(() => ({\n    integrity,\n    size\n  })).catch(er => rimraf(tmpTarget).then(() => {\n    throw er;\n  }));\n}\n\nfunction makeTmp(cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n  return fixOwner.mkdirfix(cache, path.dirname(tmpTarget)).then(() => ({\n    target: tmpTarget,\n    moved: false\n  }));\n}\n\nfunction makeTmpDisposer(tmp) {\n  if (tmp.moved) {\n    return Promise.resolve();\n  }\n\n  return rimraf(tmp.target);\n}\n\nfunction moveToDestination(tmp, cache, sri, opts) {\n  const destination = contentPath(cache, sri);\n  const destDir = path.dirname(destination);\n  return fixOwner.mkdirfix(cache, destDir).then(() => {\n    return moveFile(tmp.target, destination);\n  }).then(() => {\n    tmp.moved = true;\n    return fixOwner.chownr(cache, destination);\n  });\n}\n\nfunction sizeError(expected, found) {\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\n\nfunction checksumError(expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`);\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/cacache/lib/content/write.js"],"names":["util","require","contentPath","fixOwner","fs","moveFile","Minipass","Pipeline","Flush","path","rimraf","promisify","ssri","uniqueFilename","disposer","fsm","writeFile","module","exports","write","cache","data","opts","algorithms","length","Error","size","Promise","reject","sizeError","sri","fromData","integrity","checkData","checksumError","makeTmp","makeTmpDisposer","tmp","target","flag","then","moveToDestination","stream","writeStream","CacacheWriteStream","constructor","inputStream","on","er","emit","handleContentP","chunk","encoding","cb","handleContent","flush","end","e","code","catch","res","pipeToTmp","tmpTarget","hashStream","integrityStream","i","s","outStream","WriteStream","flags","pipeline","promise","join","tmpPrefix","mkdirfix","dirname","moved","resolve","destination","destDir","chownr","expected","found","err"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst contentPath = require('./path')\nconst fixOwner = require('../util/fix-owner')\nconst fs = require('graceful-fs')\nconst moveFile = require('../util/move-file')\nconst Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst Flush = require('minipass-flush')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\nconst { disposer } = require('./../util/disposer')\nconst fsm = require('fs-minipass')\n\nconst writeFile = util.promisify(fs.writeFile)\n\nmodule.exports = write\n\nfunction write (cache, data, opts) {\n  opts = opts || {}\n  if (opts.algorithms && opts.algorithms.length > 1) {\n    throw new Error('opts.algorithms only supports a single algorithm for now')\n  }\n  if (typeof opts.size === 'number' && data.length !== opts.size) {\n    return Promise.reject(sizeError(opts.size, data.length))\n  }\n  const sri = ssri.fromData(data, {\n    algorithms: opts.algorithms\n  })\n  if (opts.integrity && !ssri.checkData(data, opts.integrity, opts)) {\n    return Promise.reject(checksumError(opts.integrity, sri))\n  }\n\n  return disposer(makeTmp(cache, opts), makeTmpDisposer,\n    (tmp) => {\n      return writeFile(tmp.target, data, { flag: 'wx' })\n        .then(() => moveToDestination(tmp, cache, sri, opts))\n    })\n    .then(() => ({ integrity: sri, size: data.length }))\n}\n\nmodule.exports.stream = writeStream\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor (cache, opts) {\n    super()\n    this.opts = opts\n    this.cache = cache\n    this.inputStream = new Minipass()\n    this.inputStream.on('error', er => this.emit('error', er))\n    this.inputStream.on('drain', () => this.emit('drain'))\n    this.handleContentP = null\n  }\n\n  write (chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(\n        this.inputStream,\n        this.cache,\n        this.opts\n      )\n    }\n    return this.inputStream.write(chunk, encoding, cb)\n  }\n\n  flush (cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty')\n        e.code = 'ENODATA'\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb)\n      }\n      this.handleContentP.then(\n        (res) => {\n          res.integrity && this.emit('integrity', res.integrity)\n          res.size !== null && this.emit('size', res.size)\n          cb()\n        },\n        (er) => cb(er)\n      )\n    })\n  }\n}\n\nfunction writeStream (cache, opts) {\n  opts = opts || {}\n  return new CacacheWriteStream(cache, opts)\n}\n\nfunction handleContent (inputStream, cache, opts) {\n  return disposer(makeTmp(cache, opts), makeTmpDisposer, (tmp) => {\n    return pipeToTmp(inputStream, cache, tmp.target, opts)\n      .then((res) => {\n        return moveToDestination(\n          tmp,\n          cache,\n          res.integrity,\n          opts\n        ).then(() => res)\n      })\n  })\n}\n\nfunction pipeToTmp (inputStream, cache, tmpTarget, opts) {\n  let integrity\n  let size\n  const hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size\n  })\n  hashStream.on('integrity', i => { integrity = i })\n  hashStream.on('size', s => { size = s })\n\n  const outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx'\n  })\n\n  // NB: this can throw if the hashStream has a problem with\n  // it, and the data is fully written.  but pipeToTmp is only\n  // called in promisory contexts where that is handled.\n  const pipeline = new Pipeline(\n    inputStream,\n    hashStream,\n    outStream\n  )\n\n  return pipeline.promise()\n    .then(() => ({ integrity, size }))\n    .catch(er => rimraf(tmpTarget).then(() => { throw er }))\n}\n\nfunction makeTmp (cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n  return fixOwner.mkdirfix(cache, path.dirname(tmpTarget)).then(() => ({\n    target: tmpTarget,\n    moved: false\n  }))\n}\n\nfunction makeTmpDisposer (tmp) {\n  if (tmp.moved) {\n    return Promise.resolve()\n  }\n  return rimraf(tmp.target)\n}\n\nfunction moveToDestination (tmp, cache, sri, opts) {\n  const destination = contentPath(cache, sri)\n  const destDir = path.dirname(destination)\n\n  return fixOwner\n    .mkdirfix(cache, destDir)\n    .then(() => {\n      return moveFile(tmp.target, destination)\n    })\n    .then(() => {\n      tmp.moved = true\n      return fixOwner.chownr(cache, destination)\n    })\n}\n\nfunction sizeError (expected, found) {\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)\n  err.expected = expected\n  err.found = found\n  err.code = 'EBADSIZE'\n  return err\n}\n\nfunction checksumError (expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`)\n  err.code = 'EINTEGRITY'\n  err.expected = expected\n  err.found = found\n  return err\n}\n"]},"metadata":{},"sourceType":"script"}