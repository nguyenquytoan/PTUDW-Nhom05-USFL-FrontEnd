{"ast":null,"code":"/*!\n * XRegExp.matchRecursive 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nexport default (XRegExp => {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name,\n      value,\n      start,\n      end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = (str, left, right, flags, options) => {\n    flags = flags || '';\n    options = options || {};\n    const global = flags.includes('g');\n    const sticky = flags.includes('y'); // Flag `y` is controlled internally\n\n    const basicFlags = flags.replace(/y/g, '');\n    let {\n      escapeChar\n    } = options;\n    const vN = options.valueNames;\n    const output = [];\n    let openTokens = 0;\n    let delimStart = 0;\n    let delimEnd = 0;\n    let lastOuterEnd = 0;\n    let outerStart;\n    let innerStart;\n    let leftMatch;\n    let rightMatch;\n    let esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp(`(?:${escapeChar}[\\\\S\\\\s]|(?:(?!${// Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source})[^${escapeChar}])+)+`, // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push(str.slice(innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/src/addons/matchrecursive.js"],"names":["XRegExp","row","name","value","start","end","matchRecursive","str","left","right","flags","options","global","includes","sticky","basicFlags","replace","escapeChar","vN","valueNames","output","openTokens","delimStart","delimEnd","lastOuterEnd","outerStart","innerStart","leftMatch","rightMatch","esc","length","Error","escape","RegExp","union","conjunction","source","exec","index","push","slice"],"mappings":"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","sourcesContent":["/*!\n * XRegExp.matchRecursive 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\n\nexport default (XRegExp) => {\n\n    /**\n     * Returns a match detail object composed of the provided values.\n     *\n     * @private\n     */\n    function row(name, value, start, end) {\n        return {\n            name,\n            value,\n            start,\n            end\n        };\n    }\n\n    /**\n     * Returns an array of match strings between outermost left and right delimiters, or an array of\n     * objects with detailed match parts and position data. An error is thrown if delimiters are\n     * unbalanced within the data.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {String} left Left delimiter as an XRegExp pattern.\n     * @param {String} right Right delimiter as an XRegExp pattern.\n     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n     * @returns {Array} Array of matches, or an empty array.\n     * @example\n     *\n     * // Basic usage\n     * let str = '(t((e))s)t()(ing)';\n     * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n     * // -> ['t((e))s', '', 'ing']\n     *\n     * // Extended information mode with valueNames\n     * str = 'Here is <div> <div>an</div></div> example';\n     * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n     *   valueNames: ['between', 'left', 'match', 'right']\n     * });\n     * // -> [\n     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n     * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n     * // {name: 'between', value: ' example',       start: 33, end: 41}\n     * // ]\n     *\n     * // Omitting unneeded parts with null valueNames, and using escapeChar\n     * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n     * XRegExp.matchRecursive(str, '{', '}', 'g', {\n     *   valueNames: ['literal', null, 'value', null],\n     *   escapeChar: '\\\\'\n     * });\n     * // -> [\n     * // {name: 'literal', value: '...',  start: 0, end: 3},\n     * // {name: 'value',   value: '1',    start: 4, end: 5},\n     * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n     * // ]\n     *\n     * // Sticky mode via flag y\n     * str = '<1><<<2>>><3>4<5>';\n     * XRegExp.matchRecursive(str, '<', '>', 'gy');\n     * // -> ['1', '<<2>>', '3']\n     */\n    XRegExp.matchRecursive = (str, left, right, flags, options) => {\n        flags = flags || '';\n        options = options || {};\n        const global = flags.includes('g');\n        const sticky = flags.includes('y');\n        // Flag `y` is controlled internally\n        const basicFlags = flags.replace(/y/g, '');\n        let {escapeChar} = options;\n        const vN = options.valueNames;\n        const output = [];\n        let openTokens = 0;\n        let delimStart = 0;\n        let delimEnd = 0;\n        let lastOuterEnd = 0;\n        let outerStart;\n        let innerStart;\n        let leftMatch;\n        let rightMatch;\n        let esc;\n        left = XRegExp(left, basicFlags);\n        right = XRegExp(right, basicFlags);\n\n        if (escapeChar) {\n            if (escapeChar.length > 1) {\n                throw new Error('Cannot use more than one escape character');\n            }\n            escapeChar = XRegExp.escape(escapeChar);\n            // Example of concatenated `esc` regex:\n            // `escapeChar`: '%'\n            // `left`: '<'\n            // `right`: '>'\n            // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n            esc = new RegExp(\n                `(?:${escapeChar}[\\\\S\\\\s]|(?:(?!${\n                    // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n                    // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n                    // transformation resulting from those flags was already applied to `left` and\n                    // `right` when they were passed through the XRegExp constructor above.\n                    XRegExp.union([left, right], '', {conjunction: 'or'}).source\n                })[^${escapeChar}])+)+`,\n                // Flags `gy` not needed here\n                flags.replace(/[^imu]+/g, '')\n            );\n        }\n\n        while (true) {\n            // If using an escape character, advance to the delimiter's next starting position,\n            // skipping any escaped characters in between\n            if (escapeChar) {\n                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n            }\n            leftMatch = XRegExp.exec(str, left, delimEnd);\n            rightMatch = XRegExp.exec(str, right, delimEnd);\n            // Keep the leftmost match only\n            if (leftMatch && rightMatch) {\n                if (leftMatch.index <= rightMatch.index) {\n                    rightMatch = null;\n                } else {\n                    leftMatch = null;\n                }\n            }\n            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n            // LM | RM | OT | Result\n            // 1  | 0  | 1  | loop\n            // 1  | 0  | 0  | loop\n            // 0  | 1  | 1  | loop\n            // 0  | 1  | 0  | throw\n            // 0  | 0  | 1  | throw\n            // 0  | 0  | 0  | break\n            // The paths above don't include the sticky mode special case. The loop ends after the\n            // first completed match if not `global`.\n            if (leftMatch || rightMatch) {\n                delimStart = (leftMatch || rightMatch).index;\n                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n            } else if (!openTokens) {\n                break;\n            }\n            if (sticky && !openTokens && delimStart > lastOuterEnd) {\n                break;\n            }\n            if (leftMatch) {\n                if (!openTokens) {\n                    outerStart = delimStart;\n                    innerStart = delimEnd;\n                }\n                ++openTokens;\n            } else if (rightMatch && openTokens) {\n                if (!--openTokens) {\n                    if (vN) {\n                        if (vN[0] && outerStart > lastOuterEnd) {\n                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n                        }\n                        if (vN[1]) {\n                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));\n                        }\n                        if (vN[2]) {\n                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));\n                        }\n                        if (vN[3]) {\n                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));\n                        }\n                    } else {\n                        output.push(str.slice(innerStart, delimStart));\n                    }\n                    lastOuterEnd = delimEnd;\n                    if (!global) {\n                        break;\n                    }\n                }\n            } else {\n                throw new Error('Unbalanced delimiter found in string');\n            }\n            // If the delimiter matched an empty string, avoid an infinite loop\n            if (delimStart === delimEnd) {\n                ++delimEnd;\n            }\n        }\n\n        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));\n        }\n\n        return output;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}