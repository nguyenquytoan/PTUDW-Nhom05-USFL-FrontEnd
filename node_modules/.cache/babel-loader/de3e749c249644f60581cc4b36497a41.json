{"ast":null,"code":"const openBracket = '{'.charCodeAt(0);\nconst closeBracket = '}'.charCodeAt(0);\nconst openParen = '('.charCodeAt(0);\nconst closeParen = ')'.charCodeAt(0);\nconst singleQuote = \"'\".charCodeAt(0);\nconst doubleQuote = '\"'.charCodeAt(0);\nconst backslash = '\\\\'.charCodeAt(0);\nconst slash = '/'.charCodeAt(0);\nconst period = '.'.charCodeAt(0);\nconst comma = ','.charCodeAt(0);\nconst colon = ':'.charCodeAt(0);\nconst asterisk = '*'.charCodeAt(0);\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\nconst pound = '#'.charCodeAt(0);\nconst newline = '\\n'.charCodeAt(0);\nconst space = ' '.charCodeAt(0);\nconst feed = '\\f'.charCodeAt(0);\nconst tab = '\\t'.charCodeAt(0);\nconst cr = '\\r'.charCodeAt(0);\nconst at = '@'.charCodeAt(0);\nconst lowerE = 'e'.charCodeAt(0);\nconst upperE = 'E'.charCodeAt(0);\nconst digit0 = '0'.charCodeAt(0);\nconst digit9 = '9'.charCodeAt(0);\nconst lowerU = 'u'.charCodeAt(0);\nconst upperU = 'U'.charCodeAt(0);\nconst atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;,/]/g;\nconst wordEnd = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\nconst wordEndNum = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\-\\+\\|~>,\\[\\]\\\\]|\\//g;\nconst alphaNum = /^[a-z0-9]/i;\nconst unicodeRange = /^[a-f0-9?\\-]/i;\n\nconst util = require('util');\n\nconst TokenizeError = require('./errors/TokenizeError');\n\nmodule.exports = function tokenize(input, options) {\n  options = options || {};\n  const tokens = [];\n  const css = input.valueOf();\n  const length = css.length;\n  let offset = -1;\n  let line = 1;\n  let pos = 0;\n  let parentCount = 0;\n  let isURLArg = null;\n  let code;\n  let next;\n  let quote;\n  let lines;\n  let last;\n  let content;\n  let escape;\n  let nextLine;\n  let nextOffset;\n  let escaped;\n  let escapePos;\n  let nextChar;\n\n  function unclosed(what) {\n    const message = util.format('Unclosed %s at line: %d, column: %d, token: %d', what, line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  function tokenizeError() {\n    const message = util.format('Syntax error at line: %d, column: %d, token: %d', line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  while (pos < length) {\n    code = css.charCodeAt(pos);\n\n    if (code === newline) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case newline:\n      case space:\n      case tab:\n      case cr:\n      case feed:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === space || code === newline || code === tab || code === cr || code === feed);\n\n        tokens.push(['space', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case colon:\n        next = pos + 1;\n        tokens.push(['colon', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case comma:\n        next = pos + 1;\n        tokens.push(['comma', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case openBracket:\n        tokens.push(['{', '{', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeBracket:\n        tokens.push(['}', '}', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case openParen:\n        parentCount++;\n        isURLArg = !isURLArg && parentCount === 1 && tokens.length > 0 && tokens[tokens.length - 1][0] === 'word' && tokens[tokens.length - 1][1] === 'url';\n        tokens.push(['(', '(', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeParen:\n        parentCount--;\n        isURLArg = !isURLArg && parentCount === 1;\n        tokens.push([')', ')', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case singleQuote:\n      case doubleQuote:\n        quote = code === singleQuote ? \"'\" : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case at:\n        atEnd.lastIndex = pos + 1;\n        atEnd.test(css);\n\n        if (atEnd.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = atEnd.lastIndex - 2;\n        }\n\n        tokens.push(['atword', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case backslash:\n        next = pos;\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n          next += 1;\n        }\n\n        tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case plus:\n      case minus:\n      case asterisk:\n        next = pos + 1;\n        nextChar = css.slice(pos + 1, next + 1);\n        const prevChar = css.slice(pos - 1, pos); // if the operator is immediately followed by a word character, then we\n        // have a prefix of some kind, and should fall-through. eg. -webkit\n        // look for --* for custom variables\n\n        if (code === minus && nextChar.charCodeAt(0) === minus) {\n          next++;\n          tokens.push(['word', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n          break;\n        }\n\n        tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      default:\n        if (code === slash && (css.charCodeAt(pos + 1) === asterisk || options.loose && !isURLArg && css.charCodeAt(pos + 1) === slash)) {\n          const isStandardComment = css.charCodeAt(pos + 1) === asterisk;\n\n          if (isStandardComment) {\n            next = css.indexOf('*/', pos + 2) + 1;\n\n            if (next === 0) {\n              unclosed('comment', '*/');\n            }\n          } else {\n            const newlinePos = css.indexOf('\\n', pos + 2);\n            next = newlinePos !== -1 ? newlinePos - 1 : length;\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else if (code === pound && !alphaNum.test(css.slice(pos + 1, pos + 2))) {\n          next = pos + 1;\n          tokens.push(['#', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n        } else if ((code === lowerU || code === upperU) && css.charCodeAt(pos + 1) === plus) {\n          next = pos + 2;\n\n          do {\n            next += 1;\n            code = css.charCodeAt(next);\n          } while (next < length && unicodeRange.test(css.slice(next, next + 1)));\n\n          tokens.push(['unicoderange', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n        } // catch a regular slash, that isn't a comment\n        else if (code === slash) {\n            next = pos + 1;\n            tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n            pos = next - 1;\n          } else {\n            let regex = wordEnd; // we're dealing with a word that starts with a number\n            // those get treated differently\n\n            if (code >= digit0 && code <= digit9) {\n              regex = wordEndNum;\n            }\n\n            regex.lastIndex = pos + 1;\n            regex.test(css);\n\n            if (regex.lastIndex === 0) {\n              next = css.length - 1;\n            } else {\n              next = regex.lastIndex - 2;\n            } // Exponential number notation with minus or plus: 1e-10, 1e+10\n\n\n            if (regex === wordEndNum || code === period) {\n              const ncode = css.charCodeAt(next);\n              const ncode1 = css.charCodeAt(next + 1);\n              const ncode2 = css.charCodeAt(next + 2);\n\n              if ((ncode === lowerE || ncode === upperE) && (ncode1 === minus || ncode1 === plus) && ncode2 >= digit0 && ncode2 <= digit9) {\n                wordEndNum.lastIndex = next + 2;\n                wordEndNum.test(css);\n\n                if (wordEndNum.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = wordEndNum.lastIndex - 2;\n                }\n              }\n            }\n\n            tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n            pos = next;\n          }\n\n        break;\n    }\n\n    pos++;\n  }\n\n  return tokens;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-values-parser/old-lib/tokenize.js"],"names":["openBracket","charCodeAt","closeBracket","openParen","closeParen","singleQuote","doubleQuote","backslash","slash","period","comma","colon","asterisk","minus","plus","pound","newline","space","feed","tab","cr","at","lowerE","upperE","digit0","digit9","lowerU","upperU","atEnd","wordEnd","wordEndNum","alphaNum","unicodeRange","util","require","TokenizeError","module","exports","tokenize","input","options","tokens","css","valueOf","length","offset","line","pos","parentCount","isURLArg","code","next","quote","lines","last","content","escape","nextLine","nextOffset","escaped","escapePos","nextChar","unclosed","what","message","format","tokenizeError","push","slice","indexOf","lastIndex","test","prevChar","loose","isStandardComment","newlinePos","split","regex","ncode","ncode1","ncode2"],"mappings":"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","sourcesContent":["const openBracket = '{'.charCodeAt(0);\nconst closeBracket = '}'.charCodeAt(0);\nconst openParen = '('.charCodeAt(0);\nconst closeParen = ')'.charCodeAt(0);\nconst singleQuote = \"'\".charCodeAt(0);\nconst doubleQuote = '\"'.charCodeAt(0);\nconst backslash = '\\\\'.charCodeAt(0);\nconst slash = '/'.charCodeAt(0);\nconst period = '.'.charCodeAt(0);\nconst comma = ','.charCodeAt(0);\nconst colon = ':'.charCodeAt(0);\nconst asterisk = '*'.charCodeAt(0);\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\nconst pound = '#'.charCodeAt(0);\nconst newline = '\\n'.charCodeAt(0);\nconst space = ' '.charCodeAt(0);\nconst feed = '\\f'.charCodeAt(0);\nconst tab = '\\t'.charCodeAt(0);\nconst cr = '\\r'.charCodeAt(0);\nconst at = '@'.charCodeAt(0);\nconst lowerE = 'e'.charCodeAt(0);\nconst upperE = 'E'.charCodeAt(0);\nconst digit0 = '0'.charCodeAt(0);\nconst digit9 = '9'.charCodeAt(0);\nconst lowerU = 'u'.charCodeAt(0);\nconst upperU = 'U'.charCodeAt(0);\nconst atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;,/]/g;\nconst wordEnd = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\nconst wordEndNum = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\-\\+\\|~>,\\[\\]\\\\]|\\//g;\nconst alphaNum = /^[a-z0-9]/i;\nconst unicodeRange = /^[a-f0-9?\\-]/i;\n\nconst util = require('util');\n\nconst TokenizeError = require('./errors/TokenizeError');\n\nmodule.exports = function tokenize(input, options) {\n  options = options || {};\n\n  const tokens = [];\n\n  const css = input.valueOf();\n\n  const length = css.length;\n\n  let offset = -1;\n\n  let line = 1;\n\n  let pos = 0;\n\n  let parentCount = 0;\n\n  let isURLArg = null;\n\n  let code;\n  let next;\n  let quote;\n  let lines;\n  let last;\n  let content;\n  let escape;\n  let nextLine;\n  let nextOffset;\n\n  let escaped;\n  let escapePos;\n  let nextChar;\n\n  function unclosed(what) {\n    const message = util.format(\n      'Unclosed %s at line: %d, column: %d, token: %d',\n      what,\n      line,\n      pos - offset,\n      pos\n    );\n    throw new TokenizeError(message);\n  }\n\n  function tokenizeError() {\n    const message = util.format(\n      'Syntax error at line: %d, column: %d, token: %d',\n      line,\n      pos - offset,\n      pos\n    );\n    throw new TokenizeError(message);\n  }\n\n  while (pos < length) {\n    code = css.charCodeAt(pos);\n\n    if (code === newline) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case newline:\n      case space:\n      case tab:\n      case cr:\n      case feed:\n        next = pos;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n          if (code === newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (\n          code === space ||\n          code === newline ||\n          code === tab ||\n          code === cr ||\n          code === feed\n        );\n\n        tokens.push(['space', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n\n        pos = next - 1;\n        break;\n\n      case colon:\n        next = pos + 1;\n        tokens.push(['colon', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n\n        pos = next - 1;\n        break;\n\n      case comma:\n        next = pos + 1;\n        tokens.push(['comma', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n\n        pos = next - 1;\n        break;\n\n      case openBracket:\n        tokens.push(['{', '{', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeBracket:\n        tokens.push(['}', '}', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case openParen:\n        parentCount++;\n        isURLArg =\n          !isURLArg &&\n          parentCount === 1 &&\n          tokens.length > 0 &&\n          tokens[tokens.length - 1][0] === 'word' &&\n          tokens[tokens.length - 1][1] === 'url';\n        tokens.push(['(', '(', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeParen:\n        parentCount--;\n        isURLArg = !isURLArg && parentCount === 1;\n        tokens.push([')', ')', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case singleQuote:\n      case doubleQuote:\n        quote = code === singleQuote ? \"'\" : '\"';\n        next = pos;\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n          escapePos = next;\n          while (css.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokens.push([\n          'string',\n          css.slice(pos, next + 1),\n          line,\n          pos - offset,\n          line,\n          next - offset,\n          pos\n        ]);\n        pos = next;\n        break;\n\n      case at:\n        atEnd.lastIndex = pos + 1;\n        atEnd.test(css);\n\n        if (atEnd.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = atEnd.lastIndex - 2;\n        }\n\n        tokens.push([\n          'atword',\n          css.slice(pos, next + 1),\n          line,\n          pos - offset,\n          line,\n          next - offset,\n          pos\n        ]);\n        pos = next;\n        break;\n\n      case backslash:\n        next = pos;\n        code = css.charCodeAt(next + 1);\n\n        if (\n          escape &&\n          (code !== slash &&\n            code !== space &&\n            code !== newline &&\n            code !== tab &&\n            code !== cr &&\n            code !== feed)\n        ) {\n          next += 1;\n        }\n\n        tokens.push([\n          'word',\n          css.slice(pos, next + 1),\n          line,\n          pos - offset,\n          line,\n          next - offset,\n          pos\n        ]);\n\n        pos = next;\n        break;\n\n      case plus:\n      case minus:\n      case asterisk:\n        next = pos + 1;\n        nextChar = css.slice(pos + 1, next + 1);\n\n        const prevChar = css.slice(pos - 1, pos);\n\n        // if the operator is immediately followed by a word character, then we\n        // have a prefix of some kind, and should fall-through. eg. -webkit\n\n        // look for --* for custom variables\n        if (code === minus && nextChar.charCodeAt(0) === minus) {\n          next++;\n\n          tokens.push(['word', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n\n          pos = next - 1;\n          break;\n        }\n\n        tokens.push([\n          'operator',\n          css.slice(pos, next),\n          line,\n          pos - offset,\n          line,\n          next - offset,\n          pos\n        ]);\n\n        pos = next - 1;\n        break;\n\n      default:\n        if (\n          code === slash &&\n          (css.charCodeAt(pos + 1) === asterisk ||\n            (options.loose && !isURLArg && css.charCodeAt(pos + 1) === slash))\n        ) {\n          const isStandardComment = css.charCodeAt(pos + 1) === asterisk;\n\n          if (isStandardComment) {\n            next = css.indexOf('*/', pos + 2) + 1;\n            if (next === 0) {\n              unclosed('comment', '*/');\n            }\n          } else {\n            const newlinePos = css.indexOf('\\n', pos + 2);\n\n            next = newlinePos !== -1 ? newlinePos - 1 : length;\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);\n\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else if (code === pound && !alphaNum.test(css.slice(pos + 1, pos + 2))) {\n          next = pos + 1;\n\n          tokens.push(['#', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n\n          pos = next - 1;\n        } else if ((code === lowerU || code === upperU) && css.charCodeAt(pos + 1) === plus) {\n          next = pos + 2;\n\n          do {\n            next += 1;\n            code = css.charCodeAt(next);\n          } while (next < length && unicodeRange.test(css.slice(next, next + 1)));\n\n          tokens.push([\n            'unicoderange',\n            css.slice(pos, next),\n            line,\n            pos - offset,\n            line,\n            next - offset,\n            pos\n          ]);\n          pos = next - 1;\n        }\n        // catch a regular slash, that isn't a comment\n        else if (code === slash) {\n          next = pos + 1;\n\n          tokens.push([\n            'operator',\n            css.slice(pos, next),\n            line,\n            pos - offset,\n            line,\n            next - offset,\n            pos\n          ]);\n\n          pos = next - 1;\n        } else {\n          let regex = wordEnd;\n\n          // we're dealing with a word that starts with a number\n          // those get treated differently\n          if (code >= digit0 && code <= digit9) {\n            regex = wordEndNum;\n          }\n\n          regex.lastIndex = pos + 1;\n          regex.test(css);\n\n          if (regex.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = regex.lastIndex - 2;\n          }\n\n          // Exponential number notation with minus or plus: 1e-10, 1e+10\n          if (regex === wordEndNum || code === period) {\n            const ncode = css.charCodeAt(next);\n\n            const ncode1 = css.charCodeAt(next + 1);\n\n            const ncode2 = css.charCodeAt(next + 2);\n\n            if (\n              (ncode === lowerE || ncode === upperE) &&\n              (ncode1 === minus || ncode1 === plus) &&\n              (ncode2 >= digit0 && ncode2 <= digit9)\n            ) {\n              wordEndNum.lastIndex = next + 2;\n              wordEndNum.test(css);\n\n              if (wordEndNum.lastIndex === 0) {\n                next = css.length - 1;\n              } else {\n                next = wordEndNum.lastIndex - 2;\n              }\n            }\n          }\n\n          tokens.push([\n            'word',\n            css.slice(pos, next + 1),\n            line,\n            pos - offset,\n            line,\n            next - offset,\n            pos\n          ]);\n          pos = next;\n        }\n        break;\n    }\n\n    pos++;\n  }\n\n  return tokens;\n};\n"]},"metadata":{},"sourceType":"script"}