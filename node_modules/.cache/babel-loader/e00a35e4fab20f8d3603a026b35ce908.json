{"ast":null,"code":"/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a particular style for multiline comments\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"starred-block\", \"separate-lines\", \"bare-block\"]\n    }],\n    messages: {\n      expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n      expectedBareBlock: \"Expected a block comment without padding stars.\",\n      startNewline: \"Expected a linebreak after '/*'.\",\n      endNewline: \"Expected a linebreak before '*/'.\",\n      missingStar: \"Expected a '*' at the start of this line.\",\n      alignment: \"Expected this line to be aligned with the start of the comment.\",\n      expectedLines: \"Expected multiple line comments instead of a block comment.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"starred-block\"; //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Checks if a comment line is starred.\n     * @param {string} line A string representing a comment line.\n     * @returns {boolean} Whether or not the comment line is starred.\n     */\n\n    function isStarredCommentLine(line) {\n      return /^\\s*\\*/u.test(line);\n    }\n    /**\n     * Checks if a comment group is in starred-block form.\n     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n     * @returns {boolean} Whether or not the comment group is in starred block form.\n     */\n\n\n    function isStarredBlockComment([firstComment]) {\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER); // The first and last lines can only contain whitespace.\n\n      return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n    }\n    /**\n     * Checks if a comment group is in JSDoc form.\n     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n     * @returns {boolean} Whether or not the comment group is in JSDoc form.\n     */\n\n\n    function isJSDocComment([firstComment]) {\n      if (firstComment.type !== \"Block\") {\n        return false;\n      }\n\n      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n      return /^\\*\\s*$/u.test(lines[0]) && lines.slice(1, -1).every(line => /^\\s* /u.test(line)) && /^\\s*$/u.test(lines[lines.length - 1]);\n    }\n    /**\n     * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n     * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n     * @returns {string[]} An array of the processed lines.\n     */\n\n\n    function processSeparateLineComments(commentGroup) {\n      const allLinesHaveLeadingSpace = commentGroup.map(({\n        value\n      }) => value).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return commentGroup.map(({\n        value\n      }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value);\n    }\n    /**\n     * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n     * @param {Token} comment A single block comment token in starred-block form.\n     * @returns {string[]} An array of the processed lines.\n     */\n\n\n    function processStarredBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map(line => line.replace(/^\\s*$/u, \"\"));\n      const allLinesHaveLeadingSpace = lines.map(line => line.replace(/\\s*\\*/u, \"\")).filter(line => line.trim().length).every(line => line.startsWith(\" \"));\n      return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n    }\n    /**\n     * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n     * @param {Token} comment A single block comment token in bare-block form.\n     * @returns {string[]} An array of the processed lines.\n     */\n\n\n    function processBareBlockComment(comment) {\n      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n      const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n      let offset = \"\";\n      /*\n       * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n       * The first line should not be checked because it is inline with the opening block comment delimiter.\n       */\n\n      for (const [i, line] of lines.entries()) {\n        if (!line.trim().length || i === 0) {\n          continue;\n        }\n\n        const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n        if (lineOffset.length < leadingWhitespace.length) {\n          const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n          if (newOffset.length > offset.length) {\n            offset = newOffset;\n          }\n        }\n      }\n\n      return lines.map(line => {\n        const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n        const [, lineOffset, lineContents] = match;\n\n        if (lineOffset.length > leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n        }\n\n        if (lineOffset.length < leadingWhitespace.length) {\n          return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n        }\n\n        return lineContents;\n      });\n    }\n    /**\n     * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n     * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n     * @returns {string[]} A list of comment lines.\n     */\n\n\n    function getCommentLines(commentGroup) {\n      const [firstComment] = commentGroup;\n\n      if (firstComment.type === \"Line\") {\n        return processSeparateLineComments(commentGroup);\n      }\n\n      if (isStarredBlockComment(commentGroup)) {\n        return processStarredBlockComment(firstComment);\n      }\n\n      return processBareBlockComment(firstComment);\n    }\n    /**\n     * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n     * @param {Token} comment The token to check.\n     * @returns {string} The offset from the beginning of a line to the token.\n     */\n\n\n    function getInitialOffset(comment) {\n      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n    }\n    /**\n     * Converts a comment into starred-block form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n     */\n\n\n    function convertToStarredBlock(firstComment, commentLinesList) {\n      const initialOffset = getInitialOffset(firstComment);\n      return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n    }\n    /**\n     * Converts a comment into separate-line form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in separate-line form\n     */\n\n\n    function convertToSeparateLines(firstComment, commentLinesList) {\n      return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n    }\n    /**\n     * Converts a comment into bare-block form\n     * @param {Token} firstComment The first comment of the group being converted\n     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n     * @returns {string} A representation of the comment value in bare-block form\n     */\n\n\n    function convertToBlock(firstComment, commentLinesList) {\n      return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n    }\n    /**\n     * Each method checks a group of comments to see if it's valid according to the given option.\n     * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n     * block comment or multiple line comments.\n     * @returns {void}\n     */\n\n\n    const commentGroupCheckers = {\n      \"starred-block\"(commentGroup) {\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup);\n\n        if (commentLines.some(value => value.includes(\"*/\"))) {\n          return;\n        }\n\n        if (commentGroup.length > 1) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n              return commentLines.some(value => value.startsWith(\"/\")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n            }\n\n          });\n        } else {\n          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n          const expectedLeadingWhitespace = getInitialOffset(firstComment);\n          const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n          if (!/^\\*?\\s*$/u.test(lines[0])) {\n            const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n            context.report({\n              loc: {\n                start: firstComment.loc.start,\n                end: {\n                  line: firstComment.loc.start.line,\n                  column: firstComment.loc.start.column + 2\n                }\n              },\n              messageId: \"startNewline\",\n              fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n            });\n          }\n\n          if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n            context.report({\n              loc: {\n                start: {\n                  line: firstComment.loc.end.line,\n                  column: firstComment.loc.end.column - 2\n                },\n                end: firstComment.loc.end\n              },\n              messageId: \"endNewline\",\n              fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n            });\n          }\n\n          for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n            const lineText = sourceCode.lines[lineNumber - 1];\n            const errorType = isStarredCommentLine(lineText) ? \"alignment\" : \"missingStar\";\n\n            if (!lineText.startsWith(expectedLinePrefix)) {\n              context.report({\n                loc: {\n                  start: {\n                    line: lineNumber,\n                    column: 0\n                  },\n                  end: {\n                    line: lineNumber,\n                    column: lineText.length\n                  }\n                },\n                messageId: errorType,\n\n                fix(fixer) {\n                  const lineStartIndex = sourceCode.getIndexFromLoc({\n                    line: lineNumber,\n                    column: 0\n                  });\n\n                  if (errorType === \"alignment\") {\n                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                  }\n\n                  const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                  const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                  let offset;\n\n                  for (const [idx, line] of lines.entries()) {\n                    if (!/\\S+/u.test(line)) {\n                      continue;\n                    }\n\n                    const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                    const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n                    offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n                    break;\n                  }\n\n                  return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                }\n\n              });\n            }\n          }\n        }\n      },\n\n      \"separate-lines\"(commentGroup) {\n        const [firstComment] = commentGroup;\n\n        if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n          return;\n        }\n\n        const commentLines = getCommentLines(commentGroup);\n        const tokenAfter = sourceCode.getTokenAfter(firstComment, {\n          includeComments: true\n        });\n\n        if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n          return;\n        }\n\n        context.report({\n          loc: {\n            start: firstComment.loc.start,\n            end: {\n              line: firstComment.loc.start.line,\n              column: firstComment.loc.start.column + 2\n            }\n          },\n          messageId: \"expectedLines\",\n\n          fix(fixer) {\n            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n          }\n\n        });\n      },\n\n      \"bare-block\"(commentGroup) {\n        if (isJSDocComment(commentGroup)) {\n          return;\n        }\n\n        const [firstComment] = commentGroup;\n        const commentLines = getCommentLines(commentGroup); // Disallows consecutive line comments in favor of using a block comment.\n\n        if (firstComment.type === \"Line\" && commentLines.length > 1 && !commentLines.some(value => value.includes(\"*/\"))) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: commentGroup[commentGroup.length - 1].loc.end\n            },\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));\n            }\n\n          });\n        } // Prohibits block comments from having a * at the beginning of each line.\n\n\n        if (isStarredBlockComment(commentGroup)) {\n          context.report({\n            loc: {\n              start: firstComment.loc.start,\n              end: {\n                line: firstComment.loc.start.line,\n                column: firstComment.loc.start.column + 2\n              }\n            },\n            messageId: \"expectedBareBlock\",\n\n            fix(fixer) {\n              return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n            }\n\n          });\n        }\n      }\n\n    }; //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      Program() {\n        return sourceCode.getAllComments().filter(comment => comment.type !== \"Shebang\").filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n        }).reduce((commentGroups, comment, index, commentList) => {\n          const tokenBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n\n          if (comment.type === \"Line\" && index && commentList[index - 1].type === \"Line\" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {\n            commentGroups[commentGroups.length - 1].push(comment);\n          } else {\n            commentGroups.push([comment]);\n          }\n\n          return commentGroups;\n        }, []).filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/multiline-comment-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expectedBlock","expectedBareBlock","startNewline","endNewline","missingStar","alignment","expectedLines","create","context","sourceCode","getSourceCode","option","options","isStarredCommentLine","line","test","isStarredBlockComment","firstComment","lines","value","split","LINEBREAK_MATCHER","length","every","i","isJSDocComment","slice","processSeparateLineComments","commentGroup","allLinesHaveLeadingSpace","map","filter","trim","startsWith","replace","processStarredBlockComment","comment","linesArr","processBareBlockComment","leadingWhitespace","text","range","loc","start","column","offset","entries","lineOffset","match","newOffset","lineContents","getCommentLines","getInitialOffset","convertToStarredBlock","commentLinesList","initialOffset","join","convertToSeparateLines","convertToBlock","commentGroupCheckers","commentLines","some","includes","report","end","messageId","fix","fixer","replaceTextRange","expectedLeadingWhitespace","expectedLinePrefix","insertTextAfterRange","lineNumber","lineText","errorType","lineStartIndex","getIndexFromLoc","commentTextPrefix","commentTextStartIndex","idx","lineTextToAlignWith","prefix","tokenAfter","getTokenAfter","includeComments","replaceText","Program","getAllComments","COMMENTS_IGNORE_PATTERN","tokenBefore","getTokenBefore","reduce","commentGroups","index","commentList","push","forEach"],"mappings":"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","sourcesContent":["/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a particular style for multiline comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [{ enum: [\"starred-block\", \"separate-lines\", \"bare-block\"] }],\n        messages: {\n            expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n            expectedBareBlock: \"Expected a block comment without padding stars.\",\n            startNewline: \"Expected a linebreak after '/*'.\",\n            endNewline: \"Expected a linebreak before '*/'.\",\n            missingStar: \"Expected a '*' at the start of this line.\",\n            alignment: \"Expected this line to be aligned with the start of the comment.\",\n            expectedLines: \"Expected multiple line comments instead of a block comment.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"starred-block\";\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks if a comment line is starred.\n         * @param {string} line A string representing a comment line.\n         * @returns {boolean} Whether or not the comment line is starred.\n         */\n        function isStarredCommentLine(line) {\n            return /^\\s*\\*/u.test(line);\n        }\n\n        /**\n         * Checks if a comment group is in starred-block form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in starred block form.\n         */\n        function isStarredBlockComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            // The first and last lines can only contain whitespace.\n            return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n        }\n\n        /**\n         * Checks if a comment group is in JSDoc form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in JSDoc form.\n         */\n        function isJSDocComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            return /^\\*\\s*$/u.test(lines[0]) &&\n                lines.slice(1, -1).every(line => /^\\s* /u.test(line)) &&\n                /^\\s*$/u.test(lines[lines.length - 1]);\n        }\n\n        /**\n         * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n         * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processSeparateLineComments(commentGroup) {\n            const allLinesHaveLeadingSpace = commentGroup\n                .map(({ value }) => value)\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return commentGroup.map(({ value }) => (allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value));\n        }\n\n        /**\n         * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in starred-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processStarredBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER)\n                .filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1))\n                .map(line => line.replace(/^\\s*$/u, \"\"));\n            const allLinesHaveLeadingSpace = lines\n                .map(line => line.replace(/\\s*\\*/u, \"\"))\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n        }\n\n        /**\n         * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in bare-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processBareBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n            const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n            let offset = \"\";\n\n            /*\n             * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n             * The first line should not be checked because it is inline with the opening block comment delimiter.\n             */\n            for (const [i, line] of lines.entries()) {\n                if (!line.trim().length || i === 0) {\n                    continue;\n                }\n\n                const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n                    if (newOffset.length > offset.length) {\n                        offset = newOffset;\n                    }\n                }\n            }\n\n            return lines.map(line => {\n                const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n                const [, lineOffset, lineContents] = match;\n\n                if (lineOffset.length > leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n                }\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n                }\n\n                return lineContents;\n            });\n        }\n\n        /**\n         * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n         * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n         * @returns {string[]} A list of comment lines.\n         */\n        function getCommentLines(commentGroup) {\n            const [firstComment] = commentGroup;\n\n            if (firstComment.type === \"Line\") {\n                return processSeparateLineComments(commentGroup);\n            }\n\n            if (isStarredBlockComment(commentGroup)) {\n                return processStarredBlockComment(firstComment);\n            }\n\n            return processBareBlockComment(firstComment);\n        }\n\n        /**\n         * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n         * @param {Token} comment The token to check.\n         * @returns {string} The offset from the beginning of a line to the token.\n         */\n        function getInitialOffset(comment) {\n            return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n        }\n\n        /**\n         * Converts a comment into starred-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n         */\n        function convertToStarredBlock(firstComment, commentLinesList) {\n            const initialOffset = getInitialOffset(firstComment);\n\n            return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n        }\n\n        /**\n         * Converts a comment into separate-line form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in separate-line form\n         */\n        function convertToSeparateLines(firstComment, commentLinesList) {\n            return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n        }\n\n        /**\n         * Converts a comment into bare-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in bare-block form\n         */\n        function convertToBlock(firstComment, commentLinesList) {\n            return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n        }\n\n        /**\n         * Each method checks a group of comments to see if it's valid according to the given option.\n         * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n         * block comment or multiple line comments.\n         * @returns {void}\n         */\n        const commentGroupCheckers = {\n            \"starred-block\"(commentGroup) {\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                if (commentLines.some(value => value.includes(\"*/\"))) {\n                    return;\n                }\n\n                if (commentGroup.length > 1) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n\n                            return commentLines.some(value => value.startsWith(\"/\"))\n                                ? null\n                                : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n                        }\n                    });\n                } else {\n                    const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n                    const expectedLeadingWhitespace = getInitialOffset(firstComment);\n                    const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n                    if (!/^\\*?\\s*$/u.test(lines[0])) {\n                        const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n\n                        context.report({\n                            loc: {\n                                start: firstComment.loc.start,\n                                end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                            },\n                            messageId: \"startNewline\",\n                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n                        });\n                    }\n\n                    if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n                        context.report({\n                            loc: {\n                                start: { line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2 },\n                                end: firstComment.loc.end\n                            },\n                            messageId: \"endNewline\",\n                            fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n                        });\n                    }\n\n                    for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n                        const lineText = sourceCode.lines[lineNumber - 1];\n                        const errorType = isStarredCommentLine(lineText)\n                            ? \"alignment\"\n                            : \"missingStar\";\n\n                        if (!lineText.startsWith(expectedLinePrefix)) {\n                            context.report({\n                                loc: {\n                                    start: { line: lineNumber, column: 0 },\n                                    end: { line: lineNumber, column: lineText.length }\n                                },\n                                messageId: errorType,\n                                fix(fixer) {\n                                    const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });\n\n                                    if (errorType === \"alignment\") {\n                                        const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                                        const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n\n                                        return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                                    }\n\n                                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                                    let offset;\n\n                                    for (const [idx, line] of lines.entries()) {\n                                        if (!/\\S+/u.test(line)) {\n                                            continue;\n                                        }\n\n                                        const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                                        const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n\n                                        offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n                                        break;\n                                    }\n\n                                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n            \"separate-lines\"(commentGroup) {\n                const [firstComment] = commentGroup;\n\n                if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const commentLines = getCommentLines(commentGroup);\n                const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });\n\n                if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n                    return;\n                }\n\n                context.report({\n                    loc: {\n                        start: firstComment.loc.start,\n                        end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                    },\n                    messageId: \"expectedLines\",\n                    fix(fixer) {\n                        return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n                    }\n                });\n            },\n            \"bare-block\"(commentGroup) {\n                if (isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                // Disallows consecutive line comments in favor of using a block comment.\n                if (firstComment.type === \"Line\" && commentLines.length > 1 &&\n                    !commentLines.some(value => value.includes(\"*/\"))) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]],\n                                convertToBlock(firstComment, commentLines)\n                            );\n                        }\n                    });\n                }\n\n                // Prohibits block comments from having a * at the beginning of each line.\n                if (isStarredBlockComment(commentGroup)) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                        },\n                        messageId: \"expectedBareBlock\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n                        }\n                    });\n                }\n            }\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                return sourceCode.getAllComments()\n                    .filter(comment => comment.type !== \"Shebang\")\n                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))\n                    .filter(comment => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n                    })\n                    .reduce((commentGroups, comment, index, commentList) => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        if (\n                            comment.type === \"Line\" &&\n                            index && commentList[index - 1].type === \"Line\" &&\n                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&\n                            tokenBefore === commentList[index - 1]\n                        ) {\n                            commentGroups[commentGroups.length - 1].push(comment);\n                        } else {\n                            commentGroups.push([comment]);\n                        }\n\n                        return commentGroups;\n                    }, [])\n                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))\n                    .forEach(commentGroupCheckers[option]);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}