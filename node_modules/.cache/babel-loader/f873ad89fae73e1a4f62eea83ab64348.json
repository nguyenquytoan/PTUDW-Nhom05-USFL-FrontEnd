{"ast":null,"code":"/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst SELECTOR = `:matches(${[\"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"ExportAllDeclaration\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\", \"ThrowStatement\", \"VariableDeclaration\"].join(\",\")})`;\n/**\n * Get the child node list of a given node.\n * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\n\nfunction getChildren(node) {\n  const t = node.type;\n\n  if (t === \"BlockStatement\" || t === \"Program\") {\n    return node.body;\n  }\n\n  if (t === \"SwitchCase\") {\n    return node.consequent;\n  }\n\n  return null;\n}\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\n\n\nfunction isLastChild(node) {\n  const t = node.parent.type;\n\n  if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) {\n    // before `else` keyword.\n    return true;\n  }\n\n  if (t === \"DoWhileStatement\") {\n    // before `while` keyword.\n    return true;\n  }\n\n  const nodeList = getChildren(node.parent);\n  return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce location of semicolons\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-style\"\n    },\n    schema: [{\n      enum: [\"last\", \"first\"]\n    }],\n    fixable: \"whitespace\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"last\";\n    /**\n     * Check the given semicolon token.\n     * @param {Token} semiToken The semicolon token to check.\n     * @param {\"first\"|\"last\"} expected The expected location to check.\n     * @returns {void}\n     */\n\n    function check(semiToken, expected) {\n      const prevToken = sourceCode.getTokenBefore(semiToken);\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n      if (expected === \"last\" && !prevIsSameLine || expected === \"first\" && !nextIsSameLine) {\n        context.report({\n          loc: semiToken.loc,\n          message: \"Expected this semicolon to be at {{pos}}.\",\n          data: {\n            pos: expected === \"last\" ? \"the end of the previous line\" : \"the beginning of the next line\"\n          },\n\n          fix(fixer) {\n            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n              return null;\n            }\n\n            const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n            const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n            const text = expected === \"last\" ? \";\\n\" : \"\\n;\";\n            return fixer.replaceTextRange([start, end], text);\n          }\n\n        });\n      }\n    }\n\n    return {\n      [SELECTOR](node) {\n        if (option === \"first\" && isLastChild(node)) {\n          return;\n        }\n\n        const lastToken = sourceCode.getLastToken(node);\n\n        if (astUtils.isSemicolonToken(lastToken)) {\n          check(lastToken, option);\n        }\n      },\n\n      ForStatement(node) {\n        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n        if (firstSemi) {\n          check(firstSemi, \"last\");\n        }\n\n        if (secondSemi) {\n          check(secondSemi, \"last\");\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/semi-style.js"],"names":["astUtils","require","SELECTOR","join","getChildren","node","t","type","body","consequent","isLastChild","parent","alternate","nodeList","length","module","exports","meta","docs","description","category","recommended","url","schema","enum","fixable","create","context","sourceCode","getSourceCode","option","options","check","semiToken","expected","prevToken","getTokenBefore","nextToken","getTokenAfter","prevIsSameLine","isTokenOnSameLine","nextIsSameLine","report","loc","message","data","pos","fix","fixer","commentsExistBetween","start","range","end","text","replaceTextRange","lastToken","getLastToken","isSemicolonToken","ForStatement","firstSemi","init","secondSemi","test"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = `:matches(${\n    [\n        \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\n        \"DoWhileStatement\", \"ExportAllDeclaration\",\n        \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\n        \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\n        \"ThrowStatement\", \"VariableDeclaration\"\n    ].join(\",\")\n})`;\n\n/**\n * Get the child node list of a given node.\n * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\nfunction getChildren(node) {\n    const t = node.type;\n\n    if (t === \"BlockStatement\" || t === \"Program\") {\n        return node.body;\n    }\n    if (t === \"SwitchCase\") {\n        return node.consequent;\n    }\n    return null;\n}\n\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\nfunction isLastChild(node) {\n    const t = node.parent.type;\n\n    if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) { // before `else` keyword.\n        return true;\n    }\n    if (t === \"DoWhileStatement\") { // before `while` keyword.\n        return true;\n    }\n    const nodeList = getChildren(node.parent);\n\n    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce location of semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-style\"\n        },\n\n        schema: [{ enum: [\"last\", \"first\"] }],\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"last\";\n\n        /**\n         * Check the given semicolon token.\n         * @param {Token} semiToken The semicolon token to check.\n         * @param {\"first\"|\"last\"} expected The expected location to check.\n         * @returns {void}\n         */\n        function check(semiToken, expected) {\n            const prevToken = sourceCode.getTokenBefore(semiToken);\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\n                context.report({\n                    loc: semiToken.loc,\n                    message: \"Expected this semicolon to be at {{pos}}.\",\n                    data: {\n                        pos: (expected === \"last\")\n                            ? \"the end of the previous line\"\n                            : \"the beginning of the next line\"\n                    },\n                    fix(fixer) {\n                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n                            return null;\n                        }\n\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\n\n                        return fixer.replaceTextRange([start, end], text);\n                    }\n                });\n            }\n        }\n\n        return {\n            [SELECTOR](node) {\n                if (option === \"first\" && isLastChild(node)) {\n                    return;\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    check(lastToken, option);\n                }\n            },\n\n            ForStatement(node) {\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n                if (firstSemi) {\n                    check(firstSemi, \"last\");\n                }\n                if (secondSemi) {\n                    check(secondSemi, \"last\");\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}