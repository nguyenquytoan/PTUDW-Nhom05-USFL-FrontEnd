{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _dotProp = require('dot-prop');\n\nvar _dotProp2 = _interopRequireDefault(_dotProp);\n\nvar _indexesOf = require('indexes-of');\n\nvar _indexesOf2 = _interopRequireDefault(_indexesOf);\n\nvar _uniq = require('uniq');\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nvar _root = require('./selectors/root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _selector = require('./selectors/selector');\n\nvar _selector2 = _interopRequireDefault(_selector);\n\nvar _className = require('./selectors/className');\n\nvar _className2 = _interopRequireDefault(_className);\n\nvar _comment = require('./selectors/comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _id = require('./selectors/id');\n\nvar _id2 = _interopRequireDefault(_id);\n\nvar _tag = require('./selectors/tag');\n\nvar _tag2 = _interopRequireDefault(_tag);\n\nvar _string = require('./selectors/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _pseudo = require('./selectors/pseudo');\n\nvar _pseudo2 = _interopRequireDefault(_pseudo);\n\nvar _attribute = require('./selectors/attribute');\n\nvar _attribute2 = _interopRequireDefault(_attribute);\n\nvar _universal = require('./selectors/universal');\n\nvar _universal2 = _interopRequireDefault(_universal);\n\nvar _combinator = require('./selectors/combinator');\n\nvar _combinator2 = _interopRequireDefault(_combinator);\n\nvar _nesting = require('./selectors/nesting');\n\nvar _nesting2 = _interopRequireDefault(_nesting);\n\nvar _sortAscending = require('./sortAscending');\n\nvar _sortAscending2 = _interopRequireDefault(_sortAscending);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar tokens = _interopRequireWildcard(_tokenTypes);\n\nvar _types = require('./selectors/types');\n\nvar types = _interopRequireWildcard(_types);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nvar Parser = function () {\n  function Parser(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Parser);\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.root = new _root2.default();\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector2.default();\n    this.root.append(selector);\n    this.current = selector;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\n    if (this.options.lossy) {\n      this.css = this.css.trim();\n    }\n\n    this.tokens = (0, _tokenize2.default)({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    this.loop();\n  }\n\n  Parser.prototype._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  Parser.prototype.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[0] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[0] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[5]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[5]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][0])) {\n      return this.expected('attribute', attr[0][5]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[0]) {\n        case tokens.space:\n          if (len === 1 || pos === 0 && this.content(next) === '|') {\n            return this.expected('attribute', token[5], content);\n          }\n\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            var spaceProp = 'spaces.' + lastAdded + '.after';\n\n            _dotProp2.default.set(node, spaceProp, _dotProp2.default.get(node, spaceProp, '') + content);\n\n            var commentProp = 'raws.spaces.' + lastAdded + '.after';\n\n            var existingComment = _dotProp2.default.get(node, commentProp);\n\n            if (existingComment) {\n              _dotProp2.default.set(node, commentProp, existingComment + content);\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[0] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);\n\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              _dotProp2.default.set(node, 'raws.spaces.attribute.before', spaceBefore);\n\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n\n            var rawValue = _dotProp2.default.get(node, \"raws.namespace\");\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n        case tokens.caret:\n          if (next[0] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[0] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[0] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][0] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);\n\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              _dotProp2.default.set(node, 'raws.spaces.attribute.before', commentBefore);\n\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = _dotProp2.default.get(node, \"raws.attribute\");\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            node.value = (node.value || \"\") + content;\n\n            var _rawValue2 = _dotProp2.default.get(node, \"raws.value\");\n\n            if (_rawValue2) {\n              node.raws.value += content;\n            }\n\n            lastAdded = 'value';\n\n            _dotProp2.default.set(node, 'raws.unquoted', _dotProp2.default.get(node, 'raws.unquoted', '') + content);\n          } else if (content === 'i') {\n            if (node.value && (node.quoted || spaceAfterMeaningfulToken)) {\n              node.insensitive = true;\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                _dotProp2.default.set(node, 'spaces.insensitive.before', spaceBefore);\n\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                _dotProp2.default.set(node, 'raws.spaces.insensitive.before', commentBefore);\n\n                commentBefore = '';\n              }\n            } else if (node.value) {\n              lastAdded = 'value';\n              node.value += 'i';\n\n              if (node.raws.value) {\n                node.raws.value += 'i';\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error('Expected an attribute followed by an operator preceding the string.', {\n              index: token[5]\n            });\n          }\n\n          node.value = content;\n          node.quoted = true;\n          lastAdded = 'value';\n\n          _dotProp2.default.set(node, 'raws.unquoted', content.slice(1, -1));\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[5], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[5]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[0] === tokens.space) {\n              var lastComment = _dotProp2.default.get(node, 'raws.spaces.' + lastAdded + '.after', _dotProp2.default.get(node, 'spaces.' + lastAdded + '.after', ''));\n\n              _dotProp2.default.set(node, 'raws.spaces.' + lastAdded + '.after', lastComment + content);\n            } else {\n              var lastValue = _dotProp2.default.get(node, 'raws.' + lastAdded, _dotProp2.default.get(node, lastAdded, ''));\n\n              _dotProp2.default.set(node, 'raws.' + lastAdded, lastValue + content);\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error('Unexpected \"' + content + '\" found.', {\n            index: token[5]\n          });\n      }\n\n      pos++;\n    }\n\n    this.newNode(new _attribute2.default(node));\n    this.position++;\n  };\n\n  Parser.prototype.combinator = function combinator() {\n    var current = this.currToken;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    }\n\n    var node = new _combinator2.default({\n      value: '',\n      source: getSource(current[1], current[2], current[3], current[4]),\n      sourceIndex: current[5]\n    });\n\n    while (this.position < this.tokens.length && this.currToken && (this.currToken[0] === tokens.space || this.currToken[0] === tokens.combinator)) {\n      var content = this.content();\n\n      if (this.nextToken && this.nextToken[0] === tokens.combinator) {\n        node.spaces.before = this.parseSpace(content);\n        node.source = getSource(this.nextToken[1], this.nextToken[2], this.nextToken[3], this.nextToken[4]);\n        node.sourceIndex = this.nextToken[5];\n      } else if (this.prevToken && this.prevToken[0] === tokens.combinator) {\n        node.spaces.after = this.parseSpace(content);\n      } else if (this.currToken[0] === tokens.combinator) {\n        node.value = content;\n      } else if (this.currToken[0] === tokens.space) {\n        node.value = this.parseSpace(content, ' ');\n      }\n\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  Parser.prototype.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    var selector = new _selector2.default();\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  Parser.prototype.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment2.default({\n      value: this.content(),\n      source: getSource(current[1], current[2], current[3], current[4]),\n      sourceIndex: current[5]\n    }));\n    this.position++;\n  };\n\n  Parser.prototype.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  Parser.prototype.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[5]\n    });\n  };\n\n  Parser.prototype.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[5]);\n  };\n\n  Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[5]);\n  };\n\n  Parser.prototype.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[0] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[0] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  Parser.prototype.nesting = function nesting() {\n    var current = this.currToken;\n    this.newNode(new _nesting2.default({\n      value: this.content(),\n      source: getSource(current[1], current[2], current[3], current[4]),\n      sourceIndex: current[5]\n    }));\n    this.position++;\n  };\n\n  Parser.prototype.parentheses = function parentheses() {\n    var last = this.current.last;\n    var balanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector2.default();\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && balanced) {\n        if (this.currToken[0] === tokens.openParenthesis) {\n          balanced++;\n        }\n\n        if (this.currToken[0] === tokens.closeParenthesis) {\n          balanced--;\n        }\n\n        if (balanced) {\n          this.parse();\n        } else {\n          selector.parent.source.end.line = this.currToken[3];\n          selector.parent.source.end.column = this.currToken[4];\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      last.value += '(';\n\n      while (this.position < this.tokens.length && balanced) {\n        if (this.currToken[0] === tokens.openParenthesis) {\n          balanced++;\n        }\n\n        if (this.currToken[0] === tokens.closeParenthesis) {\n          balanced--;\n        }\n\n        last.value += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n    }\n\n    if (balanced) {\n      return this.expected('closing parenthesis', this.currToken[5]);\n    }\n  };\n\n  Parser.prototype.pseudo = function pseudo() {\n    var _this2 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[0] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[0] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this2.newNode(new _pseudo2.default({\n          value: pseudoStr,\n          source: getSource(startingToken[1], startingToken[2], _this2.currToken[3], _this2.currToken[4]),\n          sourceIndex: startingToken[5]\n        }));\n\n        if (length > 1 && _this2.nextToken && _this2.nextToken[0] === tokens.openParenthesis) {\n          _this2.error('Misplaced parenthesis.', {\n            index: _this2.nextToken[5]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[5]);\n    }\n  };\n\n  Parser.prototype.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[0] === tokens.comma || this.prevToken[0] === tokens.openParenthesis) {\n      this.spaces = this.parseSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[0] === tokens.comma || this.nextToken[0] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.parseSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  Parser.prototype.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string2.default({\n      value: this.content(),\n      source: getSource(current[1], current[2], current[3], current[4]),\n      sourceIndex: current[5]\n    }));\n    this.position++;\n  };\n\n  Parser.prototype.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal2.default({\n      value: this.content(),\n      source: getSource(current[1], current[2], current[3], current[4]),\n      sourceIndex: current[5]\n    }), namespace);\n    this.position++;\n  };\n\n  Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n    var _this3 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[0])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[0] === tokens.space) {\n          word += this.parseSpace(this.content(next), ' ');\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = (0, _indexesOf2.default)(word, '.');\n    var hasId = (0, _indexesOf2.default)(word, '#'); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = (0, _indexesOf2.default)(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this3, value, indices.length);\n      }\n\n      var node = void 0;\n      var current = _this3.currToken;\n      var sourceIndex = current[5] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        node = new _className2.default({\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        });\n      } else if (~hasId.indexOf(ind)) {\n        node = new _id2.default({\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        });\n      } else {\n        node = new _tag2.default({\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        });\n      }\n\n      _this3.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  Parser.prototype.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  Parser.prototype.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    return this.root;\n  };\n\n  Parser.prototype.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[0]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n    }\n  };\n  /**\n   * Helpers\n   */\n\n\n  Parser.prototype.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + ' or ' + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error('Expected ' + an + ' ' + description + '.', {\n        index: index\n      });\n    }\n\n    return this.error('Expected ' + an + ' ' + description + ', found \"' + found + '\" instead.', {\n      index: index\n    });\n  };\n\n  Parser.prototype.parseNamespace = function parseNamespace(namespace) {\n    if (this.options.lossy && typeof namespace === 'string') {\n      var trimmed = namespace.trim();\n\n      if (!trimmed.length) {\n        return true;\n      }\n\n      return trimmed;\n    }\n\n    return namespace;\n  };\n\n  Parser.prototype.parseSpace = function parseSpace(space) {\n    var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return this.options.lossy ? replacement : space;\n  };\n\n  Parser.prototype.parseValue = function parseValue(value) {\n    if (!this.options.lossy || !value || typeof value !== 'string') {\n      return value;\n    }\n\n    return value.trim();\n  };\n\n  Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (!this.options.lossy) {\n      return content;\n    }\n\n    if (token[0] === tokens.space) {\n      return this.parseSpace(content, ' ');\n    }\n\n    return this.parseValue(content);\n  };\n\n  Parser.prototype.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      node.namespace = this.parseNamespace(namespace);\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  Parser.prototype.content = function content() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;\n    return this.css.slice(token[5], token[6]);\n  };\n\n  _createClass(Parser, [{\n    key: 'currToken',\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: 'nextToken',\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: 'prevToken',\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-minify-selectors/node_modules/postcss-selector-parser/dist/parser.js"],"names":["exports","__esModule","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_dotProp","require","_dotProp2","_interopRequireDefault","_indexesOf","_indexesOf2","_uniq","_uniq2","_root","_root2","_selector","_selector2","_className","_className2","_comment","_comment2","_id","_id2","_tag","_tag2","_string","_string2","_pseudo","_pseudo2","_attribute","_attribute2","_universal","_universal2","_combinator","_combinator2","_nesting","_nesting2","_sortAscending","_sortAscending2","_tokenize","_tokenize2","_tokenTypes","tokens","_interopRequireWildcard","_types","types","obj","newObj","hasOwnProperty","call","default","_classCallCheck","instance","TypeError","getSource","startLine","startColumn","endLine","endColumn","start","line","column","end","Parser","rule","options","arguments","undefined","assign","lossy","safe","position","root","errorGenerator","_errorGenerator","selector","append","current","css","trim","error","loop","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","closeSquare","push","expected","len","node","source","sourceIndex","word","indexOf","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","token","content","next","space","spaceProp","set","get","commentProp","existingComment","asterisk","equals","operator","namespace","rawValue","raws","dollar","caret","combinator","_rawValue","value","_rawValue2","quoted","insensitive","str","index","slice","comment","lastComment","lastValue","newNode","nextToken","spaces","before","parseSpace","prevToken","after","comma","trailingComma","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","universal","nesting","parentheses","last","balanced","type","PSEUDO","cache","openParenthesis","closeParenthesis","parse","parseParenthesisToken","pseudo","_this2","pseudoStr","colon","splitWord","first","string","firstCallback","_this3","lastIndexOf","hasClass","hasId","interpolations","filter","hashIndex","indices","concat","forEach","ind","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","Array","isArray","pop","join","an","test","parseNamespace","trimmed","replacement","parseValue","module"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _dotProp = require('dot-prop');\n\nvar _dotProp2 = _interopRequireDefault(_dotProp);\n\nvar _indexesOf = require('indexes-of');\n\nvar _indexesOf2 = _interopRequireDefault(_indexesOf);\n\nvar _uniq = require('uniq');\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nvar _root = require('./selectors/root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _selector = require('./selectors/selector');\n\nvar _selector2 = _interopRequireDefault(_selector);\n\nvar _className = require('./selectors/className');\n\nvar _className2 = _interopRequireDefault(_className);\n\nvar _comment = require('./selectors/comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _id = require('./selectors/id');\n\nvar _id2 = _interopRequireDefault(_id);\n\nvar _tag = require('./selectors/tag');\n\nvar _tag2 = _interopRequireDefault(_tag);\n\nvar _string = require('./selectors/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _pseudo = require('./selectors/pseudo');\n\nvar _pseudo2 = _interopRequireDefault(_pseudo);\n\nvar _attribute = require('./selectors/attribute');\n\nvar _attribute2 = _interopRequireDefault(_attribute);\n\nvar _universal = require('./selectors/universal');\n\nvar _universal2 = _interopRequireDefault(_universal);\n\nvar _combinator = require('./selectors/combinator');\n\nvar _combinator2 = _interopRequireDefault(_combinator);\n\nvar _nesting = require('./selectors/nesting');\n\nvar _nesting2 = _interopRequireDefault(_nesting);\n\nvar _sortAscending = require('./sortAscending');\n\nvar _sortAscending2 = _interopRequireDefault(_sortAscending);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar tokens = _interopRequireWildcard(_tokenTypes);\n\nvar _types = require('./selectors/types');\n\nvar types = _interopRequireWildcard(_types);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n    return {\n        start: {\n            line: startLine,\n            column: startColumn\n        },\n        end: {\n            line: endLine,\n            column: endColumn\n        }\n    };\n}\n\nvar Parser = function () {\n    function Parser(rule) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Parser);\n\n        this.rule = rule;\n        this.options = Object.assign({ lossy: false, safe: false }, options);\n        this.position = 0;\n        this.root = new _root2.default();\n        this.root.errorGenerator = this._errorGenerator();\n\n        var selector = new _selector2.default();\n        this.root.append(selector);\n        this.current = selector;\n\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\n        if (this.options.lossy) {\n            this.css = this.css.trim();\n        }\n        this.tokens = (0, _tokenize2.default)({\n            css: this.css,\n            error: this._errorGenerator(),\n            safe: this.options.safe\n        });\n\n        this.loop();\n    }\n\n    Parser.prototype._errorGenerator = function _errorGenerator() {\n        var _this = this;\n\n        return function (message, errorOptions) {\n            if (typeof _this.rule === 'string') {\n                return new Error(message);\n            }\n            return _this.rule.error(message, errorOptions);\n        };\n    };\n\n    Parser.prototype.attribute = function attribute() {\n        var attr = [];\n        var startingToken = this.currToken;\n        this.position++;\n        while (this.position < this.tokens.length && this.currToken[0] !== tokens.closeSquare) {\n            attr.push(this.currToken);\n            this.position++;\n        }\n        if (this.currToken[0] !== tokens.closeSquare) {\n            return this.expected('closing square bracket', this.currToken[5]);\n        }\n\n        var len = attr.length;\n        var node = {\n            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n            sourceIndex: startingToken[5]\n        };\n\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][0])) {\n            return this.expected('attribute', attr[0][5]);\n        }\n\n        var pos = 0;\n        var spaceBefore = '';\n        var commentBefore = '';\n        var lastAdded = null;\n        var spaceAfterMeaningfulToken = false;\n\n        while (pos < len) {\n            var token = attr[pos];\n            var content = this.content(token);\n            var next = attr[pos + 1];\n\n            switch (token[0]) {\n                case tokens.space:\n                    if (len === 1 || pos === 0 && this.content(next) === '|') {\n                        return this.expected('attribute', token[5], content);\n                    }\n                    spaceAfterMeaningfulToken = true;\n                    if (this.options.lossy) {\n                        break;\n                    }\n                    if (lastAdded) {\n                        var spaceProp = 'spaces.' + lastAdded + '.after';\n                        _dotProp2.default.set(node, spaceProp, _dotProp2.default.get(node, spaceProp, '') + content);\n                        var commentProp = 'raws.spaces.' + lastAdded + '.after';\n                        var existingComment = _dotProp2.default.get(node, commentProp);\n                        if (existingComment) {\n                            _dotProp2.default.set(node, commentProp, existingComment + content);\n                        }\n                    } else {\n                        spaceBefore = spaceBefore + content;\n                        commentBefore = commentBefore + content;\n                    }\n                    break;\n                case tokens.asterisk:\n                    if (next[0] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n                        if (spaceBefore) {\n                            _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            _dotProp2.default.set(node, 'raws.spaces.attribute.before', spaceBefore);\n                            commentBefore = '';\n                        }\n                        node.namespace = (node.namespace || \"\") + content;\n                        var rawValue = _dotProp2.default.get(node, \"raws.namespace\");\n                        if (rawValue) {\n                            node.raws.namespace += content;\n                        }\n                        lastAdded = 'namespace';\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.dollar:\n                case tokens.caret:\n                    if (next[0] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.combinator:\n                    if (content === '~' && next[0] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    }\n                    if (content !== '|') {\n                        spaceAfterMeaningfulToken = false;\n                        break;\n                    }\n                    if (next[0] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    } else if (!node.namespace && !node.attribute) {\n                        node.namespace = true;\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.word:\n                    if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][0] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n                    !node.operator && !node.namespace) {\n                        node.namespace = content;\n                        lastAdded = 'namespace';\n                    } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n                        if (spaceBefore) {\n                            _dotProp2.default.set(node, 'spaces.attribute.before', spaceBefore);\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            _dotProp2.default.set(node, 'raws.spaces.attribute.before', commentBefore);\n                            commentBefore = '';\n                        }\n                        node.attribute = (node.attribute || \"\") + content;\n                        var _rawValue = _dotProp2.default.get(node, \"raws.attribute\");\n                        if (_rawValue) {\n                            node.raws.attribute += content;\n                        }\n                        lastAdded = 'attribute';\n                    } else if (!node.value || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n                        node.value = (node.value || \"\") + content;\n                        var _rawValue2 = _dotProp2.default.get(node, \"raws.value\");\n                        if (_rawValue2) {\n                            node.raws.value += content;\n                        }\n                        lastAdded = 'value';\n                        _dotProp2.default.set(node, 'raws.unquoted', _dotProp2.default.get(node, 'raws.unquoted', '') + content);\n                    } else if (content === 'i') {\n                        if (node.value && (node.quoted || spaceAfterMeaningfulToken)) {\n                            node.insensitive = true;\n                            lastAdded = 'insensitive';\n                            if (spaceBefore) {\n                                _dotProp2.default.set(node, 'spaces.insensitive.before', spaceBefore);\n                                spaceBefore = '';\n                            }\n                            if (commentBefore) {\n                                _dotProp2.default.set(node, 'raws.spaces.insensitive.before', commentBefore);\n                                commentBefore = '';\n                            }\n                        } else if (node.value) {\n                            lastAdded = 'value';\n                            node.value += 'i';\n                            if (node.raws.value) {\n                                node.raws.value += 'i';\n                            }\n                        }\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.str:\n                    if (!node.attribute || !node.operator) {\n                        return this.error('Expected an attribute followed by an operator preceding the string.', {\n                            index: token[5]\n                        });\n                    }\n                    node.value = content;\n                    node.quoted = true;\n                    lastAdded = 'value';\n                    _dotProp2.default.set(node, 'raws.unquoted', content.slice(1, -1));\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.equals:\n                    if (!node.attribute) {\n                        return this.expected('attribute', token[5], content);\n                    }\n                    if (node.value) {\n                        return this.error('Unexpected \"=\" found; an operator was already defined.', { index: token[5] });\n                    }\n                    node.operator = node.operator ? node.operator + content : content;\n                    lastAdded = 'operator';\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.comment:\n                    if (lastAdded) {\n                        if (spaceAfterMeaningfulToken || next && next[0] === tokens.space) {\n                            var lastComment = _dotProp2.default.get(node, 'raws.spaces.' + lastAdded + '.after', _dotProp2.default.get(node, 'spaces.' + lastAdded + '.after', ''));\n                            _dotProp2.default.set(node, 'raws.spaces.' + lastAdded + '.after', lastComment + content);\n                        } else {\n                            var lastValue = _dotProp2.default.get(node, 'raws.' + lastAdded, _dotProp2.default.get(node, lastAdded, ''));\n                            _dotProp2.default.set(node, 'raws.' + lastAdded, lastValue + content);\n                        }\n                    } else {\n                        commentBefore = commentBefore + content;\n                    }\n                    break;\n                default:\n                    return this.error('Unexpected \"' + content + '\" found.', { index: token[5] });\n            }\n            pos++;\n        }\n\n        this.newNode(new _attribute2.default(node));\n        this.position++;\n    };\n\n    Parser.prototype.combinator = function combinator() {\n        var current = this.currToken;\n        if (this.content() === '|') {\n            return this.namespace();\n        }\n        var node = new _combinator2.default({\n            value: '',\n            source: getSource(current[1], current[2], current[3], current[4]),\n            sourceIndex: current[5]\n        });\n        while (this.position < this.tokens.length && this.currToken && (this.currToken[0] === tokens.space || this.currToken[0] === tokens.combinator)) {\n            var content = this.content();\n            if (this.nextToken && this.nextToken[0] === tokens.combinator) {\n                node.spaces.before = this.parseSpace(content);\n                node.source = getSource(this.nextToken[1], this.nextToken[2], this.nextToken[3], this.nextToken[4]);\n                node.sourceIndex = this.nextToken[5];\n            } else if (this.prevToken && this.prevToken[0] === tokens.combinator) {\n                node.spaces.after = this.parseSpace(content);\n            } else if (this.currToken[0] === tokens.combinator) {\n                node.value = content;\n            } else if (this.currToken[0] === tokens.space) {\n                node.value = this.parseSpace(content, ' ');\n            }\n            this.position++;\n        }\n        return this.newNode(node);\n    };\n\n    Parser.prototype.comma = function comma() {\n        if (this.position === this.tokens.length - 1) {\n            this.root.trailingComma = true;\n            this.position++;\n            return;\n        }\n        var selector = new _selector2.default();\n        this.current.parent.append(selector);\n        this.current = selector;\n        this.position++;\n    };\n\n    Parser.prototype.comment = function comment() {\n        var current = this.currToken;\n        this.newNode(new _comment2.default({\n            value: this.content(),\n            source: getSource(current[1], current[2], current[3], current[4]),\n            sourceIndex: current[5]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.error = function error(message, opts) {\n        throw this.root.error(message, opts);\n    };\n\n    Parser.prototype.missingBackslash = function missingBackslash() {\n        return this.error('Expected a backslash preceding the semicolon.', {\n            index: this.currToken[5]\n        });\n    };\n\n    Parser.prototype.missingParenthesis = function missingParenthesis() {\n        return this.expected('opening parenthesis', this.currToken[5]);\n    };\n\n    Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n        return this.expected('opening square bracket', this.currToken[5]);\n    };\n\n    Parser.prototype.namespace = function namespace() {\n        var before = this.prevToken && this.content(this.prevToken) || true;\n        if (this.nextToken[0] === tokens.word) {\n            this.position++;\n            return this.word(before);\n        } else if (this.nextToken[0] === tokens.asterisk) {\n            this.position++;\n            return this.universal(before);\n        }\n    };\n\n    Parser.prototype.nesting = function nesting() {\n        var current = this.currToken;\n        this.newNode(new _nesting2.default({\n            value: this.content(),\n            source: getSource(current[1], current[2], current[3], current[4]),\n            sourceIndex: current[5]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.parentheses = function parentheses() {\n        var last = this.current.last;\n        var balanced = 1;\n        this.position++;\n        if (last && last.type === types.PSEUDO) {\n            var selector = new _selector2.default();\n            var cache = this.current;\n            last.append(selector);\n            this.current = selector;\n            while (this.position < this.tokens.length && balanced) {\n                if (this.currToken[0] === tokens.openParenthesis) {\n                    balanced++;\n                }\n                if (this.currToken[0] === tokens.closeParenthesis) {\n                    balanced--;\n                }\n                if (balanced) {\n                    this.parse();\n                } else {\n                    selector.parent.source.end.line = this.currToken[3];\n                    selector.parent.source.end.column = this.currToken[4];\n                    this.position++;\n                }\n            }\n            this.current = cache;\n        } else {\n            last.value += '(';\n            while (this.position < this.tokens.length && balanced) {\n                if (this.currToken[0] === tokens.openParenthesis) {\n                    balanced++;\n                }\n                if (this.currToken[0] === tokens.closeParenthesis) {\n                    balanced--;\n                }\n                last.value += this.parseParenthesisToken(this.currToken);\n                this.position++;\n            }\n        }\n        if (balanced) {\n            return this.expected('closing parenthesis', this.currToken[5]);\n        }\n    };\n\n    Parser.prototype.pseudo = function pseudo() {\n        var _this2 = this;\n\n        var pseudoStr = '';\n        var startingToken = this.currToken;\n        while (this.currToken && this.currToken[0] === tokens.colon) {\n            pseudoStr += this.content();\n            this.position++;\n        }\n        if (!this.currToken) {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n        }\n        if (this.currToken[0] === tokens.word) {\n            this.splitWord(false, function (first, length) {\n                pseudoStr += first;\n                _this2.newNode(new _pseudo2.default({\n                    value: pseudoStr,\n                    source: getSource(startingToken[1], startingToken[2], _this2.currToken[3], _this2.currToken[4]),\n                    sourceIndex: startingToken[5]\n                }));\n                if (length > 1 && _this2.nextToken && _this2.nextToken[0] === tokens.openParenthesis) {\n                    _this2.error('Misplaced parenthesis.', {\n                        index: _this2.nextToken[5]\n                    });\n                }\n            });\n        } else {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[5]);\n        }\n    };\n\n    Parser.prototype.space = function space() {\n        var content = this.content();\n        // Handle space before and after the selector\n        if (this.position === 0 || this.prevToken[0] === tokens.comma || this.prevToken[0] === tokens.openParenthesis) {\n            this.spaces = this.parseSpace(content);\n            this.position++;\n        } else if (this.position === this.tokens.length - 1 || this.nextToken[0] === tokens.comma || this.nextToken[0] === tokens.closeParenthesis) {\n            this.current.last.spaces.after = this.parseSpace(content);\n            this.position++;\n        } else {\n            this.combinator();\n        }\n    };\n\n    Parser.prototype.string = function string() {\n        var current = this.currToken;\n        this.newNode(new _string2.default({\n            value: this.content(),\n            source: getSource(current[1], current[2], current[3], current[4]),\n            sourceIndex: current[5]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.universal = function universal(namespace) {\n        var nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position++;\n            return this.namespace();\n        }\n        var current = this.currToken;\n        this.newNode(new _universal2.default({\n            value: this.content(),\n            source: getSource(current[1], current[2], current[3], current[4]),\n            sourceIndex: current[5]\n        }), namespace);\n        this.position++;\n    };\n\n    Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n        var _this3 = this;\n\n        var nextToken = this.nextToken;\n        var word = this.content();\n        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[0])) {\n            this.position++;\n            var current = this.content();\n            word += current;\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\n                var next = this.nextToken;\n                if (next && next[0] === tokens.space) {\n                    word += this.parseSpace(this.content(next), ' ');\n                    this.position++;\n                }\n            }\n            nextToken = this.nextToken;\n        }\n        var hasClass = (0, _indexesOf2.default)(word, '.');\n        var hasId = (0, _indexesOf2.default)(word, '#');\n        // Eliminate Sass interpolations from the list of id indexes\n        var interpolations = (0, _indexesOf2.default)(word, '#{');\n        if (interpolations.length) {\n            hasId = hasId.filter(function (hashIndex) {\n                return !~interpolations.indexOf(hashIndex);\n            });\n        }\n        var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));\n        indices.forEach(function (ind, i) {\n            var index = indices[i + 1] || word.length;\n            var value = word.slice(ind, index);\n            if (i === 0 && firstCallback) {\n                return firstCallback.call(_this3, value, indices.length);\n            }\n            var node = void 0;\n            var current = _this3.currToken;\n            var sourceIndex = current[5] + indices[i];\n            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n            if (~hasClass.indexOf(ind)) {\n                node = new _className2.default({\n                    value: value.slice(1),\n                    source: source,\n                    sourceIndex: sourceIndex\n                });\n            } else if (~hasId.indexOf(ind)) {\n                node = new _id2.default({\n                    value: value.slice(1),\n                    source: source,\n                    sourceIndex: sourceIndex\n                });\n            } else {\n                node = new _tag2.default({\n                    value: value,\n                    source: source,\n                    sourceIndex: sourceIndex\n                });\n            }\n            _this3.newNode(node, namespace);\n            // Ensure that the namespace is used only once\n            namespace = null;\n        });\n        this.position++;\n    };\n\n    Parser.prototype.word = function word(namespace) {\n        var nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position++;\n            return this.namespace();\n        }\n        return this.splitWord(namespace);\n    };\n\n    Parser.prototype.loop = function loop() {\n        while (this.position < this.tokens.length) {\n            this.parse(true);\n        }\n        return this.root;\n    };\n\n    Parser.prototype.parse = function parse(throwOnParenthesis) {\n        switch (this.currToken[0]) {\n            case tokens.space:\n                this.space();\n                break;\n            case tokens.comment:\n                this.comment();\n                break;\n            case tokens.openParenthesis:\n                this.parentheses();\n                break;\n            case tokens.closeParenthesis:\n                if (throwOnParenthesis) {\n                    this.missingParenthesis();\n                }\n                break;\n            case tokens.openSquare:\n                this.attribute();\n                break;\n            case tokens.dollar:\n            case tokens.caret:\n            case tokens.equals:\n            case tokens.word:\n                this.word();\n                break;\n            case tokens.colon:\n                this.pseudo();\n                break;\n            case tokens.comma:\n                this.comma();\n                break;\n            case tokens.asterisk:\n                this.universal();\n                break;\n            case tokens.ampersand:\n                this.nesting();\n                break;\n            case tokens.combinator:\n                this.combinator();\n                break;\n            case tokens.str:\n                this.string();\n                break;\n            // These cases throw; no break needed.\n            case tokens.closeSquare:\n                this.missingSquareBracket();\n            case tokens.semicolon:\n                this.missingBackslash();\n        }\n    };\n\n    /**\n     * Helpers\n     */\n\n    Parser.prototype.expected = function expected(description, index, found) {\n        if (Array.isArray(description)) {\n            var last = description.pop();\n            description = description.join(', ') + ' or ' + last;\n        }\n        var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n        if (!found) {\n            return this.error('Expected ' + an + ' ' + description + '.', { index: index });\n        }\n        return this.error('Expected ' + an + ' ' + description + ', found \"' + found + '\" instead.', { index: index });\n    };\n\n    Parser.prototype.parseNamespace = function parseNamespace(namespace) {\n        if (this.options.lossy && typeof namespace === 'string') {\n            var trimmed = namespace.trim();\n            if (!trimmed.length) {\n                return true;\n            }\n\n            return trimmed;\n        }\n\n        return namespace;\n    };\n\n    Parser.prototype.parseSpace = function parseSpace(space) {\n        var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n        return this.options.lossy ? replacement : space;\n    };\n\n    Parser.prototype.parseValue = function parseValue(value) {\n        if (!this.options.lossy || !value || typeof value !== 'string') {\n            return value;\n        }\n        return value.trim();\n    };\n\n    Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n        var content = this.content(token);\n        if (!this.options.lossy) {\n            return content;\n        }\n\n        if (token[0] === tokens.space) {\n            return this.parseSpace(content, ' ');\n        }\n\n        return this.parseValue(content);\n    };\n\n    Parser.prototype.newNode = function newNode(node, namespace) {\n        if (namespace) {\n            node.namespace = this.parseNamespace(namespace);\n        }\n        if (this.spaces) {\n            node.spaces.before = this.spaces;\n            this.spaces = '';\n        }\n        return this.current.append(node);\n    };\n\n    Parser.prototype.content = function content() {\n        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;\n\n        return this.css.slice(token[5], token[6]);\n    };\n\n    _createClass(Parser, [{\n        key: 'currToken',\n        get: function get() {\n            return this.tokens[this.position];\n        }\n    }, {\n        key: 'nextToken',\n        get: function get() {\n            return this.tokens[this.position + 1];\n        }\n    }, {\n        key: 'prevToken',\n        get: function get() {\n            return this.tokens[this.position - 1];\n        }\n    }]);\n\n    return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}