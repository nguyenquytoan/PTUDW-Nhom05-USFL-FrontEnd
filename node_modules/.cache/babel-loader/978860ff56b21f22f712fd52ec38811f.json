{"ast":null,"code":"/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce variables to be declared either together or separately in functions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/one-var\"\n    },\n    fixable: \"code\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consecutive\"]\n      }, {\n        type: \"object\",\n        properties: {\n          separateRequires: {\n            type: \"boolean\"\n          },\n          var: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          let: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          const: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          initialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          uninitialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const MODE_ALWAYS = \"always\";\n    const MODE_NEVER = \"never\";\n    const MODE_CONSECUTIVE = \"consecutive\";\n    const mode = context.options[0] || MODE_ALWAYS;\n    const options = {};\n\n    if (typeof mode === \"string\") {\n      // simple options configuration with just a string\n      options.var = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.let = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.const = {\n        uninitialized: mode,\n        initialized: mode\n      };\n    } else if (typeof mode === \"object\") {\n      // options configuration is an object\n      options.separateRequires = !!mode.separateRequires;\n      options.var = {\n        uninitialized: mode.var,\n        initialized: mode.var\n      };\n      options.let = {\n        uninitialized: mode.let,\n        initialized: mode.let\n      };\n      options.const = {\n        uninitialized: mode.const,\n        initialized: mode.const\n      };\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n        options.var.uninitialized = mode.uninitialized;\n        options.let.uninitialized = mode.uninitialized;\n        options.const.uninitialized = mode.uninitialized;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n        options.var.initialized = mode.initialized;\n        options.let.initialized = mode.initialized;\n        options.const.initialized = mode.initialized;\n      }\n    }\n\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const functionStack = [];\n    const blockStack = [];\n    /**\n     * Increments the blockStack counter.\n     * @returns {void}\n     * @private\n     */\n\n    function startBlock() {\n      blockStack.push({\n        let: {\n          initialized: false,\n          uninitialized: false\n        },\n        const: {\n          initialized: false,\n          uninitialized: false\n        }\n      });\n    }\n    /**\n     * Increments the functionStack counter.\n     * @returns {void}\n     * @private\n     */\n\n\n    function startFunction() {\n      functionStack.push({\n        initialized: false,\n        uninitialized: false\n      });\n      startBlock();\n    }\n    /**\n     * Decrements the blockStack counter.\n     * @returns {void}\n     * @private\n     */\n\n\n    function endBlock() {\n      blockStack.pop();\n    }\n    /**\n     * Decrements the functionStack counter.\n     * @returns {void}\n     * @private\n     */\n\n\n    function endFunction() {\n      functionStack.pop();\n      endBlock();\n    }\n    /**\n     * Check if a variable declaration is a require.\n     * @param {ASTNode} decl variable declaration Node\n     * @returns {bool} if decl is a require, return true; else return false.\n     * @private\n     */\n\n\n    function isRequire(decl) {\n      return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n    }\n    /**\n     * Records whether initialized/uninitialized/required variables are defined in current scope.\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @param {ASTNode[]} declarations List of declarations\n     * @param {Object} currentScope The scope being investigated\n     * @returns {void}\n     * @private\n     */\n\n\n    function recordTypes(statementType, declarations, currentScope) {\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n            currentScope.uninitialized = true;\n          }\n        } else {\n          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n            if (options.separateRequires && isRequire(declarations[i])) {\n              currentScope.required = true;\n            } else {\n              currentScope.initialized = true;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Determines the current scope (function or block)\n     * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @returns {Object} The scope associated with statementType\n     */\n\n\n    function getCurrentScope(statementType) {\n      let currentScope;\n\n      if (statementType === \"var\") {\n        currentScope = functionStack[functionStack.length - 1];\n      } else if (statementType === \"let\") {\n        currentScope = blockStack[blockStack.length - 1].let;\n      } else if (statementType === \"const\") {\n        currentScope = blockStack[blockStack.length - 1].const;\n      }\n\n      return currentScope;\n    }\n    /**\n     * Counts the number of initialized and uninitialized declarations in a list of declarations\n     * @param {ASTNode[]} declarations List of declarations\n     * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n     * @private\n     */\n\n\n    function countDeclarations(declarations) {\n      const counts = {\n        uninitialized: 0,\n        initialized: 0\n      };\n\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          counts.uninitialized++;\n        } else {\n          counts.initialized++;\n        }\n      }\n\n      return counts;\n    }\n    /**\n     * Determines if there is more than one var statement in the current scope.\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n     * @param {ASTNode[]} declarations List of declarations\n     * @returns {boolean} Returns true if it is the first var declaration, false if not.\n     * @private\n     */\n\n\n    function hasOnlyOneStatement(statementType, declarations) {\n      const declarationCounts = countDeclarations(declarations);\n      const currentOptions = options[statementType] || {};\n      const currentScope = getCurrentScope(statementType);\n      const hasRequires = declarations.some(isRequire);\n\n      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n        if (currentScope.uninitialized || currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (declarationCounts.uninitialized > 0) {\n        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n          return false;\n        }\n      }\n\n      if (declarationCounts.initialized > 0) {\n        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (currentScope.required && hasRequires) {\n        return false;\n      }\n\n      recordTypes(statementType, declarations, currentScope);\n      return true;\n    }\n    /**\n     * Fixer to join VariableDeclaration's into a single declaration\n     * @param   {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n     * @returns {Function}                         The fixer function\n     */\n\n\n    function joinDeclarations(declarations) {\n      const declaration = declarations[0];\n      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n      const previousNode = body[currentIndex - 1];\n      return fixer => {\n        const type = sourceCode.getTokenBefore(declaration);\n        const prevSemi = sourceCode.getTokenBefore(type);\n        const res = [];\n\n        if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n          if (prevSemi.value === \";\") {\n            res.push(fixer.replaceText(prevSemi, \",\"));\n          } else {\n            res.push(fixer.insertTextAfter(prevSemi, \",\"));\n          }\n\n          res.push(fixer.replaceText(type, \"\"));\n        }\n\n        return res;\n      };\n    }\n    /**\n     * Fixer to split a VariableDeclaration into individual declarations\n     * @param   {VariableDeclaration}   declaration The `VariableDeclaration` to split\n     * @returns {Function}                          The fixer function\n     */\n\n\n    function splitDeclarations(declaration) {\n      return fixer => declaration.declarations.map(declarator => {\n        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n        if (tokenAfterDeclarator === null) {\n          return null;\n        }\n\n        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {\n          includeComments: true\n        });\n\n        if (tokenAfterDeclarator.value !== \",\") {\n          return null;\n        }\n        /*\n         * `var x,y`\n         * tokenAfterDeclarator ^^ afterComma\n         */\n\n\n        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n          return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind} `);\n        }\n        /*\n         * `var x,\n         * tokenAfterDeclarator ^\n         *      y`\n         *      ^ afterComma\n         */\n\n\n        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === \"Line\" || afterComma.type === \"Block\") {\n          let lastComment = afterComma;\n\n          while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n            lastComment = sourceCode.getTokenAfter(lastComment, {\n              includeComments: true\n            });\n          }\n\n          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${declaration.kind} `);\n        }\n\n        return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind}`);\n      }).filter(x => x);\n    }\n    /**\n     * Checks a given VariableDeclaration node for errors.\n     * @param {ASTNode} node The VariableDeclaration node to check\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkVariableDeclaration(node) {\n      const parent = node.parent;\n      const type = node.kind;\n\n      if (!options[type]) {\n        return;\n      }\n\n      const declarations = node.declarations;\n      const declarationCounts = countDeclarations(declarations);\n      const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n      if (options[type].initialized === MODE_ALWAYS) {\n        if (options.separateRequires && mixedRequires) {\n          context.report({\n            node,\n            message: \"Split requires to be separated into a single block.\"\n          });\n        }\n      } // consecutive\n\n\n      const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;\n\n      if (nodeIndex > 0) {\n        const previousNode = parent.body[nodeIndex - 1];\n        const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n        const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n        if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {\n          const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n          if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n            context.report({\n              node,\n              message: \"Combine this with the previous '{{type}}' statement.\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n            context.report({\n              node,\n              message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {\n            context.report({\n              node,\n              message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      } // always\n\n\n      if (!hasOnlyOneStatement(type, declarations)) {\n        if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n          context.report({\n            node,\n            message: \"Combine this with the previous '{{type}}' statement.\",\n            data: {\n              type\n            },\n            fix: joinDeclarations(declarations)\n          });\n        } else {\n          if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n            context.report({\n              node,\n              message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n\n          if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n            if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n              return;\n            }\n\n            context.report({\n              node,\n              message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      } // never\n\n\n      if (parent.type !== \"ForStatement\" || parent.init !== node) {\n        const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n        if (totalDeclarations > 1) {\n          if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n            // both initialized and uninitialized\n            context.report({\n              node,\n              message: \"Split '{{type}}' declarations into multiple statements.\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n            // initialized\n            context.report({\n              node,\n              message: \"Split initialized '{{type}}' declarations into multiple statements.\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n            // uninitialized\n            context.report({\n              node,\n              message: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: startFunction,\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      BlockStatement: startBlock,\n      ForStatement: startBlock,\n      ForInStatement: startBlock,\n      ForOfStatement: startBlock,\n      SwitchStatement: startBlock,\n      VariableDeclaration: checkVariableDeclaration,\n      \"ForStatement:exit\": endBlock,\n      \"ForOfStatement:exit\": endBlock,\n      \"ForInStatement:exit\": endBlock,\n      \"SwitchStatement:exit\": endBlock,\n      \"BlockStatement:exit\": endBlock,\n      \"Program:exit\": endFunction,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/one-var.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","separateRequires","var","let","const","additionalProperties","initialized","uninitialized","create","context","MODE_ALWAYS","MODE_NEVER","MODE_CONSECUTIVE","mode","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","functionStack","blockStack","startBlock","push","startFunction","endBlock","pop","endFunction","isRequire","decl","init","callee","name","recordTypes","statementType","declarations","currentScope","i","length","required","getCurrentScope","countDeclarations","counts","hasOnlyOneStatement","declarationCounts","currentOptions","hasRequires","some","joinDeclarations","declaration","body","Array","isArray","parent","currentIndex","findIndex","node","range","previousNode","fixer","getTokenBefore","prevSemi","res","kind","getText","value","replaceText","insertTextAfter","splitDeclarations","map","declarator","tokenAfterDeclarator","getTokenAfter","afterComma","includeComments","loc","start","line","end","lastComment","replaceTextRange","text","slice","filter","x","checkVariableDeclaration","mixedRequires","every","report","message","nodeIndex","indexOf","isPreviousNodeDeclaration","declarationsWithPrevious","concat","previousDeclCounts","data","fix","left","totalDeclarations","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","VariableDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consecutive\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            separateRequires: {\n                                type: \"boolean\"\n                            },\n                            var: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const MODE_ALWAYS = \"always\";\n        const MODE_NEVER = \"never\";\n        const MODE_CONSECUTIVE = \"consecutive\";\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {};\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            options.separateRequires = !!mode.separateRequires;\n            options.var = { uninitialized: mode.var, initialized: mode.var };\n            options.let = { uninitialized: mode.let, initialized: mode.let };\n            options.const = { uninitialized: mode.const, initialized: mode.const };\n            if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Check if a variable declaration is a require.\n         * @param {ASTNode} decl variable declaration Node\n         * @returns {bool} if decl is a require, return true; else return false.\n         * @private\n         */\n        function isRequire(decl) {\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n        }\n\n        /**\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        if (options.separateRequires && isRequire(declarations[i])) {\n                            currentScope.required = true;\n                        } else {\n                            currentScope.initialized = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n            const hasRequires = declarations.some(isRequire);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n            if (currentScope.required && hasRequires) {\n                return false;\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n        /**\n         * Fixer to join VariableDeclaration's into a single declaration\n         * @param   {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n         * @returns {Function}                         The fixer function\n         */\n        function joinDeclarations(declarations) {\n            const declaration = declarations[0];\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n            const previousNode = body[currentIndex - 1];\n\n            return fixer => {\n                const type = sourceCode.getTokenBefore(declaration);\n                const prevSemi = sourceCode.getTokenBefore(type);\n                const res = [];\n\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n                    if (prevSemi.value === \";\") {\n                        res.push(fixer.replaceText(prevSemi, \",\"));\n                    } else {\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\n                    }\n                    res.push(fixer.replaceText(type, \"\"));\n                }\n\n                return res;\n            };\n        }\n\n        /**\n         * Fixer to split a VariableDeclaration into individual declarations\n         * @param   {VariableDeclaration}   declaration The `VariableDeclaration` to split\n         * @returns {Function}                          The fixer function\n         */\n        function splitDeclarations(declaration) {\n            return fixer => declaration.declarations.map(declarator => {\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n                if (tokenAfterDeclarator === null) {\n                    return null;\n                }\n\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\n\n                if (tokenAfterDeclarator.value !== \",\") {\n                    return null;\n                }\n\n                /*\n                 * `var x,y`\n                 * tokenAfterDeclarator ^^ afterComma\n                 */\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind} `);\n                }\n\n                /*\n                 * `var x,\n                 * tokenAfterDeclarator ^\n                 *      y`\n                 *      ^ afterComma\n                 */\n                if (\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\n                    afterComma.type === \"Line\" ||\n                    afterComma.type === \"Block\"\n                ) {\n                    let lastComment = afterComma;\n\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\n                    }\n\n                    return fixer.replaceTextRange(\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${declaration.kind} `\n                    );\n                }\n\n                return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind}`);\n            }).filter(x => x);\n        }\n\n        /**\n         * Checks a given VariableDeclaration node for errors.\n         * @param {ASTNode} node The VariableDeclaration node to check\n         * @returns {void}\n         * @private\n         */\n        function checkVariableDeclaration(node) {\n            const parent = node.parent;\n            const type = node.kind;\n\n            if (!options[type]) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            const declarationCounts = countDeclarations(declarations);\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n            if (options[type].initialized === MODE_ALWAYS) {\n                if (options.separateRequires && mixedRequires) {\n                    context.report({\n                        node,\n                        message: \"Split requires to be separated into a single block.\"\n                    });\n                }\n            }\n\n            // consecutive\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\n\n            if (nodeIndex > 0) {\n                const previousNode = parent.body[nodeIndex - 1];\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n                if (\n                    isPreviousNodeDeclaration &&\n                    previousNode.kind === type &&\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\n                ) {\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\n                            declarationCounts.uninitialized > 0 &&\n                            previousDeclCounts.uninitialized > 0) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // always\n            if (!hasOnlyOneStatement(type, declarations)) {\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                    context.report({\n                        node,\n                        message: \"Combine this with the previous '{{type}}' statement.\",\n                        data: {\n                            type\n                        },\n                        fix: joinDeclarations(declarations)\n                    });\n                } else {\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                            return;\n                        }\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // never\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                if (totalDeclarations > 1) {\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                        // both initialized and uninitialized\n                        context.report({\n                            node,\n                            message: \"Split '{{type}}' declarations into multiple statements.\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                        // initialized\n                        context.report({\n                            node,\n                            message: \"Split initialized '{{type}}' declarations into multiple statements.\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                        // uninitialized\n                        context.report({\n                            node,\n                            message: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n            VariableDeclaration: checkVariableDeclaration,\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}