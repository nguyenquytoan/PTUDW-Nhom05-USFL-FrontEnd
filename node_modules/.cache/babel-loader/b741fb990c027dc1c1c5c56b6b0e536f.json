{"ast":null,"code":"/*!\n * XRegExp 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nconst REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nconst features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nconst nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nconst fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nlet regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nlet patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nconst tokens = []; // Token scopes\n\nconst defaultScope = 'default';\nconst classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nconst nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nconst replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nconst correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nconst hasFlagsProp = /x/.flags !== undefined; // Shortcut to `Object.prototype.toString`\n\nconst {\n  toString\n} = {};\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  let isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag);\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nconst hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nconst hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nconst registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  regex[REGEX_DATA] = {\n    captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (const p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  const xData = regex[REGEX_DATA] || {};\n  let flags = getNativeFlags(regex);\n  let flagsToAdd = '';\n  let flagsToRemove = '';\n  let xregexpSource = null;\n  let xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(`[${flagsToRemove}]+`, 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if (xData.flags != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\n\n\nfunction dec(hex) {\n  return parseInt(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if ( // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? regex.flags : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\n\n\nfunction hex(dec) {\n  return parseInt(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  const inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  const lineCommentPattern = '#[^#\\\\n]*';\n  const quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call(flags.includes('x') ? // Ignore any leading whitespace, line comments, and inline comments\n  new RegExp(`^(?:\\\\s|${lineCommentPattern}|${inlineCommentPattern})*(?:${quantifierPattern})`) : // Ignore any leading inline comments\n  new RegExp(`^(?:${inlineCommentPattern})*(?:${quantifierPattern})`), pattern.slice(pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === `[object ${type}]`;\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = `0${str}`;\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(`Invalid duplicate regex flag ${flags}`);\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, ($0, $1) => {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(`Cannot use flag g or y in mode modifier ${$0}`);\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  for (const flag of flags) {\n    if (!registeredFlags[flag]) {\n      throw new SyntaxError(`Unknown regex flag ${flag}`);\n    }\n  }\n\n  return {\n    pattern,\n    flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n\nfunction prepareOptions(value) {\n  const options = {};\n\n  if (isType(value, 'String')) {\n    XRegExp.forEach(value, /[^\\s,]+/, match => {\n      options[match] = true;\n    });\n    return options;\n  }\n\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  let i = tokens.length;\n  const leadChar = pattern[pos];\n  let result = null;\n  let match;\n  let t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !flags.includes(t.flag)) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && !flags.includes('A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    const context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    let scope = defaultScope;\n    let output = '';\n    let pos = 0;\n    let result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    const applied = prepareFlags(pattern, flags);\n    let appliedPattern = applied.pattern;\n    const appliedFlags = applied.flags; // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        const [token] = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky');\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  const generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = new RegExp(); // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.3.0'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = (regex, handler, options) => {\n  options = options || {};\n  let {\n    optionalFlags\n  } = options;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n\n    for (const flag of optionalFlags) {\n      registerFlag(flag);\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = (pattern, flags) => {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = cacheName => {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n\nXRegExp.escape = str => nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = (str, regex, pos, sticky) => {\n  let cacheKey = 'g';\n  let addY = false;\n  let fakeY = false;\n  let match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  const r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY,\n    source: fakeY ? `${regex.source}|()` : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n\nXRegExp.forEach = (str, regex, callback) => {\n  let pos = 0;\n  let i = -1;\n  let match;\n\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n\nXRegExp.globalize = regex => copyRegex(regex, {\n  addG: true\n});\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\n\nXRegExp.install = options => {\n  options = prepareOptions(options);\n\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = feature => !!features[feature];\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = value => toString.call(value) === '[object RegExp]'; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n\nXRegExp.match = (str, regex, scope) => {\n  const global = regex.global && scope !== 'one' || scope === 'all';\n  const cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  const r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  const result = nativ.match.call(toObject(str), r2);\n\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n\nXRegExp.matchChain = (str, chain) => function recurseChain(values, level) {\n  const item = chain[level].regex ? chain[level] : {\n    regex: chain[level]\n  };\n  const matches = [];\n\n  function addMatch(match) {\n    if (item.backref) {\n      const ERR_UNDEFINED_GROUP = `Backreference to undefined group: ${item.backref}`;\n      const isNamedBackref = isNaN(item.backref);\n\n      if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n        // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n        if (!(item.backref in match.groups)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n      } else if (!match.hasOwnProperty(item.backref)) {\n        throw new ReferenceError(ERR_UNDEFINED_GROUP);\n      }\n\n      const backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n      matches.push(backrefValue || '');\n    } else {\n      matches.push(match[0]);\n    }\n  }\n\n  for (const value of values) {\n    XRegExp.forEach(value, item.regex, addMatch);\n  }\n\n  return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n}([str], 0);\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = (str, search, replacement, scope) => {\n  const isRegex = XRegExp.isRegExp(search);\n  const global = search.global && scope !== 'one' || scope === 'all';\n  const cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  let s2 = search;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  const result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\n\nXRegExp.replaceEach = (str, replacements) => {\n  for (const r of replacements) {\n    str = XRegExp.replace(str, r[0], r[1], r[2]);\n  }\n\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n\nXRegExp.split = (str, separator, limit) => fixed.split.call(toObject(str), separator, limit);\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\n\nXRegExp.test = (str, regex, pos, sticky) => !!XRegExp.exec(str, regex, pos, sticky);\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\n\nXRegExp.uninstall = options => {\n  options = prepareOptions(options);\n\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\n\nXRegExp.union = (patterns, flags, options) => {\n  options = options || {};\n  const conjunction = options.conjunction || 'or';\n  let numCaptures = 0;\n  let numPriorCaptures;\n  let captureNames;\n\n  function rewrite(match, paren, backref) {\n    const name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return `(?<${name}>`;\n      } // Backreference\n\n    } else if (backref) {\n      // Rewrite the backreference\n      return `\\\\${+backref + numPriorCaptures}`;\n    }\n\n    return match;\n  }\n\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n\n  const parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  const output = [];\n\n  for (const pattern of patterns) {\n    if (XRegExp.isRegExp(pattern)) {\n      numPriorCaptures = numCaptures;\n      captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n      // independently valid; helps keep this simple. Named captures are put back\n\n      output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n    } else {\n      output.push(XRegExp.escape(pattern));\n    }\n  }\n\n  const separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  const origLastIndex = this.lastIndex;\n  const match = nativ.exec.apply(this, arguments);\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && match.includes('')) {\n      const r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call(String(str).slice(match.index), r2, (...args) => {\n        const len = args.length; // Skip index 0 and the last 2\n\n        for (let i = 1; i < len - 2; ++i) {\n          if (args[i] === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    let groupsObject = match;\n\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = Object.create(null);\n      groupsObject = match.groups;\n    }\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (let i = 1; i < match.length; ++i) {\n        const name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\n\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    const result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  const isRegex = XRegExp.isRegExp(search);\n  let origLastIndex;\n  let captureNames;\n  let result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      ({\n        captureNames\n      } = search[REGEX_DATA]);\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, (...args) => {\n      if (captureNames) {\n        let groupsObject;\n\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = Object.create(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          [groupsObject] = args;\n        } // Store named backreferences\n\n\n        for (let i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n      // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n\n\n      if (isRegex && search.global) {\n        search.lastIndex = args[args.length - 2] + args[0].length;\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement(...args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, (...args) => {\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          let n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? captureNames.indexOf(bracketed) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError(`Backreference to undefined group ${$0}`);\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if (dollarToken === '`') {\n          // $` (left context)\n          return args[args.length - 1].slice(0, args[args.length - 2]);\n        }\n\n        if (dollarToken === \"'\") {\n          // $' (right context)\n          return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(`Backreference to undefined group ${$0}`);\n          }\n\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError(`Invalid token ${$0}`);\n      }\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  const str = String(this);\n  const output = [];\n  const origLastIndex = separator.lastIndex;\n  let lastLastIndex = 0;\n  let lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  XRegExp.forEach(str, separator, match => {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push(str.slice(lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, match.slice(1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push(str.slice(lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? output.slice(0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, (match, scope) => {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError(`Invalid escape ${match[0]}`);\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, (match, scope, flags) => {\n  const code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(`Invalid Unicode code point ${match[0]}`);\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return `\\\\u${pad4(hex(code))}`;\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && flags.includes('u')) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nmatch => match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B',\n/* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, () => '[\\\\s\\\\S]', {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  const index = isNaN(match[1]) ? this.captureNames.indexOf(match[1]) + 1 : +match[1];\n  const endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(`Backreference to undefined group ${match[0]}`);\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return `\\\\${index}${endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)'}`;\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(`Cannot use octal escape or backreference to undefined group ${match[0]}`);\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(`Cannot use integer as capture name ${match[0]}`);\n  }\n\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(`Cannot use reserved word as capture name ${match[0]}`);\n  }\n\n  if (this.captureNames.includes(match[1])) {\n    throw new SyntaxError(`Cannot use same name for multiple groups ${match[0]}`);\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if (flags.includes('n')) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nexport default XRegExp;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/src/xregexp.js"],"names":["REGEX_DATA","features","astral","namespacing","nativ","exec","RegExp","prototype","test","match","String","replace","split","fixed","regexCache","patternCache","tokens","defaultScope","classScope","nativeTokens","replacementToken","correctExecNpcg","call","undefined","hasFlagsProp","flags","toString","hasNativeFlag","flag","isSupported","exception","hasNativeU","hasNativeY","registeredFlags","g","i","m","u","y","augment","regex","captureNames","xSource","xFlags","isInternalOnly","__proto__","XRegExp","p","source","sort","join","clipDuplicates","str","copyRegex","options","isRegExp","TypeError","xData","getNativeFlags","flagsToAdd","flagsToRemove","xregexpSource","xregexpFlags","removeG","removeY","addG","addY","hasNamedCapture","slice","dec","hex","parseInt","getContextualTokenSeparator","scope","input","index","length","substr","isQuantifierNext","pattern","pos","inlineCommentPattern","lineCommentPattern","quantifierPattern","includes","isType","value","type","pad4","prepareFlags","SyntaxError","$0","$1","prepareOptions","forEach","registerFlag","Error","runTokens","context","leadChar","result","t","matchLength","output","handler","reparse","setAstral","on","setNamespacing","toObject","isInstalled","applied","appliedPattern","appliedFlags","token","captures","generated","version","_clipDuplicates","_hasNativeFlag","_dec","_hex","_pad4","addToken","optionalFlags","push","cache","flush","cacheName","escape","sticky","cacheKey","fakeY","r2","lastIndex","pop","global","callback","globalize","install","feature","matchChain","chain","recurseChain","values","level","item","matches","addMatch","backref","ERR_UNDEFINED_GROUP","isNamedBackref","isNaN","groups","ReferenceError","hasOwnProperty","backrefValue","search","replacement","isRegex","s2","replaceEach","replacements","r","separator","limit","uninstall","union","patterns","conjunction","numCaptures","numPriorCaptures","rewrite","paren","name","parts","origLastIndex","apply","arguments","args","len","groupsObject","Object","create","replacer","bracketed","angled","dollarToken","n","indexOf","lastLastIndex","lastLength","Array","code","endIndex"],"mappings":"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","sourcesContent":["/*!\n * XRegExp 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n\n// Property name used for extended regex instance data\nconst REGEX_DATA = 'xregexp';\n// Optional features that can be installed and uninstalled\nconst features = {\n    astral: false,\n    namespacing: false\n};\n// Native methods to use and restore ('native' is an ES3 reserved keyword)\nconst nativ = {\n    exec: RegExp.prototype.exec,\n    test: RegExp.prototype.test,\n    match: String.prototype.match,\n    replace: String.prototype.replace,\n    split: String.prototype.split\n};\n// Storage for fixed/extended native methods\nconst fixed = {};\n// Storage for regexes cached by `XRegExp.cache`\nlet regexCache = {};\n// Storage for pattern details cached by the `XRegExp` constructor\nlet patternCache = {};\n// Storage for regex syntax tokens added internally or by `XRegExp.addToken`\nconst tokens = [];\n// Token scopes\nconst defaultScope = 'default';\nconst classScope = 'class';\n// Regexes that match native regex syntax, including octals\nconst nativeTokens = {\n    // Any native multicharacter token in default scope, or any single character\n    'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n    // Any native multicharacter token in character class scope, or any single character\n    'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n};\n// Any backreference or dollar-prefixed character in replacement strings\nconst replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g;\n// Check for correct `exec` handling of nonparticipating capturing groups\nconst correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;\n// Check for ES6 `flags` prop support\nconst hasFlagsProp = /x/.flags !== undefined;\n// Shortcut to `Object.prototype.toString`\nconst {toString} = {};\n\nfunction hasNativeFlag(flag) {\n    // Can't check based on the presence of properties/getters since browsers might support such\n    // properties even when they don't support the corresponding flag in regex construction (tested\n    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n    // throws an error)\n    let isSupported = true;\n    try {\n        // Can't use regex literals for testing even in a `try` because regex literals with\n        // unsupported flags cause a compilation error in IE\n        new RegExp('', flag);\n    } catch (exception) {\n        isSupported = false;\n    }\n    return isSupported;\n}\n// Check for ES6 `u` flag support\nconst hasNativeU = hasNativeFlag('u');\n// Check for ES6 `y` flag support\nconst hasNativeY = hasNativeFlag('y');\n// Tracker for known flags, including addon flags\nconst registeredFlags = {\n    g: true,\n    i: true,\n    m: true,\n    u: hasNativeU,\n    y: hasNativeY\n};\n\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n    regex[REGEX_DATA] = {\n        captureNames\n    };\n\n    if (isInternalOnly) {\n        return regex;\n    }\n\n    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n    if (regex.__proto__) {\n        regex.__proto__ = XRegExp.prototype;\n    } else {\n        for (const p in XRegExp.prototype) {\n            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n            // extensions exist on `regex.prototype` anyway\n            regex[p] = XRegExp.prototype[p];\n        }\n    }\n\n    regex[REGEX_DATA].source = xSource;\n    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;\n\n    return regex;\n}\n\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\nfunction clipDuplicates(str) {\n    return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\nfunction copyRegex(regex, options) {\n    if (!XRegExp.isRegExp(regex)) {\n        throw new TypeError('Type RegExp expected');\n    }\n\n    const xData = regex[REGEX_DATA] || {};\n    let flags = getNativeFlags(regex);\n    let flagsToAdd = '';\n    let flagsToRemove = '';\n    let xregexpSource = null;\n    let xregexpFlags = null;\n\n    options = options || {};\n\n    if (options.removeG) {flagsToRemove += 'g';}\n    if (options.removeY) {flagsToRemove += 'y';}\n    if (flagsToRemove) {\n        flags = nativ.replace.call(flags, new RegExp(`[${flagsToRemove}]+`, 'g'), '');\n    }\n\n    if (options.addG) {flagsToAdd += 'g';}\n    if (options.addY) {flagsToAdd += 'y';}\n    if (flagsToAdd) {\n        flags = clipDuplicates(flags + flagsToAdd);\n    }\n\n    if (!options.isInternalOnly) {\n        if (xData.source !== undefined) {\n            xregexpSource = xData.source;\n        }\n        // null or undefined; don't want to add to `flags` if the previous value was null, since\n        // that indicates we're not tracking original precompilation flags\n        if (xData.flags != null) {\n            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n            // removed for non-internal regexes, so don't need to handle it\n            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;\n        }\n    }\n\n    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n    // translation to native regex syntax\n    regex = augment(\n        new RegExp(options.source || regex.source, flags),\n        hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,\n        xregexpSource,\n        xregexpFlags,\n        options.isInternalOnly\n    );\n\n    return regex;\n}\n\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\nfunction dec(hex) {\n    return parseInt(hex, 16);\n}\n\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\nfunction getContextualTokenSeparator(match, scope, flags) {\n    if (\n        // No need to separate tokens if at the beginning or end of a group\n        match.input[match.index - 1] === '(' ||\n        match.input[match.index + match[0].length] === ')' ||\n\n        // No need to separate tokens if before or after a `|`\n        match.input[match.index - 1] === '|' ||\n        match.input[match.index + match[0].length] === '|' ||\n\n        // No need to separate tokens if at the beginning or end of the pattern\n        match.index < 1 ||\n        match.index + match[0].length >= match.input.length ||\n\n        // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n        // The way this is written relies on:\n        // - The search regex matching only 3-char strings.\n        // - Although `substr` gives chars from the end of the string if given a negative index,\n        //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n        nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) ||\n\n        // Avoid separating tokens when the following token is a quantifier\n        isQuantifierNext(match.input, match.index + match[0].length, flags)\n    ) {\n        return '';\n    }\n    // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n    // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n    // error `(? :` into `(?:`.\n    return '(?:)';\n}\n\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\nfunction getNativeFlags(regex) {\n    return hasFlagsProp ?\n        regex.flags :\n        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n        // with an empty string) allows this to continue working predictably when\n        // `XRegExp.proptotype.toString` is overridden\n        nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\nfunction hasNamedCapture(regex) {\n    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\nfunction hex(dec) {\n    return parseInt(dec, 10).toString(16);\n}\n\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\nfunction isQuantifierNext(pattern, pos, flags) {\n    const inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n    const lineCommentPattern = '#[^#\\\\n]*';\n    const quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n    return nativ.test.call(\n        flags.includes('x') ?\n            // Ignore any leading whitespace, line comments, and inline comments\n            new RegExp(`^(?:\\\\s|${lineCommentPattern}|${inlineCommentPattern})*(?:${quantifierPattern})`) :\n            // Ignore any leading inline comments\n            new RegExp(`^(?:${inlineCommentPattern})*(?:${quantifierPattern})`),\n        pattern.slice(pos)\n    );\n}\n\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\nfunction isType(value, type) {\n    return toString.call(value) === `[object ${type}]`;\n}\n\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\nfunction pad4(str) {\n    while (str.length < 4) {\n        str = `0${str}`;\n    }\n    return str;\n}\n\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\nfunction prepareFlags(pattern, flags) {\n    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n    if (clipDuplicates(flags) !== flags) {\n        throw new SyntaxError(`Invalid duplicate regex flag ${flags}`);\n    }\n\n    // Strip and apply a leading mode modifier with any combination of flags except g or y\n    pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, ($0, $1) => {\n        if (nativ.test.call(/[gy]/, $1)) {\n            throw new SyntaxError(`Cannot use flag g or y in mode modifier ${$0}`);\n        }\n        // Allow duplicate flags within the mode modifier\n        flags = clipDuplicates(flags + $1);\n        return '';\n    });\n\n    // Throw on unknown native or nonnative flags\n    for (const flag of flags) {\n        if (!registeredFlags[flag]) {\n            throw new SyntaxError(`Unknown regex flag ${flag}`);\n        }\n    }\n\n    return {\n        pattern,\n        flags\n    };\n}\n\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\nfunction prepareOptions(value) {\n    const options = {};\n\n    if (isType(value, 'String')) {\n        XRegExp.forEach(value, /[^\\s,]+/, (match) => {\n            options[match] = true;\n        });\n\n        return options;\n    }\n\n    return value;\n}\n\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\nfunction registerFlag(flag) {\n    if (!/^[\\w$]$/.test(flag)) {\n        throw new Error('Flag must be a single character A-Za-z0-9_$');\n    }\n\n    registeredFlags[flag] = true;\n}\n\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\nfunction runTokens(pattern, flags, pos, scope, context) {\n    let i = tokens.length;\n    const leadChar = pattern[pos];\n    let result = null;\n    let match;\n    let t;\n\n    // Run in reverse insertion order\n    while (i--) {\n        t = tokens[i];\n        if (\n            (t.leadChar && t.leadChar !== leadChar) ||\n            (t.scope !== scope && t.scope !== 'all') ||\n            (t.flag && !flags.includes(t.flag))\n        ) {\n            continue;\n        }\n\n        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n        if (match) {\n            result = {\n                matchLength: match[0].length,\n                output: t.handler.call(context, match, scope, flags),\n                reparse: t.reparse\n            };\n            // Finished with token tests\n            break;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\nfunction setAstral(on) {\n    features.astral = on;\n}\n\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\nfunction setNamespacing(on) {\n    features.namespacing = on;\n}\n\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\nfunction toObject(value) {\n    // null or undefined\n    if (value == null) {\n        throw new TypeError('Cannot convert null or undefined to object');\n    }\n\n    return value;\n}\n\n// ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\nfunction XRegExp(pattern, flags) {\n    if (XRegExp.isRegExp(pattern)) {\n        if (flags !== undefined) {\n            throw new TypeError('Cannot supply flags when copying a RegExp');\n        }\n        return copyRegex(pattern);\n    }\n\n    // Copy the argument behavior of `RegExp`\n    pattern = pattern === undefined ? '' : String(pattern);\n    flags = flags === undefined ? '' : String(flags);\n\n    if (XRegExp.isInstalled('astral') && !flags.includes('A')) {\n        // This causes an error to be thrown if the Unicode Base addon is not available\n        flags += 'A';\n    }\n\n    if (!patternCache[pattern]) {\n        patternCache[pattern] = {};\n    }\n\n    if (!patternCache[pattern][flags]) {\n        const context = {\n            hasNamedCapture: false,\n            captureNames: []\n        };\n        let scope = defaultScope;\n        let output = '';\n        let pos = 0;\n        let result;\n\n        // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n        const applied = prepareFlags(pattern, flags);\n        let appliedPattern = applied.pattern;\n        const appliedFlags = applied.flags;\n\n        // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n        // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n        while (pos < appliedPattern.length) {\n            do {\n                // Check for custom tokens at the current position\n                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);\n                // If the matched token used the `reparse` option, splice its output into the\n                // pattern before running tokens again at the same position\n                if (result && result.reparse) {\n                    appliedPattern = appliedPattern.slice(0, pos) +\n                        result.output +\n                        appliedPattern.slice(pos + result.matchLength);\n                }\n            } while (result && result.reparse);\n\n            if (result) {\n                output += result.output;\n                pos += (result.matchLength || 1);\n            } else {\n                // Get the native token at the current position\n                const [token] = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky');\n                output += token;\n                pos += token.length;\n                if (token === '[' && scope === defaultScope) {\n                    scope = classScope;\n                } else if (token === ']' && scope === classScope) {\n                    scope = defaultScope;\n                }\n            }\n        }\n\n        patternCache[pattern][flags] = {\n            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n            // groups are sometimes inserted during regex transpilation in order to keep tokens\n            // separated. However, more than one empty group in a row is never needed.\n            pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n            // Strip all but native flags\n            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n            // `context.captureNames` has an item for each capturing group, even if unnamed\n            captures: context.hasNamedCapture ? context.captureNames : null\n        };\n    }\n\n    const generated = patternCache[pattern][flags];\n    return augment(\n        new RegExp(generated.pattern, generated.flags),\n        generated.captures,\n        pattern,\n        flags\n    );\n}\n\n// Add `RegExp.prototype` to the prototype chain\nXRegExp.prototype = new RegExp();\n\n// ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\nXRegExp.version = '4.3.0';\n\n// ==--------------------------==\n// Public methods\n// ==--------------------------==\n\n// Intentionally undocumented; used in tests and addons\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\nXRegExp.addToken = (regex, handler, options) => {\n    options = options || {};\n    let {optionalFlags} = options;\n\n    if (options.flag) {\n        registerFlag(options.flag);\n    }\n\n    if (optionalFlags) {\n        optionalFlags = nativ.split.call(optionalFlags, '');\n        for (const flag of optionalFlags) {\n            registerFlag(flag);\n        }\n    }\n\n    // Add to the private list of syntax tokens\n    tokens.push({\n        regex: copyRegex(regex, {\n            addG: true,\n            addY: hasNativeY,\n            isInternalOnly: true\n        }),\n        handler,\n        scope: options.scope || defaultScope,\n        flag: options.flag,\n        reparse: options.reparse,\n        leadChar: options.leadChar\n    });\n\n    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n    // might now produce different results\n    XRegExp.cache.flush('patterns');\n};\n\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\nXRegExp.cache = (pattern, flags) => {\n    if (!regexCache[pattern]) {\n        regexCache[pattern] = {};\n    }\n    return regexCache[pattern][flags] || (\n        regexCache[pattern][flags] = XRegExp(pattern, flags)\n    );\n};\n\n// Intentionally undocumented; used in tests\nXRegExp.cache.flush = (cacheName) => {\n    if (cacheName === 'patterns') {\n        // Flush the pattern cache used by the `XRegExp` constructor\n        patternCache = {};\n    } else {\n        // Flush the regex cache populated by `XRegExp.cache`\n        regexCache = {};\n    }\n};\n\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\nXRegExp.escape = (str) => nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\nXRegExp.exec = (str, regex, pos, sticky) => {\n    let cacheKey = 'g';\n    let addY = false;\n    let fakeY = false;\n    let match;\n\n    addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));\n    if (addY) {\n        cacheKey += 'y';\n    } else if (sticky) {\n        // Simulate sticky matching by appending an empty capture to the original regex. The\n        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n        // and will not search the rest of the subject string. We'll know that the original regex\n        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n        // capture participated in the match).\n        fakeY = true;\n        cacheKey += 'FakeY';\n    }\n\n    regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n    // Shares cached copies with `XRegExp.match`/`replace`\n    const r2 = regex[REGEX_DATA][cacheKey] || (\n        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n            addG: true,\n            addY,\n            source: fakeY ? `${regex.source}|()` : undefined,\n            removeY: sticky === false,\n            isInternalOnly: true\n        })\n    );\n\n    pos = pos || 0;\n    r2.lastIndex = pos;\n\n    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n    match = fixed.exec.call(r2, str);\n\n    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n    // the original regexp failed (see above).\n    if (fakeY && match && match.pop() === '') {\n        match = null;\n    }\n\n    if (regex.global) {\n        regex.lastIndex = match ? r2.lastIndex : 0;\n    }\n\n    return match;\n};\n\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\nXRegExp.forEach = (str, regex, callback) => {\n    let pos = 0;\n    let i = -1;\n    let match;\n\n    while ((match = XRegExp.exec(str, regex, pos))) {\n        // Because `regex` is provided to `callback`, the function could use the deprecated/\n        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n        // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n        // which is a nice side effect that brings extra safety.\n        callback(match, ++i, str, regex);\n\n        pos = match.index + (match[0].length || 1);\n    }\n};\n\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\nXRegExp.globalize = (regex) => copyRegex(regex, {addG: true});\n\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\nXRegExp.install = (options) => {\n    options = prepareOptions(options);\n\n    if (!features.astral && options.astral) {\n        setAstral(true);\n    }\n\n    if (!features.namespacing && options.namespacing) {\n        setNamespacing(true);\n    }\n};\n\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\nXRegExp.isInstalled = (feature) => !!(features[feature]);\n\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\nXRegExp.isRegExp = (value) => toString.call(value) === '[object RegExp]'; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\nXRegExp.match = (str, regex, scope) => {\n    const global = (regex.global && scope !== 'one') || scope === 'all';\n    const cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';\n\n    regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n    // Shares cached copies with `XRegExp.exec`/`replace`\n    const r2 = regex[REGEX_DATA][cacheKey] || (\n        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n            addG: !!global,\n            removeG: scope === 'one',\n            isInternalOnly: true\n        })\n    );\n\n    const result = nativ.match.call(toObject(str), r2);\n\n    if (regex.global) {\n        regex.lastIndex = (\n            (scope === 'one' && result) ?\n                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n                (result.index + result[0].length) : 0\n        );\n    }\n\n    return global ? (result || []) : (result && result[0]);\n};\n\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\nXRegExp.matchChain = (str, chain) => (function recurseChain(values, level) {\n    const item = chain[level].regex ? chain[level] : {regex: chain[level]};\n    const matches = [];\n\n    function addMatch(match) {\n        if (item.backref) {\n            const ERR_UNDEFINED_GROUP = `Backreference to undefined group: ${item.backref}`;\n            const isNamedBackref = isNaN(item.backref);\n\n            if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n                // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n                if (!(item.backref in match.groups)) {\n                    throw new ReferenceError(ERR_UNDEFINED_GROUP);\n                }\n            } else if (!match.hasOwnProperty(item.backref)) {\n                throw new ReferenceError(ERR_UNDEFINED_GROUP);\n            }\n\n            const backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ?\n                match.groups[item.backref] :\n                match[item.backref];\n\n            matches.push(backrefValue || '');\n        } else {\n            matches.push(match[0]);\n        }\n    }\n\n    for (const value of values) {\n        XRegExp.forEach(value, item.regex, addMatch);\n    }\n\n    return ((level === chain.length - 1) || !matches.length) ?\n        matches :\n        recurseChain(matches, level + 1);\n}([str], 0));\n\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\nXRegExp.replace = (str, search, replacement, scope) => {\n    const isRegex = XRegExp.isRegExp(search);\n    const global = (search.global && scope !== 'one') || scope === 'all';\n    const cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';\n    let s2 = search;\n\n    if (isRegex) {\n        search[REGEX_DATA] = search[REGEX_DATA] || {};\n\n        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n        // `lastIndex` isn't updated *during* replacement iterations\n        s2 = search[REGEX_DATA][cacheKey] || (\n            search[REGEX_DATA][cacheKey] = copyRegex(search, {\n                addG: !!global,\n                removeG: scope === 'one',\n                isInternalOnly: true\n            })\n        );\n    } else if (global) {\n        s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n    }\n\n    // Fixed `replace` required for named backreferences, etc.\n    const result = fixed.replace.call(toObject(str), s2, replacement);\n\n    if (isRegex && search.global) {\n        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n        search.lastIndex = 0;\n    }\n\n    return result;\n};\n\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\nXRegExp.replaceEach = (str, replacements) => {\n    for (const r of replacements) {\n        str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n\n    return str;\n};\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\nXRegExp.split = (str, separator, limit) => fixed.split.call(toObject(str), separator, limit);\n\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\nXRegExp.test = (str, regex, pos, sticky) => !!XRegExp.exec(str, regex, pos, sticky);\n\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\nXRegExp.uninstall = (options) => {\n    options = prepareOptions(options);\n\n    if (features.astral && options.astral) {\n        setAstral(false);\n    }\n\n    if (features.namespacing && options.namespacing) {\n        setNamespacing(false);\n    }\n};\n\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\nXRegExp.union = (patterns, flags, options) => {\n    options = options || {};\n    const conjunction = options.conjunction || 'or';\n    let numCaptures = 0;\n    let numPriorCaptures;\n    let captureNames;\n\n    function rewrite(match, paren, backref) {\n        const name = captureNames[numCaptures - numPriorCaptures];\n\n        // Capturing group\n        if (paren) {\n            ++numCaptures;\n            // If the current capture has a name, preserve the name\n            if (name) {\n                return `(?<${name}>`;\n            }\n        // Backreference\n        } else if (backref) {\n            // Rewrite the backreference\n            return `\\\\${+backref + numPriorCaptures}`;\n        }\n\n        return match;\n    }\n\n    if (!(isType(patterns, 'Array') && patterns.length)) {\n        throw new TypeError('Must provide a nonempty array of patterns to merge');\n    }\n\n    const parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n    const output = [];\n    for (const pattern of patterns) {\n        if (XRegExp.isRegExp(pattern)) {\n            numPriorCaptures = numCaptures;\n            captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];\n\n            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n            // independently valid; helps keep this simple. Named captures are put back\n            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n        } else {\n            output.push(XRegExp.escape(pattern));\n        }\n    }\n\n    const separator = conjunction === 'none' ? '' : '|';\n    return XRegExp(output.join(separator), flags);\n};\n\n// ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\nfixed.exec = function(str) {\n    const origLastIndex = this.lastIndex;\n    const match = nativ.exec.apply(this, arguments);\n\n    if (match) {\n        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n        // in standards mode follows the spec.\n        if (!correctExecNpcg && match.length > 1 && match.includes('')) {\n            const r2 = copyRegex(this, {\n                removeG: true,\n                isInternalOnly: true\n            });\n            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n            // matching due to characters outside the match\n            nativ.replace.call(String(str).slice(match.index), r2, (...args) => {\n                const len = args.length;\n                // Skip index 0 and the last 2\n                for (let i = 1; i < len - 2; ++i) {\n                    if (args[i] === undefined) {\n                        match[i] = undefined;\n                    }\n                }\n            });\n        }\n\n        // Attach named capture properties\n        let groupsObject = match;\n        if (XRegExp.isInstalled('namespacing')) {\n            // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n            match.groups = Object.create(null);\n            groupsObject = match.groups;\n        }\n        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n            // Skip index 0\n            for (let i = 1; i < match.length; ++i) {\n                const name = this[REGEX_DATA].captureNames[i - 1];\n                if (name) {\n                    groupsObject[name] = match[i];\n                }\n            }\n        }\n\n        // Fix browsers that increment `lastIndex` after zero-length matches\n        if (this.global && !match[0].length && (this.lastIndex > match.index)) {\n            this.lastIndex = match.index;\n        }\n    }\n\n    if (!this.global) {\n        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n        this.lastIndex = origLastIndex;\n    }\n\n    return match;\n};\n\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\nfixed.test = function(str) {\n    // Do this the easy way :-)\n    return !!fixed.exec.call(this, str);\n};\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\nfixed.match = function(regex) {\n    if (!XRegExp.isRegExp(regex)) {\n        // Use the native `RegExp` rather than `XRegExp`\n        regex = new RegExp(regex);\n    } else if (regex.global) {\n        const result = nativ.match.apply(this, arguments);\n        // Fixes IE bug\n        regex.lastIndex = 0;\n\n        return result;\n    }\n\n    return fixed.exec.call(regex, toObject(this));\n};\n\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\nfixed.replace = function(search, replacement) {\n    const isRegex = XRegExp.isRegExp(search);\n    let origLastIndex;\n    let captureNames;\n    let result;\n\n    if (isRegex) {\n        if (search[REGEX_DATA]) {\n            ({captureNames} = search[REGEX_DATA]);\n        }\n        // Only needed if `search` is nonglobal\n        origLastIndex = search.lastIndex;\n    } else {\n        search += ''; // Type-convert\n    }\n\n    // Don't use `typeof`; some older browsers return 'function' for regex objects\n    if (isType(replacement, 'Function')) {\n        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n        // functions isn't type-converted to a string\n        result = nativ.replace.call(String(this), search, (...args) => {\n            if (captureNames) {\n                let groupsObject;\n\n                if (XRegExp.isInstalled('namespacing')) {\n                    // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n                    groupsObject = Object.create(null);\n                    args.push(groupsObject);\n                } else {\n                    // Change the `args[0]` string primitive to a `String` object that can store\n                    // properties. This really does need to use `String` as a constructor\n                    args[0] = new String(args[0]);\n                    [groupsObject] = args;\n                }\n\n                // Store named backreferences\n                for (let i = 0; i < captureNames.length; ++i) {\n                    if (captureNames[i]) {\n                        groupsObject[captureNames[i]] = args[i + 1];\n                    }\n                }\n            }\n            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n            if (isRegex && search.global) {\n                search.lastIndex = args[args.length - 2] + args[0].length;\n            }\n            // ES6 specs the context for replacement functions as `undefined`\n            return replacement(...args);\n        });\n    } else {\n        // Ensure that the last value of `args` will be a string when given nonstring `this`,\n        // while still throwing on null or undefined context\n        result = nativ.replace.call(this == null ? this : String(this), search, (...args) => {\n            return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n            function replacer($0, bracketed, angled, dollarToken) {\n                bracketed = bracketed || angled;\n                // Named or numbered backreference with curly or angled braces\n                if (bracketed) {\n                    // XRegExp behavior for `${n}` or `$<n>`:\n                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n                    //    entire match. Any number of leading zeros may be used.\n                    // 2. Backreference to named capture `n`, if it exists and is not an integer\n                    //    overridden by numbered capture. In practice, this does not overlap with\n                    //    numbered capture since XRegExp does not allow named capture to use a bare\n                    //    integer as the name.\n                    // 3. If the name or number does not refer to an existing capturing group, it's\n                    //    an error.\n                    let n = +bracketed; // Type-convert; drop leading zeros\n                    if (n <= args.length - 3) {\n                        return args[n] || '';\n                    }\n                    // Groups with the same name is an error, else would need `lastIndexOf`\n                    n = captureNames ? captureNames.indexOf(bracketed) : -1;\n                    if (n < 0) {\n                        throw new SyntaxError(`Backreference to undefined group ${$0}`);\n                    }\n                    return args[n + 1] || '';\n                }\n                // Else, special variable or numbered backreference without curly braces\n                if (dollarToken === '$') { // $$\n                    return '$';\n                }\n                if (dollarToken === '&' || +dollarToken === 0) { // $&, $0 (not followed by 1-9), $00\n                    return args[0];\n                }\n                if (dollarToken === '`') { // $` (left context)\n                    return args[args.length - 1].slice(0, args[args.length - 2]);\n                }\n                if (dollarToken === \"'\") { // $' (right context)\n                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\n                }\n                // Else, numbered backreference without braces\n                dollarToken = +dollarToken; // Type-convert; drop leading zero\n                // XRegExp behavior for `$n` and `$nn`:\n                // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n                // - `$1` is an error if no capturing groups.\n                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n                //   instead.\n                // - `$01` is `$1` if at least one capturing group, else it's an error.\n                // - `$0` (not followed by 1-9) and `$00` are the entire match.\n                // Native behavior, for comparison:\n                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n                // - `$1` is a literal `$1` if no capturing groups.\n                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n                // - `$0` is a literal `$0`.\n                if (!isNaN(dollarToken)) {\n                    if (dollarToken > args.length - 3) {\n                        throw new SyntaxError(`Backreference to undefined group ${$0}`);\n                    }\n                    return args[dollarToken] || '';\n                }\n                // `$` followed by an unsupported char is an error, unlike native JS\n                throw new SyntaxError(`Invalid token ${$0}`);\n            }\n        });\n    }\n\n    if (isRegex) {\n        if (search.global) {\n            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n            search.lastIndex = 0;\n        } else {\n            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n            search.lastIndex = origLastIndex;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\nfixed.split = function(separator, limit) {\n    if (!XRegExp.isRegExp(separator)) {\n        // Browsers handle nonregex split correctly, so use the faster native method\n        return nativ.split.apply(this, arguments);\n    }\n\n    const str = String(this);\n    const output = [];\n    const origLastIndex = separator.lastIndex;\n    let lastLastIndex = 0;\n    let lastLength;\n\n    // Values for `limit`, per the spec:\n    // If undefined: pow(2,32) - 1\n    // If 0, Infinity, or NaN: 0\n    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n    // If negative number: pow(2,32) - floor(abs(limit))\n    // If other: Type-convert, then use the above rules\n    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n    limit = (limit === undefined ? -1 : limit) >>> 0;\n\n    XRegExp.forEach(str, separator, (match) => {\n        // This condition is not the same as `if (match[0].length)`\n        if ((match.index + match[0].length) > lastLastIndex) {\n            output.push(str.slice(lastLastIndex, match.index));\n            if (match.length > 1 && match.index < str.length) {\n                Array.prototype.push.apply(output, match.slice(1));\n            }\n            lastLength = match[0].length;\n            lastLastIndex = match.index + lastLength;\n        }\n    });\n\n    if (lastLastIndex === str.length) {\n        if (!nativ.test.call(separator, '') || lastLength) {\n            output.push('');\n        }\n    } else {\n        output.push(str.slice(lastLastIndex));\n    }\n\n    separator.lastIndex = origLastIndex;\n    return output.length > limit ? output.slice(0, limit) : output;\n};\n\n// ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\nXRegExp.addToken(\n    /\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/,\n    (match, scope) => {\n        // \\B is allowed in default scope only\n        if (match[1] === 'B' && scope === defaultScope) {\n            return match[0];\n        }\n        throw new SyntaxError(`Invalid escape ${match[0]}`);\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\nXRegExp.addToken(\n    /\\\\u{([\\dA-Fa-f]+)}/,\n    (match, scope, flags) => {\n        const code = dec(match[1]);\n        if (code > 0x10FFFF) {\n            throw new SyntaxError(`Invalid Unicode code point ${match[0]}`);\n        }\n        if (code <= 0xFFFF) {\n            // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n            // separate from preceding tokens\n            return `\\\\u${pad4(hex(code))}`;\n        }\n        // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n        if (hasNativeU && flags.includes('u')) {\n            return match[0];\n        }\n        throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\nXRegExp.addToken(\n    /\\[(\\^?)\\]/,\n    // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n    // (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n    /* eslint-disable no-confusing-arrow */\n    (match) => (match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B'),\n    /* eslint-enable no-confusing-arrow */\n    {leadChar: '['}\n);\n\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\nXRegExp.addToken(\n    /\\(\\?#[^)]*\\)/,\n    getContextualTokenSeparator,\n    {leadChar: '('}\n);\n\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\nXRegExp.addToken(\n    /\\s+|#[^\\n]*\\n?/,\n    getContextualTokenSeparator,\n    {flag: 'x'}\n);\n\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\nXRegExp.addToken(\n    /\\./,\n    () => '[\\\\s\\\\S]',\n    {\n        flag: 's',\n        leadChar: '.'\n    }\n);\n\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\nXRegExp.addToken(\n    /\\\\k<([\\w$]+)>/,\n    function(match) {\n        // Groups with the same name is an error, else would need `lastIndexOf`\n        const index = isNaN(match[1]) ? (this.captureNames.indexOf(match[1]) + 1) : +match[1];\n        const endIndex = match.index + match[0].length;\n        if (!index || index > this.captureNames.length) {\n            throw new SyntaxError(`Backreference to undefined group ${match[0]}`);\n        }\n        // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n        // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n        return `\\\\${index}${\n            endIndex === match.input.length || isNaN(match.input[endIndex]) ?\n                '' : '(?:)'\n        }`;\n    },\n    {leadChar: '\\\\'}\n);\n\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\nXRegExp.addToken(\n    /\\\\(\\d+)/,\n    function(match, scope) {\n        if (\n            !(\n                scope === defaultScope &&\n                /^[1-9]/.test(match[1]) &&\n                +match[1] <= this.captureNames.length\n            ) &&\n            match[1] !== '0'\n        ) {\n            throw new SyntaxError(`Cannot use octal escape or backreference to undefined group ${match[0]}`);\n        }\n        return match[0];\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\nXRegExp.addToken(\n    /\\(\\?P?<([\\w$]+)>/,\n    function(match) {\n        // Disallow bare integers as names because named backreferences are added to match arrays\n        // and therefore numeric properties may lead to incorrect lookups\n        if (!isNaN(match[1])) {\n            throw new SyntaxError(`Cannot use integer as capture name ${match[0]}`);\n        }\n        if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n            throw new SyntaxError(`Cannot use reserved word as capture name ${match[0]}`);\n        }\n        if (this.captureNames.includes(match[1])) {\n            throw new SyntaxError(`Cannot use same name for multiple groups ${match[0]}`);\n        }\n        this.captureNames.push(match[1]);\n        this.hasNamedCapture = true;\n        return '(';\n    },\n    {leadChar: '('}\n);\n\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\nXRegExp.addToken(\n    /\\((?!\\?)/,\n    function(match, scope, flags) {\n        if (flags.includes('n')) {\n            return '(?:';\n        }\n        this.captureNames.push(null);\n        return '(';\n    },\n    {\n        optionalFlags: 'n',\n        leadChar: '('\n    }\n);\n\nexport default XRegExp;\n"]},"metadata":{},"sourceType":"module"}