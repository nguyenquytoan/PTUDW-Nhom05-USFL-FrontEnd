{"ast":null,"code":"!function (n, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t((n = n || self).workbox = {});\n}(this, function (n) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:window:4.3.1\"] && _();\n  } catch (n) {}\n\n  var t = function (n, t) {\n    return new Promise(function (i) {\n      var e = new MessageChannel();\n      e.port1.onmessage = function (n) {\n        return i(n.data);\n      }, n.postMessage(t, [e.port2]);\n    });\n  };\n\n  function i(n, t) {\n    for (var i = 0; i < t.length; i++) {\n      var e = t[i];\n      e.enumerable = e.enumerable || !1, e.configurable = !0, \"value\" in e && (e.writable = !0), Object.defineProperty(n, e.key, e);\n    }\n  }\n\n  function e(n) {\n    if (void 0 === n) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return n;\n  }\n\n  try {\n    self[\"workbox:core:4.3.1\"] && _();\n  } catch (n) {}\n\n  var r = function () {\n    var n = this;\n    this.promise = new Promise(function (t, i) {\n      n.resolve = t, n.reject = i;\n    });\n  },\n      o = function (n, t) {\n    return new URL(n, location).href === new URL(t, location).href;\n  },\n      u = function (n, t) {\n    Object.assign(this, t, {\n      type: n\n    });\n  };\n\n  function s(n) {\n    return function () {\n      for (var t = [], i = 0; i < arguments.length; i++) t[i] = arguments[i];\n\n      try {\n        return Promise.resolve(n.apply(this, t));\n      } catch (n) {\n        return Promise.reject(n);\n      }\n    };\n  }\n\n  function a(n, t, i) {\n    return i ? t ? t(n) : n : (n && n.then || (n = Promise.resolve(n)), t ? n.then(t) : n);\n  }\n\n  function c() {}\n\n  var f = function (n) {\n    var f, h;\n\n    function v(t, i) {\n      var o;\n      return void 0 === i && (i = {}), (o = n.call(this) || this).t = t, o.i = i, o.o = 0, o.u = new r(), o.s = new r(), o.h = new r(), o.v = o.v.bind(e(e(o))), o.l = o.l.bind(e(e(o))), o.g = o.g.bind(e(e(o))), o.m = o.m.bind(e(e(o))), o;\n    }\n\n    h = n, (f = v).prototype = Object.create(h.prototype), f.prototype.constructor = f, f.__proto__ = h;\n    var l,\n        w,\n        d,\n        g = v.prototype;\n    return g.register = s(function (n) {\n      var t,\n          i,\n          e = this,\n          r = (void 0 === n ? {} : n).immediate,\n          s = void 0 !== r && r;\n      return t = function () {\n        return e.p = Boolean(navigator.serviceWorker.controller), e.P = e.j(), a(e.O(), function (n) {\n          e.R = n, e.P && (e._ = e.P, e.s.resolve(e.P), e.h.resolve(e.P), e.k(e.P), e.P.addEventListener(\"statechange\", e.l, {\n            once: !0\n          }));\n          var t = e.R.waiting;\n          return t && o(t.scriptURL, e.t) && (e._ = t, Promise.resolve().then(function () {\n            e.dispatchEvent(new u(\"waiting\", {\n              sw: t,\n              wasWaitingBeforeRegister: !0\n            }));\n          })), e._ && e.u.resolve(e._), e.R.addEventListener(\"updatefound\", e.g), navigator.serviceWorker.addEventListener(\"controllerchange\", e.m, {\n            once: !0\n          }), \"BroadcastChannel\" in self && (e.B = new BroadcastChannel(\"workbox\"), e.B.addEventListener(\"message\", e.v)), navigator.serviceWorker.addEventListener(\"message\", e.v), e.R;\n        });\n      }, (i = function () {\n        if (!s && \"complete\" !== document.readyState) return function (n, t) {\n          if (!t) return n && n.then ? n.then(c) : Promise.resolve();\n        }(new Promise(function (n) {\n          return addEventListener(\"load\", n);\n        }));\n      }()) && i.then ? i.then(t) : t(i);\n    }), g.getSW = s(function () {\n      return this._ || this.u.promise;\n    }), g.messageSW = s(function (n) {\n      return a(this.getSW(), function (i) {\n        return t(i, n);\n      });\n    }), g.j = function () {\n      var n = navigator.serviceWorker.controller;\n      if (n && o(n.scriptURL, this.t)) return n;\n    }, g.O = s(function () {\n      var n = this;\n      return function (n, t) {\n        try {\n          var i = n();\n        } catch (n) {\n          return t(n);\n        }\n\n        return i && i.then ? i.then(void 0, t) : i;\n      }(function () {\n        return a(navigator.serviceWorker.register(n.t, n.i), function (t) {\n          return n.C = performance.now(), t;\n        });\n      }, function (n) {\n        throw n;\n      });\n    }), g.k = function (n) {\n      t(n, {\n        type: \"WINDOW_READY\",\n        meta: \"workbox-window\"\n      });\n    }, g.g = function () {\n      var n = this.R.installing;\n      this.o > 0 || !o(n.scriptURL, this.t) || performance.now() > this.C + 6e4 ? (this.L = n, this.R.removeEventListener(\"updatefound\", this.g)) : (this._ = n, this.u.resolve(n)), ++this.o, n.addEventListener(\"statechange\", this.l);\n    }, g.l = function (n) {\n      var t = this,\n          i = n.target,\n          e = i.state,\n          r = i === this.L,\n          o = r ? \"external\" : \"\",\n          s = {\n        sw: i,\n        originalEvent: n\n      };\n      !r && this.p && (s.isUpdate = !0), this.dispatchEvent(new u(o + e, s)), \"installed\" === e ? this.W = setTimeout(function () {\n        \"installed\" === e && t.R.waiting === i && t.dispatchEvent(new u(o + \"waiting\", s));\n      }, 200) : \"activating\" === e && (clearTimeout(this.W), r || this.s.resolve(i));\n    }, g.m = function (n) {\n      var t = this._;\n      t === navigator.serviceWorker.controller && (this.dispatchEvent(new u(\"controlling\", {\n        sw: t,\n        originalEvent: n\n      })), this.h.resolve(t));\n    }, g.v = function (n) {\n      var t = n.data;\n      this.dispatchEvent(new u(\"message\", {\n        data: t,\n        originalEvent: n\n      }));\n    }, l = v, (w = [{\n      key: \"active\",\n      get: function () {\n        return this.s.promise;\n      }\n    }, {\n      key: \"controlling\",\n      get: function () {\n        return this.h.promise;\n      }\n    }]) && i(l.prototype, w), d && i(l, d), v;\n  }(function () {\n    function n() {\n      this.D = {};\n    }\n\n    var t = n.prototype;\n    return t.addEventListener = function (n, t) {\n      this.M(n).add(t);\n    }, t.removeEventListener = function (n, t) {\n      this.M(n).delete(t);\n    }, t.dispatchEvent = function (n) {\n      n.target = this, this.M(n.type).forEach(function (t) {\n        return t(n);\n      });\n    }, t.M = function (n) {\n      return this.D[n] = this.D[n] || new Set();\n    }, n;\n  }());\n\n  n.Workbox = f, n.messageSW = t, Object.defineProperty(n, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"sources":["../_version.mjs","../messageSW.mjs","../../workbox-core/_version.mjs","../../workbox-core/_private/Deferred.mjs","../utils/urlsMatch.mjs","../utils/WorkboxEvent.mjs","../Workbox.mjs","../utils/EventTargetShim.mjs"],"names":["self","_","e","messageSW","sw","data","Promise","resolve","messageChannel","MessageChannel","port1","onmessage","evt","postMessage","port2","Deferred","promise","reject","_this","urlsMatch","url1","url2","URL","location","href","WorkboxEvent","type","props","Object","assign","this","Workbox","scriptURL","registerOptions","_scriptURL","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_onMessage","bind","_onStateChange","_onUpdateFound","_onControllerChange","f","args","i","arguments","length","apply","register","immediate","value","then","direct","document","readyState","res","addEventListener","_isUpdate","Boolean","navigator","serviceWorker","controller","_compatibleControllingSW","_this2","_getControllingSWIfCompatible","_registration","_registerScript","_sw","_reportWindowReady","once","waitingSW","waiting","dispatchEvent","wasWaitingBeforeRegister","_broadcastChannel","BroadcastChannel","getSW","reg","_this5","_registrationTime","performance","now","error","meta","installingSW","installing","_externalSW","removeEventListener","originalEvent","target","state","isExternal","eventPrefix","eventProps","isUpdate","_waitingTimeout","setTimeout","_this6","clearTimeout","result","body","recover","_eventListenerRegistry","listener","_getEventListenersByType","add","delete","event","forEach","Set"],"mappings":"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","sourcesContent":["try{self['workbox:window:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n *\n * @memberof module:workbox-window\n */\nconst messageSW = (sw, data) => {\n  return new Promise((resolve) => {\n    let messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = (evt) => resolve(evt.data);\n    sw.postMessage(data, [messageChannel.port2]);\n  });\n};\n\nexport {messageSW};\n","try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nconst urlsMatch = (url1, url2) => {\n  return new URL(url1, location).href === new URL(url2, location).href;\n};\n\nexport {urlsMatch};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nclass WorkboxEvent {\n  /**\n   * @param {string} type\n   * @param {Object} props\n   */\n  constructor(type, props) {\n    Object.assign(this, props, {type});\n  }\n}\n\nexport {WorkboxEvent};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {messageSW} from './messageSW.mjs';\nimport {EventTargetShim} from './utils/EventTargetShim.mjs';\nimport {urlsMatch} from './utils/urlsMatch.mjs';\nimport {WorkboxEvent} from './utils/WorkboxEvent.mjs';\nimport './_version.mjs';\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n *\n * @memberof module:workbox-window\n */\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0;\n\n    // Deferreds we can resolve later.\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n\n    // Bind event handler callbacks.\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n  async register({immediate = false} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' +\n            'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise((res) => addEventListener('load', res));\n    }\n\n    // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n    this._isUpdate = Boolean(navigator.serviceWorker.controller);\n\n    // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n\n    this._registration = await this._registerScript();\n\n    // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n      this._compatibleControllingSW.addEventListener(\n          'statechange', this._onStateChange, {once: true});\n    }\n\n    // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the prevoius\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n    const waitingSW = this._registration.waiting;\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW;\n\n      // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true,\n        }));\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' +\n              'before this script was registered...');\n        }\n      });\n    }\n\n    // If an \"own\" SW is already set, resolve the deferred.\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' +\n              'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' +\n              'currently controlling the page. The browser is now fetching ' +\n              'the new script now...');\n        }\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(\n            this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' +\n            'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n    navigator.serviceWorker.addEventListener(\n        'controllerchange', this._onControllerChange, {once: true});\n\n    // Add message listeners.\n    if ('BroadcastChannel' in self) {\n      this._broadcastChannel = new BroadcastChannel('workbox');\n      this._broadcastChannel.addEventListener('message', this._onMessage);\n    }\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n\n    return this._registration;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get active() {\n    return this._activeDeferred.promise;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  async getSW() {\n    // If `this._sw` is set, resolve with that as we want `getSW()` to\n    // return the correct (new) service worker if an update is found.\n    return this._sw || this._swDeferred.promise;\n  }\n\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return messageSW(sw, data);\n  }\n\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matchs.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    }\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(\n          this._scriptURL, this._registerOptions);\n\n      // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n      this._registrationTime = performance.now();\n\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      }\n      // Re-throw the error.\n      throw error;\n    }\n  }\n\n\n  /**\n   * Sends a message to the passed service worker that the window is ready.\n   *\n   * @param {ServiceWorker} sw\n   * @private\n   */\n  _reportWindowReady(sw) {\n    messageSW(sw, {\n      type: 'WINDOW_READY',\n      meta: 'workbox-window',\n    });\n  }\n\n  /**\n   * @private\n   */\n  _onUpdateFound() {\n    const installingSW = this._registration.installing;\n\n    // If the script URL passed to `navigator.serviceWorker.register()` is\n    // different from the current controlling SW's script URL, we know any\n    // successful registration calls will trigger an `updatefound` event.\n    // But if the registered script URL is the same as the current controlling\n    // SW's script URL, we'll only get an `updatefound` event if the file\n    // changed since it was last registered. This can be a problem if the user\n    // opens up the same page in a different tab, and that page registers\n    // a SW that triggers an update. It's a problem because this page has no\n    // good way of knowing whether the `updatefound` event came from the SW\n    // script it registered or from a registration attempt made by a newer\n    // version of the page running in another tab.\n    // To minimize the possibility of a false positive, we use the logic here:\n    let updateLikelyTriggeredExternally =\n        // Since we enforce only calling `register()` once, and since we don't\n        // add the `updatefound` event listener until the `register()` call, if\n        // `_updateFoundCount` is > 0 then it means this method has already\n        // been called, thus this SW must be external\n        this._updateFoundCount > 0 ||\n        // If the script URL of the installing SW is different from this\n        // instance's script URL, we know it's definitely not from our\n        // registration.\n        !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n        // If all of the above are false, then we use a time-based heuristic:\n        // Any `updatefound` event that occurs long after our registration is\n        // assumed to be external.\n        (performance.now() >\n            this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n\n    if (updateLikelyTriggeredExternally) {\n      this._externalSW = installingSW;\n      this._registration.removeEventListener(\n          'updatefound', this._onUpdateFound);\n    } else {\n      // If the update was not triggered externally we know the installing\n      // SW is the one we registered, so we set it.\n      this._sw = installingSW;\n      this._swDeferred.resolve(installingSW);\n\n      // The `installing` state isn't something we have a dedicated\n      // callback for, but we do log messages for it in development.\n      if (process.env.NODE_ENV !== 'production') {\n        if (navigator.serviceWorker.controller) {\n          logger.log('Updated service worker found. Installing now...');\n        } else {\n          logger.log('Service worker is installing...');\n        }\n      }\n    }\n\n    // Increment the `updatefound` count, so future invocations of this\n    // method can be sure they were triggered externally.\n    ++this._updateFoundCount;\n\n    // Add a `statechange` listener regardless of whether this update was\n    // triggered externally, since we have callbacks for both.\n    installingSW.addEventListener('statechange', this._onStateChange);\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onStateChange(originalEvent) {\n    const sw = originalEvent.target;\n    const {state} = sw;\n    const isExternal = sw === this._externalSW;\n    const eventPrefix = isExternal ? 'external' : '';\n\n    const eventProps = {sw, originalEvent};\n    if (!isExternal && this._isUpdate) {\n      eventProps.isUpdate = true;\n    }\n\n    this.dispatchEvent(new WorkboxEvent(\n        eventPrefix + state, eventProps));\n\n    if (state === 'installed') {\n      // This timeout is used to ignore cases where the service worker calls\n      // `skipWaiting()` in the install event, thus moving it directly in the\n      // activating state. (Since all service workers *must* go through the\n      // waiting phase, the only way to detect `skipWaiting()` called in the\n      // install event is to observe that the time spent in the waiting phase\n      // is very short.)\n      // NOTE: we don't need separate timeouts for the own and external SWs\n      // since they can't go through these phases at the same time.\n      this._waitingTimeout = setTimeout(() => {\n        // Ensure the SW is still waiting (it may now be redundant).\n        if (state === 'installed' && this._registration.waiting === sw) {\n          this.dispatchEvent(new WorkboxEvent(\n              eventPrefix + 'waiting', eventProps));\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (isExternal) {\n              logger.warn('An external service worker has installed but is ' +\n                  'waiting for this client to close before activating...');\n            } else {\n              logger.warn('The service worker has installed but is waiting ' +\n                  'for existing clients to close before activating...');\n            }\n          }\n        }\n      }, WAITING_TIMEOUT_DURATION);\n    } else if (state === 'activating') {\n      clearTimeout(this._waitingTimeout);\n      if (!isExternal) {\n        this._activeDeferred.resolve(sw);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      switch (state) {\n        case 'installed':\n          if (isExternal) {\n            logger.warn('An external service worker has installed. ' +\n                'You may want to suggest users reload this page.');\n          } else {\n            logger.log('Registered service worker installed.');\n          }\n          break;\n        case 'activated':\n          if (isExternal) {\n            logger.warn('An external service worker has activated.');\n          } else {\n            logger.log('Registered service worker activated.');\n            if (sw !== navigator.serviceWorker.controller) {\n              logger.warn('The registered service worker is active but ' +\n                  'not yet controlling the page. Reload or run ' +\n                  '`clients.claim()` in the service worker.');\n            }\n          }\n          break;\n        case 'redundant':\n          if (sw === this._compatibleControllingSW) {\n            logger.log('Previously controlling service worker now redundant!');\n          } else if (!isExternal) {\n            logger.log('Registered service worker now redundant!');\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onControllerChange(originalEvent) {\n    const sw = this._sw;\n    if (sw === navigator.serviceWorker.controller) {\n      this.dispatchEvent(new WorkboxEvent('controlling', {sw, originalEvent}));\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered service worker now controlling this page.');\n      }\n      this._controllingDeferred.resolve(sw);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onMessage(originalEvent) {\n    const {data} = originalEvent;\n    this.dispatchEvent(new WorkboxEvent('message', {data, originalEvent}));\n  }\n}\n\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` (or a\n * `BroadcastChannel` message with the `workbox` channel name) is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The native `controllerchange` event\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\nexport {Workbox};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nclass EventTargetShim {\n  /**\n   * Creates an event listener registry\n   *\n   * @private\n   */\n  constructor() {\n    // A registry of event types to listeners.\n    this._eventListenerRegistry = {};\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  addEventListener(type, listener) {\n    this._getEventListenersByType(type).add(listener);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  removeEventListener(type, listener) {\n    this._getEventListenersByType(type).delete(listener);\n  }\n\n  /**\n   * @param {Event} event\n   * @private\n   */\n  dispatchEvent(event) {\n    event.target = this;\n    this._getEventListenersByType(event.type).forEach(\n        (listener) => listener(event));\n  }\n\n  /**\n   * Returns a Set of listeners associated with the passed event type.\n   * If no handlers have been registered, an empty Set is returned.\n   *\n   * @param {string} type The event type.\n   * @return {Set} An array of handler functions.\n   * @private\n   */\n  _getEventListenersByType(type) {\n    return this._eventListenerRegistry[type] =\n        (this._eventListenerRegistry[type] || new Set());\n  }\n}\n\nexport {EventTargetShim};\n"]},"metadata":{},"sourceType":"script"}