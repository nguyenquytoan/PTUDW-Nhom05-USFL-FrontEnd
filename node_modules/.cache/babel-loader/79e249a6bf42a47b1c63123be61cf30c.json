{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\n\nvar matchDataUri = require('./match-data-uri');\n\nvar rebaseLocalMap = require('./rebase-local-map');\n\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\n\nvar hasProtocol = require('../utils/has-protocol');\n\nvar isDataUriResource = require('../utils/is-data-uri-resource');\n\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n  return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } else if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } else {\n    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n    // it is rebased to be consistent with rebasing other URIs\n    // however here we need to resolve it back to read it from disk\n    absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n    if (sourceMap) {\n      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n      return whenSourceMapReady(rebasedMap);\n    } else {\n      return whenSourceMapReady(null);\n    }\n  }\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n  var buffer = new Buffer(data, encoding);\n  buffer.charset = charset;\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/clean-css/lib/reader/apply-source-maps.js"],"names":["fs","require","path","isAllowedResource","matchDataUri","rebaseLocalMap","rebaseRemoteMap","Token","hasProtocol","isDataUriResource","isRemoteResource","MAP_MARKER_PATTERN","applySourceMaps","tokens","context","callback","applyContext","fetch","options","index","inline","inlineRequest","inlineTimeout","inputSourceMapTracker","localOnly","processedTokens","rebaseTo","sourceTokens","warnings","sourceMap","length","doApplySourceMaps","singleSourceTokens","lastSource","findTokenSource","source","token","l","push","COMMENT","test","fetchAndApplySourceMap","scope","metadata","AT_RULE","sourceMapComment","extractInputSourceMapFrom","inputSourceMap","track","applySourceMapRecursively","whenSourceMapReady","uri","exec","absoluteUri","rebasedMap","extractInputSourceMapFromDataUri","loadInputSourceMapFromRemoteUri","parsedMap","JSON","parse","resolve","loadInputSourceMapFromLocalUri","dataUriMatch","charset","split","encoding","data","global","unescape","buffer","Buffer","toString","whenLoaded","isAllowed","isRuntimeResource","error","body","existsSync","statSync","isFile","readFileSync","i","applySourceMapTo","AT_RULE_BLOCK","AT_RULE_BLOCK_SCOPE","NESTED_BLOCK","NESTED_BLOCK_SCOPE","PROPERTY","PROPERTY_BLOCK","PROPERTY_NAME","PROPERTY_VALUE","RULE","RULE_SCOPE","value","newMetadata","originalPositionFor","module","exports"],"mappings":"AAAA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AAEA,IAAIE,iBAAiB,GAAGF,OAAO,CAAC,uBAAD,CAA/B;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,kBAAD,CAA1B;;AACA,IAAII,cAAc,GAAGJ,OAAO,CAAC,oBAAD,CAA5B;;AACA,IAAIK,eAAe,GAAGL,OAAO,CAAC,qBAAD,CAA7B;;AAEA,IAAIM,KAAK,GAAGN,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAIO,WAAW,GAAGP,OAAO,CAAC,uBAAD,CAAzB;;AACA,IAAIQ,iBAAiB,GAAGR,OAAO,CAAC,+BAAD,CAA/B;;AACA,IAAIS,gBAAgB,GAAGT,OAAO,CAAC,6BAAD,CAA9B;;AAEA,IAAIU,kBAAkB,GAAG,qCAAzB;;AAEA,SAASC,eAAT,CAAyBC,MAAzB,EAAiCC,OAAjC,EAA0CC,QAA1C,EAAoD;AAClD,MAAIC,YAAY,GAAG;AACjBD,IAAAA,QAAQ,EAAEA,QADO;AAEjBE,IAAAA,KAAK,EAAEH,OAAO,CAACI,OAAR,CAAgBD,KAFN;AAGjBE,IAAAA,KAAK,EAAE,CAHU;AAIjBC,IAAAA,MAAM,EAAEN,OAAO,CAACI,OAAR,CAAgBE,MAJP;AAKjBC,IAAAA,aAAa,EAAEP,OAAO,CAACI,OAAR,CAAgBG,aALd;AAMjBC,IAAAA,aAAa,EAAER,OAAO,CAACI,OAAR,CAAgBI,aANd;AAOjBC,IAAAA,qBAAqB,EAAET,OAAO,CAACS,qBAPd;AAQjBC,IAAAA,SAAS,EAAEV,OAAO,CAACU,SARF;AASjBC,IAAAA,eAAe,EAAE,EATA;AAUjBC,IAAAA,QAAQ,EAAEZ,OAAO,CAACI,OAAR,CAAgBQ,QAVT;AAWjBC,IAAAA,YAAY,EAAEd,MAXG;AAYjBe,IAAAA,QAAQ,EAAEd,OAAO,CAACc;AAZD,GAAnB;AAeA,SAAOd,OAAO,CAACI,OAAR,CAAgBW,SAAhB,IAA6BhB,MAAM,CAACiB,MAAP,GAAgB,CAA7C,GACLC,iBAAiB,CAACf,YAAD,CADZ,GAELD,QAAQ,CAACF,MAAD,CAFV;AAGD;;AAED,SAASkB,iBAAT,CAA2Bf,YAA3B,EAAyC;AACvC,MAAIgB,kBAAkB,GAAG,EAAzB;AACA,MAAIC,UAAU,GAAGC,eAAe,CAAClB,YAAY,CAACW,YAAb,CAA0B,CAA1B,CAAD,CAAhC;AACA,MAAIQ,MAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,CAAJ;;AAEA,OAAKA,CAAC,GAAGrB,YAAY,CAACW,YAAb,CAA0BG,MAAnC,EAA2Cd,YAAY,CAACG,KAAb,GAAqBkB,CAAhE,EAAmErB,YAAY,CAACG,KAAb,EAAnE,EAAyF;AACvFiB,IAAAA,KAAK,GAAGpB,YAAY,CAACW,YAAb,CAA0BX,YAAY,CAACG,KAAvC,CAAR;AACAgB,IAAAA,MAAM,GAAGD,eAAe,CAACE,KAAD,CAAxB;;AAEA,QAAID,MAAM,IAAIF,UAAd,EAA0B;AACxBD,MAAAA,kBAAkB,GAAG,EAArB;AACAC,MAAAA,UAAU,GAAGE,MAAb;AACD;;AAEDH,IAAAA,kBAAkB,CAACM,IAAnB,CAAwBF,KAAxB;AACApB,IAAAA,YAAY,CAACS,eAAb,CAA6Ba,IAA7B,CAAkCF,KAAlC;;AAEA,QAAIA,KAAK,CAAC,CAAD,CAAL,IAAY7B,KAAK,CAACgC,OAAlB,IAA6B5B,kBAAkB,CAAC6B,IAAnB,CAAwBJ,KAAK,CAAC,CAAD,CAA7B,CAAjC,EAAoE;AAClE,aAAOK,sBAAsB,CAACL,KAAK,CAAC,CAAD,CAAN,EAAWD,MAAX,EAAmBH,kBAAnB,EAAuChB,YAAvC,CAA7B;AACD;AACF;;AAED,SAAOA,YAAY,CAACD,QAAb,CAAsBC,YAAY,CAACS,eAAnC,CAAP;AACD;;AAED,SAASS,eAAT,CAAyBE,KAAzB,EAAgC;AAC9B,MAAIM,KAAJ;AACA,MAAIC,QAAJ;;AAEA,MAAIP,KAAK,CAAC,CAAD,CAAL,IAAY7B,KAAK,CAACqC,OAAlB,IAA6BR,KAAK,CAAC,CAAD,CAAL,IAAY7B,KAAK,CAACgC,OAAnD,EAA4D;AAC1DI,IAAAA,QAAQ,GAAGP,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAX;AACD,GAFD,MAEO;AACLM,IAAAA,KAAK,GAAGN,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAR;AACAO,IAAAA,QAAQ,GAAGD,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAX;AACD;;AAED,SAAOC,QAAQ,CAAC,CAAD,CAAf;AACD;;AAED,SAASF,sBAAT,CAAgCI,gBAAhC,EAAkDV,MAAlD,EAA0DH,kBAA1D,EAA8EhB,YAA9E,EAA4F;AAC1F,SAAO8B,yBAAyB,CAACD,gBAAD,EAAmB7B,YAAnB,EAAiC,UAAU+B,cAAV,EAA0B;AACzF,QAAIA,cAAJ,EAAoB;AAClB/B,MAAAA,YAAY,CAACO,qBAAb,CAAmCyB,KAAnC,CAAyCb,MAAzC,EAAiDY,cAAjD;AACAE,MAAAA,yBAAyB,CAACjB,kBAAD,EAAqBhB,YAAY,CAACO,qBAAlC,CAAzB;AACD;;AAEDP,IAAAA,YAAY,CAACG,KAAb;AACA,WAAOY,iBAAiB,CAACf,YAAD,CAAxB;AACD,GAR+B,CAAhC;AASD;;AAED,SAAS8B,yBAAT,CAAmCD,gBAAnC,EAAqD7B,YAArD,EAAmEkC,kBAAnE,EAAuF;AACrF,MAAIC,GAAG,GAAGxC,kBAAkB,CAACyC,IAAnB,CAAwBP,gBAAxB,EAA0C,CAA1C,CAAV;AACA,MAAIQ,WAAJ;AACA,MAAIxB,SAAJ;AACA,MAAIyB,UAAJ;;AAEA,MAAI7C,iBAAiB,CAAC0C,GAAD,CAArB,EAA4B;AAC1BtB,IAAAA,SAAS,GAAG0B,gCAAgC,CAACJ,GAAD,CAA5C;AACA,WAAOD,kBAAkB,CAACrB,SAAD,CAAzB;AACD,GAHD,MAGO,IAAInB,gBAAgB,CAACyC,GAAD,CAApB,EAA2B;AAChC,WAAOK,+BAA+B,CAACL,GAAD,EAAMnC,YAAN,EAAoB,UAAUa,SAAV,EAAqB;AAC7E,UAAI4B,SAAJ;;AAEA,UAAI5B,SAAJ,EAAe;AACb4B,QAAAA,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAW9B,SAAX,CAAZ;AACAyB,QAAAA,UAAU,GAAGhD,eAAe,CAACmD,SAAD,EAAYN,GAAZ,CAA5B;AACAD,QAAAA,kBAAkB,CAACI,UAAD,CAAlB;AACD,OAJD,MAIO;AACLJ,QAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACD;AACF,KAVqC,CAAtC;AAWD,GAZM,MAYA;AACL;AACA;AACA;AACAG,IAAAA,WAAW,GAAGnD,IAAI,CAAC0D,OAAL,CAAa5C,YAAY,CAACU,QAA1B,EAAoCyB,GAApC,CAAd;AACAtB,IAAAA,SAAS,GAAGgC,8BAA8B,CAACR,WAAD,EAAcrC,YAAd,CAA1C;;AAEA,QAAIa,SAAJ,EAAe;AACbyB,MAAAA,UAAU,GAAGjD,cAAc,CAACwB,SAAD,EAAYwB,WAAZ,EAAyBrC,YAAY,CAACU,QAAtC,CAA3B;AACA,aAAOwB,kBAAkB,CAACI,UAAD,CAAzB;AACD,KAHD,MAGO;AACL,aAAOJ,kBAAkB,CAAC,IAAD,CAAzB;AACD;AACF;AACF;;AAED,SAASK,gCAAT,CAA0CJ,GAA1C,EAA+C;AAC7C,MAAIW,YAAY,GAAG1D,YAAY,CAAC+C,GAAD,CAA/B;AACA,MAAIY,OAAO,GAAGD,YAAY,CAAC,CAAD,CAAZ,GAAkBA,YAAY,CAAC,CAAD,CAAZ,CAAgBE,KAAhB,CAAsB,MAAtB,EAA8B,CAA9B,CAAlB,GAAqD,UAAnE;AACA,MAAIC,QAAQ,GAAGH,YAAY,CAAC,CAAD,CAAZ,GAAkBA,YAAY,CAAC,CAAD,CAAZ,CAAgBE,KAAhB,CAAsB,GAAtB,EAA2B,CAA3B,CAAlB,GAAkD,MAAjE;AACA,MAAIE,IAAI,GAAGD,QAAQ,IAAI,MAAZ,GAAqBE,MAAM,CAACC,QAAP,CAAgBN,YAAY,CAAC,CAAD,CAA5B,CAArB,GAAwDA,YAAY,CAAC,CAAD,CAA/E;AAEA,MAAIO,MAAM,GAAG,IAAIC,MAAJ,CAAWJ,IAAX,EAAiBD,QAAjB,CAAb;AACAI,EAAAA,MAAM,CAACN,OAAP,GAAiBA,OAAjB;AAEA,SAAOL,IAAI,CAACC,KAAL,CAAWU,MAAM,CAACE,QAAP,EAAX,CAAP;AACD;;AAED,SAASf,+BAAT,CAAyCL,GAAzC,EAA8CnC,YAA9C,EAA4DwD,UAA5D,EAAwE;AACtE,MAAIC,SAAS,GAAGtE,iBAAiB,CAACgD,GAAD,EAAM,IAAN,EAAYnC,YAAY,CAACI,MAAzB,CAAjC;AACA,MAAIsD,iBAAiB,GAAG,CAAClE,WAAW,CAAC2C,GAAD,CAApC;;AAEA,MAAInC,YAAY,CAACQ,SAAjB,EAA4B;AAC1BR,IAAAA,YAAY,CAACY,QAAb,CAAsBU,IAAtB,CAA2B,wCAAwCa,GAAxC,GAA8C,yBAAzE;AACA,WAAOqB,UAAU,CAAC,IAAD,CAAjB;AACD,GAHD,MAGO,IAAIE,iBAAJ,EAAuB;AAC5B1D,IAAAA,YAAY,CAACY,QAAb,CAAsBU,IAAtB,CAA2B,mBAAmBa,GAAnB,GAAyB,yBAApD;AACA,WAAOqB,UAAU,CAAC,IAAD,CAAjB;AACD,GAHM,MAGA,IAAI,CAACC,SAAL,EAAgB;AACrBzD,IAAAA,YAAY,CAACY,QAAb,CAAsBU,IAAtB,CAA2B,mBAAmBa,GAAnB,GAAyB,+BAApD;AACA,WAAOqB,UAAU,CAAC,IAAD,CAAjB;AACD;;AAEDxD,EAAAA,YAAY,CAACC,KAAb,CAAmBkC,GAAnB,EAAwBnC,YAAY,CAACK,aAArC,EAAoDL,YAAY,CAACM,aAAjE,EAAgF,UAAUqD,KAAV,EAAiBC,IAAjB,EAAuB;AACrG,QAAID,KAAJ,EAAW;AACT3D,MAAAA,YAAY,CAACY,QAAb,CAAsBU,IAAtB,CAA2B,4BAA4Ba,GAA5B,GAAkC,MAAlC,GAA2CwB,KAAtE;AACA,aAAOH,UAAU,CAAC,IAAD,CAAjB;AACD;;AAEDA,IAAAA,UAAU,CAACI,IAAD,CAAV;AACD,GAPD;AAQD;;AAED,SAASf,8BAAT,CAAwCV,GAAxC,EAA6CnC,YAA7C,EAA2D;AACzD,MAAIyD,SAAS,GAAGtE,iBAAiB,CAACgD,GAAD,EAAM,KAAN,EAAanC,YAAY,CAACI,MAA1B,CAAjC;AACA,MAAIS,SAAJ;;AAEA,MAAI,CAAC7B,EAAE,CAAC6E,UAAH,CAAc1B,GAAd,CAAD,IAAuB,CAACnD,EAAE,CAAC8E,QAAH,CAAY3B,GAAZ,EAAiB4B,MAAjB,EAA5B,EAAuD;AACrD/D,IAAAA,YAAY,CAACY,QAAb,CAAsBU,IAAtB,CAA2B,mCAAmCa,GAAnC,GAAyC,2BAApE;AACA,WAAO,IAAP;AACD,GAHD,MAGO,IAAI,CAACsB,SAAL,EAAgB;AACrBzD,IAAAA,YAAY,CAACY,QAAb,CAAsBU,IAAtB,CAA2B,mBAAmBa,GAAnB,GAAyB,+BAApD;AACA,WAAO,IAAP;AACD;;AAEDtB,EAAAA,SAAS,GAAG7B,EAAE,CAACgF,YAAH,CAAgB7B,GAAhB,EAAqB,OAArB,CAAZ;AACA,SAAOO,IAAI,CAACC,KAAL,CAAW9B,SAAX,CAAP;AACD;;AAED,SAASoB,yBAAT,CAAmCpC,MAAnC,EAA2CU,qBAA3C,EAAkE;AAChE,MAAIa,KAAJ;AACA,MAAI6C,CAAJ,EAAO5C,CAAP;;AAEA,OAAK4C,CAAC,GAAG,CAAJ,EAAO5C,CAAC,GAAGxB,MAAM,CAACiB,MAAvB,EAA+BmD,CAAC,GAAG5C,CAAnC,EAAsC4C,CAAC,EAAvC,EAA2C;AACzC7C,IAAAA,KAAK,GAAGvB,MAAM,CAACoE,CAAD,CAAd;;AAEA,YAAQ7C,KAAK,CAAC,CAAD,CAAb;AACE,WAAK7B,KAAK,CAACqC,OAAX;AACEsC,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AACA;;AACF,WAAKhB,KAAK,CAAC4E,aAAX;AACElC,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA0B,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA;;AACF,WAAKhB,KAAK,CAAC6E,mBAAX;AACEF,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AACA;;AACF,WAAKhB,KAAK,CAAC8E,YAAX;AACEpC,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA0B,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA;;AACF,WAAKhB,KAAK,CAAC+E,kBAAX;AACEJ,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AACA;;AACF,WAAKhB,KAAK,CAACgC,OAAX;AACE2C,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AACA;;AACF,WAAKhB,KAAK,CAACgF,QAAX;AACEtC,QAAAA,yBAAyB,CAACb,KAAD,EAAQb,qBAAR,CAAzB;AACA;;AACF,WAAKhB,KAAK,CAACiF,cAAX;AACEvC,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA;;AACF,WAAKhB,KAAK,CAACkF,aAAX;AACEP,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AACA;;AACF,WAAKhB,KAAK,CAACmF,cAAX;AACER,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AACA;;AACF,WAAKhB,KAAK,CAACoF,IAAX;AACE1C,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA0B,QAAAA,yBAAyB,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWb,qBAAX,CAAzB;AACA;;AACF,WAAKhB,KAAK,CAACqF,UAAX;AACEV,QAAAA,gBAAgB,CAAC9C,KAAD,EAAQb,qBAAR,CAAhB;AAtCJ;AAwCD;;AAED,SAAOV,MAAP;AACD;;AAED,SAASqE,gBAAT,CAA0B9C,KAA1B,EAAiCb,qBAAjC,EAAwD;AACtD,MAAIsE,KAAK,GAAGzD,KAAK,CAAC,CAAD,CAAjB;AACA,MAAIO,QAAQ,GAAGP,KAAK,CAAC,CAAD,CAApB;AACA,MAAI0D,WAAW,GAAG,EAAlB;AACA,MAAIb,CAAJ,EAAO5C,CAAP;;AAEA,OAAK4C,CAAC,GAAG,CAAJ,EAAO5C,CAAC,GAAGM,QAAQ,CAACb,MAAzB,EAAiCmD,CAAC,GAAG5C,CAArC,EAAwC4C,CAAC,EAAzC,EAA6C;AAC3Ca,IAAAA,WAAW,CAACxD,IAAZ,CAAiBf,qBAAqB,CAACwE,mBAAtB,CAA0CpD,QAAQ,CAACsC,CAAD,CAAlD,EAAuDY,KAAK,CAAC/D,MAA7D,CAAjB;AACD;;AAEDM,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAW0D,WAAX;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiBrF,eAAjB","sourcesContent":["var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && tokens.length > 0 ?\n    doApplySourceMaps(applyContext) :\n    callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } else if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } else {\n    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n    // it is rebased to be consistent with rebasing other URIs\n    // however here we need to resolve it back to read it from disk\n    absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n    if (sourceMap) {\n      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n      return whenSourceMapReady(rebasedMap);\n    } else {\n      return whenSourceMapReady(null);\n    }\n  }\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n\n  var buffer = new Buffer(data, encoding);\n  buffer.charset = charset;\n\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;\n"]},"metadata":{},"sourceType":"script"}