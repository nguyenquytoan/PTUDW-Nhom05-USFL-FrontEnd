{"ast":null,"code":"/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary boolean casts\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedCall: \"Redundant Boolean call.\",\n      unexpectedNegation: \"Redundant double negation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Node types which have a test which will coerce values to booleans.\n\n    const BOOLEAN_NODE_TYPES = [\"IfStatement\", \"DoWhileStatement\", \"WhileStatement\", \"ConditionalExpression\", \"ForStatement\"];\n    /**\n     * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n     * @param {ASTNode} node The node\n     * @param {ASTNode} parent Its parent\n     * @returns {boolean} If it is in a boolean context\n     */\n\n    function isInBooleanContext(node, parent) {\n      return BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 && node === parent.test || // !<bool>\n      parent.type === \"UnaryExpression\" && parent.operator === \"!\";\n    }\n    /**\n     * Check if a node has comments inside.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if it has comments inside.\n     */\n\n\n    function hasCommentsInside(node) {\n      return Boolean(sourceCode.getCommentsInside(node).length);\n    }\n\n    return {\n      UnaryExpression(node) {\n        const ancestors = context.getAncestors(),\n              parent = ancestors.pop(),\n              grandparent = ancestors.pop(); // Exit early if it's guaranteed not to match\n\n        if (node.operator !== \"!\" || parent.type !== \"UnaryExpression\" || parent.operator !== \"!\") {\n          return;\n        }\n\n        if (isInBooleanContext(parent, grandparent) || // Boolean(<bool>) and new Boolean(<bool>)\n        (grandparent.type === \"CallExpression\" || grandparent.type === \"NewExpression\") && grandparent.callee.type === \"Identifier\" && grandparent.callee.name === \"Boolean\") {\n          context.report({\n            node: parent,\n            messageId: \"unexpectedNegation\",\n            fix: fixer => {\n              if (hasCommentsInside(parent)) {\n                return null;\n              }\n\n              let prefix = \"\";\n              const tokenBefore = sourceCode.getTokenBefore(parent);\n              const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n              if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \";\n              }\n\n              return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n            }\n          });\n        }\n      },\n\n      CallExpression(node) {\n        const parent = node.parent;\n\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n          return;\n        }\n\n        if (isInBooleanContext(node, parent)) {\n          context.report({\n            node,\n            messageId: \"unexpectedCall\",\n            fix: fixer => {\n              if (!node.arguments.length) {\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n                  // !Boolean() -> true\n                  if (hasCommentsInside(parent)) {\n                    return null;\n                  }\n\n                  const replacement = \"true\";\n                  let prefix = \"\";\n                  const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                    prefix = \" \";\n                  }\n\n                  return fixer.replaceText(parent, prefix + replacement);\n                } // Boolean() -> false\n\n\n                if (hasCommentsInside(node)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, \"false\");\n              }\n\n              if (node.arguments.length > 1 || node.arguments[0].type === \"SpreadElement\" || hasCommentsInside(node)) {\n                return null;\n              }\n\n              const argument = node.arguments[0];\n\n              if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {\n                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n              }\n\n              return fixer.replaceText(node, sourceCode.getText(argument));\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-extra-boolean-cast.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","fixable","messages","unexpectedCall","unexpectedNegation","create","context","sourceCode","getSourceCode","BOOLEAN_NODE_TYPES","isInBooleanContext","node","parent","indexOf","test","operator","hasCommentsInside","Boolean","getCommentsInside","length","UnaryExpression","ancestors","getAncestors","pop","grandparent","callee","name","report","messageId","fix","fixer","prefix","tokenBefore","getTokenBefore","firstReplacementToken","getFirstToken","argument","range","canTokensBeAdjacent","replaceText","getText","CallExpression","arguments","replacement","getPrecedence"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedCall: \"Redundant Boolean call.\",\n            unexpectedNegation: \"Redundant double negation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         * @param {ASTNode} node The node\n         * @param {ASTNode} parent Its parent\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node, parent) {\n            return (\n                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&\n                    node === parent.test) ||\n\n                // !<bool>\n                (parent.type === \"UnaryExpression\" &&\n                    parent.operator === \"!\")\n            );\n        }\n\n        /**\n         * Check if a node has comments inside.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if it has comments inside.\n         */\n        function hasCommentsInside(node) {\n            return Boolean(sourceCode.getCommentsInside(node).length);\n        }\n\n        return {\n            UnaryExpression(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                        parent.type !== \"UnaryExpression\" ||\n                        parent.operator !== \"!\") {\n                    return;\n                }\n\n                if (isInBooleanContext(parent, grandparent) ||\n\n                    // Boolean(<bool>) and new Boolean(<bool>)\n                    ((grandparent.type === \"CallExpression\" || grandparent.type === \"NewExpression\") &&\n                        grandparent.callee.type === \"Identifier\" &&\n                        grandparent.callee.name === \"Boolean\")\n                ) {\n                    context.report({\n                        node: parent,\n                        messageId: \"unexpectedNegation\",\n                        fix: fixer => {\n                            if (hasCommentsInside(parent)) {\n                                return null;\n                            }\n\n                            let prefix = \"\";\n                            const tokenBefore = sourceCode.getTokenBefore(parent);\n                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n                            if (tokenBefore && tokenBefore.range[1] === parent.range[0] &&\n                                    !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                                prefix = \" \";\n                            }\n\n                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n                        }\n                    });\n                }\n            },\n            CallExpression(node) {\n                const parent = node.parent;\n\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInBooleanContext(node, parent)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedCall\",\n                        fix: fixer => {\n                            if (!node.arguments.length) {\n                                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n\n                                    // !Boolean() -> true\n\n                                    if (hasCommentsInside(parent)) {\n                                        return null;\n                                    }\n\n                                    const replacement = \"true\";\n                                    let prefix = \"\";\n                                    const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                                    if (tokenBefore && tokenBefore.range[1] === parent.range[0] &&\n                                            !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                                        prefix = \" \";\n                                    }\n\n                                    return fixer.replaceText(parent, prefix + replacement);\n                                }\n\n                                // Boolean() -> false\n                                if (hasCommentsInside(node)) {\n                                    return null;\n                                }\n                                return fixer.replaceText(node, \"false\");\n                            }\n\n                            if (node.arguments.length > 1 || node.arguments[0].type === \"SpreadElement\" ||\n                                    hasCommentsInside(node)) {\n                                return null;\n                            }\n\n                            const argument = node.arguments[0];\n\n                            if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {\n                                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                            }\n                            return fixer.replaceText(node, sourceCode.getText(argument));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}