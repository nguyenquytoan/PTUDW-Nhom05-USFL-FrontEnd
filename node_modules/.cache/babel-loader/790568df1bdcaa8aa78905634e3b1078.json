{"ast":null,"code":"'use strict';\n\nexports.type = 'perItem';\nexports.active = true;\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  makeArcs: {\n    threshold: 2.5,\n    // coefficient of rounding error\n    tolerance: 0.5 // percentage of radius\n\n  },\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true,\n  noSpaceAfterFlags: true,\n  forceAbsolutePath: false\n};\n\nvar pathElems = require('./_collections.js').pathElems,\n    path2js = require('./_path.js').path2js,\n    js2path = require('./_path.js').js2path,\n    applyTransforms = require('./_path.js').applyTransforms,\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    roundData,\n    precision,\n    error,\n    arcThreshold,\n    arcTolerance,\n    hasMarkerMid,\n    hasStrokeLinecap;\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see http://www.w3.org/TR/SVG/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\n\nexports.fn = function (item, params) {\n  if (item.isElem(pathElems) && item.hasAttr('d')) {\n    precision = params.floatPrecision;\n    error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;\n    roundData = precision > 0 && precision < 20 ? strongRound : round;\n\n    if (params.makeArcs) {\n      arcThreshold = params.makeArcs.threshold;\n      arcTolerance = params.makeArcs.tolerance;\n    }\n\n    hasMarkerMid = item.hasAttr('marker-mid');\n    var stroke = item.computedAttr('stroke'),\n        strokeLinecap = item.computedAttr('stroke');\n    hasStrokeLinecap = stroke && stroke != 'none' && strokeLinecap && strokeLinecap != 'butt';\n    var data = path2js(item); // TODO: get rid of functions returns\n\n    if (data.length) {\n      convertToRelative(data);\n\n      if (params.applyTransforms) {\n        data = applyTransforms(item, data, params);\n      }\n\n      data = filters(data, params);\n\n      if (params.utilizeAbsolute) {\n        data = convertToMixed(data, params);\n      }\n\n      js2path(item, data, params);\n    }\n  }\n};\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nfunction convertToRelative(path) {\n  var point = [0, 0],\n      subpathPoint = [0, 0],\n      baseItem;\n  path.forEach(function (item, index) {\n    var instruction = item.instruction,\n        data = item.data; // data !== !z\n\n    if (data) {\n      // already relative\n      // recalculate current point\n      if ('mcslqta'.indexOf(instruction) > -1) {\n        point[0] += data[data.length - 2];\n        point[1] += data[data.length - 1];\n\n        if (instruction === 'm') {\n          subpathPoint[0] = point[0];\n          subpathPoint[1] = point[1];\n          baseItem = item;\n        }\n      } else if (instruction === 'h') {\n        point[0] += data[0];\n      } else if (instruction === 'v') {\n        point[1] += data[0];\n      } // convert absolute path data coordinates to relative\n      // if \"M\" was not transformed from \"m\"\n      // M → m\n\n\n      if (instruction === 'M') {\n        if (index > 0) instruction = 'm';\n        data[0] -= point[0];\n        data[1] -= point[1];\n        subpathPoint[0] = point[0] += data[0];\n        subpathPoint[1] = point[1] += data[1];\n        baseItem = item;\n      } // L → l\n      // T → t\n      else if ('LT'.indexOf(instruction) > -1) {\n          instruction = instruction.toLowerCase(); // x y\n          // 0 1\n\n          data[0] -= point[0];\n          data[1] -= point[1];\n          point[0] += data[0];\n          point[1] += data[1]; // C → c\n        } else if (instruction === 'C') {\n          instruction = 'c'; // x1 y1 x2 y2 x y\n          // 0  1  2  3  4 5\n\n          data[0] -= point[0];\n          data[1] -= point[1];\n          data[2] -= point[0];\n          data[3] -= point[1];\n          data[4] -= point[0];\n          data[5] -= point[1];\n          point[0] += data[4];\n          point[1] += data[5]; // S → s\n          // Q → q\n        } else if ('SQ'.indexOf(instruction) > -1) {\n          instruction = instruction.toLowerCase(); // x1 y1 x y\n          // 0  1  2 3\n\n          data[0] -= point[0];\n          data[1] -= point[1];\n          data[2] -= point[0];\n          data[3] -= point[1];\n          point[0] += data[2];\n          point[1] += data[3]; // A → a\n        } else if (instruction === 'A') {\n          instruction = 'a'; // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n          // 0  1  2               3              4          5 6\n\n          data[5] -= point[0];\n          data[6] -= point[1];\n          point[0] += data[5];\n          point[1] += data[6]; // H → h\n        } else if (instruction === 'H') {\n          instruction = 'h';\n          data[0] -= point[0];\n          point[0] += data[0]; // V → v\n        } else if (instruction === 'V') {\n          instruction = 'v';\n          data[0] -= point[1];\n          point[1] += data[0];\n        }\n\n      item.instruction = instruction;\n      item.data = data; // store absolute coordinates for later use\n\n      item.coords = point.slice(-2);\n    } // !data === z, reset current point\n    else if (instruction == 'z') {\n        if (baseItem) {\n          item.coords = baseItem.coords;\n        }\n\n        point[0] = subpathPoint[0];\n        point[1] = subpathPoint[1];\n      }\n\n    item.base = index > 0 ? path[index - 1].coords : [0, 0];\n  });\n  return path;\n}\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nfunction filters(path, params) {\n  var stringify = data2Path.bind(null, params),\n      relSubpoint = [0, 0],\n      pathBase = [0, 0],\n      prev = {};\n  path = path.filter(function (item, index, path) {\n    var instruction = item.instruction,\n        data = item.data,\n        next = path[index + 1];\n\n    if (data) {\n      var sdata = data,\n          circle;\n\n      if (instruction === 's') {\n        sdata = [0, 0].concat(data);\n\n        if ('cs'.indexOf(prev.instruction) > -1) {\n          var pdata = prev.data,\n              n = pdata.length; // (-x, -y) of the prev tangent point relative to the current point\n\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      } // convert curves to arcs if possible\n\n\n      if (params.makeArcs && (instruction == 'c' || instruction == 's') && isConvex(sdata) && (circle = findCircle(sdata))) {\n        var r = roundData([circle.radius])[0],\n            angle = findArcAngle(sdata, circle),\n            sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n            arc = {\n          instruction: 'a',\n          data: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n          coords: item.coords.slice(),\n          base: item.base\n        },\n            output = [arc],\n            // relative coordinates to adjust the found circle\n        relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],\n            relCircle = {\n          center: relCenter,\n          radius: circle.radius\n        },\n            arcCurves = [item],\n            hasPrev = 0,\n            suffix = '',\n            nextLonghand;\n\n        if (prev.instruction == 'c' && isConvex(prev.data) && isArcPrev(prev.data, circle) || prev.instruction == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)) {\n          arcCurves.unshift(prev);\n          arc.base = prev.base;\n          arc.data[5] = arc.coords[0] - arc.base[0];\n          arc.data[6] = arc.coords[1] - arc.base[1];\n          var prevData = prev.instruction == 'a' ? prev.sdata : prev.data;\n          var prevAngle = findArcAngle(prevData, {\n            center: [prevData[4] + circle.center[0], prevData[5] + circle.center[1]],\n            radius: circle.radius\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.data[3] = 1;\n          hasPrev = 1;\n        } // check if next curves are fitting the arc\n\n\n        for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.instruction);) {\n          var nextData = next.data;\n\n          if (next.instruction == 's') {\n            nextLonghand = makeLonghand({\n              instruction: 's',\n              data: next.data.slice()\n            }, path[j - 1].data);\n            nextData = nextLonghand.data;\n            nextLonghand.data = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n\n            if (angle > Math.PI) arc.data[3] = 1;\n            arcCurves.push(next);\n\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              arc.coords = next.coords;\n              arc.data[5] = arc.coords[0] - arc.base[0];\n              arc.data[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.data[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.data[6] = 2 * (relCircle.center[1] - nextData[5]);\n              arc.coords = [arc.base[0] + arc.data[5], arc.base[1] + arc.data[6]];\n              arc = {\n                instruction: 'a',\n                data: [r, r, 0, 0, sweep, next.coords[0] - arc.coords[0], next.coords[1] - arc.coords[1]],\n                coords: next.coords,\n                base: arc.coords\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].instruction == 's') {\n            makeLonghand(path[j], path[j - 1].data);\n          }\n\n          if (hasPrev) {\n            var prevArc = output.shift();\n            roundData(prevArc.data);\n            relSubpoint[0] += prevArc.data[5] - prev.data[prev.data.length - 2];\n            relSubpoint[1] += prevArc.data[6] - prev.data[prev.data.length - 1];\n            prev.instruction = 'a';\n            prev.data = prevArc.data;\n            item.base = prev.coords = prevArc.coords;\n          }\n\n          arc = output.shift();\n\n          if (arcCurves.length == 1) {\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(path, [index + 1, arcCurves.length - 1 - hasPrev].concat(output));\n          }\n\n          if (!arc) return false;\n          instruction = 'a';\n          data = arc.data;\n          item.coords = arc.coords;\n        }\n      } // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n\n\n      if (precision !== false) {\n        if ('mltqsc'.indexOf(instruction) > -1) {\n          for (var i = data.length; i--;) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (instruction == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (instruction == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (instruction == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n\n        roundData(data);\n        if (instruction == 'h') relSubpoint[0] += data[0];else if (instruction == 'v') relSubpoint[1] += data[0];else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (instruction.toLowerCase() == 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      } // convert straight curves into lines segments\n\n\n      if (params.straightCurves) {\n        if (instruction === 'c' && isCurveStraightLine(data) || instruction === 's' && isCurveStraightLine(sdata)) {\n          if (next && next.instruction == 's') makeLonghand(next, data); // fix up next curve\n\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 'q' && isCurveStraightLine(data)) {\n          if (next && next.instruction == 't') makeLonghand(next, data); // fix up next curve\n\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 't' && prev.instruction !== 'q' && prev.instruction !== 't') {\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 'a' && (data[0] === 0 || data[1] === 0)) {\n          instruction = 'l';\n          data = data.slice(-2);\n        }\n      } // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n\n\n      if (params.lineShorthands && instruction === 'l') {\n        if (data[1] === 0) {\n          instruction = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          instruction = 'v';\n          data.shift();\n        }\n      } // collapse repeated commands\n      // h 20 h 30 -> h 50\n\n\n      if (params.collapseRepeated && !hasMarkerMid && 'mhv'.indexOf(instruction) > -1 && prev.instruction && instruction == prev.instruction.toLowerCase() && (instruction != 'h' && instruction != 'v' || prev.data[0] >= 0 == item.data[0] >= 0)) {\n        prev.data[0] += data[0];\n\n        if (instruction != 'h' && instruction != 'v') {\n          prev.data[1] += data[1];\n        }\n\n        prev.coords = item.coords;\n        path[index] = prev;\n        return false;\n      } // convert curves into smooth shorthands\n\n\n      if (params.curveSmoothShorthands && prev.instruction) {\n        // curveto\n        if (instruction === 'c') {\n          // c + c → c + s\n          if (prev.instruction === 'c' && data[0] === -(prev.data[2] - prev.data[4]) && data[1] === -(prev.data[3] - prev.data[5])) {\n            instruction = 's';\n            data = data.slice(2);\n          } // s + c → s + s\n          else if (prev.instruction === 's' && data[0] === -(prev.data[0] - prev.data[2]) && data[1] === -(prev.data[1] - prev.data[3])) {\n              instruction = 's';\n              data = data.slice(2);\n            } // [^cs] + c → [^cs] + s\n            else if ('cs'.indexOf(prev.instruction) === -1 && data[0] === 0 && data[1] === 0) {\n                instruction = 's';\n                data = data.slice(2);\n              }\n        } // quadratic Bézier curveto\n        else if (instruction === 'q') {\n            // q + q → q + t\n            if (prev.instruction === 'q' && data[0] === prev.data[2] - prev.data[0] && data[1] === prev.data[3] - prev.data[1]) {\n              instruction = 't';\n              data = data.slice(2);\n            } // t + q → t + t\n            else if (prev.instruction === 't' && data[2] === prev.data[0] && data[3] === prev.data[1]) {\n                instruction = 't';\n                data = data.slice(2);\n              }\n          }\n      } // remove useless non-first path segments\n\n\n      if (params.removeUseless && !hasStrokeLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if ('lhvqtcs'.indexOf(instruction) > -1 && data.every(function (i) {\n          return i === 0;\n        })) {\n          path[index] = prev;\n          return false;\n        } // a 25,25 -30 0,1 0,0\n\n\n        if (instruction === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.instruction = instruction;\n      item.data = data;\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.instruction == 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n  return path;\n}\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n\n    if (!item.data) {\n      prev = item;\n      return true;\n    }\n\n    var instruction = item.instruction,\n        data = item.data,\n        adata = data && data.slice(0);\n\n    if ('mltqsc'.indexOf(instruction) > -1) {\n      for (var i = adata.length; i--;) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (instruction == 'h') {\n      adata[0] += item.base[0];\n    } else if (instruction == 'v') {\n      adata[0] += item.base[1];\n    } else if (instruction == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n    var absoluteDataStr = cleanupOutData(adata, params),\n        relativeDataStr = cleanupOutData(data, params); // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous instruction.\n    // l20 30-10-50 instead of l20 30L20 30\n\n    if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && instruction == prev.instruction && prev.instruction.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || /^0\\./.test(data[0]) && prev.data[prev.data.length - 1] % 1))) {\n      item.instruction = instruction.toUpperCase();\n      item.data = adata;\n    }\n\n    prev = item;\n    return true;\n  });\n  return path;\n}\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction isConvex(data) {\n  var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);\n  return center && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];\n}\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\n\n\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3],\n      // y1 - y2\n  b1 = coords[2] - coords[0],\n      // x2 - x1\n  c1 = coords[0] * coords[3] - coords[2] * coords[1],\n      // x1 * y2 - x2 * y1\n  // Next line equation parameters\n  a2 = coords[5] - coords[7],\n      // y1 - y2\n  b2 = coords[6] - coords[4],\n      // x2 - x1\n  c2 = coords[4] * coords[7] - coords[5] * coords[6],\n      // x1 * y2 - x2 * y1\n  denom = a1 * b2 - a2 * b1;\n  if (!denom) return; // parallel lines havn't an intersection\n\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n\n  if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {\n    return cross;\n  }\n}\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0;) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n}\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction round(data) {\n  for (var i = data.length; i-- > 0;) {\n    data[i] = Math.round(data[i]);\n  }\n\n  return data;\n}\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n      a = -data[i + 1],\n      // y1 − y2 (y1 = 0)\n  b = data[i],\n      // x2 − x1 (x1 = 0)\n  d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error) return false;\n  }\n\n  return true;\n}\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\n\nfunction makeLonghand(item, data) {\n  switch (item.instruction) {\n    case 's':\n      item.instruction = 'c';\n      break;\n\n    case 't':\n      item.instruction = 'q';\n      break;\n  }\n\n  item.data.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);\n  return item;\n}\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n      cubT = sqrT * t,\n      mt = 1 - t,\n      sqrMt = mt * mt;\n  return [3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4], 3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]];\n}\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n      m1 = [midPoint[0] / 2, midPoint[1] / 2],\n      m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n      center = getIntersection([m1[0], m1[1], m1[0] + m1[1], m1[1] - m1[0], m2[0], m2[1], m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])]),\n      radius = center && getDistance([0, 0], center),\n      tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);\n  if (center && radius < 1e15 && [1 / 4, 3 / 4].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;\n  })) return {\n    center: center,\n    radius: radius\n  };\n}\n/**\n * Checks if a curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;\n  });\n}\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius\n  });\n}\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n      y1 = -relCircle.center[1],\n      x2 = curve[4] - relCircle.center[0],\n      y2 = curve[5] - relCircle.center[1];\n  return Math.acos((x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)));\n}\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n\n    if (item.data) {\n      strData = cleanupOutData(roundData(item.data.slice()), params);\n    }\n\n    return pathString + item.instruction + strData;\n  }, '');\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/svgo/plugins/convertPathData.js"],"names":["exports","type","active","description","params","applyTransforms","applyTransformsStroked","makeArcs","threshold","tolerance","straightCurves","lineShorthands","curveSmoothShorthands","floatPrecision","transformPrecision","removeUseless","collapseRepeated","utilizeAbsolute","leadingZero","negativeExtraSpace","noSpaceAfterFlags","forceAbsolutePath","pathElems","require","path2js","js2path","cleanupOutData","roundData","precision","error","arcThreshold","arcTolerance","hasMarkerMid","hasStrokeLinecap","fn","item","isElem","hasAttr","Math","pow","toFixed","strongRound","round","stroke","computedAttr","strokeLinecap","data","length","convertToRelative","filters","convertToMixed","path","point","subpathPoint","baseItem","forEach","index","instruction","indexOf","toLowerCase","coords","slice","base","stringify","data2Path","bind","relSubpoint","pathBase","prev","filter","next","sdata","circle","concat","pdata","n","isConvex","findCircle","r","radius","angle","findArcAngle","sweep","arc","output","relCenter","center","relCircle","arcCurves","hasPrev","suffix","nextLonghand","isArcPrev","unshift","prevData","prevAngle","PI","j","nextData","makeLonghand","isArc","push","prevArc","shift","splice","apply","i","isCurveStraightLine","pop","every","adata","absoluteDataStr","relativeDataStr","charCodeAt","test","toUpperCase","getIntersection","a1","b1","c1","a2","b2","c2","denom","cross","isNaN","isFinite","rounded","abs","a","b","d","sqrt","getDistance","point1","point2","hypot","getCubicBezierPoint","curve","t","sqrT","cubT","mt","sqrMt","midPoint","m1","m2","min","x1","y1","x2","y2","acos","pathData","reduce","pathString","strData"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.type = 'perItem';\n\nexports.active = true;\n\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\n\nexports.params = {\n    applyTransforms: true,\n    applyTransformsStroked: true,\n    makeArcs: {\n        threshold: 2.5, // coefficient of rounding error\n        tolerance: 0.5  // percentage of radius\n    },\n    straightCurves: true,\n    lineShorthands: true,\n    curveSmoothShorthands: true,\n    floatPrecision: 3,\n    transformPrecision: 5,\n    removeUseless: true,\n    collapseRepeated: true,\n    utilizeAbsolute: true,\n    leadingZero: true,\n    negativeExtraSpace: true,\n    noSpaceAfterFlags: true,\n    forceAbsolutePath: false\n};\n\nvar pathElems = require('./_collections.js').pathElems,\n    path2js = require('./_path.js').path2js,\n    js2path = require('./_path.js').js2path,\n    applyTransforms = require('./_path.js').applyTransforms,\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    roundData,\n    precision,\n    error,\n    arcThreshold,\n    arcTolerance,\n    hasMarkerMid,\n    hasStrokeLinecap;\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see http://www.w3.org/TR/SVG/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\nexports.fn = function(item, params) {\n\n    if (item.isElem(pathElems) && item.hasAttr('d')) {\n\n        precision = params.floatPrecision;\n        error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;\n        roundData = precision > 0 && precision < 20 ? strongRound : round;\n        if (params.makeArcs) {\n            arcThreshold = params.makeArcs.threshold;\n            arcTolerance = params.makeArcs.tolerance;\n        }\n        hasMarkerMid = item.hasAttr('marker-mid');\n\n        var stroke = item.computedAttr('stroke'),\n            strokeLinecap = item.computedAttr('stroke');\n        hasStrokeLinecap = stroke && stroke != 'none' && strokeLinecap && strokeLinecap != 'butt';\n\n        var data = path2js(item);\n\n        // TODO: get rid of functions returns\n        if (data.length) {\n            convertToRelative(data);\n\n            if (params.applyTransforms) {\n                data = applyTransforms(item, data, params);\n            }\n\n            data = filters(data, params);\n\n            if (params.utilizeAbsolute) {\n                data = convertToMixed(data, params);\n            }\n\n            js2path(item, data, params);\n        }\n\n    }\n\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction convertToRelative(path) {\n\n    var point = [0, 0],\n        subpathPoint = [0, 0],\n        baseItem;\n\n    path.forEach(function(item, index) {\n\n        var instruction = item.instruction,\n            data = item.data;\n\n        // data !== !z\n        if (data) {\n\n            // already relative\n            // recalculate current point\n            if ('mcslqta'.indexOf(instruction) > -1) {\n\n                point[0] += data[data.length - 2];\n                point[1] += data[data.length - 1];\n\n                if (instruction === 'm') {\n                    subpathPoint[0] = point[0];\n                    subpathPoint[1] = point[1];\n                    baseItem = item;\n                }\n\n            } else if (instruction === 'h') {\n\n                point[0] += data[0];\n\n            } else if (instruction === 'v') {\n\n                point[1] += data[0];\n\n            }\n\n            // convert absolute path data coordinates to relative\n            // if \"M\" was not transformed from \"m\"\n            // M → m\n            if (instruction === 'M') {\n\n                if (index > 0) instruction = 'm';\n\n                data[0] -= point[0];\n                data[1] -= point[1];\n\n                subpathPoint[0] = point[0] += data[0];\n                subpathPoint[1] = point[1] += data[1];\n\n                baseItem = item;\n\n            }\n\n            // L → l\n            // T → t\n            else if ('LT'.indexOf(instruction) > -1) {\n\n                instruction = instruction.toLowerCase();\n\n                // x y\n                // 0 1\n                data[0] -= point[0];\n                data[1] -= point[1];\n\n                point[0] += data[0];\n                point[1] += data[1];\n\n            // C → c\n            } else if (instruction === 'C') {\n\n                instruction = 'c';\n\n                // x1 y1 x2 y2 x y\n                // 0  1  2  3  4 5\n                data[0] -= point[0];\n                data[1] -= point[1];\n                data[2] -= point[0];\n                data[3] -= point[1];\n                data[4] -= point[0];\n                data[5] -= point[1];\n\n                point[0] += data[4];\n                point[1] += data[5];\n\n            // S → s\n            // Q → q\n            } else if ('SQ'.indexOf(instruction) > -1) {\n\n                instruction = instruction.toLowerCase();\n\n                // x1 y1 x y\n                // 0  1  2 3\n                data[0] -= point[0];\n                data[1] -= point[1];\n                data[2] -= point[0];\n                data[3] -= point[1];\n\n                point[0] += data[2];\n                point[1] += data[3];\n\n            // A → a\n            } else if (instruction === 'A') {\n\n                instruction = 'a';\n\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                // 0  1  2               3              4          5 6\n                data[5] -= point[0];\n                data[6] -= point[1];\n\n                point[0] += data[5];\n                point[1] += data[6];\n\n            // H → h\n            } else if (instruction === 'H') {\n\n                instruction = 'h';\n\n                data[0] -= point[0];\n\n                point[0] += data[0];\n\n            // V → v\n            } else if (instruction === 'V') {\n\n                instruction = 'v';\n\n                data[0] -= point[1];\n\n                point[1] += data[0];\n\n            }\n\n            item.instruction = instruction;\n            item.data = data;\n\n            // store absolute coordinates for later use\n            item.coords = point.slice(-2);\n\n        }\n\n        // !data === z, reset current point\n        else if (instruction == 'z') {\n            if (baseItem) {\n                item.coords = baseItem.coords;\n            }\n            point[0] = subpathPoint[0];\n            point[1] = subpathPoint[1];\n        }\n\n        item.base = index > 0 ? path[index - 1].coords : [0, 0];\n\n    });\n\n    return path;\n\n}\n\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction filters(path, params) {\n\n    var stringify = data2Path.bind(null, params),\n        relSubpoint = [0, 0],\n        pathBase = [0, 0],\n        prev = {};\n\n    path = path.filter(function(item, index, path) {\n\n        var instruction = item.instruction,\n            data = item.data,\n            next = path[index + 1];\n\n        if (data) {\n\n            var sdata = data,\n                circle;\n\n            if (instruction === 's') {\n                sdata = [0, 0].concat(data);\n\n                if ('cs'.indexOf(prev.instruction) > -1) {\n                    var pdata = prev.data,\n                        n = pdata.length;\n\n                    // (-x, -y) of the prev tangent point relative to the current point\n                    sdata[0] = pdata[n - 2] - pdata[n - 4];\n                    sdata[1] = pdata[n - 1] - pdata[n - 3];\n                }\n\n            }\n\n            // convert curves to arcs if possible\n            if (\n                params.makeArcs &&\n                (instruction == 'c' || instruction == 's') &&\n                isConvex(sdata) &&\n                (circle = findCircle(sdata))\n            ) {\n                var r = roundData([circle.radius])[0],\n                    angle = findArcAngle(sdata, circle),\n                    sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n                    arc = {\n                        instruction: 'a',\n                        data: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n                        coords: item.coords.slice(),\n                        base: item.base\n                    },\n                    output = [arc],\n                    // relative coordinates to adjust the found circle\n                    relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],\n                    relCircle = { center: relCenter, radius: circle.radius },\n                    arcCurves = [item],\n                    hasPrev = 0,\n                    suffix = '',\n                    nextLonghand;\n\n                if (\n                    prev.instruction == 'c' && isConvex(prev.data) && isArcPrev(prev.data, circle) ||\n                    prev.instruction == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)\n                ) {\n                    arcCurves.unshift(prev);\n                    arc.base = prev.base;\n                    arc.data[5] = arc.coords[0] - arc.base[0];\n                    arc.data[6] = arc.coords[1] - arc.base[1];\n                    var prevData = prev.instruction == 'a' ? prev.sdata : prev.data;\n                    var prevAngle = findArcAngle(prevData,\n                        {\n                            center: [prevData[4] + circle.center[0], prevData[5] + circle.center[1]],\n                            radius: circle.radius\n                        }\n                    );\n                    angle += prevAngle;\n                    if (angle > Math.PI) arc.data[3] = 1;\n                    hasPrev = 1;\n                }\n\n                // check if next curves are fitting the arc\n                for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.instruction);) {\n                    var nextData = next.data;\n                    if (next.instruction == 's') {\n                        nextLonghand = makeLonghand({instruction: 's', data: next.data.slice() },\n                            path[j - 1].data);\n                        nextData = nextLonghand.data;\n                        nextLonghand.data = nextData.slice(0, 2);\n                        suffix = stringify([nextLonghand]);\n                    }\n                    if (isConvex(nextData) && isArc(nextData, relCircle)) {\n                        angle += findArcAngle(nextData, relCircle);\n                        if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n                        if (angle > Math.PI) arc.data[3] = 1;\n                        arcCurves.push(next);\n                        if (2 * Math.PI - angle > 1e-3) { // less than 360°\n                            arc.coords = next.coords;\n                            arc.data[5] = arc.coords[0] - arc.base[0];\n                            arc.data[6] = arc.coords[1] - arc.base[1];\n                        } else {\n                            // full circle, make a half-circle arc and add a second one\n                            arc.data[5] = 2 * (relCircle.center[0] - nextData[4]);\n                            arc.data[6] = 2 * (relCircle.center[1] - nextData[5]);\n                            arc.coords = [arc.base[0] + arc.data[5], arc.base[1] + arc.data[6]];\n                            arc = {\n                                instruction: 'a',\n                                data: [r, r, 0, 0, sweep,\n                                    next.coords[0] - arc.coords[0], next.coords[1] - arc.coords[1]],\n                                coords: next.coords,\n                                base: arc.coords\n                            };\n                            output.push(arc);\n                            j++;\n                            break;\n                        }\n                        relCenter[0] -= nextData[4];\n                        relCenter[1] -= nextData[5];\n                    } else break;\n                }\n\n                if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n                    if (path[j] && path[j].instruction == 's') {\n                        makeLonghand(path[j], path[j - 1].data);\n                    }\n                    if (hasPrev) {\n                        var prevArc = output.shift();\n                        roundData(prevArc.data);\n                        relSubpoint[0] += prevArc.data[5] - prev.data[prev.data.length - 2];\n                        relSubpoint[1] += prevArc.data[6] - prev.data[prev.data.length - 1];\n                        prev.instruction = 'a';\n                        prev.data = prevArc.data;\n                        item.base = prev.coords = prevArc.coords;\n                    }\n                    arc = output.shift();\n                    if (arcCurves.length == 1) {\n                        item.sdata = sdata.slice(); // preserve curve data for future checks\n                    } else if (arcCurves.length - 1 - hasPrev > 0) {\n                        // filter out consumed next items\n                        path.splice.apply(path, [index + 1, arcCurves.length - 1 - hasPrev].concat(output));\n                    }\n                    if (!arc) return false;\n                    instruction = 'a';\n                    data = arc.data;\n                    item.coords = arc.coords;\n                }\n            }\n\n            // Rounding relative coordinates, taking in account accummulating error\n            // to get closer to absolute coordinates. Sum of rounded value remains same:\n            // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n            if (precision !== false) {\n                if ('mltqsc'.indexOf(instruction) > -1) {\n                    for (var i = data.length; i--;) {\n                        data[i] += item.base[i % 2] - relSubpoint[i % 2];\n                    }\n                } else if (instruction == 'h') {\n                    data[0] += item.base[0] - relSubpoint[0];\n                } else if (instruction == 'v') {\n                    data[0] += item.base[1] - relSubpoint[1];\n                } else if (instruction == 'a') {\n                    data[5] += item.base[0] - relSubpoint[0];\n                    data[6] += item.base[1] - relSubpoint[1];\n                }\n                roundData(data);\n\n                if      (instruction == 'h') relSubpoint[0] += data[0];\n                else if (instruction == 'v') relSubpoint[1] += data[0];\n                else {\n                    relSubpoint[0] += data[data.length - 2];\n                    relSubpoint[1] += data[data.length - 1];\n                }\n                roundData(relSubpoint);\n\n                if (instruction.toLowerCase() == 'm') {\n                    pathBase[0] = relSubpoint[0];\n                    pathBase[1] = relSubpoint[1];\n                }\n            }\n\n            // convert straight curves into lines segments\n            if (params.straightCurves) {\n\n                if (\n                    instruction === 'c' &&\n                    isCurveStraightLine(data) ||\n                    instruction === 's' &&\n                    isCurveStraightLine(sdata)\n                ) {\n                    if (next && next.instruction == 's')\n                        makeLonghand(next, data); // fix up next curve\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n\n                else if (\n                    instruction === 'q' &&\n                    isCurveStraightLine(data)\n                ) {\n                    if (next && next.instruction == 't')\n                        makeLonghand(next, data); // fix up next curve\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n\n                else if (\n                    instruction === 't' &&\n                    prev.instruction !== 'q' &&\n                    prev.instruction !== 't'\n                ) {\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n\n                else if (\n                    instruction === 'a' &&\n                    (data[0] === 0 || data[1] === 0)\n                ) {\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n            }\n\n            // horizontal and vertical line shorthands\n            // l 50 0 → h 50\n            // l 0 50 → v 50\n            if (\n                params.lineShorthands &&\n                instruction === 'l'\n            ) {\n                if (data[1] === 0) {\n                    instruction = 'h';\n                    data.pop();\n                } else if (data[0] === 0) {\n                    instruction = 'v';\n                    data.shift();\n                }\n            }\n\n            // collapse repeated commands\n            // h 20 h 30 -> h 50\n            if (\n                params.collapseRepeated &&\n                !hasMarkerMid &&\n                ('mhv'.indexOf(instruction) > -1) &&\n                prev.instruction &&\n                instruction == prev.instruction.toLowerCase() &&\n                (\n                    (instruction != 'h' && instruction != 'v') ||\n                    (prev.data[0] >= 0) == (item.data[0] >= 0)\n            )) {\n                prev.data[0] += data[0];\n                if (instruction != 'h' && instruction != 'v') {\n                    prev.data[1] += data[1];\n                }\n                prev.coords = item.coords;\n                path[index] = prev;\n                return false;\n            }\n\n            // convert curves into smooth shorthands\n            if (params.curveSmoothShorthands && prev.instruction) {\n\n                // curveto\n                if (instruction === 'c') {\n\n                    // c + c → c + s\n                    if (\n                        prev.instruction === 'c' &&\n                        data[0] === -(prev.data[2] - prev.data[4]) &&\n                        data[1] === -(prev.data[3] - prev.data[5])\n                    ) {\n                        instruction = 's';\n                        data = data.slice(2);\n                    }\n\n                    // s + c → s + s\n                    else if (\n                        prev.instruction === 's' &&\n                        data[0] === -(prev.data[0] - prev.data[2]) &&\n                        data[1] === -(prev.data[1] - prev.data[3])\n                    ) {\n                        instruction = 's';\n                        data = data.slice(2);\n                    }\n\n                    // [^cs] + c → [^cs] + s\n                    else if (\n                        'cs'.indexOf(prev.instruction) === -1 &&\n                        data[0] === 0 &&\n                        data[1] === 0\n                    ) {\n                        instruction = 's';\n                        data = data.slice(2);\n                    }\n\n                }\n\n                // quadratic Bézier curveto\n                else if (instruction === 'q') {\n\n                    // q + q → q + t\n                    if (\n                        prev.instruction === 'q' &&\n                        data[0] === (prev.data[2] - prev.data[0]) &&\n                        data[1] === (prev.data[3] - prev.data[1])\n                    ) {\n                        instruction = 't';\n                        data = data.slice(2);\n                    }\n\n                    // t + q → t + t\n                    else if (\n                        prev.instruction === 't' &&\n                        data[2] === prev.data[0] &&\n                        data[3] === prev.data[1]\n                    ) {\n                        instruction = 't';\n                        data = data.slice(2);\n                    }\n\n                }\n\n            }\n\n            // remove useless non-first path segments\n            if (params.removeUseless && !hasStrokeLinecap) {\n\n                // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n                if (\n                    (\n                     'lhvqtcs'.indexOf(instruction) > -1\n                    ) &&\n                    data.every(function(i) { return i === 0; })\n                ) {\n                    path[index] = prev;\n                    return false;\n                }\n\n                // a 25,25 -30 0,1 0,0\n                if (\n                    instruction === 'a' &&\n                    data[5] === 0 &&\n                    data[6] === 0\n                ) {\n                    path[index] = prev;\n                    return false;\n                }\n\n            }\n\n            item.instruction = instruction;\n            item.data = data;\n\n            prev = item;\n\n        } else {\n\n            // z resets coordinates\n            relSubpoint[0] = pathBase[0];\n            relSubpoint[1] = pathBase[1];\n            if (prev.instruction == 'z') return false;\n            prev = item;\n\n        }\n\n        return true;\n\n    });\n\n    return path;\n\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction convertToMixed(path, params) {\n\n    var prev = path[0];\n\n    path = path.filter(function(item, index) {\n\n        if (index == 0) return true;\n        if (!item.data) {\n            prev = item;\n            return true;\n        }\n\n        var instruction = item.instruction,\n            data = item.data,\n            adata = data && data.slice(0);\n\n        if ('mltqsc'.indexOf(instruction) > -1) {\n            for (var i = adata.length; i--;) {\n                adata[i] += item.base[i % 2];\n            }\n        } else if (instruction == 'h') {\n                adata[0] += item.base[0];\n        } else if (instruction == 'v') {\n                adata[0] += item.base[1];\n        } else if (instruction == 'a') {\n                adata[5] += item.base[0];\n                adata[6] += item.base[1];\n        }\n\n        roundData(adata);\n\n        var absoluteDataStr = cleanupOutData(adata, params),\n            relativeDataStr = cleanupOutData(data, params);\n\n        // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n        // v-20 -> V0\n        // Don't convert if it fits following previous instruction.\n        // l20 30-10-50 instead of l20 30L20 30\n        if (\n            params.forceAbsolutePath || (\n            absoluteDataStr.length < relativeDataStr.length &&\n            !(\n                params.negativeExtraSpace &&\n                instruction == prev.instruction &&\n                prev.instruction.charCodeAt(0) > 96 &&\n                absoluteDataStr.length == relativeDataStr.length - 1 &&\n                (data[0] < 0 || /^0\\./.test(data[0]) && prev.data[prev.data.length - 1] % 1)\n            ))\n        ) {\n            item.instruction = instruction.toUpperCase();\n            item.data = adata;\n        }\n\n        prev = item;\n\n        return true;\n\n    });\n\n    return path;\n\n}\n\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction isConvex(data) {\n\n    var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);\n\n    return center &&\n        (data[2] < center[0] == center[0] < 0) &&\n        (data[3] < center[1] == center[1] < 0) &&\n        (data[4] < center[0] == center[0] < data[0]) &&\n        (data[5] < center[1] == center[1] < data[1]);\n\n}\n\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\nfunction getIntersection(coords) {\n\n        // Prev line equation parameters.\n    var a1 = coords[1] - coords[3], // y1 - y2\n        b1 = coords[2] - coords[0], // x2 - x1\n        c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1\n\n        // Next line equation parameters\n        a2 = coords[5] - coords[7], // y1 - y2\n        b2 = coords[6] - coords[4], // x2 - x1\n        c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1\n        denom = (a1 * b2 - a2 * b1);\n\n    if (!denom) return; // parallel lines havn't an intersection\n\n    var cross = [\n            (b1 * c2 - b2 * c1) / denom,\n            (a1 * c2 - a2 * c1) / -denom\n        ];\n    if (\n        !isNaN(cross[0]) && !isNaN(cross[1]) &&\n        isFinite(cross[0]) && isFinite(cross[1])\n    ) {\n        return cross;\n    }\n\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\nfunction strongRound(data) {\n    for (var i = data.length; i-- > 0;) {\n        if (data[i].toFixed(precision) != data[i]) {\n            var rounded = +data[i].toFixed(precision - 1);\n            data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ?\n                +data[i].toFixed(precision) :\n                rounded;\n        }\n    }\n    return data;\n}\n\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\nfunction round(data) {\n    for (var i = data.length; i-- > 0;) {\n        data[i] = Math.round(data[i]);\n    }\n    return data;\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\nfunction isCurveStraightLine(data) {\n\n    // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n    var i = data.length - 2,\n        a = -data[i + 1], // y1 − y2 (y1 = 0)\n        b = data[i],      // x2 − x1 (x1 = 0)\n        d = 1 / (a * a + b * b); // same part for all points\n\n    if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n\n    // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n    while ((i -= 2) >= 0) {\n        if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)\n            return false;\n    }\n\n    return true;\n\n}\n\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\nfunction makeLonghand(item, data) {\n    switch (item.instruction) {\n        case 's': item.instruction = 'c'; break;\n        case 't': item.instruction = 'q'; break;\n    }\n    item.data.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);\n    return item;\n}\n\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\nfunction getDistance(point1, point2) {\n    return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\nfunction getCubicBezierPoint(curve, t) {\n    var sqrT = t * t,\n        cubT = sqrT * t,\n        mt = 1 - t,\n        sqrMt = mt * mt;\n\n    return [\n        3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],\n        3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]\n    ];\n}\n\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\nfunction findCircle(curve) {\n    var midPoint = getCubicBezierPoint(curve, 1/2),\n        m1 = [midPoint[0] / 2, midPoint[1] / 2],\n        m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n        center = getIntersection([\n            m1[0], m1[1],\n            m1[0] + m1[1], m1[1] - m1[0],\n            m2[0], m2[1],\n            m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])\n        ]),\n        radius = center && getDistance([0, 0], center),\n        tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);\n\n    if (center && radius < 1e15 &&\n        [1/4, 3/4].every(function(point) {\n        return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;\n    }))\n        return { center: center, radius: radius};\n}\n\n/**\n * Checks if a curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\nfunction isArc(curve, circle) {\n    var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);\n\n    return [0, 1/4, 1/2, 3/4, 1].every(function(point) {\n        return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;\n    });\n}\n\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\nfunction isArcPrev(curve, circle) {\n    return isArc(curve, {\n        center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n        radius: circle.radius\n    });\n}\n\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\nfunction findArcAngle(curve, relCircle) {\n    var x1 = -relCircle.center[0],\n        y1 = -relCircle.center[1],\n        x2 = curve[4] - relCircle.center[0],\n        y2 = curve[5] - relCircle.center[1];\n\n    return Math.acos(\n            (x1 * x2 + y1 * y2) /\n            Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n        );\n}\n\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\nfunction data2Path(params, pathData) {\n    return pathData.reduce(function(pathString, item) {\n        var strData = '';\n        if (item.data) {\n            strData = cleanupOutData(roundData(item.data.slice()), params);\n        }\n        return pathString + item.instruction + strData;\n    }, '');\n}\n"]},"metadata":{},"sourceType":"script"}