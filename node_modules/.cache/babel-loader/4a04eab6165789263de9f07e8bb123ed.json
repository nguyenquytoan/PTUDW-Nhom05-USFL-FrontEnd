{"ast":null,"code":"/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n\n/* istanbul ignore next */\n\n\nfunction getId(segment) {\n  // eslint-disable-line jsdoc/require-jsdoc\n  return segment.id + (segment.reachable ? \"\" : \"!\");\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  /**\n   * A flag that debug dumping is enabled or not.\n   * @type {boolean}\n   */\n  enabled: debug.enabled,\n\n  /**\n   * Dumps given objects.\n   * @param {...any} args objects to dump.\n   * @returns {void}\n   */\n  dump: debug,\n\n  /**\n   * Dumps the current analyzing state.\n   * @param {ASTNode} node A node to dump.\n   * @param {CodePathState} state A state to dump.\n   * @param {boolean} leaving A flag whether or not it's leaving\n   * @returns {void}\n   */\n  dumpState: !debug.enabled ? debug :\n  /* istanbul ignore next */\n  function (node, state, leaving) {\n    for (let i = 0; i < state.currentSegments.length; ++i) {\n      const segInternal = state.currentSegments[i].internal;\n\n      if (leaving) {\n        segInternal.exitNodes.push(node);\n      } else {\n        segInternal.nodes.push(node);\n      }\n    }\n\n    debug([`${state.currentSegments.map(getId).join(\",\")})`, `${node.type}${leaving ? \":exit\" : \"\"}`].join(\" \"));\n  },\n\n  /**\n   * Dumps a DOT code of a given code path.\n   * The DOT code can be visialized with Graphvis.\n   * @param {CodePath} codePath A code path to dump.\n   * @returns {void}\n   * @see http://www.graphviz.org\n   * @see http://www.webgraphviz.com\n   */\n  dumpDot: !debug.enabled ? debug :\n  /* istanbul ignore next */\n  function (codePath) {\n    let text = \"\\n\" + \"digraph {\\n\" + \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" + \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n    if (codePath.returnedSegments.length > 0) {\n      text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n    }\n\n    if (codePath.thrownSegments.length > 0) {\n      text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n    }\n\n    const traceMap = Object.create(null);\n    const arrows = this.makeDotArrows(codePath, traceMap);\n\n    for (const id in traceMap) {\n      // eslint-disable-line guard-for-in\n      const segment = traceMap[id];\n      text += `${id}[`;\n\n      if (segment.reachable) {\n        text += \"label=\\\"\";\n      } else {\n        text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n      }\n\n      if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {\n        text += [].concat(segment.internal.nodes.map(node => {\n          switch (node.type) {\n            case \"Identifier\":\n              return `${node.type} (${node.name})`;\n\n            case \"Literal\":\n              return `${node.type} (${node.value})`;\n\n            default:\n              return node.type;\n          }\n        }), segment.internal.exitNodes.map(node => {\n          switch (node.type) {\n            case \"Identifier\":\n              return `${node.type}:exit (${node.name})`;\n\n            case \"Literal\":\n              return `${node.type}:exit (${node.value})`;\n\n            default:\n              return `${node.type}:exit`;\n          }\n        })).join(\"\\\\n\");\n      } else {\n        text += \"????\";\n      }\n\n      text += \"\\\"];\\n\";\n    }\n\n    text += `${arrows}\\n`;\n    text += \"}\";\n    debug(\"DOT\", text);\n  },\n\n  /**\n   * Makes a DOT code of a given code path.\n   * The DOT code can be visialized with Graphvis.\n   * @param {CodePath} codePath A code path to make DOT.\n   * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n   * @returns {string} A DOT code of the code path.\n   */\n  makeDotArrows(codePath, traceMap) {\n    const stack = [[codePath.initialSegment, 0]];\n    const done = traceMap || Object.create(null);\n    let lastId = codePath.initialSegment.id;\n    let text = `initial->${codePath.initialSegment.id}`;\n\n    while (stack.length > 0) {\n      const item = stack.pop();\n      const segment = item[0];\n      const index = item[1];\n\n      if (done[segment.id] && index === 0) {\n        continue;\n      }\n\n      done[segment.id] = segment;\n      const nextSegment = segment.allNextSegments[index];\n\n      if (!nextSegment) {\n        continue;\n      }\n\n      if (lastId === segment.id) {\n        text += `->${nextSegment.id}`;\n      } else {\n        text += `;\\n${segment.id}->${nextSegment.id}`;\n      }\n\n      lastId = nextSegment.id;\n      stack.unshift([segment, 1 + index]);\n      stack.push([nextSegment, 0]);\n    }\n\n    codePath.returnedSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->final\";\n      } else {\n        text += `;\\n${finalSegment.id}->final`;\n      }\n\n      lastId = null;\n    });\n    codePath.thrownSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->thrown\";\n      } else {\n        text += `;\\n${finalSegment.id}->thrown`;\n      }\n\n      lastId = null;\n    });\n    return `${text};`;\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js"],"names":["debug","require","getId","segment","id","reachable","module","exports","enabled","dump","dumpState","node","state","leaving","i","currentSegments","length","segInternal","internal","exitNodes","push","nodes","map","join","type","dumpDot","codePath","text","returnedSegments","thrownSegments","traceMap","Object","create","arrows","makeDotArrows","concat","name","value","stack","initialSegment","done","lastId","item","pop","index","nextSegment","allNextSegments","unshift","forEach","finalSegment"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line jsdoc/require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     * @param {...any} args objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     * @param {ASTNode} node A node to dump.\n     * @param {CodePathState} state A state to dump.\n     * @param {boolean} leaving A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                segInternal.exitNodes.push(node);\n            } else {\n                segInternal.nodes.push(node);\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     * @param {CodePath} codePath A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {\n                text += [].concat(\n                    segment.internal.nodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type} (${node.name})`;\n                            case \"Literal\": return `${node.type} (${node.value})`;\n                            default: return node.type;\n                        }\n                    }),\n                    segment.internal.exitNodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type}:exit (${node.name})`;\n                            case \"Literal\": return `${node.type}:exit (${node.value})`;\n                            default: return `${node.type}:exit`;\n                        }\n                    })\n                ).join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     * @param {CodePath} codePath A code path to make DOT.\n     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}