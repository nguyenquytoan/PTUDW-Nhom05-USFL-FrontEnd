{"ast":null,"code":"/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\n\nfunction parseOptions(options) {\n  return {\n    boolean: \"boolean\" in options ? options.boolean : true,\n    number: \"number\" in options ? options.number : true,\n    string: \"string\" in options ? options.string : true,\n    allow: options.allow || []\n  };\n}\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\n\n\nfunction isDoubleLogicalNegating(node) {\n  return node.operator === \"!\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n}\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\n\n\nfunction isBinaryNegatingOfIndexOf(node) {\n  return node.operator === \"~\" && node.argument.type === \"CallExpression\" && node.argument.callee.type === \"MemberExpression\" && node.argument.callee.property.type === \"Identifier\" && INDEX_OF_PATTERN.test(node.argument.callee.property.name);\n}\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\n\n\nfunction isMultiplyByOne(node) {\n  return node.operator === \"*\" && (node.left.type === \"Literal\" && node.left.value === 1 || node.right.type === \"Literal\" && node.right.value === 1);\n}\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\n\n\nfunction isNumeric(node) {\n  return node.type === \"Literal\" && typeof node.value === \"number\" || node.type === \"CallExpression\" && (node.callee.name === \"Number\" || node.callee.name === \"parseInt\" || node.callee.name === \"parseFloat\");\n}\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\n\n\nfunction getNonNumericOperand(node) {\n  const left = node.left,\n        right = node.right;\n\n  if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n    return right;\n  }\n\n  if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n    return left;\n  }\n\n  return null;\n}\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\n\n\nfunction isEmptyString(node) {\n  return astUtils.isStringLiteral(node) && (node.value === \"\" || node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\");\n}\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\n\n\nfunction isConcatWithEmptyString(node) {\n  return node.operator === \"+\" && (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right) || isEmptyString(node.right) && !astUtils.isStringLiteral(node.left));\n}\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\n\n\nfunction isAppendEmptyString(node) {\n  return node.operator === \"+=\" && isEmptyString(node.right);\n}\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\n\n\nfunction getNonEmptyOperand(node) {\n  return isEmptyString(node.left) ? node.right : node.left;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow shorthand type conversions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        boolean: {\n          type: \"boolean\",\n          default: true\n        },\n        number: {\n          type: \"boolean\",\n          default: true\n        },\n        string: {\n          type: \"boolean\",\n          default: true\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOWABLE_OPERATORS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0] || {});\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports an error and autofixes the node\n     * @param {ASTNode} node An ast node to report the error on.\n     * @param {string} recommendation The recommended code for the issue\n     * @param {bool} shouldFix Whether this report should fix the node\n     * @returns {void}\n     */\n\n    function report(node, recommendation, shouldFix) {\n      context.report({\n        node,\n        message: \"use `{{recommendation}}` instead.\",\n        data: {\n          recommendation\n        },\n\n        fix(fixer) {\n          if (!shouldFix) {\n            return null;\n          }\n\n          const tokenBefore = sourceCode.getTokenBefore(node);\n\n          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {\n            return fixer.replaceText(node, ` ${recommendation}`);\n          }\n\n          return fixer.replaceText(node, recommendation);\n        }\n\n      });\n    }\n\n    return {\n      UnaryExpression(node) {\n        let operatorAllowed; // !!foo\n\n        operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n          report(node, recommendation, true);\n        } // ~foo.indexOf(bar)\n\n\n        operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n          const recommendation = `${sourceCode.getText(node.argument)} !== -1`;\n          report(node, recommendation, false);\n        } // +foo\n\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n          const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      // Use `:exit` to prevent double reporting\n      \"BinaryExpression:exit\"(node) {\n        let operatorAllowed; // 1 * foo\n\n        operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n        if (nonNumericOperand) {\n          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n          report(node, recommendation, true);\n        } // \"\" + foo\n\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      AssignmentExpression(node) {\n        // foo += \"\"\n        const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n          const code = sourceCode.getText(getNonEmptyOperand(node));\n          const recommendation = `${code} = String(${code})`;\n          report(node, recommendation, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-implicit-coercion.js"],"names":["astUtils","require","INDEX_OF_PATTERN","ALLOWABLE_OPERATORS","parseOptions","options","boolean","number","string","allow","isDoubleLogicalNegating","node","operator","argument","type","isBinaryNegatingOfIndexOf","callee","property","test","name","isMultiplyByOne","left","value","right","isNumeric","getNonNumericOperand","isEmptyString","isStringLiteral","quasis","length","cooked","isConcatWithEmptyString","isAppendEmptyString","getNonEmptyOperand","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","default","items","enum","uniqueItems","additionalProperties","create","context","sourceCode","getSourceCode","report","recommendation","shouldFix","message","data","fix","fixer","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","replaceText","UnaryExpression","operatorAllowed","indexOf","getText","nonNumericOperand","AssignmentExpression","code"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    return {\n        boolean: \"boolean\" in options ? options.boolean : true,\n        number: \"number\" in options ? options.number : true,\n        string: \"string\" in options ? options.string : true,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    return (\n        node.operator === \"~\" &&\n        node.argument.type === \"CallExpression\" &&\n        node.argument.callee.type === \"MemberExpression\" &&\n        node.argument.callee.property.type === \"Identifier\" &&\n        INDEX_OF_PATTERN.test(node.argument.callee.property.name)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||\n        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\",\n                    default: true\n                },\n                number: {\n                    type: \"boolean\",\n                    default: true\n                },\n                string: {\n                    type: \"boolean\",\n                    default: true\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0] || {});\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node An ast node to report the error on.\n         * @param {string} recommendation The recommended code for the issue\n         * @param {bool} shouldFix Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldFix) {\n            context.report({\n                node,\n                message: \"use `{{recommendation}}` instead.\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n                    const recommendation = `${sourceCode.getText(node.argument)} !== -1`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true);\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}