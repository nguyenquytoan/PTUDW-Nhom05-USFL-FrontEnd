{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar tokenizer = require('postcss/lib/tokenize');\n\nvar Comment = require('postcss/lib/comment');\n\nvar Parser = require('postcss/lib/parser');\n\nvar SafeParser = function (_Parser) {\n  _inherits(SafeParser, _Parser);\n\n  function SafeParser() {\n    _classCallCheck(this, SafeParser);\n\n    return _possibleConstructorReturn(this, _Parser.apply(this, arguments));\n  }\n\n  SafeParser.prototype.createTokenizer = function createTokenizer() {\n    this.tokenizer = tokenizer(this.input, {\n      ignoreErrors: true\n    });\n  };\n\n  SafeParser.prototype.comment = function comment(token) {\n    var node = new Comment();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2);\n    if (text.slice(-2) === '*/') text = text.slice(0, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  SafeParser.prototype.decl = function decl(tokens) {\n    if (tokens.length > 1) {\n      _Parser.prototype.decl.call(this, tokens);\n    }\n  };\n\n  SafeParser.prototype.unclosedBracket = function unclosedBracket() {};\n\n  SafeParser.prototype.unknownWord = function unknownWord(tokens) {\n    this.spaces += tokens.map(function (i) {\n      return i[1];\n    }).join('');\n  };\n\n  SafeParser.prototype.unexpectedClose = function unexpectedClose() {\n    this.current.raws.after += '}';\n  };\n\n  SafeParser.prototype.doubleColon = function doubleColon() {};\n\n  SafeParser.prototype.unnamedAtrule = function unnamedAtrule(node) {\n    node.name = '';\n  };\n\n  SafeParser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var split = void 0;\n\n    for (split = colon - 1; split >= 0; split--) {\n      if (tokens[split][0] === 'word') break;\n    }\n\n    for (split -= 1; split >= 0; split--) {\n      if (tokens[split][0] !== 'space') {\n        split += 1;\n        break;\n      }\n    }\n\n    var other = tokens.splice(split, tokens.length - split);\n    this.decl(other);\n  };\n\n  SafeParser.prototype.checkMissedSemicolon = function checkMissedSemicolon() {};\n\n  SafeParser.prototype.endFile = function endFile() {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n\n    while (this.current.parent) {\n      this.current = this.current.parent;\n      this.current.raws.after = '';\n    }\n  };\n\n  return SafeParser;\n}(Parser);\n\nmodule.exports = SafeParser;","map":{"version":3,"sources":["safe-parser.es6"],"names":["tokenizer","require","Comment","Parser","SafeParser","createTokenizer","ignoreErrors","comment","token","node","line","column","text","match","decl","tokens","unclosedBracket","unknownWord","i","unexpectedClose","doubleColon","unnamedAtrule","precheckMissedSemicolon","colon","split","other","checkMissedSemicolon","endFile","module"],"mappings":"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","sourcesContent":["const tokenizer = require('postcss/lib/tokenize')\nconst Comment = require('postcss/lib/comment')\nconst Parser = require('postcss/lib/parser')\n\nclass SafeParser extends Parser {\n  createTokenizer () {\n    this.tokenizer = tokenizer(this.input, { ignoreErrors: true })\n  }\n\n  comment (token) {\n    const node = new Comment()\n    this.init(node, token[2], token[3])\n    node.source.end = { line: token[4], column: token[5] }\n\n    let text = token[1].slice(2)\n    if (text.slice(-2) === '*/') text = text.slice(0, -2)\n\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      const match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  decl (tokens) {\n    if (tokens.length > 1) {\n      super.decl(tokens)\n    }\n  }\n\n  unclosedBracket () { }\n\n  unknownWord (tokens) {\n    this.spaces += tokens.map(i => i[1]).join('')\n  }\n\n  unexpectedClose () {\n    this.current.raws.after += '}'\n  }\n\n  doubleColon () { }\n\n  unnamedAtrule (node) {\n    node.name = ''\n  }\n\n  precheckMissedSemicolon (tokens) {\n    const colon = this.colon(tokens)\n    if (colon === false) return\n\n    let split\n    for (split = colon - 1; split >= 0; split--) {\n      if (tokens[split][0] === 'word') break\n    }\n    for (split -= 1; split >= 0; split--) {\n      if (tokens[split][0] !== 'space') {\n        split += 1\n        break\n      }\n    }\n    const other = tokens.splice(split, tokens.length - split)\n    this.decl(other)\n  }\n\n  checkMissedSemicolon () { }\n\n  endFile () {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n\n    while (this.current.parent) {\n      this.current = this.current.parent\n      this.current.raws.after = ''\n    }\n  }\n}\n\nmodule.exports = SafeParser\n"]},"metadata":{},"sourceType":"script"}