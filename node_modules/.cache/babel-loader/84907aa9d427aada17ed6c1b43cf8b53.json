{"ast":null,"code":"/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst SPACES = /\\s+/gu;\n/**\n * Checks whether the property of 2 given member expression nodes are the same\n * property or not.\n * @param {ASTNode} left A member expression node to check.\n * @param {ASTNode} right Another member expression node to check.\n * @returns {boolean} `true` if the member expressions have the same property.\n */\n\nfunction isSameProperty(left, right) {\n  if (left.property.type === \"Identifier\" && left.property.type === right.property.type && left.property.name === right.property.name && left.computed === right.computed) {\n    return true;\n  }\n\n  const lname = astUtils.getStaticPropertyName(left);\n  const rname = astUtils.getStaticPropertyName(right);\n  return lname !== null && lname === rname;\n}\n/**\n * Checks whether 2 given member expression nodes are the reference to the same\n * property or not.\n * @param {ASTNode} left A member expression node to check.\n * @param {ASTNode} right Another member expression node to check.\n * @returns {boolean} `true` if the member expressions are the reference to the\n *  same property or not.\n */\n\n\nfunction isSameMember(left, right) {\n  if (!isSameProperty(left, right)) {\n    return false;\n  }\n\n  const lobj = left.object;\n  const robj = right.object;\n\n  if (lobj.type !== robj.type) {\n    return false;\n  }\n\n  if (lobj.type === \"MemberExpression\") {\n    return isSameMember(lobj, robj);\n  }\n\n  if (lobj.type === \"ThisExpression\") {\n    return true;\n  }\n\n  return lobj.type === \"Identifier\" && lobj.name === robj.name;\n}\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props The flag to check member expressions as well.\n * @param {Function} report A callback function to report.\n * @returns {void}\n */\n\n\nfunction eachSelfAssignment(left, right, props, report) {\n  if (!left || !right) {// do nothing\n  } else if (left.type === \"Identifier\" && right.type === \"Identifier\" && left.name === right.name) {\n    report(right);\n  } else if (left.type === \"ArrayPattern\" && right.type === \"ArrayExpression\") {\n    const end = Math.min(left.elements.length, right.elements.length);\n\n    for (let i = 0; i < end; ++i) {\n      const leftElement = left.elements[i];\n      const rightElement = right.elements[i]; // Avoid cases such as [...a] = [...a, 1]\n\n      if (leftElement && leftElement.type === \"RestElement\" && i < right.elements.length - 1) {\n        break;\n      }\n\n      eachSelfAssignment(leftElement, rightElement, props, report); // After a spread element, those indices are unknown.\n\n      if (rightElement && rightElement.type === \"SpreadElement\") {\n        break;\n      }\n    }\n  } else if (left.type === \"RestElement\" && right.type === \"SpreadElement\") {\n    eachSelfAssignment(left.argument, right.argument, props, report);\n  } else if (left.type === \"ObjectPattern\" && right.type === \"ObjectExpression\" && right.properties.length >= 1) {\n    /*\n     * Gets the index of the last spread property.\n     * It's possible to overwrite properties followed by it.\n     */\n    let startJ = 0;\n\n    for (let i = right.properties.length - 1; i >= 0; --i) {\n      const propType = right.properties[i].type;\n\n      if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n        startJ = i + 1;\n        break;\n      }\n    }\n\n    for (let i = 0; i < left.properties.length; ++i) {\n      for (let j = startJ; j < right.properties.length; ++j) {\n        eachSelfAssignment(left.properties[i], right.properties[j], props, report);\n      }\n    }\n  } else if (left.type === \"Property\" && right.type === \"Property\" && right.kind === \"init\" && !right.method) {\n    const leftName = astUtils.getStaticPropertyName(left);\n\n    if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n      eachSelfAssignment(left.value, right.value, props, report);\n    }\n  } else if (props && left.type === \"MemberExpression\" && right.type === \"MemberExpression\" && isSameMember(left, right)) {\n    report(right);\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments where both sides are exactly the same\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-self-assign\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        props: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const [{\n      props = true\n    } = {}] = context.options;\n    /**\n     * Reports a given node as self assignments.\n     * @param {ASTNode} node A node to report. This is an Identifier node.\n     * @returns {void}\n     */\n\n    function report(node) {\n      context.report({\n        node,\n        message: \"'{{name}}' is assigned to itself.\",\n        data: {\n          name: sourceCode.getText(node).replace(SPACES, \"\")\n        }\n      });\n    }\n\n    return {\n      AssignmentExpression(node) {\n        if (node.operator === \"=\") {\n          eachSelfAssignment(node.left, node.right, props, report);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-self-assign.js"],"names":["astUtils","require","SPACES","isSameProperty","left","right","property","type","name","computed","lname","getStaticPropertyName","rname","isSameMember","lobj","object","robj","eachSelfAssignment","props","report","end","Math","min","elements","length","i","leftElement","rightElement","argument","properties","startJ","propType","j","kind","method","leftName","value","module","exports","meta","docs","description","category","recommended","url","schema","default","additionalProperties","create","context","sourceCode","getSourceCode","options","node","message","data","getText","replace","AssignmentExpression","operator"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/gu;\n\n/**\n * Checks whether the property of 2 given member expression nodes are the same\n * property or not.\n * @param {ASTNode} left A member expression node to check.\n * @param {ASTNode} right Another member expression node to check.\n * @returns {boolean} `true` if the member expressions have the same property.\n */\nfunction isSameProperty(left, right) {\n    if (left.property.type === \"Identifier\" &&\n        left.property.type === right.property.type &&\n        left.property.name === right.property.name &&\n        left.computed === right.computed\n    ) {\n        return true;\n    }\n\n    const lname = astUtils.getStaticPropertyName(left);\n    const rname = astUtils.getStaticPropertyName(right);\n\n    return lname !== null && lname === rname;\n}\n\n/**\n * Checks whether 2 given member expression nodes are the reference to the same\n * property or not.\n * @param {ASTNode} left A member expression node to check.\n * @param {ASTNode} right Another member expression node to check.\n * @returns {boolean} `true` if the member expressions are the reference to the\n *  same property or not.\n */\nfunction isSameMember(left, right) {\n    if (!isSameProperty(left, right)) {\n        return false;\n    }\n\n    const lobj = left.object;\n    const robj = right.object;\n\n    if (lobj.type !== robj.type) {\n        return false;\n    }\n    if (lobj.type === \"MemberExpression\") {\n        return isSameMember(lobj, robj);\n    }\n    if (lobj.type === \"ThisExpression\") {\n        return true;\n    }\n    return lobj.type === \"Identifier\" && lobj.name === robj.name;\n}\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props The flag to check member expressions as well.\n * @param {Function} report A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const leftElement = left.elements[i];\n            const rightElement = right.elements[i];\n\n            // Avoid cases such as [...a] = [...a, 1]\n            if (\n                leftElement &&\n                leftElement.type === \"RestElement\" &&\n                i < right.elements.length - 1\n            ) {\n                break;\n            }\n\n            eachSelfAssignment(leftElement, rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        /*\n         * Gets the index of the last spread property.\n         * It's possible to overwrite properties followed by it.\n         */\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            const propType = right.properties[i].type;\n\n            if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        right.kind === \"init\" &&\n        !right.method\n    ) {\n        const leftName = astUtils.getStaticPropertyName(left);\n\n        if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n            eachSelfAssignment(left.value, right.value, props, report);\n        }\n    } else if (\n        props &&\n        left.type === \"MemberExpression\" &&\n        right.type === \"MemberExpression\" &&\n        isSameMember(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-self-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const [{ props = true } = {}] = context.options;\n\n        /**\n         * Reports a given node as self assignments.\n         * @param {ASTNode} node A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"'{{name}}' is assigned to itself.\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if (node.operator === \"=\") {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}