{"ast":null,"code":"'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Possible types of a MockFunctionResult.\n * 'return': The call completed by returning normally.\n * 'throw': The call completed by throwing a value.\n * 'incomplete': The call has not completed yet. This is possible if you read\n *               the  mock function result from within the mock function itself\n *               (or a function called by the mock function).\n */\n\n/**\n * Represents the result of a single call to a mock function.\n */\n// see https://github.com/Microsoft/TypeScript/issues/25215\n\n\nconst MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\nconst FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\nconst FUNCTION_NAME_RESERVED_REPLACE = new RegExp(FUNCTION_NAME_RESERVED_PATTERN.source, 'g');\nconst RESERVED_KEYWORDS = new Set(['arguments', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield']);\n\nfunction matchArity(fn, length) {\n  let mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function mockConstructor(_a) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 2:\n      mockConstructor = function mockConstructor(_a, _b) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 3:\n      mockConstructor = function mockConstructor(_a, _b, _c) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 4:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 5:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 6:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 7:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 8:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g, _h) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 9:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g, _h, _i) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    default:\n      mockConstructor = function mockConstructor() {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref) {\n  const typeName = getObjectType(ref);\n\n  if (typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction') {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object') {\n    return 'object';\n  } else if (typeName === 'Number' || typeName === 'String' || typeName === 'Boolean' || typeName === 'Symbol') {\n    return 'constant';\n  } else if (typeName === 'Map' || typeName === 'WeakMap' || typeName === 'Set') {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  if (prop === 'arguments' || prop === 'caller' || prop === 'callee' || prop === 'name' || prop === 'length') {\n    const typeName = getObjectType(object);\n    return typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction';\n  }\n\n  if (prop === 'source' || prop === 'global' || prop === 'ignoreCase' || prop === 'multiline') {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nclass ModuleMockerClass {\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  constructor(global) {\n    _defineProperty(this, '_environmentGlobal', void 0);\n\n    _defineProperty(this, '_mockState', void 0);\n\n    _defineProperty(this, '_mockConfigRegistry', void 0);\n\n    _defineProperty(this, '_spyState', void 0);\n\n    _defineProperty(this, '_invocationCallCounter', void 0);\n\n    _defineProperty(this, 'ModuleMocker', void 0);\n\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this.ModuleMocker = ModuleMockerClass;\n    this._invocationCallCounter = 1;\n  }\n\n  _getSlots(object) {\n    if (!object) {\n      return [];\n    }\n\n    const slots = new Set();\n    const EnvObjectProto = this._environmentGlobal.Object.prototype;\n    const EnvFunctionProto = this._environmentGlobal.Function.prototype;\n    const EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through\n    // core node modules.\n\n    const ObjectProto = Object.prototype;\n    const FunctionProto = Function.prototype;\n    const RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype\n    // are never reported as slots\n\n    while (object != null && object !== EnvObjectProto && object !== EnvFunctionProto && object !== EnvRegExpProto && object !== ObjectProto && object !== FunctionProto && object !== RegExpProto) {\n      const ownNames = Object.getOwnPropertyNames(object);\n\n      for (let i = 0; i < ownNames.length; i++) {\n        const prop = ownNames[i];\n\n        if (!isReadonlyProp(object, prop)) {\n          const propDesc = Object.getOwnPropertyDescriptor(object, prop); // @ts-ignore Object.__esModule\n\n          if (propDesc !== undefined && !propDesc.get || object.__esModule) {\n            slots.add(prop);\n          }\n        }\n      }\n\n      object = Object.getPrototypeOf(object);\n    }\n\n    return Array.from(slots);\n  }\n\n  _ensureMockConfig(f) {\n    let config = this._mockConfigRegistry.get(f);\n\n    if (!config) {\n      config = this._defaultMockConfig();\n\n      this._mockConfigRegistry.set(f, config);\n    }\n\n    return config;\n  }\n\n  _ensureMockState(f) {\n    let state = this._mockState.get(f);\n\n    if (!state) {\n      state = this._defaultMockState();\n\n      this._mockState.set(f, state);\n    }\n\n    return state;\n  }\n\n  _defaultMockConfig() {\n    return {\n      defaultReturnValue: undefined,\n      isReturnValueLastSet: false,\n      mockImpl: undefined,\n      mockName: 'jest.fn()',\n      specificMockImpls: [],\n      specificReturnValues: []\n    };\n  }\n\n  _defaultMockState() {\n    return {\n      calls: [],\n      instances: [],\n      invocationCallOrder: [],\n      results: []\n    };\n  }\n\n  _makeComponent(metadata, restore) {\n    if (metadata.type === 'object') {\n      return new this._environmentGlobal.Object();\n    } else if (metadata.type === 'array') {\n      return new this._environmentGlobal.Array();\n    } else if (metadata.type === 'regexp') {\n      return new this._environmentGlobal.RegExp('');\n    } else if (metadata.type === 'constant' || metadata.type === 'collection' || metadata.type === 'null' || metadata.type === 'undefined') {\n      return metadata.value;\n    } else if (metadata.type === 'function') {\n      const prototype = metadata.members && metadata.members.prototype && metadata.members.prototype.members || {};\n\n      const prototypeSlots = this._getSlots(prototype);\n\n      const mocker = this;\n      const mockConstructor = matchArity(function (...args) {\n        const mockState = mocker._ensureMockState(f);\n\n        const mockConfig = mocker._ensureMockConfig(f);\n\n        mockState.instances.push(this);\n        mockState.calls.push(args); // Create and record an \"incomplete\" mock result immediately upon\n        // calling rather than waiting for the mock to return. This avoids\n        // issues caused by recursion where results can be recorded in the\n        // wrong order.\n\n        const mockResult = {\n          type: 'incomplete',\n          value: undefined\n        };\n        mockState.results.push(mockResult);\n        mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown\n\n        let finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)\n\n        let thrownError; // Will be set to true if the mock throws an error. The presence of a\n        // value in `thrownError` is not a 100% reliable indicator because a\n        // function could throw a value of undefined.\n\n        let callDidThrowError = false;\n\n        try {\n          // The bulk of the implementation is wrapped in an immediately\n          // executed arrow function so the return value of the mock function\n          // can be easily captured and recorded, despite the many separate\n          // return points within the logic.\n          finalReturnValue = (() => {\n            if (this instanceof f) {\n              // This is probably being called as a constructor\n              prototypeSlots.forEach(slot => {\n                // Copy prototype methods to the instance to make\n                // it easier to interact with mock instance call and\n                // return values\n                if (prototype[slot].type === 'function') {\n                  // @ts-ignore no index signature\n                  const protoImpl = this[slot]; // @ts-ignore no index signature\n\n                  this[slot] = mocker.generateFromMetadata(prototype[slot]); // @ts-ignore no index signature\n\n                  this[slot]._protoImpl = protoImpl;\n                }\n              }); // Run the mock constructor implementation\n\n              const mockImpl = mockConfig.specificMockImpls.length ? mockConfig.specificMockImpls.shift() : mockConfig.mockImpl;\n              return mockImpl && mockImpl.apply(this, arguments);\n            }\n\n            const returnValue = mockConfig.defaultReturnValue; // If return value is last set, either specific or default, i.e.\n            // mockReturnValueOnce()/mockReturnValue() is called and no\n            // mockImplementationOnce()/mockImplementation() is called after\n            // that.\n            // use the set return value.\n\n            if (mockConfig.specificReturnValues.length) {\n              return mockConfig.specificReturnValues.shift();\n            }\n\n            if (mockConfig.isReturnValueLastSet) {\n              return mockConfig.defaultReturnValue;\n            } // If mockImplementationOnce()/mockImplementation() is last set,\n            // or specific return values are used up, use the mock\n            // implementation.\n\n\n            let specificMockImpl;\n\n            if (returnValue === undefined) {\n              specificMockImpl = mockConfig.specificMockImpls.shift();\n\n              if (specificMockImpl === undefined) {\n                specificMockImpl = mockConfig.mockImpl;\n              }\n\n              if (specificMockImpl) {\n                return specificMockImpl.apply(this, arguments);\n              }\n            } // Otherwise use prototype implementation\n\n\n            if (returnValue === undefined && f._protoImpl) {\n              return f._protoImpl.apply(this, arguments);\n            }\n\n            return returnValue;\n          })();\n        } catch (error) {\n          // Store the thrown error so we can record it, then re-throw it.\n          thrownError = error;\n          callDidThrowError = true;\n          throw error;\n        } finally {\n          // Record the result of the function.\n          // NOTE: Intentionally NOT pushing/indexing into the array of mock\n          //       results here to avoid corrupting results data if mockClear()\n          //       is called during the execution of the mock.\n          mockResult.type = callDidThrowError ? 'throw' : 'return';\n          mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n        }\n\n        return finalReturnValue;\n      }, metadata.length || 0);\n\n      const f = this._createMockFunction(metadata, mockConstructor);\n\n      f._isMockFunction = true;\n\n      f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;\n\n      if (typeof restore === 'function') {\n        this._spyState.add(restore);\n      }\n\n      this._mockState.set(f, this._defaultMockState());\n\n      this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n      Object.defineProperty(f, 'mock', {\n        configurable: false,\n        enumerable: true,\n        get: () => this._ensureMockState(f),\n        set: val => this._mockState.set(f, val)\n      });\n\n      f.mockClear = () => {\n        this._mockState.delete(f);\n\n        return f;\n      };\n\n      f.mockReset = () => {\n        f.mockClear();\n\n        this._mockConfigRegistry.delete(f);\n\n        return f;\n      };\n\n      f.mockRestore = () => {\n        f.mockReset();\n        return restore ? restore() : undefined;\n      };\n\n      f.mockReturnValueOnce = value => {\n        // next function call will return this value or default return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.specificReturnValues.push(value);\n        return f;\n      };\n\n      f.mockResolvedValueOnce = value => f.mockImplementationOnce(() => Promise.resolve(value));\n\n      f.mockRejectedValueOnce = value => f.mockImplementationOnce(() => Promise.reject(value));\n\n      f.mockReturnValue = value => {\n        // next function call will return specified return value or this one\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.isReturnValueLastSet = true;\n        mockConfig.defaultReturnValue = value;\n        return f;\n      };\n\n      f.mockResolvedValue = value => f.mockImplementation(() => Promise.resolve(value));\n\n      f.mockRejectedValue = value => f.mockImplementation(() => Promise.reject(value));\n\n      f.mockImplementationOnce = fn => {\n        // next function call will use this mock implementation return value\n        // or default mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.isReturnValueLastSet = false;\n        mockConfig.specificMockImpls.push(fn);\n        return f;\n      };\n\n      f.mockImplementation = fn => {\n        // next function call will use mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.isReturnValueLastSet = false;\n        mockConfig.defaultReturnValue = undefined;\n        mockConfig.mockImpl = fn;\n        return f;\n      };\n\n      f.mockReturnThis = () => f.mockImplementation(function () {\n        return this;\n      });\n\n      f.mockName = name => {\n        if (name) {\n          const mockConfig = this._ensureMockConfig(f);\n\n          mockConfig.mockName = name;\n        }\n\n        return f;\n      };\n\n      f.getMockName = () => {\n        const mockConfig = this._ensureMockConfig(f);\n\n        return mockConfig.mockName || 'jest.fn()';\n      };\n\n      if (metadata.mockImpl) {\n        f.mockImplementation(metadata.mockImpl);\n      }\n\n      return f;\n    } else {\n      const unknownType = metadata.type || 'undefined type';\n      throw new Error('Unrecognized type ' + unknownType);\n    }\n  }\n\n  _createMockFunction(metadata, mockConstructor) {\n    let name = metadata.name;\n\n    if (!name) {\n      return mockConstructor;\n    } // Preserve `name` property of mocked function.\n\n\n    const boundFunctionPrefix = 'bound ';\n    let bindCall = ''; // if-do-while for perf reasons. The common case is for the if to fail.\n\n    if (name && name.startsWith(boundFunctionPrefix)) {\n      do {\n        name = name.substring(boundFunctionPrefix.length); // Call bind() just to alter the function name.\n\n        bindCall = '.bind(null)';\n      } while (name && name.startsWith(boundFunctionPrefix));\n    } // Special case functions named `mockConstructor` to guard for infinite\n    // loops.\n\n\n    if (name === MOCK_CONSTRUCTOR_NAME) {\n      return mockConstructor;\n    }\n\n    if ( // It's a syntax error to define functions with a reserved keyword\n    // as name.\n    RESERVED_KEYWORDS.has(name) || // It's also a syntax error to define functions with a name that starts with a number\n    /^\\d/.test(name)) {\n      name = '$' + name;\n    } // It's also a syntax error to define a function with a reserved character\n    // as part of it's name.\n\n\n    if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n      name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n    }\n\n    const body = 'return function ' + name + '() {' + 'return ' + MOCK_CONSTRUCTOR_NAME + '.apply(this,arguments);' + '}' + bindCall;\n    const createConstructor = new this._environmentGlobal.Function(MOCK_CONSTRUCTOR_NAME, body);\n    return createConstructor(mockConstructor);\n  }\n\n  _generateMock(metadata, callbacks, refs) {\n    // metadata not compatible but it's the same type, maybe problem with\n    // overloading of _makeComponent and not _generateMock?\n    // @ts-ignore\n    const mock = this._makeComponent(metadata);\n\n    if (metadata.refID != null) {\n      refs[metadata.refID] = mock;\n    }\n\n    this._getSlots(metadata.members).forEach(slot => {\n      const slotMetadata = metadata.members && metadata.members[slot] || {};\n\n      if (slotMetadata.ref != null) {\n        callbacks.push(function (ref) {\n          return () => mock[slot] = refs[ref];\n        }(slotMetadata.ref));\n      } else {\n        mock[slot] = this._generateMock(slotMetadata, callbacks, refs);\n      }\n    });\n\n    if (metadata.type !== 'undefined' && metadata.type !== 'null' && mock.prototype && typeof mock.prototype === 'object') {\n      mock.prototype.constructor = mock;\n    }\n\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param _metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   */\n\n\n  generateFromMetadata(_metadata) {\n    const callbacks = [];\n    const refs = {};\n\n    const mock = this._generateMock(_metadata, callbacks, refs);\n\n    callbacks.forEach(setter => setter());\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param component The component for which to retrieve metadata.\n   */\n\n\n  getMetadata(component, _refs) {\n    const refs = _refs || new Map();\n    const ref = refs.get(component);\n\n    if (ref != null) {\n      return {\n        ref\n      };\n    }\n\n    const type = getType(component);\n\n    if (!type) {\n      return null;\n    }\n\n    const metadata = {\n      type\n    };\n\n    if (type === 'constant' || type === 'collection' || type === 'undefined' || type === 'null') {\n      metadata.value = component;\n      return metadata;\n    } else if (type === 'function') {\n      // @ts-ignore this is a function so it has a name\n      metadata.name = component.name; // @ts-ignore may be a mock\n\n      if (component._isMockFunction === true) {\n        // @ts-ignore may be a mock\n        metadata.mockImpl = component.getMockImplementation();\n      }\n    }\n\n    metadata.refID = refs.size;\n    refs.set(component, metadata.refID);\n    let members = null; // Leave arrays alone\n\n    if (type !== 'array') {\n      this._getSlots(component).forEach(slot => {\n        if (type === 'function' && // @ts-ignore may be a mock\n        component._isMockFunction === true && slot.match(/^mock/)) {\n          return;\n        } // @ts-ignore no index signature\n\n\n        const slotMetadata = this.getMetadata(component[slot], refs);\n\n        if (slotMetadata) {\n          if (!members) {\n            members = {};\n          }\n\n          members[slot] = slotMetadata;\n        }\n      });\n    }\n\n    if (members) {\n      metadata.members = members;\n    }\n\n    return metadata;\n  }\n\n  isMockFunction(fn) {\n    return !!fn && fn._isMockFunction === true;\n  }\n\n  fn(implementation) {\n    const length = implementation ? implementation.length : 0;\n\n    const fn = this._makeComponent({\n      length,\n      type: 'function'\n    });\n\n    if (implementation) {\n      fn.mockImplementation(implementation);\n    }\n\n    return fn;\n  }\n\n  spyOn(object, methodName, accessType) {\n    if (accessType) {\n      return this._spyOnProperty(object, methodName, accessType);\n    }\n\n    if (typeof object !== 'object' && typeof object !== 'function') {\n      throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given');\n    }\n\n    const original = object[methodName];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error('Cannot spy the ' + methodName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');\n      }\n\n      const isMethodOwner = object.hasOwnProperty(methodName); // @ts-ignore overriding original method with a Mock\n\n      object[methodName] = this._makeComponent({\n        type: 'function'\n      }, () => {\n        if (isMethodOwner) {\n          object[methodName] = original;\n        } else {\n          delete object[methodName];\n        }\n      }); // @ts-ignore original method is now a Mock\n\n      object[methodName].mockImplementation(function () {\n        return original.apply(this, arguments);\n      });\n    }\n\n    return object[methodName];\n  }\n\n  _spyOnProperty(obj, propertyName, accessType = 'get') {\n    if (typeof obj !== 'object' && typeof obj !== 'function') {\n      throw new Error('Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given');\n    }\n\n    if (!obj) {\n      throw new Error('spyOn could not find an object to spy upon for ' + propertyName + '');\n    }\n\n    if (!propertyName) {\n      throw new Error('No property name supplied');\n    }\n\n    let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n    let proto = Object.getPrototypeOf(obj);\n\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    if (!descriptor) {\n      throw new Error(propertyName + ' property does not exist');\n    }\n\n    if (!descriptor.configurable) {\n      throw new Error(propertyName + ' is not declared configurable');\n    }\n\n    if (!descriptor[accessType]) {\n      throw new Error('Property ' + propertyName + ' does not have access type ' + accessType);\n    }\n\n    const original = descriptor[accessType];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error('Cannot spy the ' + propertyName + ' property because it is not a function; ' + this._typeOf(original) + ' given instead');\n      } // @ts-ignore: mock is assignable\n\n\n      descriptor[accessType] = this._makeComponent({\n        type: 'function'\n      }, () => {\n        // @ts-ignore: mock is assignable\n        descriptor[accessType] = original;\n        Object.defineProperty(obj, propertyName, descriptor);\n      });\n      descriptor[accessType].mockImplementation(function () {\n        // @ts-ignore\n        return original.apply(this, arguments);\n      });\n    }\n\n    Object.defineProperty(obj, propertyName, descriptor);\n    return descriptor[accessType];\n  }\n\n  clearAllMocks() {\n    this._mockState = new WeakMap();\n  }\n\n  resetAllMocks() {\n    this._mockConfigRegistry = new WeakMap();\n    this._mockState = new WeakMap();\n  }\n\n  restoreAllMocks() {\n    this._spyState.forEach(restore => restore());\n\n    this._spyState = new Set();\n  }\n\n  _typeOf(value) {\n    return value == null ? '' + value : typeof value;\n  }\n\n}\n/* eslint-disable-next-line no-redeclare */\n\n\nconst JestMock = new ModuleMockerClass(global);\nmodule.exports = JestMock;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-mock/build/index.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","MOCK_CONSTRUCTOR_NAME","FUNCTION_NAME_RESERVED_PATTERN","FUNCTION_NAME_RESERVED_REPLACE","RegExp","source","RESERVED_KEYWORDS","Set","matchArity","fn","length","mockConstructor","_a","apply","arguments","_b","_c","_d","_e","_f","_g","_h","_i","getObjectType","prototype","toString","slice","getType","ref","typeName","Array","isArray","undefined","isReadonlyProp","object","prop","ModuleMockerClass","constructor","global","_environmentGlobal","_mockState","WeakMap","_mockConfigRegistry","_spyState","ModuleMocker","_invocationCallCounter","_getSlots","slots","EnvObjectProto","EnvFunctionProto","Function","EnvRegExpProto","ObjectProto","FunctionProto","RegExpProto","ownNames","getOwnPropertyNames","i","propDesc","getOwnPropertyDescriptor","get","__esModule","add","getPrototypeOf","from","_ensureMockConfig","f","config","_defaultMockConfig","set","_ensureMockState","state","_defaultMockState","defaultReturnValue","isReturnValueLastSet","mockImpl","mockName","specificMockImpls","specificReturnValues","calls","instances","invocationCallOrder","results","_makeComponent","metadata","restore","type","members","prototypeSlots","mocker","args","mockState","mockConfig","push","mockResult","finalReturnValue","thrownError","callDidThrowError","forEach","slot","protoImpl","generateFromMetadata","_protoImpl","shift","returnValue","specificMockImpl","error","_createMockFunction","_isMockFunction","getMockImplementation","val","mockClear","delete","mockReset","mockRestore","mockReturnValueOnce","mockResolvedValueOnce","mockImplementationOnce","Promise","resolve","mockRejectedValueOnce","reject","mockReturnValue","mockResolvedValue","mockImplementation","mockRejectedValue","mockReturnThis","name","getMockName","unknownType","Error","boundFunctionPrefix","bindCall","startsWith","substring","has","test","replace","body","createConstructor","_generateMock","callbacks","refs","mock","refID","slotMetadata","_metadata","setter","getMetadata","component","_refs","Map","size","match","isMockFunction","implementation","spyOn","methodName","accessType","_spyOnProperty","_typeOf","original","isMethodOwner","hasOwnProperty","propertyName","descriptor","proto","clearAllMocks","resetAllMocks","restoreAllMocks","JestMock","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Possible types of a MockFunctionResult.\n * 'return': The call completed by returning normally.\n * 'throw': The call completed by throwing a value.\n * 'incomplete': The call has not completed yet. This is possible if you read\n *               the  mock function result from within the mock function itself\n *               (or a function called by the mock function).\n */\n\n/**\n * Represents the result of a single call to a mock function.\n */\n// see https://github.com/Microsoft/TypeScript/issues/25215\nconst MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\nconst FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\nconst FUNCTION_NAME_RESERVED_REPLACE = new RegExp(\n  FUNCTION_NAME_RESERVED_PATTERN.source,\n  'g'\n);\nconst RESERVED_KEYWORDS = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield'\n]);\n\nfunction matchArity(fn, length) {\n  let mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function mockConstructor(_a) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 2:\n      mockConstructor = function mockConstructor(_a, _b) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 3:\n      mockConstructor = function mockConstructor(_a, _b, _c) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 4:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 5:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 6:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 7:\n      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 8:\n      mockConstructor = function mockConstructor(\n        _a,\n        _b,\n        _c,\n        _d,\n        _e,\n        _f,\n        _g,\n        _h\n      ) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 9:\n      mockConstructor = function mockConstructor(\n        _a,\n        _b,\n        _c,\n        _d,\n        _e,\n        _f,\n        _g,\n        _h,\n        _i\n      ) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    default:\n      mockConstructor = function mockConstructor() {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref) {\n  const typeName = getObjectType(ref);\n\n  if (\n    typeName === 'Function' ||\n    typeName === 'AsyncFunction' ||\n    typeName === 'GeneratorFunction'\n  ) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object') {\n    return 'object';\n  } else if (\n    typeName === 'Number' ||\n    typeName === 'String' ||\n    typeName === 'Boolean' ||\n    typeName === 'Symbol'\n  ) {\n    return 'constant';\n  } else if (\n    typeName === 'Map' ||\n    typeName === 'WeakMap' ||\n    typeName === 'Set'\n  ) {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  if (\n    prop === 'arguments' ||\n    prop === 'caller' ||\n    prop === 'callee' ||\n    prop === 'name' ||\n    prop === 'length'\n  ) {\n    const typeName = getObjectType(object);\n    return (\n      typeName === 'Function' ||\n      typeName === 'AsyncFunction' ||\n      typeName === 'GeneratorFunction'\n    );\n  }\n\n  if (\n    prop === 'source' ||\n    prop === 'global' ||\n    prop === 'ignoreCase' ||\n    prop === 'multiline'\n  ) {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nclass ModuleMockerClass {\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  constructor(global) {\n    _defineProperty(this, '_environmentGlobal', void 0);\n\n    _defineProperty(this, '_mockState', void 0);\n\n    _defineProperty(this, '_mockConfigRegistry', void 0);\n\n    _defineProperty(this, '_spyState', void 0);\n\n    _defineProperty(this, '_invocationCallCounter', void 0);\n\n    _defineProperty(this, 'ModuleMocker', void 0);\n\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this.ModuleMocker = ModuleMockerClass;\n    this._invocationCallCounter = 1;\n  }\n\n  _getSlots(object) {\n    if (!object) {\n      return [];\n    }\n\n    const slots = new Set();\n    const EnvObjectProto = this._environmentGlobal.Object.prototype;\n    const EnvFunctionProto = this._environmentGlobal.Function.prototype;\n    const EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through\n    // core node modules.\n\n    const ObjectProto = Object.prototype;\n    const FunctionProto = Function.prototype;\n    const RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype\n    // are never reported as slots\n\n    while (\n      object != null &&\n      object !== EnvObjectProto &&\n      object !== EnvFunctionProto &&\n      object !== EnvRegExpProto &&\n      object !== ObjectProto &&\n      object !== FunctionProto &&\n      object !== RegExpProto\n    ) {\n      const ownNames = Object.getOwnPropertyNames(object);\n\n      for (let i = 0; i < ownNames.length; i++) {\n        const prop = ownNames[i];\n\n        if (!isReadonlyProp(object, prop)) {\n          const propDesc = Object.getOwnPropertyDescriptor(object, prop); // @ts-ignore Object.__esModule\n\n          if ((propDesc !== undefined && !propDesc.get) || object.__esModule) {\n            slots.add(prop);\n          }\n        }\n      }\n\n      object = Object.getPrototypeOf(object);\n    }\n\n    return Array.from(slots);\n  }\n\n  _ensureMockConfig(f) {\n    let config = this._mockConfigRegistry.get(f);\n\n    if (!config) {\n      config = this._defaultMockConfig();\n\n      this._mockConfigRegistry.set(f, config);\n    }\n\n    return config;\n  }\n\n  _ensureMockState(f) {\n    let state = this._mockState.get(f);\n\n    if (!state) {\n      state = this._defaultMockState();\n\n      this._mockState.set(f, state);\n    }\n\n    return state;\n  }\n\n  _defaultMockConfig() {\n    return {\n      defaultReturnValue: undefined,\n      isReturnValueLastSet: false,\n      mockImpl: undefined,\n      mockName: 'jest.fn()',\n      specificMockImpls: [],\n      specificReturnValues: []\n    };\n  }\n\n  _defaultMockState() {\n    return {\n      calls: [],\n      instances: [],\n      invocationCallOrder: [],\n      results: []\n    };\n  }\n\n  _makeComponent(metadata, restore) {\n    if (metadata.type === 'object') {\n      return new this._environmentGlobal.Object();\n    } else if (metadata.type === 'array') {\n      return new this._environmentGlobal.Array();\n    } else if (metadata.type === 'regexp') {\n      return new this._environmentGlobal.RegExp('');\n    } else if (\n      metadata.type === 'constant' ||\n      metadata.type === 'collection' ||\n      metadata.type === 'null' ||\n      metadata.type === 'undefined'\n    ) {\n      return metadata.value;\n    } else if (metadata.type === 'function') {\n      const prototype =\n        (metadata.members &&\n          metadata.members.prototype &&\n          metadata.members.prototype.members) ||\n        {};\n\n      const prototypeSlots = this._getSlots(prototype);\n\n      const mocker = this;\n      const mockConstructor = matchArity(function(...args) {\n        const mockState = mocker._ensureMockState(f);\n\n        const mockConfig = mocker._ensureMockConfig(f);\n\n        mockState.instances.push(this);\n        mockState.calls.push(args); // Create and record an \"incomplete\" mock result immediately upon\n        // calling rather than waiting for the mock to return. This avoids\n        // issues caused by recursion where results can be recorded in the\n        // wrong order.\n\n        const mockResult = {\n          type: 'incomplete',\n          value: undefined\n        };\n        mockState.results.push(mockResult);\n        mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown\n\n        let finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)\n\n        let thrownError; // Will be set to true if the mock throws an error. The presence of a\n        // value in `thrownError` is not a 100% reliable indicator because a\n        // function could throw a value of undefined.\n\n        let callDidThrowError = false;\n\n        try {\n          // The bulk of the implementation is wrapped in an immediately\n          // executed arrow function so the return value of the mock function\n          // can be easily captured and recorded, despite the many separate\n          // return points within the logic.\n          finalReturnValue = (() => {\n            if (this instanceof f) {\n              // This is probably being called as a constructor\n              prototypeSlots.forEach(slot => {\n                // Copy prototype methods to the instance to make\n                // it easier to interact with mock instance call and\n                // return values\n                if (prototype[slot].type === 'function') {\n                  // @ts-ignore no index signature\n                  const protoImpl = this[slot]; // @ts-ignore no index signature\n\n                  this[slot] = mocker.generateFromMetadata(prototype[slot]); // @ts-ignore no index signature\n\n                  this[slot]._protoImpl = protoImpl;\n                }\n              }); // Run the mock constructor implementation\n\n              const mockImpl = mockConfig.specificMockImpls.length\n                ? mockConfig.specificMockImpls.shift()\n                : mockConfig.mockImpl;\n              return mockImpl && mockImpl.apply(this, arguments);\n            }\n\n            const returnValue = mockConfig.defaultReturnValue; // If return value is last set, either specific or default, i.e.\n            // mockReturnValueOnce()/mockReturnValue() is called and no\n            // mockImplementationOnce()/mockImplementation() is called after\n            // that.\n            // use the set return value.\n\n            if (mockConfig.specificReturnValues.length) {\n              return mockConfig.specificReturnValues.shift();\n            }\n\n            if (mockConfig.isReturnValueLastSet) {\n              return mockConfig.defaultReturnValue;\n            } // If mockImplementationOnce()/mockImplementation() is last set,\n            // or specific return values are used up, use the mock\n            // implementation.\n\n            let specificMockImpl;\n\n            if (returnValue === undefined) {\n              specificMockImpl = mockConfig.specificMockImpls.shift();\n\n              if (specificMockImpl === undefined) {\n                specificMockImpl = mockConfig.mockImpl;\n              }\n\n              if (specificMockImpl) {\n                return specificMockImpl.apply(this, arguments);\n              }\n            } // Otherwise use prototype implementation\n\n            if (returnValue === undefined && f._protoImpl) {\n              return f._protoImpl.apply(this, arguments);\n            }\n\n            return returnValue;\n          })();\n        } catch (error) {\n          // Store the thrown error so we can record it, then re-throw it.\n          thrownError = error;\n          callDidThrowError = true;\n          throw error;\n        } finally {\n          // Record the result of the function.\n          // NOTE: Intentionally NOT pushing/indexing into the array of mock\n          //       results here to avoid corrupting results data if mockClear()\n          //       is called during the execution of the mock.\n          mockResult.type = callDidThrowError ? 'throw' : 'return';\n          mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n        }\n\n        return finalReturnValue;\n      }, metadata.length || 0);\n\n      const f = this._createMockFunction(metadata, mockConstructor);\n\n      f._isMockFunction = true;\n\n      f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;\n\n      if (typeof restore === 'function') {\n        this._spyState.add(restore);\n      }\n\n      this._mockState.set(f, this._defaultMockState());\n\n      this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n      Object.defineProperty(f, 'mock', {\n        configurable: false,\n        enumerable: true,\n        get: () => this._ensureMockState(f),\n        set: val => this._mockState.set(f, val)\n      });\n\n      f.mockClear = () => {\n        this._mockState.delete(f);\n\n        return f;\n      };\n\n      f.mockReset = () => {\n        f.mockClear();\n\n        this._mockConfigRegistry.delete(f);\n\n        return f;\n      };\n\n      f.mockRestore = () => {\n        f.mockReset();\n        return restore ? restore() : undefined;\n      };\n\n      f.mockReturnValueOnce = value => {\n        // next function call will return this value or default return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.specificReturnValues.push(value);\n        return f;\n      };\n\n      f.mockResolvedValueOnce = value =>\n        f.mockImplementationOnce(() => Promise.resolve(value));\n\n      f.mockRejectedValueOnce = value =>\n        f.mockImplementationOnce(() => Promise.reject(value));\n\n      f.mockReturnValue = value => {\n        // next function call will return specified return value or this one\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.isReturnValueLastSet = true;\n        mockConfig.defaultReturnValue = value;\n        return f;\n      };\n\n      f.mockResolvedValue = value =>\n        f.mockImplementation(() => Promise.resolve(value));\n\n      f.mockRejectedValue = value =>\n        f.mockImplementation(() => Promise.reject(value));\n\n      f.mockImplementationOnce = fn => {\n        // next function call will use this mock implementation return value\n        // or default mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.isReturnValueLastSet = false;\n        mockConfig.specificMockImpls.push(fn);\n        return f;\n      };\n\n      f.mockImplementation = fn => {\n        // next function call will use mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.isReturnValueLastSet = false;\n        mockConfig.defaultReturnValue = undefined;\n        mockConfig.mockImpl = fn;\n        return f;\n      };\n\n      f.mockReturnThis = () =>\n        f.mockImplementation(function() {\n          return this;\n        });\n\n      f.mockName = name => {\n        if (name) {\n          const mockConfig = this._ensureMockConfig(f);\n\n          mockConfig.mockName = name;\n        }\n\n        return f;\n      };\n\n      f.getMockName = () => {\n        const mockConfig = this._ensureMockConfig(f);\n\n        return mockConfig.mockName || 'jest.fn()';\n      };\n\n      if (metadata.mockImpl) {\n        f.mockImplementation(metadata.mockImpl);\n      }\n\n      return f;\n    } else {\n      const unknownType = metadata.type || 'undefined type';\n      throw new Error('Unrecognized type ' + unknownType);\n    }\n  }\n\n  _createMockFunction(metadata, mockConstructor) {\n    let name = metadata.name;\n\n    if (!name) {\n      return mockConstructor;\n    } // Preserve `name` property of mocked function.\n\n    const boundFunctionPrefix = 'bound ';\n    let bindCall = ''; // if-do-while for perf reasons. The common case is for the if to fail.\n\n    if (name && name.startsWith(boundFunctionPrefix)) {\n      do {\n        name = name.substring(boundFunctionPrefix.length); // Call bind() just to alter the function name.\n\n        bindCall = '.bind(null)';\n      } while (name && name.startsWith(boundFunctionPrefix));\n    } // Special case functions named `mockConstructor` to guard for infinite\n    // loops.\n\n    if (name === MOCK_CONSTRUCTOR_NAME) {\n      return mockConstructor;\n    }\n\n    if (\n      // It's a syntax error to define functions with a reserved keyword\n      // as name.\n      RESERVED_KEYWORDS.has(name) || // It's also a syntax error to define functions with a name that starts with a number\n      /^\\d/.test(name)\n    ) {\n      name = '$' + name;\n    } // It's also a syntax error to define a function with a reserved character\n    // as part of it's name.\n\n    if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n      name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n    }\n\n    const body =\n      'return function ' +\n      name +\n      '() {' +\n      'return ' +\n      MOCK_CONSTRUCTOR_NAME +\n      '.apply(this,arguments);' +\n      '}' +\n      bindCall;\n    const createConstructor = new this._environmentGlobal.Function(\n      MOCK_CONSTRUCTOR_NAME,\n      body\n    );\n    return createConstructor(mockConstructor);\n  }\n\n  _generateMock(metadata, callbacks, refs) {\n    // metadata not compatible but it's the same type, maybe problem with\n    // overloading of _makeComponent and not _generateMock?\n    // @ts-ignore\n    const mock = this._makeComponent(metadata);\n\n    if (metadata.refID != null) {\n      refs[metadata.refID] = mock;\n    }\n\n    this._getSlots(metadata.members).forEach(slot => {\n      const slotMetadata = (metadata.members && metadata.members[slot]) || {};\n\n      if (slotMetadata.ref != null) {\n        callbacks.push(\n          (function(ref) {\n            return () => (mock[slot] = refs[ref]);\n          })(slotMetadata.ref)\n        );\n      } else {\n        mock[slot] = this._generateMock(slotMetadata, callbacks, refs);\n      }\n    });\n\n    if (\n      metadata.type !== 'undefined' &&\n      metadata.type !== 'null' &&\n      mock.prototype &&\n      typeof mock.prototype === 'object'\n    ) {\n      mock.prototype.constructor = mock;\n    }\n\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param _metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   */\n\n  generateFromMetadata(_metadata) {\n    const callbacks = [];\n    const refs = {};\n\n    const mock = this._generateMock(_metadata, callbacks, refs);\n\n    callbacks.forEach(setter => setter());\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param component The component for which to retrieve metadata.\n   */\n\n  getMetadata(component, _refs) {\n    const refs = _refs || new Map();\n    const ref = refs.get(component);\n\n    if (ref != null) {\n      return {\n        ref\n      };\n    }\n\n    const type = getType(component);\n\n    if (!type) {\n      return null;\n    }\n\n    const metadata = {\n      type\n    };\n\n    if (\n      type === 'constant' ||\n      type === 'collection' ||\n      type === 'undefined' ||\n      type === 'null'\n    ) {\n      metadata.value = component;\n      return metadata;\n    } else if (type === 'function') {\n      // @ts-ignore this is a function so it has a name\n      metadata.name = component.name; // @ts-ignore may be a mock\n\n      if (component._isMockFunction === true) {\n        // @ts-ignore may be a mock\n        metadata.mockImpl = component.getMockImplementation();\n      }\n    }\n\n    metadata.refID = refs.size;\n    refs.set(component, metadata.refID);\n    let members = null; // Leave arrays alone\n\n    if (type !== 'array') {\n      this._getSlots(component).forEach(slot => {\n        if (\n          type === 'function' && // @ts-ignore may be a mock\n          component._isMockFunction === true &&\n          slot.match(/^mock/)\n        ) {\n          return;\n        } // @ts-ignore no index signature\n\n        const slotMetadata = this.getMetadata(component[slot], refs);\n\n        if (slotMetadata) {\n          if (!members) {\n            members = {};\n          }\n\n          members[slot] = slotMetadata;\n        }\n      });\n    }\n\n    if (members) {\n      metadata.members = members;\n    }\n\n    return metadata;\n  }\n\n  isMockFunction(fn) {\n    return !!fn && fn._isMockFunction === true;\n  }\n\n  fn(implementation) {\n    const length = implementation ? implementation.length : 0;\n\n    const fn = this._makeComponent({\n      length,\n      type: 'function'\n    });\n\n    if (implementation) {\n      fn.mockImplementation(implementation);\n    }\n\n    return fn;\n  }\n\n  spyOn(object, methodName, accessType) {\n    if (accessType) {\n      return this._spyOnProperty(object, methodName, accessType);\n    }\n\n    if (typeof object !== 'object' && typeof object !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given'\n      );\n    }\n\n    const original = object[methodName];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            methodName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead'\n        );\n      }\n\n      const isMethodOwner = object.hasOwnProperty(methodName); // @ts-ignore overriding original method with a Mock\n\n      object[methodName] = this._makeComponent(\n        {\n          type: 'function'\n        },\n        () => {\n          if (isMethodOwner) {\n            object[methodName] = original;\n          } else {\n            delete object[methodName];\n          }\n        }\n      ); // @ts-ignore original method is now a Mock\n\n      object[methodName].mockImplementation(function() {\n        return original.apply(this, arguments);\n      });\n    }\n\n    return object[methodName];\n  }\n\n  _spyOnProperty(obj, propertyName, accessType = 'get') {\n    if (typeof obj !== 'object' && typeof obj !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given'\n      );\n    }\n\n    if (!obj) {\n      throw new Error(\n        'spyOn could not find an object to spy upon for ' + propertyName + ''\n      );\n    }\n\n    if (!propertyName) {\n      throw new Error('No property name supplied');\n    }\n\n    let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n    let proto = Object.getPrototypeOf(obj);\n\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    if (!descriptor) {\n      throw new Error(propertyName + ' property does not exist');\n    }\n\n    if (!descriptor.configurable) {\n      throw new Error(propertyName + ' is not declared configurable');\n    }\n\n    if (!descriptor[accessType]) {\n      throw new Error(\n        'Property ' + propertyName + ' does not have access type ' + accessType\n      );\n    }\n\n    const original = descriptor[accessType];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            propertyName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead'\n        );\n      } // @ts-ignore: mock is assignable\n\n      descriptor[accessType] = this._makeComponent(\n        {\n          type: 'function'\n        },\n        () => {\n          // @ts-ignore: mock is assignable\n          descriptor[accessType] = original;\n          Object.defineProperty(obj, propertyName, descriptor);\n        }\n      );\n      descriptor[accessType].mockImplementation(function() {\n        // @ts-ignore\n        return original.apply(this, arguments);\n      });\n    }\n\n    Object.defineProperty(obj, propertyName, descriptor);\n    return descriptor[accessType];\n  }\n\n  clearAllMocks() {\n    this._mockState = new WeakMap();\n  }\n\n  resetAllMocks() {\n    this._mockConfigRegistry = new WeakMap();\n    this._mockState = new WeakMap();\n  }\n\n  restoreAllMocks() {\n    this._spyState.forEach(restore => restore());\n\n    this._spyState = new Set();\n  }\n\n  _typeOf(value) {\n    return value == null ? '' + value : typeof value;\n  }\n}\n/* eslint-disable-next-line no-redeclare */\n\nconst JestMock = new ModuleMockerClass(global);\nmodule.exports = JestMock;\n"]},"metadata":{},"sourceType":"script"}