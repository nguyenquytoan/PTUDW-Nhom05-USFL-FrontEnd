{"ast":null,"code":"\"use strict\";\n\nconst babel = require(\"@babel/core\");\n\nmodule.exports = function injectCaller(opts, target) {\n  if (!supportsCallerOption()) return opts;\n  return Object.assign({}, opts, {\n    caller: Object.assign({\n      name: \"babel-loader\",\n      // Provide plugins with insight into webpack target.\n      // https://github.com/babel/babel-loader/issues/787\n      target,\n      // Webpack >= 2 supports ESM and dynamic import.\n      supportsStaticESM: true,\n      supportsDynamicImport: true,\n      // Webpack 5 supports TLA behind a flag. We enable it by default\n      // for Babel, and then webpack will throw an error if the experimental\n      // flag isn't enabled.\n      supportsTopLevelAwait: true\n    }, opts.caller)\n  });\n}; // TODO: We can remove this eventually, I'm just adding it so that people have\n// a little time to migrate to the newer RCs of @babel/core without getting\n// hard-to-diagnose errors about unknown 'caller' options.\n\n\nlet supportsCallerOptionFlag = undefined;\n\nfunction supportsCallerOption() {\n  if (supportsCallerOptionFlag === undefined) {\n    try {\n      // Rather than try to match the Babel version, we just see if it throws\n      // when passed a 'caller' flag, and use that to decide if it is supported.\n      babel.loadPartialConfig({\n        caller: undefined,\n        babelrc: false,\n        configFile: false\n      });\n      supportsCallerOptionFlag = true;\n    } catch (err) {\n      supportsCallerOptionFlag = false;\n    }\n  }\n\n  return supportsCallerOptionFlag;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/babel-loader/lib/injectCaller.js"],"names":["babel","require","module","exports","injectCaller","opts","target","supportsCallerOption","Object","assign","caller","name","supportsStaticESM","supportsDynamicImport","supportsTopLevelAwait","supportsCallerOptionFlag","undefined","loadPartialConfig","babelrc","configFile","err"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,MAA5B,EAAoC;AACnD,MAAI,CAACC,oBAAoB,EAAzB,EAA6B,OAAOF,IAAP;AAC7B,SAAOG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,IAAlB,EAAwB;AAC7BK,IAAAA,MAAM,EAAEF,MAAM,CAACC,MAAP,CAAc;AACpBE,MAAAA,IAAI,EAAE,cADc;AAEpB;AACA;AACAL,MAAAA,MAJoB;AAKpB;AACAM,MAAAA,iBAAiB,EAAE,IANC;AAOpBC,MAAAA,qBAAqB,EAAE,IAPH;AAQpB;AACA;AACA;AACAC,MAAAA,qBAAqB,EAAE;AAXH,KAAd,EAYLT,IAAI,CAACK,MAZA;AADqB,GAAxB,CAAP;AAeD,CAjBD,C,CAiBG;AACH;AACA;;;AAGA,IAAIK,wBAAwB,GAAGC,SAA/B;;AAEA,SAAST,oBAAT,GAAgC;AAC9B,MAAIQ,wBAAwB,KAAKC,SAAjC,EAA4C;AAC1C,QAAI;AACF;AACA;AACAhB,MAAAA,KAAK,CAACiB,iBAAN,CAAwB;AACtBP,QAAAA,MAAM,EAAEM,SADc;AAEtBE,QAAAA,OAAO,EAAE,KAFa;AAGtBC,QAAAA,UAAU,EAAE;AAHU,OAAxB;AAKAJ,MAAAA,wBAAwB,GAAG,IAA3B;AACD,KATD,CASE,OAAOK,GAAP,EAAY;AACZL,MAAAA,wBAAwB,GAAG,KAA3B;AACD;AACF;;AAED,SAAOA,wBAAP;AACD","sourcesContent":["\"use strict\";\n\nconst babel = require(\"@babel/core\");\n\nmodule.exports = function injectCaller(opts, target) {\n  if (!supportsCallerOption()) return opts;\n  return Object.assign({}, opts, {\n    caller: Object.assign({\n      name: \"babel-loader\",\n      // Provide plugins with insight into webpack target.\n      // https://github.com/babel/babel-loader/issues/787\n      target,\n      // Webpack >= 2 supports ESM and dynamic import.\n      supportsStaticESM: true,\n      supportsDynamicImport: true,\n      // Webpack 5 supports TLA behind a flag. We enable it by default\n      // for Babel, and then webpack will throw an error if the experimental\n      // flag isn't enabled.\n      supportsTopLevelAwait: true\n    }, opts.caller)\n  });\n}; // TODO: We can remove this eventually, I'm just adding it so that people have\n// a little time to migrate to the newer RCs of @babel/core without getting\n// hard-to-diagnose errors about unknown 'caller' options.\n\n\nlet supportsCallerOptionFlag = undefined;\n\nfunction supportsCallerOption() {\n  if (supportsCallerOptionFlag === undefined) {\n    try {\n      // Rather than try to match the Babel version, we just see if it throws\n      // when passed a 'caller' flag, and use that to decide if it is supported.\n      babel.loadPartialConfig({\n        caller: undefined,\n        babelrc: false,\n        configFile: false\n      });\n      supportsCallerOptionFlag = true;\n    } catch (err) {\n      supportsCallerOptionFlag = false;\n    }\n  }\n\n  return supportsCallerOptionFlag;\n}"]},"metadata":{},"sourceType":"script"}