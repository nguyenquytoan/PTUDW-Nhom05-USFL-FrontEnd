{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst emojisList = require('emojis-list');\n\nconst getHashDigest = require('./getHashDigest');\n\nconst emojiRegex = /[\\uD800-\\uDFFF]./;\nconst emojiList = emojisList.filter(emoji => emojiRegex.test(emoji));\nconst emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n  const emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    const index = Math.floor(Math.random() * emojiList.length);\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  const emojiEncoding = emojis.join('');\n  emojiCache[content] = emojiEncoding;\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  let filename;\n\n  if (typeof name === 'function') {\n    filename = name(loaderContext.resourcePath);\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n  let ext = 'bin';\n  let basename = 'file';\n  let directory = '';\n  let folder = '';\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path.relative(context, resourcePath + '_').replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))).replace(/\\[emoji(?::(\\d+))?\\]/gi, (all, length) => encodeStringToEmoji(content, parseInt(length, 10)));\n  }\n\n  url = url.replace(/\\[ext\\]/gi, () => ext).replace(/\\[name\\]/gi, () => basename).replace(/\\[path\\]/gi, () => directory).replace(/\\[folder\\]/gi, () => folder);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach((matched, i) => {\n      url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n    });\n  }\n\n  if (typeof loaderContext.options === 'object' && typeof loaderContext.options.customInterpolateName === 'function') {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/adjust-sourcemap-loader/node_modules/loader-utils/lib/interpolateName.js"],"names":["path","require","emojisList","getHashDigest","emojiRegex","emojiList","filter","emoji","test","emojiCache","encodeStringToEmoji","content","length","emojis","Error","index","Math","floor","random","push","splice","emojiEncoding","join","interpolateName","loaderContext","name","options","filename","resourcePath","context","regExp","ext","basename","directory","folder","parsed","parse","substr","dir","sep","relative","replace","url","all","hashType","digestType","maxLength","parseInt","match","RegExp","forEach","matched","i","customInterpolateName","call","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst path = require('path');\nconst emojisList = require('emojis-list');\nconst getHashDigest = require('./getHashDigest');\n\nconst emojiRegex = /[\\uD800-\\uDFFF]./;\nconst emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));\nconst emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n\n  const emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    const index = Math.floor(Math.random() * emojiList.length);\n\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  const emojiEncoding = emojis.join('');\n\n  emojiCache[content] = emojiEncoding;\n\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  let filename;\n\n  if (typeof name === 'function') {\n    filename = name(loaderContext.resourcePath);\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = 'bin';\n  let basename = 'file';\n  let directory = '';\n  let folder = '';\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path\n        .relative(context, resourcePath + '_')\n        .replace(/\\\\/g, '/')\n        .replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      )\n      .replace(/\\[emoji(?::(\\d+))?\\]/gi, (all, length) =>\n        encodeStringToEmoji(content, parseInt(length, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === 'object' &&\n    typeof loaderContext.options.customInterpolateName === 'function'\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;\n"]},"metadata":{},"sourceType":"script"}