{"ast":null,"code":"/*!\n * XRegExp.build 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\nexport default (XRegExp => {\n  const REGEX_DATA = 'xregexp';\n  const subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  const parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    const leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    const trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    const flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[`subpattern${subpatternIndex}`] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    const hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? `{{subpattern${subpatternIndex}}}` : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * const h12 = /1[0-2]|0?[1-9]/;\n   * const h24 = /2[0-3]|[01][0-9]/;\n   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n   * const minutes = /^[0-5][0-9]$/;\n   * // Note that explicitly naming the 'minutes' group is required for named backreferences\n   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.tag = flags => (literals, ...substitutions) => {\n    const subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});\n    const pattern = literals.raw.map(embedSubpatternAfter).join('');\n    return XRegExp.build(pattern, subpatterns, flags);\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.build = (pattern, subs, flags) => {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    const addFlagX = flags.includes('x');\n    const inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    const data = {};\n\n    for (const p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        const sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    const patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    let numCaps = 0;\n    let numPriorCaps;\n    let numOuterCaps = 0;\n    const outerCapsMap = [0];\n    const outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    const output = patternAsRegex.source.replace(parts, ($0, $1, $2, $3, $4) => {\n      const subName = $1 || $2;\n      let capName;\n      let intro;\n      let localCapIndex; // Named subpattern\n\n      if (subName) {\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(`Undefined property ${$0}`);\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = `(?<${capName || subName}>`;\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        const rewrittenSubpattern = data[subName].pattern.replace(subParts, (match, paren, backref) => {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return `(?<${capName}>`;\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            `\\\\k<${data[subName].names[localCapIndex]}>` : `\\\\${+backref + numPriorCaps}`;\n          }\n\n          return match;\n        });\n        return `${intro}${rewrittenSubpattern})`;\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return `(?<${capName}>`;\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        `\\\\k<${outerCapNames[localCapIndex]}>` : `\\\\${outerCapsMap[+$4]}`;\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/src/addons/build.js"],"names":["XRegExp","REGEX_DATA","subParts","parts","union","conjunction","deanchor","pattern","leadingAnchor","trailingAnchor","test","replace","asXRegExp","value","addFlagX","flags","isRegExp","captureNames","source","interpolate","substitution","RegExp","escape","reduceToSubpatternsObject","subpatterns","interpolated","subpatternIndex","embedSubpatternAfter","raw","rawLiterals","hasSubpattern","length","tag","literals","substitutions","map","reduce","join","build","subs","includes","inlineFlags","exec","_clipDuplicates","data","p","hasOwnProperty","sub","names","patternAsRegex","numCaps","numPriorCaps","numOuterCaps","outerCapsMap","outerCapNames","output","$0","$1","$2","$3","$4","subName","capName","intro","localCapIndex","ReferenceError","rewrittenSubpattern","match","paren","backref"],"mappings":"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","sourcesContent":["/*!\n * XRegExp.build 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\n\nexport default (XRegExp) => {\n    const REGEX_DATA = 'xregexp';\n    const subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n    const parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n        conjunction: 'or'\n    });\n\n    /**\n     * Strips a leading `^` and trailing unescaped `$`, if both are present.\n     *\n     * @private\n     * @param {String} pattern Pattern to process.\n     * @returns {String} Pattern with edge anchors removed.\n     */\n    function deanchor(pattern) {\n        // Allow any number of empty noncapturing groups before/after anchors, because regexes\n        // built/generated by XRegExp sometimes include them\n        const leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n        const trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n        if (\n            leadingAnchor.test(pattern) &&\n            trailingAnchor.test(pattern) &&\n            // Ensure that the trailing `$` isn't escaped\n            trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))\n        ) {\n            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n        }\n\n        return pattern;\n    }\n\n    /**\n     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n     *\n     * @private\n     * @param {String|RegExp} value Value to convert.\n     * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n     *   already a regex generated by XRegExp\n     * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n     */\n    function asXRegExp(value, addFlagX) {\n        const flags = addFlagX ? 'x' : '';\n        return XRegExp.isRegExp(value) ?\n            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?\n                // Don't recompile, to preserve capture names\n                value :\n                // Recompile as XRegExp\n                XRegExp(value.source, flags)\n            ) :\n            // Compile string as XRegExp\n            XRegExp(value, flags);\n    }\n\n    function interpolate(substitution) {\n        return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n    }\n\n    function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n        subpatterns[`subpattern${subpatternIndex}`] = interpolated;\n        return subpatterns;\n    }\n\n    function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n        const hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n        return raw + (hasSubpattern ? `{{subpattern${subpatternIndex}}}` : '');\n    }\n\n    /**\n     * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n     * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n     *\n     * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n     * patterns are treated as atomic units when quantified, interpolated strings have their special\n     * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n     * regexes if both are present, and any backreferences within an interpolated regex are\n     * rewritten to work within the overall pattern.\n     *\n     * @memberOf XRegExp\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n     * @example\n     *\n     * const h12 = /1[0-2]|0?[1-9]/;\n     * const h24 = /2[0-3]|[01][0-9]/;\n     * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n     * const minutes = /^[0-5][0-9]$/;\n     * // Note that explicitly naming the 'minutes' group is required for named backreferences\n     * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n     * time.test('10:59'); // -> true\n     * XRegExp.exec('10:59', time).minutes; // -> '59'\n     */\n    XRegExp.tag = (flags) => (literals, ...substitutions) => {\n        const subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});\n        const pattern = literals.raw.map(embedSubpatternAfter).join('');\n        return XRegExp.build(pattern, subpatterns, flags);\n    };\n\n    /**\n     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n     *\n     * @memberOf XRegExp\n     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n     *   character classes.\n     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @returns {RegExp} Regex with interpolated subpatterns.\n     * @example\n     *\n     * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n     *     h12: /1[0-2]|0?[1-9]/,\n     *     h24: /2[0-3]|[01][0-9]/\n     *   }, 'x'),\n     *   minutes: /^[0-5][0-9]$/\n     * });\n     * time.test('10:59'); // -> true\n     * XRegExp.exec('10:59', time).minutes; // -> '59'\n     */\n    XRegExp.build = (pattern, subs, flags) => {\n        flags = flags || '';\n        // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n        // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n        // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n        const addFlagX = flags.includes('x');\n        const inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern);\n        // Add flags within a leading mode modifier to the overall pattern's flags\n        if (inlineFlags) {\n            flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n        }\n\n        const data = {};\n        for (const p in subs) {\n            if (subs.hasOwnProperty(p)) {\n                // Passing to XRegExp enables extended syntax and ensures independent validity,\n                // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n                // subpatterns provided as native regexes, it dies on octals and adds the property\n                // used to hold extended regex instance data, for simplicity.\n                const sub = asXRegExp(subs[p], addFlagX);\n                data[p] = {\n                    // Deanchoring allows embedding independently useful anchored regexes. If you\n                    // really need to keep your anchors, double them (i.e., `^^...$$`).\n                    pattern: deanchor(sub.source),\n                    names: sub[REGEX_DATA].captureNames || []\n                };\n            }\n        }\n\n        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n        // helps keep this simple. Named captures will be put back.\n        const patternAsRegex = asXRegExp(pattern, addFlagX);\n\n        // 'Caps' is short for 'captures'\n        let numCaps = 0;\n        let numPriorCaps;\n        let numOuterCaps = 0;\n        const outerCapsMap = [0];\n        const outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n        const output = patternAsRegex.source.replace(parts, ($0, $1, $2, $3, $4) => {\n            const subName = $1 || $2;\n            let capName;\n            let intro;\n            let localCapIndex;\n            // Named subpattern\n            if (subName) {\n                if (!data.hasOwnProperty(subName)) {\n                    throw new ReferenceError(`Undefined property ${$0}`);\n                }\n                // Named subpattern was wrapped in a capturing group\n                if ($1) {\n                    capName = outerCapNames[numOuterCaps];\n                    outerCapsMap[++numOuterCaps] = ++numCaps;\n                    // If it's a named group, preserve the name. Otherwise, use the subpattern name\n                    // as the capture name\n                    intro = `(?<${capName || subName}>`;\n                } else {\n                    intro = '(?:';\n                }\n                numPriorCaps = numCaps;\n                const rewrittenSubpattern = data[subName].pattern.replace(subParts, (match, paren, backref) => {\n                    // Capturing group\n                    if (paren) {\n                        capName = data[subName].names[numCaps - numPriorCaps];\n                        ++numCaps;\n                        // If the current capture has a name, preserve the name\n                        if (capName) {\n                            return `(?<${capName}>`;\n                        }\n                    // Backreference\n                    } else if (backref) {\n                        localCapIndex = +backref - 1;\n                        // Rewrite the backreference\n                        return data[subName].names[localCapIndex] ?\n                            // Need to preserve the backreference name in case using flag `n`\n                            `\\\\k<${data[subName].names[localCapIndex]}>` :\n                            `\\\\${+backref + numPriorCaps}`;\n                    }\n                    return match;\n                });\n                return `${intro}${rewrittenSubpattern})`;\n            }\n            // Capturing group\n            if ($3) {\n                capName = outerCapNames[numOuterCaps];\n                outerCapsMap[++numOuterCaps] = ++numCaps;\n                // If the current capture has a name, preserve the name\n                if (capName) {\n                    return `(?<${capName}>`;\n                }\n            // Backreference\n            } else if ($4) {\n                localCapIndex = +$4 - 1;\n                // Rewrite the backreference\n                return outerCapNames[localCapIndex] ?\n                    // Need to preserve the backreference name in case using flag `n`\n                    `\\\\k<${outerCapNames[localCapIndex]}>` :\n                    `\\\\${outerCapsMap[+$4]}`;\n            }\n            return $0;\n        });\n\n        return XRegExp(output, flags);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}