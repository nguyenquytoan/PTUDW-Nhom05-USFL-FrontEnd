{"ast":null,"code":"/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      CodePathSegment = require(\"./code-path-segment\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\n\n\nfunction makeSegments(context, begin, end, create) {\n  const list = context.segmentsList;\n  const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n  const normalizedEnd = end >= 0 ? end : list.length + end;\n  const segments = [];\n\n  for (let i = 0; i < context.count; ++i) {\n    const allPrevSegments = [];\n\n    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n      allPrevSegments.push(list[j][i]);\n    }\n\n    segments.push(create(context.idGenerator.next(), allPrevSegments));\n  }\n\n  return segments;\n}\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\n\n\nfunction mergeExtraSegments(context, segments) {\n  let currentSegments = segments;\n\n  while (currentSegments.length > context.count) {\n    const merged = [];\n\n    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n      merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));\n    }\n\n    currentSegments = merged;\n  }\n\n  return currentSegments;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\n\n\nclass ForkContext {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @param {ForkContext|null} upper An upper fork context.\n   * @param {number} count A number of parallel segments.\n   */\n  constructor(idGenerator, upper, count) {\n    this.idGenerator = idGenerator;\n    this.upper = upper;\n    this.count = count;\n    this.segmentsList = [];\n  }\n  /**\n   * The head segments.\n   * @type {CodePathSegment[]}\n   */\n\n\n  get head() {\n    const list = this.segmentsList;\n    return list.length === 0 ? [] : list[list.length - 1];\n  }\n  /**\n   * A flag which shows empty.\n   * @type {boolean}\n   */\n\n\n  get empty() {\n    return this.segmentsList.length === 0;\n  }\n  /**\n   * A flag which shows reachable.\n   * @type {boolean}\n   */\n\n\n  get reachable() {\n    const segments = this.head;\n    return segments.length > 0 && segments.some(isReachable);\n  }\n  /**\n   * Creates new segments from this context.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n\n\n  makeNext(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newNext);\n  }\n  /**\n   * Creates new segments from this context.\n   * The new segments is always unreachable.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n\n\n  makeUnreachable(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n  }\n  /**\n   * Creates new segments from this context.\n   * The new segments don't have connections for previous segments.\n   * But these inherit the reachable flag from this context.\n   * @param {number} begin The first index of previous segments.\n   * @param {number} end The last index of previous segments.\n   * @returns {CodePathSegment[]} New segments.\n   */\n\n\n  makeDisconnected(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n  }\n  /**\n   * Adds segments into this context.\n   * The added segments become the head.\n   * @param {CodePathSegment[]} segments Segments to add.\n   * @returns {void}\n   */\n\n\n  add(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.push(mergeExtraSegments(this, segments));\n  }\n  /**\n   * Replaces the head segments with given segments.\n   * The current head segments are removed.\n   * @param {CodePathSegment[]} segments Segments to add.\n   * @returns {void}\n   */\n\n\n  replaceHead(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n  }\n  /**\n   * Adds all segments of a given fork context into this context.\n   * @param {ForkContext} context A fork context to add.\n   * @returns {void}\n   */\n\n\n  addAll(context) {\n    assert(context.count === this.count);\n    const source = context.segmentsList;\n\n    for (let i = 0; i < source.length; ++i) {\n      this.segmentsList.push(source[i]);\n    }\n  }\n  /**\n   * Clears all secments in this context.\n   * @returns {void}\n   */\n\n\n  clear() {\n    this.segmentsList = [];\n  }\n  /**\n   * Creates the root fork context.\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\n   * @returns {ForkContext} New fork context.\n   */\n\n\n  static newRoot(idGenerator) {\n    const context = new ForkContext(idGenerator, null, 1);\n    context.add([CodePathSegment.newRoot(idGenerator.next())]);\n    return context;\n  }\n  /**\n   * Creates an empty fork context preceded by a given context.\n   * @param {ForkContext} parentContext The parent fork context.\n   * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n   * @returns {ForkContext} New fork context.\n   */\n\n\n  static newEmpty(parentContext, forkLeavingPath) {\n    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);\n  }\n\n}\n\nmodule.exports = ForkContext;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/code-path-analysis/fork-context.js"],"names":["assert","require","CodePathSegment","isReachable","segment","reachable","makeSegments","context","begin","end","create","list","segmentsList","normalizedBegin","length","normalizedEnd","segments","i","count","allPrevSegments","j","push","idGenerator","next","mergeExtraSegments","currentSegments","merged","newNext","ForkContext","constructor","upper","head","empty","some","makeNext","makeUnreachable","newUnreachable","makeDisconnected","newDisconnected","add","replaceHead","splice","addAll","source","clear","newRoot","newEmpty","parentContext","forkLeavingPath","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n    const normalizedEnd = end >= 0 ? end : list.length + end;\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n        currentSegments = merged;\n    }\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @param {ForkContext|null} upper An upper fork context.\n     * @param {number} count A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     * @param {ForkContext} context A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all secments in this context.\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     * @param {ForkContext} parentContext The parent fork context.\n     * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n"]},"metadata":{},"sourceType":"script"}