{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/parse-int\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\n\nvar _flags = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/flags\"));\n/*!\n * XRegExp 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\n\n\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = (0, _flags.default)(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar _ref = {},\n    toString = _ref.toString;\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag);\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var _context;\n\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (var p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort.default)(_context = xFlags.split('')).call(_context).join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  var _context2;\n\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  var xData = regex[REGEX_DATA] || {};\n  var flags = getNativeFlags(regex);\n  var flagsToAdd = '';\n  var flagsToRemove = '';\n  var xregexpSource = null;\n  var xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(\"[\".concat(flagsToRemove, \"]+\"), 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if ((0, _flags.default)(xData) != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags.default)(xData) + flagsToAdd) : (0, _flags.default)(xData);\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice.default)(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\n\n\nfunction dec(hex) {\n  return (0, _parseInt2.default)(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if ( // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? (0, _flags.default)(regex) : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\n\n\nfunction hex(dec) {\n  return (0, _parseInt2.default)(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  var inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  var lineCommentPattern = '#[^#\\\\n]*';\n  var quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call((0, _includes.default)(flags).call(flags, 'x') ? // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ : // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, (0, _slice.default)(pattern).call(pattern, pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === \"[object \".concat(type, \"]\");\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = \"0\".concat(str);\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator2.default)(flags), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var flag = _step.value;\n\n      if (!registeredFlags[flag]) {\n        throw new SyntaxError(\"Unknown regex flag \".concat(flag));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n\nfunction prepareOptions(value) {\n  var options = {};\n\n  if (isType(value, 'String')) {\n    (0, _forEach.default)(XRegExp).call(XRegExp, value, /[^\\s,]+/, function (match) {\n      options[match] = true;\n    });\n    return options;\n  }\n\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length;\n  var leadChar = pattern[pos];\n  var result = null;\n  var match;\n  var t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes.default)(flags).call(flags, t.flag)) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && !(0, _includes.default)(flags).call(flags, 'A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = (0, _flags.default)(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = (0, _slice.default)(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice.default)(appliedPattern).call(appliedPattern, pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\n            _XRegExp$exec2 = (0, _slicedToArray2.default)(_XRegExp$exec, 1),\n            token = _XRegExp$exec2[0];\n\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, (0, _flags.default)(generated)), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = /(?:)/; // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.3.0'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var _options = options,\n      optionalFlags = _options.optionalFlags;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = (0, _getIterator2.default)(optionalFlags), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var flag = _step2.value;\n        registerFlag(flag);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n\nXRegExp.escape = function (str) {\n  return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g';\n  var addY = false;\n  var fakeY = false;\n  var match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? \"\".concat(regex.source, \"|()\") : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n\nXRegExp.forEach = function (str, regex, callback) {\n  var pos = 0;\n  var i = -1;\n  var match;\n\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n\nXRegExp.globalize = function (regex) {\n  return copyRegex(regex, {\n    addG: true\n  });\n};\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\n\nXRegExp.install = function (options) {\n  options = prepareOptions(options);\n\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]';\n}; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n\nXRegExp.match = function (str, regex, scope) {\n  var global = regex.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  var result = nativ.match.call(toObject(str), r2);\n\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n\nXRegExp.matchChain = function (str, chain) {\n  return function recurseChain(values, level) {\n    var item = chain[level].regex ? chain[level] : {\n      regex: chain[level]\n    };\n    var matches = [];\n\n    function addMatch(match) {\n      if (item.backref) {\n        var ERR_UNDEFINED_GROUP = \"Backreference to undefined group: \".concat(item.backref);\n        var isNamedBackref = isNaN(item.backref);\n\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n          if (!(item.backref in match.groups)) {\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\n          }\n        } else if (!match.hasOwnProperty(item.backref)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n        matches.push(backrefValue || '');\n      } else {\n        matches.push(match[0]);\n      }\n    }\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (0, _getIterator2.default)(values), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var value = _step3.value;\n        (0, _forEach.default)(XRegExp).call(XRegExp, value, item.regex, addMatch);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n  }([str], 0);\n};\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search);\n  var global = search.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  var s2 = search;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  var result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\n\nXRegExp.replaceEach = function (str, replacements) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = (0, _getIterator2.default)(replacements), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var r = _step4.value;\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n\nXRegExp.split = function (str, separator, limit) {\n  return fixed.split.call(toObject(str), separator, limit);\n};\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\n\nXRegExp.test = function (str, regex, pos, sticky) {\n  return !!XRegExp.exec(str, regex, pos, sticky);\n};\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\n\nXRegExp.uninstall = function (options) {\n  options = prepareOptions(options);\n\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\n\nXRegExp.union = function (patterns, flags, options) {\n  options = options || {};\n  var conjunction = options.conjunction || 'or';\n  var numCaptures = 0;\n  var numPriorCaptures;\n  var captureNames;\n\n  function rewrite(match, paren, backref) {\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return \"(?<\".concat(name, \">\");\n      } // Backreference\n\n    } else if (backref) {\n      // Rewrite the backreference\n      return \"\\\\\".concat(+backref + numPriorCaptures);\n    }\n\n    return match;\n  }\n\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var output = [];\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = (0, _getIterator2.default)(patterns), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var pattern = _step5.value;\n\n      if (XRegExp.isRegExp(pattern)) {\n        numPriorCaptures = numCaptures;\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n        // independently valid; helps keep this simple. Named captures are put back\n\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n      } else {\n        output.push(XRegExp.escape(pattern));\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  var separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex;\n  var match = nativ.exec.apply(this, arguments);\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && (0, _includes.default)(match).call(match, '')) {\n      var _context3;\n\n      var r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call((0, _slice.default)(_context3 = String(str)).call(_context3, match.index), r2, function () {\n        var len = arguments.length; // Skip index 0 and the last 2\n\n        for (var i = 1; i < len - 2; ++i) {\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    var groupsObject = match;\n\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = (0, _create.default)(null);\n      groupsObject = match.groups;\n    }\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (var i = 1; i < match.length; ++i) {\n        var name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\n\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search);\n  var origLastIndex;\n  var captureNames;\n  var result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (captureNames) {\n        var groupsObject;\n\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = (0, _create.default)(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          groupsObject = args[0];\n        } // Store named backreferences\n\n\n        for (var i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n      // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n\n\n      if (isRegex && search.global) {\n        search.lastIndex = args[args.length - 2] + args[0].length;\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement.apply(void 0, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          var n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? (0, _indexOf.default)(captureNames).call(captureNames, bracketed) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if (dollarToken === '`') {\n          var _context4; // $` (left context)\n\n\n          return (0, _slice.default)(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\n        }\n\n        if (dollarToken === \"'\") {\n          var _context5; // $' (right context)\n\n\n          return (0, _slice.default)(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError(\"Invalid token \".concat($0));\n      }\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  var str = String(this);\n  var output = [];\n  var origLastIndex = separator.lastIndex;\n  var lastLastIndex = 0;\n  var lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  (0, _forEach.default)(XRegExp).call(XRegExp, str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push((0, _slice.default)(str).call(str, lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, (0, _slice.default)(match).call(match, 1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push((0, _slice.default)(str).call(str, lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? (0, _slice.default)(output).call(output, 0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError(\"Invalid escape \".concat(match[0]));\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return \"\\\\u\".concat(pad4(hex(code)));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && (0, _includes.default)(flags).call(flags, 'u')) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nfunction (match) {\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n},\n/* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  var _context6, _context7; // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n  var index = isNaN(match[1]) ? (0, _indexOf.default)(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\n  var endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return (0, _concat.default)(_context7 = \"\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  var _context8; // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n\n\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));\n  }\n\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));\n  }\n\n  if ((0, _includes.default)(_context8 = this.captureNames).call(_context8, match[1])) {\n    throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if ((0, _includes.default)(flags).call(flags, 'n')) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nvar _default = XRegExp;\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/lib/xregexp.js"],"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_concat","_indexOf","_create","_slicedToArray2","_forEach","_getIterator2","_includes","_parseInt2","_slice","_sort","_flags","REGEX_DATA","features","astral","namespacing","nativ","exec","RegExp","prototype","test","match","String","replace","split","fixed","regexCache","patternCache","tokens","defaultScope","classScope","nativeTokens","replacementToken","correctExecNpcg","call","undefined","hasFlagsProp","_ref","toString","hasNativeFlag","flag","isSupported","exception","hasNativeU","hasNativeY","registeredFlags","g","i","m","u","y","augment","regex","captureNames","xSource","xFlags","isInternalOnly","_context","__proto__","XRegExp","p","source","flags","join","clipDuplicates","str","copyRegex","options","_context2","isRegExp","TypeError","xData","getNativeFlags","flagsToAdd","flagsToRemove","xregexpSource","xregexpFlags","removeG","removeY","concat","addG","addY","hasNamedCapture","dec","hex","getContextualTokenSeparator","scope","input","index","length","substr","isQuantifierNext","pattern","pos","inlineCommentPattern","lineCommentPattern","quantifierPattern","isType","type","pad4","prepareFlags","SyntaxError","$0","$1","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","err","return","prepareOptions","registerFlag","Error","runTokens","context","leadChar","result","t","matchLength","output","handler","reparse","setAstral","on","setNamespacing","toObject","isInstalled","applied","appliedPattern","appliedFlags","_XRegExp$exec","_XRegExp$exec2","token","captures","generated","version","_clipDuplicates","_hasNativeFlag","_dec","_hex","_pad4","addToken","_options","optionalFlags","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","push","cache","flush","cacheName","escape","sticky","cacheKey","fakeY","r2","lastIndex","pop","global","forEach","callback","globalize","install","feature","matchChain","chain","recurseChain","values","level","item","matches","addMatch","backref","ERR_UNDEFINED_GROUP","isNamedBackref","isNaN","groups","ReferenceError","hasOwnProperty","backrefValue","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","search","replacement","isRegex","s2","replaceEach","replacements","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","r","separator","limit","uninstall","union","patterns","conjunction","numCaptures","numPriorCaptures","rewrite","paren","name","parts","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","origLastIndex","apply","arguments","_context3","len","groupsObject","_len","args","Array","_key","_len2","_key2","replacer","bracketed","angled","dollarToken","n","_context4","_context5","lastLastIndex","lastLength","code","_context6","_context7","endIndex","_context8","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/parse-int\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\n\nvar _flags = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/flags\"));\n\n/*!\n * XRegExp 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = (0, _flags.default)(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar _ref = {},\n    toString = _ref.toString;\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag);\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var _context;\n\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (var p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort.default)(_context = xFlags.split('')).call(_context).join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  var _context2;\n\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  var xData = regex[REGEX_DATA] || {};\n  var flags = getNativeFlags(regex);\n  var flagsToAdd = '';\n  var flagsToRemove = '';\n  var xregexpSource = null;\n  var xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(\"[\".concat(flagsToRemove, \"]+\"), 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if ((0, _flags.default)(xData) != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags.default)(xData) + flagsToAdd) : (0, _flags.default)(xData);\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice.default)(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\n\n\nfunction dec(hex) {\n  return (0, _parseInt2.default)(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if ( // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? (0, _flags.default)(regex) : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\n\n\nfunction hex(dec) {\n  return (0, _parseInt2.default)(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  var inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  var lineCommentPattern = '#[^#\\\\n]*';\n  var quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call((0, _includes.default)(flags).call(flags, 'x') ? // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ : // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, (0, _slice.default)(pattern).call(pattern, pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === \"[object \".concat(type, \"]\");\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = \"0\".concat(str);\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator2.default)(flags), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var flag = _step.value;\n\n      if (!registeredFlags[flag]) {\n        throw new SyntaxError(\"Unknown regex flag \".concat(flag));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n\nfunction prepareOptions(value) {\n  var options = {};\n\n  if (isType(value, 'String')) {\n    (0, _forEach.default)(XRegExp).call(XRegExp, value, /[^\\s,]+/, function (match) {\n      options[match] = true;\n    });\n    return options;\n  }\n\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length;\n  var leadChar = pattern[pos];\n  var result = null;\n  var match;\n  var t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes.default)(flags).call(flags, t.flag)) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && !(0, _includes.default)(flags).call(flags, 'A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = (0, _flags.default)(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = (0, _slice.default)(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice.default)(appliedPattern).call(appliedPattern, pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\n            _XRegExp$exec2 = (0, _slicedToArray2.default)(_XRegExp$exec, 1),\n            token = _XRegExp$exec2[0];\n\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, (0, _flags.default)(generated)), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = /(?:)/; // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.3.0'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var _options = options,\n      optionalFlags = _options.optionalFlags;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = (0, _getIterator2.default)(optionalFlags), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var flag = _step2.value;\n        registerFlag(flag);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n\nXRegExp.escape = function (str) {\n  return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g';\n  var addY = false;\n  var fakeY = false;\n  var match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? \"\".concat(regex.source, \"|()\") : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n\nXRegExp.forEach = function (str, regex, callback) {\n  var pos = 0;\n  var i = -1;\n  var match;\n\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n\nXRegExp.globalize = function (regex) {\n  return copyRegex(regex, {\n    addG: true\n  });\n};\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\n\nXRegExp.install = function (options) {\n  options = prepareOptions(options);\n\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]';\n}; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n\nXRegExp.match = function (str, regex, scope) {\n  var global = regex.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  var result = nativ.match.call(toObject(str), r2);\n\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n\nXRegExp.matchChain = function (str, chain) {\n  return function recurseChain(values, level) {\n    var item = chain[level].regex ? chain[level] : {\n      regex: chain[level]\n    };\n    var matches = [];\n\n    function addMatch(match) {\n      if (item.backref) {\n        var ERR_UNDEFINED_GROUP = \"Backreference to undefined group: \".concat(item.backref);\n        var isNamedBackref = isNaN(item.backref);\n\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n          if (!(item.backref in match.groups)) {\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\n          }\n        } else if (!match.hasOwnProperty(item.backref)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n        matches.push(backrefValue || '');\n      } else {\n        matches.push(match[0]);\n      }\n    }\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (0, _getIterator2.default)(values), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var value = _step3.value;\n        (0, _forEach.default)(XRegExp).call(XRegExp, value, item.regex, addMatch);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n  }([str], 0);\n};\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search);\n  var global = search.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  var s2 = search;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  var result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\n\nXRegExp.replaceEach = function (str, replacements) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = (0, _getIterator2.default)(replacements), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var r = _step4.value;\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n\nXRegExp.split = function (str, separator, limit) {\n  return fixed.split.call(toObject(str), separator, limit);\n};\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\n\nXRegExp.test = function (str, regex, pos, sticky) {\n  return !!XRegExp.exec(str, regex, pos, sticky);\n};\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\n\nXRegExp.uninstall = function (options) {\n  options = prepareOptions(options);\n\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\n\nXRegExp.union = function (patterns, flags, options) {\n  options = options || {};\n  var conjunction = options.conjunction || 'or';\n  var numCaptures = 0;\n  var numPriorCaptures;\n  var captureNames;\n\n  function rewrite(match, paren, backref) {\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return \"(?<\".concat(name, \">\");\n      } // Backreference\n\n    } else if (backref) {\n      // Rewrite the backreference\n      return \"\\\\\".concat(+backref + numPriorCaptures);\n    }\n\n    return match;\n  }\n\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var output = [];\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = (0, _getIterator2.default)(patterns), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var pattern = _step5.value;\n\n      if (XRegExp.isRegExp(pattern)) {\n        numPriorCaptures = numCaptures;\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n        // independently valid; helps keep this simple. Named captures are put back\n\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n      } else {\n        output.push(XRegExp.escape(pattern));\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  var separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex;\n  var match = nativ.exec.apply(this, arguments);\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && (0, _includes.default)(match).call(match, '')) {\n      var _context3;\n\n      var r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call((0, _slice.default)(_context3 = String(str)).call(_context3, match.index), r2, function () {\n        var len = arguments.length; // Skip index 0 and the last 2\n\n        for (var i = 1; i < len - 2; ++i) {\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    var groupsObject = match;\n\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = (0, _create.default)(null);\n      groupsObject = match.groups;\n    }\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (var i = 1; i < match.length; ++i) {\n        var name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\n\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search);\n  var origLastIndex;\n  var captureNames;\n  var result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (captureNames) {\n        var groupsObject;\n\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = (0, _create.default)(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          groupsObject = args[0];\n        } // Store named backreferences\n\n\n        for (var i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n      // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n\n\n      if (isRegex && search.global) {\n        search.lastIndex = args[args.length - 2] + args[0].length;\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement.apply(void 0, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          var n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? (0, _indexOf.default)(captureNames).call(captureNames, bracketed) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if (dollarToken === '`') {\n          var _context4;\n\n          // $` (left context)\n          return (0, _slice.default)(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\n        }\n\n        if (dollarToken === \"'\") {\n          var _context5;\n\n          // $' (right context)\n          return (0, _slice.default)(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError(\"Invalid token \".concat($0));\n      }\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  var str = String(this);\n  var output = [];\n  var origLastIndex = separator.lastIndex;\n  var lastLastIndex = 0;\n  var lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  (0, _forEach.default)(XRegExp).call(XRegExp, str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push((0, _slice.default)(str).call(str, lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, (0, _slice.default)(match).call(match, 1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push((0, _slice.default)(str).call(str, lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? (0, _slice.default)(output).call(output, 0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError(\"Invalid escape \".concat(match[0]));\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return \"\\\\u\".concat(pad4(hex(code)));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && (0, _includes.default)(flags).call(flags, 'u')) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nfunction (match) {\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n},\n/* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  var _context6, _context7;\n\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  var index = isNaN(match[1]) ? (0, _indexOf.default)(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\n  var endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return (0, _concat.default)(_context7 = \"\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  var _context8;\n\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));\n  }\n\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));\n  }\n\n  if ((0, _includes.default)(_context8 = this.captureNames).call(_context8, match[1])) {\n    throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if ((0, _includes.default)(flags).call(flags, 'n')) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nvar _default = XRegExp;\nexports.default = _default;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}