{"ast":null,"code":"'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/; // The map to `acorn-jsx` tokens from `acorn` namespace objects.\n\nconst acornJsxMap = new WeakMap(); // Get the original tokens for the given `acorn` namespace object.\n\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {\n        beforeExpr: true\n      }),\n      jsxTagStart: new TokenType('jsxTagStart'),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function () {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n\n      this.context.push(tc_oTag); // start opening tag context\n\n      this.exprAllowed = false;\n    };\n\n    tokTypes.jsxTagEnd.updateContext = function (prevType) {\n      let out = this.context.pop();\n\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = {\n      tokContexts: tokContexts,\n      tokTypes: tokTypes\n    };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n} // Transforms JSX element name to string.\n\n\nfunction getQualifiedJSXName(object) {\n  if (!object) return object;\n  if (object.type === 'JSXIdentifier') return object.name;\n  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;\n  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function (options) {\n  options = options || {};\n  return function (Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n}; // This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\n\n\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    } // Reads inline JSX contents token.\n\n\n    jsx_readToken() {\n      let out = '',\n          chunkStart = this.pos;\n\n      for (;;) {\n        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n          case 60: // '<'\n\n          case 123:\n            // '{'\n            if (this.pos === this.start) {\n              if (ch === 60 && this.exprAllowed) {\n                ++this.pos;\n                return this.finishToken(tok.jsxTagStart);\n              }\n\n              return this.getTokenFromCode(ch);\n            }\n\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(tok.jsxText, out);\n\n          case 38:\n            // '&'\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readEntity();\n            chunkStart = this.pos;\n            break;\n\n          case 62: // '>'\n\n          case 125:\n            // '}'\n            this.raise(this.pos, \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" + (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\");\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.pos);\n              out += this.jsx_readNewLine(true);\n              chunkStart = this.pos;\n            } else {\n              ++this.pos;\n            }\n\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '',\n          chunkStart = ++this.pos;\n\n      for (;;) {\n        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n\n        if (ch === 38) {\n          // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '',\n          count = 0,\n          entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n\n          break;\n        }\n\n        str += ch;\n      }\n\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n\n      return entity;\n    } // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n\n    jsx_readWord() {\n      let ch,\n          start = this.pos;\n\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n\n\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    } // Parse next token as JSX identifier\n\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    } // Parse namespaced identifier.\n\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start,\n          startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    } // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start,\n          startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n\n      return node;\n    } // Parses any type of JSX attribute value.\n\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n        case tt.braceL:\n          let node = this.jsx_parseExpressionContainer();\n          if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n          return node;\n\n        case tok.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    } // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    } // Parses JSX expression enclosed into curly brackets.\n\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    } // Parses following JSX attribute name-value pair.\n\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    } // Parses JSX opening tag starting after '<'.\n\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());\n\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    } // Parses JSX closing tag starting after '</'.\n\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    } // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n            case tok.jsxTagStart:\n              startPos = this.start;\n              startLoc = this.startLoc;\n              this.next();\n\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n                break contents;\n              }\n\n              children.push(this.jsx_parseElementAt(startPos, startLoc));\n              break;\n\n            case tok.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL:\n              children.push(this.jsx_parseExpressionContainer());\n              break;\n\n            default:\n              this.unexpected();\n          }\n        }\n\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    } // Parse JSX text\n\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    } // Parses entire JSX element from current position.\n\n\n    jsx_parseElement() {\n      let startPos = this.start,\n          startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n\n        this.context.push(tc_cTag); // reconsider as closing tag context\n\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/acorn-jsx/index.js"],"names":["XHTMLEntities","require","hexNumber","decimalNumber","acornJsxMap","WeakMap","getJsxTokens","acorn","Parser","acornJsx","get","tt","tokTypes","TokContext","TokenType","tc_oTag","tc_cTag","tc_expr","tokContexts","jsxName","jsxText","beforeExpr","jsxTagStart","jsxTagEnd","updateContext","context","push","exprAllowed","prevType","out","pop","slash","curContext","set","getQualifiedJSXName","object","type","name","namespace","property","module","exports","options","plugin","allowNamespaces","allowNamespacedObjects","Object","defineProperty","get_tokTypes","configurable","enumerable","tok","isNewLine","isIdentifierStart","isIdentifierChar","jsx_readToken","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","jsx_readNewLine","normalizeCRLF","String","fromCharCode","locations","curLine","lineStart","jsx_readString","quote","string","str","count","entity","startPos","substr","test","parseInt","jsx_readWord","jsx_parseIdentifier","node","startNode","value","keyword","unexpected","next","finishNode","jsx_parseNamespacedName","startLoc","eat","colon","startNodeAt","jsx_parseElementName","dot","newNode","jsx_parseAttributeValue","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","jsx_parseEmptyExpression","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","parseExpression","expect","jsx_parseAttribute","ellipsis","argument","parseMaybeAssign","eq","jsx_parseOpeningElementAt","attributes","nodeName","selfClosing","jsx_parseClosingElementAt","jsx_parseElementAt","children","openingElement","closingElement","contents","fragmentOrElement","relational","jsx_parseText","parseLiteral","jsx_parseElement","refShortHandDefaultPos","readToken","code","b_expr","b_tmpl"],"mappings":"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","sourcesContent":["'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {beforeExpr: true}),\n      jsxTagStart: new TokenType('jsxTagStart'),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function() {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object)\n    return object;\n\n  if (object.type === 'JSXIdentifier')\n    return object.name;\n\n  if (object.type === 'JSXNamespacedName')\n    return object.namespace.name + ':' + object.name.name;\n\n  if (object.type === 'JSXMemberExpression')\n    return getQualifiedJSXName(object.object) + '.' +\n    getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function(options) {\n  options = options || {};\n  return function(Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '', chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n        case 60: // '<'\n        case 123: // '{'\n          if (this.pos === this.start) {\n            if (ch === 60 && this.exprAllowed) {\n              ++this.pos;\n              return this.finishToken(tok.jsxTagStart);\n            }\n            return this.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.pos);\n          return this.finishToken(tok.jsxText, out);\n\n        case 38: // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n          break;\n\n        case 62: // '>'\n        case 125: // '}'\n          this.raise(\n            this.pos,\n            \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\n              (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\n          );\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(true);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '', chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) { // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '', count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&')\n        this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName)\n        node.name = this.value;\n      else if (this.type.keyword)\n        node.name = this.type.keyword;\n      else\n        this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n      case tt.braceL:\n        let node = this.jsx_parseExpressionContainer();\n        if (node.expression.type === 'JSXEmptyExpression')\n          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n        return node;\n\n      case tok.jsxTagStart:\n      case tt.string:\n        return this.parseExprAtom();\n\n      default:\n        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR\n        ? this.jsx_parseEmptyExpression()\n        : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n          case tok.jsxTagStart:\n            startPos = this.start; startLoc = this.startLoc;\n            this.next();\n            if (this.eat(tt.slash)) {\n              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n            children.push(this.jsx_parseElementAt(startPos, startLoc));\n            break;\n\n          case tok.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case tt.braceL:\n            children.push(this.jsx_parseExpressionContainer());\n            break;\n\n          default:\n            this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText)\n        return this.jsx_parseText();\n      else if (this.type === tok.jsxTagStart)\n        return this.jsx_parseElement();\n      else\n        return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag)\n          return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n        else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}