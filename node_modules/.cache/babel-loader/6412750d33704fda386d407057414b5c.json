{"ast":null,"code":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      {\n  breakableTypePattern\n} = require(\"../../shared/ast-utils\"),\n      CodePath = require(\"./code-path\"),\n      CodePathSegment = require(\"./code-path-segment\"),\n      IdGenerator = require(\"./id-generator\"),\n      debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\n\n\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\"\n */\n\n\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\";\n}\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\n\n\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n\n  return null;\n}\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\n\n\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n\n    default:\n      return false;\n  }\n}\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\n\n\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n\n  return void 0;\n}\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\n\n\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"Property\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n\n    default:\n      return true;\n  }\n}\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment; // Fires leaving events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && currentSegment) {\n      debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n      if (currentSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n      }\n    }\n  } // Update state.\n\n\n  state.currentSegments = headSegments; // Fires entering events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && headSegment) {\n      debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n      CodePathSegment.markUsed(headSegment);\n\n      if (headSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentStart\", headSegment, node);\n      }\n    }\n  }\n}\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = CodePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n    if (currentSegment.reachable) {\n      analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n    }\n  }\n\n  state.currentSegments = [];\n}\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction preprocess(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      /*\n       * Fork if this node is at `consequent`/`alternate`.\n       * `popForkContext()` exists at `IfStatement:exit` and\n       * `ConditionalExpression:exit`.\n       */\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n\n      break;\n\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n\n      break;\n\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert(parent.body === node);\n        state.makeWhileBody();\n      }\n\n      break;\n\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert(parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n\n      break;\n\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n\n      break;\n\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert(parent.body === node);\n        state.makeForInOfBody();\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      /*\n       * Fork if this node is at `right`.\n       * `left` is executed always, so it uses the current path.\n       * `popForkContext()` exists at `AssignmentPattern:exit`.\n       */\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath = analyzer.codePath;\n  let state = codePath && CodePath.getState(codePath);\n  const parent = node.parent;\n\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      if (codePath) {\n        // Emits onCodePathSegmentStart events if updated.\n        forwardCurrentToHead(analyzer, node);\n        debug.dumpState(node, state, false);\n      } // Create the code path of this scope.\n\n\n      codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);\n      state = CodePath.getState(codePath); // Emits onCodePathStart events.\n\n      debug.dump(`onCodePathStart ${codePath.id}`);\n      analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n\n    case \"SwitchCase\":\n      /*\n       * Fork if this node is after the 2st node in `cases`.\n       * It's similar to `else` blocks.\n       * The next `test` node is processed in this path.\n       */\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  forwardCurrentToHead(analyzer, node);\n  debug.dumpState(node, state, false);\n}\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction processCodePathToExit(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  let dontForward = false;\n\n  switch (node.type) {\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n\n    case \"SwitchCase\":\n      /*\n       * This is the same as the process at the 1st `consequent` node in\n       * `preprocess` function.\n       * Must do if this `consequent` is empty.\n       */\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n\n      break;\n\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n\n  debug.dumpState(node, state, true);\n}\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\nfunction postprocess(analyzer, node) {\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      {\n        let codePath = analyzer.codePath; // Mark the current path as the final node.\n\n        CodePath.getState(codePath).makeFinal(); // Emits onCodePathSegmentEnd event of the current segments.\n\n        leaveFromCurrentSegment(analyzer, node); // Emits onCodePathEnd event of this code path.\n\n        debug.dump(`onCodePathEnd ${codePath.id}`);\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n        debug.dumpDot(codePath);\n        codePath = analyzer.codePath = analyzer.codePath.upper;\n\n        if (codePath) {\n          debug.dumpState(node, CodePath.getState(codePath), true);\n        }\n\n        break;\n      }\n\n    default:\n      break;\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\n\n\nclass CodePathAnalyzer {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {EventGenerator} eventGenerator An event generator to wrap.\n   */\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n  /**\n   * Does the process to enter a given AST node.\n   * This updates state of analysis and calls `enterNode` of the wrapped.\n   * @param {ASTNode} node A node which is entering.\n   * @returns {void}\n   */\n\n\n  enterNode(node) {\n    this.currentNode = node; // Updates the code path due to node's position in its parent node.\n\n    if (node.parent) {\n      preprocess(this, node);\n    }\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n\n\n    processCodePathToEnter(this, node); // Emits node events.\n\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n  /**\n   * Does the process to leave a given AST node.\n   * This updates state of analysis and calls `leaveNode` of the wrapped.\n   * @param {ASTNode} node A node which is leaving.\n   * @returns {void}\n   */\n\n\n  leaveNode(node) {\n    this.currentNode = node;\n    /*\n     * Updates the code path.\n     * And emits onCodePathStart/onCodePathSegmentStart events.\n     */\n\n    processCodePathToExit(this, node); // Emits node events.\n\n    this.original.leaveNode(node); // Emits the last onCodePathStart/onCodePathSegmentStart events.\n\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n  /**\n   * This is called on a code path looped.\n   * Then this raises a looped event.\n   * @param {CodePathSegment} fromSegment A segment of prev.\n   * @param {CodePathSegment} toSegment A segment of next.\n   * @returns {void}\n   */\n\n\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n\n}\n\nmodule.exports = CodePathAnalyzer;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"],"names":["assert","require","breakableTypePattern","CodePath","CodePathSegment","IdGenerator","debug","isCaseNode","node","Boolean","test","isHandledLogicalOperator","operator","getLabel","parent","type","label","name","isForkingByTrueOrFalse","getBooleanValueIfSimpleConstant","value","isIdentifierReference","id","key","computed","shorthand","forwardCurrentToHead","analyzer","codePath","state","getState","currentSegments","headSegments","end","Math","max","length","i","currentSegment","headSegment","dump","reachable","emitter","emit","markUsed","leaveFromCurrentSegment","preprocess","right","makeLogicalRight","consequent","makeIfConsequent","alternate","makeIfAlternate","makeSwitchCaseBody","handler","makeCatchBlock","finalizer","makeFinallyBlock","makeWhileTest","body","makeWhileBody","makeDoWhileBody","makeDoWhileTest","makeForTest","update","makeForUpdate","makeForBody","left","makeForInOfLeft","makeForInOfRight","makeForInOfBody","pushForkContext","forkBypassPath","forkPath","processCodePathToEnter","dumpState","idGenerator","next","onLooped","pushChoiceContext","pushSwitchContext","cases","some","pushTryContext","discriminant","pushLoopContext","pushBreakContext","processCodePathToExit","dontForward","popChoiceContext","popSwitchContext","forkContext","popTryContext","makeBreak","makeContinue","makeReturn","makeThrow","makeFirstThrowablePathInTryBlock","popLoopContext","popForkContext","popBreakContext","postprocess","makeFinal","dumpDot","upper","CodePathAnalyzer","constructor","eventGenerator","original","currentNode","bind","enterNode","leaveNode","fromSegment","toSegment","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n    if (node.parent.type === \"LabeledStatement\") {\n        return node.parent.label.name;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node\n                );\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node\n                );\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"ImportExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n"]},"metadata":{},"sourceType":"script"}