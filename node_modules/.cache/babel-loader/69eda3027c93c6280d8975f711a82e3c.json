{"ast":null,"code":"/**\n * Socket implementation that uses flash SocketPool class as a backend.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util'); // define net namespace\n\n\nvar net = module.exports = forge.net = forge.net || {}; // map of flash ID to socket pool\n\nnet.socketPools = {};\n/**\n * Creates a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          policyPort: the default policy port for sockets, 0 to use the\n *            flash default.\n *          policyUrl: the default policy file URL for sockets (if provided\n *            used instead of a policy port).\n *          msie: true if the browser is msie, false if not.\n *\n * @return the created socket pool.\n */\n\nnet.createSocketPool = function (options) {\n  // set default\n  options.msie = options.msie || false; // initialize the flash interface\n\n  var spId = options.flashId;\n  var api = document.getElementById(spId);\n  api.init({\n    marshallExceptions: !options.msie\n  }); // create socket pool entry\n\n  var sp = {\n    // ID of the socket pool\n    id: spId,\n    // flash interface\n    flashApi: api,\n    // map of socket ID to sockets\n    sockets: {},\n    // default policy port\n    policyPort: options.policyPort || 0,\n    // default policy URL\n    policyUrl: options.policyUrl || null\n  };\n  net.socketPools[spId] = sp; // create event handler, subscribe to flash events\n\n  if (options.msie === true) {\n    sp.handler = function (e) {\n      if (e.id in sp.sockets) {\n        // get handler function\n        var f;\n\n        switch (e.type) {\n          case 'connect':\n            f = 'connected';\n            break;\n\n          case 'close':\n            f = 'closed';\n            break;\n\n          case 'socketData':\n            f = 'data';\n            break;\n\n          default:\n            f = 'error';\n            break;\n        }\n        /* IE calls javascript on the thread of the external object\n          that triggered the event (in this case flash) ... which will\n          either run concurrently with other javascript or pre-empt any\n          running javascript in the middle of its execution (BAD!) ...\n          calling setTimeout() will schedule the javascript to run on\n          the javascript thread and solve this EVIL problem. */\n\n\n        setTimeout(function () {\n          sp.sockets[e.id][f](e);\n        }, 0);\n      }\n    };\n  } else {\n    sp.handler = function (e) {\n      if (e.id in sp.sockets) {\n        // get handler function\n        var f;\n\n        switch (e.type) {\n          case 'connect':\n            f = 'connected';\n            break;\n\n          case 'close':\n            f = 'closed';\n            break;\n\n          case 'socketData':\n            f = 'data';\n            break;\n\n          default:\n            f = 'error';\n            break;\n        }\n\n        sp.sockets[e.id][f](e);\n      }\n    };\n  }\n\n  var handler = 'forge.net.socketPools[\\'' + spId + '\\'].handler';\n  api.subscribe('connect', handler);\n  api.subscribe('close', handler);\n  api.subscribe('socketData', handler);\n  api.subscribe('ioError', handler);\n  api.subscribe('securityError', handler);\n  /**\n   * Destroys a socket pool. The socket pool still needs to be cleaned\n   * up via net.cleanup().\n   */\n\n  sp.destroy = function () {\n    delete net.socketPools[options.flashId];\n\n    for (var id in sp.sockets) {\n      sp.sockets[id].destroy();\n    }\n\n    sp.sockets = {};\n    api.cleanup();\n  };\n  /**\n   * Creates a new socket.\n   *\n   * @param options:\n   *          connected: function(event) called when the socket connects.\n   *          closed: function(event) called when the socket closes.\n   *          data: function(event) called when socket data has arrived,\n   *            it can be read from the socket using receive().\n   *          error: function(event) called when a socket error occurs.\n   */\n\n\n  sp.createSocket = function (options) {\n    // default to empty options\n    options = options || {}; // create flash socket\n\n    var id = api.create(); // create javascript socket wrapper\n\n    var socket = {\n      id: id,\n      // set handlers\n      connected: options.connected || function (e) {},\n      closed: options.closed || function (e) {},\n      data: options.data || function (e) {},\n      error: options.error || function (e) {}\n    };\n    /**\n     * Destroys this socket.\n     */\n\n    socket.destroy = function () {\n      api.destroy(id);\n      delete sp.sockets[id];\n    };\n    /**\n     * Connects this socket.\n     *\n     * @param options:\n     *          host: the host to connect to.\n     *          port: the port to connect to.\n     *          policyPort: the policy port to use (if non-default), 0 to\n     *            use the flash default.\n     *          policyUrl: the policy file URL to use (instead of port).\n     */\n\n\n    socket.connect = function (options) {\n      // give precedence to policy URL over policy port\n      // if no policy URL and passed port isn't 0, use default port,\n      // otherwise use 0 for the port\n      var policyUrl = options.policyUrl || null;\n      var policyPort = 0;\n\n      if (policyUrl === null && options.policyPort !== 0) {\n        policyPort = options.policyPort || sp.policyPort;\n      }\n\n      api.connect(id, options.host, options.port, policyPort, policyUrl);\n    };\n    /**\n     * Closes this socket.\n     */\n\n\n    socket.close = function () {\n      api.close(id);\n      socket.closed({\n        id: socket.id,\n        type: 'close',\n        bytesAvailable: 0\n      });\n    };\n    /**\n     * Determines if the socket is connected or not.\n     *\n     * @return true if connected, false if not.\n     */\n\n\n    socket.isConnected = function () {\n      return api.isConnected(id);\n    };\n    /**\n     * Writes bytes to this socket.\n     *\n     * @param bytes the bytes (as a string) to write.\n     *\n     * @return true on success, false on failure.\n     */\n\n\n    socket.send = function (bytes) {\n      return api.send(id, forge.util.encode64(bytes));\n    };\n    /**\n     * Reads bytes from this socket (non-blocking). Fewer than the number\n     * of bytes requested may be read if enough bytes are not available.\n     *\n     * This method should be called from the data handler if there are\n     * enough bytes available. To see how many bytes are available, check\n     * the 'bytesAvailable' property on the event in the data handler or\n     * call the bytesAvailable() function on the socket. If the browser is\n     * msie, then the bytesAvailable() function should be used to avoid\n     * race conditions. Otherwise, using the property on the data handler's\n     * event may be quicker.\n     *\n     * @param count the maximum number of bytes to read.\n     *\n     * @return the bytes read (as a string) or null on error.\n     */\n\n\n    socket.receive = function (count) {\n      var rval = api.receive(id, count).rval;\n      return rval === null ? null : forge.util.decode64(rval);\n    };\n    /**\n     * Gets the number of bytes available for receiving on the socket.\n     *\n     * @return the number of bytes available for receiving.\n     */\n\n\n    socket.bytesAvailable = function () {\n      return api.getBytesAvailable(id);\n    }; // store and return socket\n\n\n    sp.sockets[id] = socket;\n    return socket;\n  };\n\n  return sp;\n};\n/**\n * Destroys a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n */\n\n\nnet.destroySocketPool = function (options) {\n  if (options.flashId in net.socketPools) {\n    var sp = net.socketPools[options.flashId];\n    sp.destroy();\n  }\n};\n/**\n * Creates a new socket.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          connected: function(event) called when the socket connects.\n *          closed: function(event) called when the socket closes.\n *          data: function(event) called when socket data has arrived, it\n *            can be read from the socket using receive().\n *          error: function(event) called when a socket error occurs.\n *\n * @return the created socket.\n */\n\n\nnet.createSocket = function (options) {\n  var socket = null;\n\n  if (options.flashId in net.socketPools) {\n    // get related socket pool\n    var sp = net.socketPools[options.flashId];\n    socket = sp.createSocket(options);\n  }\n\n  return socket;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/node-forge/lib/socket.js"],"names":["forge","require","net","module","exports","socketPools","createSocketPool","options","msie","spId","flashId","api","document","getElementById","init","marshallExceptions","sp","id","flashApi","sockets","policyPort","policyUrl","handler","e","f","type","setTimeout","subscribe","destroy","cleanup","createSocket","create","socket","connected","closed","data","error","connect","host","port","close","bytesAvailable","isConnected","send","bytes","util","encode64","receive","count","rval","decode64","getBytesAvailable","destroySocketPool"],"mappings":"AAAA;;;;;;;AAOA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,QAAD,CAAP,C,CAEA;;;AACA,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAP,GAAiBJ,KAAK,CAACE,GAAN,GAAYF,KAAK,CAACE,GAAN,IAAa,EAApD,C,CAEA;;AACAA,GAAG,CAACG,WAAJ,GAAkB,EAAlB;AAEA;;;;;;;;;;;;;;AAaAH,GAAG,CAACI,gBAAJ,GAAuB,UAASC,OAAT,EAAkB;AACvC;AACAA,EAAAA,OAAO,CAACC,IAAR,GAAeD,OAAO,CAACC,IAAR,IAAgB,KAA/B,CAFuC,CAIvC;;AACA,MAAIC,IAAI,GAAGF,OAAO,CAACG,OAAnB;AACA,MAAIC,GAAG,GAAGC,QAAQ,CAACC,cAAT,CAAwBJ,IAAxB,CAAV;AACAE,EAAAA,GAAG,CAACG,IAAJ,CAAS;AAACC,IAAAA,kBAAkB,EAAE,CAACR,OAAO,CAACC;AAA9B,GAAT,EAPuC,CASvC;;AACA,MAAIQ,EAAE,GAAG;AACP;AACAC,IAAAA,EAAE,EAAER,IAFG;AAGP;AACAS,IAAAA,QAAQ,EAAEP,GAJH;AAKP;AACAQ,IAAAA,OAAO,EAAE,EANF;AAOP;AACAC,IAAAA,UAAU,EAAEb,OAAO,CAACa,UAAR,IAAsB,CAR3B;AASP;AACAC,IAAAA,SAAS,EAAEd,OAAO,CAACc,SAAR,IAAqB;AAVzB,GAAT;AAYAnB,EAAAA,GAAG,CAACG,WAAJ,CAAgBI,IAAhB,IAAwBO,EAAxB,CAtBuC,CAwBvC;;AACA,MAAGT,OAAO,CAACC,IAAR,KAAiB,IAApB,EAA0B;AACxBQ,IAAAA,EAAE,CAACM,OAAH,GAAa,UAASC,CAAT,EAAY;AACvB,UAAGA,CAAC,CAACN,EAAF,IAAQD,EAAE,CAACG,OAAd,EAAuB;AACrB;AACA,YAAIK,CAAJ;;AACA,gBAAOD,CAAC,CAACE,IAAT;AACA,eAAK,SAAL;AACED,YAAAA,CAAC,GAAG,WAAJ;AACA;;AACF,eAAK,OAAL;AACEA,YAAAA,CAAC,GAAG,QAAJ;AACA;;AACF,eAAK,YAAL;AACEA,YAAAA,CAAC,GAAG,MAAJ;AACA;;AACF;AACEA,YAAAA,CAAC,GAAG,OAAJ;AACA;AAZF;AAcA;;;;;;;;AAMAE,QAAAA,UAAU,CAAC,YAAW;AAACV,UAAAA,EAAE,CAACG,OAAH,CAAWI,CAAC,CAACN,EAAb,EAAiBO,CAAjB,EAAoBD,CAApB;AAAwB,SAArC,EAAuC,CAAvC,CAAV;AACD;AACF,KA1BD;AA2BD,GA5BD,MA4BO;AACLP,IAAAA,EAAE,CAACM,OAAH,GAAa,UAASC,CAAT,EAAY;AACvB,UAAGA,CAAC,CAACN,EAAF,IAAQD,EAAE,CAACG,OAAd,EAAuB;AACrB;AACA,YAAIK,CAAJ;;AACA,gBAAOD,CAAC,CAACE,IAAT;AACA,eAAK,SAAL;AACED,YAAAA,CAAC,GAAG,WAAJ;AACA;;AACF,eAAK,OAAL;AACEA,YAAAA,CAAC,GAAG,QAAJ;AACA;;AACF,eAAK,YAAL;AACEA,YAAAA,CAAC,GAAG,MAAJ;AACA;;AACF;AACEA,YAAAA,CAAC,GAAG,OAAJ;AACA;AAZF;;AAcAR,QAAAA,EAAE,CAACG,OAAH,CAAWI,CAAC,CAACN,EAAb,EAAiBO,CAAjB,EAAoBD,CAApB;AACD;AACF,KApBD;AAqBD;;AACD,MAAID,OAAO,GAAG,6BAA6Bb,IAA7B,GAAoC,aAAlD;AACAE,EAAAA,GAAG,CAACgB,SAAJ,CAAc,SAAd,EAAyBL,OAAzB;AACAX,EAAAA,GAAG,CAACgB,SAAJ,CAAc,OAAd,EAAuBL,OAAvB;AACAX,EAAAA,GAAG,CAACgB,SAAJ,CAAc,YAAd,EAA4BL,OAA5B;AACAX,EAAAA,GAAG,CAACgB,SAAJ,CAAc,SAAd,EAAyBL,OAAzB;AACAX,EAAAA,GAAG,CAACgB,SAAJ,CAAc,eAAd,EAA+BL,OAA/B;AAEA;;;;;AAIAN,EAAAA,EAAE,CAACY,OAAH,GAAa,YAAW;AACtB,WAAO1B,GAAG,CAACG,WAAJ,CAAgBE,OAAO,CAACG,OAAxB,CAAP;;AACA,SAAI,IAAIO,EAAR,IAAcD,EAAE,CAACG,OAAjB,EAA0B;AACxBH,MAAAA,EAAE,CAACG,OAAH,CAAWF,EAAX,EAAeW,OAAf;AACD;;AACDZ,IAAAA,EAAE,CAACG,OAAH,GAAa,EAAb;AACAR,IAAAA,GAAG,CAACkB,OAAJ;AACD,GAPD;AASA;;;;;;;;;;;;AAUCb,EAAAA,EAAE,CAACc,YAAH,GAAkB,UAASvB,OAAT,EAAkB;AAClC;AACAA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAFkC,CAIlC;;AACA,QAAIU,EAAE,GAAGN,GAAG,CAACoB,MAAJ,EAAT,CALkC,CAOlC;;AACA,QAAIC,MAAM,GAAG;AACXf,MAAAA,EAAE,EAAEA,EADO;AAEX;AACAgB,MAAAA,SAAS,EAAE1B,OAAO,CAAC0B,SAAR,IAAqB,UAASV,CAAT,EAAY,CAAE,CAHnC;AAIXW,MAAAA,MAAM,EAAE3B,OAAO,CAAC2B,MAAR,IAAkB,UAASX,CAAT,EAAY,CAAE,CAJ7B;AAKXY,MAAAA,IAAI,EAAE5B,OAAO,CAAC4B,IAAR,IAAgB,UAASZ,CAAT,EAAY,CAAE,CALzB;AAMXa,MAAAA,KAAK,EAAE7B,OAAO,CAAC6B,KAAR,IAAiB,UAASb,CAAT,EAAY,CAAE;AAN3B,KAAb;AASA;;;;AAGAS,IAAAA,MAAM,CAACJ,OAAP,GAAiB,YAAW;AAC1BjB,MAAAA,GAAG,CAACiB,OAAJ,CAAYX,EAAZ;AACA,aAAOD,EAAE,CAACG,OAAH,CAAWF,EAAX,CAAP;AACD,KAHD;AAKA;;;;;;;;;;;;AAUAe,IAAAA,MAAM,CAACK,OAAP,GAAiB,UAAS9B,OAAT,EAAkB;AACjC;AACA;AACA;AACA,UAAIc,SAAS,GAAGd,OAAO,CAACc,SAAR,IAAqB,IAArC;AACA,UAAID,UAAU,GAAG,CAAjB;;AACA,UAAGC,SAAS,KAAK,IAAd,IAAsBd,OAAO,CAACa,UAAR,KAAuB,CAAhD,EAAmD;AACjDA,QAAAA,UAAU,GAAGb,OAAO,CAACa,UAAR,IAAsBJ,EAAE,CAACI,UAAtC;AACD;;AACDT,MAAAA,GAAG,CAAC0B,OAAJ,CAAYpB,EAAZ,EAAgBV,OAAO,CAAC+B,IAAxB,EAA8B/B,OAAO,CAACgC,IAAtC,EAA4CnB,UAA5C,EAAwDC,SAAxD;AACD,KAVD;AAYA;;;;;AAGAW,IAAAA,MAAM,CAACQ,KAAP,GAAe,YAAW;AACxB7B,MAAAA,GAAG,CAAC6B,KAAJ,CAAUvB,EAAV;AACAe,MAAAA,MAAM,CAACE,MAAP,CAAc;AACZjB,QAAAA,EAAE,EAAEe,MAAM,CAACf,EADC;AAEZQ,QAAAA,IAAI,EAAE,OAFM;AAGZgB,QAAAA,cAAc,EAAE;AAHJ,OAAd;AAKD,KAPD;AASA;;;;;;;AAKAT,IAAAA,MAAM,CAACU,WAAP,GAAqB,YAAW;AAC9B,aAAO/B,GAAG,CAAC+B,WAAJ,CAAgBzB,EAAhB,CAAP;AACD,KAFD;AAIA;;;;;;;;;AAOAe,IAAAA,MAAM,CAACW,IAAP,GAAc,UAASC,KAAT,EAAgB;AAC5B,aAAOjC,GAAG,CAACgC,IAAJ,CAAS1B,EAAT,EAAajB,KAAK,CAAC6C,IAAN,CAAWC,QAAX,CAAoBF,KAApB,CAAb,CAAP;AACD,KAFD;AAIA;;;;;;;;;;;;;;;;;;AAgBAZ,IAAAA,MAAM,CAACe,OAAP,GAAiB,UAASC,KAAT,EAAgB;AAC/B,UAAIC,IAAI,GAAGtC,GAAG,CAACoC,OAAJ,CAAY9B,EAAZ,EAAgB+B,KAAhB,EAAuBC,IAAlC;AACA,aAAQA,IAAI,KAAK,IAAV,GAAkB,IAAlB,GAAyBjD,KAAK,CAAC6C,IAAN,CAAWK,QAAX,CAAoBD,IAApB,CAAhC;AACD,KAHD;AAKA;;;;;;;AAKAjB,IAAAA,MAAM,CAACS,cAAP,GAAwB,YAAW;AACjC,aAAO9B,GAAG,CAACwC,iBAAJ,CAAsBlC,EAAtB,CAAP;AACD,KAFD,CAzGkC,CA6GlC;;;AACAD,IAAAA,EAAE,CAACG,OAAH,CAAWF,EAAX,IAAiBe,MAAjB;AACA,WAAOA,MAAP;AACF,GAhHA;;AAkHD,SAAOhB,EAAP;AACD,CA7ND;AA+NA;;;;;;;;AAMAd,GAAG,CAACkD,iBAAJ,GAAwB,UAAS7C,OAAT,EAAkB;AACxC,MAAGA,OAAO,CAACG,OAAR,IAAmBR,GAAG,CAACG,WAA1B,EAAuC;AACrC,QAAIW,EAAE,GAAGd,GAAG,CAACG,WAAJ,CAAgBE,OAAO,CAACG,OAAxB,CAAT;AACAM,IAAAA,EAAE,CAACY,OAAH;AACD;AACF,CALD;AAOA;;;;;;;;;;;;;;;AAaA1B,GAAG,CAAC4B,YAAJ,GAAmB,UAASvB,OAAT,EAAkB;AACnC,MAAIyB,MAAM,GAAG,IAAb;;AACA,MAAGzB,OAAO,CAACG,OAAR,IAAmBR,GAAG,CAACG,WAA1B,EAAuC;AACrC;AACA,QAAIW,EAAE,GAAGd,GAAG,CAACG,WAAJ,CAAgBE,OAAO,CAACG,OAAxB,CAAT;AACAsB,IAAAA,MAAM,GAAGhB,EAAE,CAACc,YAAH,CAAgBvB,OAAhB,CAAT;AACD;;AACD,SAAOyB,MAAP;AACD,CARD","sourcesContent":["/**\n * Socket implementation that uses flash SocketPool class as a backend.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n// define net namespace\nvar net = module.exports = forge.net = forge.net || {};\n\n// map of flash ID to socket pool\nnet.socketPools = {};\n\n/**\n * Creates a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          policyPort: the default policy port for sockets, 0 to use the\n *            flash default.\n *          policyUrl: the default policy file URL for sockets (if provided\n *            used instead of a policy port).\n *          msie: true if the browser is msie, false if not.\n *\n * @return the created socket pool.\n */\nnet.createSocketPool = function(options) {\n  // set default\n  options.msie = options.msie || false;\n\n  // initialize the flash interface\n  var spId = options.flashId;\n  var api = document.getElementById(spId);\n  api.init({marshallExceptions: !options.msie});\n\n  // create socket pool entry\n  var sp = {\n    // ID of the socket pool\n    id: spId,\n    // flash interface\n    flashApi: api,\n    // map of socket ID to sockets\n    sockets: {},\n    // default policy port\n    policyPort: options.policyPort || 0,\n    // default policy URL\n    policyUrl: options.policyUrl || null\n  };\n  net.socketPools[spId] = sp;\n\n  // create event handler, subscribe to flash events\n  if(options.msie === true) {\n    sp.handler = function(e) {\n      if(e.id in sp.sockets) {\n        // get handler function\n        var f;\n        switch(e.type) {\n        case 'connect':\n          f = 'connected';\n          break;\n        case 'close':\n          f = 'closed';\n          break;\n        case 'socketData':\n          f = 'data';\n          break;\n        default:\n          f = 'error';\n          break;\n        }\n        /* IE calls javascript on the thread of the external object\n          that triggered the event (in this case flash) ... which will\n          either run concurrently with other javascript or pre-empt any\n          running javascript in the middle of its execution (BAD!) ...\n          calling setTimeout() will schedule the javascript to run on\n          the javascript thread and solve this EVIL problem. */\n        setTimeout(function() {sp.sockets[e.id][f](e);}, 0);\n      }\n    };\n  } else {\n    sp.handler = function(e) {\n      if(e.id in sp.sockets) {\n        // get handler function\n        var f;\n        switch(e.type) {\n        case 'connect':\n          f = 'connected';\n          break;\n        case 'close':\n          f = 'closed';\n          break;\n        case 'socketData':\n          f = 'data';\n          break;\n        default:\n          f = 'error';\n          break;\n        }\n        sp.sockets[e.id][f](e);\n      }\n    };\n  }\n  var handler = 'forge.net.socketPools[\\'' + spId + '\\'].handler';\n  api.subscribe('connect', handler);\n  api.subscribe('close', handler);\n  api.subscribe('socketData', handler);\n  api.subscribe('ioError', handler);\n  api.subscribe('securityError', handler);\n\n  /**\n   * Destroys a socket pool. The socket pool still needs to be cleaned\n   * up via net.cleanup().\n   */\n  sp.destroy = function() {\n    delete net.socketPools[options.flashId];\n    for(var id in sp.sockets) {\n      sp.sockets[id].destroy();\n    }\n    sp.sockets = {};\n    api.cleanup();\n  };\n\n  /**\n   * Creates a new socket.\n   *\n   * @param options:\n   *          connected: function(event) called when the socket connects.\n   *          closed: function(event) called when the socket closes.\n   *          data: function(event) called when socket data has arrived,\n   *            it can be read from the socket using receive().\n   *          error: function(event) called when a socket error occurs.\n   */\n   sp.createSocket = function(options) {\n     // default to empty options\n     options = options || {};\n\n     // create flash socket\n     var id = api.create();\n\n     // create javascript socket wrapper\n     var socket = {\n       id: id,\n       // set handlers\n       connected: options.connected || function(e) {},\n       closed: options.closed || function(e) {},\n       data: options.data || function(e) {},\n       error: options.error || function(e) {}\n     };\n\n     /**\n      * Destroys this socket.\n      */\n     socket.destroy = function() {\n       api.destroy(id);\n       delete sp.sockets[id];\n     };\n\n     /**\n      * Connects this socket.\n      *\n      * @param options:\n      *          host: the host to connect to.\n      *          port: the port to connect to.\n      *          policyPort: the policy port to use (if non-default), 0 to\n      *            use the flash default.\n      *          policyUrl: the policy file URL to use (instead of port).\n      */\n     socket.connect = function(options) {\n       // give precedence to policy URL over policy port\n       // if no policy URL and passed port isn't 0, use default port,\n       // otherwise use 0 for the port\n       var policyUrl = options.policyUrl || null;\n       var policyPort = 0;\n       if(policyUrl === null && options.policyPort !== 0) {\n         policyPort = options.policyPort || sp.policyPort;\n       }\n       api.connect(id, options.host, options.port, policyPort, policyUrl);\n     };\n\n     /**\n      * Closes this socket.\n      */\n     socket.close = function() {\n       api.close(id);\n       socket.closed({\n         id: socket.id,\n         type: 'close',\n         bytesAvailable: 0\n       });\n     };\n\n     /**\n      * Determines if the socket is connected or not.\n      *\n      * @return true if connected, false if not.\n      */\n     socket.isConnected = function() {\n       return api.isConnected(id);\n     };\n\n     /**\n      * Writes bytes to this socket.\n      *\n      * @param bytes the bytes (as a string) to write.\n      *\n      * @return true on success, false on failure.\n      */\n     socket.send = function(bytes) {\n       return api.send(id, forge.util.encode64(bytes));\n     };\n\n     /**\n      * Reads bytes from this socket (non-blocking). Fewer than the number\n      * of bytes requested may be read if enough bytes are not available.\n      *\n      * This method should be called from the data handler if there are\n      * enough bytes available. To see how many bytes are available, check\n      * the 'bytesAvailable' property on the event in the data handler or\n      * call the bytesAvailable() function on the socket. If the browser is\n      * msie, then the bytesAvailable() function should be used to avoid\n      * race conditions. Otherwise, using the property on the data handler's\n      * event may be quicker.\n      *\n      * @param count the maximum number of bytes to read.\n      *\n      * @return the bytes read (as a string) or null on error.\n      */\n     socket.receive = function(count) {\n       var rval = api.receive(id, count).rval;\n       return (rval === null) ? null : forge.util.decode64(rval);\n     };\n\n     /**\n      * Gets the number of bytes available for receiving on the socket.\n      *\n      * @return the number of bytes available for receiving.\n      */\n     socket.bytesAvailable = function() {\n       return api.getBytesAvailable(id);\n     };\n\n     // store and return socket\n     sp.sockets[id] = socket;\n     return socket;\n  };\n\n  return sp;\n};\n\n/**\n * Destroys a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n */\nnet.destroySocketPool = function(options) {\n  if(options.flashId in net.socketPools) {\n    var sp = net.socketPools[options.flashId];\n    sp.destroy();\n  }\n};\n\n/**\n * Creates a new socket.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          connected: function(event) called when the socket connects.\n *          closed: function(event) called when the socket closes.\n *          data: function(event) called when socket data has arrived, it\n *            can be read from the socket using receive().\n *          error: function(event) called when a socket error occurs.\n *\n * @return the created socket.\n */\nnet.createSocket = function(options) {\n  var socket = null;\n  if(options.flashId in net.socketPools) {\n    // get related socket pool\n    var sp = net.socketPools[options.flashId];\n    socket = sp.createSocket(options);\n  }\n  return socket;\n};\n"]},"metadata":{},"sourceType":"script"}