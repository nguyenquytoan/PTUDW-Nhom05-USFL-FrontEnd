{"ast":null,"code":"'use strict';\n\nvar getFieldAsFn = require('./get-field-as-fn');\n/**\n * Create a decoder for input sources using the given codec hash\n * @this {object} A loader or compilation\n * @param {Array.<object>} codecs A list of codecs, each with a `decode` function\n * @param {boolean} mustDecode Return an error for a source that is not decoded\n * @returns {function(string):string|Error} A decode function that returns an absolute path or else an Error\n */\n\n\nfunction decodeSourcesWith(codecs, mustDecode) {\n  /* jshint validthis:true */\n  var context = this; // get a list of valid decoders\n\n  var candidates = [].concat(codecs).reduce(reduceValidDecoder.bind(null, codecs), []);\n  /**\n   * Attempt to decode the given source path using the previously supplied codecs\n   * @param {string} inputSource A source path from a source map\n   * @returns {Error|string|undefined} An absolute path if decoded else an error if encountered else undefined\n   */\n\n  return function decode(inputSource) {\n    // attempt all candidates until a match\n    for (var i = 0, decoded = null; i < candidates.length && !decoded; i++) {\n      // call the decoder\n      try {\n        decoded = candidates[i].decode.call(context, inputSource);\n      } catch (exception) {\n        return getNamedError(exception);\n      } // match implies a return value\n\n\n      if (decoded) {\n        // abstract sources cannot be decoded, only validated\n        if (candidates[i].abstract) {\n          return undefined;\n        } // non-string implies error\n\n\n        if (typeof decoded !== 'string') {\n          return getNamedError('Decoder returned a truthy value but it is not a string:\\n' + decoded);\n        } // otherwise success\n        else {\n            return decoded;\n          }\n      }\n    } // default is undefined or error\n\n\n    return mustDecode ? new Error('No viable decoder for source: ' + inputSource) : undefined;\n\n    function getNamedError(details) {\n      var name = candidates[i].name || '(unnamed)',\n          message = ['Decoding with codec: ' + name, 'Incoming source: ' + inputSource, details && (details.stack ? details.stack : details)].filter(Boolean).join('\\n');\n      return new Error(message);\n    }\n  };\n}\n\nmodule.exports = decodeSourcesWith;\n\nfunction reduceValidDecoder(reduced, codec) {\n  var decoder = getFieldAsFn('decode')(codec);\n  return decoder ? reduced.concat(codec) : reduced;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/adjust-sourcemap-loader/lib/process/decode-sources-with.js"],"names":["getFieldAsFn","require","decodeSourcesWith","codecs","mustDecode","context","candidates","concat","reduce","reduceValidDecoder","bind","decode","inputSource","i","decoded","length","call","exception","getNamedError","abstract","undefined","Error","details","name","message","stack","filter","Boolean","join","module","exports","reduced","codec","decoder"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,mBAAD,CAA1B;AAEA;;;;;;;;;AAOA,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,UAAnC,EAA+C;AAC7C;AACA,MAAIC,OAAO,GAAG,IAAd,CAF6C,CAI7C;;AACA,MAAIC,UAAU,GAAG,GAAGC,MAAH,CAAUJ,MAAV,EACdK,MADc,CACPC,kBAAkB,CAACC,IAAnB,CAAwB,IAAxB,EAA8BP,MAA9B,CADO,EACgC,EADhC,CAAjB;AAGA;;;;;;AAKA,SAAO,SAASQ,MAAT,CAAgBC,WAAhB,EAA6B;AAElC;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,OAAO,GAAG,IAA1B,EAAgCD,CAAC,GAAGP,UAAU,CAACS,MAAf,IAAyB,CAACD,OAA1D,EAAmED,CAAC,EAApE,EAAwE;AAEtE;AACA,UAAI;AACFC,QAAAA,OAAO,GAAGR,UAAU,CAACO,CAAD,CAAV,CAAcF,MAAd,CAAqBK,IAArB,CAA0BX,OAA1B,EAAmCO,WAAnC,CAAV;AACD,OAFD,CAGA,OAAOK,SAAP,EAAkB;AAChB,eAAOC,aAAa,CAACD,SAAD,CAApB;AACD,OARqE,CAUtE;;;AACA,UAAIH,OAAJ,EAAa;AAEX;AACA,YAAIR,UAAU,CAACO,CAAD,CAAV,CAAcM,QAAlB,EAA4B;AAC1B,iBAAOC,SAAP;AACD,SALU,CAMX;;;AACA,YAAI,OAAON,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,iBAAOI,aAAa,CAAC,8DAA8DJ,OAA/D,CAApB;AACD,SAFD,CAGA;AAHA,aAIK;AACH,mBAAOA,OAAP;AACD;AACF;AACF,KA7BiC,CA+BlC;;;AACA,WAAOV,UAAU,GAAG,IAAIiB,KAAJ,CAAU,mCAAmCT,WAA7C,CAAH,GAA+DQ,SAAhF;;AAEA,aAASF,aAAT,CAAuBI,OAAvB,EAAgC;AAC9B,UAAIC,IAAI,GAAMjB,UAAU,CAACO,CAAD,CAAV,CAAcU,IAAd,IAAsB,WAApC;AAAA,UACIC,OAAO,GAAG,CACR,0BAA0BD,IADlB,EAER,sBAAsBX,WAFd,EAGRU,OAAO,KAAKA,OAAO,CAACG,KAAR,GAAgBH,OAAO,CAACG,KAAxB,GAAgCH,OAArC,CAHC,EAKPI,MALO,CAKAC,OALA,EAMPC,IANO,CAMF,IANE,CADd;AAQA,aAAO,IAAIP,KAAJ,CAAUG,OAAV,CAAP;AACD;AACF,GA7CD;AA8CD;;AAEDK,MAAM,CAACC,OAAP,GAAiB5B,iBAAjB;;AAEA,SAASO,kBAAT,CAA4BsB,OAA5B,EAAqCC,KAArC,EAA4C;AAC1C,MAAIC,OAAO,GAAGjC,YAAY,CAAC,QAAD,CAAZ,CAAuBgC,KAAvB,CAAd;AACA,SAAOC,OAAO,GAAGF,OAAO,CAACxB,MAAR,CAAeyB,KAAf,CAAH,GAA2BD,OAAzC;AACD","sourcesContent":["'use strict';\n\nvar getFieldAsFn = require('./get-field-as-fn');\n\n/**\n * Create a decoder for input sources using the given codec hash\n * @this {object} A loader or compilation\n * @param {Array.<object>} codecs A list of codecs, each with a `decode` function\n * @param {boolean} mustDecode Return an error for a source that is not decoded\n * @returns {function(string):string|Error} A decode function that returns an absolute path or else an Error\n */\nfunction decodeSourcesWith(codecs, mustDecode) {\n  /* jshint validthis:true */\n  var context = this;\n\n  // get a list of valid decoders\n  var candidates = [].concat(codecs)\n    .reduce(reduceValidDecoder.bind(null, codecs), []);\n\n  /**\n   * Attempt to decode the given source path using the previously supplied codecs\n   * @param {string} inputSource A source path from a source map\n   * @returns {Error|string|undefined} An absolute path if decoded else an error if encountered else undefined\n   */\n  return function decode(inputSource) {\n\n    // attempt all candidates until a match\n    for (var i = 0, decoded = null; i < candidates.length && !decoded; i++) {\n\n      // call the decoder\n      try {\n        decoded = candidates[i].decode.call(context, inputSource);\n      }\n      catch (exception) {\n        return getNamedError(exception);\n      }\n\n      // match implies a return value\n      if (decoded) {\n\n        // abstract sources cannot be decoded, only validated\n        if (candidates[i].abstract) {\n          return undefined;\n        }\n        // non-string implies error\n        if (typeof decoded !== 'string') {\n          return getNamedError('Decoder returned a truthy value but it is not a string:\\n' + decoded);\n        }\n        // otherwise success\n        else {\n          return decoded;\n        }\n      }\n    }\n\n    // default is undefined or error\n    return mustDecode ? new Error('No viable decoder for source: ' + inputSource) : undefined;\n\n    function getNamedError(details) {\n      var name    = candidates[i].name || '(unnamed)',\n          message = [\n            'Decoding with codec: ' + name,\n            'Incoming source: ' + inputSource,\n            details && (details.stack ? details.stack : details)\n          ]\n            .filter(Boolean)\n            .join('\\n');\n      return new Error(message);\n    }\n  };\n}\n\nmodule.exports = decodeSourcesWith;\n\nfunction reduceValidDecoder(reduced, codec) {\n  var decoder = getFieldAsFn('decode')(codec);\n  return decoder ? reduced.concat(codec) : reduced;\n}"]},"metadata":{},"sourceType":"script"}