{"ast":null,"code":"// Generated by LiveScript 1.4.0\n(function () {\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n\n  function peek(tokens) {\n    var token;\n    token = tokens[0];\n\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n\n    return token;\n  }\n\n  function consumeIdent(tokens) {\n    var token;\n    token = peek(tokens);\n\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n\n    return tokens.shift();\n  }\n\n  function consumeOp(tokens, op) {\n    var token;\n    token = peek(tokens);\n\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n\n    return tokens.shift();\n  }\n\n  function maybeConsumeOp(tokens, op) {\n    var token;\n    token = tokens[0];\n\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n\n  function consumeArray(tokens) {\n    var types;\n    consumeOp(tokens, '[');\n\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n\n  function consumeTuple(tokens) {\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n\n  function consumeFields(tokens) {\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n\n  function consumeField(tokens) {\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n\n  function maybeConsumeStructure(tokens) {\n    switch (tokens[0]) {\n      case '[':\n        return consumeArray(tokens);\n\n      case '(':\n        return consumeTuple(tokens);\n\n      case '{':\n        return consumeFields(tokens);\n    }\n  }\n\n  function consumeType(tokens) {\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n\n      return structure;\n    }\n  }\n\n  function consumeTypes(tokens) {\n    var lookahead, types, typesSoFar, typeObj, type;\n\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n\n    lookahead = tokens[1];\n\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n\n    types = [];\n    typesSoFar = {};\n\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [{\n        type: 'Undefined'\n      }, {\n        type: 'Null'\n      }];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type;\n\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n\n      typesSoFar[type] = true;\n\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n\n    return types;\n  }\n\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n\n  module.exports = function (input) {\n    var tokens, e;\n\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n\n    tokens = input.match(tokenRegex) || [];\n\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n\n  function in$(x, xs) {\n    var i = -1,\n        l = xs.length >>> 0;\n\n    while (++i < l) if (x === xs[i]) return true;\n\n    return false;\n  }\n}).call(this);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/type-check/lib/parse-type.js"],"names":["identifierRegex","tokenRegex","peek","tokens","token","Error","consumeIdent","test","shift","consumeOp","op","maybeConsumeOp","consumeArray","types","consumeTypes","structure","of","consumeTuple","components","push","consumeFields","fields","subset","ref$","key","consumeField","maybeConsumeStructure","consumeType","wildcard","type","lookahead","typesSoFar","typeObj","Undefined","Null","RegExp","source","module","exports","input","e","length","match","in$","e$","message","JSON","stringify","x","xs","i","l","call"],"mappings":"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","sourcesContent":["// Generated by LiveScript 1.4.0\n(function(){\n  var identifierRegex, tokenRegex;\n  identifierRegex = /[\\$\\w]+/;\n  function peek(tokens){\n    var token;\n    token = tokens[0];\n    if (token == null) {\n      throw new Error('Unexpected end of input.');\n    }\n    return token;\n  }\n  function consumeIdent(tokens){\n    var token;\n    token = peek(tokens);\n    if (!identifierRegex.test(token)) {\n      throw new Error(\"Expected text, got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function consumeOp(tokens, op){\n    var token;\n    token = peek(tokens);\n    if (token !== op) {\n      throw new Error(\"Expected '\" + op + \"', got '\" + token + \"' instead.\");\n    }\n    return tokens.shift();\n  }\n  function maybeConsumeOp(tokens, op){\n    var token;\n    token = tokens[0];\n    if (token === op) {\n      return tokens.shift();\n    } else {\n      return null;\n    }\n  }\n  function consumeArray(tokens){\n    var types;\n    consumeOp(tokens, '[');\n    if (peek(tokens) === ']') {\n      throw new Error(\"Must specify type of Array - eg. [Type], got [] instead.\");\n    }\n    types = consumeTypes(tokens);\n    consumeOp(tokens, ']');\n    return {\n      structure: 'array',\n      of: types\n    };\n  }\n  function consumeTuple(tokens){\n    var components;\n    components = [];\n    consumeOp(tokens, '(');\n    if (peek(tokens) === ')') {\n      throw new Error(\"Tuple must be of at least length 1 - eg. (Type), got () instead.\");\n    }\n    for (;;) {\n      components.push(consumeTypes(tokens));\n      maybeConsumeOp(tokens, ',');\n      if (')' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, ')');\n    return {\n      structure: 'tuple',\n      of: components\n    };\n  }\n  function consumeFields(tokens){\n    var fields, subset, ref$, key, types;\n    fields = {};\n    consumeOp(tokens, '{');\n    subset = false;\n    for (;;) {\n      if (maybeConsumeOp(tokens, '...')) {\n        subset = true;\n        break;\n      }\n      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];\n      fields[key] = types;\n      maybeConsumeOp(tokens, ',');\n      if ('}' === peek(tokens)) {\n        break;\n      }\n    }\n    consumeOp(tokens, '}');\n    return {\n      structure: 'fields',\n      of: fields,\n      subset: subset\n    };\n  }\n  function consumeField(tokens){\n    var key, types;\n    key = consumeIdent(tokens);\n    consumeOp(tokens, ':');\n    types = consumeTypes(tokens);\n    return [key, types];\n  }\n  function maybeConsumeStructure(tokens){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens);\n    case '(':\n      return consumeTuple(tokens);\n    case '{':\n      return consumeFields(tokens);\n    }\n  }\n  function consumeType(tokens){\n    var token, wildcard, type, structure;\n    token = peek(tokens);\n    wildcard = token === '*';\n    if (wildcard || identifierRegex.test(token)) {\n      type = wildcard\n        ? consumeOp(tokens, '*')\n        : consumeIdent(tokens);\n      structure = maybeConsumeStructure(tokens);\n      if (structure) {\n        return structure.type = type, structure;\n      } else {\n        return {\n          type: type\n        };\n      }\n    } else {\n      structure = maybeConsumeStructure(tokens);\n      if (!structure) {\n        throw new Error(\"Unexpected character: \" + token);\n      }\n      return structure;\n    }\n  }\n  function consumeTypes(tokens){\n    var lookahead, types, typesSoFar, typeObj, type;\n    if ('::' === peek(tokens)) {\n      throw new Error(\"No comment before comment separator '::' found.\");\n    }\n    lookahead = tokens[1];\n    if (lookahead != null && lookahead === '::') {\n      tokens.shift();\n      tokens.shift();\n    }\n    types = [];\n    typesSoFar = {};\n    if ('Maybe' === peek(tokens)) {\n      tokens.shift();\n      types = [\n        {\n          type: 'Undefined'\n        }, {\n          type: 'Null'\n        }\n      ];\n      typesSoFar = {\n        Undefined: true,\n        Null: true\n      };\n    }\n    for (;;) {\n      typeObj = consumeType(tokens), type = typeObj.type;\n      if (!typesSoFar[type]) {\n        types.push(typeObj);\n      }\n      typesSoFar[type] = true;\n      if (!maybeConsumeOp(tokens, '|')) {\n        break;\n      }\n    }\n    return types;\n  }\n  tokenRegex = RegExp('\\\\.\\\\.\\\\.|::|->|' + identifierRegex.source + '|\\\\S', 'g');\n  module.exports = function(input){\n    var tokens, e;\n    if (!input.length) {\n      throw new Error('No type specified.');\n    }\n    tokens = input.match(tokenRegex) || [];\n    if (in$('->', tokens)) {\n      throw new Error(\"Function types are not supported.\\ To validate that something is a function, you may use 'Function'.\");\n    }\n    try {\n      return consumeTypes(tokens);\n    } catch (e$) {\n      e = e$;\n      throw new Error(e.message + \" - Remaining tokens: \" + JSON.stringify(tokens) + \" - Initial input: '\" + input + \"'\");\n    }\n  };\n  function in$(x, xs){\n    var i = -1, l = xs.length >>> 0;\n    while (++i < l) if (x === xs[i]) return true;\n    return false;\n  }\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}