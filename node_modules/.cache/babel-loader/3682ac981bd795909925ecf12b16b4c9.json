{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst globToRegExp = require('glob-to-regexp');\n\nmodule.exports = normalizeOptions;\nlet isWindows = /^win/.test(process.platform);\n/**\n * @typedef {Object} FSFacade\n * @property {fs.readdir} readdir\n * @property {fs.stat} stat\n * @property {fs.lstat} lstat\n */\n\n/**\n * Validates and normalizes the options argument\n *\n * @param {object} [options] - User-specified options, if any\n * @param {object} internalOptions - Internal options that aren't part of the public API\n *\n * @param {number|boolean|function} [options.deep]\n * The number of directories to recursively traverse. Any falsy value or negative number will\n * default to zero, so only the top-level contents will be returned. Set to `true` or `Infinity`\n * to traverse all subdirectories.  Or provide a function that accepts a {@link fs.Stats} object\n * and returns a truthy value if the directory's contents should be crawled.\n *\n * @param {function|string|RegExp} [options.filter]\n * A function that accepts a {@link fs.Stats} object and returns a truthy value if the data should\n * be returned.  Or a RegExp or glob string pattern, to filter by file name.\n *\n * @param {string} [options.sep]\n * The path separator to use. By default, the OS-specific separator will be used, but this can be\n * set to a specific value to ensure consistency across platforms.\n *\n * @param {string} [options.basePath]\n * The base path to prepend to each result. If empty, then all results will be relative to `dir`.\n *\n * @param {FSFacade} [options.fs]\n * Synchronous or asynchronous facades for Node.js File System module\n *\n * @param {object} [internalOptions.facade]\n * Synchronous or asynchronous facades for various methods, including for the Node.js File System module\n *\n * @param {boolean} [internalOptions.emit]\n * Indicates whether the reader should emit \"file\", \"directory\", and \"symlink\" events\n *\n * @param {boolean} [internalOptions.stats]\n * Indicates whether the reader should emit {@link fs.Stats} objects instead of path strings\n *\n * @returns {object}\n */\n\nfunction normalizeOptions(options, internalOptions) {\n  if (options === null || options === undefined) {\n    options = {};\n  } else if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n\n  let recurseDepth,\n      recurseFn,\n      recurseRegExp,\n      recurseGlob,\n      deep = options.deep;\n\n  if (deep === null || deep === undefined) {\n    recurseDepth = 0;\n  } else if (typeof deep === 'boolean') {\n    recurseDepth = deep ? Infinity : 0;\n  } else if (typeof deep === 'number') {\n    if (deep < 0 || isNaN(deep)) {\n      throw new Error('options.deep must be a positive number');\n    } else if (Math.floor(deep) !== deep) {\n      throw new Error('options.deep must be an integer');\n    } else {\n      recurseDepth = deep;\n    }\n  } else if (typeof deep === 'function') {\n    recurseDepth = Infinity;\n    recurseFn = deep;\n  } else if (deep instanceof RegExp) {\n    recurseDepth = Infinity;\n    recurseRegExp = deep;\n  } else if (typeof deep === 'string' && deep.length > 0) {\n    recurseDepth = Infinity;\n    recurseGlob = globToRegExp(deep, {\n      extended: true,\n      globstar: true\n    });\n  } else {\n    throw new TypeError('options.deep must be a boolean, number, function, regular expression, or glob pattern');\n  }\n\n  let filterFn,\n      filterRegExp,\n      filterGlob,\n      filter = options.filter;\n\n  if (filter !== null && filter !== undefined) {\n    if (typeof filter === 'function') {\n      filterFn = filter;\n    } else if (filter instanceof RegExp) {\n      filterRegExp = filter;\n    } else if (typeof filter === 'string' && filter.length > 0) {\n      filterGlob = globToRegExp(filter, {\n        extended: true,\n        globstar: true\n      });\n    } else {\n      throw new TypeError('options.filter must be a function, regular expression, or glob pattern');\n    }\n  }\n\n  let sep = options.sep;\n\n  if (sep === null || sep === undefined) {\n    sep = path.sep;\n  } else if (typeof sep !== 'string') {\n    throw new TypeError('options.sep must be a string');\n  }\n\n  let basePath = options.basePath;\n\n  if (basePath === null || basePath === undefined) {\n    basePath = '';\n  } else if (typeof basePath === 'string') {\n    // Append a path separator to the basePath, if necessary\n    if (basePath && basePath.substr(-1) !== sep) {\n      basePath += sep;\n    }\n  } else {\n    throw new TypeError('options.basePath must be a string');\n  } // Convert the basePath to POSIX (forward slashes)\n  // so that glob pattern matching works consistently, even on Windows\n\n\n  let posixBasePath = basePath;\n\n  if (posixBasePath && sep !== '/') {\n    posixBasePath = posixBasePath.replace(new RegExp('\\\\' + sep, 'g'), '/');\n    /* istanbul ignore if */\n\n    if (isWindows) {\n      // Convert Windows root paths (C:\\) and UNCs (\\\\) to POSIX root paths\n      posixBasePath = posixBasePath.replace(/^([a-zA-Z]\\:\\/|\\/\\/)/, '/');\n    }\n  } // Determine which facade methods to use\n\n\n  let facade;\n\n  if (options.fs === null || options.fs === undefined) {\n    // The user didn't provide their own facades, so use our internal ones\n    facade = internalOptions.facade;\n  } else if (typeof options.fs === 'object') {\n    // Merge the internal facade methods with the user-provided `fs` facades\n    facade = Object.assign({}, internalOptions.facade);\n    facade.fs = Object.assign({}, internalOptions.facade.fs, options.fs);\n  } else {\n    throw new TypeError('options.fs must be an object');\n  }\n\n  return {\n    recurseDepth,\n    recurseFn,\n    recurseRegExp,\n    recurseGlob,\n    filterFn,\n    filterRegExp,\n    filterGlob,\n    sep,\n    basePath,\n    posixBasePath,\n    facade,\n    emit: !!internalOptions.emit,\n    stats: !!internalOptions.stats\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@mrmlnc/readdir-enhanced/lib/normalize-options.js"],"names":["path","require","globToRegExp","module","exports","normalizeOptions","isWindows","test","process","platform","options","internalOptions","undefined","TypeError","recurseDepth","recurseFn","recurseRegExp","recurseGlob","deep","Infinity","isNaN","Error","Math","floor","RegExp","length","extended","globstar","filterFn","filterRegExp","filterGlob","filter","sep","basePath","substr","posixBasePath","replace","facade","fs","Object","assign","emit","stats"],"mappings":"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","sourcesContent":["'use strict';\n\nconst path = require('path');\nconst globToRegExp = require('glob-to-regexp');\n\nmodule.exports = normalizeOptions;\n\nlet isWindows = /^win/.test(process.platform);\n\n/**\n * @typedef {Object} FSFacade\n * @property {fs.readdir} readdir\n * @property {fs.stat} stat\n * @property {fs.lstat} lstat\n */\n\n/**\n * Validates and normalizes the options argument\n *\n * @param {object} [options] - User-specified options, if any\n * @param {object} internalOptions - Internal options that aren't part of the public API\n *\n * @param {number|boolean|function} [options.deep]\n * The number of directories to recursively traverse. Any falsy value or negative number will\n * default to zero, so only the top-level contents will be returned. Set to `true` or `Infinity`\n * to traverse all subdirectories.  Or provide a function that accepts a {@link fs.Stats} object\n * and returns a truthy value if the directory's contents should be crawled.\n *\n * @param {function|string|RegExp} [options.filter]\n * A function that accepts a {@link fs.Stats} object and returns a truthy value if the data should\n * be returned.  Or a RegExp or glob string pattern, to filter by file name.\n *\n * @param {string} [options.sep]\n * The path separator to use. By default, the OS-specific separator will be used, but this can be\n * set to a specific value to ensure consistency across platforms.\n *\n * @param {string} [options.basePath]\n * The base path to prepend to each result. If empty, then all results will be relative to `dir`.\n *\n * @param {FSFacade} [options.fs]\n * Synchronous or asynchronous facades for Node.js File System module\n *\n * @param {object} [internalOptions.facade]\n * Synchronous or asynchronous facades for various methods, including for the Node.js File System module\n *\n * @param {boolean} [internalOptions.emit]\n * Indicates whether the reader should emit \"file\", \"directory\", and \"symlink\" events\n *\n * @param {boolean} [internalOptions.stats]\n * Indicates whether the reader should emit {@link fs.Stats} objects instead of path strings\n *\n * @returns {object}\n */\nfunction normalizeOptions (options, internalOptions) {\n  if (options === null || options === undefined) {\n    options = {};\n  }\n  else if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n\n  let recurseDepth, recurseFn, recurseRegExp, recurseGlob, deep = options.deep;\n  if (deep === null || deep === undefined) {\n    recurseDepth = 0;\n  }\n  else if (typeof deep === 'boolean') {\n    recurseDepth = deep ? Infinity : 0;\n  }\n  else if (typeof deep === 'number') {\n    if (deep < 0 || isNaN(deep)) {\n      throw new Error('options.deep must be a positive number');\n    }\n    else if (Math.floor(deep) !== deep) {\n      throw new Error('options.deep must be an integer');\n    }\n    else {\n      recurseDepth = deep;\n    }\n  }\n  else if (typeof deep === 'function') {\n    recurseDepth = Infinity;\n    recurseFn = deep;\n  }\n  else if (deep instanceof RegExp) {\n    recurseDepth = Infinity;\n    recurseRegExp = deep;\n  }\n  else if (typeof deep === 'string' && deep.length > 0) {\n    recurseDepth = Infinity;\n    recurseGlob = globToRegExp(deep, { extended: true, globstar: true });\n  }\n  else {\n    throw new TypeError('options.deep must be a boolean, number, function, regular expression, or glob pattern');\n  }\n\n  let filterFn, filterRegExp, filterGlob, filter = options.filter;\n  if (filter !== null && filter !== undefined) {\n    if (typeof filter === 'function') {\n      filterFn = filter;\n    }\n    else if (filter instanceof RegExp) {\n      filterRegExp = filter;\n    }\n    else if (typeof filter === 'string' && filter.length > 0) {\n      filterGlob = globToRegExp(filter, { extended: true, globstar: true });\n    }\n    else {\n      throw new TypeError('options.filter must be a function, regular expression, or glob pattern');\n    }\n  }\n\n  let sep = options.sep;\n  if (sep === null || sep === undefined) {\n    sep = path.sep;\n  }\n  else if (typeof sep !== 'string') {\n    throw new TypeError('options.sep must be a string');\n  }\n\n  let basePath = options.basePath;\n  if (basePath === null || basePath === undefined) {\n    basePath = '';\n  }\n  else if (typeof basePath === 'string') {\n    // Append a path separator to the basePath, if necessary\n    if (basePath && basePath.substr(-1) !== sep) {\n      basePath += sep;\n    }\n  }\n  else {\n    throw new TypeError('options.basePath must be a string');\n  }\n\n  // Convert the basePath to POSIX (forward slashes)\n  // so that glob pattern matching works consistently, even on Windows\n  let posixBasePath = basePath;\n  if (posixBasePath && sep !== '/') {\n    posixBasePath = posixBasePath.replace(new RegExp('\\\\' + sep, 'g'), '/');\n\n    /* istanbul ignore if */\n    if (isWindows) {\n      // Convert Windows root paths (C:\\) and UNCs (\\\\) to POSIX root paths\n      posixBasePath = posixBasePath.replace(/^([a-zA-Z]\\:\\/|\\/\\/)/, '/');\n    }\n  }\n\n  // Determine which facade methods to use\n  let facade;\n  if (options.fs === null || options.fs === undefined) {\n    // The user didn't provide their own facades, so use our internal ones\n    facade = internalOptions.facade;\n  }\n  else if (typeof options.fs === 'object') {\n    // Merge the internal facade methods with the user-provided `fs` facades\n    facade = Object.assign({}, internalOptions.facade);\n    facade.fs = Object.assign({}, internalOptions.facade.fs, options.fs);\n  }\n  else {\n    throw new TypeError('options.fs must be an object');\n  }\n\n  return {\n    recurseDepth,\n    recurseFn,\n    recurseRegExp,\n    recurseGlob,\n    filterFn,\n    filterRegExp,\n    filterGlob,\n    sep,\n    basePath,\n    posixBasePath,\n    facade,\n    emit: !!internalOptions.emit,\n    stats: !!internalOptions.stats,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}