{"ast":null,"code":"/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst {\n  isParenthesized: isParenthesizedRaw\n} = require(\"eslint-utils\");\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow unnecessary parentheses\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-parens\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"functions\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }, {\n          type: \"object\",\n          properties: {\n            conditionalAssign: {\n              type: \"boolean\"\n            },\n            nestedBinaryExpressions: {\n              type: \"boolean\"\n            },\n            returnAssign: {\n              type: \"boolean\"\n            },\n            ignoreJSX: {\n              enum: [\"none\", \"all\", \"single-line\", \"multi-line\"]\n            },\n            enforceForArrowConditionals: {\n              type: \"boolean\"\n            },\n            enforceForSequenceExpressions: {\n              type: \"boolean\"\n            },\n            enforceForNewInMemberExpressions: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      unexpected: \"Unnecessary parentheses around expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const tokensToIgnore = new WeakSet();\n    const precedence = astUtils.getPrecedence;\n    const ALL_NODES = context.options[0] !== \"functions\";\n    const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n    const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n    const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n    const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;\n    const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;\n    const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;\n    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({\n      type: \"AssignmentExpression\"\n    });\n    const PRECEDENCE_OF_UPDATE_EXPR = precedence({\n      type: \"UpdateExpression\"\n    });\n    let reportsBuffer;\n    /**\n     * Determines if this rule should be enforced for a node given the current configuration.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the rule should be enforced for this node.\n     * @private\n     */\n\n    function ruleApplies(node) {\n      if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n        const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n        switch (IGNORE_JSX) {\n          // Exclude this JSX element from linting\n          case \"all\":\n            return false;\n          // Exclude this JSX element if it is multi-line element\n\n          case \"multi-line\":\n            return isSingleLine;\n          // Exclude this JSX element if it is single-line element\n\n          case \"single-line\":\n            return !isSingleLine;\n          // Nothing special to be done for JSX elements\n\n          case \"none\":\n            break;\n          // no default\n        }\n      }\n\n      if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n        return false;\n      }\n\n      return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n    }\n    /**\n     * Determines if a node is surrounded by parentheses.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is parenthesised.\n     * @private\n     */\n\n\n    function isParenthesised(node) {\n      return isParenthesizedRaw(1, node, sourceCode);\n    }\n    /**\n     * Determines if a node is surrounded by parentheses twice.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is doubly parenthesised.\n     * @private\n     */\n\n\n    function isParenthesisedTwice(node) {\n      return isParenthesizedRaw(2, node, sourceCode);\n    }\n    /**\n     * Determines if a node is surrounded by (potentially) invalid parentheses.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is incorrectly parenthesised.\n     * @private\n     */\n\n\n    function hasExcessParens(node) {\n      return ruleApplies(node) && isParenthesised(node);\n    }\n    /**\n     * Determines if a node that is expected to be parenthesised is surrounded by\n     * (potentially) invalid extra parentheses.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n     * @private\n     */\n\n\n    function hasDoubleExcessParens(node) {\n      return ruleApplies(node) && isParenthesisedTwice(node);\n    }\n    /**\n     * Determines if a node test expression is allowed to have a parenthesised assignment\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the assignment can be parenthesised.\n     * @private\n     */\n\n\n    function isCondAssignException(node) {\n      return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n    }\n    /**\n     * Determines if a node is in a return statement\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is in a return statement.\n     * @private\n     */\n\n\n    function isInReturnStatement(node) {\n      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (currentNode.type === \"ReturnStatement\" || currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\") {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a constructor function is newed-up with parens\n     * @param {ASTNode} newExpression The NewExpression node to be checked.\n     * @returns {boolean} True if the constructor is called with parens.\n     * @private\n     */\n\n\n    function isNewExpressionWithParens(newExpression) {\n      const lastToken = sourceCode.getLastToken(newExpression);\n      const penultimateToken = sourceCode.getTokenBefore(lastToken);\n      return newExpression.arguments.length > 0 || // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n      astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];\n    }\n    /**\n     * Determines if a node is or contains an assignment expression\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is or contains an assignment expression.\n     * @private\n     */\n\n\n    function containsAssignment(node) {\n      if (node.type === \"AssignmentExpression\") {\n        return true;\n      }\n\n      if (node.type === \"ConditionalExpression\" && (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n        return true;\n      }\n\n      if (node.left && node.left.type === \"AssignmentExpression\" || node.right && node.right.type === \"AssignmentExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the assignment can be parenthesised.\n     * @private\n     */\n\n\n    function isReturnAssignException(node) {\n      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n        return false;\n      }\n\n      if (node.type === \"ReturnStatement\") {\n        return node.argument && containsAssignment(node.argument);\n      }\n\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        return containsAssignment(node.body);\n      }\n\n      return containsAssignment(node);\n    }\n    /**\n     * Determines if a node following a [no LineTerminator here] restriction is\n     * surrounded by (potentially) invalid extra parentheses.\n     * @param {Token} token The token preceding the [no LineTerminator here] restriction.\n     * @param {ASTNode} node The node to be checked.\n     * @returns {boolean} True if the node is incorrectly parenthesised.\n     * @private\n     */\n\n\n    function hasExcessParensNoLineTerminator(token, node) {\n      if (token.loc.end.line === node.loc.start.line) {\n        return hasExcessParens(node);\n      }\n\n      return hasDoubleExcessParens(node);\n    }\n    /**\n     * Determines whether a node should be preceded by an additional space when removing parens\n     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n     * @returns {boolean} `true` if a space should be inserted before the node\n     * @private\n     */\n\n\n    function requiresLeadingSpace(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);\n      const firstToken = sourceCode.getFirstToken(node);\n      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === firstToken.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);\n    }\n    /**\n     * Determines whether a node should be followed by an additional space when removing parens\n     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n     * @returns {boolean} `true` if a space should be inserted after the node\n     * @private\n     */\n\n\n    function requiresTrailingSpace(node) {\n      const nextTwoTokens = sourceCode.getTokensAfter(node, {\n        count: 2\n      });\n      const rightParenToken = nextTwoTokens[0];\n      const tokenAfterRightParen = nextTwoTokens[1];\n      const tokenBeforeRightParen = sourceCode.getLastToken(node);\n      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n    }\n    /**\n     * Determines if a given expression node is an IIFE\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the given node is an IIFE\n     */\n\n\n    function isIIFE(node) {\n      return node.type === \"CallExpression\" && node.callee.type === \"FunctionExpression\";\n    }\n    /**\n     * Report the node\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const rightParenToken = sourceCode.getTokenAfter(node);\n\n      if (!isParenthesisedTwice(node)) {\n        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n          return;\n        }\n\n        if (isIIFE(node) && !isParenthesised(node.callee)) {\n          return;\n        }\n      }\n      /**\n       * Finishes reporting\n       * @returns {void}\n       * @private\n       */\n\n\n      function finishReport() {\n        context.report({\n          node,\n          loc: leftParenToken.loc,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n            return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n          }\n\n        });\n      }\n\n      if (reportsBuffer) {\n        reportsBuffer.reports.push({\n          node,\n          finishReport\n        });\n        return;\n      }\n\n      finishReport();\n    }\n    /**\n     * Evaluate Unary update\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkUnaryUpdate(node) {\n      if (node.type === \"UnaryExpression\" && node.argument.type === \"BinaryExpression\" && node.argument.operator === \"**\") {\n        return;\n      }\n\n      if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n        report(node.argument);\n      }\n    }\n    /**\n     * Check if a member expression contains a call expression\n     * @param {ASTNode} node MemberExpression node to evaluate\n     * @returns {boolean} true if found, false if not\n     */\n\n\n    function doesMemberExpressionContainCallExpression(node) {\n      let currentNode = node.object;\n      let currentNodeType = node.object.type;\n\n      while (currentNodeType === \"MemberExpression\") {\n        currentNode = currentNode.object;\n        currentNodeType = currentNode.type;\n      }\n\n      return currentNodeType === \"CallExpression\";\n    }\n    /**\n     * Evaluate a new call\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkCallNew(node) {\n      const callee = node.callee;\n\n      if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {\n        const hasNewParensException = callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee);\n\n        if (hasDoubleExcessParens(callee) || !isIIFE(node) && !hasNewParensException && !(\n        /*\n         * Allow extra parens around a new expression if\n         * there are intervening parentheses.\n         */\n        callee.type === \"MemberExpression\" && doesMemberExpressionContainCallExpression(callee))) {\n          report(node.callee);\n        }\n      }\n\n      node.arguments.filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR).forEach(report);\n    }\n    /**\n     * Evaluate binary logicals\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkBinaryLogical(node) {\n      const prec = precedence(node);\n      const leftPrecedence = precedence(node.left);\n      const rightPrecedence = precedence(node.right);\n      const isExponentiation = node.operator === \"**\";\n      const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\") || node.left.type === \"UnaryExpression\" && isExponentiation;\n      const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n      if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation)) {\n        report(node.left);\n      }\n\n      if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation)) {\n        report(node.right);\n      }\n    }\n    /**\n     * Check the parentheses around the super class of the given class definition.\n     * @param {ASTNode} node The node of class declarations to check.\n     * @returns {void}\n     */\n\n\n    function checkClass(node) {\n      if (!node.superClass) {\n        return;\n      }\n      /*\n       * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n       * Otherwise, parentheses are needed.\n       */\n\n\n      const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);\n\n      if (hasExtraParens) {\n        report(node.superClass);\n      }\n    }\n    /**\n     * Check the parentheses around the argument of the given spread operator.\n     * @param {ASTNode} node The node of spread elements/properties to check.\n     * @returns {void}\n     */\n\n\n    function checkSpreadOperator(node) {\n      const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR ? hasExcessParens(node.argument) : hasDoubleExcessParens(node.argument);\n\n      if (hasExtraParens) {\n        report(node.argument);\n      }\n    }\n    /**\n     * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n     * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n     * @returns {void}\n     */\n\n\n    function checkExpressionOrExportStatement(node) {\n      const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n      const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n      if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === \"Keyword\" && (secondToken.value === \"function\" || secondToken.value === \"class\" || secondToken.value === \"let\" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === \"Identifier\")) || secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\")) {\n        tokensToIgnore.add(secondToken);\n      }\n\n      if (hasExcessParens(node)) {\n        report(node);\n      }\n    }\n    /**\n     * Finds the path from the given node to the specified ancestor.\n     * @param {ASTNode} node First node in the path.\n     * @param {ASTNode} ancestor Last node in the path.\n     * @returns {ASTNode[]} Path, including both nodes.\n     * @throws {Error} If the given node does not have the specified ancestor.\n     */\n\n\n    function pathToAncestor(node, ancestor) {\n      const path = [node];\n      let currentNode = node;\n\n      while (currentNode !== ancestor) {\n        currentNode = currentNode.parent;\n        /* istanbul ignore if */\n\n        if (currentNode === null) {\n          throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n        }\n\n        path.push(currentNode);\n      }\n\n      return path;\n    }\n    /**\n     * Finds the path from the given node to the specified descendant.\n     * @param {ASTNode} node First node in the path.\n     * @param {ASTNode} descendant Last node in the path.\n     * @returns {ASTNode[]} Path, including both nodes.\n     * @throws {Error} If the given node does not have the specified descendant.\n     */\n\n\n    function pathToDescendant(node, descendant) {\n      return pathToAncestor(descendant, node).reverse();\n    }\n    /**\n     * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\n     * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\n     * @param {ASTNode} node Ancestor of an 'in' expression.\n     * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\n     * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\n     */\n\n\n    function isSafelyEnclosingInExpression(node, child) {\n      switch (node.type) {\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n        case \"BlockStatement\":\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n        case \"TemplateLiteral\":\n          return true;\n\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n          return node.params.includes(child);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.arguments.includes(child);\n\n        case \"MemberExpression\":\n          return node.computed && node.property === child;\n\n        case \"ConditionalExpression\":\n          return node.consequent === child;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\n     * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\n     * @returns {void}\n     */\n\n\n    function startNewReportsBuffering() {\n      reportsBuffer = {\n        upper: reportsBuffer,\n        inExpressionNodes: [],\n        reports: []\n      };\n    }\n    /**\n     * Ends the current reports buffering.\n     * @returns {void}\n     */\n\n\n    function endCurrentReportsBuffering() {\n      const {\n        upper,\n        inExpressionNodes,\n        reports\n      } = reportsBuffer;\n\n      if (upper) {\n        upper.inExpressionNodes.push(...inExpressionNodes);\n        upper.reports.push(...reports);\n      } else {\n        // flush remaining reports\n        reports.forEach(({\n          finishReport\n        }) => finishReport());\n      }\n\n      reportsBuffer = upper;\n    }\n    /**\n     * Checks whether the given node is in the current reports buffer.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is in the current buffer, false otherwise.\n     */\n\n\n    function isInCurrentReportsBuffer(node) {\n      return reportsBuffer.reports.some(r => r.node === node);\n    }\n    /**\n     * Removes the given node from the current reports buffer.\n     * @param {ASTNode} node Node to remove.\n     * @returns {void}\n     */\n\n\n    function removeFromCurrentReportsBuffer(node) {\n      reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n    }\n\n    return {\n      ArrayExpression(node) {\n        node.elements.filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR).forEach(report);\n      },\n\n      ArrowFunctionExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (node.body.type === \"ConditionalExpression\" && IGNORE_ARROW_CONDITIONALS && !isParenthesisedTwice(node.body)) {\n          return;\n        }\n\n        if (node.body.type !== \"BlockStatement\") {\n          const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n          const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n          if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n            tokensToIgnore.add(firstBodyToken);\n          }\n\n          if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n            report(node.body);\n          }\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n          report(node.right);\n        }\n      },\n\n      BinaryExpression(node) {\n        if (reportsBuffer && node.operator === \"in\") {\n          reportsBuffer.inExpressionNodes.push(node);\n        }\n\n        checkBinaryLogical(node);\n      },\n\n      CallExpression: checkCallNew,\n\n      ClassBody(node) {\n        node.body.filter(member => member.type === \"MethodDefinition\" && member.computed && member.key && hasExcessParens(member.key) && precedence(member.key) >= PRECEDENCE_OF_ASSIGNMENT_EXPR).forEach(member => report(member.key));\n      },\n\n      ConditionalExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (hasExcessParens(node.test) && precedence(node.test) >= precedence({\n          type: \"LogicalExpression\",\n          operator: \"||\"\n        })) {\n          report(node.test);\n        }\n\n        if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n          report(node.consequent);\n        }\n\n        if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n          report(node.alternate);\n        }\n      },\n\n      DoWhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n      ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n      \"ForInStatement, ForOfStatement\"(node) {\n        if (node.left.type !== \"VariableDeclarator\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n          if (firstLeftToken.value === \"let\" && (\n          /*\n           * If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`\n           * Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.\n           */\n          firstLeftToken.range[1] === node.left.range[1] ||\n          /*\n          * If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`\n          * Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.\n          */\n          astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)))) {\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n\n        if (!(node.type === \"ForOfStatement\" && node.right.type === \"SequenceExpression\") && hasExcessParens(node.right)) {\n          report(node.right);\n        }\n\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n      },\n\n      ForStatement(node) {\n        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n\n        if (node.update && hasExcessParens(node.update)) {\n          report(node.update);\n        }\n\n        if (node.init) {\n          startNewReportsBuffering();\n\n          if (hasExcessParens(node.init)) {\n            report(node.init);\n          }\n        }\n      },\n\n      \"ForStatement > *.init:exit\"(node) {\n        /*\n         * Removing parentheses around `in` expressions might change semantics and cause errors.\n         *\n         * For example, this valid for loop:\n         *      for (let a = (b in c); ;);\n         * after removing parentheses would be treated as an invalid for-in loop:\n         *      for (let a = b in c; ;);\n         */\n        if (reportsBuffer.reports.length) {\n          reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n            const path = pathToDescendant(node, inExpressionNode);\n            let nodeToExclude;\n\n            for (let i = 0; i < path.length; i++) {\n              const pathNode = path[i];\n\n              if (i < path.length - 1) {\n                const nextPathNode = path[i + 1];\n\n                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n                  // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                  return;\n                }\n              }\n\n              if (isParenthesised(pathNode)) {\n                if (isInCurrentReportsBuffer(pathNode)) {\n                  // This node was supposed to be reported, but parentheses might be necessary.\n                  if (isParenthesisedTwice(pathNode)) {\n                    /*\n                     * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\n                     * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\n                     * The remaining pair is safely enclosing the 'in' expression.\n                     */\n                    return;\n                  } // Exclude the outermost node only.\n\n\n                  if (!nodeToExclude) {\n                    nodeToExclude = pathNode;\n                  } // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n\n                } else {\n                  // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                  return;\n                }\n              }\n            } // Exclude the node from the list (i.e. treat parentheses as necessary)\n\n\n            removeFromCurrentReportsBuffer(nodeToExclude);\n          });\n        }\n\n        endCurrentReportsBuffering();\n      },\n\n      IfStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      ImportExpression(node) {\n        const {\n          source\n        } = node;\n\n        if (source.type === \"SequenceExpression\") {\n          if (hasDoubleExcessParens(source)) {\n            report(source);\n          }\n        } else if (hasExcessParens(source)) {\n          report(source);\n        }\n      },\n\n      LogicalExpression: checkBinaryLogical,\n\n      MemberExpression(node) {\n        const nodeObjHasExcessParens = hasExcessParens(node.object);\n\n        if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) || // RegExp literal is allowed to have parens (#1589)\n        node.object.type === \"Literal\" && node.object.regex))) {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && node.object.type === \"CallExpression\" && node.parent.type !== \"NewExpression\") {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === \"NewExpression\" && isNewExpressionWithParens(node.object)) {\n          report(node.object);\n        }\n\n        if (node.computed && hasExcessParens(node.property)) {\n          report(node.property);\n        }\n      },\n\n      NewExpression: checkCallNew,\n\n      ObjectExpression(node) {\n        node.properties.filter(property => {\n          const value = property.value;\n          return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;\n        }).forEach(property => report(property.value));\n      },\n\n      Property(node) {\n        if (node.computed) {\n          const {\n            key\n          } = node;\n\n          if (key && hasExcessParens(key) && precedence(key) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n            report(key);\n          }\n        }\n      },\n\n      ReturnStatement(node) {\n        const returnToken = sourceCode.getFirstToken(node);\n\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) && // RegExp literal is allowed to have parens (#1589)\n        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n          report(node.argument);\n        }\n      },\n\n      SequenceExpression(node) {\n        node.expressions.filter(e => hasExcessParens(e) && precedence(e) >= precedence(node)).forEach(report);\n      },\n\n      SwitchCase(node) {\n        if (node.test && hasExcessParens(node.test)) {\n          report(node.test);\n        }\n      },\n\n      SwitchStatement(node) {\n        if (hasExcessParens(node.discriminant)) {\n          report(node.discriminant);\n        }\n      },\n\n      ThrowStatement(node) {\n        const throwToken = sourceCode.getFirstToken(node);\n\n        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n          report(node.argument);\n        }\n      },\n\n      UnaryExpression: checkUnaryUpdate,\n      UpdateExpression: checkUnaryUpdate,\n      AwaitExpression: checkUnaryUpdate,\n\n      VariableDeclarator(node) {\n        if (node.init && hasExcessParens(node.init) && precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR && // RegExp literal is allowed to have parens (#1589)\n        !(node.init.type === \"Literal\" && node.init.regex)) {\n          report(node.init);\n        }\n      },\n\n      WhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      WithStatement(node) {\n        if (hasExcessParens(node.object)) {\n          report(node.object);\n        }\n      },\n\n      YieldExpression(node) {\n        if (node.argument) {\n          const yieldToken = sourceCode.getFirstToken(node);\n\n          if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {\n            report(node.argument);\n          }\n        }\n      },\n\n      ClassDeclaration: checkClass,\n      ClassExpression: checkClass,\n      SpreadElement: checkSpreadOperator,\n      SpreadProperty: checkSpreadOperator,\n      ExperimentalSpreadProperty: checkSpreadOperator,\n\n      TemplateLiteral(node) {\n        node.expressions.filter(e => e && hasExcessParens(e)).forEach(report);\n      },\n\n      AssignmentPattern(node) {\n        const {\n          right\n        } = node;\n\n        if (right && hasExcessParens(right) && precedence(right) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n          report(right);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-extra-parens.js"],"names":["isParenthesized","isParenthesizedRaw","require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","properties","conditionalAssign","nestedBinaryExpressions","returnAssign","ignoreJSX","enforceForArrowConditionals","enforceForSequenceExpressions","enforceForNewInMemberExpressions","additionalProperties","messages","unexpected","create","context","sourceCode","getSourceCode","tokensToIgnore","WeakSet","precedence","getPrecedence","ALL_NODES","options","EXCEPT_COND_ASSIGN","NESTED_BINARY","EXCEPT_RETURN_ASSIGN","IGNORE_JSX","IGNORE_ARROW_CONDITIONALS","IGNORE_SEQUENCE_EXPRESSIONS","IGNORE_NEW_IN_MEMBER_EXPR","PRECEDENCE_OF_ASSIGNMENT_EXPR","PRECEDENCE_OF_UPDATE_EXPR","reportsBuffer","ruleApplies","node","isSingleLine","loc","start","line","end","isParenthesised","isParenthesisedTwice","hasExcessParens","hasDoubleExcessParens","isCondAssignException","test","isInReturnStatement","currentNode","parent","body","isNewExpressionWithParens","newExpression","lastToken","getLastToken","penultimateToken","getTokenBefore","arguments","length","isOpeningParenToken","isClosingParenToken","callee","range","containsAssignment","consequent","alternate","left","right","isReturnAssignException","argument","hasExcessParensNoLineTerminator","token","requiresLeadingSpace","leftParenToken","tokenBeforeLeftParen","firstToken","getFirstToken","canTokensBeAdjacent","requiresTrailingSpace","nextTwoTokens","getTokensAfter","count","rightParenToken","tokenAfterRightParen","tokenBeforeRightParen","isSpaceBetweenTokens","isIIFE","report","getTokenAfter","has","finishReport","messageId","fix","fixer","parenthesizedSource","text","slice","replaceTextRange","reports","push","checkUnaryUpdate","operator","doesMemberExpressionContainCallExpression","object","currentNodeType","checkCallNew","hasNewParensException","filter","arg","forEach","checkBinaryLogical","prec","leftPrecedence","rightPrecedence","isExponentiation","shouldSkipLeft","shouldSkipRight","checkClass","superClass","hasExtraParens","checkSpreadOperator","checkExpressionOrExportStatement","secondToken","isNotOpeningParenToken","thirdToken","tokenAfterClosingParens","isNotClosingParenToken","isOpeningBraceToken","value","isOpeningBracketToken","add","pathToAncestor","ancestor","path","Error","pathToDescendant","descendant","reverse","isSafelyEnclosingInExpression","child","params","includes","computed","property","startNewReportsBuffering","upper","inExpressionNodes","endCurrentReportsBuffering","isInCurrentReportsBuffer","some","r","removeFromCurrentReportsBuffer","ArrayExpression","elements","e","ArrowFunctionExpression","firstBodyToken","tokenBeforeFirst","AssignmentExpression","BinaryExpression","CallExpression","ClassBody","member","key","ConditionalExpression","DoWhileStatement","ExportDefaultDeclaration","declaration","ExpressionStatement","expression","firstLeftToken","ForStatement","update","init","inExpressionNode","nodeToExclude","i","pathNode","nextPathNode","IfStatement","ImportExpression","source","LogicalExpression","MemberExpression","nodeObjHasExcessParens","isDecimalInteger","regex","NewExpression","ObjectExpression","Property","ReturnStatement","returnToken","SequenceExpression","expressions","SwitchCase","SwitchStatement","discriminant","ThrowStatement","throwToken","UnaryExpression","UpdateExpression","AwaitExpression","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","yieldToken","ClassDeclaration","ClassExpression","SpreadElement","SpreadProperty","ExperimentalSpreadProperty","TemplateLiteral","AssignmentPattern"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst { isParenthesized: isParenthesizedRaw } = require(\"eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils.js\");\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow unnecessary parentheses\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\n                                enforceForArrowConditionals: { type: \"boolean\" },\n                                enforceForSequenceExpressions: { type: \"boolean\" },\n                                enforceForNewInMemberExpressions: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unnecessary parentheses around expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const tokensToIgnore = new WeakSet();\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForArrowConditionals === false;\n        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForSequenceExpressions === false;\n        const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForNewInMemberExpressions === false;\n\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        let reportsBuffer;\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n                return false;\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is parenthesised.\n         * @private\n         */\n        function isParenthesised(node) {\n            return isParenthesizedRaw(1, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            return isParenthesizedRaw(2, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n                if (\n                    currentNode.type === \"ReturnStatement\" ||\n                    (currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\")\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 ||\n                (\n\n                    // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n                    astUtils.isOpeningParenToken(penultimateToken) &&\n                    astUtils.isClosingParenToken(lastToken) &&\n                    newExpression.callee.range[1] < newExpression.range[1]\n                );\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            }\n            if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            }\n            if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            }\n            if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);\n            const firstToken = sourceCode.getFirstToken(node);\n\n            return tokenBeforeLeftParen &&\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\n                leftParenToken.range[1] === firstToken.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);\n        }\n\n        /**\n         * Determines whether a node should be followed by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted after the node\n         * @private\n         */\n        function requiresTrailingSpace(node) {\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\n            const rightParenToken = nextTwoTokens[0];\n            const tokenAfterRightParen = nextTwoTokens[1];\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\n\n            return rightParenToken && tokenAfterRightParen &&\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n        }\n\n        /**\n         * Determines if a given expression node is an IIFE\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the given node is an IIFE\n         */\n        function isIIFE(node) {\n            return node.type === \"CallExpression\" && node.callee.type === \"FunctionExpression\";\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (!isParenthesisedTwice(node)) {\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n                    return;\n                }\n\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\n                    return;\n                }\n            }\n\n            /**\n             * Finishes reporting\n             * @returns {void}\n             * @private\n             */\n            function finishReport() {\n                context.report({\n                    node,\n                    loc: leftParenToken.loc,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                        return fixer.replaceTextRange([\n                            leftParenToken.range[0],\n                            rightParenToken.range[1]\n                        ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n                    }\n                });\n            }\n\n            if (reportsBuffer) {\n                reportsBuffer.reports.push({ node, finishReport });\n                return;\n            }\n\n            finishReport();\n        }\n\n        /**\n         * Evaluate Unary update\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkUnaryUpdate(node) {\n            if (node.type === \"UnaryExpression\" && node.argument.type === \"BinaryExpression\" && node.argument.operator === \"**\") {\n                return;\n            }\n\n            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Check if a member expression contains a call expression\n         * @param {ASTNode} node MemberExpression node to evaluate\n         * @returns {boolean} true if found, false if not\n         */\n        function doesMemberExpressionContainCallExpression(node) {\n            let currentNode = node.object;\n            let currentNodeType = node.object.type;\n\n            while (currentNodeType === \"MemberExpression\") {\n                currentNode = currentNode.object;\n                currentNodeType = currentNode.type;\n            }\n\n            return currentNodeType === \"CallExpression\";\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            const callee = node.callee;\n\n            if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {\n                const hasNewParensException = callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee);\n\n                if (\n                    hasDoubleExcessParens(callee) ||\n                    !isIIFE(node) && !hasNewParensException && !(\n\n                        /*\n                         * Allow extra parens around a new expression if\n                         * there are intervening parentheses.\n                         */\n                        (callee.type === \"MemberExpression\" && doesMemberExpressionContainCallExpression(callee))\n                    )\n                ) {\n                    report(node.callee);\n                }\n            }\n            node.arguments\n                .filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                .forEach(report);\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = (NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\")) ||\n              node.left.type === \"UnaryExpression\" && isExponentiation;\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation))) {\n                report(node.left);\n            }\n            if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation))) {\n                report(node.right);\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            /*\n             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n             * Otherwise, parentheses are needed.\n             */\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR\n                ? hasExcessParens(node.argument)\n                : hasDoubleExcessParens(node.argument);\n\n            if (hasExtraParens) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" &&\n                            tokenAfterClosingParens &&\n                            (\n                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||\n                                tokenAfterClosingParens.type === \"Identifier\"\n                            )\n                    ) ||\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            if (hasExcessParens(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Finds the path from the given node to the specified ancestor.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} ancestor Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified ancestor.\n         */\n        function pathToAncestor(node, ancestor) {\n            const path = [node];\n            let currentNode = node;\n\n            while (currentNode !== ancestor) {\n\n                currentNode = currentNode.parent;\n\n                /* istanbul ignore if */\n                if (currentNode === null) {\n                    throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n                }\n\n                path.push(currentNode);\n            }\n\n            return path;\n        }\n\n        /**\n         * Finds the path from the given node to the specified descendant.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} descendant Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified descendant.\n         */\n        function pathToDescendant(node, descendant) {\n            return pathToAncestor(descendant, node).reverse();\n        }\n\n        /**\n         * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\n         * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\n         * @param {ASTNode} node Ancestor of an 'in' expression.\n         * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\n         * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\n         */\n        function isSafelyEnclosingInExpression(node, child) {\n            switch (node.type) {\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                case \"BlockStatement\":\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                case \"TemplateLiteral\":\n                    return true;\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                    return node.params.includes(child);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.arguments.includes(child);\n                case \"MemberExpression\":\n                    return node.computed && node.property === child;\n                case \"ConditionalExpression\":\n                    return node.consequent === child;\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\n         * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\n         * @returns {void}\n         */\n        function startNewReportsBuffering() {\n            reportsBuffer = {\n                upper: reportsBuffer,\n                inExpressionNodes: [],\n                reports: []\n            };\n        }\n\n        /**\n         * Ends the current reports buffering.\n         * @returns {void}\n         */\n        function endCurrentReportsBuffering() {\n            const { upper, inExpressionNodes, reports } = reportsBuffer;\n\n            if (upper) {\n                upper.inExpressionNodes.push(...inExpressionNodes);\n                upper.reports.push(...reports);\n            } else {\n\n                // flush remaining reports\n                reports.forEach(({ finishReport }) => finishReport());\n            }\n\n            reportsBuffer = upper;\n        }\n\n        /**\n         * Checks whether the given node is in the current reports buffer.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is in the current buffer, false otherwise.\n         */\n        function isInCurrentReportsBuffer(node) {\n            return reportsBuffer.reports.some(r => r.node === node);\n        }\n\n        /**\n         * Removes the given node from the current reports buffer.\n         * @param {ASTNode} node Node to remove.\n         * @returns {void}\n         */\n        function removeFromCurrentReportsBuffer(node) {\n            reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n        }\n\n        return {\n            ArrayExpression(node) {\n                node.elements\n                    .filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                    .forEach(report);\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type === \"ConditionalExpression\" &&\n                    IGNORE_ARROW_CONDITIONALS &&\n                    !isParenthesisedTwice(node.body)\n                ) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression(node) {\n                if (reportsBuffer && node.operator === \"in\") {\n                    reportsBuffer.inExpressionNodes.push(node);\n                }\n\n                checkBinaryLogical(node);\n            },\n\n            CallExpression: checkCallNew,\n\n            ClassBody(node) {\n                node.body\n                    .filter(member => member.type === \"MethodDefinition\" && member.computed &&\n                        member.key && hasExcessParens(member.key) && precedence(member.key) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                    .forEach(member => report(member.key));\n            },\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: \"LogicalExpression\", operator: \"||\" })) {\n                    report(node.test);\n                }\n\n                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.consequent);\n                }\n\n                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            \"ForInStatement, ForOfStatement\"(node) {\n                if (node.left.type !== \"VariableDeclarator\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (\n                        firstLeftToken.value === \"let\" && (\n\n                            /*\n                             * If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`\n                             * Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.\n                             */\n                            (firstLeftToken.range[1] === node.left.range[1] || /*\n                             * If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`\n                             * Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.\n                             */\n                            astUtils.isOpeningBracketToken(\n                                sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\n                            ))\n                        )\n                    ) {\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n                if (!(node.type === \"ForOfStatement\" && node.right.type === \"SequenceExpression\") && hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n\n                if (node.init) {\n                    startNewReportsBuffering();\n\n                    if (hasExcessParens(node.init)) {\n                        report(node.init);\n                    }\n                }\n            },\n\n            \"ForStatement > *.init:exit\"(node) {\n\n                /*\n                 * Removing parentheses around `in` expressions might change semantics and cause errors.\n                 *\n                 * For example, this valid for loop:\n                 *      for (let a = (b in c); ;);\n                 * after removing parentheses would be treated as an invalid for-in loop:\n                 *      for (let a = b in c; ;);\n                 */\n\n                if (reportsBuffer.reports.length) {\n                    reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n                        const path = pathToDescendant(node, inExpressionNode);\n                        let nodeToExclude;\n\n                        for (let i = 0; i < path.length; i++) {\n                            const pathNode = path[i];\n\n                            if (i < path.length - 1) {\n                                const nextPathNode = path[i + 1];\n\n                                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n\n                                    // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                                    return;\n                                }\n                            }\n\n                            if (isParenthesised(pathNode)) {\n                                if (isInCurrentReportsBuffer(pathNode)) {\n\n                                    // This node was supposed to be reported, but parentheses might be necessary.\n\n                                    if (isParenthesisedTwice(pathNode)) {\n\n                                        /*\n                                         * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\n                                         * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\n                                         * The remaining pair is safely enclosing the 'in' expression.\n                                         */\n                                        return;\n                                    }\n\n                                    // Exclude the outermost node only.\n                                    if (!nodeToExclude) {\n                                        nodeToExclude = pathNode;\n                                    }\n\n                                    // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n\n                                } else {\n\n                                    // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                                    return;\n                                }\n                            }\n                        }\n\n                        // Exclude the node from the list (i.e. treat parentheses as necessary)\n                        removeFromCurrentReportsBuffer(nodeToExclude);\n                    });\n                }\n\n                endCurrentReportsBuffering();\n            },\n\n            IfStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ImportExpression(node) {\n                const { source } = node;\n\n                if (source.type === \"SequenceExpression\") {\n                    if (hasDoubleExcessParens(source)) {\n                        report(source);\n                    }\n                } else if (hasExcessParens(source)) {\n                    report(source);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                const nodeObjHasExcessParens = hasExcessParens(node.object);\n\n                if (\n                    nodeObjHasExcessParens &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  node.object.type === \"CallExpression\" &&\n                  node.parent.type !== \"NewExpression\") {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  !IGNORE_NEW_IN_MEMBER_EXPR &&\n                  node.object.type === \"NewExpression\" &&\n                  isNewExpressionWithParens(node.object)) {\n                    report(node.object);\n                }\n\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                node.properties\n                    .filter(property => {\n                        const value = property.value;\n\n                        return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;\n                    }).forEach(property => report(property.value));\n            },\n\n            Property(node) {\n                if (node.computed) {\n                    const { key } = node;\n\n                    if (key && hasExcessParens(key) && precedence(key) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(key);\n                    }\n                }\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                node.expressions\n                    .filter(e => hasExcessParens(e) && precedence(e) >= precedence(node))\n                    .forEach(report);\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkUnaryUpdate,\n            UpdateExpression: checkUnaryUpdate,\n            AwaitExpression: checkUnaryUpdate,\n\n            VariableDeclarator(node) {\n                if (node.init && hasExcessParens(node.init) &&\n                        precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.init.type === \"Literal\" && node.init.regex)) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator,\n\n            TemplateLiteral(node) {\n                node.expressions\n                    .filter(e => e && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            AssignmentPattern(node) {\n                const { right } = node;\n\n                if (right && hasExcessParens(right) && precedence(right) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(right);\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}