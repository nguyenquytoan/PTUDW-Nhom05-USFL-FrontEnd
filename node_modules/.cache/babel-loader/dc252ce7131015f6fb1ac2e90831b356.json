{"ast":null,"code":"/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n      FixTracker = require(\"./utils/fix-tracker\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\n\n\nfunction remove(array, element) {\n  const index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removeable.\n */\n\n\nfunction isRemovable(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\n\n\nfunction isInFinally(node) {\n  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {\n    if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n      return true;\n    }\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow redundant return statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-return\"\n    },\n    fixable: \"code\",\n    schema: []\n  },\n\n  create(context) {\n    const segmentInfoMap = new WeakMap();\n    const usedUnreachableSegments = new WeakSet();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\n     * Checks whether the given segment is terminated by a return statement or not.\n     * @param {CodePathSegment} segment The segment to check.\n     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n     */\n\n    function isReturned(segment) {\n      const info = segmentInfoMap.get(segment);\n      return !info || info.returned;\n    }\n    /**\n     * Collects useless return statements from the given previous segments.\n     *\n     * A previous segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {ASTNode[]} uselessReturns The collected return statements.\n     * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n     * @returns {ASTNode[]} `uselessReturns`.\n     */\n\n\n    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n      const traversedSegments = providedTraversedSegments || new WeakSet();\n\n      for (const segment of prevSegments) {\n        if (!segment.reachable) {\n          if (!traversedSegments.has(segment)) {\n            traversedSegments.add(segment);\n            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);\n          }\n\n          continue;\n        }\n\n        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n      }\n\n      return uselessReturns;\n    }\n    /**\n     * Removes the return statements on the given segment from the useless return\n     * statement list.\n     *\n     * This segment may be an unreachable segment.\n     * In that case, the information object of the unreachable segment is not\n     * initialized because `onCodePathSegmentStart` event is not notified for\n     * unreachable segments.\n     * This goes to the previous segments of the unreachable segment recursively\n     * if the unreachable segment was generated by a return statement. Otherwise,\n     * this ignores the unreachable segment.\n     *\n     * This behavior would simulate code paths for the case that the return\n     * statement does not exist.\n     * @param {CodePathSegment} segment The segment to get return statements.\n     * @returns {void}\n     */\n\n\n    function markReturnStatementsOnSegmentAsUsed(segment) {\n      if (!segment.reachable) {\n        usedUnreachableSegments.add(segment);\n        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);\n        return;\n      }\n\n      const info = segmentInfoMap.get(segment);\n\n      for (const node of info.uselessReturns) {\n        remove(scopeInfo.uselessReturns, node);\n      }\n\n      info.uselessReturns = [];\n    }\n    /**\n     * Removes the return statements on the current segments from the useless\n     * return statement list.\n     *\n     * This function will be called at every statement except FunctionDeclaration,\n     * BlockStatement, and BreakStatement.\n     *\n     * - FunctionDeclarations are always executed whether it's returned or not.\n     * - BlockStatements do nothing.\n     * - BreakStatements go the next merely.\n     * @returns {void}\n     */\n\n\n    function markReturnStatementsOnCurrentSegmentsAsUsed() {\n      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      // Makes and pushs a new scope information.\n      onCodePathStart(codePath) {\n        scopeInfo = {\n          upper: scopeInfo,\n          uselessReturns: [],\n          codePath\n        };\n      },\n\n      // Reports useless return statements if exist.\n      onCodePathEnd() {\n        for (const node of scopeInfo.uselessReturns) {\n          context.report({\n            node,\n            loc: node.loc,\n            message: \"Unnecessary return statement.\",\n\n            fix(fixer) {\n              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n                /*\n                 * Extend the replacement range to include the\n                 * entire function to avoid conflicting with\n                 * no-else-return.\n                 * https://github.com/eslint/eslint/issues/8026\n                 */\n                return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);\n              }\n\n              return null;\n            }\n\n          });\n        }\n\n        scopeInfo = scopeInfo.upper;\n      },\n\n      /*\n       * Initializes segments.\n       * NOTE: This event is notified for only reachable segments.\n       */\n      onCodePathSegmentStart(segment) {\n        const info = {\n          uselessReturns: getUselessReturns([], segment.allPrevSegments),\n          returned: false\n        }; // Stores the info.\n\n        segmentInfoMap.set(segment, info);\n      },\n\n      // Adds ReturnStatement node to check whether it's useless or not.\n      ReturnStatement(node) {\n        if (node.argument) {\n          markReturnStatementsOnCurrentSegmentsAsUsed();\n        }\n\n        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n        !scopeInfo.codePath.currentSegments.some(s => s.reachable)) {\n          return;\n        }\n\n        for (const segment of scopeInfo.codePath.currentSegments) {\n          const info = segmentInfoMap.get(segment);\n\n          if (info) {\n            info.uselessReturns.push(node);\n            info.returned = true;\n          }\n        }\n\n        scopeInfo.uselessReturns.push(node);\n      },\n\n      /*\n       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n       * Removes return statements of the current segments from the useless return statement list.\n       */\n      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-useless-return.js"],"names":["astUtils","require","FixTracker","remove","array","element","index","indexOf","splice","isRemovable","node","STATEMENT_LIST_PARENTS","has","parent","type","isInFinally","currentNode","isFunction","finalizer","module","exports","meta","docs","description","category","recommended","url","fixable","schema","create","context","segmentInfoMap","WeakMap","usedUnreachableSegments","WeakSet","sourceCode","getSourceCode","scopeInfo","isReturned","segment","info","get","returned","getUselessReturns","uselessReturns","prevSegments","providedTraversedSegments","traversedSegments","reachable","add","allPrevSegments","filter","push","markReturnStatementsOnSegmentAsUsed","prevSegment","forEach","markReturnStatementsOnCurrentSegmentsAsUsed","codePath","currentSegments","onCodePathStart","upper","onCodePathEnd","report","loc","message","fix","fixer","getCommentsInside","length","retainEnclosingFunction","onCodePathSegmentStart","set","ReturnStatement","argument","isInLoop","some","s","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","EmptyStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removeable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         * @param {CodePathSegment} segment The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {ASTNode[]} uselessReturns The collected return statements.\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {CodePathSegment} segment The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        message: \"Unnecessary return statement.\",\n                        fix(fixer) {\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (\n                    node.argument ||\n                    astUtils.isInLoop(node) ||\n                    isInFinally(node) ||\n\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)\n                ) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}