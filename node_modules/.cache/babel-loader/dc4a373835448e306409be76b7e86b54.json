{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst {\n  FileCoverage\n} = require('istanbul-lib-coverage').classes;\n\nfunction locString(loc) {\n  return [loc.start.line, loc.start.column, loc.end.line, loc.end.column].join(':');\n}\n\nclass MappedCoverage extends FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      },\n      seen: {}\n    };\n  }\n\n  addStatement(loc, hits) {\n    const key = 's:' + locString(loc);\n    const {\n      meta\n    } = this;\n    let index = meta.seen[key];\n\n    if (index === undefined) {\n      index = meta.last.s;\n      meta.last.s += 1;\n      meta.seen[key] = index;\n      this.statementMap[index] = this.cloneLocation(loc);\n    }\n\n    this.s[index] = this.s[index] || 0;\n    this.s[index] += hits;\n    return index;\n  }\n\n  addFunction(name, decl, loc, hits) {\n    const key = 'f:' + locString(decl);\n    const {\n      meta\n    } = this;\n    let index = meta.seen[key];\n\n    if (index === undefined) {\n      index = meta.last.f;\n      meta.last.f += 1;\n      meta.seen[key] = index;\n      name = name || `(unknown_${index})`;\n      this.fnMap[index] = {\n        name,\n        decl: this.cloneLocation(decl),\n        loc: this.cloneLocation(loc)\n      };\n    }\n\n    this.f[index] = this.f[index] || 0;\n    this.f[index] += hits;\n    return index;\n  }\n\n  addBranch(type, loc, branchLocations, hits) {\n    const key = ['b', ...branchLocations.map(l => locString(l))].join(':');\n    const {\n      meta\n    } = this;\n    let index = meta.seen[key];\n\n    if (index === undefined) {\n      index = meta.last.b;\n      meta.last.b += 1;\n      meta.seen[key] = index;\n      this.branchMap[index] = {\n        loc,\n        type,\n        locations: branchLocations.map(l => this.cloneLocation(l))\n      };\n    }\n\n    if (!this.b[index]) {\n      this.b[index] = branchLocations.map(() => 0);\n    }\n\n    hits.forEach((hit, i) => {\n      this.b[index][i] += hit;\n    });\n    return index;\n  }\n  /* Returns a clone of the location object with only the attributes of interest */\n\n\n  cloneLocation(loc) {\n    return {\n      start: {\n        line: loc.start.line,\n        column: loc.start.column\n      },\n      end: {\n        line: loc.end.line,\n        column: loc.end.column\n      }\n    };\n  }\n\n}\n\nmodule.exports = {\n  MappedCoverage\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-source-maps/lib/mapped.js"],"names":["FileCoverage","require","classes","locString","loc","start","line","column","end","join","MappedCoverage","constructor","pathOrObj","meta","last","s","f","b","seen","addStatement","hits","key","index","undefined","statementMap","cloneLocation","addFunction","name","decl","fnMap","addBranch","type","branchLocations","map","l","branchMap","locations","forEach","hit","i","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst { FileCoverage } = require('istanbul-lib-coverage').classes;\n\nfunction locString(loc) {\n    return [\n        loc.start.line,\n        loc.start.column,\n        loc.end.line,\n        loc.end.column\n    ].join(':');\n}\n\nclass MappedCoverage extends FileCoverage {\n    constructor(pathOrObj) {\n        super(pathOrObj);\n\n        this.meta = {\n            last: {\n                s: 0,\n                f: 0,\n                b: 0\n            },\n            seen: {}\n        };\n    }\n\n    addStatement(loc, hits) {\n        const key = 's:' + locString(loc);\n        const { meta } = this;\n        let index = meta.seen[key];\n\n        if (index === undefined) {\n            index = meta.last.s;\n            meta.last.s += 1;\n            meta.seen[key] = index;\n            this.statementMap[index] = this.cloneLocation(loc);\n        }\n\n        this.s[index] = this.s[index] || 0;\n        this.s[index] += hits;\n        return index;\n    }\n\n    addFunction(name, decl, loc, hits) {\n        const key = 'f:' + locString(decl);\n        const { meta } = this;\n        let index = meta.seen[key];\n\n        if (index === undefined) {\n            index = meta.last.f;\n            meta.last.f += 1;\n            meta.seen[key] = index;\n            name = name || `(unknown_${index})`;\n            this.fnMap[index] = {\n                name,\n                decl: this.cloneLocation(decl),\n                loc: this.cloneLocation(loc)\n            };\n        }\n\n        this.f[index] = this.f[index] || 0;\n        this.f[index] += hits;\n        return index;\n    }\n\n    addBranch(type, loc, branchLocations, hits) {\n        const key = ['b', ...branchLocations.map(l => locString(l))].join(':');\n        const { meta } = this;\n        let index = meta.seen[key];\n        if (index === undefined) {\n            index = meta.last.b;\n            meta.last.b += 1;\n            meta.seen[key] = index;\n            this.branchMap[index] = {\n                loc,\n                type,\n                locations: branchLocations.map(l => this.cloneLocation(l))\n            };\n        }\n\n        if (!this.b[index]) {\n            this.b[index] = branchLocations.map(() => 0);\n        }\n\n        hits.forEach((hit, i) => {\n            this.b[index][i] += hit;\n        });\n        return index;\n    }\n\n    /* Returns a clone of the location object with only the attributes of interest */\n    cloneLocation(loc) {\n        return {\n            start: {\n                line: loc.start.line,\n                column: loc.start.column\n            },\n            end: {\n                line: loc.end.line,\n                column: loc.end.column\n            }\n        };\n    }\n}\n\nmodule.exports = {\n    MappedCoverage\n};\n"]},"metadata":{},"sourceType":"script"}