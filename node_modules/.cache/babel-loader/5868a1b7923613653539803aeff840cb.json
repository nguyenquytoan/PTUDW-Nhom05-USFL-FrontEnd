{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _stylehacks = require('stylehacks');\n\nvar _insertCloned = require('../insertCloned');\n\nvar _insertCloned2 = _interopRequireDefault(_insertCloned);\n\nvar _parseTrbl = require('../parseTrbl');\n\nvar _parseTrbl2 = _interopRequireDefault(_parseTrbl);\n\nvar _hasAllProps = require('../hasAllProps');\n\nvar _hasAllProps2 = _interopRequireDefault(_hasAllProps);\n\nvar _getDecls = require('../getDecls');\n\nvar _getDecls2 = _interopRequireDefault(_getDecls);\n\nvar _getRules = require('../getRules');\n\nvar _getRules2 = _interopRequireDefault(_getRules);\n\nvar _getValue = require('../getValue');\n\nvar _getValue2 = _interopRequireDefault(_getValue);\n\nvar _mergeRules = require('../mergeRules');\n\nvar _mergeRules2 = _interopRequireDefault(_mergeRules);\n\nvar _minifyTrbl = require('../minifyTrbl');\n\nvar _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);\n\nvar _minifyWsc = require('../minifyWsc');\n\nvar _minifyWsc2 = _interopRequireDefault(_minifyWsc);\n\nvar _canMerge = require('../canMerge');\n\nvar _canMerge2 = _interopRequireDefault(_canMerge);\n\nvar _remove = require('../remove');\n\nvar _remove2 = _interopRequireDefault(_remove);\n\nvar _trbl = require('../trbl');\n\nvar _trbl2 = _interopRequireDefault(_trbl);\n\nvar _isCustomProp = require('../isCustomProp');\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nvar _canExplode = require('../canExplode');\n\nvar _canExplode2 = _interopRequireDefault(_canExplode);\n\nvar _getLastNode = require('../getLastNode');\n\nvar _getLastNode2 = _interopRequireDefault(_getLastNode);\n\nvar _parseWsc = require('../parseWsc');\n\nvar _parseWsc2 = _interopRequireDefault(_parseWsc);\n\nvar _validateWsc = require('../validateWsc');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\n\nfunction borderProperty(...parts) {\n  return `border-${parts.join('-')}`;\n}\n\nfunction mapBorderProperty(value) {\n  return borderProperty(value);\n}\n\nconst directions = _trbl2.default.map(mapBorderProperty);\n\nconst properties = wsc.map(mapBorderProperty);\nconst directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);\nconst precedence = [['border'], directions.concat(properties), directionalProperties];\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\nfunction getLevel(prop) {\n  for (let i = 0; i < precedence.length; i++) {\n    if (!!~precedence[i].indexOf(prop.toLowerCase())) {\n      return i;\n    }\n  }\n}\n\nconst isValueCustomProp = value => value && !!~value.search(/var\\s*\\(\\s*--/i);\n\nfunction canMergeValues(values) {\n  return !values.some(isValueCustomProp) || values.every(isValueCustomProp);\n}\n\nfunction getColorValue(decl) {\n  if (decl.prop.substr(-5) === 'color') {\n    return decl.value;\n  }\n\n  return (0, _parseWsc2.default)(decl.value)[2] || defaults[2];\n}\n\nfunction diffingProps(values, nextValues) {\n  return wsc.reduce((prev, curr, i) => {\n    if (values[i] === nextValues[i]) {\n      return prev;\n    }\n\n    return [...prev, curr];\n  }, []);\n}\n\nfunction mergeRedundant({\n  values,\n  nextValues,\n  decl,\n  nextDecl,\n  index\n}) {\n  if (!(0, _canMerge2.default)([decl, nextDecl])) {\n    return;\n  }\n\n  if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {\n    return;\n  }\n\n  const diff = diffingProps(values, nextValues);\n\n  if (diff.length > 1) {\n    return;\n  }\n\n  const prop = diff.pop();\n  const position = wsc.indexOf(prop);\n  const prop1 = `${nextDecl.prop}-${prop}`;\n  const prop2 = `border-${prop}`;\n  let props = (0, _parseTrbl2.default)(values[position]);\n  props[index] = nextValues[position];\n  const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n  const propValue2 = (0, _minifyTrbl2.default)(props);\n  const origLength = ((0, _minifyWsc2.default)(decl.value) + nextDecl.prop + nextDecl.value).length;\n  const newLength1 = decl.value.length + prop1.length + (0, _minifyWsc2.default)(nextValues[position]).length;\n  const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n  if (newLength1 < newLength2 && newLength1 < origLength) {\n    nextDecl.prop = prop1;\n    nextDecl.value = nextValues[position];\n  }\n\n  if (newLength2 < newLength1 && newLength2 < origLength) {\n    decl.value = borderValue2;\n    nextDecl.prop = prop2;\n    nextDecl.value = propValue2;\n  }\n}\n\nfunction isCloseEnough(mapped) {\n  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];\n}\n\nfunction getDistinctShorthands(mapped) {\n  return mapped.reduce((a, b) => {\n    a = Array.isArray(a) ? a : [a];\n\n    if (!~a.indexOf(b)) {\n      a.push(b);\n    }\n\n    return a;\n  });\n}\n\nfunction explode(rule) {\n  rule.walkDecls(/^border/i, decl => {\n    if (!(0, _canExplode2.default)(decl, false)) {\n      return;\n    }\n\n    if ((0, _stylehacks.detect)(decl)) {\n      return;\n    }\n\n    const prop = decl.prop.toLowerCase(); // border -> border-trbl\n\n    if (prop === 'border') {\n      if ((0, _validateWsc.isValidWsc)((0, _parseWsc2.default)(decl.value))) {\n        directions.forEach(direction => {\n          (0, _insertCloned2.default)(decl.parent, decl, {\n            prop: direction\n          });\n        });\n        return decl.remove();\n      }\n    } // border-trbl -> border-trbl-wsc\n\n\n    if (directions.some(direction => prop === direction)) {\n      let values = (0, _parseWsc2.default)(decl.value);\n\n      if ((0, _validateWsc.isValidWsc)(values)) {\n        wsc.forEach((d, i) => {\n          (0, _insertCloned2.default)(decl.parent, decl, {\n            prop: `${prop}-${d}`,\n            value: values[i] || defaults[i]\n          });\n        });\n        return decl.remove();\n      }\n    } // border-wsc -> border-trbl-wsc\n\n\n    wsc.some(style => {\n      if (prop !== borderProperty(style)) {\n        return false;\n      }\n\n      (0, _parseTrbl2.default)(decl.value).forEach((value, i) => {\n        (0, _insertCloned2.default)(decl.parent, decl, {\n          prop: borderProperty(_trbl2.default[i], style),\n          value\n        });\n      });\n      return decl.remove();\n    });\n  });\n}\n\nfunction merge(rule) {\n  // border-trbl-wsc -> border-trbl\n  _trbl2.default.forEach(direction => {\n    const prop = borderProperty(direction);\n    (0, _mergeRules2.default)(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {\n      if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n        (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n          prop,\n          value: rules.map(_getValue2.default).join(' ')\n        });\n        rules.forEach(_remove2.default);\n        return true;\n      }\n    });\n  }); // border-trbl-wsc -> border-wsc\n\n\n  wsc.forEach(style => {\n    const prop = borderProperty(style);\n    (0, _mergeRules2.default)(rule, _trbl2.default.map(direction => borderProperty(direction, style)), (rules, lastNode) => {\n      if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {\n        (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n          prop,\n          value: (0, _minifyTrbl2.default)(rules.map(_getValue2.default).join(' '))\n        });\n        rules.forEach(_remove2.default);\n        return true;\n      }\n    });\n  }); // border-trbl -> border-wsc\n\n  (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {\n    if (rules.some(_stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(({\n      value\n    }) => value);\n\n    if (!canMergeValues(values)) {\n      return;\n    }\n\n    const parsed = values.map(value => (0, _parseWsc2.default)(value));\n\n    if (!parsed.every(_validateWsc.isValidWsc)) {\n      return;\n    }\n\n    wsc.forEach((d, i) => {\n      const value = parsed.map(v => v[i] || defaults[i]);\n\n      if (canMergeValues(value)) {\n        (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n          prop: borderProperty(d),\n          value: (0, _minifyTrbl2.default)(value)\n        });\n      } else {\n        (0, _insertCloned2.default)(lastNode.parent, lastNode);\n      }\n    });\n    rules.forEach(_remove2.default);\n    return true;\n  }); // border-wsc -> border\n  // border-wsc -> border + border-color\n  // border-wsc -> border + border-dir\n\n  (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n    if (rules.some(_stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(node => (0, _parseTrbl2.default)(node.value));\n    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n\n    if (!canMergeValues(mapped)) {\n      return;\n    }\n\n    const [width, style, color] = rules;\n    const reduced = getDistinctShorthands(mapped);\n\n    if (isCloseEnough(mapped) && (0, _canMerge2.default)(rules, false)) {\n      const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n      const border = (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n        prop: 'border',\n        value: first ? reduced[0] : reduced[1]\n      });\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = borderProperty(_trbl2.default[mapped.indexOf(value)]);\n        rule.insertAfter(border, Object.assign(lastNode.clone(), {\n          prop,\n          value\n        }));\n      }\n\n      rules.forEach(_remove2.default);\n      return true;\n    } else if (reduced.length === 1) {\n      rule.insertBefore(color, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: [width, style].map(_getValue2.default).join(' ')\n      }));\n      rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(_remove2.default);\n      return true;\n    }\n  }); // border-wsc -> border + border-trbl\n\n  (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n    if (rules.some(_stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(node => (0, _parseTrbl2.default)(node.value));\n    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n    const reduced = getDistinctShorthands(mapped);\n    const none = 'medium none currentcolor';\n\n    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n      const filtered = mapped.filter(p => p !== none);\n      const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];\n      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: borderValue\n      }));\n      directions.forEach((dir, i) => {\n        if (mapped[i] !== borderValue) {\n          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n            prop: dir,\n            value: mapped[i]\n          }));\n        }\n      });\n      rules.forEach(_remove2.default);\n      return true;\n    }\n  }); // border-trbl -> border\n  // border-trbl -> border + border-trbl\n\n  (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {\n    if (rules.some(_stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(node => {\n      const wscValue = (0, _parseWsc2.default)(node.value);\n\n      if (!(0, _validateWsc.isValidWsc)(wscValue)) {\n        return node.value;\n      }\n\n      return wscValue.map((value, i) => value || defaults[i]).join(' ');\n    });\n    const reduced = getDistinctShorthands(values);\n\n    if (isCloseEnough(values)) {\n      const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: (0, _minifyWsc2.default)(first ? values[0] : values[1])\n      }));\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = directions[values.indexOf(value)];\n        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n          prop: prop,\n          value: (0, _minifyWsc2.default)(value)\n        }));\n      }\n\n      rules.forEach(_remove2.default);\n      return true;\n    }\n  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n\n  directions.forEach(direction => {\n    wsc.forEach((style, i) => {\n      const prop = `${direction}-${style}`;\n      (0, _mergeRules2.default)(rule, [direction, prop], (rules, lastNode) => {\n        if (lastNode.prop !== direction) {\n          return;\n        }\n\n        const values = (0, _parseWsc2.default)(lastNode.value);\n\n        if (!(0, _validateWsc.isValidWsc)(values)) {\n          return;\n        }\n\n        const wscProp = rules.filter(r => r !== lastNode)[0];\n\n        if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {\n          return;\n        }\n\n        const wscValue = values[i];\n        values[i] = wscProp.value;\n\n        if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n          (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n            prop,\n            value: wscValue\n          });\n          lastNode.value = (0, _minifyWsc2.default)(values);\n          wscProp.remove();\n          return true;\n        }\n      });\n    });\n  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n\n  wsc.forEach((style, i) => {\n    const prop = borderProperty(style);\n    (0, _mergeRules2.default)(rule, ['border', prop], (rules, lastNode) => {\n      if (lastNode.prop !== 'border') {\n        return;\n      }\n\n      const values = (0, _parseWsc2.default)(lastNode.value);\n\n      if (!(0, _validateWsc.isValidWsc)(values)) {\n        return;\n      }\n\n      const wscProp = rules.filter(r => r !== lastNode)[0];\n\n      if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {\n        return;\n      }\n\n      const wscValue = values[i];\n      values[i] = wscProp.value;\n\n      if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n        (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n          prop,\n          value: wscValue\n        });\n        lastNode.value = (0, _minifyWsc2.default)(values);\n        wscProp.remove();\n        return true;\n      }\n    });\n  }); // optimize border-trbl\n\n  let decls = (0, _getDecls2.default)(rule, directions);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    wsc.forEach((d, i) => {\n      const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);\n      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n      const border = (0, _getLastNode2.default)(nodes, 'border');\n\n      if (border) {\n        nodes = nodes.slice(nodes.indexOf(border));\n      }\n\n      const props = nodes.filter(node => node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important);\n      const rules = (0, _getRules2.default)(props, names);\n\n      if ((0, _hasAllProps2.default)(rules, ...names) && !rules.some(_stylehacks.detect)) {\n        const values = rules.map(node => node ? node.value : null);\n        const filteredValues = values.filter(Boolean);\n\n        const lastNodeValue = _postcss.list.space(lastNode.value)[i];\n\n        values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n        let value = (0, _minifyTrbl2.default)(values.join(' '));\n\n        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {\n          value = filteredValues[0];\n        }\n\n        let refNode = props[props.length - 1];\n\n        if (value === lastNodeValue) {\n          refNode = lastNode;\n\n          let valueArray = _postcss.list.space(lastNode.value);\n\n          valueArray.splice(i, 1);\n          lastNode.value = valueArray.join(' ');\n        }\n\n        (0, _insertCloned2.default)(refNode.parent, refNode, {\n          prop: borderProperty(d),\n          value\n        });\n        decls = decls.filter(node => !~rules.indexOf(node));\n        rules.forEach(_remove2.default);\n      }\n    });\n    decls = decls.filter(node => node !== lastNode);\n  }\n\n  rule.walkDecls('border', decl => {\n    const nextDecl = decl.next();\n\n    if (!nextDecl || nextDecl.type !== 'decl') {\n      return;\n    }\n\n    const index = directions.indexOf(nextDecl.prop);\n\n    if (!~index) {\n      return;\n    }\n\n    const values = (0, _parseWsc2.default)(decl.value);\n    const nextValues = (0, _parseWsc2.default)(nextDecl.value);\n\n    if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {\n      return;\n    }\n\n    const config = {\n      values,\n      nextValues,\n      decl,\n      nextDecl,\n      index\n    };\n    return mergeRedundant(config);\n  });\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n    let values = (0, _parseWsc2.default)(decl.value);\n\n    if (!(0, _validateWsc.isValidWsc)(values)) {\n      return;\n    }\n\n    const position = directions.indexOf(decl.prop);\n    let dirs = [...directions];\n    dirs.splice(position, 1);\n    wsc.forEach((d, i) => {\n      const props = dirs.map(dir => `${dir}-${d}`);\n      (0, _mergeRules2.default)(rule, [decl.prop, ...props], rules => {\n        if (!rules.includes(decl)) {\n          return;\n        }\n\n        const longhands = rules.filter(p => p !== decl);\n\n        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {\n          longhands.forEach(_remove2.default);\n          (0, _insertCloned2.default)(decl.parent, decl, {\n            prop: borderProperty(d),\n            value: values[i]\n          });\n          values[i] = null;\n        }\n      });\n      const newValue = values.join(' ');\n\n      if (newValue) {\n        decl.value = newValue;\n      } else {\n        decl.remove();\n      }\n    });\n  }); // clean-up values\n\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n    decl.value = (0, _minifyWsc2.default)(decl.value);\n  }); // border-spacing-hv -> border-spacing\n\n  rule.walkDecls(/^border-spacing$/i, decl => {\n    const value = _postcss.list.space(decl.value); // merge vertical and horizontal dups\n\n\n    if (value.length > 1 && value[0] === value[1]) {\n      decl.value = value.slice(1).join(' ');\n    }\n  }); // clean-up rules\n\n  decls = (0, _getDecls2.default)(rule, allProperties);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    const lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence\n\n    const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp2.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));\n    lesser.forEach(_remove2.default);\n    decls = decls.filter(node => !~lesser.indexOf(node)); // get duplicate properties\n\n    let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));\n\n    if (duplicates.length) {\n      if (/hsla\\(|rgba\\(/i.test(getColorValue(lastNode))) {\n        const preserve = duplicates.filter(node => !/hsla\\(|rgba\\(/i.test(getColorValue(node))).pop();\n        duplicates = duplicates.filter(node => node !== preserve);\n      }\n\n      duplicates.forEach(_remove2.default);\n    }\n\n    decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));\n  }\n}\n\nexports.default = {\n  explode,\n  merge\n};\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-merge-longhand/dist/lib/decl/borders.js"],"names":["Object","defineProperty","exports","value","_postcss","require","_stylehacks","_insertCloned","_insertCloned2","_interopRequireDefault","_parseTrbl","_parseTrbl2","_hasAllProps","_hasAllProps2","_getDecls","_getDecls2","_getRules","_getRules2","_getValue","_getValue2","_mergeRules","_mergeRules2","_minifyTrbl","_minifyTrbl2","_minifyWsc","_minifyWsc2","_canMerge","_canMerge2","_remove","_remove2","_trbl","_trbl2","_isCustomProp","_isCustomProp2","_canExplode","_canExplode2","_getLastNode","_getLastNode2","_parseWsc","_parseWsc2","_validateWsc","obj","__esModule","default","wsc","defaults","borderProperty","parts","join","mapBorderProperty","directions","map","properties","directionalProperties","reduce","prev","curr","concat","prop","precedence","allProperties","a","b","getLevel","i","length","indexOf","toLowerCase","isValueCustomProp","search","canMergeValues","values","some","every","getColorValue","decl","substr","diffingProps","nextValues","mergeRedundant","nextDecl","index","detect","diff","pop","position","prop1","prop2","props","borderValue2","filter","e","propValue2","origLength","newLength1","newLength2","isCloseEnough","mapped","getDistinctShorthands","Array","isArray","push","explode","rule","walkDecls","isValidWsc","forEach","direction","parent","remove","d","style","merge","rules","lastNode","parsed","v","node","width","color","reduced","first","lastIndexOf","border","insertAfter","assign","clone","insertBefore","none","includes","filtered","p","mostCommon","sort","borderValue","dir","wscValue","wscProp","r","decls","names","name","nodes","slice","important","filteredValues","Boolean","lastNodeValue","list","space","refNode","valueArray","splice","next","type","config","dirs","longhands","newValue","lastPart","split","lesser","endsWith","duplicates","test","preserve","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _stylehacks = require('stylehacks');\n\nvar _insertCloned = require('../insertCloned');\n\nvar _insertCloned2 = _interopRequireDefault(_insertCloned);\n\nvar _parseTrbl = require('../parseTrbl');\n\nvar _parseTrbl2 = _interopRequireDefault(_parseTrbl);\n\nvar _hasAllProps = require('../hasAllProps');\n\nvar _hasAllProps2 = _interopRequireDefault(_hasAllProps);\n\nvar _getDecls = require('../getDecls');\n\nvar _getDecls2 = _interopRequireDefault(_getDecls);\n\nvar _getRules = require('../getRules');\n\nvar _getRules2 = _interopRequireDefault(_getRules);\n\nvar _getValue = require('../getValue');\n\nvar _getValue2 = _interopRequireDefault(_getValue);\n\nvar _mergeRules = require('../mergeRules');\n\nvar _mergeRules2 = _interopRequireDefault(_mergeRules);\n\nvar _minifyTrbl = require('../minifyTrbl');\n\nvar _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);\n\nvar _minifyWsc = require('../minifyWsc');\n\nvar _minifyWsc2 = _interopRequireDefault(_minifyWsc);\n\nvar _canMerge = require('../canMerge');\n\nvar _canMerge2 = _interopRequireDefault(_canMerge);\n\nvar _remove = require('../remove');\n\nvar _remove2 = _interopRequireDefault(_remove);\n\nvar _trbl = require('../trbl');\n\nvar _trbl2 = _interopRequireDefault(_trbl);\n\nvar _isCustomProp = require('../isCustomProp');\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nvar _canExplode = require('../canExplode');\n\nvar _canExplode2 = _interopRequireDefault(_canExplode);\n\nvar _getLastNode = require('../getLastNode');\n\nvar _getLastNode2 = _interopRequireDefault(_getLastNode);\n\nvar _parseWsc = require('../parseWsc');\n\nvar _parseWsc2 = _interopRequireDefault(_parseWsc);\n\nvar _validateWsc = require('../validateWsc');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\n\nfunction borderProperty(...parts) {\n    return `border-${parts.join('-')}`;\n}\n\nfunction mapBorderProperty(value) {\n    return borderProperty(value);\n}\n\nconst directions = _trbl2.default.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\nconst directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);\n\nconst precedence = [['border'], directions.concat(properties), directionalProperties];\n\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\nfunction getLevel(prop) {\n    for (let i = 0; i < precedence.length; i++) {\n        if (!!~precedence[i].indexOf(prop.toLowerCase())) {\n            return i;\n        }\n    }\n}\n\nconst isValueCustomProp = value => value && !!~value.search(/var\\s*\\(\\s*--/i);\n\nfunction canMergeValues(values) {\n    return !values.some(isValueCustomProp) || values.every(isValueCustomProp);\n}\n\nfunction getColorValue(decl) {\n    if (decl.prop.substr(-5) === 'color') {\n        return decl.value;\n    }\n\n    return (0, _parseWsc2.default)(decl.value)[2] || defaults[2];\n}\n\nfunction diffingProps(values, nextValues) {\n    return wsc.reduce((prev, curr, i) => {\n        if (values[i] === nextValues[i]) {\n            return prev;\n        }\n\n        return [...prev, curr];\n    }, []);\n}\n\nfunction mergeRedundant({ values, nextValues, decl, nextDecl, index }) {\n    if (!(0, _canMerge2.default)([decl, nextDecl])) {\n        return;\n    }\n\n    if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {\n        return;\n    }\n\n    const diff = diffingProps(values, nextValues);\n\n    if (diff.length > 1) {\n        return;\n    }\n\n    const prop = diff.pop();\n    const position = wsc.indexOf(prop);\n\n    const prop1 = `${nextDecl.prop}-${prop}`;\n    const prop2 = `border-${prop}`;\n\n    let props = (0, _parseTrbl2.default)(values[position]);\n\n    props[index] = nextValues[position];\n\n    const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n    const propValue2 = (0, _minifyTrbl2.default)(props);\n\n    const origLength = ((0, _minifyWsc2.default)(decl.value) + nextDecl.prop + nextDecl.value).length;\n    const newLength1 = decl.value.length + prop1.length + (0, _minifyWsc2.default)(nextValues[position]).length;\n    const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n    if (newLength1 < newLength2 && newLength1 < origLength) {\n        nextDecl.prop = prop1;\n        nextDecl.value = nextValues[position];\n    }\n\n    if (newLength2 < newLength1 && newLength2 < origLength) {\n        decl.value = borderValue2;\n        nextDecl.prop = prop2;\n        nextDecl.value = propValue2;\n    }\n}\n\nfunction isCloseEnough(mapped) {\n    return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];\n}\n\nfunction getDistinctShorthands(mapped) {\n    return mapped.reduce((a, b) => {\n        a = Array.isArray(a) ? a : [a];\n\n        if (!~a.indexOf(b)) {\n            a.push(b);\n        }\n\n        return a;\n    });\n}\n\nfunction explode(rule) {\n    rule.walkDecls(/^border/i, decl => {\n        if (!(0, _canExplode2.default)(decl, false)) {\n            return;\n        }\n\n        if ((0, _stylehacks.detect)(decl)) {\n            return;\n        }\n\n        const prop = decl.prop.toLowerCase();\n\n        // border -> border-trbl\n        if (prop === 'border') {\n            if ((0, _validateWsc.isValidWsc)((0, _parseWsc2.default)(decl.value))) {\n                directions.forEach(direction => {\n                    (0, _insertCloned2.default)(decl.parent, decl, { prop: direction });\n                });\n\n                return decl.remove();\n            }\n        }\n\n        // border-trbl -> border-trbl-wsc\n        if (directions.some(direction => prop === direction)) {\n            let values = (0, _parseWsc2.default)(decl.value);\n\n            if ((0, _validateWsc.isValidWsc)(values)) {\n                wsc.forEach((d, i) => {\n                    (0, _insertCloned2.default)(decl.parent, decl, {\n                        prop: `${prop}-${d}`,\n                        value: values[i] || defaults[i]\n                    });\n                });\n\n                return decl.remove();\n            }\n        }\n\n        // border-wsc -> border-trbl-wsc\n        wsc.some(style => {\n            if (prop !== borderProperty(style)) {\n                return false;\n            }\n\n            (0, _parseTrbl2.default)(decl.value).forEach((value, i) => {\n                (0, _insertCloned2.default)(decl.parent, decl, {\n                    prop: borderProperty(_trbl2.default[i], style),\n                    value\n                });\n            });\n\n            return decl.remove();\n        });\n    });\n}\n\nfunction merge(rule) {\n    // border-trbl-wsc -> border-trbl\n    _trbl2.default.forEach(direction => {\n        const prop = borderProperty(direction);\n\n        (0, _mergeRules2.default)(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {\n            if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop,\n                    value: rules.map(_getValue2.default).join(' ')\n                });\n\n                rules.forEach(_remove2.default);\n\n                return true;\n            }\n        });\n    });\n\n    // border-trbl-wsc -> border-wsc\n    wsc.forEach(style => {\n        const prop = borderProperty(style);\n\n        (0, _mergeRules2.default)(rule, _trbl2.default.map(direction => borderProperty(direction, style)), (rules, lastNode) => {\n            if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop,\n                    value: (0, _minifyTrbl2.default)(rules.map(_getValue2.default).join(' '))\n                });\n\n                rules.forEach(_remove2.default);\n\n                return true;\n            }\n        });\n    });\n\n    // border-trbl -> border-wsc\n    (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(({ value }) => value);\n\n        if (!canMergeValues(values)) {\n            return;\n        }\n\n        const parsed = values.map(value => (0, _parseWsc2.default)(value));\n\n        if (!parsed.every(_validateWsc.isValidWsc)) {\n            return;\n        }\n\n        wsc.forEach((d, i) => {\n            const value = parsed.map(v => v[i] || defaults[i]);\n\n            if (canMergeValues(value)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop: borderProperty(d),\n                    value: (0, _minifyTrbl2.default)(value)\n                });\n            } else {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode);\n            }\n        });\n\n        rules.forEach(_remove2.default);\n\n        return true;\n    });\n\n    // border-wsc -> border\n    // border-wsc -> border + border-color\n    // border-wsc -> border + border-dir\n    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(node => (0, _parseTrbl2.default)(node.value));\n        const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n\n        if (!canMergeValues(mapped)) {\n            return;\n        }\n\n        const [width, style, color] = rules;\n        const reduced = getDistinctShorthands(mapped);\n\n        if (isCloseEnough(mapped) && (0, _canMerge2.default)(rules, false)) {\n            const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n\n            const border = (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                prop: 'border',\n                value: first ? reduced[0] : reduced[1]\n            });\n\n            if (reduced[1]) {\n                const value = first ? reduced[1] : reduced[0];\n                const prop = borderProperty(_trbl2.default[mapped.indexOf(value)]);\n\n                rule.insertAfter(border, Object.assign(lastNode.clone(), {\n                    prop,\n                    value\n                }));\n            }\n            rules.forEach(_remove2.default);\n\n            return true;\n        } else if (reduced.length === 1) {\n            rule.insertBefore(color, Object.assign(lastNode.clone(), {\n                prop: 'border',\n                value: [width, style].map(_getValue2.default).join(' ')\n            }));\n            rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    // border-wsc -> border + border-trbl\n    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(node => (0, _parseTrbl2.default)(node.value));\n        const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n        const reduced = getDistinctShorthands(mapped);\n        const none = 'medium none currentcolor';\n\n        if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n            const filtered = mapped.filter(p => p !== none);\n            const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];\n            const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n\n            rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                prop: 'border',\n                value: borderValue\n            }));\n\n            directions.forEach((dir, i) => {\n                if (mapped[i] !== borderValue) {\n                    rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                        prop: dir,\n                        value: mapped[i]\n                    }));\n                }\n            });\n\n            rules.forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    // border-trbl -> border\n    // border-trbl -> border + border-trbl\n    (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(node => {\n            const wscValue = (0, _parseWsc2.default)(node.value);\n\n            if (!(0, _validateWsc.isValidWsc)(wscValue)) {\n                return node.value;\n            }\n\n            return wscValue.map((value, i) => value || defaults[i]).join(' ');\n        });\n\n        const reduced = getDistinctShorthands(values);\n\n        if (isCloseEnough(values)) {\n            const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n\n            rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                prop: 'border',\n                value: (0, _minifyWsc2.default)(first ? values[0] : values[1])\n            }));\n\n            if (reduced[1]) {\n                const value = first ? reduced[1] : reduced[0];\n                const prop = directions[values.indexOf(value)];\n                rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                    prop: prop,\n                    value: (0, _minifyWsc2.default)(value)\n                }));\n            }\n\n            rules.forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n    directions.forEach(direction => {\n        wsc.forEach((style, i) => {\n            const prop = `${direction}-${style}`;\n\n            (0, _mergeRules2.default)(rule, [direction, prop], (rules, lastNode) => {\n                if (lastNode.prop !== direction) {\n                    return;\n                }\n\n                const values = (0, _parseWsc2.default)(lastNode.value);\n\n                if (!(0, _validateWsc.isValidWsc)(values)) {\n                    return;\n                }\n\n                const wscProp = rules.filter(r => r !== lastNode)[0];\n\n                if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {\n                    return;\n                }\n\n                const wscValue = values[i];\n\n                values[i] = wscProp.value;\n\n                if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n                    (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                        prop,\n                        value: wscValue\n                    });\n                    lastNode.value = (0, _minifyWsc2.default)(values);\n\n                    wscProp.remove();\n\n                    return true;\n                }\n            });\n        });\n    });\n\n    // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n    wsc.forEach((style, i) => {\n        const prop = borderProperty(style);\n        (0, _mergeRules2.default)(rule, ['border', prop], (rules, lastNode) => {\n            if (lastNode.prop !== 'border') {\n                return;\n            }\n\n            const values = (0, _parseWsc2.default)(lastNode.value);\n\n            if (!(0, _validateWsc.isValidWsc)(values)) {\n                return;\n            }\n\n            const wscProp = rules.filter(r => r !== lastNode)[0];\n\n            if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {\n                return;\n            }\n\n            const wscValue = values[i];\n\n            values[i] = wscProp.value;\n\n            if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop,\n                    value: wscValue\n                });\n                lastNode.value = (0, _minifyWsc2.default)(values);\n                wscProp.remove();\n\n                return true;\n            }\n        });\n    });\n\n    // optimize border-trbl\n    let decls = (0, _getDecls2.default)(rule, directions);\n\n    while (decls.length) {\n        const lastNode = decls[decls.length - 1];\n\n        wsc.forEach((d, i) => {\n            const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);\n\n            let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n\n            const border = (0, _getLastNode2.default)(nodes, 'border');\n\n            if (border) {\n                nodes = nodes.slice(nodes.indexOf(border));\n            }\n\n            const props = nodes.filter(node => node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important);\n            const rules = (0, _getRules2.default)(props, names);\n\n            if ((0, _hasAllProps2.default)(rules, ...names) && !rules.some(_stylehacks.detect)) {\n                const values = rules.map(node => node ? node.value : null);\n                const filteredValues = values.filter(Boolean);\n                const lastNodeValue = _postcss.list.space(lastNode.value)[i];\n\n                values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n\n                let value = (0, _minifyTrbl2.default)(values.join(' '));\n\n                if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {\n                    value = filteredValues[0];\n                }\n\n                let refNode = props[props.length - 1];\n\n                if (value === lastNodeValue) {\n                    refNode = lastNode;\n                    let valueArray = _postcss.list.space(lastNode.value);\n                    valueArray.splice(i, 1);\n                    lastNode.value = valueArray.join(' ');\n                }\n\n                (0, _insertCloned2.default)(refNode.parent, refNode, {\n                    prop: borderProperty(d),\n                    value\n                });\n\n                decls = decls.filter(node => !~rules.indexOf(node));\n                rules.forEach(_remove2.default);\n            }\n        });\n\n        decls = decls.filter(node => node !== lastNode);\n    }\n\n    rule.walkDecls('border', decl => {\n        const nextDecl = decl.next();\n\n        if (!nextDecl || nextDecl.type !== 'decl') {\n            return;\n        }\n\n        const index = directions.indexOf(nextDecl.prop);\n\n        if (!~index) {\n            return;\n        }\n\n        const values = (0, _parseWsc2.default)(decl.value);\n        const nextValues = (0, _parseWsc2.default)(nextDecl.value);\n\n        if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {\n            return;\n        }\n\n        const config = {\n            values,\n            nextValues,\n            decl,\n            nextDecl,\n            index\n        };\n\n        return mergeRedundant(config);\n    });\n\n    rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n        let values = (0, _parseWsc2.default)(decl.value);\n\n        if (!(0, _validateWsc.isValidWsc)(values)) {\n            return;\n        }\n\n        const position = directions.indexOf(decl.prop);\n        let dirs = [...directions];\n\n        dirs.splice(position, 1);\n        wsc.forEach((d, i) => {\n            const props = dirs.map(dir => `${dir}-${d}`);\n\n            (0, _mergeRules2.default)(rule, [decl.prop, ...props], rules => {\n                if (!rules.includes(decl)) {\n                    return;\n                }\n\n                const longhands = rules.filter(p => p !== decl);\n\n                if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {\n                    longhands.forEach(_remove2.default);\n\n                    (0, _insertCloned2.default)(decl.parent, decl, {\n                        prop: borderProperty(d),\n                        value: values[i]\n                    });\n\n                    values[i] = null;\n                }\n            });\n\n            const newValue = values.join(' ');\n\n            if (newValue) {\n                decl.value = newValue;\n            } else {\n                decl.remove();\n            }\n        });\n    });\n\n    // clean-up values\n    rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n        decl.value = (0, _minifyWsc2.default)(decl.value);\n    });\n\n    // border-spacing-hv -> border-spacing\n    rule.walkDecls(/^border-spacing$/i, decl => {\n        const value = _postcss.list.space(decl.value);\n\n        // merge vertical and horizontal dups\n        if (value.length > 1 && value[0] === value[1]) {\n            decl.value = value.slice(1).join(' ');\n        }\n    });\n\n    // clean-up rules\n    decls = (0, _getDecls2.default)(rule, allProperties);\n\n    while (decls.length) {\n        const lastNode = decls[decls.length - 1];\n        const lastPart = lastNode.prop.split('-').pop();\n\n        // remove properties of lower precedence\n        const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp2.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));\n\n        lesser.forEach(_remove2.default);\n        decls = decls.filter(node => !~lesser.indexOf(node));\n\n        // get duplicate properties\n        let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));\n\n        if (duplicates.length) {\n            if (/hsla\\(|rgba\\(/i.test(getColorValue(lastNode))) {\n                const preserve = duplicates.filter(node => !/hsla\\(|rgba\\(/i.test(getColorValue(node))).pop();\n\n                duplicates = duplicates.filter(node => node !== preserve);\n            }\n\n            duplicates.forEach(_remove2.default);\n        }\n\n        decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));\n    }\n}\n\nexports.default = {\n    explode,\n    merge\n};\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}