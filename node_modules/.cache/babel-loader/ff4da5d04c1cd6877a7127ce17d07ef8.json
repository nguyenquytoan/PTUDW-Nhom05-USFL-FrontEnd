{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.broadcastUpdate = function (e, t) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:broadcast-update:4.3.1\"] && _();\n  } catch (e) {}\n\n  const s = (e, t, s) => {\n    return !s.some(s => e.headers.has(s) && t.headers.has(s)) || s.every(s => {\n      const n = e.headers.has(s) === t.headers.has(s),\n            a = e.headers.get(s) === t.headers.get(s);\n      return n && a;\n    });\n  },\n        n = \"workbox\",\n        a = 1e4,\n        i = [\"content-length\", \"etag\", \"last-modified\"],\n        o = async ({\n    channel: e,\n    cacheName: t,\n    url: s\n  }) => {\n    const n = {\n      type: \"CACHE_UPDATED\",\n      meta: \"workbox-broadcast-update\",\n      payload: {\n        cacheName: t,\n        updatedURL: s\n      }\n    };\n    if (e) e.postMessage(n);else {\n      const e = await clients.matchAll({\n        type: \"window\"\n      });\n\n      for (const t of e) t.postMessage(n);\n    }\n  };\n\n  class c {\n    constructor({\n      headersToCheck: e,\n      channelName: t,\n      deferNoticationTimeout: s\n    } = {}) {\n      this.t = e || i, this.s = t || n, this.i = s || a, this.o();\n    }\n\n    notifyIfUpdated({\n      oldResponse: e,\n      newResponse: t,\n      url: n,\n      cacheName: a,\n      event: i\n    }) {\n      if (!s(e, t, this.t)) {\n        const e = (async () => {\n          i && i.request && \"navigate\" === i.request.mode && (await this.h(i)), await this.l({\n            channel: this.u(),\n            cacheName: a,\n            url: n\n          });\n        })();\n\n        if (i) try {\n          i.waitUntil(e);\n        } catch (e) {}\n        return e;\n      }\n    }\n\n    async l(e) {\n      await o(e);\n    }\n\n    u() {\n      return \"BroadcastChannel\" in self && !this.p && (this.p = new BroadcastChannel(this.s)), this.p;\n    }\n\n    h(e) {\n      if (!this.m.has(e)) {\n        const s = new t.Deferred();\n        this.m.set(e, s);\n        const n = setTimeout(() => {\n          s.resolve();\n        }, this.i);\n        s.promise.then(() => clearTimeout(n));\n      }\n\n      return this.m.get(e).promise;\n    }\n\n    o() {\n      this.m = new Map(), self.addEventListener(\"message\", e => {\n        if (\"WINDOW_READY\" === e.data.type && \"workbox-window\" === e.data.meta && this.m.size > 0) {\n          for (const e of this.m.values()) e.resolve();\n\n          this.m.clear();\n        }\n      });\n    }\n\n  }\n\n  return e.BroadcastCacheUpdate = c, e.Plugin = class {\n    constructor(e) {\n      this.l = new c(e);\n    }\n\n    cacheDidUpdate({\n      cacheName: e,\n      oldResponse: t,\n      newResponse: s,\n      request: n,\n      event: a\n    }) {\n      t && this.l.notifyIfUpdated({\n        cacheName: e,\n        oldResponse: t,\n        newResponse: s,\n        event: a,\n        url: n.url\n      });\n    }\n\n  }, e.broadcastUpdate = o, e.responsesAreSame = s, e;\n}({}, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../responsesAreSame.mjs","../utils/constants.mjs","../broadcastUpdate.mjs","../BroadcastCacheUpdate.mjs","../Plugin.mjs"],"names":["self","_","e","responsesAreSame","firstResponse","secondResponse","headersToCheck","some","header","headers","has","every","headerStateComparison","headerValueComparison","get","DEFAULT_BROADCAST_CHANNEL_NAME","DEFAULT_DEFER_NOTIFICATION_TIMEOUT","DEFAULT_HEADERS_TO_CHECK","broadcastUpdate","async","channel","cacheName","url","data","type","meta","payload","updatedURL","postMessage","windows","clients","matchAll","win","BroadcastCacheUpdate","constructor","channelName","deferNoticationTimeout","_headersToCheck","_channelName","_deferNoticationTimeout","_initWindowReadyDeferreds","notifyIfUpdated","oldResponse","newResponse","event","this","request","mode","_windowReadyOrTimeout","_broadcastUpdate","_getChannel","done","sendUpdate","waitUntil","error","opts","_channel","BroadcastChannel","_navigationEventsDeferreds","deferred","Deferred","set","timeout","setTimeout","resolve","promise","then","clearTimeout","Map","addEventListener","size","values","clear","options","cacheDidUpdate"],"mappings":"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","sourcesContent":["try{self['workbox:broadcast-update:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport './_version.mjs';\n\n/**\n * Given two `Response's`, compares several header values to see if they are\n * the same or not.\n *\n * @param {Response} firstResponse\n * @param {Response} secondResponse\n * @param {Array<string>} headersToCheck\n * @return {boolean}\n *\n * @memberof workbox.broadcastUpdate\n * @private\n */\nconst responsesAreSame = (firstResponse, secondResponse, headersToCheck) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!(firstResponse instanceof Response &&\n      secondResponse instanceof Response)) {\n      throw new WorkboxError('invalid-responses-are-same-args');\n    }\n  }\n\n  const atLeastOneHeaderAvailable = headersToCheck.some((header) => {\n    return firstResponse.headers.has(header) &&\n      secondResponse.headers.has(header);\n  });\n\n  if (!atLeastOneHeaderAvailable) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.warn(`Unable to determine where the response has been updated ` +\n        `because none of the headers that would be checked are present.`);\n      logger.debug(`Attempting to compare the following: `,\n          firstResponse, secondResponse, headersToCheck);\n    }\n\n    // Just return true, indicating the that responses are the same, since we\n    // can't determine otherwise.\n    return true;\n  }\n\n  return headersToCheck.every((header) => {\n    const headerStateComparison = firstResponse.headers.has(header) ===\n      secondResponse.headers.has(header);\n    const headerValueComparison = firstResponse.headers.get(header) ===\n      secondResponse.headers.get(header);\n\n    return headerStateComparison && headerValueComparison;\n  });\n};\n\nexport {responsesAreSame};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const CACHE_UPDATED_MESSAGE_TYPE = 'CACHE_UPDATED';\nexport const CACHE_UPDATED_MESSAGE_META = 'workbox-broadcast-update';\nexport const DEFAULT_BROADCAST_CHANNEL_NAME = 'workbox';\nexport const DEFAULT_DEFER_NOTIFICATION_TIMEOUT = 10000;\nexport const DEFAULT_HEADERS_TO_CHECK = [\n  'content-length',\n  'etag',\n  'last-modified',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {CACHE_UPDATED_MESSAGE_TYPE, CACHE_UPDATED_MESSAGE_META}\n  from './utils/constants.mjs';\n\nimport './_version.mjs';\n\n/**\n * You would not normally call this method directly; it's called automatically\n * by an instance of the {@link BroadcastCacheUpdate} class. It's exposed here\n * for the benefit of developers who would rather not use the full\n * `BroadcastCacheUpdate` implementation.\n *\n * Calling this will dispatch a message on the provided\n * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel}\n * to notify interested subscribers about a change to a cached resource.\n *\n * The message that's posted has a formation inspired by the\n * [Flux standard action](https://github.com/acdlite/flux-standard-action#introduction)\n * format like so:\n *\n * ```\n * {\n *   type: 'CACHE_UPDATED',\n *   meta: 'workbox-broadcast-update',\n *   payload: {\n *     cacheName: 'the-cache-name',\n *     updatedURL: 'https://example.com/'\n *   }\n * }\n * ```\n *\n * (Usage of [Flux](https://facebook.github.io/flux/) itself is not at\n * all required.)\n *\n * @param {Object} options\n * @param {string} options.cacheName The name of the cache in which the updated\n *     `Response` was stored.\n * @param {string} options.url The URL associated with the updated `Response`.\n * @param {BroadcastChannel} [options.channel] The `BroadcastChannel` to use.\n *     If no channel is set or the browser doesn't support the BroadcastChannel\n *     api, then an attempt will be made to `postMessage` each window client.\n *\n * @memberof workbox.broadcastUpdate\n */\nconst broadcastUpdate = async ({channel, cacheName, url}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(cacheName, 'string', {\n      moduleName: 'workbox-broadcast-update',\n      className: '~',\n      funcName: 'broadcastUpdate',\n      paramName: 'cacheName',\n    });\n    assert.isType(url, 'string', {\n      moduleName: 'workbox-broadcast-update',\n      className: '~',\n      funcName: 'broadcastUpdate',\n      paramName: 'url',\n    });\n  }\n\n  const data = {\n    type: CACHE_UPDATED_MESSAGE_TYPE,\n    meta: CACHE_UPDATED_MESSAGE_META,\n    payload: {\n      cacheName: cacheName,\n      updatedURL: url,\n    },\n  };\n\n  if (channel) {\n    channel.postMessage(data);\n  } else {\n    const windows = await clients.matchAll({type: 'window'});\n    for (const win of windows) {\n      win.postMessage(data);\n    }\n  }\n};\n\nexport {broadcastUpdate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {responsesAreSame} from './responsesAreSame.mjs';\nimport {broadcastUpdate} from './broadcastUpdate.mjs';\n\nimport {DEFAULT_HEADERS_TO_CHECK, DEFAULT_BROADCAST_CHANNEL_NAME,\n  DEFAULT_DEFER_NOTIFICATION_TIMEOUT} from './utils/constants.mjs';\n\nimport './_version.mjs';\n\n/**\n * Uses the [Broadcast Channel API]{@link https://developers.google.com/web/updates/2016/09/broadcastchannel}\n * to notify interested parties when a cached response has been updated.\n * In browsers that do not support the Broadcast Channel API, the instance\n * falls back to sending the update via `postMessage()` to all window clients.\n *\n * For efficiency's sake, the underlying response bodies are not compared;\n * only specific response headers are checked.\n *\n * @memberof workbox.broadcastUpdate\n */\nclass BroadcastCacheUpdate {\n  /**\n   * Construct a BroadcastCacheUpdate instance with a specific `channelName` to\n   * broadcast messages on\n   *\n   * @param {Object} options\n   * @param {Array<string>}\n   *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n   *     A list of headers that will be used to determine whether the responses\n   *     differ.\n   * @param {string} [options.channelName='workbox'] The name that will be used\n   *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n   *     channel name used by the `workbox-window` package).\n   * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n   *     to wait for a ready message from the window on navigation requests\n   *     before sending the update.\n   */\n  constructor({headersToCheck, channelName, deferNoticationTimeout} = {}) {\n    this._headersToCheck = headersToCheck || DEFAULT_HEADERS_TO_CHECK;\n    this._channelName = channelName || DEFAULT_BROADCAST_CHANNEL_NAME;\n    this._deferNoticationTimeout =\n        deferNoticationTimeout || DEFAULT_DEFER_NOTIFICATION_TIMEOUT;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(this._channelName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'channelName',\n      });\n      assert.isArray(this._headersToCheck, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'headersToCheck',\n      });\n    }\n\n    this._initWindowReadyDeferreds();\n  }\n\n  /**\n   * Compare two [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n   * and send a message via the\n   * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel API}\n   * if they differ.\n   *\n   * Neither of the Responses can be {@link http://stackoverflow.com/questions/39109789|opaque}.\n   *\n   * @param {Object} options\n   * @param {Response} options.oldResponse Cached response to compare.\n   * @param {Response} options.newResponse Possibly updated response to compare.\n   * @param {string} options.url The URL of the request.\n   * @param {string} options.cacheName Name of the cache the responses belong\n   *     to. This is included in the broadcast message.\n   * @param {Event} [options.event] event An optional event that triggered\n   *     this possible cache update.\n   * @return {Promise} Resolves once the update is sent.\n   */\n  notifyIfUpdated({oldResponse, newResponse, url, cacheName, event}) {\n    if (!responsesAreSame(oldResponse, newResponse, this._headersToCheck)) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Newer response found (and cached) for:`, url);\n      }\n\n      const sendUpdate = async () => {\n        // In the case of a navigation request, the requesting page will likely\n        // not have loaded its JavaScript in time to recevied the update\n        // notification, so we defer it until ready (or we timeout waiting).\n        if (event && event.request && event.request.mode === 'navigate') {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Original request was a navigation request, ` +\n                `waiting for a ready message from the window`, event.request);\n          }\n          await this._windowReadyOrTimeout(event);\n        }\n        await this._broadcastUpdate({\n          channel: this._getChannel(),\n          cacheName,\n          url,\n        });\n      };\n\n      // Send the update and ensure the SW stays alive until it's sent.\n      const done = sendUpdate();\n\n      if (event) {\n        try {\n          event.waitUntil(done);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive ` +\n                `when broadcasting cache update for ` +\n                `${getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n      return done;\n    }\n  }\n\n  /**\n   * NOTE: this is exposed on the instance primarily so it can be spied on\n   * in tests.\n   *\n   * @param {Object} opts\n   * @private\n   */\n  async _broadcastUpdate(opts) {\n    await broadcastUpdate(opts);\n  }\n\n  /**\n   * @return {BroadcastChannel|undefined} The BroadcastChannel instance used for\n   * broadcasting updates, or undefined if the browser doesn't support the\n   * Broadcast Channel API.\n   *\n   * @private\n   */\n  _getChannel() {\n    if (('BroadcastChannel' in self) && !this._channel) {\n      this._channel = new BroadcastChannel(this._channelName);\n    }\n    return this._channel;\n  }\n\n  /**\n   * Waits for a message from the window indicating that it's capable of\n   * receiving broadcasts. By default, this will only wait for the amount of\n   * time specified via the `deferNoticationTimeout` option.\n   *\n   * @param {Event} event The navigation fetch event.\n   * @return {Promise}\n   * @private\n   */\n  _windowReadyOrTimeout(event) {\n    if (!this._navigationEventsDeferreds.has(event)) {\n      const deferred = new Deferred();\n\n      // Set the deferred on the `_navigationEventsDeferreds` map so it will\n      // be resolved when the next ready message event comes.\n      this._navigationEventsDeferreds.set(event, deferred);\n\n      // But don't wait too long for the message since it may never come.\n      const timeout = setTimeout(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Timed out after ${this._deferNoticationTimeout}` +\n              `ms waiting for message from window`);\n        }\n        deferred.resolve();\n      }, this._deferNoticationTimeout);\n\n      // Ensure the timeout is cleared if the deferred promise is resolved.\n      deferred.promise.then(() => clearTimeout(timeout));\n    }\n    return this._navigationEventsDeferreds.get(event).promise;\n  }\n\n  /**\n   * Creates a mapping between navigation fetch events and deferreds, and adds\n   * a listener for message events from the window. When message events arrive,\n   * all deferreds in the mapping are resolved.\n   *\n   * Note: it would be easier if we could only resolve the deferred of\n   * navigation fetch event whose client ID matched the source ID of the\n   * message event, but currently client IDs are not exposed on navigation\n   * fetch events: https://www.chromestatus.com/feature/4846038800138240\n   *\n   * @private\n   */\n  _initWindowReadyDeferreds() {\n    // A mapping between navigation events and their deferreds.\n    this._navigationEventsDeferreds = new Map();\n\n    // The message listener needs to be added in the initial run of the\n    // service worker, but since we don't actually need to be listening for\n    // messages until the cache updates, we only invoke the callback if set.\n    self.addEventListener('message', (event) => {\n      if (event.data.type === 'WINDOW_READY' &&\n          event.data.meta === 'workbox-window' &&\n          this._navigationEventsDeferreds.size > 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Received WINDOW_READY event: `, event);\n        }\n        // Resolve any pending deferreds.\n        for (const deferred of this._navigationEventsDeferreds.values()) {\n          deferred.resolve();\n        }\n        this._navigationEventsDeferreds.clear();\n      }\n    });\n  }\n}\n\nexport {BroadcastCacheUpdate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {BroadcastCacheUpdate} from './BroadcastCacheUpdate.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin will automatically broadcast a message whenever a cached response\n * is updated.\n *\n * @memberof workbox.broadcastUpdate\n */\nclass Plugin {\n  /**\n   * Construct a BroadcastCacheUpdate instance with the passed options and\n   * calls its `notifyIfUpdated()` method whenever the plugin's\n   * `cacheDidUpdate` callback is invoked.\n   *\n   * @param {Object} options\n   * @param {Array<string>}\n   *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n   *     A list of headers that will be used to determine whether the responses\n   *     differ.\n   * @param {string} [options.channelName='workbox'] The name that will be used\n   *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n   *     channel name used by the `workbox-window` package).\n   * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n   *     to wait for a ready message from the window on navigation requests\n   *     before sending the update.\n   */\n  constructor(options) {\n    this._broadcastUpdate = new BroadcastCacheUpdate(options);\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox-sw` and `workbox-runtime-caching` handlers when an entry is\n   * added to a cache.\n   *\n   * @private\n   * @param {Object} options The input object to this function.\n   * @param {string} options.cacheName Name of the cache being updated.\n   * @param {Response} [options.oldResponse] The previous cached value, if any.\n   * @param {Response} options.newResponse The new value in the cache.\n   * @param {Request} options.request The request that triggered the udpate.\n   * @param {Request} [options.event] The event that triggered the update.\n   */\n  cacheDidUpdate({cacheName, oldResponse, newResponse, request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(newResponse, Response, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'newResponse',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    if (!oldResponse) {\n      // Without a two responses there is nothing to compare.\n      return;\n    }\n    this._broadcastUpdate.notifyIfUpdated({\n      cacheName,\n      oldResponse,\n      newResponse,\n      event,\n      url: request.url,\n    });\n  }\n}\n\nexport {Plugin};\n"]},"metadata":{},"sourceType":"script"}