{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar parser = _interopDefault(require('postcss-values-parser'));\n\nvar convertColors = require('@csstools/convert-colors');\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar index = postcss.plugin('postcss-color-gray', opts => root => {\n  // walk all declarations likely containing a gray() function\n  root.walkDecls(decl => {\n    if (hasGrayFunction(decl)) {\n      const originalValue = decl.value; // parse the declaration value\n\n      const ast = parser(originalValue).parse(); // walk every node in the value that contains a gray() function\n\n      ast.walk(node => {\n        const _getFunctionGrayArgs = getFunctionGrayArgs(node),\n              _getFunctionGrayArgs2 = _slicedToArray(_getFunctionGrayArgs, 2),\n              lightness = _getFunctionGrayArgs2[0],\n              alpha = _getFunctionGrayArgs2[1];\n\n        if (lightness !== undefined) {\n          // rename the gray() function to rgb()\n          node.value = 'rgb'; // convert the lab gray lightness into rgb\n\n          const _lab2rgb$map = convertColors.lab2rgb(lightness, 0, 0).map(channel => Math.max(Math.min(Math.round(channel * 2.55), 255), 0)),\n                _lab2rgb$map2 = _slicedToArray(_lab2rgb$map, 3),\n                r = _lab2rgb$map2[0],\n                g = _lab2rgb$map2[1],\n                b = _lab2rgb$map2[2]; // preserve the slash nodes within rgb()\n\n\n          const openingSlash = node.first;\n          const closingSlash = node.last;\n          node.removeAll() // replace the contents of rgb with `(r,g,b`\n          .append(openingSlash).append(parser.number({\n            value: r\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: g\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: b\n          })); // if an alpha channel was defined\n\n          if (alpha < 1) {\n            // rename the rgb() function to rgba()\n            node.value += 'a';\n            node // append the contents of rgba with `,a`\n            .append(parser.comma({\n              value: ','\n            })).append(parser.number({\n              value: alpha\n            }));\n          } // append the contents of rgb/rgba with `)`\n\n\n          node.append(closingSlash);\n        }\n      });\n      const modifiedValue = ast.toString(); // if the modified value has changed from the original value\n\n      if (originalValue !== modifiedValue) {\n        // if the original gray() color is to be preserved\n        if (Object(opts).preserve) {\n          // insert the declaration value with the fallback before the current declaration\n          decl.cloneBefore({\n            value: modifiedValue\n          });\n        } else {\n          // otherwise, overwrite the declaration value with the fallback\n          decl.value = modifiedValue;\n        }\n      }\n    }\n  });\n}); // return whether a string contains a gray() function\n\nconst hasGrayFunctionRegExp = /(^|[^\\w-])gray\\(/i;\n\nconst hasGrayFunction = decl => hasGrayFunctionRegExp.test(Object(decl).value); // return whether a node matches a specific type\n\n\nconst isNumber = node => Object(node).type === 'number';\n\nconst isOperator = node => Object(node).type === 'operator';\n\nconst isFunction = node => Object(node).type === 'func';\n\nconst isCalcRegExp = /^calc$/i;\n\nconst isFunctionCalc = node => isFunction(node) && isCalcRegExp.test(node.value);\n\nconst isGrayRegExp = /^gray$/i;\n\nconst isFunctionGrayWithArgs = node => isFunction(node) && isGrayRegExp.test(node.value) && node.nodes && node.nodes.length;\n\nconst isNumberPercentage = node => isNumber(node) && node.unit === '%';\n\nconst isNumberUnitless = node => isNumber(node) && node.unit === '';\n\nconst isOperatorSlash = node => isOperator(node) && node.value === '/'; // return valid values from a node, otherwise undefined\n\n\nconst getNumberUnitless = node => isNumberUnitless(node) ? Number(node.value) : undefined;\n\nconst getOperatorSlash = node => isOperatorSlash(node) ? null : undefined;\n\nconst getAlpha = node => isFunctionCalc(node) ? String(node) : isNumberUnitless(node) ? Number(node.value) : isNumberPercentage(node) ? Number(node.value) / 100 : undefined; // return valid arguments from a gray() function\n\n\nconst functionalGrayArgs = [getNumberUnitless, getOperatorSlash, getAlpha];\n\nconst getFunctionGrayArgs = node => {\n  const validArgs = []; // if the node is a gray() function with arguments\n\n  if (isFunctionGrayWithArgs(node)) {\n    // get all the gray() function arguments between `(` and `)`\n    const nodes = node.nodes.slice(1, -1); // validate each argument\n\n    for (const index in nodes) {\n      const arg = typeof functionalGrayArgs[index] === 'function' ? functionalGrayArgs[index](nodes[index]) : undefined; // if the argument was validated\n\n      if (arg !== undefined) {\n        // push any non-null argument to the valid arguments array\n        if (arg !== null) {\n          validArgs.push(arg);\n        }\n      } else {\n        // otherwise, return an empty array\n        return [];\n      }\n    } // return the valid arguments array\n\n\n    return validArgs;\n  } else {\n    // otherwise, return an empty array\n    return [];\n  }\n};\n\nmodule.exports = index;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-color-gray/index.cjs.js"],"names":["_interopDefault","ex","postcss","require","parser","convertColors","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","Array","isArray","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","TypeError","index","plugin","opts","root","walkDecls","decl","hasGrayFunction","originalValue","ast","parse","walk","node","_getFunctionGrayArgs","getFunctionGrayArgs","_getFunctionGrayArgs2","lightness","alpha","_lab2rgb$map","lab2rgb","map","channel","Math","max","min","round","_lab2rgb$map2","r","g","b","openingSlash","first","closingSlash","last","removeAll","append","number","comma","modifiedValue","toString","Object","preserve","cloneBefore","hasGrayFunctionRegExp","test","isNumber","type","isOperator","isFunction","isCalcRegExp","isFunctionCalc","isGrayRegExp","isFunctionGrayWithArgs","nodes","isNumberPercentage","unit","isNumberUnitless","isOperatorSlash","getNumberUnitless","Number","getOperatorSlash","getAlpha","String","functionalGrayArgs","validArgs","slice","arg","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar postcss = _interopDefault(require('postcss'));\nvar parser = _interopDefault(require('postcss-values-parser'));\nvar convertColors = require('@csstools/convert-colors');\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar index = postcss.plugin('postcss-color-gray', opts => root => {\n  // walk all declarations likely containing a gray() function\n  root.walkDecls(decl => {\n    if (hasGrayFunction(decl)) {\n      const originalValue = decl.value; // parse the declaration value\n\n      const ast = parser(originalValue).parse(); // walk every node in the value that contains a gray() function\n\n      ast.walk(node => {\n        const _getFunctionGrayArgs = getFunctionGrayArgs(node),\n              _getFunctionGrayArgs2 = _slicedToArray(_getFunctionGrayArgs, 2),\n              lightness = _getFunctionGrayArgs2[0],\n              alpha = _getFunctionGrayArgs2[1];\n\n        if (lightness !== undefined) {\n          // rename the gray() function to rgb()\n          node.value = 'rgb'; // convert the lab gray lightness into rgb\n\n          const _lab2rgb$map = convertColors.lab2rgb(lightness, 0, 0).map(channel => Math.max(Math.min(Math.round(channel * 2.55), 255), 0)),\n                _lab2rgb$map2 = _slicedToArray(_lab2rgb$map, 3),\n                r = _lab2rgb$map2[0],\n                g = _lab2rgb$map2[1],\n                b = _lab2rgb$map2[2]; // preserve the slash nodes within rgb()\n\n\n          const openingSlash = node.first;\n          const closingSlash = node.last;\n          node.removeAll() // replace the contents of rgb with `(r,g,b`\n          .append(openingSlash).append(parser.number({\n            value: r\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: g\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: b\n          })); // if an alpha channel was defined\n\n          if (alpha < 1) {\n            // rename the rgb() function to rgba()\n            node.value += 'a';\n            node // append the contents of rgba with `,a`\n            .append(parser.comma({\n              value: ','\n            })).append(parser.number({\n              value: alpha\n            }));\n          } // append the contents of rgb/rgba with `)`\n\n\n          node.append(closingSlash);\n        }\n      });\n      const modifiedValue = ast.toString(); // if the modified value has changed from the original value\n\n      if (originalValue !== modifiedValue) {\n        // if the original gray() color is to be preserved\n        if (Object(opts).preserve) {\n          // insert the declaration value with the fallback before the current declaration\n          decl.cloneBefore({\n            value: modifiedValue\n          });\n        } else {\n          // otherwise, overwrite the declaration value with the fallback\n          decl.value = modifiedValue;\n        }\n      }\n    }\n  });\n}); // return whether a string contains a gray() function\n\nconst hasGrayFunctionRegExp = /(^|[^\\w-])gray\\(/i;\n\nconst hasGrayFunction = decl => hasGrayFunctionRegExp.test(Object(decl).value); // return whether a node matches a specific type\n\n\nconst isNumber = node => Object(node).type === 'number';\n\nconst isOperator = node => Object(node).type === 'operator';\n\nconst isFunction = node => Object(node).type === 'func';\n\nconst isCalcRegExp = /^calc$/i;\n\nconst isFunctionCalc = node => isFunction(node) && isCalcRegExp.test(node.value);\n\nconst isGrayRegExp = /^gray$/i;\n\nconst isFunctionGrayWithArgs = node => isFunction(node) && isGrayRegExp.test(node.value) && node.nodes && node.nodes.length;\n\nconst isNumberPercentage = node => isNumber(node) && node.unit === '%';\n\nconst isNumberUnitless = node => isNumber(node) && node.unit === '';\n\nconst isOperatorSlash = node => isOperator(node) && node.value === '/'; // return valid values from a node, otherwise undefined\n\n\nconst getNumberUnitless = node => isNumberUnitless(node) ? Number(node.value) : undefined;\n\nconst getOperatorSlash = node => isOperatorSlash(node) ? null : undefined;\n\nconst getAlpha = node => isFunctionCalc(node) ? String(node) : isNumberUnitless(node) ? Number(node.value) : isNumberPercentage(node) ? Number(node.value) / 100 : undefined; // return valid arguments from a gray() function\n\n\nconst functionalGrayArgs = [getNumberUnitless, getOperatorSlash, getAlpha];\n\nconst getFunctionGrayArgs = node => {\n  const validArgs = []; // if the node is a gray() function with arguments\n\n  if (isFunctionGrayWithArgs(node)) {\n    // get all the gray() function arguments between `(` and `)`\n    const nodes = node.nodes.slice(1, -1); // validate each argument\n\n    for (const index in nodes) {\n      const arg = typeof functionalGrayArgs[index] === 'function' ? functionalGrayArgs[index](nodes[index]) : undefined; // if the argument was validated\n\n      if (arg !== undefined) {\n        // push any non-null argument to the valid arguments array\n        if (arg !== null) {\n          validArgs.push(arg);\n        }\n      } else {\n        // otherwise, return an empty array\n        return [];\n      }\n    } // return the valid arguments array\n\n\n    return validArgs;\n  } else {\n    // otherwise, return an empty array\n    return [];\n  }\n};\n\nmodule.exports = index;\n"]},"metadata":{},"sourceType":"script"}