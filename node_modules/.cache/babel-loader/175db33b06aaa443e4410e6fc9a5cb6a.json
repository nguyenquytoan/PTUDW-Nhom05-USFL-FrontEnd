{"ast":null,"code":"/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newlines around directives\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-directive\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            enum: [\"always\", \"never\"]\n          },\n          after: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 2\n      }]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n      unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const config = context.options[0] || \"always\";\n    const expectLineBefore = typeof config === \"string\" ? config : config.before;\n    const expectLineAfter = typeof config === \"string\" ? config : config.after; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Check if node is preceded by a blank newline.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n     */\n\n    function hasNewlineBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node, {\n        includeComments: true\n      });\n      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n      return node.loc.start.line - tokenLineBefore >= 2;\n    }\n    /**\n     * Gets the last token of a node that is on the same line as the rest of the node.\n     * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n     * semicolon on a different line.\n     * @param {ASTNode} node A directive node\n     * @returns {Token} The last token of the node on the line\n     */\n\n\n    function getLastTokenOnLine(node) {\n      const lastToken = sourceCode.getLastToken(node);\n      const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;\n    }\n    /**\n     * Check if node is followed by a blank newline.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n     */\n\n\n    function hasNewlineAfter(node) {\n      const lastToken = getLastTokenOnLine(node);\n      const tokenAfter = sourceCode.getTokenAfter(lastToken, {\n        includeComments: true\n      });\n      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n    }\n    /**\n     * Report errors for newlines around directives.\n     * @param {ASTNode} node Node to check.\n     * @param {string} location Whether the error was found before or after the directive.\n     * @param {boolean} expected Whether or not a newline was expected or unexpected.\n     * @returns {void}\n     */\n\n\n    function reportError(node, location, expected) {\n      context.report({\n        node,\n        messageId: expected ? \"expected\" : \"unexpected\",\n        data: {\n          value: node.expression.value,\n          location\n        },\n\n        fix(fixer) {\n          const lastToken = getLastTokenOnLine(node);\n\n          if (expected) {\n            return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n          }\n\n          return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n        }\n\n      });\n    }\n    /**\n     * Check lines around directives in node\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function checkDirectives(node) {\n      const directives = astUtils.getDirectivePrologue(node);\n\n      if (!directives.length) {\n        return;\n      }\n\n      const firstDirective = directives[0];\n      const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n      /*\n       * Only check before the first directive if it is preceded by a comment or if it is at the top of\n       * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n       * the file if there are no comments as well as for compatibility with padded-blocks.\n       */\n\n      if (leadingComments.length) {\n        if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", true);\n        }\n\n        if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", false);\n        }\n      } else if (node.type === \"Program\" && expectLineBefore === \"never\" && !leadingComments.length && hasNewlineBefore(firstDirective)) {\n        reportError(firstDirective, \"before\", false);\n      }\n\n      const lastDirective = directives[directives.length - 1];\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n      /*\n       * Do not check after the last directive if the body only\n       * contains a directive prologue and isn't followed by a comment to ensure\n       * this rule behaves well with padded-blocks.\n       */\n\n      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n        return;\n      }\n\n      if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", true);\n      }\n\n      if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", false);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: checkDirectives,\n      FunctionDeclaration: checkDirectives,\n      FunctionExpression: checkDirectives,\n      ArrowFunctionExpression: checkDirectives\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/lines-around-directive.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","enum","properties","before","after","additionalProperties","minProperties","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","config","options","expectLineBefore","expectLineAfter","hasNewlineBefore","node","tokenBefore","getTokenBefore","includeComments","tokenLineBefore","loc","end","line","start","getLastTokenOnLine","lastToken","getLastToken","secondToLastToken","isSemicolonToken","hasNewlineAfter","tokenAfter","getTokenAfter","reportError","location","report","messageId","data","value","expression","fix","fixer","insertTextBefore","insertTextAfter","removeRange","range","checkDirectives","directives","getDirectivePrologue","length","firstDirective","leadingComments","getCommentsBefore","lastDirective","statements","body","trailingComments","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-directive\"\n        },\n\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n        },\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n         * Gets the last token of a node that is on the same line as the rest of the node.\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n         * semicolon on a different line.\n         * @param {ASTNode} node A directive node\n         * @returns {Token} The last token of the node on the line\n         */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                messageId: expected ? \"expected\" : \"unexpected\",\n                data: {\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            /*\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n             * the file if there are no comments as well as for compatibility with padded-blocks.\n             */\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            /*\n             * Do not check after the last directive if the body only\n             * contains a directive prologue and isn't followed by a comment to ensure\n             * this rule behaves well with padded-blocks.\n             */\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}