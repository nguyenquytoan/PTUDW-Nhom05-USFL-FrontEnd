{"ast":null,"code":"var Stream = require(\"stream\");\n\nvar writeMethods = [\"write\", \"end\", \"destroy\"];\nvar readMethods = [\"resume\", \"pause\"];\nvar readEvents = [\"data\", \"close\"];\nvar slice = Array.prototype.slice;\nmodule.exports = duplex;\n\nfunction forEach(arr, fn) {\n  if (arr.forEach) {\n    return arr.forEach(fn);\n  }\n\n  for (var i = 0; i < arr.length; i++) {\n    fn(arr[i], i);\n  }\n}\n\nfunction duplex(writer, reader) {\n  var stream = new Stream();\n  var ended = false;\n  forEach(writeMethods, proxyWriter);\n  forEach(readMethods, proxyReader);\n  forEach(readEvents, proxyStream);\n  reader.on(\"end\", handleEnd);\n  writer.on(\"drain\", function () {\n    stream.emit(\"drain\");\n  });\n  writer.on(\"error\", reemit);\n  reader.on(\"error\", reemit);\n  stream.writable = writer.writable;\n  stream.readable = reader.readable;\n  return stream;\n\n  function proxyWriter(methodName) {\n    stream[methodName] = method;\n\n    function method() {\n      return writer[methodName].apply(writer, arguments);\n    }\n  }\n\n  function proxyReader(methodName) {\n    stream[methodName] = method;\n\n    function method() {\n      stream.emit(methodName);\n      var func = reader[methodName];\n\n      if (func) {\n        return func.apply(reader, arguments);\n      }\n\n      reader.emit(methodName);\n    }\n  }\n\n  function proxyStream(methodName) {\n    reader.on(methodName, reemit);\n\n    function reemit() {\n      var args = slice.call(arguments);\n      args.unshift(methodName);\n      stream.emit.apply(stream, args);\n    }\n  }\n\n  function handleEnd() {\n    if (ended) {\n      return;\n    }\n\n    ended = true;\n    var args = slice.call(arguments);\n    args.unshift(\"end\");\n    stream.emit.apply(stream, args);\n  }\n\n  function reemit(err) {\n    stream.emit(\"error\", err);\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/duplexer/index.js"],"names":["Stream","require","writeMethods","readMethods","readEvents","slice","Array","prototype","module","exports","duplex","forEach","arr","fn","i","length","writer","reader","stream","ended","proxyWriter","proxyReader","proxyStream","on","handleEnd","emit","reemit","writable","readable","methodName","method","apply","arguments","func","args","call","unshift","err"],"mappings":"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","sourcesContent":["var Stream = require(\"stream\")\nvar writeMethods = [\"write\", \"end\", \"destroy\"]\nvar readMethods = [\"resume\", \"pause\"]\nvar readEvents = [\"data\", \"close\"]\nvar slice = Array.prototype.slice\n\nmodule.exports = duplex\n\nfunction forEach (arr, fn) {\n    if (arr.forEach) {\n        return arr.forEach(fn)\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n        fn(arr[i], i)\n    }\n}\n\nfunction duplex(writer, reader) {\n    var stream = new Stream()\n    var ended = false\n\n    forEach(writeMethods, proxyWriter)\n\n    forEach(readMethods, proxyReader)\n\n    forEach(readEvents, proxyStream)\n\n    reader.on(\"end\", handleEnd)\n\n    writer.on(\"drain\", function() {\n      stream.emit(\"drain\")\n    })\n\n    writer.on(\"error\", reemit)\n    reader.on(\"error\", reemit)\n\n    stream.writable = writer.writable\n    stream.readable = reader.readable\n\n    return stream\n\n    function proxyWriter(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            return writer[methodName].apply(writer, arguments)\n        }\n    }\n\n    function proxyReader(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            stream.emit(methodName)\n            var func = reader[methodName]\n            if (func) {\n                return func.apply(reader, arguments)\n            }\n            reader.emit(methodName)\n        }\n    }\n\n    function proxyStream(methodName) {\n        reader.on(methodName, reemit)\n\n        function reemit() {\n            var args = slice.call(arguments)\n            args.unshift(methodName)\n            stream.emit.apply(stream, args)\n        }\n    }\n\n    function handleEnd() {\n        if (ended) {\n            return\n        }\n        ended = true\n        var args = slice.call(arguments)\n        args.unshift(\"end\")\n        stream.emit.apply(stream, args)\n    }\n\n    function reemit(err) {\n        stream.emit(\"error\", err)\n    }\n}\n"]},"metadata":{},"sourceType":"script"}