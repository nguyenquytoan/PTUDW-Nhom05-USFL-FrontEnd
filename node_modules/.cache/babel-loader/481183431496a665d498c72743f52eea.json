{"ast":null,"code":"import { noop, resolve, reject, subscribe, PENDING } from '../-internal';\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @for Promise\n  @static\n  @param {Array} entries array of promises to observe\n  @param {String} [label] optional string for describing the promise returned.\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\n\nexport default function race(entries, label) {\n  /*jshint validthis:true */\n  let Constructor = this;\n  let promise = new Constructor(noop, label);\n\n  if (!Array.isArray(entries)) {\n    reject(promise, new TypeError('Promise.race must be called with an array'));\n    return promise;\n  }\n\n  for (let i = 0; promise._state === PENDING && i < entries.length; i++) {\n    subscribe(Constructor.resolve(entries[i]), undefined, value => resolve(promise, value), reason => reject(promise, reason));\n  }\n\n  return promise;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/rsvp/lib/rsvp/promise/race.js"],"names":["noop","resolve","reject","subscribe","PENDING","race","entries","label","Constructor","promise","Array","isArray","TypeError","i","_state","length","undefined","value","reason"],"mappings":"AAAA,SACEA,IADF,EAEEC,OAFF,EAGEC,MAHF,EAIEC,SAJF,EAKEC,OALF,QAMO,cANP;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyEA,eAAe,SAASC,IAAT,CAAcC,OAAd,EAAuBC,KAAvB,EAA8B;AAC3C;AACA,MAAIC,WAAW,GAAG,IAAlB;AAEA,MAAIC,OAAO,GAAG,IAAID,WAAJ,CAAgBR,IAAhB,EAAsBO,KAAtB,CAAd;;AAEA,MAAI,CAACG,KAAK,CAACC,OAAN,CAAcL,OAAd,CAAL,EAA6B;AAC3BJ,IAAAA,MAAM,CAACO,OAAD,EAAU,IAAIG,SAAJ,CAAc,2CAAd,CAAV,CAAN;AACA,WAAOH,OAAP;AACD;;AAED,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBJ,OAAO,CAACK,MAAR,KAAmBV,OAAnB,IAA8BS,CAAC,GAAGP,OAAO,CAACS,MAA1D,EAAkEF,CAAC,EAAnE,EAAuE;AACrEV,IAAAA,SAAS,CACPK,WAAW,CAACP,OAAZ,CAAoBK,OAAO,CAACO,CAAD,CAA3B,CADO,EAC0BG,SAD1B,EAEPC,KAAK,IAAKhB,OAAO,CAACQ,OAAD,EAAUQ,KAAV,CAFV,EAGPC,MAAM,IAAIhB,MAAM,CAACO,OAAD,EAAUS,MAAV,CAHT,CAAT;AAKD;;AAED,SAAOT,OAAP;AACD","sourcesContent":["import {\n  noop,\n  resolve,\n  reject,\n  subscribe,\n  PENDING\n} from '../-internal';\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @for Promise\n  @static\n  @param {Array} entries array of promises to observe\n  @param {String} [label] optional string for describing the promise returned.\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nexport default function race(entries, label) {\n  /*jshint validthis:true */\n  let Constructor = this;\n\n  let promise = new Constructor(noop, label);\n\n  if (!Array.isArray(entries)) {\n    reject(promise, new TypeError('Promise.race must be called with an array'));\n    return promise;\n  }\n\n  for (let i = 0; promise._state === PENDING && i < entries.length; i++) {\n    subscribe(\n      Constructor.resolve(entries[i]), undefined,\n      value  => resolve(promise, value),\n      reason => reject(promise, reason)\n    );\n  }\n\n  return promise;\n}\n"]},"metadata":{},"sourceType":"module"}