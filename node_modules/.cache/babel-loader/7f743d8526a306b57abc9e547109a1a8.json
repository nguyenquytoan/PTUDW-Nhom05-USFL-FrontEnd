{"ast":null,"code":"/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n * @param {ASTNode} node An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\n\nfunction getContainingLoopNode(node) {\n  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      case \"WhileStatement\":\n      case \"DoWhileStatement\":\n        return parent;\n\n      case \"ForStatement\":\n        // `init` is outside of the loop.\n        if (parent.init !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        // `right` is outside of the loop.\n        if (parent.right !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n      case \"FunctionDeclaration\":\n        // We don't need to check nested functions.\n        return null;\n\n      default:\n        break;\n    }\n  }\n\n  return null;\n}\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param {ASTNode} node A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\n\n\nfunction getTopLoopNode(node, excludedNode) {\n  const border = excludedNode ? excludedNode.range[1] : 0;\n  let retv = node;\n  let containingLoopNode = node;\n\n  while (containingLoopNode && containingLoopNode.range[0] >= border) {\n    retv = containingLoopNode;\n    containingLoopNode = getContainingLoopNode(containingLoopNode);\n  }\n\n  return retv;\n}\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param {ASTNode} loopNode A containing loop node.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\n\n\nfunction isSafe(loopNode, reference) {\n  const variable = reference.resolved;\n  const definition = variable && variable.defs[0];\n  const declaration = definition && definition.parent;\n  const kind = declaration && declaration.type === \"VariableDeclaration\" ? declaration.kind : \"\"; // Variables which are declared by `const` is safe.\n\n  if (kind === \"const\") {\n    return true;\n  }\n  /*\n   * Variables which are declared by `let` in the loop is safe.\n   * It's a different instance from the next loop step's.\n   */\n\n\n  if (kind === \"let\" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {\n    return true;\n  }\n  /*\n   * WriteReferences which exist after this border are unsafe because those\n   * can modify the variable.\n   */\n\n\n  const border = getTopLoopNode(loopNode, kind === \"let\" ? declaration : null).range[0];\n  /**\n   * Checks whether a given reference is safe or not.\n   * The reference is every reference of the upper scope's variable we are\n   * looking now.\n   *\n   * It's safeafe if the reference matches one of the following condition.\n   * - is readonly.\n   * - doesn't exist inside a local function and after the border.\n   * @param {eslint-scope.Reference} upperRef A reference to check.\n   * @returns {boolean} `true` if the reference is safe.\n   */\n\n  function isSafeReference(upperRef) {\n    const id = upperRef.identifier;\n    return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;\n  }\n\n  return Boolean(variable) && variable.references.every(isSafeReference);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow function declarations that contain unsafe references inside loop statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loop-func\"\n    },\n    schema: [],\n    messages: {\n      unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * Reports functions which match the following condition:\n     *\n     * - has a loop node in ancestors.\n     * - has any references which refers to an unsafe variable.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {boolean} Whether or not the node is within a loop.\n     */\n    function checkForLoops(node) {\n      const loopNode = getContainingLoopNode(node);\n\n      if (!loopNode) {\n        return;\n      }\n\n      const references = context.getScope().through;\n      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n      if (unsafeRefs.length > 0) {\n        context.report({\n          node,\n          messageId: \"unsafeRefs\",\n          data: {\n            varNames: `'${unsafeRefs.join(\"', '\")}'`\n          }\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkForLoops,\n      FunctionExpression: checkForLoops,\n      FunctionDeclaration: checkForLoops\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-loop-func.js"],"names":["getContainingLoopNode","node","currentNode","parent","type","init","right","getTopLoopNode","excludedNode","border","range","retv","containingLoopNode","isSafe","loopNode","reference","variable","resolved","definition","defs","declaration","kind","isSafeReference","upperRef","id","identifier","isWrite","scope","variableScope","from","Boolean","references","every","module","exports","meta","docs","description","category","recommended","url","schema","messages","unsafeRefs","create","context","checkForLoops","getScope","through","filter","r","map","name","length","report","messageId","data","varNames","join","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n * @param {ASTNode} node An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n\n                // `init` is outside of the loop.\n                if (parent.init !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n\n                // `right` is outside of the loop.\n                if (parent.right !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param {ASTNode} node A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n    const border = excludedNode ? excludedNode.range[1] : 0;\n    let retv = node;\n    let containingLoopNode = node;\n\n    while (containingLoopNode && containingLoopNode.range[0] >= border) {\n        retv = containingLoopNode;\n        containingLoopNode = getContainingLoopNode(containingLoopNode);\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param {ASTNode} loopNode A containing loop node.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n    const variable = reference.resolved;\n    const definition = variable && variable.defs[0];\n    const declaration = definition && definition.parent;\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\n        ? declaration.kind\n        : \"\";\n\n    // Variables which are declared by `const` is safe.\n    if (kind === \"const\") {\n        return true;\n    }\n\n    /*\n     * Variables which are declared by `let` in the loop is safe.\n     * It's a different instance from the next loop step's.\n     */\n    if (kind === \"let\" &&\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    ) {\n        return true;\n    }\n\n    /*\n     * WriteReferences which exist after this border are unsafe because those\n     * can modify the variable.\n     */\n    const border = getTopLoopNode(\n        loopNode,\n        (kind === \"let\") ? declaration : null\n    ).range[0];\n\n    /**\n     * Checks whether a given reference is safe or not.\n     * The reference is every reference of the upper scope's variable we are\n     * looking now.\n     *\n     * It's safeafe if the reference matches one of the following condition.\n     * - is readonly.\n     * - doesn't exist inside a local function and after the border.\n     * @param {eslint-scope.Reference} upperRef A reference to check.\n     * @returns {boolean} `true` if the reference is safe.\n     */\n    function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }\n\n    return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow function declarations that contain unsafe references inside loop statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loop-func\"\n        },\n\n        schema: [],\n\n        messages: {\n            unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} Whether or not the node is within a loop.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = context.getScope().through;\n            const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n            if (unsafeRefs.length > 0) {\n                context.report({\n                    node,\n                    messageId: \"unsafeRefs\",\n                    data: { varNames: `'${unsafeRefs.join(\"', '\")}'` }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}