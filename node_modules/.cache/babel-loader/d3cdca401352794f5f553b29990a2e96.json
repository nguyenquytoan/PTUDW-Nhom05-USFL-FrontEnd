{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.extract = extract;\nexports.strip = strip;\nexports.parse = parse;\nexports.parseWithComments = parseWithComments;\nexports.print = print;\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _detectNewline() {\n  const data = _interopRequireDefault(require('detect-newline'));\n\n  _detectNewline = function _detectNewline() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst commentEndRe = /\\*\\/$/;\nconst commentStartRe = /^\\/\\*\\*/;\nconst docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\nconst lineCommentRe = /(^|\\s+)\\/\\/([^\\r\\n]*)/g;\nconst ltrimNewlineRe = /^(\\r?\\n)+/;\nconst multilineRe = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;\nconst propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;\nconst stringStartRe = /(\\r?\\n|^) *\\* ?/g;\n\nfunction extract(contents) {\n  const match = contents.match(docblockRe);\n  return match ? match[0].trimLeft() : '';\n}\n\nfunction strip(contents) {\n  const match = contents.match(docblockRe);\n  return match && match[0] ? contents.substring(match[0].length) : contents;\n}\n\nfunction parse(docblock) {\n  return parseWithComments(docblock).pragmas;\n}\n\nfunction parseWithComments(docblock) {\n  const line = (0, _detectNewline().default)(docblock) || _os().EOL;\n\n  docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives\n\n  let prev = '';\n\n  while (prev !== docblock) {\n    prev = docblock;\n    docblock = docblock.replace(multilineRe, `${line}$1 $2${line}`);\n  }\n\n  docblock = docblock.replace(ltrimNewlineRe, '').trimRight();\n  const result = Object.create(null);\n  const comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();\n  let match;\n\n  while (match = propertyRe.exec(docblock)) {\n    // strip linecomments from pragmas\n    const nextPragma = match[2].replace(lineCommentRe, '');\n\n    if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {\n      result[match[1]] = [].concat(result[match[1]], nextPragma);\n    } else {\n      result[match[1]] = nextPragma;\n    }\n  }\n\n  return {\n    comments,\n    pragmas: result\n  };\n}\n\nfunction print({\n  comments = '',\n  pragmas = {}\n}) {\n  const line = (0, _detectNewline().default)(comments) || _os().EOL;\n\n  const head = '/**';\n  const start = ' *';\n  const tail = ' */';\n  const keys = Object.keys(pragmas);\n  const printedObject = keys.map(key => printKeyValues(key, pragmas[key])).reduce((arr, next) => arr.concat(next), []).map(keyValue => start + ' ' + keyValue + line).join('');\n\n  if (!comments) {\n    if (keys.length === 0) {\n      return '';\n    }\n\n    if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n      const value = pragmas[keys[0]];\n      return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;\n    }\n  }\n\n  const printedComments = comments.split(line).map(textLine => `${start} ${textLine}`).join(line) + line;\n  return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;\n}\n\nfunction printKeyValues(key, valueOrArray) {\n  return [].concat(valueOrArray).map(value => `@${key} ${value}`.trim());\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-docblock/build/index.js"],"names":["Object","defineProperty","exports","value","extract","strip","parse","parseWithComments","print","_os","data","require","_detectNewline","_interopRequireDefault","obj","__esModule","default","commentEndRe","commentStartRe","docblockRe","lineCommentRe","ltrimNewlineRe","multilineRe","propertyRe","stringStartRe","contents","match","trimLeft","substring","length","docblock","pragmas","line","EOL","replace","prev","trimRight","result","create","comments","exec","nextPragma","Array","isArray","concat","head","start","tail","keys","printedObject","map","key","printKeyValues","reduce","arr","next","keyValue","join","printedComments","split","textLine","valueOrArray","trim"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.extract = extract;\nexports.strip = strip;\nexports.parse = parse;\nexports.parseWithComments = parseWithComments;\nexports.print = print;\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _detectNewline() {\n  const data = _interopRequireDefault(require('detect-newline'));\n\n  _detectNewline = function _detectNewline() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst commentEndRe = /\\*\\/$/;\nconst commentStartRe = /^\\/\\*\\*/;\nconst docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\nconst lineCommentRe = /(^|\\s+)\\/\\/([^\\r\\n]*)/g;\nconst ltrimNewlineRe = /^(\\r?\\n)+/;\nconst multilineRe = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;\nconst propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;\nconst stringStartRe = /(\\r?\\n|^) *\\* ?/g;\n\nfunction extract(contents) {\n  const match = contents.match(docblockRe);\n  return match ? match[0].trimLeft() : '';\n}\n\nfunction strip(contents) {\n  const match = contents.match(docblockRe);\n  return match && match[0] ? contents.substring(match[0].length) : contents;\n}\n\nfunction parse(docblock) {\n  return parseWithComments(docblock).pragmas;\n}\n\nfunction parseWithComments(docblock) {\n  const line = (0, _detectNewline().default)(docblock) || _os().EOL;\n\n  docblock = docblock\n    .replace(commentStartRe, '')\n    .replace(commentEndRe, '')\n    .replace(stringStartRe, '$1'); // Normalize multi-line directives\n\n  let prev = '';\n\n  while (prev !== docblock) {\n    prev = docblock;\n    docblock = docblock.replace(multilineRe, `${line}$1 $2${line}`);\n  }\n\n  docblock = docblock.replace(ltrimNewlineRe, '').trimRight();\n  const result = Object.create(null);\n  const comments = docblock\n    .replace(propertyRe, '')\n    .replace(ltrimNewlineRe, '')\n    .trimRight();\n  let match;\n\n  while ((match = propertyRe.exec(docblock))) {\n    // strip linecomments from pragmas\n    const nextPragma = match[2].replace(lineCommentRe, '');\n\n    if (\n      typeof result[match[1]] === 'string' ||\n      Array.isArray(result[match[1]])\n    ) {\n      result[match[1]] = [].concat(result[match[1]], nextPragma);\n    } else {\n      result[match[1]] = nextPragma;\n    }\n  }\n\n  return {\n    comments,\n    pragmas: result\n  };\n}\n\nfunction print({comments = '', pragmas = {}}) {\n  const line = (0, _detectNewline().default)(comments) || _os().EOL;\n\n  const head = '/**';\n  const start = ' *';\n  const tail = ' */';\n  const keys = Object.keys(pragmas);\n  const printedObject = keys\n    .map(key => printKeyValues(key, pragmas[key]))\n    .reduce((arr, next) => arr.concat(next), [])\n    .map(keyValue => start + ' ' + keyValue + line)\n    .join('');\n\n  if (!comments) {\n    if (keys.length === 0) {\n      return '';\n    }\n\n    if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n      const value = pragmas[keys[0]];\n      return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;\n    }\n  }\n\n  const printedComments =\n    comments\n      .split(line)\n      .map(textLine => `${start} ${textLine}`)\n      .join(line) + line;\n  return (\n    head +\n    line +\n    (comments ? printedComments : '') +\n    (comments && keys.length ? start + line : '') +\n    printedObject +\n    tail\n  );\n}\n\nfunction printKeyValues(key, valueOrArray) {\n  return [].concat(valueOrArray).map(value => `@${key} ${value}`.trim());\n}\n"]},"metadata":{},"sourceType":"script"}