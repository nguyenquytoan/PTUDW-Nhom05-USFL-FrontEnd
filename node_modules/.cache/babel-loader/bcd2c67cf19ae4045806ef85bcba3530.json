{"ast":null,"code":"/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\"use strict\";\n\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"eslint-utils\");\n\nconst {\n  isCommaToken,\n  isOpeningParenToken,\n  isClosingParenToken,\n  isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\n\nfunction hasArraySpread(node) {\n  return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\n\n\nfunction needsParens(node, sourceCode) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"VariableDeclarator\":\n    case \"ArrayExpression\":\n    case \"ReturnStatement\":\n    case \"CallExpression\":\n    case \"Property\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.left === node && !isParenthesised(sourceCode, node);\n\n    default:\n      return !isParenthesised(sourceCode, node);\n  }\n}\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\n\n\nfunction argNeedsParens(node, sourceCode) {\n  switch (node.type) {\n    case \"AssignmentExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ConditionalExpression\":\n      return !isParenthesised(sourceCode, node);\n\n    default:\n      return false;\n  }\n}\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This incldues the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\n\n\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n  let leftNext = sourceCode.getTokenBefore(node);\n  let rightNext = sourceCode.getTokenAfter(node); // Note: don't include the parens of the argument list.\n\n  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {\n    parens.push(leftNext, rightNext);\n    leftNext = sourceCode.getTokenBefore(leftNext);\n    rightNext = sourceCode.getTokenAfter(rightNext);\n  }\n\n  return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\n\n\nfunction getStartWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let start = token.range[0]; // If the previous token is a line comment then skip this step to avoid commenting this token out.\n\n  {\n    const prevToken = sourceCode.getTokenBefore(token, {\n      includeComments: true\n    });\n\n    if (prevToken && prevToken.type === \"Line\") {\n      return start;\n    }\n  } // Detect spaces before the token.\n\n  while (ANY_SPACE.test(text[start - 1] || \"\")) {\n    start -= 1;\n  }\n\n  return start;\n}\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\n\n\nfunction getEndWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let end = token.range[1]; // Detect spaces after the token.\n\n  while (ANY_SPACE.test(text[end] || \"\")) {\n    end += 1;\n  }\n\n  return end;\n}\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\n\n\nfunction defineFixer(node, sourceCode) {\n  return function* (fixer) {\n    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n    const rightParen = sourceCode.getLastToken(node); // Remove the callee `Object.assign`\n\n    yield fixer.remove(node.callee); // Replace the parens of argument list to braces.\n\n    if (needsParens(node, sourceCode)) {\n      yield fixer.replaceText(leftParen, \"({\");\n      yield fixer.replaceText(rightParen, \"})\");\n    } else {\n      yield fixer.replaceText(leftParen, \"{\");\n      yield fixer.replaceText(rightParen, \"}\");\n    } // Process arguments.\n\n\n    for (const argNode of node.arguments) {\n      const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n      const left = innerParens.shift();\n      const right = innerParens.pop();\n\n      if (argNode.type === \"ObjectExpression\") {\n        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n        const maybeArgumentComma = sourceCode.getTokenAfter(right);\n        /*\n         * Make bare this object literal.\n         * And remove spaces inside of the braces for better formatting.\n         */\n\n        for (const innerParen of innerParens) {\n          yield fixer.remove(innerParen);\n        }\n\n        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n        right.range[1]];\n        yield fixer.removeRange(leftRange);\n        yield fixer.removeRange(rightRange); // Remove the comma of this argument if it's duplication.\n\n        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {\n          yield fixer.remove(maybeArgumentComma);\n        }\n      } else {\n        // Make spread.\n        if (argNeedsParens(argNode, sourceCode)) {\n          yield fixer.insertTextBefore(left, \"...(\");\n          yield fixer.insertTextAfter(right, \")\");\n        } else {\n          yield fixer.insertTextBefore(left, \"...\");\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n      useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Object: {\n            assign: {\n              [CALL]: true\n            }\n          }\n        }; // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          if (node.arguments.length >= 1 && node.arguments[0].type === \"ObjectExpression\" && !hasArraySpread(node)) {\n            const messageId = node.arguments.length === 1 ? \"useLiteralMessage\" : \"useSpreadMessage\";\n            const fix = defineFixer(node, sourceCode);\n            context.report({\n              node,\n              messageId,\n              fix\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-object-spread.js"],"names":["CALL","ReferenceTracker","require","isCommaToken","isOpeningParenToken","isClosingParenToken","isParenthesised","ANY_SPACE","hasArraySpread","node","arguments","some","arg","type","needsParens","sourceCode","parent","left","argNeedsParens","getParenTokens","leftArgumentListParen","parens","getFirstToken","getLastToken","leftNext","getTokenBefore","rightNext","getTokenAfter","range","push","sort","a","b","getStartWithSpaces","token","text","start","prevToken","includeComments","test","getEndWithSpaces","end","defineFixer","fixer","leftParen","callee","rightParen","remove","replaceText","argNode","innerParens","shift","right","pop","maybeTrailingComma","maybeArgumentComma","innerParen","leftRange","rightRange","Math","max","removeRange","properties","length","insertTextBefore","insertTextAfter","module","exports","meta","docs","description","category","recommended","url","schema","fixable","messages","useSpreadMessage","useLiteralMessage","create","context","getSourceCode","Program","scope","getScope","tracker","trackMap","Object","assign","iterateGlobalReferences","messageId","fix","report"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\nconst {\n    isCommaToken,\n    isOpeningParenToken,\n    isClosingParenToken,\n    isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"VariableDeclarator\":\n        case \"ArrayExpression\":\n        case \"ReturnStatement\":\n        case \"CallExpression\":\n        case \"Property\":\n            return false;\n        case \"AssignmentExpression\":\n            return parent.left === node && !isParenthesised(sourceCode, node);\n        default:\n            return !isParenthesised(sourceCode, node);\n    }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n    switch (node.type) {\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ConditionalExpression\":\n            return !isParenthesised(sourceCode, node);\n        default:\n            return false;\n    }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This incldues the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n    let leftNext = sourceCode.getTokenBefore(node);\n    let rightNext = sourceCode.getTokenAfter(node);\n\n    // Note: don't include the parens of the argument list.\n    while (\n        leftNext &&\n        rightNext &&\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\n        isOpeningParenToken(leftNext) &&\n        isClosingParenToken(rightNext)\n    ) {\n        parens.push(leftNext, rightNext);\n        leftNext = sourceCode.getTokenBefore(leftNext);\n        rightNext = sourceCode.getTokenAfter(rightNext);\n    }\n\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let start = token.range[0];\n\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\n    {\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n        if (prevToken && prevToken.type === \"Line\") {\n            return start;\n        }\n    }\n\n    // Detect spaces before the token.\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\n        start -= 1;\n    }\n\n    return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let end = token.range[1];\n\n    // Detect spaces after the token.\n    while (ANY_SPACE.test(text[end] || \"\")) {\n        end += 1;\n    }\n\n    return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n    return function *(fixer) {\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n        const rightParen = sourceCode.getLastToken(node);\n\n        // Remove the callee `Object.assign`\n        yield fixer.remove(node.callee);\n\n        // Replace the parens of argument list to braces.\n        if (needsParens(node, sourceCode)) {\n            yield fixer.replaceText(leftParen, \"({\");\n            yield fixer.replaceText(rightParen, \"})\");\n        } else {\n            yield fixer.replaceText(leftParen, \"{\");\n            yield fixer.replaceText(rightParen, \"}\");\n        }\n\n        // Process arguments.\n        for (const argNode of node.arguments) {\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n            const left = innerParens.shift();\n            const right = innerParens.pop();\n\n            if (argNode.type === \"ObjectExpression\") {\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n                /*\n                 * Make bare this object literal.\n                 * And remove spaces inside of the braces for better formatting.\n                 */\n                for (const innerParen of innerParens) {\n                    yield fixer.remove(innerParen);\n                }\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n                const rightRange = [\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n                    right.range[1]\n                ];\n\n                yield fixer.removeRange(leftRange);\n                yield fixer.removeRange(rightRange);\n\n                // Remove the comma of this argument if it's duplication.\n                if (\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\n                    isCommaToken(maybeArgumentComma)\n                ) {\n                    yield fixer.remove(maybeArgumentComma);\n                }\n            } else {\n\n                // Make spread.\n                if (argNeedsParens(argNode, sourceCode)) {\n                    yield fixer.insertTextBefore(left, \"...(\");\n                    yield fixer.insertTextAfter(right, \")\");\n                } else {\n                    yield fixer.insertTextBefore(left, \"...\");\n                }\n            }\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description:\n                \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Object: {\n                        assign: { [CALL]: true }\n                    }\n                };\n\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    if (\n                        node.arguments.length >= 1 &&\n                        node.arguments[0].type === \"ObjectExpression\" &&\n                        !hasArraySpread(node)\n                    ) {\n                        const messageId = node.arguments.length === 1\n                            ? \"useLiteralMessage\"\n                            : \"useSpreadMessage\";\n                        const fix = defineFixer(node, sourceCode);\n\n                        context.report({ node, messageId, fix });\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}