{"ast":null,"code":"/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst fs = require(\"fs\");\n\nconst fileEntryCache = require(\"file-entry-cache\");\n\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\n\nconst pkg = require(\"../../package.json\");\n\nconst hash = require(\"./hash\"); //-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\n\nfunction hashOfConfigFor(config) {\n  if (!configHashCache.has(config)) {\n    configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n  }\n\n  return configHashCache.get(config);\n} //-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\n\n\nclass LintResultCache {\n  /**\n   * Creates a new LintResultCache instance.\n   * @param {string} cacheFileLocation The cache file location.\n   *   configuration lookup by file path).\n   */\n  constructor(cacheFileLocation) {\n    assert(cacheFileLocation, \"Cache file location is required\");\n    this.fileEntryCache = fileEntryCache.create(cacheFileLocation);\n  }\n  /**\n   * Retrieve cached lint results for a given file path, if present in the\n   * cache. If the file is present and has not been changed, rebuild any\n   * missing result information.\n   * @param {string} filePath The file for which to retrieve lint results.\n   * @param {ConfigArray} config The config of the file.\n   * @returns {Object|null} The rebuilt lint results, or null if the file is\n   *   changed or not in the filesystem.\n   */\n\n\n  getCachedLintResults(filePath, config) {\n    /*\n     * Cached lint results are valid if and only if:\n     * 1. The file is present in the filesystem\n     * 2. The file has not changed since the time it was previously linted\n     * 3. The ESLint configuration has not changed since the time the file\n     *    was previously linted\n     * If any of these are not true, we will not reuse the lint results.\n     */\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n    const hashOfConfig = hashOfConfigFor(config);\n    const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n    if (fileDescriptor.notFound || changed) {\n      return null;\n    } // If source is present but null, need to reread the file from the filesystem.\n\n\n    if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {\n      fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n    }\n\n    return fileDescriptor.meta.results;\n  }\n  /**\n   * Set the cached lint results for a given file path, after removing any\n   * information that will be both unnecessary and difficult to serialize.\n   * Avoids caching results with an \"output\" property (meaning fixes were\n   * applied), to prevent potentially incorrect results if fixes are not\n   * written to disk.\n   * @param {string} filePath The file for which to set lint results.\n   * @param {ConfigArray} config The config of the file.\n   * @param {Object} result The lint result to be set for the file.\n   * @returns {void}\n   */\n\n\n  setCachedLintResults(filePath, config, result) {\n    if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n      return;\n    }\n\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n    if (fileDescriptor && !fileDescriptor.notFound) {\n      // Serialize the result, except that we want to remove the file source if present.\n      const resultToSerialize = Object.assign({}, result);\n      /*\n       * Set result.source to null.\n       * In `getCachedLintResults`, if source is explicitly null, we will\n       * read the file from the filesystem to set the value again.\n       */\n\n      if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n        resultToSerialize.source = null;\n      }\n\n      fileDescriptor.meta.results = resultToSerialize;\n      fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n    }\n  }\n  /**\n   * Persists the in-memory cache to disk.\n   * @returns {void}\n   */\n\n\n  reconcile() {\n    this.fileEntryCache.reconcile();\n  }\n\n}\n\nmodule.exports = LintResultCache;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/cli-engine/lint-result-cache.js"],"names":["assert","require","fs","fileEntryCache","stringify","pkg","hash","configHashCache","WeakMap","nodeVersion","process","version","hashOfConfigFor","config","has","set","get","LintResultCache","constructor","cacheFileLocation","create","getCachedLintResults","filePath","fileDescriptor","getFileDescriptor","hashOfConfig","changed","meta","notFound","results","source","readFileSync","setCachedLintResults","result","Object","prototype","hasOwnProperty","call","resultToSerialize","assign","reconcile","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst fs = require(\"fs\");\nconst fileEntryCache = require(\"file-entry-cache\");\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\nconst pkg = require(\"../../package.json\");\nconst hash = require(\"./hash\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\n\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\nfunction hashOfConfigFor(config) {\n    if (!configHashCache.has(config)) {\n        configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n    }\n\n    return configHashCache.get(config);\n}\n\n//-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\nclass LintResultCache {\n\n    /**\n     * Creates a new LintResultCache instance.\n     * @param {string} cacheFileLocation The cache file location.\n     *   configuration lookup by file path).\n     */\n    constructor(cacheFileLocation) {\n        assert(cacheFileLocation, \"Cache file location is required\");\n\n        this.fileEntryCache = fileEntryCache.create(cacheFileLocation);\n    }\n\n    /**\n     * Retrieve cached lint results for a given file path, if present in the\n     * cache. If the file is present and has not been changed, rebuild any\n     * missing result information.\n     * @param {string} filePath The file for which to retrieve lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @returns {Object|null} The rebuilt lint results, or null if the file is\n     *   changed or not in the filesystem.\n     */\n    getCachedLintResults(filePath, config) {\n\n        /*\n         * Cached lint results are valid if and only if:\n         * 1. The file is present in the filesystem\n         * 2. The file has not changed since the time it was previously linted\n         * 3. The ESLint configuration has not changed since the time the file\n         *    was previously linted\n         * If any of these are not true, we will not reuse the lint results.\n         */\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n        const hashOfConfig = hashOfConfigFor(config);\n        const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n        if (fileDescriptor.notFound || changed) {\n            return null;\n        }\n\n        // If source is present but null, need to reread the file from the filesystem.\n        if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {\n            fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n        }\n\n        return fileDescriptor.meta.results;\n    }\n\n    /**\n     * Set the cached lint results for a given file path, after removing any\n     * information that will be both unnecessary and difficult to serialize.\n     * Avoids caching results with an \"output\" property (meaning fixes were\n     * applied), to prevent potentially incorrect results if fixes are not\n     * written to disk.\n     * @param {string} filePath The file for which to set lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @param {Object} result The lint result to be set for the file.\n     * @returns {void}\n     */\n    setCachedLintResults(filePath, config, result) {\n        if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n            return;\n        }\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n        if (fileDescriptor && !fileDescriptor.notFound) {\n\n            // Serialize the result, except that we want to remove the file source if present.\n            const resultToSerialize = Object.assign({}, result);\n\n            /*\n             * Set result.source to null.\n             * In `getCachedLintResults`, if source is explicitly null, we will\n             * read the file from the filesystem to set the value again.\n             */\n            if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n                resultToSerialize.source = null;\n            }\n\n            fileDescriptor.meta.results = resultToSerialize;\n            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n        }\n    }\n\n    /**\n     * Persists the in-memory cache to disk.\n     * @returns {void}\n     */\n    reconcile() {\n        this.fileEntryCache.reconcile();\n    }\n}\n\nmodule.exports = LintResultCache;\n"]},"metadata":{},"sourceType":"script"}