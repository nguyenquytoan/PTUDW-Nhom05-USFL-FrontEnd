{"ast":null,"code":"/* eslint-env jest */\nimport getProp from '../src/getProp';\nconst nodeVersion = parseInt(process.version.match(/^v(\\d+)\\./)[1], 10);\nexport const fallbackToBabylon = nodeVersion < 6;\nlet parserName;\nconst babelParser = fallbackToBabylon ? require('babylon') : require('@babel/parser');\n\nconst flowParser = require('flow-parser');\n\nconst defaultPlugins = ['jsx', 'functionBind', 'estree', 'objectRestSpread', 'optionalChaining' // 'nullishCoalescing', // TODO: update to babel 7\n];\nlet plugins = [...defaultPlugins];\nexport function setParserName(name) {\n  parserName = name;\n}\nexport function changePlugins(pluginOrFn) {\n  if (Array.isArray(pluginOrFn)) {\n    plugins = pluginOrFn;\n  } else if (typeof pluginOrFn === 'function') {\n    plugins = pluginOrFn(plugins);\n  } else {\n    throw new Error('changePlugins argument should be either an array or a function');\n  }\n}\nbeforeEach(() => {\n  plugins = [...defaultPlugins];\n});\n\nfunction parse(code) {\n  if (parserName === undefined) {\n    throw new Error('No parser specified');\n  }\n\n  if (parserName === 'babel') {\n    try {\n      return babelParser.parse(code, {\n        plugins,\n        sourceFilename: 'test.js'\n      });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn(`Failed to parse with ${fallbackToBabylon ? 'babylon' : 'Babel'} parser.`);\n    }\n  }\n\n  if (parserName === 'flow') {\n    try {\n      return flowParser.parse(code, {\n        plugins\n      });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to parse with the Flow parser');\n    }\n  }\n\n  throw new Error(`The parser ${parserName} is not yet supported for testing.`);\n}\n\nexport function getOpeningElement(code) {\n  const parsedCode = parse(code);\n  let body;\n\n  if (parsedCode.program) {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.program.body;\n  } else {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.body;\n  }\n\n  if (Array.isArray(body) && body[0] != null) {\n    return body[0].expression.openingElement;\n  }\n\n  return null;\n}\nexport function extractProp(code, prop = 'foo') {\n  const node = getOpeningElement(code);\n  const {\n    attributes: props\n  } = node;\n  return getProp(props, prop);\n}\nexport const describeIfNotBabylon = fallbackToBabylon ? describe.skip : describe;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsx-ast-utils/__tests__/helper.js"],"names":["getProp","nodeVersion","parseInt","process","version","match","fallbackToBabylon","parserName","babelParser","require","flowParser","defaultPlugins","plugins","setParserName","name","changePlugins","pluginOrFn","Array","isArray","Error","beforeEach","parse","code","undefined","sourceFilename","_","console","warn","getOpeningElement","parsedCode","body","program","expression","openingElement","extractProp","prop","node","attributes","props","describeIfNotBabylon","describe","skip"],"mappings":"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","sourcesContent":["/* eslint-env jest */\nimport getProp from '../src/getProp';\n\nconst nodeVersion = parseInt(process.version.match(/^v(\\d+)\\./)[1], 10);\n\nexport const fallbackToBabylon = nodeVersion < 6;\n\nlet parserName;\nconst babelParser = fallbackToBabylon ? require('babylon') : require('@babel/parser');\nconst flowParser = require('flow-parser');\n\nconst defaultPlugins = [\n  'jsx',\n  'functionBind',\n  'estree',\n  'objectRestSpread',\n  'optionalChaining',\n  // 'nullishCoalescing', // TODO: update to babel 7\n];\nlet plugins = [...defaultPlugins];\n\nexport function setParserName(name) {\n  parserName = name;\n}\n\nexport function changePlugins(pluginOrFn) {\n  if (Array.isArray(pluginOrFn)) {\n    plugins = pluginOrFn;\n  } else if (typeof pluginOrFn === 'function') {\n    plugins = pluginOrFn(plugins);\n  } else {\n    throw new Error('changePlugins argument should be either an array or a function');\n  }\n}\n\nbeforeEach(() => {\n  plugins = [...defaultPlugins];\n});\n\nfunction parse(code) {\n  if (parserName === undefined) {\n    throw new Error('No parser specified');\n  }\n  if (parserName === 'babel') {\n    try {\n      return babelParser.parse(code, { plugins, sourceFilename: 'test.js' });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn(`Failed to parse with ${fallbackToBabylon ? 'babylon' : 'Babel'} parser.`);\n    }\n  }\n  if (parserName === 'flow') {\n    try {\n      return flowParser.parse(code, { plugins });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to parse with the Flow parser');\n    }\n  }\n  throw new Error(`The parser ${parserName} is not yet supported for testing.`);\n}\n\nexport function getOpeningElement(code) {\n  const parsedCode = parse(code);\n  let body;\n  if (parsedCode.program) {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.program.body;\n  } else {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.body;\n  }\n  if (Array.isArray(body) && body[0] != null) {\n    return body[0].expression.openingElement;\n  }\n\n  return null;\n}\n\nexport function extractProp(code, prop = 'foo') {\n  const node = getOpeningElement(code);\n  const { attributes: props } = node;\n  return getProp(props, prop);\n}\n\nexport const describeIfNotBabylon = fallbackToBabylon ? describe.skip : describe;\n"]},"metadata":{},"sourceType":"module"}