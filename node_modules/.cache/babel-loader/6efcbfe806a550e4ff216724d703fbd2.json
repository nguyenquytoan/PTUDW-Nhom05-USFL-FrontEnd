{"ast":null,"code":"/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around immediate `function` invocations\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/wrap-iife\"\n    },\n    schema: [{\n      enum: [\"outside\", \"inside\", \"any\"]\n    }, {\n      type: \"object\",\n      properties: {\n        functionPrototypeMethods: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n      wrapExpression: \"Wrap only the function expression in parens.\",\n      moveInvocation: \"Move the invocation into the parens that contain the function.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"outside\";\n    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Check if the node is wrapped in ()\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if it is wrapped\n     * @private\n     */\n\n    function wrapped(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\n     * Get the function node from an IIFE\n     * @param {ASTNode} node node to evaluate\n     * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n     */\n\n\n    function getFunctionNodeFromIIFE(node) {\n      const callee = node.callee;\n\n      if (callee.type === \"FunctionExpression\") {\n        return callee;\n      }\n\n      if (includeFunctionPrototypeMethods && callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")) {\n        return callee.object;\n      }\n\n      return null;\n    }\n\n    return {\n      CallExpression(node) {\n        const innerNode = getFunctionNodeFromIIFE(node);\n\n        if (!innerNode) {\n          return;\n        }\n\n        const callExpressionWrapped = wrapped(node),\n              functionExpressionWrapped = wrapped(innerNode);\n\n        if (!callExpressionWrapped && !functionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapInvocation\",\n\n            fix(fixer) {\n              const nodeToSurround = style === \"inside\" ? innerNode : node;\n              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n            }\n\n          });\n        } else if (style === \"inside\" && !functionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapExpression\",\n\n            fix(fixer) {\n              /*\n               * The outer call expression will always be wrapped at this point.\n               * Replace the range between the end of the function expression and the end of the call expression.\n               * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n               * Replace the parens from the outer expression, and parenthesize the function expression.\n               */\n              const parenAfter = sourceCode.getTokenAfter(node);\n              return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);\n            }\n\n          });\n        } else if (style === \"outside\" && !callExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"moveInvocation\",\n\n            fix(fixer) {\n              /*\n               * The inner function expression will always be wrapped at this point.\n               * It's only necessary to replace the range between the end of the function expression\n               * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n               * should get replaced with `(bar))`.\n               */\n              const parenAfter = sourceCode.getTokenAfter(innerNode);\n              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/wrap-iife.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","properties","functionPrototypeMethods","default","additionalProperties","fixable","messages","wrapInvocation","wrapExpression","moveInvocation","create","context","style","options","includeFunctionPrototypeMethods","sourceCode","getSourceCode","wrapped","node","isParenthesised","getFunctionNodeFromIIFE","callee","object","getStaticPropertyName","CallExpression","innerNode","callExpressionWrapped","functionExpressionWrapped","report","messageId","fix","fixer","nodeToSurround","replaceText","getText","parenAfter","getTokenAfter","replaceTextRange","range","slice"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-iife\"\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n            wrapExpression: \"Wrap only the function expression in parens.\",\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in ()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped\n         * @private\n         */\n        function wrapped(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Get the function node from an IIFE\n         * @param {ASTNode} node node to evaluate\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n         */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = node.callee;\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const callExpressionWrapped = wrapped(node),\n                    functionExpressionWrapped = wrapped(innerNode);\n\n                if (!callExpressionWrapped && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapInvocation\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapExpression\",\n                        fix(fixer) {\n\n                            /*\n                             * The outer call expression will always be wrapped at this point.\n                             * Replace the range between the end of the function expression and the end of the call expression.\n                             * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                             * Replace the parens from the outer expression, and parenthesize the function expression.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(node);\n\n                            return fixer.replaceTextRange(\n                                [innerNode.range[1], parenAfter.range[1]],\n                                `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                            );\n                        }\n                    });\n                } else if (style === \"outside\" && !callExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"moveInvocation\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}