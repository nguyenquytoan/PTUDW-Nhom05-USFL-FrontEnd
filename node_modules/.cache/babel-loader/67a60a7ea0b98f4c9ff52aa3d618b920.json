{"ast":null,"code":"/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst FixTracker = require(\"./utils/fix-tracker\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `else` blocks after `return` statements in `if` statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-else-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowElseIf: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Unnecessary 'else' after 'return'.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether the given names can be safely used to declare block-scoped variables\n     * in the given scope. Name collisions can produce redeclaration syntax errors,\n     * or silently change references and modify behavior of the original code.\n     *\n     * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n     * a function's inner scope, and that the names can be valid identifiers in the given scope.\n     * @param {string[]} names Array of variable names.\n     * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n     * @returns {boolean} True if all names can be safely declared, false otherwise.\n     */\n    function isSafeToDeclare(names, scope) {\n      if (names.length === 0) {\n        return true;\n      }\n\n      const functionScope = scope.variableScope;\n      /*\n       * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n       * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n       * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n       *\n       * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n       */\n\n      const declaredVariables = scope.variables.filter(({\n        defs\n      }) => defs.length > 0);\n\n      if (declaredVariables.some(({\n        name\n      }) => names.includes(name))) {\n        return false;\n      } // Redeclaring a catch variable would also cause a syntax error.\n\n\n      if (scope !== functionScope && scope.upper.type === \"catch\") {\n        if (scope.upper.variables.some(({\n          name\n        }) => names.includes(name))) {\n          return false;\n        }\n      }\n      /*\n       * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n       * However, if the variable was used, declaring a new one with the same name would change references\n       * and modify behavior.\n       */\n\n\n      const usedImplicitVariables = scope.variables.filter(({\n        defs,\n        references\n      }) => defs.length === 0 && references.length > 0);\n\n      if (usedImplicitVariables.some(({\n        name\n      }) => names.includes(name))) {\n        return false;\n      }\n      /*\n       * Declaring a variable with a name that was already used to reference a variable from an upper scope\n       * would change references and modify behavior.\n       */\n\n\n      if (scope.through.some(t => names.includes(t.identifier.name))) {\n        return false;\n      }\n      /*\n       * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n       * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n       *\n       * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n       * function foo() { if (bar) { let a; if (baz) { var a; } } }\n       */\n\n\n      if (scope !== functionScope) {\n        const scopeNodeRange = scope.block.range;\n        const variablesToCheck = functionScope.variables.filter(({\n          name\n        }) => names.includes(name));\n\n        if (variablesToCheck.some(v => v.defs.some(({\n          node: {\n            range\n          }\n        }) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n     * @param {Node} node The 'else' node.\n     * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n     * @returns {boolean} True if it is safe, false otherwise.\n     */\n\n\n    function isSafeFromNameCollisions(node, scope) {\n      if (node.type === \"FunctionDeclaration\") {\n        // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n        return false;\n      }\n\n      if (node.type !== \"BlockStatement\") {\n        return true;\n      }\n\n      const elseBlockScope = scope.childScopes.find(({\n        block\n      }) => block === node);\n\n      if (!elseBlockScope) {\n        // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n        return true;\n      }\n      /*\n       * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n       * only block-scoped variables (such as let and const variables or class and function declarations)\n       * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n       */\n\n\n      const namesToCheck = elseBlockScope.variables.map(({\n        name\n      }) => name);\n      return isSafeToDeclare(namesToCheck, scope);\n    }\n    /**\n     * Display the context report if rule is violated\n     * @param {Node} node The 'else' node\n     * @returns {void}\n     */\n\n\n    function displayReport(node) {\n      const currentScope = context.getScope();\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        fix: fixer => {\n          if (!isSafeFromNameCollisions(node, currentScope)) {\n            return null;\n          }\n\n          const sourceCode = context.getSourceCode();\n          const startToken = sourceCode.getFirstToken(node);\n          const elseToken = sourceCode.getTokenBefore(startToken);\n          const source = sourceCode.getText(node);\n          const lastIfToken = sourceCode.getTokenBefore(elseToken);\n          let fixedSource, firstTokenOfElseBlock;\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n          } else {\n            firstTokenOfElseBlock = startToken;\n          }\n          /*\n           * If the if block does not have curly braces and does not end in a semicolon\n           * and the else block starts with (, [, /, +, ` or -, then it is not\n           * safe to remove the else keyword, because ASI will not add a semicolon\n           * after the if block\n           */\n\n\n          const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n            return null;\n          }\n\n          const endToken = sourceCode.getLastToken(node);\n          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n          if (lastTokenOfElseBlock.value !== \";\") {\n            const nextToken = sourceCode.getTokenAfter(endToken);\n            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n            /*\n             * If the else block contents does not end in a semicolon,\n             * and the else block starts with (, [, /, +, ` or -, then it is not\n             * safe to remove the else block, because ASI will not add a semicolon\n             * after the remaining else block contents\n             */\n\n            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== \"}\") {\n              return null;\n            }\n          }\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            fixedSource = source.slice(1, -1);\n          } else {\n            fixedSource = source;\n          }\n          /*\n           * Extend the replacement range to include the entire\n           * function to avoid conflicting with no-useless-return.\n           * https://github.com/eslint/eslint/issues/8026\n           *\n           * Also, to avoid name collisions between two else blocks.\n           */\n\n\n          return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n        }\n      });\n    }\n    /**\n     * Check to see if the node is a ReturnStatement\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if node is a return\n     */\n\n\n    function checkForReturn(node) {\n      return node.type === \"ReturnStatement\";\n    }\n    /**\n     * Naive return checking, does not iterate through the whole\n     * BlockStatement because we make the assumption that the ReturnStatement\n     * will be the last node in the body of the BlockStatement.\n     * @param {Node} node The consequent/alternate node\n     * @returns {boolean} True if it has a return\n     */\n\n\n    function naiveHasReturn(node) {\n      if (node.type === \"BlockStatement\") {\n        const body = node.body,\n              lastChildNode = body[body.length - 1];\n        return lastChildNode && checkForReturn(lastChildNode);\n      }\n\n      return checkForReturn(node);\n    }\n    /**\n     * Check to see if the node is valid for evaluation,\n     * meaning it has an else.\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if the node is valid\n     */\n\n\n    function hasElse(node) {\n      return node.alternate && node.consequent;\n    }\n    /**\n     * If the consequent is an IfStatement, check to see if it has an else\n     * and both its consequent and alternate path return, meaning this is\n     * a nested case of rule violation.  If-Else not considered currently.\n     * @param {Node} node The consequent node\n     * @returns {boolean} True if this is a nested rule violation\n     */\n\n\n    function checkForIf(node) {\n      return node.type === \"IfStatement\" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n    }\n    /**\n     * Check the consequent/body node to make sure it is not\n     * a ReturnStatement or an IfStatement that returns on both\n     * code paths.\n     * @param {Node} node The consequent or body node\n     * @returns {boolean} `true` if it is a Return/If node that always returns.\n     */\n\n\n    function checkForReturnOrIf(node) {\n      return checkForReturn(node) || checkForIf(node);\n    }\n    /**\n     * Check whether a node returns in every codepath.\n     * @param {Node} node The node to be checked\n     * @returns {boolean} `true` if it returns on every codepath.\n     */\n\n\n    function alwaysReturns(node) {\n      if (node.type === \"BlockStatement\") {\n        // If we have a BlockStatement, check each consequent body node.\n        return node.body.some(checkForReturnOrIf);\n      }\n      /*\n       * If not a block statement, make sure the consequent isn't a\n       * ReturnStatement or an IfStatement with returns on both paths.\n       */\n\n\n      return checkForReturnOrIf(node);\n    }\n    /**\n     * Check the if statement, but don't catch else-if blocks.\n     * @returns {void}\n     * @param {Node} node The node for the if statement to check\n     * @private\n     */\n\n\n    function checkIfWithoutElse(node) {\n      const parent = node.parent;\n      /*\n       * Fixing this would require splitting one statement into two, so no error should\n       * be reported if this node is in a position where only one statement is allowed.\n       */\n\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n\n      const consequents = [];\n      let alternate;\n\n      for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n        if (!currentNode.alternate) {\n          return;\n        }\n\n        consequents.push(currentNode.consequent);\n        alternate = currentNode.alternate;\n      }\n\n      if (consequents.every(alwaysReturns)) {\n        displayReport(alternate);\n      }\n    }\n    /**\n     * Check the if statement\n     * @returns {void}\n     * @param {Node} node The node for the if statement to check\n     * @private\n     */\n\n\n    function checkIfWithElse(node) {\n      const parent = node.parent;\n      /*\n       * Fixing this would require splitting one statement into two, so no error should\n       * be reported if this node is in a position where only one statement is allowed.\n       */\n\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n\n      const alternate = node.alternate;\n\n      if (alternate && alwaysReturns(node.consequent)) {\n        displayReport(alternate);\n      }\n    }\n\n    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false); //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-else-return.js"],"names":["astUtils","require","FixTracker","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowElseIf","default","additionalProperties","fixable","messages","unexpected","create","context","isSafeToDeclare","names","scope","length","functionScope","variableScope","declaredVariables","variables","filter","defs","some","name","includes","upper","usedImplicitVariables","references","through","t","identifier","scopeNodeRange","block","range","variablesToCheck","v","node","isSafeFromNameCollisions","elseBlockScope","childScopes","find","namesToCheck","map","displayReport","currentScope","getScope","report","messageId","fix","fixer","sourceCode","getSourceCode","startToken","getFirstToken","elseToken","getTokenBefore","source","getText","lastIfToken","fixedSource","firstTokenOfElseBlock","value","getTokenAfter","ifBlockMaybeUnsafe","parent","consequent","elseBlockUnsafe","test","endToken","getLastToken","lastTokenOfElseBlock","nextToken","nextTokenUnsafe","nextTokenOnSameLine","loc","start","line","slice","retainEnclosingFunction","replaceTextRange","checkForReturn","naiveHasReturn","body","lastChildNode","hasElse","alternate","checkForIf","checkForReturnOrIf","alwaysReturns","checkIfWithoutElse","STATEMENT_LIST_PARENTS","has","consequents","currentNode","push","every","checkIfWithElse","options"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-else-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowElseIf: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Unnecessary 'else' after 'return'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether the given names can be safely used to declare block-scoped variables\n         * in the given scope. Name collisions can produce redeclaration syntax errors,\n         * or silently change references and modify behavior of the original code.\n         *\n         * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n         * a function's inner scope, and that the names can be valid identifiers in the given scope.\n         * @param {string[]} names Array of variable names.\n         * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n         * @returns {boolean} True if all names can be safely declared, false otherwise.\n         */\n        function isSafeToDeclare(names, scope) {\n\n            if (names.length === 0) {\n                return true;\n            }\n\n            const functionScope = scope.variableScope;\n\n            /*\n             * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n             *\n             * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n             */\n            const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);\n\n            if (declaredVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            // Redeclaring a catch variable would also cause a syntax error.\n            if (scope !== functionScope && scope.upper.type === \"catch\") {\n                if (scope.upper.variables.some(({ name }) => names.includes(name))) {\n                    return false;\n                }\n            }\n\n            /*\n             * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n             * However, if the variable was used, declaring a new one with the same name would change references\n             * and modify behavior.\n             */\n            const usedImplicitVariables = scope.variables.filter(({ defs, references }) =>\n                defs.length === 0 && references.length > 0);\n\n            if (usedImplicitVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            /*\n             * Declaring a variable with a name that was already used to reference a variable from an upper scope\n             * would change references and modify behavior.\n             */\n            if (scope.through.some(t => names.includes(t.identifier.name))) {\n                return false;\n            }\n\n            /*\n             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n             *\n             * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n             * function foo() { if (bar) { let a; if (baz) { var a; } } }\n             */\n            if (scope !== functionScope) {\n                const scopeNodeRange = scope.block.range;\n                const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));\n\n                if (variablesToCheck.some(v => v.defs.some(({ node: { range } }) =>\n                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n\n        /**\n         * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n         * @param {Node} node The 'else' node.\n         * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n         * @returns {boolean} True if it is safe, false otherwise.\n         */\n        function isSafeFromNameCollisions(node, scope) {\n\n            if (node.type === \"FunctionDeclaration\") {\n\n                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n                return false;\n            }\n\n            if (node.type !== \"BlockStatement\") {\n                return true;\n            }\n\n            const elseBlockScope = scope.childScopes.find(({ block }) => block === node);\n\n            if (!elseBlockScope) {\n\n                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n                return true;\n            }\n\n            /*\n             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n             * only block-scoped variables (such as let and const variables or class and function declarations)\n             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n             */\n            const namesToCheck = elseBlockScope.variables.map(({ name }) => name);\n\n            return isSafeToDeclare(namesToCheck, scope);\n        }\n\n        /**\n         * Display the context report if rule is violated\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            const currentScope = context.getScope();\n\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                fix: fixer => {\n\n                    if (!isSafeFromNameCollisions(node, currentScope)) {\n                        return null;\n                    }\n\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    /*\n                     * If the if block does not have curly braces and does not end in a semicolon\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\n                     * safe to remove the else keyword, because ASI will not add a semicolon\n                     * after the if block\n                     */\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        /*\n                         * If the else block contents does not end in a semicolon,\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\n                         * safe to remove the else block, because ASI will not add a semicolon\n                         * after the remaining else block contents\n                         */\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    /*\n                     * Extend the replacement range to include the entire\n                     * function to avoid conflicting with no-useless-return.\n                     * https://github.com/eslint/eslint/issues/8026\n                     *\n                     * Also, to avoid name collisions between two else blocks.\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else.\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent;\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         * @param {Node} node The consequent or body node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n\n        /**\n         * Check the if statement, but don't catch else-if blocks.\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithoutElse(node) {\n            const parent = node.parent;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const consequents = [];\n            let alternate;\n\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n                if (!currentNode.alternate) {\n                    return;\n                }\n                consequents.push(currentNode.consequent);\n                alternate = currentNode.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithElse(node) {\n            const parent = node.parent;\n\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const alternate = node.alternate;\n\n            if (alternate && alwaysReturns(node.consequent)) {\n                displayReport(alternate);\n            }\n        }\n\n        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}