{"ast":null,"code":"/*\n * Element Traversal methods from Juriy Zaytsev (kangax)\n * used to emulate Prototype up/down/previous/next methods\n */\n(function (D) {\n  // TODO: all of this needs tests\n  var match = D.match,\n      select = D.select,\n      root = document.documentElement,\n      // Use the Element Traversal API if available.\n  nextElement = 'nextElementSibling',\n      previousElement = 'previousElementSibling',\n      parentElement = 'parentElement'; // Fall back to the DOM Level 1 API.\n\n  if (!(nextElement in root)) nextElement = 'nextSibling';\n  if (!(previousElement in root)) previousElement = 'previousSibling';\n  if (!(parentElement in root)) parentElement = 'parentNode';\n\n  function walkElements(property, element, expr) {\n    var i = 0,\n        isIndex = typeof expr == 'number';\n\n    if (typeof expr == 'undefined') {\n      isIndex = true;\n      expr = 0;\n    }\n\n    while (element = element[property]) {\n      if (element.nodeType != 1) continue;\n\n      if (isIndex) {\n        ++i;\n        if (i == expr) return element;\n      } else if (match(element, expr)) {\n        return element;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @method up\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n\n\n  function up(element, expr) {\n    return walkElements(parentElement, element, expr);\n  }\n  /**\n   * @method next\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n\n\n  function next(element, expr) {\n    return walkElements(nextElement, element, expr);\n  }\n  /**\n   * @method previous\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n\n\n  function previous(element, expr) {\n    return walkElements(previousElement, element, expr);\n  }\n  /**\n   * @method down\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n\n\n  function down(element, expr) {\n    var isIndex = typeof expr == 'number',\n        descendants,\n        index,\n        descendant;\n\n    if (expr === null) {\n      element = element.firstChild;\n\n      while (element && element.nodeType != 1) element = element[nextElement];\n\n      return element;\n    }\n\n    if (!isIndex && match(element, expr) || isIndex && expr === 0) return element;\n    descendants = select('*', element);\n    if (isIndex) return descendants[expr] || null;\n    index = 0;\n\n    while ((descendant = descendants[index]) && !match(descendant, expr)) {\n      ++index;\n    }\n\n    return descendant || null;\n  }\n\n  D.up = up;\n  D.down = down;\n  D.next = next;\n  D.previous = previous;\n})(NW.Dom);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/nwsapi/src/modules/nwsapi-traversal.js"],"names":["D","match","select","root","document","documentElement","nextElement","previousElement","parentElement","walkElements","property","element","expr","i","isIndex","nodeType","up","next","previous","down","descendants","index","descendant","firstChild","NW","Dom"],"mappings":"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","sourcesContent":["/*\n * Element Traversal methods from Juriy Zaytsev (kangax)\n * used to emulate Prototype up/down/previous/next methods\n */\n\n(function(D){\n\n  // TODO: all of this needs tests\n  var match = D.match, select = D.select, root = document.documentElement,\n\n  // Use the Element Traversal API if available.\n  nextElement = 'nextElementSibling',\n  previousElement = 'previousElementSibling',\n  parentElement = 'parentElement';\n\n  // Fall back to the DOM Level 1 API.\n  if (!(nextElement in root)) nextElement = 'nextSibling';\n  if (!(previousElement in root)) previousElement = 'previousSibling';\n  if (!(parentElement in root)) parentElement = 'parentNode';\n\n  function walkElements(property, element, expr) {\n    var i = 0, isIndex = typeof expr == 'number';\n    if (typeof expr == 'undefined') {\n      isIndex = true;\n      expr = 0;\n    }\n    while ((element = element[property])) {\n      if (element.nodeType != 1) continue;\n      if (isIndex) {\n        ++i;\n        if (i == expr) return element;\n      } else if (match(element, expr)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @method up\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n  function up(element, expr) {\n    return walkElements(parentElement, element, expr);\n  }\n  /**\n   * @method next\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n  function next(element, expr) {\n    return walkElements(nextElement, element, expr);\n  }\n  /**\n   * @method previous\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n  function previous(element, expr) {\n    return walkElements(previousElement, element, expr);\n  }\n  /**\n   * @method down\n   * @param {HTMLElement} element element to walk from\n   * @param {String | Number} expr CSS expression or an index\n   * @return {HTMLElement | null}\n   */\n  function down(element, expr) {\n    var isIndex = typeof expr == 'number', descendants, index, descendant;\n    if (expr === null) {\n      element = element.firstChild;\n      while (element && element.nodeType != 1) element = element[nextElement];\n      return element;\n    }\n    if (!isIndex && match(element, expr) || isIndex && expr === 0) return element;\n    descendants = select('*', element);\n    if (isIndex) return descendants[expr] || null;\n    index = 0;\n    while ((descendant = descendants[index]) && !match(descendant, expr)) { ++index; }\n    return descendant || null;\n  }\n  D.up = up;\n  D.down = down;\n  D.next = next;\n  D.previous = previous;\n})(NW.Dom);\n"]},"metadata":{},"sourceType":"script"}