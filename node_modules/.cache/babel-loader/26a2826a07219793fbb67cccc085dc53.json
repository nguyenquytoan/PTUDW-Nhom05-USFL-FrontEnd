{"ast":null,"code":"'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\n\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\n\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        const lineStart = offset + 1;\n        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n} // Published as 'yaml/parse-cst'\n\n\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/yaml/dist/parse-cst.js"],"names":["PlainValue","require","BlankLine","Node","constructor","Type","BLANK_LINE","includesTrailingLines","parse","context","start","range","Range","CollectionItem","type","props","node","parseNode","src","atLineStart","lineStart","SEQ_ITEM","error","YAMLSemanticError","indent","offset","endOfWhiteSpace","ch","inlineComment","comments","blankLine","end","endOfLine","push","wsEnd","length","endOfIndent","nextNodeIsIndented","inCollection","parent","items","contents","Array","prototype","apply","c","valueRange","setOrigRanges","cr","toString","value","str","slice","String","addStringTerminator","Comment","COMMENT","parseComment","grabCollectionEndComments","cnode","Collection","len","ci","i","n","ca","splice","prevEnd","nextContentHasIndent","firstItem","SEQ","MAP","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","comment","atBlank","next","msg","YAMLSyntaxError","ls","prev","forEach","item","Directive","DIRECTIVE","name","parameters","raw","rawValue","trim","split","parseName","parseParameters","Document","startCommentOrEndBlankLine","DOCUMENT","directives","directivesEndMarker","documentEndMarker","parseDirectives","hasDirectives","atDocumentBoundary","Char","DIRECTIVES_END","directive","parseContents","DOCUMENT_END","iEnd","inFlow","undefined","root","charCodeAt","setOrigRange","join","Alias","endOfIdentifier","Chomp","CLIP","KEEP","STRIP","BlockValue","blockIndent","chomping","header","strValue","isEmpty","lastNewLine","keepStart","bi","folded","BLOCK_FOLDED","atStart","sep","prevMoreIndented","j","lineEnd","line","parseBlockHeader","Number","parseBlockValue","explicit","valueEnd","minBlockIndent","endOfBlockIndent","lineIndent","FlowCollection","prevNodeIsJsonLike","idx","jsonLike","char","origOffset","nodes","filter","prefix","QuoteDouble","endOfQuote","errors","fold","foldNewline","parseCharCode","substr","wsStart","cc","ok","test","code","parseInt","NaN","isNaN","fromCodePoint","QuoteSingle","createNewNode","ALIAS","BLOCK_LITERAL","FLOW_MAP","FLOW_SEQ","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","ParseContext","parseType","orig","_defineProperty","overlay","valueStart","parseProps","Error","parseEnd","source","nodeStartsCollection","collection","lineHasProps","ANCHOR","TAG","inEnd","indentDiff","noIndicatorAsIndent","indexOf","replace","match","documents","doc","crOffset","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        const lineStart = offset + 1;\n        const inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (!PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n"]},"metadata":{},"sourceType":"script"}