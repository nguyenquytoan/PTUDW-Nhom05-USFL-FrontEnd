{"ast":null,"code":"// Generated by LiveScript 1.2.0\n(function () {\n  var reject, special, tokenRegex;\n  reject = require('prelude-ls').reject;\n\n  function consumeOp(tokens, op) {\n    if (tokens[0] === op) {\n      return tokens.shift();\n    } else {\n      throw new Error(\"Expected '\" + op + \"', but got '\" + tokens[0] + \"' instead in \" + JSON.stringify(tokens) + \".\");\n    }\n  }\n\n  function maybeConsumeOp(tokens, op) {\n    if (tokens[0] === op) {\n      return tokens.shift();\n    }\n  }\n\n  function consumeList(tokens, delimiters, hasDelimiters) {\n    var result;\n\n    if (hasDelimiters) {\n      consumeOp(tokens, delimiters[0]);\n    }\n\n    result = [];\n\n    while (tokens.length && tokens[0] !== delimiters[1]) {\n      result.push(consumeElement(tokens));\n      maybeConsumeOp(tokens, ',');\n    }\n\n    if (hasDelimiters) {\n      consumeOp(tokens, delimiters[1]);\n    }\n\n    return result;\n  }\n\n  function consumeArray(tokens, hasDelimiters) {\n    return consumeList(tokens, ['[', ']'], hasDelimiters);\n  }\n\n  function consumeTuple(tokens, hasDelimiters) {\n    return consumeList(tokens, ['(', ')'], hasDelimiters);\n  }\n\n  function consumeFields(tokens, hasDelimiters) {\n    var result, key;\n\n    if (hasDelimiters) {\n      consumeOp(tokens, '{');\n    }\n\n    result = {};\n\n    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {\n      key = tokens.shift();\n      consumeOp(tokens, ':');\n      result[key] = consumeElement(tokens);\n      maybeConsumeOp(tokens, ',');\n    }\n\n    if (hasDelimiters) {\n      consumeOp(tokens, '}');\n    }\n\n    return result;\n  }\n\n  function consumeElement(tokens) {\n    switch (tokens[0]) {\n      case '[':\n        return consumeArray(tokens, true);\n\n      case '(':\n        return consumeTuple(tokens, true);\n\n      case '{':\n        return consumeFields(tokens, true);\n\n      default:\n        return tokens.shift();\n    }\n  }\n\n  function consumeTopLevel(tokens, types) {\n    var ref$, type, structure, origTokens, result, finalResult, x$, y$;\n    ref$ = types[0], type = ref$.type, structure = ref$.structure;\n    origTokens = tokens.concat();\n\n    if (types.length === 1 && (structure || type === 'Array' || type === 'Object')) {\n      result = structure === 'array' || type === 'Array' ? consumeArray(tokens, tokens[0] === '[') : structure === 'tuple' ? consumeTuple(tokens, tokens[0] === '(') : consumeFields(tokens, tokens[0] === '{');\n      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array' ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$) : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;\n    } else {\n      finalResult = consumeElement(tokens);\n    }\n\n    if (tokens.length && origTokens.length) {\n      throw new Error(\"Unable to parse \" + JSON.stringify(origTokens) + \" of type \" + JSON.stringify(types) + \".\");\n    } else {\n      return finalResult;\n    }\n  }\n\n  special = /\\[\\]\\(\\)}{:,/.source;\n  tokenRegex = RegExp('(\"(?:[^\"]|\\\\\\\\\")*\")|(\\'(?:[^\\']|\\\\\\\\\\')*\\')|(#.*#)|(/(?:\\\\\\\\/|[^/])*/[gimy]*)|([' + special + '])|([^\\\\s' + special + ']+)|\\\\s*');\n\n  module.exports = function (string, types) {\n    var tokens, node;\n    tokens = reject(function (it) {\n      return !it || /^\\s+$/.test(it);\n    }, string.split(tokenRegex));\n    node = consumeTopLevel(tokens, types);\n\n    if (!node) {\n      throw new Error(\"Error parsing '\" + string + \"'.\");\n    }\n\n    return node;\n  };\n}).call(this);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/levn/lib/parse.js"],"names":["reject","special","tokenRegex","require","consumeOp","tokens","op","shift","Error","JSON","stringify","maybeConsumeOp","consumeList","delimiters","hasDelimiters","result","length","push","consumeElement","consumeArray","consumeTuple","consumeFields","key","consumeTopLevel","types","ref$","type","structure","origTokens","finalResult","x$","y$","concat","unshift","source","RegExp","module","exports","string","node","it","test","split","call"],"mappings":"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","sourcesContent":["// Generated by LiveScript 1.2.0\n(function(){\n  var reject, special, tokenRegex;\n  reject = require('prelude-ls').reject;\n  function consumeOp(tokens, op){\n    if (tokens[0] === op) {\n      return tokens.shift();\n    } else {\n      throw new Error(\"Expected '\" + op + \"', but got '\" + tokens[0] + \"' instead in \" + JSON.stringify(tokens) + \".\");\n    }\n  }\n  function maybeConsumeOp(tokens, op){\n    if (tokens[0] === op) {\n      return tokens.shift();\n    }\n  }\n  function consumeList(tokens, delimiters, hasDelimiters){\n    var result;\n    if (hasDelimiters) {\n      consumeOp(tokens, delimiters[0]);\n    }\n    result = [];\n    while (tokens.length && tokens[0] !== delimiters[1]) {\n      result.push(consumeElement(tokens));\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, delimiters[1]);\n    }\n    return result;\n  }\n  function consumeArray(tokens, hasDelimiters){\n    return consumeList(tokens, ['[', ']'], hasDelimiters);\n  }\n  function consumeTuple(tokens, hasDelimiters){\n    return consumeList(tokens, ['(', ')'], hasDelimiters);\n  }\n  function consumeFields(tokens, hasDelimiters){\n    var result, key;\n    if (hasDelimiters) {\n      consumeOp(tokens, '{');\n    }\n    result = {};\n    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {\n      key = tokens.shift();\n      consumeOp(tokens, ':');\n      result[key] = consumeElement(tokens);\n      maybeConsumeOp(tokens, ',');\n    }\n    if (hasDelimiters) {\n      consumeOp(tokens, '}');\n    }\n    return result;\n  }\n  function consumeElement(tokens){\n    switch (tokens[0]) {\n    case '[':\n      return consumeArray(tokens, true);\n    case '(':\n      return consumeTuple(tokens, true);\n    case '{':\n      return consumeFields(tokens, true);\n    default:\n      return tokens.shift();\n    }\n  }\n  function consumeTopLevel(tokens, types){\n    var ref$, type, structure, origTokens, result, finalResult, x$, y$;\n    ref$ = types[0], type = ref$.type, structure = ref$.structure;\n    origTokens = tokens.concat();\n    if (types.length === 1 && (structure || (type === 'Array' || type === 'Object'))) {\n      result = structure === 'array' || type === 'Array'\n        ? consumeArray(tokens, tokens[0] === '[')\n        : structure === 'tuple'\n          ? consumeTuple(tokens, tokens[0] === '(')\n          : consumeFields(tokens, tokens[0] === '{');\n      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array'\n        ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$)\n        : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;\n    } else {\n      finalResult = consumeElement(tokens);\n    }\n    if (tokens.length && origTokens.length) {\n      throw new Error(\"Unable to parse \" + JSON.stringify(origTokens) + \" of type \" + JSON.stringify(types) + \".\");\n    } else {\n      return finalResult;\n    }\n  }\n  special = /\\[\\]\\(\\)}{:,/.source;\n  tokenRegex = RegExp('(\"(?:[^\"]|\\\\\\\\\")*\")|(\\'(?:[^\\']|\\\\\\\\\\')*\\')|(#.*#)|(/(?:\\\\\\\\/|[^/])*/[gimy]*)|([' + special + '])|([^\\\\s' + special + ']+)|\\\\s*');\n  module.exports = function(string, types){\n    var tokens, node;\n    tokens = reject(function(it){\n      return !it || /^\\s+$/.test(it);\n    }, string.split(tokenRegex));\n    node = consumeTopLevel(tokens, types);\n    if (!node) {\n      throw new Error(\"Error parsing '\" + string + \"'.\");\n    }\n    return node;\n  };\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}