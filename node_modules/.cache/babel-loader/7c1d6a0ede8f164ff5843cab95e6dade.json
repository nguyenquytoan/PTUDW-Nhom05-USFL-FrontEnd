{"ast":null,"code":"/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/linebreak-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"unix\", \"windows\"]\n    }],\n    messages: {\n      expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n      expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Builds a fix function that replaces text at the specified range in the source text.\n     * @param {int[]} range The range to replace\n     * @param {string} text The text to insert.\n     * @returns {Function} Fixer function\n     * @private\n     */\n\n    function createFix(range, text) {\n      return function (fixer) {\n        return fixer.replaceTextRange(range, text);\n      };\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkForlinebreakStyle(node) {\n        const linebreakStyle = context.options[0] || \"unix\",\n              expectedLF = linebreakStyle === \"unix\",\n              expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n              source = sourceCode.getText(),\n              pattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n        let i = 0;\n\n        while ((match = pattern.exec(source)) !== null) {\n          i++;\n\n          if (match[0] === expectedLFChars) {\n            continue;\n          }\n\n          const index = match.index;\n          const range = [index, index + match[0].length];\n          context.report({\n            node,\n            loc: {\n              line: i,\n              column: sourceCode.lines[i - 1].length\n            },\n            messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n            fix: createFix(range, expectedLFChars)\n          });\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/linebreak-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expectedLF","expectedCRLF","create","context","sourceCode","getSourceCode","createFix","range","text","fixer","replaceTextRange","Program","checkForlinebreakStyle","node","linebreakStyle","options","expectedLFChars","source","getText","pattern","createGlobalLinebreakMatcher","match","i","exec","index","length","report","loc","line","column","lines","messageId","fix"],"mappings":"AAAA;;;;AAKA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,oCADX;AAEFC,MAAAA,QAAQ,EAAE,kBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,OAAO,EAAE,YAVP;AAYFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,MAAD,EAAS,SAAT;AADV,KADI,CAZN;AAiBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,UAAU,EAAE,kDADN;AAENC,MAAAA,YAAY,EAAE;AAFR;AAjBR,GADO;;AAwBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB,CADY,CAGZ;AACA;AACA;;AAEA;;;;;;;;AAOA,aAASC,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgC;AAC5B,aAAO,UAASC,KAAT,EAAgB;AACnB,eAAOA,KAAK,CAACC,gBAAN,CAAuBH,KAAvB,EAA8BC,IAA9B,CAAP;AACH,OAFD;AAGH,KAlBW,CAoBZ;AACA;AACA;;;AAEA,WAAO;AACHG,MAAAA,OAAO,EAAE,SAASC,sBAAT,CAAgCC,IAAhC,EAAsC;AAC3C,cAAMC,cAAc,GAAGX,OAAO,CAACY,OAAR,CAAgB,CAAhB,KAAsB,MAA7C;AAAA,cACIf,UAAU,GAAGc,cAAc,KAAK,MADpC;AAAA,cAEIE,eAAe,GAAGhB,UAAU,GAAG,IAAH,GAAU,MAF1C;AAAA,cAGIiB,MAAM,GAAGb,UAAU,CAACc,OAAX,EAHb;AAAA,cAIIC,OAAO,GAAGlC,QAAQ,CAACmC,4BAAT,EAJd;AAKA,YAAIC,KAAJ;AAEA,YAAIC,CAAC,GAAG,CAAR;;AAEA,eAAO,CAACD,KAAK,GAAGF,OAAO,CAACI,IAAR,CAAaN,MAAb,CAAT,MAAmC,IAA1C,EAAgD;AAC5CK,UAAAA,CAAC;;AACD,cAAID,KAAK,CAAC,CAAD,CAAL,KAAaL,eAAjB,EAAkC;AAC9B;AACH;;AAED,gBAAMQ,KAAK,GAAGH,KAAK,CAACG,KAApB;AACA,gBAAMjB,KAAK,GAAG,CAACiB,KAAD,EAAQA,KAAK,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASI,MAAzB,CAAd;AAEAtB,UAAAA,OAAO,CAACuB,MAAR,CAAe;AACXb,YAAAA,IADW;AAEXc,YAAAA,GAAG,EAAE;AACDC,cAAAA,IAAI,EAAEN,CADL;AAEDO,cAAAA,MAAM,EAAEzB,UAAU,CAAC0B,KAAX,CAAiBR,CAAC,GAAG,CAArB,EAAwBG;AAF/B,aAFM;AAMXM,YAAAA,SAAS,EAAE/B,UAAU,GAAG,YAAH,GAAkB,cAN5B;AAOXgC,YAAAA,GAAG,EAAE1B,SAAS,CAACC,KAAD,EAAQS,eAAR;AAPH,WAAf;AASH;AACJ;AA9BE,KAAP;AAgCH;;AAhFY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/linebreak-style\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"unix\", \"windows\"]\n            }\n        ],\n        messages: {\n            expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n            expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Builds a fix function that replaces text at the specified range in the source text.\n         * @param {int[]} range The range to replace\n         * @param {string} text The text to insert.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function createFix(range, text) {\n            return function(fixer) {\n                return fixer.replaceTextRange(range, text);\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkForlinebreakStyle(node) {\n                const linebreakStyle = context.options[0] || \"unix\",\n                    expectedLF = linebreakStyle === \"unix\",\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n                    source = sourceCode.getText(),\n                    pattern = astUtils.createGlobalLinebreakMatcher();\n                let match;\n\n                let i = 0;\n\n                while ((match = pattern.exec(source)) !== null) {\n                    i++;\n                    if (match[0] === expectedLFChars) {\n                        continue;\n                    }\n\n                    const index = match.index;\n                    const range = [index, index + match[0].length];\n\n                    context.report({\n                        node,\n                        loc: {\n                            line: i,\n                            column: sourceCode.lines[i - 1].length\n                        },\n                        messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n                        fix: createFix(range, expectedLFChars)\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}