{"ast":null,"code":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n  type: \"array\",\n  items: {\n    type: \"string\"\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `import`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStrings\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n\n  create(context) {\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n\n      return memo;\n    }, {}); // if no imports are restricted we don\"t need to check\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n      return {};\n    }\n\n    const restrictedPatternsMatcher = ignore().add(restrictedPatterns);\n    /**\n     * Checks to see if \"*\" is being used to import everything.\n     * @param {Set.<string>} importNames Set of import names that are being imported\n     * @returns {boolean} whether everything is imported or not\n     */\n\n    function isEverythingImported(importNames) {\n      return importNames.has(\"*\");\n    }\n    /**\n     * Report a restricted path.\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n\n\n    function reportPath(node) {\n      const importSource = node.source.value.trim();\n      const customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;\n      context.report({\n        node,\n        messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n        data: {\n          importSource,\n          customMessage\n        }\n      });\n    }\n    /**\n     * Report a restricted path specifically for patterns.\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n\n\n    function reportPathForPatterns(node) {\n      const importSource = node.source.value.trim();\n      context.report({\n        node,\n        messageId: \"patterns\",\n        data: {\n          importSource\n        }\n      });\n    }\n    /**\n     * Report a restricted path specifically when using the '*' import.\n     * @param {string} importSource path of the import\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n\n\n    function reportPathForEverythingImported(importSource, node) {\n      const importNames = restrictedPathMessages[importSource].importNames;\n      const customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;\n      context.report({\n        node,\n        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n        data: {\n          importSource,\n          importNames,\n          customMessage\n        }\n      });\n    }\n    /**\n     * Check if the given importSource is restricted because '*' is being imported.\n     * @param {string} importSource path of the import\n     * @param {Set.<string>} importNames Set of import names that are being imported\n     * @returns {boolean} whether the path is restricted\n     * @private\n     */\n\n\n    function isRestrictedForEverythingImported(importSource, importNames) {\n      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) && restrictedPathMessages[importSource].importNames && isEverythingImported(importNames);\n    }\n    /**\n     * Check if the given importNames are restricted given a list of restrictedImportNames.\n     * @param {Set.<string>} importNames Set of import names that are being imported\n     * @param {string[]} restrictedImportNames array of import names that are restricted for this import\n     * @returns {boolean} whether the objectName is restricted\n     * @private\n     */\n\n\n    function isRestrictedObject(importNames, restrictedImportNames) {\n      return restrictedImportNames.some(restrictedObjectName => importNames.has(restrictedObjectName));\n    }\n    /**\n     * Check if the given importSource is a restricted path.\n     * @param {string} importSource path of the import\n     * @param {Set.<string>} importNames Set of import names that are being imported\n     * @returns {boolean} whether the variable is a restricted path or not\n     * @private\n     */\n\n\n    function isRestrictedPath(importSource, importNames) {\n      let isRestricted = false;\n\n      if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        if (restrictedPathMessages[importSource].importNames) {\n          isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);\n        } else {\n          isRestricted = true;\n        }\n      }\n\n      return isRestricted;\n    }\n    /**\n     * Check if the given importSource is restricted by a pattern.\n     * @param {string} importSource path of the import\n     * @returns {boolean} whether the variable is a restricted pattern or not\n     * @private\n     */\n\n\n    function isRestrictedPattern(importSource) {\n      return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);\n    }\n    /**\n     * Checks a node to see if any problems should be reported.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = node.specifiers ? node.specifiers.reduce((set, specifier) => {\n        if (specifier.type === \"ImportDefaultSpecifier\") {\n          set.add(\"default\");\n        } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n          set.add(\"*\");\n        } else if (specifier.imported) {\n          set.add(specifier.imported.name);\n        } else if (specifier.local) {\n          set.add(specifier.local.name);\n        }\n\n        return set;\n      }, new Set()) : new Set();\n\n      if (isRestrictedForEverythingImported(importSource, importNames)) {\n        reportPathForEverythingImported(importSource, node);\n      }\n\n      if (isRestrictedPath(importSource, importNames)) {\n        reportPath(node);\n      }\n\n      if (isRestrictedPattern(importSource)) {\n        reportPathForPatterns(node);\n      }\n    }\n\n    return {\n      ImportDeclaration: checkNode,\n\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n\n      ExportAllDeclaration: checkNode\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-restricted-imports.js"],"names":["ignore","require","arrayOfStrings","type","items","uniqueItems","arrayOfStringsOrObjects","anyOf","properties","name","message","minLength","importNames","additionalProperties","required","module","exports","meta","docs","description","category","recommended","url","messages","path","pathWithCustomMessage","patterns","everything","everythingWithCustomMessage","schema","paths","additionalItems","create","context","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPatterns","restrictedPathMessages","reduce","memo","importSource","keys","length","restrictedPatternsMatcher","add","isEverythingImported","has","reportPath","node","source","value","trim","customMessage","report","messageId","data","reportPathForPatterns","reportPathForEverythingImported","isRestrictedForEverythingImported","isRestrictedObject","restrictedImportNames","some","restrictedObjectName","isRestrictedPath","isRestricted","isRestrictedPattern","ignores","checkNode","specifiers","set","specifier","imported","local","Set","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const restrictedPatternsMatcher = ignore().add(restrictedPatterns);\n\n        /**\n         * Checks to see if \"*\" is being used to import everything.\n         * @param {Set.<string>} importNames Set of import names that are being imported\n         * @returns {boolean} whether everything is imported or not\n         */\n        function isEverythingImported(importNames) {\n            return importNames.has(\"*\");\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPath(node) {\n            const importSource = node.source.value.trim();\n            const customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;\n\n            context.report({\n                node,\n                messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                data: {\n                    importSource,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node) {\n            const importSource = node.source.value.trim();\n\n            context.report({\n                node,\n                messageId: \"patterns\",\n                data: {\n                    importSource\n                }\n            });\n        }\n\n        /**\n         * Report a restricted path specifically when using the '*' import.\n         * @param {string} importSource path of the import\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPathForEverythingImported(importSource, node) {\n            const importNames = restrictedPathMessages[importSource].importNames;\n            const customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;\n\n            context.report({\n                node,\n                messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                data: {\n                    importSource,\n                    importNames,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted because '*' is being imported.\n         * @param {string} importSource path of the import\n         * @param {Set.<string>} importNames Set of import names that are being imported\n         * @returns {boolean} whether the path is restricted\n         * @private\n         */\n        function isRestrictedForEverythingImported(importSource, importNames) {\n            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) &&\n                restrictedPathMessages[importSource].importNames &&\n                isEverythingImported(importNames);\n        }\n\n        /**\n         * Check if the given importNames are restricted given a list of restrictedImportNames.\n         * @param {Set.<string>} importNames Set of import names that are being imported\n         * @param {string[]} restrictedImportNames array of import names that are restricted for this import\n         * @returns {boolean} whether the objectName is restricted\n         * @private\n         */\n        function isRestrictedObject(importNames, restrictedImportNames) {\n            return restrictedImportNames.some(restrictedObjectName => (\n                importNames.has(restrictedObjectName)\n            ));\n        }\n\n        /**\n         * Check if the given importSource is a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Set.<string>} importNames Set of import names that are being imported\n         * @returns {boolean} whether the variable is a restricted path or not\n         * @private\n         */\n        function isRestrictedPath(importSource, importNames) {\n            let isRestricted = false;\n\n            if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                if (restrictedPathMessages[importSource].importNames) {\n                    isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);\n                } else {\n                    isRestricted = true;\n                }\n            }\n\n            return isRestricted;\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource) {\n            return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = node.specifiers ? node.specifiers.reduce((set, specifier) => {\n                if (specifier.type === \"ImportDefaultSpecifier\") {\n                    set.add(\"default\");\n                } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                    set.add(\"*\");\n                } else if (specifier.imported) {\n                    set.add(specifier.imported.name);\n                } else if (specifier.local) {\n                    set.add(specifier.local.name);\n                }\n                return set;\n            }, new Set()) : new Set();\n\n            if (isRestrictedForEverythingImported(importSource, importNames)) {\n                reportPathForEverythingImported(importSource, node);\n            }\n\n            if (isRestrictedPath(importSource, importNames)) {\n                reportPath(node);\n            }\n            if (isRestrictedPattern(importSource)) {\n                reportPathForPatterns(node);\n            }\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}