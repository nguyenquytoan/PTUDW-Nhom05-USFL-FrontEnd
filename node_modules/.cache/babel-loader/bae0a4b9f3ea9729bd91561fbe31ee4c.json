{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nconst {\n  simultaneousIterators\n} = require(\"../../utils\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst {\n  clone,\n  locateNamespacePrefix,\n  locateNamespace\n} = require(\"../node\");\n\nconst attributes = require(\"../attributes\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\n\nconst {\n  queueTreeMutationRecord\n} = require(\"../helpers/mutation-observers\");\n\nconst {\n  isShadowRoot,\n  getRoot,\n  shadowIncludingRoot,\n  assignSlot,\n  assignSlotableForTree,\n  assignSlotable,\n  signalSlotChange,\n  isSlot\n} = require(\"../helpers/shadow-dom\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE || //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n  node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n} // https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\n\n\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n\n  const rootImplB = getRoot(nodeImplB);\n\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n    domSymbolTree.initialize(this);\n    this._ownerDocument = privateData.ownerDocument;\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n  }\n\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n\n    return domSymbolTree.parent(this);\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : getRoot(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    } // should never happen\n\n\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  } // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n\n\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl([], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  _modified() {\n    this._version++;\n\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {// Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      } // Normalize should only transform Text nodes, and nothing else.\n\n\n      if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      if (child.nodeValue === \"\") {\n        this._remove(child);\n\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n\n        this._remove(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl); // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          return locateNamespacePrefix(this, namespace);\n        }\n\n      case NODE_TYPE.DOCUMENT_NODE:\n        {\n          return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n        }\n\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        {\n          return null;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n        }\n\n      default:\n        {\n          return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n        }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    } // Fast-path, not in the spec\n\n\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw new DOMException(\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\");\n    }\n\n    deep = Boolean(deep);\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          attributes.setAnExistingAttributeValue(this, value);\n          break;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let text = \"\";\n\n          for (const child of domSymbolTree.treeIterator(this)) {\n            if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n              text += child.nodeValue;\n            }\n          }\n\n          return text;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n\n  set textContent(value) {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let nodeImpl = null;\n\n          if (value !== null && value !== \"\") {\n            nodeImpl = this._ownerDocument.createTextNode(value);\n          }\n\n          this._replaceAll(nodeImpl);\n\n          break;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          attributes.setAnExistingAttributeValue(this, value);\n          break;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  } // https://dom.spec.whatwg.org/#dom-node-insertbefore\n\n\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  } // https://dom.spec.whatwg.org/#dom-node-appendchild\n\n\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  } // https://dom.spec.whatwg.org/#dom-node-replacechild\n\n\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  } // https://dom.spec.whatwg.org/#dom-node-removechild\n\n\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  } // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n\n\n  _preInsertValidity(nodeImpl, childImpl) {\n    const {\n      nodeType,\n      nodeName\n    } = nodeImpl;\n    const {\n      nodeType: parentType,\n      nodeName: parentName\n    } = this;\n\n    if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n      throw new DOMException(`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw new DOMException(\"The child can not be found in the parent.\", \"NotFoundError\");\n    }\n\n    if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n    nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n      throw new DOMException(`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\");\n    }\n\n    if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n\n            if (nodeChildrenElements.length > 1) {\n              throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n            }\n\n            const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n\n            if (hasNodeTextChildren) {\n              throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n            }\n\n            if (nodeChildrenElements.length === 1 && (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n              throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n            }\n\n            break;\n          }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n            throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n          }\n\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE || !childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE)) {\n            throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n          }\n\n          break;\n      }\n    }\n  } // https://dom.spec.whatwg.org/#concept-node-pre-insert\n\n\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n\n    let referenceChildImpl = childImpl;\n\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    this._insert(nodeImpl, referenceChildImpl);\n\n    return nodeImpl;\n  } // https://dom.spec.whatwg.org/#concept-node-insert\n\n\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n\n      while (grandChildImpl = domSymbolTree.firstChild(nodeImpl)) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n\n    const previousChildImpl = childImpl ? domSymbolTree.previousSibling(childImpl) : domSymbolTree.lastChild(this);\n\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n\n      if (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null && (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)) {\n        assignSlot(node);\n      }\n\n      this._modified();\n\n      if (node.nodeType === NODE_TYPE.TEXT_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(getRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      const root = getRoot(node);\n\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n\n      this._descendantAdded(this, node);\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  } // https://dom.spec.whatwg.org/#concept-node-append\n\n\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  } // https://dom.spec.whatwg.org/#concept-node-replace\n\n\n  _replace(nodeImpl, childImpl) {\n    const {\n      nodeType,\n      nodeName\n    } = nodeImpl;\n    const {\n      nodeType: parentType,\n      nodeName: parentName\n    } = this; // Note: This section differs from the pre-insert validation algorithm.\n\n    if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n      throw new DOMException(`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw new DOMException(\"The child can not be found in the parent.\", \"NotFoundError\");\n    }\n\n    if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n    nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n      throw new DOMException(`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\");\n    }\n\n    if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n\n            if (nodeChildrenElements.length > 1) {\n              throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n            }\n\n            const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n\n            if (hasNodeTextChildren) {\n              throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n            }\n\n            const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n\n            if (nodeChildrenElements.length === 1 && (parentChildElements.length === 1 && parentChildElements[0] !== childImpl || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n              throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n            }\n\n            break;\n          }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n            throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n          }\n\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE) {\n            throw new DOMException(`Invalid insertion of ${nodeName} node in ${parentName} node.`, \"HierarchyRequestError\");\n          }\n\n          break;\n      }\n    }\n\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    let removedNodesImpl = [];\n\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n\n      this._remove(childImpl, true);\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n    this._insert(nodeImpl, referenceChildImpl, true);\n\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n    return childImpl;\n  } // https://dom.spec.whatwg.org/#concept-node-replace-all\n\n\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n    let addedNodesImpl;\n\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n\n    if (nodeImpl) {\n      this._insert(nodeImpl, null, true);\n    }\n\n    queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n  } // https://dom.spec.whatwg.org/#concept-node-pre-remove\n\n\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw new DOMException(\"The node to be removed is not a child of this node.\", \"NotFoundError\");\n    }\n\n    this._remove(childImpl);\n\n    return childImpl;\n  } // https://dom.spec.whatwg.org/#concept-node-remove\n\n\n  _remove(nodeImpl, suppressObservers) {\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n    domSymbolTree.remove(nodeImpl);\n\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(getRoot(this))) {\n      signalSlotChange(this);\n    }\n\n    let hasSlotDescendant = isSlot(nodeImpl);\n\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n\n    if (hasSlotDescendant) {\n      assignSlotableForTree(getRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n\n    this._modified();\n\n    nodeImpl._detach();\n\n    this._descendantRemoved(this, nodeImpl);\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-environment-jsdom-fourteen/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js"],"names":["DOMException","require","EventTargetImpl","implementation","simultaneousIterators","NODE_TYPE","NODE_DOCUMENT_POSITION","NodeList","clone","locateNamespacePrefix","locateNamespace","attributes","domSymbolTree","documentBaseURLSerialized","queueTreeMutationRecord","isShadowRoot","getRoot","shadowIncludingRoot","assignSlot","assignSlotableForTree","assignSlotable","signalSlotChange","isSlot","isObsoleteNodeType","node","nodeType","ENTITY_NODE","ENTITY_REFERENCE_NODE","NOTATION_NODE","CDATA_SECTION_NODE","nodeEquals","a","b","DOCUMENT_TYPE_NODE","name","publicId","systemId","ELEMENT_NODE","_namespaceURI","_prefix","_localName","_attributes","length","PROCESSING_INSTRUCTION_NODE","_target","_data","TEXT_NODE","COMMENT_NODE","attributeListsEqual","nodes","childrenIterator","isHostInclusiveAncestor","nodeImplA","nodeImplB","ancestor","ancestorsIterator","rootImplB","_host","NodeImpl","constructor","args","privateData","initialize","_ownerDocument","ownerDocument","_childNodesList","_childrenList","_version","_memoizedQueries","_registeredObserverList","_getTheParent","_assignedSlot","parent","parentNode","getRootNode","options","composed","nodeName","tagName","target","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","firstChild","isConnected","root","lastChild","childNodes","createImpl","element","query","childrenToArray","_update","nextSibling","previousSibling","_modified","_clearMemoizedQueries","_childTextContentChangeSteps","myParent","_descendantRemoved","child","_descendantAdded","_attach","_attached","_detach","_lastFocusedElement","hasChildNodes","hasChildren","normalize","nodeValue","_remove","prevChild","appendData","parentElement","baseURI","compareDocumentPosition","otherImpl","reference","Error","result","compareTreePosition","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_FOLLOWING","lookupPrefix","namespace","documentElement","ATTRIBUTE_NODE","_element","lookupNamespaceURI","prefix","isDefaultNamespace","defaultNamespace","contains","other","Boolean","DOCUMENT_POSITION_CONTAINED_BY","isEqualNode","isSameNode","cloneNode","deep","undefined","_value","value","setAnExistingAttributeValue","replaceData","textContent","text","treeIterator","nodeImpl","createTextNode","_replaceAll","insertBefore","childImpl","_preInsert","appendChild","_append","replaceChild","_replace","removeChild","oldChildImpl","_preRemove","_preInsertValidity","parentType","parentName","nodeChildren","parentChildren","nodeChildrenElements","filter","hasNodeTextChildren","some","referenceChildImpl","_adoptNode","_insert","suppressObservers","nodesImpl","grandChildImpl","previousChildImpl","_shadowRoot","_assignedNodes","parentChildElements","previousSiblingImpl","removedNodesImpl","addedNodesImpl","_runPreRemovingSteps","oldPreviousSiblingImpl","oldNextSiblingImpl","remove","hasSlotDescendant","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst { simultaneousIterators } = require(\"../../utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst NodeList = require(\"../generated/NodeList\");\nconst { clone, locateNamespacePrefix, locateNamespace } = require(\"../node\");\nconst attributes = require(\"../attributes\");\n\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { queueTreeMutationRecord } = require(\"../helpers/mutation-observers\");\nconst {\n  isShadowRoot, getRoot, shadowIncludingRoot, assignSlot, assignSlotableForTree, assignSlotable,\n  signalSlotChange, isSlot\n} = require(\"../helpers/shadow-dom\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n  //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n\n  const rootImplB = getRoot(nodeImplB);\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n\n    domSymbolTree.initialize(this);\n\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n  }\n\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n\n    return domSymbolTree.parent(this);\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : getRoot(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl([], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {\n    // Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      // Normalize should only transform Text nodes, and nothing else.\n      if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      if (child.nodeValue === \"\") {\n        this._remove(child);\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this._remove(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE: {\n        return locateNamespacePrefix(this, namespace);\n      }\n      case NODE_TYPE.DOCUMENT_NODE: {\n        return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n      }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n        return null;\n      }\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n      }\n      default: {\n        return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n      }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw new DOMException(\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\");\n    }\n\n    deep = Boolean(deep);\n\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        attributes.setAnExistingAttributeValue(this, value);\n        break;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set textContent(value) {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let nodeImpl = null;\n\n        if (value !== null && value !== \"\") {\n          nodeImpl = this._ownerDocument.createTextNode(value);\n        }\n\n        this._replaceAll(nodeImpl);\n        break;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        attributes.setAnExistingAttributeValue(this, value);\n        break;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-insertbefore\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-appendchild\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-replacechild\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-removechild\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n  _preInsertValidity(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw new DOMException(`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw new DOMException(\"The child can not be found in the parent.\", \"NotFoundError\");\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw new DOMException(`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\");\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw new DOMException(`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n              (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n            (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            ) ||\n            (!childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE))\n          ) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n          break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-insert\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n\n    let referenceChildImpl = childImpl;\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    this._insert(nodeImpl, referenceChildImpl);\n\n    return nodeImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-insert\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(nodeImpl))) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n\n    const previousChildImpl = childImpl ?\n      domSymbolTree.previousSibling(childImpl) :\n      domSymbolTree.lastChild(this);\n\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n\n      if (\n        (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null) &&\n        (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)\n      ) {\n        assignSlot(node);\n      }\n\n      this._modified();\n\n      if (node.nodeType === NODE_TYPE.TEXT_NODE ||\n          node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(getRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      const root = getRoot(node);\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n\n      this._descendantAdded(this, node);\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-append\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace\n  _replace(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    // Note: This section differs from the pre-insert validation algorithm.\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw new DOMException(`Node can't be inserted in a ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw new DOMException(\"The child can not be found in the parent.\", \"NotFoundError\");\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw new DOMException(`${nodeName} node can't be inserted in parent node.`, \"HierarchyRequestError\");\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw new DOMException(`${nodeName} node can't be inserted in ${parentName} parent.`, \"HierarchyRequestError\");\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n\n\n          const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              (parentChildElements.length === 1 && parentChildElements[0] !== childImpl) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            )\n          ) {\n            throw new DOMException(\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            );\n          }\n          break;\n      }\n    }\n\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    let removedNodesImpl = [];\n\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n      this._remove(childImpl, true);\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    this._insert(nodeImpl, referenceChildImpl, true);\n\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace-all\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n\n    let addedNodesImpl;\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n\n    if (nodeImpl) {\n      this._insert(nodeImpl, null, true);\n    }\n\n    queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-remove\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw new DOMException(\"The node to be removed is not a child of this node.\", \"NotFoundError\");\n    }\n\n    this._remove(childImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-remove\n  _remove(nodeImpl, suppressObservers) {\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n\n    domSymbolTree.remove(nodeImpl);\n\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(getRoot(this))) {\n      signalSlotChange(this);\n    }\n\n    let hasSlotDescendant = isSlot(nodeImpl);\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n\n    if (hasSlotDescendant) {\n      assignSlotableForTree(getRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n\n    this._modified();\n    nodeImpl._detach();\n    this._descendantRemoved(this, nodeImpl);\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n"]},"metadata":{},"sourceType":"script"}