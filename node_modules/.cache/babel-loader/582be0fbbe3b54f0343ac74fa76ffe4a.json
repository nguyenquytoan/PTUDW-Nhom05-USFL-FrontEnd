{"ast":null,"code":"function resolveModuleName(request, issuer, compilerOptions, moduleResolutionHost, parentResolver) {\n  const pnp = require(`pnpapi`);\n\n  const topLevelLocation = pnp.getPackageInformation(pnp.topLevel).packageLocation;\n  const [, prefix = ``, packageName = ``, rest] = request.match(/^(!(?:.*!)+)?((?!\\.{0,2}\\/)(?:@[^\\/]+\\/)?[^\\/]+)?(.*)/);\n  let failedLookupLocations = []; // First we try the resolution on \"@types/package-name\" starting from the project root\n\n  if (packageName) {\n    const typesPackagePath = `@types/${packageName.replace(/\\//g, `__`)}${rest}`;\n    let unqualified;\n\n    try {\n      unqualified = pnp.resolveToUnqualified(typesPackagePath, `${topLevelLocation}/`, {\n        considerBuiltins: false\n      });\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified)) unqualified += `/`;\n      const finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  } // Then we try on \"package-name\", this time starting from the package that makes the request\n\n\n  if (true) {\n    const regularPackagePath = `${packageName || ``}${rest}`;\n    let unqualified;\n\n    try {\n      unqualified = pnp.resolveToUnqualified(regularPackagePath, issuer, {\n        considerBuiltins: false\n      });\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified)) unqualified += `/`;\n      const finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  }\n\n  return {\n    resolvedModule: undefined,\n    resolvedTypeReferenceDirective: undefined,\n    failedLookupLocations\n  };\n}\n\nmodule.exports.resolveModuleName = process.versions.pnp ? resolveModuleName : (moduleName, containingFile, compilerOptions, compilerHost, resolveModuleName) => resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/ts-pnp/index.js"],"names":["resolveModuleName","request","issuer","compilerOptions","moduleResolutionHost","parentResolver","pnp","require","topLevelLocation","getPackageInformation","topLevel","packageLocation","prefix","packageName","rest","match","failedLookupLocations","typesPackagePath","replace","unqualified","resolveToUnqualified","considerBuiltins","error","directoryExists","finalResolution","resolvedModule","resolvedTypeReferenceDirective","concat","regularPackagePath","undefined","module","exports","process","versions","moduleName","containingFile","compilerHost"],"mappings":"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","sourcesContent":["function resolveModuleName(request, issuer, compilerOptions, moduleResolutionHost, parentResolver) {\n  const pnp = require(`pnpapi`);\n\n  const topLevelLocation = pnp.getPackageInformation(pnp.topLevel).packageLocation;\n\n  const [, prefix = ``, packageName = ``, rest] = request.match(/^(!(?:.*!)+)?((?!\\.{0,2}\\/)(?:@[^\\/]+\\/)?[^\\/]+)?(.*)/);\n\n  let failedLookupLocations = [];\n\n  // First we try the resolution on \"@types/package-name\" starting from the project root\n  if (packageName) {\n    const typesPackagePath = `@types/${packageName.replace(/\\//g, `__`)}${rest}`;\n\n    let unqualified;\n    try {\n      unqualified = pnp.resolveToUnqualified(typesPackagePath, `${topLevelLocation}/`, {considerBuiltins: false});\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified))\n        unqualified += `/`;\n\n      const finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  }\n\n  // Then we try on \"package-name\", this time starting from the package that makes the request\n  if (true) {\n    const regularPackagePath = `${packageName || ``}${rest}`;\n\n    let unqualified;\n    try {\n      unqualified = pnp.resolveToUnqualified(regularPackagePath, issuer, {considerBuiltins: false});\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified))\n        unqualified += `/`;\n\n      const finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  }\n\n  return {\n    resolvedModule: undefined,\n    resolvedTypeReferenceDirective: undefined,\n    failedLookupLocations,\n  };\n}\n\nmodule.exports.resolveModuleName = process.versions.pnp\n  ? resolveModuleName\n  : (moduleName, containingFile, compilerOptions, compilerHost, resolveModuleName) =>\n      resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost);\n"]},"metadata":{},"sourceType":"script"}