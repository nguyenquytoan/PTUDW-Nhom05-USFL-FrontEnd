{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOpts = defaultOpts;\nexports.default = void 0;\n\nvar parser = _interopRequireWildcard(require(\"@babel/parser\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n\nfunction defaultOpts() {\n  return {\n    coverageVariable: '__coverage__',\n    coverageGlobalScope: 'this',\n    coverageGlobalScopeFunc: true,\n    preserveComments: false,\n    compact: true,\n    esModules: false,\n    autoWrap: false,\n    produceSourceMap: false,\n    ignoreClassMethods: [],\n    sourceMapUrlCallback: null,\n    debug: false,\n\n    /* babel parser plugins are to be enabled when the feature is stage 3 and\n     * implemented in a released version of node.js */\n    plugins: ['asyncGenerators', 'bigInt', 'classProperties', 'classPrivateProperties', 'dynamicImport', 'importMeta', 'objectRestSpread', 'optionalCatchBinding', 'flow', 'jsx']\n  };\n}\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.plugins=['asyncGenerators','dynamicImport','objectRestSpread','optionalCatchBinding','flow','jsx']] - set plugins\n */\n\n\nclass Instrumenter {\n  constructor(opts = defaultOpts()) {\n    this.opts = this.normalizeOpts(opts);\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * normalize options passed in and assign defaults.\n   * @param opts\n   * @private\n   */\n\n\n  normalizeOpts(opts) {\n    const normalize = (name, defaultValue) => {\n      if (!opts.hasOwnProperty(name)) {\n        opts[name] = defaultValue;\n      }\n    };\n\n    const defOpts = defaultOpts();\n    Object.keys(defOpts).forEach(k => {\n      normalize(k, defOpts[k]);\n    });\n    return opts;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const opts = this.opts;\n    const ast = parser.parse(code, {\n      allowReturnOutsideFunction: opts.autoWrap,\n      sourceType: opts.esModules ? 'module' : 'script',\n      plugins: opts.plugins\n    });\n    const ee = (0, _visitor.default)(t, filename, {\n      coverageVariable: opts.coverageVariable,\n      coverageGlobalScope: opts.coverageGlobalScope,\n      coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n      ignoreClassMethods: opts.ignoreClassMethods,\n      inputSourceMap\n    });\n    let output = {};\n    const visitor = {\n      Program: {\n        enter: ee.enter,\n\n        exit(path) {\n          output = ee.exit(path);\n        }\n\n      }\n    };\n    (0, _traverse.default)(ast, visitor);\n    const generateOptions = {\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      sourceMaps: opts.produceSourceMap,\n      sourceFileName: filename\n    };\n    const codeMap = (0, _generator.default)(ast, generateOptions, code);\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nvar _default = Instrumenter;\nexports.default = _default;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-instrument/dist/instrumenter.js"],"names":["Object","defineProperty","exports","value","defaultOpts","default","parser","_interopRequireWildcard","require","t","_traverse","_interopRequireDefault","_generator","_visitor","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","coverageVariable","coverageGlobalScope","coverageGlobalScopeFunc","preserveComments","compact","esModules","autoWrap","produceSourceMap","ignoreClassMethods","sourceMapUrlCallback","debug","plugins","Instrumenter","constructor","opts","normalizeOpts","fileCoverage","sourceMap","normalize","name","defaultValue","defOpts","keys","forEach","k","instrumentSync","code","filename","inputSourceMap","Error","String","Date","getTime","ast","parse","allowReturnOutsideFunction","sourceType","ee","output","visitor","Program","enter","exit","path","generateOptions","comments","sourceMaps","sourceFileName","codeMap","map","cb","sourceMappingURL","instrument","callback","out","ex","lastFileCoverage","lastSourceMap","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOpts = defaultOpts;\nexports.default = void 0;\n\nvar parser = _interopRequireWildcard(require(\"@babel/parser\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nfunction defaultOpts() {\n  return {\n    coverageVariable: '__coverage__',\n    coverageGlobalScope: 'this',\n    coverageGlobalScopeFunc: true,\n    preserveComments: false,\n    compact: true,\n    esModules: false,\n    autoWrap: false,\n    produceSourceMap: false,\n    ignoreClassMethods: [],\n    sourceMapUrlCallback: null,\n    debug: false,\n\n    /* babel parser plugins are to be enabled when the feature is stage 3 and\n     * implemented in a released version of node.js */\n    plugins: ['asyncGenerators', 'bigInt', 'classProperties', 'classPrivateProperties', 'dynamicImport', 'importMeta', 'objectRestSpread', 'optionalCatchBinding', 'flow', 'jsx']\n  };\n}\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.plugins=['asyncGenerators','dynamicImport','objectRestSpread','optionalCatchBinding','flow','jsx']] - set plugins\n */\n\n\nclass Instrumenter {\n  constructor(opts = defaultOpts()) {\n    this.opts = this.normalizeOpts(opts);\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * normalize options passed in and assign defaults.\n   * @param opts\n   * @private\n   */\n\n\n  normalizeOpts(opts) {\n    const normalize = (name, defaultValue) => {\n      if (!opts.hasOwnProperty(name)) {\n        opts[name] = defaultValue;\n      }\n    };\n\n    const defOpts = defaultOpts();\n    Object.keys(defOpts).forEach(k => {\n      normalize(k, defOpts[k]);\n    });\n    return opts;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const opts = this.opts;\n    const ast = parser.parse(code, {\n      allowReturnOutsideFunction: opts.autoWrap,\n      sourceType: opts.esModules ? 'module' : 'script',\n      plugins: opts.plugins\n    });\n    const ee = (0, _visitor.default)(t, filename, {\n      coverageVariable: opts.coverageVariable,\n      coverageGlobalScope: opts.coverageGlobalScope,\n      coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n      ignoreClassMethods: opts.ignoreClassMethods,\n      inputSourceMap\n    });\n    let output = {};\n    const visitor = {\n      Program: {\n        enter: ee.enter,\n\n        exit(path) {\n          output = ee.exit(path);\n        }\n\n      }\n    };\n    (0, _traverse.default)(ast, visitor);\n    const generateOptions = {\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      sourceMaps: opts.produceSourceMap,\n      sourceFileName: filename\n    };\n    const codeMap = (0, _generator.default)(ast, generateOptions, code);\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nvar _default = Instrumenter;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}