{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`-like methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implied-eval\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/u;\n    /*\n     * Figures out if we should inspect a given binary expression. Is a stack\n     * of stacks, where the first element in each substack is a CallExpression.\n     */\n\n    const impliedEvalAncestorsStack = []; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n     * @param {Array} arr What to inspect\n     * @returns {*} The last element of arr\n     * @private\n     */\n\n    function last(arr) {\n      return arr ? arr[arr.length - 1] : null;\n    }\n    /**\n     * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n     * @param {ASTNode} node The MemberExpression node to check.\n     * @returns {boolean} Whether or not the given node is potentially an implied eval.\n     * @private\n     */\n\n\n    function isImpliedEvalMemberExpression(node) {\n      const object = node.object,\n            property = node.property,\n            hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n      return object.name === \"window\" && hasImpliedEvalName;\n    }\n    /**\n     * Determines if a node represents a call to a potentially implied eval.\n     *\n     * This checks the callee name and that there's an argument, but not the type of the argument.\n     * @param {ASTNode} node The CallExpression to check.\n     * @returns {boolean} True if the node matches, false if not.\n     * @private\n     */\n\n\n    function isImpliedEvalCallExpression(node) {\n      const isMemberExpression = node.callee.type === \"MemberExpression\",\n            isIdentifier = node.callee.type === \"Identifier\",\n            isImpliedEvalCallee = isIdentifier && CALLEE_RE.test(node.callee.name) || isMemberExpression && isImpliedEvalMemberExpression(node.callee);\n      return isImpliedEvalCallee && node.arguments.length;\n    }\n    /**\n     * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n     * @param {ASTNode} node The node to inspect the parent of.\n     * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n     * @private\n     */\n\n\n    function hasImpliedEvalParent(node) {\n      // make sure our parent is marked\n      return node.parent === last(last(impliedEvalAncestorsStack)) && ( // if our parent is a CallExpression, make sure we're the first argument\n      node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n    }\n    /**\n     * Checks if our parent is marked as part of an implied eval argument. If\n     * so, collapses the top of impliedEvalAncestorsStack and reports on the\n     * original CallExpression.\n     * @param {ASTNode} node The CallExpression to check.\n     * @returns {boolean} True if the node matches, false if not.\n     * @private\n     */\n\n\n    function checkString(node) {\n      if (hasImpliedEvalParent(node)) {\n        // remove the entire substack, to avoid duplicate reports\n        const substack = impliedEvalAncestorsStack.pop();\n        context.report({\n          node: substack[0],\n          message: \"Implied eval. Consider passing a function instead of a string.\"\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      CallExpression(node) {\n        if (isImpliedEvalCallExpression(node)) {\n          // call expressions create a new substack\n          impliedEvalAncestorsStack.push([node]);\n        }\n      },\n\n      \"CallExpression:exit\"(node) {\n        if (node === last(last(impliedEvalAncestorsStack))) {\n          /*\n           * Destroys the entire sub-stack, rather than just using\n           * last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n           * always the bottom of a impliedEvalAncestorsStack substack.\n           */\n          impliedEvalAncestorsStack.pop();\n        }\n      },\n\n      BinaryExpression(node) {\n        if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n          last(impliedEvalAncestorsStack).push(node);\n        }\n      },\n\n      \"BinaryExpression:exit\"(node) {\n        if (node === last(last(impliedEvalAncestorsStack))) {\n          last(impliedEvalAncestorsStack).pop();\n        }\n      },\n\n      Literal(node) {\n        if (typeof node.value === \"string\") {\n          checkString(node);\n        }\n      },\n\n      TemplateLiteral(node) {\n        checkString(node);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-implied-eval.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","create","context","CALLEE_RE","impliedEvalAncestorsStack","last","arr","length","isImpliedEvalMemberExpression","node","object","property","hasImpliedEvalName","test","name","value","isImpliedEvalCallExpression","isMemberExpression","callee","isIdentifier","isImpliedEvalCallee","arguments","hasImpliedEvalParent","parent","checkString","substack","pop","report","message","CallExpression","push","BinaryExpression","operator","Literal","TemplateLiteral"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implied-eval\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/u;\n\n        /*\n         * Figures out if we should inspect a given binary expression. Is a stack\n         * of stacks, where the first element in each substack is a CallExpression.\n         */\n        const impliedEvalAncestorsStack = [];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n         * @param {Array} arr What to inspect\n         * @returns {*} The last element of arr\n         * @private\n         */\n        function last(arr) {\n            return arr ? arr[arr.length - 1] : null;\n        }\n\n        /**\n         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} Whether or not the given node is potentially an implied eval.\n         * @private\n         */\n        function isImpliedEvalMemberExpression(node) {\n            const object = node.object,\n                property = node.property,\n                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n\n            return object.name === \"window\" && hasImpliedEvalName;\n        }\n\n        /**\n         * Determines if a node represents a call to a potentially implied eval.\n         *\n         * This checks the callee name and that there's an argument, but not the type of the argument.\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function isImpliedEvalCallExpression(node) {\n            const isMemberExpression = (node.callee.type === \"MemberExpression\"),\n                isIdentifier = (node.callee.type === \"Identifier\"),\n                isImpliedEvalCallee =\n                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||\n                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));\n\n            return isImpliedEvalCallee && node.arguments.length;\n        }\n\n        /**\n         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n         * @param {ASTNode} node The node to inspect the parent of.\n         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n         * @private\n         */\n        function hasImpliedEvalParent(node) {\n\n            // make sure our parent is marked\n            return node.parent === last(last(impliedEvalAncestorsStack)) &&\n\n                // if our parent is a CallExpression, make sure we're the first argument\n                (node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n        }\n\n        /**\n         * Checks if our parent is marked as part of an implied eval argument. If\n         * so, collapses the top of impliedEvalAncestorsStack and reports on the\n         * original CallExpression.\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function checkString(node) {\n            if (hasImpliedEvalParent(node)) {\n\n                // remove the entire substack, to avoid duplicate reports\n                const substack = impliedEvalAncestorsStack.pop();\n\n                context.report({ node: substack[0], message: \"Implied eval. Consider passing a function instead of a string.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (isImpliedEvalCallExpression(node)) {\n\n                    // call expressions create a new substack\n                    impliedEvalAncestorsStack.push([node]);\n                }\n            },\n\n            \"CallExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n\n                    /*\n                     * Destroys the entire sub-stack, rather than just using\n                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n                     * always the bottom of a impliedEvalAncestorsStack substack.\n                     */\n                    impliedEvalAncestorsStack.pop();\n                }\n            },\n\n            BinaryExpression(node) {\n                if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n                    last(impliedEvalAncestorsStack).push(node);\n                }\n            },\n\n            \"BinaryExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n                    last(impliedEvalAncestorsStack).pop();\n                }\n            },\n\n            Literal(node) {\n                if (typeof node.value === \"string\") {\n                    checkString(node);\n                }\n            },\n\n            TemplateLiteral(node) {\n                checkString(node);\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}