{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst candidatesOfGlobalObject = Object.freeze([\"global\", \"window\"]);\n/**\n * Checks a given node is a Identifier node of the specified name.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a Identifier node of the name.\n */\n\nfunction isIdentifier(node, name) {\n  return node.type === \"Identifier\" && node.name === name;\n}\n/**\n * Checks a given node is a Literal node of the specified string value.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a Literal node of the name.\n */\n\n\nfunction isConstant(node, name) {\n  switch (node.type) {\n    case \"Literal\":\n      return node.value === name;\n\n    case \"TemplateLiteral\":\n      return node.expressions.length === 0 && node.quasis[0].value.cooked === name;\n\n    default:\n      return false;\n  }\n}\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\n\n\nfunction isMember(node, name) {\n  return node.type === \"MemberExpression\" && (node.computed ? isConstant : isIdentifier)(node.property, name);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-eval\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndirect: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"eval can be harmful.\"\n    }\n  },\n\n  create(context) {\n    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n    /**\n     * Pushs a variable scope (Program or Function) information to the stack.\n     *\n     * This is used in order to check whether or not `this` binding is a\n     * reference to the global object.\n     * @param {ASTNode} node A node of the scope. This is one of Program,\n     *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n     * @returns {void}\n     */\n\n    function enterVarScope(node) {\n      const strict = context.getScope().isStrict;\n      funcInfo = {\n        upper: funcInfo,\n        node,\n        strict,\n        defaultThis: false,\n        initialized: strict\n      };\n    }\n    /**\n     * Pops a variable scope from the stack.\n     * @returns {void}\n     */\n\n\n    function exitVarScope() {\n      funcInfo = funcInfo.upper;\n    }\n    /**\n     * Reports a given node.\n     *\n     * `node` is `Identifier` or `MemberExpression`.\n     * The parent of `node` might be `CallExpression`.\n     *\n     * The location of the report is always `eval` `Identifier` (or possibly\n     * `Literal`). The type of the report is `CallExpression` if the parent is\n     * `CallExpression`. Otherwise, it's the given node type.\n     * @param {ASTNode} node A node to report.\n     * @returns {void}\n     */\n\n\n    function report(node) {\n      const parent = node.parent;\n      const locationNode = node.type === \"MemberExpression\" ? node.property : node;\n      const reportNode = parent.type === \"CallExpression\" && parent.callee === node ? parent : node;\n      context.report({\n        node: reportNode,\n        loc: locationNode.loc.start,\n        messageId: \"unexpected\"\n      });\n    }\n    /**\n     * Reports accesses of `eval` via the global object.\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n\n\n    function reportAccessingEvalViaGlobalObject(globalScope) {\n      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n        const name = candidatesOfGlobalObject[i];\n        const variable = astUtils.getVariableByName(globalScope, name);\n\n        if (!variable) {\n          continue;\n        }\n\n        const references = variable.references;\n\n        for (let j = 0; j < references.length; ++j) {\n          const identifier = references[j].identifier;\n          let node = identifier.parent; // To detect code like `window.window.eval`.\n\n          while (isMember(node, name)) {\n            node = node.parent;\n          } // Reports.\n\n\n          if (isMember(node, \"eval\")) {\n            report(node);\n          }\n        }\n      }\n    }\n    /**\n     * Reports all accesses of `eval` (excludes direct calls to eval).\n     * @param {eslint-scope.Scope} globalScope The global scope.\n     * @returns {void}\n     */\n\n\n    function reportAccessingEval(globalScope) {\n      const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n      if (!variable) {\n        return;\n      }\n\n      const references = variable.references;\n\n      for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n        const id = reference.identifier;\n\n        if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n          // Is accessing to eval (excludes direct calls to eval)\n          report(id);\n        }\n      }\n    }\n\n    if (allowIndirect) {\n      // Checks only direct calls to eval. It's simple!\n      return {\n        \"CallExpression:exit\"(node) {\n          const callee = node.callee;\n\n          if (isIdentifier(callee, \"eval\")) {\n            report(callee);\n          }\n        }\n\n      };\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = node.callee;\n\n        if (isIdentifier(callee, \"eval\")) {\n          report(callee);\n        }\n      },\n\n      Program(node) {\n        const scope = context.getScope(),\n              features = context.parserOptions.ecmaFeatures || {},\n              strict = scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict;\n        funcInfo = {\n          upper: null,\n          node,\n          strict,\n          defaultThis: true,\n          initialized: true\n        };\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        exitVarScope();\n        reportAccessingEval(globalScope);\n        reportAccessingEvalViaGlobalObject(globalScope);\n      },\n\n      FunctionDeclaration: enterVarScope,\n      \"FunctionDeclaration:exit\": exitVarScope,\n      FunctionExpression: enterVarScope,\n      \"FunctionExpression:exit\": exitVarScope,\n      ArrowFunctionExpression: enterVarScope,\n      \"ArrowFunctionExpression:exit\": exitVarScope,\n\n      ThisExpression(node) {\n        if (!isMember(node.parent, \"eval\")) {\n          return;\n        }\n        /*\n         * `this.eval` is found.\n         * Checks whether or not the value of `this` is the global object.\n         */\n\n\n        if (!funcInfo.initialized) {\n          funcInfo.initialized = true;\n          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);\n        }\n\n        if (!funcInfo.strict && funcInfo.defaultThis) {\n          // `this.eval` is possible built-in `eval`.\n          report(node.parent);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-eval.js"],"names":["astUtils","require","candidatesOfGlobalObject","Object","freeze","isIdentifier","node","name","type","isConstant","value","expressions","length","quasis","cooked","isMember","computed","property","module","exports","meta","docs","description","category","recommended","url","schema","properties","allowIndirect","default","additionalProperties","messages","unexpected","create","context","Boolean","options","sourceCode","getSourceCode","funcInfo","enterVarScope","strict","getScope","isStrict","upper","defaultThis","initialized","exitVarScope","report","parent","locationNode","reportNode","callee","loc","start","messageId","reportAccessingEvalViaGlobalObject","globalScope","i","variable","getVariableByName","references","j","identifier","reportAccessingEval","reference","id","isCallee","Program","scope","features","parserOptions","ecmaFeatures","sourceType","globalReturn","childScopes","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ThisExpression","isDefaultThisBinding"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\"\n]);\n\n/**\n * Checks a given node is a Identifier node of the specified name.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a Identifier node of the name.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks a given node is a Literal node of the specified string value.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a Literal node of the name.\n */\nfunction isConstant(node, name) {\n    switch (node.type) {\n        case \"Literal\":\n            return node.value === name;\n\n        case \"TemplateLiteral\":\n            return (\n                node.expressions.length === 0 &&\n                node.quasis[0].value.cooked === name\n            );\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return (\n        node.type === \"MemberExpression\" &&\n        (node.computed ? isConstant : isIdentifier)(node.property, name)\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         * @param {ASTNode} node A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc.start,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    if (isIdentifier(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (isIdentifier(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}