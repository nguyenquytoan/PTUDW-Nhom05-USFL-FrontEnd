{"ast":null,"code":"/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR);\nconst DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\n\nfunction normalizeOptions(options = {}) {\n  const hasGroups = options.groups && options.groups.length > 0;\n  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n  const allowSamePrecedence = options.allowSamePrecedence !== false;\n  return {\n    groups,\n    allowSamePrecedence\n  };\n}\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\n\n\nfunction includesBothInAGroup(groups, left, right) {\n  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\n\n\nfunction getChildNode(node) {\n  return node.type === \"ConditionalExpression\" ? node.test : node.left;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow mixed binary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        groups: {\n          type: \"array\",\n          items: {\n            type: \"array\",\n            items: {\n              enum: ALL_OPERATORS\n            },\n            minItems: 2,\n            uniqueItems: true\n          },\n          uniqueItems: true\n        },\n        allowSamePrecedence: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = normalizeOptions(context.options[0]);\n    /**\n     * Checks whether a given node should be ignored by options or not.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {boolean} `true` if the node should be ignored.\n     */\n\n    function shouldIgnore(node) {\n      const a = node;\n      const b = node.parent;\n      return !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);\n    }\n    /**\n     * Checks whether the operator of a given node is mixed with parent\n     * node's operator or not.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {boolean} `true` if the node was mixed.\n     */\n\n\n    function isMixedWithParent(node) {\n      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\n     * Checks whether the operator of a given node is mixed with a\n     * conditional expression.\n     * @param {ASTNode} node A node to check. This is a conditional\n     *      expression node\n     * @returns {boolean} `true` if the node was mixed.\n     */\n\n\n    function isMixedWithConditionalParent(node) {\n      return !astUtils.isParenthesised(sourceCode, node) && !astUtils.isParenthesised(sourceCode, node.test);\n    }\n    /**\n     * Gets the operator token of a given node.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node.\n     * @returns {Token} The operator token of the node.\n     */\n\n\n    function getOperatorToken(node) {\n      return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n    }\n    /**\n     * Reports both the operator of a given node and the operator of the\n     * parent node.\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\n     *      node or a LogicalExpression node. This parent node is one of\n     *      them, too.\n     * @returns {void}\n     */\n\n\n    function reportBothOperators(node) {\n      const parent = node.parent;\n      const left = getChildNode(parent) === node ? node : parent;\n      const right = getChildNode(parent) !== node ? node : parent;\n      const message = \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.\";\n      const data = {\n        leftOperator: left.operator || \"?:\",\n        rightOperator: right.operator || \"?:\"\n      };\n      context.report({\n        node: left,\n        loc: getOperatorToken(left).loc,\n        message,\n        data\n      });\n      context.report({\n        node: right,\n        loc: getOperatorToken(right).loc,\n        message,\n        data\n      });\n    }\n    /**\n     * Checks between the operator of this node and the operator of the\n     * parent node.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      if (TARGET_NODE_TYPE.test(node.parent.type)) {\n        if (node.parent.type === \"ConditionalExpression\" && !shouldIgnore(node) && isMixedWithConditionalParent(node.parent)) {\n          reportBothOperators(node);\n        } else {\n          if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {\n            reportBothOperators(node);\n          }\n        }\n      }\n    }\n\n    return {\n      BinaryExpression: check,\n      LogicalExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-mixed-operators.js"],"names":["astUtils","require","ARITHMETIC_OPERATORS","BITWISE_OPERATORS","COMPARISON_OPERATORS","LOGICAL_OPERATORS","RELATIONAL_OPERATORS","TERNARY_OPERATOR","ALL_OPERATORS","concat","DEFAULT_GROUPS","TARGET_NODE_TYPE","normalizeOptions","options","hasGroups","groups","length","allowSamePrecedence","includesBothInAGroup","left","right","some","group","indexOf","getChildNode","node","type","test","module","exports","meta","docs","description","category","recommended","url","schema","properties","items","enum","minItems","uniqueItems","default","additionalProperties","create","context","sourceCode","getSourceCode","shouldIgnore","a","b","parent","operator","getPrecedence","isMixedWithParent","isParenthesised","isMixedWithConditionalParent","getOperatorToken","getTokenAfter","isNotClosingParenToken","reportBothOperators","message","data","leftOperator","rightOperator","report","loc","check","BinaryExpression","LogicalExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS,\n    TERNARY_OPERATOR\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n    const hasGroups = options.groups && options.groups.length > 0;\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\nfunction getChildNode(node) {\n    return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with a\n         * conditional expression.\n         * @param {ASTNode} node A node to check. This is a conditional\n         *      expression node\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithConditionalParent(node) {\n            return !astUtils.isParenthesised(sourceCode, node) && !astUtils.isParenthesised(sourceCode, node.test);\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (getChildNode(parent) === node) ? node : parent;\n            const right = (getChildNode(parent) !== node) ? node : parent;\n            const message =\n                \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.\";\n            const data = {\n                leftOperator: left.operator || \"?:\",\n                rightOperator: right.operator || \"?:\"\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc,\n                message,\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc,\n                message,\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (TARGET_NODE_TYPE.test(node.parent.type)) {\n                if (node.parent.type === \"ConditionalExpression\" && !shouldIgnore(node) && isMixedWithConditionalParent(node.parent)) {\n                    reportBothOperators(node);\n                } else {\n                    if (TARGET_NODE_TYPE.test(node.parent.type) &&\n                        isMixedWithParent(node) &&\n                        !shouldIgnore(node)\n                    ) {\n                        reportBothOperators(node);\n                    }\n                }\n            }\n\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}