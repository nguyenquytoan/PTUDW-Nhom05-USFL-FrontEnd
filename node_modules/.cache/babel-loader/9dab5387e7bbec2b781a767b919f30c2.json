{"ast":null,"code":"'use strict';\n\nconst Node = require('./node');\n\nclass Container extends Node {\n  constructor(opts) {\n    super(opts);\n\n    if (!this.nodes) {\n      this.nodes = [];\n    }\n  }\n\n  push(child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  }\n\n  each(callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    let id = this.lastEach,\n        index,\n        result;\n    this.indexes[id] = 0;\n    if (!this.nodes) return undefined;\n\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n    return result;\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result = callback(child, i);\n\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n\n      return result;\n    });\n  }\n\n  walkType(type, callback) {\n    if (!type || !callback) {\n      throw new Error('Parameters {type} and {callback} are required.');\n    } // allow users to pass a constructor, or node type string; eg. Word.\n\n\n    const isTypeCallable = typeof type === 'function';\n    return this.walk((node, index) => {\n      if (isTypeCallable && node instanceof type || !isTypeCallable && node.type === type) {\n        return callback.call(this, node, index);\n      }\n    });\n  }\n\n  append(node) {\n    node.parent = this;\n    this.nodes.push(node);\n    return this;\n  }\n\n  prepend(node) {\n    node.parent = this;\n    this.nodes.unshift(node);\n    return this;\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween);\n\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween);\n    }\n  }\n\n  insertAfter(oldNode, newNode) {\n    let oldIndex = this.index(oldNode),\n        index;\n    this.nodes.splice(oldIndex + 1, 0, newNode);\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n\n      if (oldIndex <= index) {\n        this.indexes[id] = index + this.nodes.length;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(oldNode, newNode) {\n    let oldIndex = this.index(oldNode),\n        index;\n    this.nodes.splice(oldIndex, 0, newNode);\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n\n      if (oldIndex <= index) {\n        this.indexes[id] = index + this.nodes.length;\n      }\n    }\n\n    return this;\n  }\n\n  removeChild(child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n    let index;\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  }\n\n  removeAll() {\n    for (let node of this.nodes) node.parent = undefined;\n\n    this.nodes = [];\n    return this;\n  }\n\n  every(condition) {\n    return this.nodes.every(condition);\n  }\n\n  some(condition) {\n    return this.nodes.some(condition);\n  }\n\n  index(child) {\n    if (typeof child === 'number') {\n      return child;\n    } else {\n      return this.nodes.indexOf(child);\n    }\n  }\n\n  get first() {\n    if (!this.nodes) return undefined;\n    return this.nodes[0];\n  }\n\n  get last() {\n    if (!this.nodes) return undefined;\n    return this.nodes[this.nodes.length - 1];\n  }\n\n  toString() {\n    let result = this.nodes.map(String).join('');\n\n    if (this.value) {\n      result = this.value + result;\n    }\n\n    if (this.raws.before) {\n      result = this.raws.before + result;\n    }\n\n    if (this.raws.after) {\n      result += this.raws.after;\n    }\n\n    return result;\n  }\n\n}\n\nContainer.registerWalker = constructor => {\n  let walkerName = 'walk' + constructor.name; // plural sugar\n\n  if (walkerName.lastIndexOf('s') !== walkerName.length - 1) {\n    walkerName += 's';\n  }\n\n  if (Container.prototype[walkerName]) {\n    return;\n  } // we need access to `this` so we can't use an arrow function\n\n\n  Container.prototype[walkerName] = function (callback) {\n    return this.walkType(constructor, callback);\n  };\n};\n\nmodule.exports = Container;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-values-parser/lib/container.js"],"names":["Node","require","Container","constructor","opts","nodes","push","child","parent","each","callback","lastEach","indexes","id","index","result","undefined","length","walk","i","walkType","type","Error","isTypeCallable","node","call","append","prepend","unshift","cleanRaws","keepBetween","insertAfter","oldNode","newNode","oldIndex","splice","insertBefore","removeChild","removeAll","every","condition","some","indexOf","first","last","toString","map","String","join","value","raws","before","after","registerWalker","walkerName","name","lastIndexOf","prototype","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Node = require('./node');\n\nclass Container extends Node {\n\n  constructor (opts) {\n    super(opts);\n\n    if (!this.nodes) {\n      this.nodes = [];\n    }\n  }\n\n  push (child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  }\n\n  each (callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = { };\n\n    this.lastEach += 1;\n\n    let id = this.lastEach,\n      index,\n      result;\n\n    this.indexes[id] = 0;\n\n    if (!this.nodes) return undefined;\n\n    while (this.indexes[id] < this.nodes.length) {\n      index  = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n\n    return result;\n  }\n\n  walk (callback) {\n    return this.each((child, i) => {\n      let result = callback(child, i);\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n      return result;\n    });\n  }\n\n  walkType (type, callback) {\n    if (!type || !callback) {\n      throw new Error('Parameters {type} and {callback} are required.');\n    }\n\n    // allow users to pass a constructor, or node type string; eg. Word.\n    const isTypeCallable = typeof type === 'function';\n\n    return this.walk((node, index) => {\n      if (isTypeCallable && node instanceof type || !isTypeCallable && node.type === type) {\n        return callback.call(this, node, index);\n      }\n    });\n  }\n\n  append (node) {\n    node.parent = this;\n    this.nodes.push(node);\n    return this;\n  }\n\n  prepend (node) {\n    node.parent = this;\n    this.nodes.unshift(node);\n    return this;\n  }\n\n  cleanRaws (keepBetween) {\n    super.cleanRaws(keepBetween);\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween);\n    }\n  }\n\n  insertAfter (oldNode, newNode) {\n    let oldIndex = this.index(oldNode),\n      index;\n\n    this.nodes.splice(oldIndex + 1, 0, newNode);\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n      if (oldIndex <= index) {\n        this.indexes[id] = index + this.nodes.length;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore (oldNode, newNode) {\n    let oldIndex = this.index(oldNode),\n      index;\n\n    this.nodes.splice(oldIndex, 0, newNode);\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n      if (oldIndex <= index) {\n        this.indexes[id] = index + this.nodes.length;\n      }\n    }\n\n    return this;\n  }\n\n  removeChild (child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n\n    let index;\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  }\n\n  removeAll () {\n    for (let node of this.nodes) node.parent = undefined;\n    this.nodes = [];\n    return this;\n  }\n\n  every (condition) {\n    return this.nodes.every(condition);\n  }\n\n  some (condition) {\n    return this.nodes.some(condition);\n  }\n\n  index (child) {\n    if (typeof child === 'number') {\n      return child;\n    }\n    else {\n      return this.nodes.indexOf(child);\n    }\n  }\n\n  get first () {\n    if (!this.nodes) return undefined;\n    return this.nodes[0];\n  }\n\n  get last () {\n    if (!this.nodes) return undefined;\n    return this.nodes[this.nodes.length - 1];\n  }\n\n  toString () {\n    let result = this.nodes.map(String).join('');\n\n    if (this.value) {\n      result = this.value + result;\n    }\n\n    if (this.raws.before) {\n      result = this.raws.before + result;\n    }\n\n    if (this.raws.after) {\n      result += this.raws.after;\n    }\n\n    return result;\n  }\n}\n\nContainer.registerWalker = (constructor) => {\n  let walkerName = 'walk' + constructor.name;\n\n  // plural sugar\n  if (walkerName.lastIndexOf('s') !== walkerName.length - 1) {\n    walkerName += 's';\n  }\n\n  if (Container.prototype[walkerName]) {\n    return;\n  }\n\n  // we need access to `this` so we can't use an arrow function\n  Container.prototype[walkerName] = function (callback) {\n    return this.walkType(constructor, callback);\n  };\n};\n\nmodule.exports = Container;\n"]},"metadata":{},"sourceType":"script"}