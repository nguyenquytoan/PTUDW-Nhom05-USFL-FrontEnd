{"ast":null,"code":"'use strict'; // var Construct = require('es-abstract/2019/Construct');\n\nvar Get = require('es-abstract/2019/Get');\n\nvar Set = require('es-abstract/2019/Set');\n\nvar SpeciesConstructor = require('es-abstract/2019/SpeciesConstructor');\n\nvar ToLength = require('es-abstract/2019/ToLength');\n\nvar ToString = require('es-abstract/2019/ToString');\n\nvar Type = require('es-abstract/2019/Type');\n\nvar flagsGetter = require('regexp.prototype.flags');\n\nvar RegExpStringIterator = require('./helpers/RegExpStringIterator');\n\nvar OrigRegExp = RegExp;\n\nvar CreateRegExpStringIterator = function CreateRegExpStringIterator(R, S, global, fullUnicode) {\n  if (Type(S) !== 'String') {\n    throw new TypeError('\"S\" value must be a String');\n  }\n\n  if (Type(global) !== 'Boolean') {\n    throw new TypeError('\"global\" value must be a Boolean');\n  }\n\n  if (Type(fullUnicode) !== 'Boolean') {\n    throw new TypeError('\"fullUnicode\" value must be a Boolean');\n  }\n\n  var iterator = new RegExpStringIterator(R, S, global, fullUnicode);\n  return iterator;\n};\n\nvar supportsConstructingWithFlags = ('flags' in RegExp.prototype);\n\nvar constructRegexWithFlags = function constructRegex(C, R) {\n  var matcher; // workaround for older engines that lack RegExp.prototype.flags\n\n  var flags = 'flags' in R ? Get(R, 'flags') : ToString(flagsGetter(R));\n\n  if (supportsConstructingWithFlags && typeof flags === 'string') {\n    matcher = new C(R, flags);\n  } else if (C === OrigRegExp) {\n    // workaround for older engines that can not construct a RegExp with flags\n    matcher = new C(R.source, flags);\n  } else {\n    matcher = new C(R, flags);\n  }\n\n  return {\n    flags: flags,\n    matcher: matcher\n  };\n};\n\nvar regexMatchAll = function SymbolMatchAll(string) {\n  var R = this;\n\n  if (Type(R) !== 'Object') {\n    throw new TypeError('\"this\" value must be an Object');\n  }\n\n  var S = ToString(string);\n  var C = SpeciesConstructor(R, OrigRegExp);\n  var tmp = constructRegexWithFlags(C, R); // var flags = ToString(Get(R, 'flags'));\n\n  var flags = tmp.flags; // var matcher = Construct(C, [R, flags]);\n\n  var matcher = tmp.matcher;\n  var lastIndex = ToLength(Get(R, 'lastIndex'));\n  Set(matcher, 'lastIndex', lastIndex, true);\n  var global = flags.indexOf('g') > -1;\n  var fullUnicode = flags.indexOf('u') > -1;\n  return CreateRegExpStringIterator(matcher, S, global, fullUnicode);\n};\n\nvar defineP = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nif (defineP && gOPD) {\n  var desc = gOPD(regexMatchAll, 'name');\n\n  if (desc && desc.configurable) {\n    defineP(regexMatchAll, 'name', {\n      value: '[Symbol.matchAll]'\n    });\n  }\n}\n\nmodule.exports = regexMatchAll;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/string.prototype.matchall/regexp-matchall.js"],"names":["Get","require","Set","SpeciesConstructor","ToLength","ToString","Type","flagsGetter","RegExpStringIterator","OrigRegExp","RegExp","CreateRegExpStringIterator","R","S","global","fullUnicode","TypeError","iterator","supportsConstructingWithFlags","prototype","constructRegexWithFlags","constructRegex","C","matcher","flags","source","regexMatchAll","SymbolMatchAll","string","tmp","lastIndex","indexOf","defineP","Object","defineProperty","gOPD","getOwnPropertyDescriptor","desc","configurable","value","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// var Construct = require('es-abstract/2019/Construct');\nvar Get = require('es-abstract/2019/Get');\nvar Set = require('es-abstract/2019/Set');\nvar SpeciesConstructor = require('es-abstract/2019/SpeciesConstructor');\nvar ToLength = require('es-abstract/2019/ToLength');\nvar ToString = require('es-abstract/2019/ToString');\nvar Type = require('es-abstract/2019/Type');\nvar flagsGetter = require('regexp.prototype.flags');\n\nvar RegExpStringIterator = require('./helpers/RegExpStringIterator');\nvar OrigRegExp = RegExp;\n\nvar CreateRegExpStringIterator = function CreateRegExpStringIterator(R, S, global, fullUnicode) {\n\tif (Type(S) !== 'String') {\n\t\tthrow new TypeError('\"S\" value must be a String');\n\t}\n\tif (Type(global) !== 'Boolean') {\n\t\tthrow new TypeError('\"global\" value must be a Boolean');\n\t}\n\tif (Type(fullUnicode) !== 'Boolean') {\n\t\tthrow new TypeError('\"fullUnicode\" value must be a Boolean');\n\t}\n\n\tvar iterator = new RegExpStringIterator(R, S, global, fullUnicode);\n\treturn iterator;\n};\n\nvar supportsConstructingWithFlags = 'flags' in RegExp.prototype;\n\nvar constructRegexWithFlags = function constructRegex(C, R) {\n\tvar matcher;\n\t// workaround for older engines that lack RegExp.prototype.flags\n\tvar flags = 'flags' in R ? Get(R, 'flags') : ToString(flagsGetter(R));\n\tif (supportsConstructingWithFlags && typeof flags === 'string') {\n\t\tmatcher = new C(R, flags);\n\t} else if (C === OrigRegExp) {\n\t\t// workaround for older engines that can not construct a RegExp with flags\n\t\tmatcher = new C(R.source, flags);\n\t} else {\n\t\tmatcher = new C(R, flags);\n\t}\n\treturn { flags: flags, matcher: matcher };\n};\n\nvar regexMatchAll = function SymbolMatchAll(string) {\n\tvar R = this;\n\tif (Type(R) !== 'Object') {\n\t\tthrow new TypeError('\"this\" value must be an Object');\n\t}\n\tvar S = ToString(string);\n\tvar C = SpeciesConstructor(R, OrigRegExp);\n\n\tvar tmp = constructRegexWithFlags(C, R);\n\t// var flags = ToString(Get(R, 'flags'));\n\tvar flags = tmp.flags;\n\t// var matcher = Construct(C, [R, flags]);\n\tvar matcher = tmp.matcher;\n\n\tvar lastIndex = ToLength(Get(R, 'lastIndex'));\n\tSet(matcher, 'lastIndex', lastIndex, true);\n\tvar global = flags.indexOf('g') > -1;\n\tvar fullUnicode = flags.indexOf('u') > -1;\n\treturn CreateRegExpStringIterator(matcher, S, global, fullUnicode);\n};\n\nvar defineP = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nif (defineP && gOPD) {\n\tvar desc = gOPD(regexMatchAll, 'name');\n\tif (desc && desc.configurable) {\n\t\tdefineP(regexMatchAll, 'name', { value: '[Symbol.matchAll]' });\n\t}\n}\n\nmodule.exports = regexMatchAll;\n"]},"metadata":{},"sourceType":"script"}