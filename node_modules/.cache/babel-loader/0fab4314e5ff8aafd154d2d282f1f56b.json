{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = runTest;\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function _console() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestLeakDetector() {\n  const data = _interopRequireDefault(require('jest-leak-detector'));\n\n  _jestLeakDetector = function _jestLeakDetector() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction docblock() {\n  const data = _interopRequireWildcard(require('jest-docblock'));\n\n  docblock = function docblock() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sourceMapSupport() {\n  const data = _interopRequireDefault(require('source-map-support'));\n\n  _sourceMapSupport = function _sourceMapSupport() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction freezeConsole(testConsole, config) {\n  // @ts-ignore: `_log` is `private` - we should figure out some proper API here\n  testConsole._log = function fakeConsolePush(_type, message) {\n    const error = new (_jestUtil().ErrorWithStack)(`${_chalk().default.red(`${_chalk().default.bold('Cannot log after tests are done.')} Did you forget to wait for something async in your test?`)}\\nAttempted to log \"${message}\".`, fakeConsolePush);\n    const formattedError = (0, _jestMessageUtil().formatExecError)(error, config, {\n      noStackTrace: false\n    }, undefined, true);\n    process.stderr.write('\\n' + formattedError + '\\n'); // TODO: set exit code in Jest 25\n    // process.exitCode = 1;\n  };\n} // Keeping the core of \"runTest\" as a separate function (as \"runTestInternal\")\n// is key to be able to detect memory leaks. Since all variables are local to\n// the function, when \"runTestInternal\" finishes its execution, they can all be\n// freed, UNLESS something else is leaking them (and that's why we can detect\n// the leak!).\n//\n// If we had all the code in a single function, we should manually nullify all\n// references to verify if there is a leak, which is not maintainable and error\n// prone. That's why \"runTestInternal\" CANNOT be inlined inside \"runTest\".\n\n\nfunction runTestInternal(_x, _x2, _x3, _x4, _x5) {\n  return _runTestInternal.apply(this, arguments);\n}\n\nfunction _runTestInternal() {\n  _runTestInternal = _asyncToGenerator(function* (path, globalConfig, config, resolver, context) {\n    const testSource = _gracefulFs().default.readFileSync(path, 'utf8');\n\n    const docblockPragmas = docblock().parse(docblock().extract(testSource));\n    const customEnvironment = docblockPragmas['jest-environment'];\n    let testEnvironment = config.testEnvironment;\n\n    if (customEnvironment) {\n      if (Array.isArray(customEnvironment)) {\n        throw new Error(`You can only define a single test environment through docblocks, got \"${customEnvironment.join(', ')}\"`);\n      }\n\n      testEnvironment = (0, _jestConfig().getTestEnvironment)(_objectSpread({}, config, {\n        testEnvironment: customEnvironment\n      }));\n    }\n\n    const TestEnvironment = (0, _jestUtil().interopRequireDefault)(require(testEnvironment)).default;\n    const testFramework = process.env.JEST_CIRCUS === '1' ? require('jest-circus/runner') // eslint-disable-line import/no-extraneous-dependencies\n    : require(config.testRunner);\n    const Runtime = config.moduleLoader ? require(config.moduleLoader) : require('jest-runtime');\n    let runtime = undefined;\n    const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;\n\n    const consoleFormatter = (type, message) => (0, _console().getConsoleOutput)(config.cwd, !!globalConfig.verbose, // 4 = the console call is buried 4 stack frames deep\n    _console().BufferedConsole.write([], type, message, 4, runtime && runtime.getSourceMaps()));\n\n    let testConsole;\n\n    if (globalConfig.silent) {\n      testConsole = new (_console().NullConsole)(consoleOut, consoleOut, consoleFormatter);\n    } else if (globalConfig.verbose) {\n      testConsole = new (_console().CustomConsole)(consoleOut, consoleOut, consoleFormatter);\n    } else {\n      testConsole = new (_console().BufferedConsole)(() => runtime && runtime.getSourceMaps());\n    }\n\n    const environment = new TestEnvironment(config, {\n      console: testConsole,\n      docblockPragmas,\n      testPath: path\n    });\n    const leakDetector = config.detectLeaks ? new (_jestLeakDetector().default)(environment) : null;\n    const cacheFS = {\n      [path]: testSource\n    };\n    (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);\n    runtime = new Runtime(config, environment, resolver, cacheFS, {\n      changedFiles: context && context.changedFiles,\n      collectCoverage: globalConfig.collectCoverage,\n      collectCoverageFrom: globalConfig.collectCoverageFrom,\n      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom\n    });\n    const start = Date.now();\n    const sourcemapOptions = {\n      environment: 'node',\n      handleUncaughtExceptions: false,\n      retrieveSourceMap: source => {\n        const sourceMaps = runtime && runtime.getSourceMaps();\n        const sourceMapSource = sourceMaps && sourceMaps[source];\n\n        if (sourceMapSource) {\n          try {\n            return {\n              map: JSON.parse(_gracefulFs().default.readFileSync(sourceMapSource, 'utf8')),\n              url: source\n            };\n          } catch (e) {}\n        }\n\n        return null;\n      }\n    }; // For tests\n\n    runtime.requireInternalModule(require.resolve('source-map-support'), 'source-map-support').install(sourcemapOptions); // For runtime errors\n\n    _sourceMapSupport().default.install(sourcemapOptions);\n\n    if (environment.global && environment.global.process && environment.global.process.exit) {\n      const realExit = environment.global.process.exit;\n\n      environment.global.process.exit = function exit(...args) {\n        const error = new (_jestUtil().ErrorWithStack)(`process.exit called with \"${args.join(', ')}\"`, exit);\n        const formattedError = (0, _jestMessageUtil().formatExecError)(error, config, {\n          noStackTrace: false\n        }, undefined, true);\n        process.stderr.write(formattedError);\n        return realExit(...args);\n      };\n    }\n\n    try {\n      yield environment.setup();\n      let result;\n\n      try {\n        result = yield testFramework(globalConfig, config, environment, runtime, path);\n      } catch (err) {\n        // Access stack before uninstalling sourcemaps\n        err.stack;\n        throw err;\n      }\n\n      freezeConsole(testConsole, config);\n      const testCount = result.numPassingTests + result.numFailingTests + result.numPendingTests + result.numTodoTests;\n      result.perfStats = {\n        end: Date.now(),\n        start\n      };\n      result.testFilePath = path;\n      result.console = testConsole.getBuffer();\n      result.skipped = testCount === result.numPendingTests;\n      result.displayName = config.displayName;\n      const coverage = runtime.getAllCoverageInfoCopy();\n\n      if (coverage) {\n        const coverageKeys = Object.keys(coverage);\n\n        if (coverageKeys.length) {\n          result.coverage = coverage;\n          result.sourceMaps = runtime.getSourceMapInfo(new Set(coverageKeys));\n        }\n      }\n\n      if (globalConfig.logHeapUsage) {\n        if (global.gc) {\n          global.gc();\n        }\n\n        result.memoryUsage = process.memoryUsage().heapUsed;\n      } // Delay the resolution to allow log messages to be output.\n\n\n      return new Promise(resolve => {\n        setImmediate(() => resolve({\n          leakDetector,\n          result\n        }));\n      });\n    } finally {\n      yield environment.teardown();\n\n      _sourceMapSupport().default.resetRetrieveHandlers();\n    }\n  });\n  return _runTestInternal.apply(this, arguments);\n}\n\nfunction runTest(_x6, _x7, _x8, _x9, _x10) {\n  return _runTest.apply(this, arguments);\n}\n\nfunction _runTest() {\n  _runTest = _asyncToGenerator(function* (path, globalConfig, config, resolver, context) {\n    const _ref = yield runTestInternal(path, globalConfig, config, resolver, context),\n          leakDetector = _ref.leakDetector,\n          result = _ref.result;\n\n    if (leakDetector) {\n      // We wanna allow a tiny but time to pass to allow last-minute cleanup\n      yield new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the \"runTestInternal\" closure.\n\n      result.leaks = leakDetector.isLeaking();\n    } else {\n      result.leaks = false;\n    }\n\n    return result;\n  });\n  return _runTest.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-runner/build/runTest.js"],"names":["Object","defineProperty","exports","value","default","runTest","_console","data","require","_gracefulFs","_interopRequireDefault","_jestUtil","_jestLeakDetector","_jestConfig","docblock","_interopRequireWildcard","_jestMessageUtil","_sourceMapSupport","_chalk","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","enumerable","forEach","_defineProperty","configurable","writable","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","args","apply","err","undefined","freezeConsole","testConsole","config","_log","fakeConsolePush","_type","message","ErrorWithStack","red","bold","formattedError","formatExecError","noStackTrace","process","stderr","write","runTestInternal","_x","_x2","_x3","_x4","_x5","_runTestInternal","path","globalConfig","resolver","context","testSource","readFileSync","docblockPragmas","parse","extract","customEnvironment","testEnvironment","Array","isArray","Error","join","getTestEnvironment","TestEnvironment","interopRequireDefault","testFramework","env","JEST_CIRCUS","testRunner","Runtime","moduleLoader","runtime","consoleOut","useStderr","stdout","consoleFormatter","type","getConsoleOutput","cwd","verbose","BufferedConsole","getSourceMaps","silent","NullConsole","CustomConsole","environment","console","testPath","leakDetector","detectLeaks","cacheFS","setGlobal","global","changedFiles","collectCoverage","collectCoverageFrom","collectCoverageOnlyFrom","start","Date","now","sourcemapOptions","handleUncaughtExceptions","retrieveSourceMap","sourceMaps","sourceMapSource","map","JSON","url","e","requireInternalModule","install","exit","realExit","setup","result","stack","testCount","numPassingTests","numFailingTests","numPendingTests","numTodoTests","perfStats","end","testFilePath","getBuffer","skipped","displayName","coverage","getAllCoverageInfoCopy","coverageKeys","getSourceMapInfo","Set","logHeapUsage","gc","memoryUsage","heapUsed","setImmediate","teardown","resetRetrieveHandlers","_x6","_x7","_x8","_x9","_x10","_runTest","_ref","setTimeout","leaks","isLeaking"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = runTest;\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function _console() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestLeakDetector() {\n  const data = _interopRequireDefault(require('jest-leak-detector'));\n\n  _jestLeakDetector = function _jestLeakDetector() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction docblock() {\n  const data = _interopRequireWildcard(require('jest-docblock'));\n\n  docblock = function docblock() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sourceMapSupport() {\n  const data = _interopRequireDefault(require('source-map-support'));\n\n  _sourceMapSupport = function _sourceMapSupport() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc =\n            Object.defineProperty && Object.getOwnPropertyDescriptor\n              ? Object.getOwnPropertyDescriptor(obj, key)\n              : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction freezeConsole(testConsole, config) {\n  // @ts-ignore: `_log` is `private` - we should figure out some proper API here\n  testConsole._log = function fakeConsolePush(_type, message) {\n    const error = new (_jestUtil()).ErrorWithStack(\n      `${_chalk().default.red(\n        `${_chalk().default.bold(\n          'Cannot log after tests are done.'\n        )} Did you forget to wait for something async in your test?`\n      )}\\nAttempted to log \"${message}\".`,\n      fakeConsolePush\n    );\n    const formattedError = (0, _jestMessageUtil().formatExecError)(\n      error,\n      config,\n      {\n        noStackTrace: false\n      },\n      undefined,\n      true\n    );\n    process.stderr.write('\\n' + formattedError + '\\n'); // TODO: set exit code in Jest 25\n    // process.exitCode = 1;\n  };\n} // Keeping the core of \"runTest\" as a separate function (as \"runTestInternal\")\n// is key to be able to detect memory leaks. Since all variables are local to\n// the function, when \"runTestInternal\" finishes its execution, they can all be\n// freed, UNLESS something else is leaking them (and that's why we can detect\n// the leak!).\n//\n// If we had all the code in a single function, we should manually nullify all\n// references to verify if there is a leak, which is not maintainable and error\n// prone. That's why \"runTestInternal\" CANNOT be inlined inside \"runTest\".\n\nfunction runTestInternal(_x, _x2, _x3, _x4, _x5) {\n  return _runTestInternal.apply(this, arguments);\n}\n\nfunction _runTestInternal() {\n  _runTestInternal = _asyncToGenerator(function*(\n    path,\n    globalConfig,\n    config,\n    resolver,\n    context\n  ) {\n    const testSource = _gracefulFs().default.readFileSync(path, 'utf8');\n\n    const docblockPragmas = docblock().parse(docblock().extract(testSource));\n    const customEnvironment = docblockPragmas['jest-environment'];\n    let testEnvironment = config.testEnvironment;\n\n    if (customEnvironment) {\n      if (Array.isArray(customEnvironment)) {\n        throw new Error(\n          `You can only define a single test environment through docblocks, got \"${customEnvironment.join(\n            ', '\n          )}\"`\n        );\n      }\n\n      testEnvironment = (0, _jestConfig().getTestEnvironment)(\n        _objectSpread({}, config, {\n          testEnvironment: customEnvironment\n        })\n      );\n    }\n\n    const TestEnvironment = (0, _jestUtil().interopRequireDefault)(\n      require(testEnvironment)\n    ).default;\n    const testFramework =\n      process.env.JEST_CIRCUS === '1'\n        ? require('jest-circus/runner') // eslint-disable-line import/no-extraneous-dependencies\n        : require(config.testRunner);\n    const Runtime = config.moduleLoader\n      ? require(config.moduleLoader)\n      : require('jest-runtime');\n    let runtime = undefined;\n    const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;\n\n    const consoleFormatter = (type, message) =>\n      (0, _console().getConsoleOutput)(\n        config.cwd,\n        !!globalConfig.verbose, // 4 = the console call is buried 4 stack frames deep\n        _console().BufferedConsole.write(\n          [],\n          type,\n          message,\n          4,\n          runtime && runtime.getSourceMaps()\n        )\n      );\n\n    let testConsole;\n\n    if (globalConfig.silent) {\n      testConsole = new (_console()).NullConsole(\n        consoleOut,\n        consoleOut,\n        consoleFormatter\n      );\n    } else if (globalConfig.verbose) {\n      testConsole = new (_console()).CustomConsole(\n        consoleOut,\n        consoleOut,\n        consoleFormatter\n      );\n    } else {\n      testConsole = new (_console()).BufferedConsole(\n        () => runtime && runtime.getSourceMaps()\n      );\n    }\n\n    const environment = new TestEnvironment(config, {\n      console: testConsole,\n      docblockPragmas,\n      testPath: path\n    });\n    const leakDetector = config.detectLeaks\n      ? new (_jestLeakDetector()).default(environment)\n      : null;\n    const cacheFS = {\n      [path]: testSource\n    };\n    (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);\n    runtime = new Runtime(config, environment, resolver, cacheFS, {\n      changedFiles: context && context.changedFiles,\n      collectCoverage: globalConfig.collectCoverage,\n      collectCoverageFrom: globalConfig.collectCoverageFrom,\n      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom\n    });\n    const start = Date.now();\n    const sourcemapOptions = {\n      environment: 'node',\n      handleUncaughtExceptions: false,\n      retrieveSourceMap: source => {\n        const sourceMaps = runtime && runtime.getSourceMaps();\n        const sourceMapSource = sourceMaps && sourceMaps[source];\n\n        if (sourceMapSource) {\n          try {\n            return {\n              map: JSON.parse(\n                _gracefulFs().default.readFileSync(sourceMapSource, 'utf8')\n              ),\n              url: source\n            };\n          } catch (e) {}\n        }\n\n        return null;\n      }\n    }; // For tests\n\n    runtime\n      .requireInternalModule(\n        require.resolve('source-map-support'),\n        'source-map-support'\n      )\n      .install(sourcemapOptions); // For runtime errors\n\n    _sourceMapSupport().default.install(sourcemapOptions);\n\n    if (\n      environment.global &&\n      environment.global.process &&\n      environment.global.process.exit\n    ) {\n      const realExit = environment.global.process.exit;\n\n      environment.global.process.exit = function exit(...args) {\n        const error = new (_jestUtil()).ErrorWithStack(\n          `process.exit called with \"${args.join(', ')}\"`,\n          exit\n        );\n        const formattedError = (0, _jestMessageUtil().formatExecError)(\n          error,\n          config,\n          {\n            noStackTrace: false\n          },\n          undefined,\n          true\n        );\n        process.stderr.write(formattedError);\n        return realExit(...args);\n      };\n    }\n\n    try {\n      yield environment.setup();\n      let result;\n\n      try {\n        result = yield testFramework(\n          globalConfig,\n          config,\n          environment,\n          runtime,\n          path\n        );\n      } catch (err) {\n        // Access stack before uninstalling sourcemaps\n        err.stack;\n        throw err;\n      }\n\n      freezeConsole(testConsole, config);\n      const testCount =\n        result.numPassingTests +\n        result.numFailingTests +\n        result.numPendingTests +\n        result.numTodoTests;\n      result.perfStats = {\n        end: Date.now(),\n        start\n      };\n      result.testFilePath = path;\n      result.console = testConsole.getBuffer();\n      result.skipped = testCount === result.numPendingTests;\n      result.displayName = config.displayName;\n      const coverage = runtime.getAllCoverageInfoCopy();\n\n      if (coverage) {\n        const coverageKeys = Object.keys(coverage);\n\n        if (coverageKeys.length) {\n          result.coverage = coverage;\n          result.sourceMaps = runtime.getSourceMapInfo(new Set(coverageKeys));\n        }\n      }\n\n      if (globalConfig.logHeapUsage) {\n        if (global.gc) {\n          global.gc();\n        }\n\n        result.memoryUsage = process.memoryUsage().heapUsed;\n      } // Delay the resolution to allow log messages to be output.\n\n      return new Promise(resolve => {\n        setImmediate(() =>\n          resolve({\n            leakDetector,\n            result\n          })\n        );\n      });\n    } finally {\n      yield environment.teardown();\n\n      _sourceMapSupport().default.resetRetrieveHandlers();\n    }\n  });\n  return _runTestInternal.apply(this, arguments);\n}\n\nfunction runTest(_x6, _x7, _x8, _x9, _x10) {\n  return _runTest.apply(this, arguments);\n}\n\nfunction _runTest() {\n  _runTest = _asyncToGenerator(function*(\n    path,\n    globalConfig,\n    config,\n    resolver,\n    context\n  ) {\n    const _ref = yield runTestInternal(\n        path,\n        globalConfig,\n        config,\n        resolver,\n        context\n      ),\n      leakDetector = _ref.leakDetector,\n      result = _ref.result;\n\n    if (leakDetector) {\n      // We wanna allow a tiny but time to pass to allow last-minute cleanup\n      yield new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the \"runTestInternal\" closure.\n\n      result.leaks = leakDetector.isLeaking();\n    } else {\n      result.leaks = false;\n    }\n\n    return result;\n  });\n  return _runTest.apply(this, arguments);\n}\n"]},"metadata":{},"sourceType":"script"}