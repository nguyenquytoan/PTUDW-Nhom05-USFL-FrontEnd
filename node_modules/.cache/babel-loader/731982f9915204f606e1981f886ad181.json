{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst assert = require('assert');\n\nconst fse = require('fs-extra');\n\nconst path = require('path');\n\nconst checkForDeprecatedOptions = require('../lib/check-for-deprecated-options');\n\nconst defaults = require('./options/defaults');\n\nconst errors = require('../lib/errors');\n\nconst getFileManifestEntries = require('../lib/get-file-manifest-entries');\n\nconst injectManifestSchema = require('./options/inject-manifest-schema');\n\nconst validate = require('./options/validate');\n/**\n * This method creates a list of URLs to precache, referred to as a \"precache\n * manifest\", based on the options you provide.\n *\n * The manifest is injected into the `swSrc` file, and the regular expression\n * `injectionPointRegexp` determines where in the file the manifest should go.\n *\n * The final service worker file, with the manifest injected, is written to\n * disk at `swDest`.\n *\n * @param {Object} config Please refer to the\n * [configuration guide](https://developers.google.com/web/tools/workbox/modules/workbox-build#full_injectmanifest_config).\n * @return {Promise<{count: number, size: number, warnings: Array<string>}>}\n * A promise that resolves once the service worker file has been written to\n * `swDest`. The `size` property contains the aggregate size of all the\n * precached entries, in bytes, and the `count` property contains the total\n * number of precached entries. Any non-fatal warning messages will be returned\n * via `warnings`.\n *\n * @memberof module:workbox-build\n */\n\n\nasync function injectManifest(config) {\n  // This check needs to be done before validation, since the deprecated options\n  // will be renamed.\n  const deprecationWarnings = checkForDeprecatedOptions(config);\n  const options = validate(config, injectManifestSchema);\n\n  if (path.normalize(config.swSrc) === path.normalize(config.swDest)) {\n    throw new Error(errors['same-src-and-dest']);\n  }\n\n  const globalRegexp = new RegExp(options.injectionPointRegexp, 'g');\n  const {\n    count,\n    size,\n    manifestEntries,\n    warnings\n  } = await getFileManifestEntries(options);\n  let swFileContents;\n\n  try {\n    swFileContents = await fse.readFile(config.swSrc, 'utf8');\n  } catch (error) {\n    throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n  }\n\n  const injectionResults = swFileContents.match(globalRegexp);\n  assert(injectionResults, errors['injection-point-not-found'] + ( // Customize the error message when this happens:\n  // - If the default RegExp is used, then include the expected string that\n  //   matches as a hint to the developer.\n  // - If a custom RegExp is used, then just include the raw RegExp.\n  options.injectionPointRegexp === defaults.injectionPointRegexp ? 'workbox.precaching.precacheAndRoute([])' : options.injectionPointRegexp));\n  assert(injectionResults.length === 1, errors['multiple-injection-points'] + ` ${options.injectionPointRegexp}`);\n  const entriesString = JSON.stringify(manifestEntries, null, 2);\n  swFileContents = swFileContents.replace(globalRegexp, `$1${entriesString}$2`);\n\n  try {\n    await fse.mkdirp(path.dirname(options.swDest));\n  } catch (error) {\n    throw new Error(errors['unable-to-make-injection-directory'] + ` '${error.message}'`);\n  }\n\n  await fse.writeFile(config.swDest, swFileContents); // Add in any deprecation warnings.\n\n  warnings.push(...deprecationWarnings);\n  return {\n    count,\n    size,\n    warnings\n  };\n}\n\nmodule.exports = injectManifest;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-build/src/entry-points/inject-manifest.js"],"names":["assert","require","fse","path","checkForDeprecatedOptions","defaults","errors","getFileManifestEntries","injectManifestSchema","validate","injectManifest","config","deprecationWarnings","options","normalize","swSrc","swDest","Error","globalRegexp","RegExp","injectionPointRegexp","count","size","manifestEntries","warnings","swFileContents","readFile","error","message","injectionResults","match","length","entriesString","JSON","stringify","replace","mkdirp","dirname","writeFile","push","module","exports"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst assert = require('assert');\nconst fse = require('fs-extra');\nconst path = require('path');\n\nconst checkForDeprecatedOptions =\n    require('../lib/check-for-deprecated-options');\nconst defaults = require('./options/defaults');\nconst errors = require('../lib/errors');\nconst getFileManifestEntries = require('../lib/get-file-manifest-entries');\nconst injectManifestSchema = require('./options/inject-manifest-schema');\nconst validate = require('./options/validate');\n\n/**\n * This method creates a list of URLs to precache, referred to as a \"precache\n * manifest\", based on the options you provide.\n *\n * The manifest is injected into the `swSrc` file, and the regular expression\n * `injectionPointRegexp` determines where in the file the manifest should go.\n *\n * The final service worker file, with the manifest injected, is written to\n * disk at `swDest`.\n *\n * @param {Object} config Please refer to the\n * [configuration guide](https://developers.google.com/web/tools/workbox/modules/workbox-build#full_injectmanifest_config).\n * @return {Promise<{count: number, size: number, warnings: Array<string>}>}\n * A promise that resolves once the service worker file has been written to\n * `swDest`. The `size` property contains the aggregate size of all the\n * precached entries, in bytes, and the `count` property contains the total\n * number of precached entries. Any non-fatal warning messages will be returned\n * via `warnings`.\n *\n * @memberof module:workbox-build\n */\nasync function injectManifest(config) {\n  // This check needs to be done before validation, since the deprecated options\n  // will be renamed.\n  const deprecationWarnings = checkForDeprecatedOptions(config);\n\n  const options = validate(config, injectManifestSchema);\n\n  if (path.normalize(config.swSrc) === path.normalize(config.swDest)) {\n    throw new Error(errors['same-src-and-dest']);\n  }\n\n  const globalRegexp = new RegExp(options.injectionPointRegexp, 'g');\n\n  const {count, size, manifestEntries, warnings} =\n    await getFileManifestEntries(options);\n  let swFileContents;\n  try {\n    swFileContents = await fse.readFile(config.swSrc, 'utf8');\n  } catch (error) {\n    throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n  }\n\n  const injectionResults = swFileContents.match(globalRegexp);\n  assert(injectionResults, errors['injection-point-not-found'] +\n    // Customize the error message when this happens:\n    // - If the default RegExp is used, then include the expected string that\n    //   matches as a hint to the developer.\n    // - If a custom RegExp is used, then just include the raw RegExp.\n    (options.injectionPointRegexp === defaults.injectionPointRegexp ?\n      'workbox.precaching.precacheAndRoute([])' :\n      options.injectionPointRegexp));\n  assert(injectionResults.length === 1, errors['multiple-injection-points'] +\n    ` ${options.injectionPointRegexp}`);\n\n  const entriesString = JSON.stringify(manifestEntries, null, 2);\n  swFileContents = swFileContents.replace(globalRegexp, `$1${entriesString}$2`);\n\n  try {\n    await fse.mkdirp(path.dirname(options.swDest));\n  } catch (error) {\n    throw new Error(errors['unable-to-make-injection-directory'] +\n      ` '${error.message}'`);\n  }\n\n  await fse.writeFile(config.swDest, swFileContents);\n\n  // Add in any deprecation warnings.\n  warnings.push(...deprecationWarnings);\n\n  return {count, size, warnings};\n}\n\nmodule.exports = injectManifest;\n"]},"metadata":{},"sourceType":"script"}