{"ast":null,"code":"var sourceMappingURL = require(\"source-map-url\");\n\nvar resolveUrl = require(\"./resolve-url\");\n\nvar decodeUriComponent = require(\"./decode-uri-component\");\n\nvar urix = require(\"urix\");\n\nvar atob = require(\"atob\");\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function () {\n    callback(error, result);\n  });\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"));\n  } catch (error) {\n    error.sourceMapData = data;\n    throw error;\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = decodeUriComponent(url);\n\n  try {\n    return String(read(readUrl));\n  } catch (error) {\n    error.sourceMapData = data;\n    throw error;\n  }\n}\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData;\n\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl);\n  } catch (error) {\n    return callbackAsync(callback, error);\n  }\n\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData);\n  }\n\n  var readUrl = decodeUriComponent(mapData.url);\n  read(readUrl, function (error, result) {\n    if (error) {\n      error.sourceMapData = mapData;\n      return callback(error);\n    }\n\n    mapData.map = String(result);\n\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData);\n    } catch (error) {\n      return callback(error);\n    }\n\n    callback(null, mapData);\n  });\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl);\n\n  if (!mapData || mapData.map) {\n    return mapData;\n  }\n\n  mapData.map = readSync(read, mapData.url, mapData);\n  mapData.map = parseMapToJSON(mapData.map, mapData);\n  return mapData;\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;\n/**\n * The media type for JSON text is application/json.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n *\n * `text/json` is non-standard media type\n */\n\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/;\n/**\n * JSON text exchanged between systems that are not part of a closed ecosystem\n * MUST be encoded using UTF-8.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n */\n\nvar jsonCharacterEncoding = \"utf-8\";\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64);\n  var len = binStr.length;\n  var arr = new Uint8Array(len);\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = binStr.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n    return atob(b64);\n  }\n\n  var buf = base64ToBuf(b64); // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\"EncodingError\"` value when an coding error is found.\n\n  var decoder = new TextDecoder(jsonCharacterEncoding, {\n    fatal: true\n  });\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = urix(codeUrl);\n  var url = sourceMappingURL.getFrom(code);\n\n  if (!url) {\n    return null;\n  }\n\n  var dataUri = url.match(dataUriRegex);\n\n  if (dataUri) {\n    var mimeType = dataUri[1] || \"text/plain\";\n    var lastParameter = dataUri[2] || \"\";\n    var encoded = dataUri[3] || \"\";\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    };\n\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType);\n      error.sourceMapData = data;\n      throw error;\n    }\n\n    try {\n      data.map = parseMapToJSON(lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n\n    return data;\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url);\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  };\n}\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var pending = map.sources ? map.sources.length : 0;\n  var result = {\n    sourcesResolved: [],\n    sourcesContent: []\n  };\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result);\n    return;\n  }\n\n  var done = function () {\n    pending--;\n\n    if (pending === 0) {\n      callback(null, result);\n    }\n  };\n\n  resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl;\n\n    if (typeof sourceContent === \"string\") {\n      result.sourcesContent[index] = sourceContent;\n      callbackAsync(done, null);\n    } else {\n      var readUrl = decodeUriComponent(fullUrl);\n      read(readUrl, function (error, source) {\n        result.sourcesContent[index] = error ? error : String(source);\n        done();\n      });\n    }\n  });\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent: []\n  };\n\n  if (!map.sources || map.sources.length === 0) {\n    return result;\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl;\n\n    if (read !== null) {\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent;\n      } else {\n        var readUrl = decodeUriComponent(fullUrl);\n\n        try {\n          result.sourcesContent[index] = String(read(readUrl));\n        } catch (error) {\n          result.sourcesContent[index] = error;\n        }\n      }\n    }\n  });\n  return result;\n}\n\nvar endingSlash = /\\/?$/;\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {};\n  mapUrl = urix(mapUrl);\n  var fullUrl;\n  var sourceContent;\n  var sourceRoot;\n\n  for (var index = 0, len = map.sources.length; index < len; index++) {\n    sourceRoot = null;\n\n    if (typeof options.sourceRoot === \"string\") {\n      sourceRoot = options.sourceRoot;\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot;\n    } // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n\n\n    if (sourceRoot === null || sourceRoot === '') {\n      fullUrl = resolveUrl(mapUrl, map.sources[index]);\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index]);\n    }\n\n    sourceContent = (map.sourcesContent || [])[index];\n    fn(fullUrl, sourceContent, index);\n  }\n}\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  if (code === null) {\n    var mapUrl = codeUrl;\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n    var readUrl = decodeUriComponent(mapUrl);\n    read(readUrl, function (error, result) {\n      if (error) {\n        error.sourceMapData = data;\n        return callback(error);\n      }\n\n      data.map = String(result);\n\n      try {\n        data.map = parseMapToJSON(data.map, data);\n      } catch (error) {\n        return callback(error);\n      }\n\n      _resolveSources(data);\n    });\n  } else {\n    resolveSourceMap(code, codeUrl, read, function (error, mapData) {\n      if (error) {\n        return callback(error);\n      }\n\n      if (!mapData) {\n        return callback(null, null);\n      }\n\n      _resolveSources(mapData);\n    });\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {\n      if (error) {\n        return callback(error);\n      }\n\n      mapData.sourcesResolved = result.sourcesResolved;\n      mapData.sourcesContent = result.sourcesContent;\n      callback(null, mapData);\n    });\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData;\n\n  if (code === null) {\n    var mapUrl = codeUrl;\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n    mapData.map = readSync(read, mapUrl, mapData);\n    mapData.map = parseMapToJSON(mapData.map, mapData);\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read);\n\n    if (!mapData) {\n      return null;\n    }\n  }\n\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);\n  mapData.sourcesResolved = result.sourcesResolved;\n  mapData.sourcesContent = result.sourcesContent;\n  return mapData;\n}\n\nmodule.exports = {\n  resolveSourceMap: resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources: resolveSources,\n  resolveSourcesSync: resolveSourcesSync,\n  resolve: resolve,\n  resolveSync: resolveSync,\n  parseMapToJSON: parseMapToJSON\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/source-map-resolve/lib/source-map-resolve-node.js"],"names":["sourceMappingURL","require","resolveUrl","decodeUriComponent","urix","atob","callbackAsync","callback","error","result","setImmediate","parseMapToJSON","string","data","JSON","parse","replace","sourceMapData","readSync","read","url","readUrl","String","resolveSourceMap","code","codeUrl","mapData","resolveSourceMapHelper","map","resolveSourceMapSync","dataUriRegex","jsonMimeTypeRegex","jsonCharacterEncoding","base64ToBuf","b64","binStr","len","length","arr","Uint8Array","i","charCodeAt","decodeBase64String","TextDecoder","buf","decoder","fatal","decode","getFrom","dataUri","match","mimeType","lastParameter","encoded","sourcesRelativeTo","test","Error","decodeURIComponent","mapUrl","resolveSources","options","pending","sources","sourcesResolved","sourcesContent","done","resolveSourcesHelper","fullUrl","sourceContent","index","source","resolveSourcesSync","endingSlash","fn","sourceRoot","resolve","_resolveSources","resolveSync","module","exports"],"mappings":"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","sourcesContent":["var sourceMappingURL   = require(\"source-map-url\")\n\nvar resolveUrl         = require(\"./resolve-url\")\nvar decodeUriComponent = require(\"./decode-uri-component\")\nvar urix               = require(\"urix\")\nvar atob               = require(\"atob\")\n\n\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function() { callback(error, result) })\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = decodeUriComponent(url)\n  try {\n    return String(read(readUrl))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\n\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl)\n  } catch (error) {\n    return callbackAsync(callback, error)\n  }\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData)\n  }\n  var readUrl = decodeUriComponent(mapData.url)\n  read(readUrl, function(error, result) {\n    if (error) {\n      error.sourceMapData = mapData\n      return callback(error)\n    }\n    mapData.map = String(result)\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData)\n    } catch (error) {\n      return callback(error)\n    }\n    callback(null, mapData)\n  })\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl)\n  if (!mapData || mapData.map) {\n    return mapData\n  }\n  mapData.map = readSync(read, mapData.url, mapData)\n  mapData.map = parseMapToJSON(mapData.map, mapData)\n  return mapData\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\n\n/**\n * The media type for JSON text is application/json.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n *\n * `text/json` is non-standard media type\n */\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/\n\n/**\n * JSON text exchanged between systems that are not part of a closed ecosystem\n * MUST be encoded using UTF-8.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n */\nvar jsonCharacterEncoding = \"utf-8\"\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64)\n  var len = binStr.length\n  var arr = new Uint8Array(len)\n  for (var i = 0; i < len; i++) {\n    arr[i] = binStr.charCodeAt(i)\n  }\n  return arr\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n    return atob(b64)\n  }\n  var buf = base64ToBuf(b64);\n  // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\"EncodingError\"` value when an coding error is found.\n  var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = urix(codeUrl)\n\n  var url = sourceMappingURL.getFrom(code)\n  if (!url) {\n    return null\n  }\n\n  var dataUri = url.match(dataUriRegex)\n  if (dataUri) {\n    var mimeType = dataUri[1] || \"text/plain\"\n    var lastParameter = dataUri[2] || \"\"\n    var encoded = dataUri[3] || \"\"\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    }\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType)\n      error.sourceMapData = data\n      throw error\n    }\n    try {\n      data.map = parseMapToJSON(\n        lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded),\n        data\n      )\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n    return data\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url)\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  }\n}\n\n\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options\n    options = {}\n  }\n  var pending = map.sources ? map.sources.length : 0\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result)\n    return\n  }\n\n  var done = function() {\n    pending--\n    if (pending === 0) {\n      callback(null, result)\n    }\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (typeof sourceContent === \"string\") {\n      result.sourcesContent[index] = sourceContent\n      callbackAsync(done, null)\n    } else {\n      var readUrl = decodeUriComponent(fullUrl)\n      read(readUrl, function(error, source) {\n        result.sourcesContent[index] = error ? error : String(source)\n        done()\n      })\n    }\n  })\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (!map.sources || map.sources.length === 0) {\n    return result\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (read !== null) {\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent\n      } else {\n        var readUrl = decodeUriComponent(fullUrl)\n        try {\n          result.sourcesContent[index] = String(read(readUrl))\n        } catch (error) {\n          result.sourcesContent[index] = error\n        }\n      }\n    }\n  })\n\n  return result\n}\n\nvar endingSlash = /\\/?$/\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {}\n  mapUrl = urix(mapUrl)\n  var fullUrl\n  var sourceContent\n  var sourceRoot\n  for (var index = 0, len = map.sources.length; index < len; index++) {\n    sourceRoot = null\n    if (typeof options.sourceRoot === \"string\") {\n      sourceRoot = options.sourceRoot\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot\n    }\n    // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n    if (sourceRoot === null || sourceRoot === '') {\n      fullUrl = resolveUrl(mapUrl, map.sources[index])\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index])\n    }\n    sourceContent = (map.sourcesContent || [])[index]\n    fn(fullUrl, sourceContent, index)\n  }\n}\n\n\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options\n    options = {}\n  }\n  if (code === null) {\n    var mapUrl = codeUrl\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    var readUrl = decodeUriComponent(mapUrl)\n    read(readUrl, function(error, result) {\n      if (error) {\n        error.sourceMapData = data\n        return callback(error)\n      }\n      data.map = String(result)\n      try {\n        data.map = parseMapToJSON(data.map, data)\n      } catch (error) {\n        return callback(error)\n      }\n      _resolveSources(data)\n    })\n  } else {\n    resolveSourceMap(code, codeUrl, read, function(error, mapData) {\n      if (error) {\n        return callback(error)\n      }\n      if (!mapData) {\n        return callback(null, null)\n      }\n      _resolveSources(mapData)\n    })\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\n      if (error) {\n        return callback(error)\n      }\n      mapData.sourcesResolved = result.sourcesResolved\n      mapData.sourcesContent  = result.sourcesContent\n      callback(null, mapData)\n    })\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData\n  if (code === null) {\n    var mapUrl = codeUrl\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    mapData.map = readSync(read, mapUrl, mapData)\n    mapData.map = parseMapToJSON(mapData.map, mapData)\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read)\n    if (!mapData) {\n      return null\n    }\n  }\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\n  mapData.sourcesResolved = result.sourcesResolved\n  mapData.sourcesContent  = result.sourcesContent\n  return mapData\n}\n\n\n\nmodule.exports = {\n  resolveSourceMap:     resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources:       resolveSources,\n  resolveSourcesSync:   resolveSourcesSync,\n  resolve:              resolve,\n  resolveSync:          resolveSync,\n  parseMapToJSON:       parseMapToJSON\n}\n"]},"metadata":{},"sourceType":"script"}