{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\");\n\nvar _instrumenter = require(\"./instrumenter\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // pattern for istanbul to ignore a section\n\n\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.identifier(this.varName), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      } else {\n        console.error('Unable to insert counter for node type:', path.node.type);\n      }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n\n      case 'FunctionExpression':\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function wrappedEntry(path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function exit(path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = (0, _template.default)(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = (0, _template.default)(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = (0, _template.default)(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`); // the template to insert at the top of the program.\n\nconst coverageTemplate = (0, _template.default)(`\n    var COVERAGE_VAR = (function () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (coverage[path] && coverage[path].hash === hash) {\n            return coverage[path];\n        }\n        return coverage[path] = coverageData;\n    })();\n`); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n\nconst defaultProgramVisitorOpts = {\n  inputSourceMap: undefined\n};\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = defaultProgramVisitorOpts) {\n  const T = types; // This sets some unused options but ensures all required options are initialized\n\n  opts = Object.assign({}, (0, _instrumenter.defaultOpts)(), defaultProgramVisitorOpts, opts);\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      const hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_VAR: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      });\n      cv._blockHoist = 5;\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-instrument/dist/visitor.js"],"names":["Object","defineProperty","exports","value","default","_crypto","require","_template","_interopRequireDefault","_sourceCoverage","_constants","_instrumenter","obj","__esModule","COMMENT_RE","COMMENT_FILE_RE","SOURCE_MAP_RE","genVar","filename","hash","createHash","SHA","update","parseInt","digest","substr","toString","VisitState","constructor","types","sourceFilePath","inputSourceMap","ignoreClassMethods","varName","attrs","nextIgnore","cov","SourceCoverage","sourceMappingURL","shouldIgnore","path","node","loc","hintFor","hint","leadingComments","forEach","c","v","trim","groups","match","maybeAssignSourceMapURL","extractURL","comments","trailingComments","counterNeedsHoisting","isFunctionExpression","isArrowFunctionExpression","isClassExpression","onEnter","n","getAttr","some","name","id","isClassMethod","key","onExit","__cov__","setAttr","increase","type","index","T","wrap","x","memberExpression","numericLiteral","updateExpression","identifier","insertCounter","increment","isBlockStatement","body","unshift","expressionStatement","isStatement","insertBefore","isVariableDeclarator","parentPath","parent","isExportNamedDeclaration","isProgram","replaceWith","sequenceExpression","isExpression","console","error","insertStatementCounter","newStatement","insertFunctionCounter","dloc","start","end","line","column","newFunction","get","getBranchIncrement","branchName","addBranchPath","insertBranchCounter","findLeaves","accumulator","property","left","right","push","entries","enter","wrappedEntry","e","call","exit","coverStatement","coverAssignmentPattern","b","newBranch","coverFunction","coverVariableDeclarator","coverClassPropDeclarator","makeBlock","blockStatement","blockProp","prop","makeParenthesizedExpressionForNonIdentifier","isIdentifier","parenthesizedExpression","parenthesizedExpressionProp","convertArrowExpression","bloc","expression","returnStatement","coverIfBranches","ignoreIf","ignoreElse","branch","consequent","alternate","createSwitchBranch","coverSwitchCase","Error","coverTernary","cHint","aHint","coverLogicalExpression","leaves","i","length","leaf","codeVisitor","ArrowFunctionExpression","AssignmentPattern","BlockStatement","ExportDefaultDeclaration","ExportNamedDeclaration","ClassMethod","ClassDeclaration","ClassProperty","ClassPrivateProperty","ObjectMethod","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","ReturnStatement","ThrowStatement","TryStatement","VariableDeclaration","VariableDeclarator","IfStatement","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","SwitchStatement","SwitchCase","WithStatement","FunctionDeclaration","FunctionExpression","LabeledStatement","ConditionalExpression","LogicalExpression","globalTemplateAlteredFunction","globalTemplateFunction","globalTemplateVariable","coverageTemplate","alreadyInstrumented","visitState","scope","hasBinding","shouldIgnoreFile","programNode","test","defaultProgramVisitorOpts","undefined","programVisitor","opts","assign","defaultOpts","find","p","traverse","freeze","coverageData","toJSON","fileCoverage","MAGIC_KEY","MAGIC_VALUE","JSON","stringify","coverageNode","valueToNode","gvTemplate","coverageGlobalScopeFunc","getBinding","GLOBAL_COVERAGE_SCOPE","stringLiteral","coverageGlobalScope","cv","GLOBAL_COVERAGE_VAR","coverageVariable","GLOBAL_COVERAGE_TEMPLATE","COVERAGE_VAR","PATH","INITIAL","HASH","_blockHoist","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\");\n\nvar _instrumenter = require(\"./instrumenter\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// pattern for istanbul to ignore a section\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.identifier(this.varName), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      } else {\n        console.error('Unable to insert counter for node type:', path.node.type);\n      }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n\n      case 'FunctionExpression':\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function wrappedEntry(path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function exit(path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = (0, _template.default)(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = (0, _template.default)(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = (0, _template.default)(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`); // the template to insert at the top of the program.\n\nconst coverageTemplate = (0, _template.default)(`\n    var COVERAGE_VAR = (function () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (coverage[path] && coverage[path].hash === hash) {\n            return coverage[path];\n        }\n        return coverage[path] = coverageData;\n    })();\n`); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n\nconst defaultProgramVisitorOpts = {\n  inputSourceMap: undefined\n};\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = defaultProgramVisitorOpts) {\n  const T = types; // This sets some unused options but ensures all required options are initialized\n\n  opts = Object.assign({}, (0, _instrumenter.defaultOpts)(), defaultProgramVisitorOpts, opts);\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      const hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_VAR: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      });\n      cv._blockHoist = 5;\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}