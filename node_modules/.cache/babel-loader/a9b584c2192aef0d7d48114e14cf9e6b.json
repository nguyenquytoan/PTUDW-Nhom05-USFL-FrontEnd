{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { getCacheKeyForURL } from './getCacheKeyForURL.mjs';\nimport '../_version.mjs';\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n */\n\nexport const addFetchListener = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null\n} = {}) => {\n  const cacheName = cacheNames.getPrecacheName();\n  addEventListener('fetch', event => {\n    const precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs,\n      directoryIndex,\n      ignoreURLParametersMatching,\n      urlManipulation\n    });\n\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` + getFriendlyURL(event.request.url));\n      }\n\n      return;\n    }\n\n    let responsePromise = caches.open(cacheName).then(cache => {\n      return cache.match(precachedURL);\n    }).then(cachedResponse => {\n      if (cachedResponse) {\n        return cachedResponse;\n      } // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` + `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` + `Falling back to the network instead.`);\n      }\n\n      return fetch(precachedURL);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then(response => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(event.request.url));\n        logger.log(`Serving the precached url: ${precachedURL}`);\n        logger.groupCollapsed(`View request details here.`);\n        logger.log(event.request);\n        logger.groupEnd();\n        logger.groupCollapsed(`View response details here.`);\n        logger.log(response);\n        logger.groupEnd();\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-precaching/utils/addFetchListener.mjs"],"names":["cacheNames","getFriendlyURL","logger","getCacheKeyForURL","addFetchListener","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","cacheName","getPrecacheName","addEventListener","event","precachedURL","request","url","process","env","NODE_ENV","debug","responsePromise","caches","open","then","cache","match","cachedResponse","warn","fetch","response","groupCollapsed","log","groupEnd","respondWith"],"mappings":"AAAA;;;;;;;AAQA,SAAQA,UAAR,QAAyB,sCAAzB;AACA,SAAQC,cAAR,QAA6B,0CAA7B;AACA,SAAQC,MAAR,QAAqB,kCAArB;AACA,SAAQC,iBAAR,QAAgC,yBAAhC;AACA,OAAO,iBAAP;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAO,MAAMC,gBAAgB,GAAG,CAAC;AAC/BC,EAAAA,2BAA2B,GAAG,CAAC,OAAD,CADC;AAE/BC,EAAAA,cAAc,GAAG,YAFc;AAG/BC,EAAAA,SAAS,GAAG,IAHmB;AAI/BC,EAAAA,eAAe,GAAG;AAJa,IAK7B,EAL4B,KAKrB;AACT,QAAMC,SAAS,GAAGT,UAAU,CAACU,eAAX,EAAlB;AAEAC,EAAAA,gBAAgB,CAAC,OAAD,EAAWC,KAAD,IAAW;AACnC,UAAMC,YAAY,GAAGV,iBAAiB,CAACS,KAAK,CAACE,OAAN,CAAcC,GAAf,EAAoB;AACxDR,MAAAA,SADwD;AAExDD,MAAAA,cAFwD;AAGxDD,MAAAA,2BAHwD;AAIxDG,MAAAA;AAJwD,KAApB,CAAtC;;AAMA,QAAI,CAACK,YAAL,EAAmB;AACjB,UAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzChB,QAAAA,MAAM,CAACiB,KAAP,CAAc,sCAAD,GACXlB,cAAc,CAACW,KAAK,CAACE,OAAN,CAAcC,GAAf,CADhB;AAED;;AACD;AACD;;AAED,QAAIK,eAAe,GAAGC,MAAM,CAACC,IAAP,CAAYb,SAAZ,EAAuBc,IAAvB,CAA6BC,KAAD,IAAW;AAC3D,aAAOA,KAAK,CAACC,KAAN,CAAYZ,YAAZ,CAAP;AACD,KAFqB,EAEnBU,IAFmB,CAEbG,cAAD,IAAoB;AAC1B,UAAIA,cAAJ,EAAoB;AAClB,eAAOA,cAAP;AACD,OAHyB,CAK1B;AACA;;;AACA,UAAIV,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzChB,QAAAA,MAAM,CAACyB,IAAP,CAAa,6BAAD,GACX,GAAE1B,cAAc,CAACY,YAAD,CAAe,OAAMJ,SAAU,kBADpC,GAEX,sCAFD;AAGD;;AAED,aAAOmB,KAAK,CAACf,YAAD,CAAZ;AACD,KAhBqB,CAAtB;;AAkBA,QAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCE,MAAAA,eAAe,GAAGA,eAAe,CAACG,IAAhB,CAAsBM,QAAD,IAAc;AACnD;AACA;AACA3B,QAAAA,MAAM,CAAC4B,cAAP,CAAuB,+BAAD,GACpB7B,cAAc,CAACW,KAAK,CAACE,OAAN,CAAcC,GAAf,CADhB;AAEAb,QAAAA,MAAM,CAAC6B,GAAP,CAAY,8BAA6BlB,YAAa,EAAtD;AAEAX,QAAAA,MAAM,CAAC4B,cAAP,CAAuB,4BAAvB;AACA5B,QAAAA,MAAM,CAAC6B,GAAP,CAAWnB,KAAK,CAACE,OAAjB;AACAZ,QAAAA,MAAM,CAAC8B,QAAP;AAEA9B,QAAAA,MAAM,CAAC4B,cAAP,CAAuB,6BAAvB;AACA5B,QAAAA,MAAM,CAAC6B,GAAP,CAAWF,QAAX;AACA3B,QAAAA,MAAM,CAAC8B,QAAP;AAEA9B,QAAAA,MAAM,CAAC8B,QAAP;AACA,eAAOH,QAAP;AACD,OAjBiB,CAAlB;AAkBD;;AAEDjB,IAAAA,KAAK,CAACqB,WAAN,CAAkBb,eAAlB;AACD,GAvDe,CAAhB;AAwDD,CAhEM","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getCacheKeyForURL} from './getCacheKeyForURL.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n */\nexport const addFetchListener = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null,\n} = {}) => {\n  const cacheName = cacheNames.getPrecacheName();\n\n  addEventListener('fetch', (event) => {\n    const precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs,\n      directoryIndex,\n      ignoreURLParametersMatching,\n      urlManipulation,\n    });\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` +\n          getFriendlyURL(event.request.url));\n      }\n      return;\n    }\n\n    let responsePromise = caches.open(cacheName).then((cache) => {\n      return cache.match(precachedURL);\n    }).then((cachedResponse) => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n\n      // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` +\n        `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n        `Falling back to the network instead.`);\n      }\n\n      return fetch(precachedURL);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then((response) => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(`Precaching is responding to: ` +\n          getFriendlyURL(event.request.url));\n        logger.log(`Serving the precached url: ${precachedURL}`);\n\n        logger.groupCollapsed(`View request details here.`);\n        logger.log(event.request);\n        logger.groupEnd();\n\n        logger.groupCollapsed(`View response details here.`);\n        logger.log(response);\n        logger.groupEnd();\n\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};\n"]},"metadata":{},"sourceType":"module"}