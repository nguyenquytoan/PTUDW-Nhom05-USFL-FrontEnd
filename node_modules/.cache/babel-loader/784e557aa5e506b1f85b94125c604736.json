{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst MESSAGE_UNNECESSARY_COMPUTED = \"Unnecessarily computed property [{{property}}] found.\";\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary computed property keys in objects and classes\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n    function check(node) {\n      if (!node.computed) {\n        return;\n      }\n\n      const key = node.key,\n            nodeType = typeof key.value;\n      let allowedKey;\n\n      if (node.type === \"MethodDefinition\") {\n        allowedKey = node.static ? \"prototype\" : \"constructor\";\n      } else {\n        allowedKey = \"__proto__\";\n      }\n\n      if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n        context.report({\n          node,\n          message: MESSAGE_UNNECESSARY_COMPUTED,\n          data: {\n            property: sourceCode.getText(key)\n          },\n\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);\n            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);\n\n            if (tokensBetween.slice(0, -1).some((token, index) => sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {\n              // If there are comments between the brackets and the property name, don't do a fix.\n              return null;\n            }\n\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket); // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n\n        });\n      }\n    }\n\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : lodash.noop\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-useless-computed-key.js"],"names":["lodash","require","astUtils","MESSAGE_UNNECESSARY_COMPUTED","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","enforceForClassMembers","default","additionalProperties","fixable","create","context","sourceCode","getSourceCode","options","check","node","computed","key","nodeType","value","allowedKey","static","report","message","data","property","getText","fix","fixer","leftSquareBracket","getFirstToken","isOpeningBracketToken","rightSquareBracket","getFirstTokenBetween","isClosingBracketToken","tokensBetween","getTokensBetween","slice","some","token","index","range","trim","tokenBeforeLeftBracket","getTokenBefore","needsSpaceBeforeKey","canTokensBeAdjacent","replacementKey","raw","replaceTextRange","Property","MethodDefinition","noop"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst MESSAGE_UNNECESSARY_COMPUTED = \"Unnecessarily computed property [{{property}}] found.\";\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary computed property keys in objects and classes\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\"\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (!node.computed) {\n                return;\n            }\n\n            const key = node.key,\n                nodeType = typeof key.value;\n\n            let allowedKey;\n\n            if (node.type === \"MethodDefinition\") {\n                allowedKey = node.static ? \"prototype\" : \"constructor\";\n            } else {\n                allowedKey = \"__proto__\";\n            }\n\n            if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n                context.report({\n                    node,\n                    message: MESSAGE_UNNECESSARY_COMPUTED,\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);\n                        const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);\n\n                        if (tokensBetween.slice(0, -1).some((token, index) =>\n                            sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {\n\n                            // If there are comments between the brackets and the property name, don't do a fix.\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : lodash.noop\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}