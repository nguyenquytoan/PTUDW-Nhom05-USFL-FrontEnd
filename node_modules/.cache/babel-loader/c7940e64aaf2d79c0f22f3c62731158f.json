{"ast":null,"code":"/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require variables within the same declaration block to be sorted\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-vars\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          sourceCode = context.getSourceCode();\n    return {\n      VariableDeclaration(node) {\n        const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n        const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n        const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n        let fixed = false;\n        idDeclarations.slice(1).reduce((memo, decl) => {\n          const lastVariableName = getSortableName(memo),\n                currentVariableName = getSortableName(decl);\n\n          if (currentVariableName < lastVariableName) {\n            context.report({\n              node: decl,\n              message: \"Variables within the same declaration block should be sorted alphabetically.\",\n\n              fix(fixer) {\n                if (unfixable || fixed) {\n                  return null;\n                }\n\n                return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations // Clone the idDeclarations array to avoid mutating it\n                .slice() // Sort the array into the desired order\n                .sort((declA, declB) => {\n                  const aName = getSortableName(declA);\n                  const bName = getSortableName(declB);\n                  return aName > bName ? 1 : -1;\n                }) // Build a string out of the sorted list of identifier declarations and the text between the originals\n                .reduce((sourceText, identifier, index) => {\n                  const textAfterIdentifier = index === idDeclarations.length - 1 ? \"\" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                }, \"\"));\n              }\n\n            });\n            fixed = true;\n            return memo;\n          }\n\n          return decl;\n        }, idDeclarations[0]);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/sort-vars.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreCase","default","additionalProperties","fixable","create","context","configuration","options","sourceCode","getSourceCode","VariableDeclaration","node","idDeclarations","declarations","filter","decl","id","getSortableName","name","toLowerCase","unfixable","some","init","fixed","slice","reduce","memo","lastVariableName","currentVariableName","report","message","fix","fixer","replaceTextRange","range","length","sort","declA","declB","aName","bName","sourceText","identifier","index","textAfterIdentifier","getText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require variables within the same declaration block to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-vars\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            sourceCode = context.getSourceCode();\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n                const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n                const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n                let fixed = false;\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    const lastVariableName = getSortableName(memo),\n                        currentVariableName = getSortableName(decl);\n\n                    if (currentVariableName < lastVariableName) {\n                        context.report({\n                            node: decl,\n                            message: \"Variables within the same declaration block should be sorted alphabetically.\",\n                            fix(fixer) {\n                                if (unfixable || fixed) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange(\n                                    [idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]],\n                                    idDeclarations\n\n                                        // Clone the idDeclarations array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((declA, declB) => {\n                                            const aName = getSortableName(declA);\n                                            const bName = getSortableName(declB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of identifier declarations and the text between the originals\n                                        .reduce((sourceText, identifier, index) => {\n                                            const textAfterIdentifier = index === idDeclarations.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                                        }, \"\")\n\n                                );\n                            }\n                        });\n                        fixed = true;\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}