{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _isAnnotatedForRemoval = _interopRequireDefault(require(\"./isAnnotatedForRemoval\"));\n\nvar _isStatelessComponent = _interopRequireDefault(require(\"./isStatelessComponent\"));\n\nvar _remove = _interopRequireDefault(require(\"./remove\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction isPathReactClass(path, globalOptions) {\n  var node = path.node;\n  var matchers = globalOptions.classNameMatchers;\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n\n  var answer = false;\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    var className = superClass.node.name;\n    var binding = scope.getBinding(className);\n\n    if (!binding) {\n      answer = false;\n    } else {\n      var bindingSuperClass = binding.path.get('superClass');\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  return !Array.from(set1).some(function (item) {\n    return !set2.has(item);\n  });\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  var parent = path.findParent(function (p) {\n    return !p.isMemberExpression();\n  });\n  var type = parent.node.type;\n  var memberExpression;\n\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n\n  return memberExpression.get('object');\n}\n\nfunction _default(api) {\n  var template = api.template,\n      types = api.types,\n      traverse = api.traverse;\n  var nestedIdentifiers = new Set();\n  var removedPaths = new WeakSet();\n  var collectNestedIdentifiers = {\n    Identifier: function Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        var root = memberExpressionRootIdentifier(path);\n\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n\n        return;\n      }\n\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program: function Program(programPath, state) {\n        var ignoreFilenames;\n        var classNameMatchers;\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n\n        var globalOptions = {\n          visitedKey: \"transform-react-remove-prop-types\".concat(Date.now()),\n          unsafeWrapTemplate: template(\"\\n              if (process.env.NODE_ENV !== \\\"production\\\") {\\n                NODE;\\n              }\\n            \", {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function wrapTemplate(_ref) {\n            var LEFT = _ref.LEFT,\n                RIGHT = _ref.RIGHT;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var _options$as = options.as,\n                as = _options$as === void 0 ? 'assignmentExpression' : _options$as;\n            var right = template.expression(\"\\n                process.env.NODE_ENV !== \\\"production\\\" ? RIGHT : {}\\n              \", {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT: RIGHT\n            });\n\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n\n              default:\n                throw new Error(\"unrecognized template type \".concat(as));\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames: ignoreFilenames,\n          types: types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers: classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n\n        if (state.opts.plugins) {\n          var pluginsState = state;\n          var pluginsVisitors = state.opts.plugins.map(function (pluginOpts) {\n            var pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = _objectSpread({}, pluginsState.opts, pluginOpts[1]);\n            }\n\n            var plugin = require(pluginName);\n\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit: function exit(path) {\n              var node = path.node;\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n\n              var parent = path.findParent(function (currentNode) {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty: function ClassProperty(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.key.name === 'propTypes') {\n              var pathClassDeclaration = scope.path;\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration: pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression: function AssignmentExpression(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n\n            var forceRemoval = (0, _isAnnotatedForRemoval.default)(path.node.left);\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n\n            var className = node.left.object.name;\n            var binding = scope.getBinding(className);\n\n            if (!binding) {\n              return;\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              var superClass = binding.path.get('superClass');\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if ((0, _isStatelessComponent.default)(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        var skippedIdentifiers = 0;\n        var removeNewlyUnusedIdentifiers = {\n          VariableDeclarator: function VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n\n            var name = path.node.id.name;\n\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n\n            var _path$scope$getBindin = path.scope.getBinding(name),\n                referencePaths = _path$scope$getBindin.referencePaths; // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n\n            var hasRemainingReferencePaths = referencePaths.some(function (referencePath) {\n              var found = referencePath.find(function (path2) {\n                return removedPaths.has(path2);\n              });\n              return !found;\n            });\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            (0, _remove.default)(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        var lastNestedIdentifiers = new Set();\n\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration: function ImportDeclaration(path) {\n                var _path$node = path.node,\n                    source = _path$node.source,\n                    specifiers = _path$node.specifiers;\n                var found = globalOptions.libraries.some(function (library) {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n\n                  return source.value === library;\n                });\n\n                if (!found) {\n                  return;\n                }\n\n                var haveUsedSpecifiers = specifiers.some(function (specifier) {\n                  var importedIdentifierName = specifier.local.name;\n\n                  var _path$scope$getBindin2 = path.scope.getBinding(importedIdentifierName),\n                      referencePaths = _path$scope$getBindin2.referencePaths;\n\n                  return referencePaths.length > 0;\n                });\n\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/babel-plugin-transform-react-remove-prop-types/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_default","_isAnnotatedForRemoval","_interopRequireDefault","require","_isStatelessComponent","_remove","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","isPathReactClass","path","globalOptions","node","matchers","classNameMatchers","matchesPattern","name","test","isReactClass","superClass","scope","answer","className","binding","getBinding","bindingSuperClass","get","areSetsEqual","set1","set2","size","Array","from","some","item","has","memberExpressionRootIdentifier","parent","findParent","p","isMemberExpression","type","memberExpression","object","api","template","types","traverse","nestedIdentifiers","Set","removedPaths","WeakSet","collectNestedIdentifiers","Identifier","root","add","shorthand","visitor","Program","programPath","state","ignoreFilenames","opts","RegExp","join","undefined","visitedKey","Date","now","unsafeWrapTemplate","placeholderPattern","wrapTemplate","_ref","LEFT","RIGHT","options","_options$as","as","right","expression","variableDeclarator","assignmentExpression","Error","mode","removeImport","libraries","additionalLibraries","createReactClassName","plugins","pluginsState","pluginsVisitors","map","pluginOpts","pluginName","plugin","visitors","merge","parentPath","ObjectProperty","exit","computed","currentNode","property","ClassProperty","pathClassDeclaration","AssignmentExpression","left","forceRemoval","isClassDeclaration","skippedIdentifiers","removeNewlyUnusedIdentifiers","VariableDeclarator","block","includes","id","_path$scope$getBindin","referencePaths","hasRemainingReferencePaths","referencePath","found","find","path2","delete","lastNestedIdentifiers","crawl","ImportDeclaration","_path$node","specifiers","library","haveUsedSpecifiers","specifier","importedIdentifierName","local","_path$scope$getBindin2","remove"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _isAnnotatedForRemoval = _interopRequireDefault(require(\"./isAnnotatedForRemoval\"));\n\nvar _isStatelessComponent = _interopRequireDefault(require(\"./isStatelessComponent\"));\n\nvar _remove = _interopRequireDefault(require(\"./remove\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction isPathReactClass(path, globalOptions) {\n  var node = path.node;\n  var matchers = globalOptions.classNameMatchers;\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n\n  var answer = false;\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    var className = superClass.node.name;\n    var binding = scope.getBinding(className);\n\n    if (!binding) {\n      answer = false;\n    } else {\n      var bindingSuperClass = binding.path.get('superClass');\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  return !Array.from(set1).some(function (item) {\n    return !set2.has(item);\n  });\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  var parent = path.findParent(function (p) {\n    return !p.isMemberExpression();\n  });\n  var type = parent.node.type;\n  var memberExpression;\n\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n\n  return memberExpression.get('object');\n}\n\nfunction _default(api) {\n  var template = api.template,\n      types = api.types,\n      traverse = api.traverse;\n  var nestedIdentifiers = new Set();\n  var removedPaths = new WeakSet();\n  var collectNestedIdentifiers = {\n    Identifier: function Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        var root = memberExpressionRootIdentifier(path);\n\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n\n        return;\n      }\n\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n\n      nestedIdentifiers.add(path.node.name);\n    }\n  };\n  return {\n    visitor: {\n      Program: function Program(programPath, state) {\n        var ignoreFilenames;\n        var classNameMatchers;\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n\n        var globalOptions = {\n          visitedKey: \"transform-react-remove-prop-types\".concat(Date.now()),\n          unsafeWrapTemplate: template(\"\\n              if (process.env.NODE_ENV !== \\\"production\\\") {\\n                NODE;\\n              }\\n            \", {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function wrapTemplate(_ref) {\n            var LEFT = _ref.LEFT,\n                RIGHT = _ref.RIGHT;\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var _options$as = options.as,\n                as = _options$as === void 0 ? 'assignmentExpression' : _options$as;\n            var right = template.expression(\"\\n                process.env.NODE_ENV !== \\\"production\\\" ? RIGHT : {}\\n              \", {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT: RIGHT\n            });\n\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n\n              default:\n                throw new Error(\"unrecognized template type \".concat(as));\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames: ignoreFilenames,\n          types: types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers: classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n\n        if (state.opts.plugins) {\n          var pluginsState = state;\n          var pluginsVisitors = state.opts.plugins.map(function (pluginOpts) {\n            var pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = _objectSpread({}, pluginsState.opts, pluginOpts[1]);\n            }\n\n            var plugin = require(pluginName);\n\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit: function exit(path) {\n              var node = path.node;\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n\n              var parent = path.findParent(function (currentNode) {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n          },\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty: function ClassProperty(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.key.name === 'propTypes') {\n              var pathClassDeclaration = scope.path;\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration: pathClassDeclaration\n                });\n              }\n            }\n          },\n          AssignmentExpression: function AssignmentExpression(path) {\n            var node = path.node,\n                scope = path.scope;\n\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n\n            var forceRemoval = (0, _isAnnotatedForRemoval.default)(path.node.left);\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n\n            var className = node.left.object.name;\n            var binding = scope.getBinding(className);\n\n            if (!binding) {\n              return;\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              var superClass = binding.path.get('superClass');\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                (0, _remove.default)(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if ((0, _isStatelessComponent.default)(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              (0, _remove.default)(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n        });\n        var skippedIdentifiers = 0;\n        var removeNewlyUnusedIdentifiers = {\n          VariableDeclarator: function VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n\n            var name = path.node.id.name;\n\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n\n            var _path$scope$getBindin = path.scope.getBinding(name),\n                referencePaths = _path$scope$getBindin.referencePaths; // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n\n            var hasRemainingReferencePaths = referencePaths.some(function (referencePath) {\n              var found = referencePath.find(function (path2) {\n                return removedPaths.has(path2);\n              });\n              return !found;\n            });\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            (0, _remove.default)(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n        };\n        var lastNestedIdentifiers = new Set();\n\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration: function ImportDeclaration(path) {\n                var _path$node = path.node,\n                    source = _path$node.source,\n                    specifiers = _path$node.specifiers;\n                var found = globalOptions.libraries.some(function (library) {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n\n                  return source.value === library;\n                });\n\n                if (!found) {\n                  return;\n                }\n\n                var haveUsedSpecifiers = specifiers.some(function (specifier) {\n                  var importedIdentifierName = specifier.local.name;\n\n                  var _path$scope$getBindin2 = path.scope.getBinding(importedIdentifierName),\n                      referencePaths = _path$scope$getBindin2.referencePaths;\n\n                  return referencePaths.length > 0;\n                });\n\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}