{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar pathUtils = require(\"../../utils/path\");\n\nvar patternUtils = require(\"../../utils/pattern\");\n\nvar DeepFilter =\n/** @class */\nfunction () {\n  function DeepFilter(options, micromatchOptions) {\n    this.options = options;\n    this.micromatchOptions = micromatchOptions;\n  }\n  /**\r\n   * Returns filter for directories.\r\n   */\n\n\n  DeepFilter.prototype.getFilter = function (positive, negative) {\n    var _this = this;\n\n    var maxPatternDepth = this.getMaxPatternDepth(positive);\n    var negativeRe = this.getNegativePatternsRe(negative);\n    return function (entry) {\n      return _this.filter(entry, negativeRe, maxPatternDepth);\n    };\n  };\n  /**\r\n   * Returns max depth of the provided patterns.\r\n   */\n\n\n  DeepFilter.prototype.getMaxPatternDepth = function (patterns) {\n    var globstar = patterns.some(patternUtils.hasGlobStar);\n    return globstar ? Infinity : patternUtils.getMaxNaivePatternsDepth(patterns);\n  };\n  /**\r\n   * Returns RegExp's for patterns that can affect the depth of reading.\r\n   */\n\n\n  DeepFilter.prototype.getNegativePatternsRe = function (patterns) {\n    var affectDepthOfReadingPatterns = patterns.filter(patternUtils.isAffectDepthOfReadingPattern);\n    return patternUtils.convertPatternsToRe(affectDepthOfReadingPatterns, this.micromatchOptions);\n  };\n  /**\r\n   * Returns «true» for directory that should be read.\r\n   */\n\n\n  DeepFilter.prototype.filter = function (entry, negativeRe, maxPatternDepth) {\n    if (this.isSkippedByDeepOption(entry.depth)) {\n      return false;\n    }\n\n    if (this.isSkippedByMaxPatternDepth(entry.depth, maxPatternDepth)) {\n      return false;\n    }\n\n    if (this.isSkippedSymlinkedDirectory(entry)) {\n      return false;\n    }\n\n    if (this.isSkippedDotDirectory(entry)) {\n      return false;\n    }\n\n    return this.isSkippedByNegativePatterns(entry, negativeRe);\n  };\n  /**\r\n   * Returns «true» when the «deep» option is disabled or number and depth of the entry is greater that the option value.\r\n   */\n\n\n  DeepFilter.prototype.isSkippedByDeepOption = function (entryDepth) {\n    return !this.options.deep || typeof this.options.deep === 'number' && entryDepth >= this.options.deep;\n  };\n  /**\r\n   * Returns «true» when depth parameter is not an Infinity and entry depth greater that the parameter value.\r\n   */\n\n\n  DeepFilter.prototype.isSkippedByMaxPatternDepth = function (entryDepth, maxPatternDepth) {\n    return maxPatternDepth !== Infinity && entryDepth >= maxPatternDepth;\n  };\n  /**\r\n   * Returns «true» for symlinked directory if the «followSymlinkedDirectories» option is disabled.\r\n   */\n\n\n  DeepFilter.prototype.isSkippedSymlinkedDirectory = function (entry) {\n    return !this.options.followSymlinkedDirectories && entry.isSymbolicLink();\n  };\n  /**\r\n   * Returns «true» for a directory whose name starts with a period if «dot» option is disabled.\r\n   */\n\n\n  DeepFilter.prototype.isSkippedDotDirectory = function (entry) {\n    return !this.options.dot && pathUtils.isDotDirectory(entry.path);\n  };\n  /**\r\n   * Returns «true» for a directory whose path math to any negative pattern.\r\n   */\n\n\n  DeepFilter.prototype.isSkippedByNegativePatterns = function (entry, negativeRe) {\n    return !patternUtils.matchAny(entry.path, negativeRe);\n  };\n\n  return DeepFilter;\n}();\n\nexports.default = DeepFilter;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/fast-glob/out/providers/filters/deep.js"],"names":["Object","defineProperty","exports","value","pathUtils","require","patternUtils","DeepFilter","options","micromatchOptions","prototype","getFilter","positive","negative","_this","maxPatternDepth","getMaxPatternDepth","negativeRe","getNegativePatternsRe","entry","filter","patterns","globstar","some","hasGlobStar","Infinity","getMaxNaivePatternsDepth","affectDepthOfReadingPatterns","isAffectDepthOfReadingPattern","convertPatternsToRe","isSkippedByDeepOption","depth","isSkippedByMaxPatternDepth","isSkippedSymlinkedDirectory","isSkippedDotDirectory","isSkippedByNegativePatterns","entryDepth","deep","followSymlinkedDirectories","isSymbolicLink","dot","isDotDirectory","path","matchAny","default"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar pathUtils = require(\"../../utils/path\");\r\nvar patternUtils = require(\"../../utils/pattern\");\r\nvar DeepFilter = /** @class */ (function () {\r\n    function DeepFilter(options, micromatchOptions) {\r\n        this.options = options;\r\n        this.micromatchOptions = micromatchOptions;\r\n    }\r\n    /**\r\n     * Returns filter for directories.\r\n     */\r\n    DeepFilter.prototype.getFilter = function (positive, negative) {\r\n        var _this = this;\r\n        var maxPatternDepth = this.getMaxPatternDepth(positive);\r\n        var negativeRe = this.getNegativePatternsRe(negative);\r\n        return function (entry) { return _this.filter(entry, negativeRe, maxPatternDepth); };\r\n    };\r\n    /**\r\n     * Returns max depth of the provided patterns.\r\n     */\r\n    DeepFilter.prototype.getMaxPatternDepth = function (patterns) {\r\n        var globstar = patterns.some(patternUtils.hasGlobStar);\r\n        return globstar ? Infinity : patternUtils.getMaxNaivePatternsDepth(patterns);\r\n    };\r\n    /**\r\n     * Returns RegExp's for patterns that can affect the depth of reading.\r\n     */\r\n    DeepFilter.prototype.getNegativePatternsRe = function (patterns) {\r\n        var affectDepthOfReadingPatterns = patterns.filter(patternUtils.isAffectDepthOfReadingPattern);\r\n        return patternUtils.convertPatternsToRe(affectDepthOfReadingPatterns, this.micromatchOptions);\r\n    };\r\n    /**\r\n     * Returns «true» for directory that should be read.\r\n     */\r\n    DeepFilter.prototype.filter = function (entry, negativeRe, maxPatternDepth) {\r\n        if (this.isSkippedByDeepOption(entry.depth)) {\r\n            return false;\r\n        }\r\n        if (this.isSkippedByMaxPatternDepth(entry.depth, maxPatternDepth)) {\r\n            return false;\r\n        }\r\n        if (this.isSkippedSymlinkedDirectory(entry)) {\r\n            return false;\r\n        }\r\n        if (this.isSkippedDotDirectory(entry)) {\r\n            return false;\r\n        }\r\n        return this.isSkippedByNegativePatterns(entry, negativeRe);\r\n    };\r\n    /**\r\n     * Returns «true» when the «deep» option is disabled or number and depth of the entry is greater that the option value.\r\n     */\r\n    DeepFilter.prototype.isSkippedByDeepOption = function (entryDepth) {\r\n        return !this.options.deep || (typeof this.options.deep === 'number' && entryDepth >= this.options.deep);\r\n    };\r\n    /**\r\n     * Returns «true» when depth parameter is not an Infinity and entry depth greater that the parameter value.\r\n     */\r\n    DeepFilter.prototype.isSkippedByMaxPatternDepth = function (entryDepth, maxPatternDepth) {\r\n        return maxPatternDepth !== Infinity && entryDepth >= maxPatternDepth;\r\n    };\r\n    /**\r\n     * Returns «true» for symlinked directory if the «followSymlinkedDirectories» option is disabled.\r\n     */\r\n    DeepFilter.prototype.isSkippedSymlinkedDirectory = function (entry) {\r\n        return !this.options.followSymlinkedDirectories && entry.isSymbolicLink();\r\n    };\r\n    /**\r\n     * Returns «true» for a directory whose name starts with a period if «dot» option is disabled.\r\n     */\r\n    DeepFilter.prototype.isSkippedDotDirectory = function (entry) {\r\n        return !this.options.dot && pathUtils.isDotDirectory(entry.path);\r\n    };\r\n    /**\r\n     * Returns «true» for a directory whose path math to any negative pattern.\r\n     */\r\n    DeepFilter.prototype.isSkippedByNegativePatterns = function (entry, negativeRe) {\r\n        return !patternUtils.matchAny(entry.path, negativeRe);\r\n    };\r\n    return DeepFilter;\r\n}());\r\nexports.default = DeepFilter;\r\n"]},"metadata":{},"sourceType":"script"}