{"ast":null,"code":"/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\n\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n  for (const reference of scope.references) {\n    outReferenceMap.set(reference.identifier, reference);\n  }\n\n  for (const childScope of scope.childScopes) {\n    if (childScope.type !== \"function\") {\n      createReferenceMap(childScope, outReferenceMap);\n    }\n  }\n\n  return outReferenceMap;\n}\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\n\n\nfunction getWriteExpr(reference) {\n  if (reference.writeExpr) {\n    return reference.writeExpr;\n  }\n\n  let node = reference.identifier;\n\n  while (node) {\n    const t = node.parent.type;\n\n    if (t === \"AssignmentExpression\" && node.parent.left === node) {\n      return node.parent.right;\n    }\n\n    if (t === \"MemberExpression\" && node.parent.object === node) {\n      node = node.parent;\n      continue;\n    }\n\n    break;\n  }\n\n  return null;\n}\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\n\n\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n  if (!variable) {\n    return false; // A global variable which was not defined.\n  } // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n\n\n  if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n    return false;\n  }\n\n  const functionScope = variable.scope.variableScope;\n  return variable.references.every(reference => reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n  constructor() {\n    this.info = new WeakMap();\n  }\n  /**\n   * Initialize the segment information.\n   * @param {PathSegment} segment The segment to initialize.\n   * @returns {void}\n   */\n\n\n  initialize(segment) {\n    const outdatedReadVariableNames = new Set();\n    const freshReadVariableNames = new Set();\n\n    for (const prevSegment of segment.prevSegments) {\n      const info = this.info.get(prevSegment);\n\n      if (info) {\n        info.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);\n        info.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);\n      }\n    }\n\n    this.info.set(segment, {\n      outdatedReadVariableNames,\n      freshReadVariableNames\n    });\n  }\n  /**\n   * Mark a given variable as read on given segments.\n   * @param {PathSegment[]} segments The segments that it read the variable on.\n   * @param {string} variableName The variable name to be read.\n   * @returns {void}\n   */\n\n\n  markAsRead(segments, variableName) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariableNames.add(variableName);\n      }\n    }\n  }\n  /**\n   * Move `freshReadVariableNames` to `outdatedReadVariableNames`.\n   * @param {PathSegment[]} segments The segments to process.\n   * @returns {void}\n   */\n\n\n  makeOutdated(segments) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariableNames.forEach(Set.prototype.add, info.outdatedReadVariableNames);\n        info.freshReadVariableNames.clear();\n      }\n    }\n  }\n  /**\n   * Check if a given variable is outdated on the current segments.\n   * @param {PathSegment[]} segments The current segments.\n   * @param {string} variableName The variable name to check.\n   * @returns {boolean} `true` if the variable is outdated on the segments.\n   */\n\n\n  isOutdated(segments, variableName) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info && info.outdatedReadVariableNames.has(variableName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const assignmentReferences = new Map();\n    const segmentInfo = new SegmentInfo();\n    let stack = null;\n    return {\n      onCodePathStart(codePath) {\n        const scope = context.getScope();\n        const shouldVerify = scope.type === \"function\" && (scope.block.async || scope.block.generator);\n        stack = {\n          upper: stack,\n          codePath,\n          referenceMap: shouldVerify ? createReferenceMap(scope) : null\n        };\n      },\n\n      onCodePathEnd() {\n        stack = stack.upper;\n      },\n\n      // Initialize the segment information.\n      onCodePathSegmentStart(segment) {\n        segmentInfo.initialize(segment);\n      },\n\n      // Handle references to prepare verification.\n      Identifier(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n        const reference = referenceMap && referenceMap.get(node); // Ignore if this is not a valid variable reference.\n\n        if (!reference) {\n          return;\n        }\n\n        const name = reference.identifier.name;\n        const variable = reference.resolved;\n        const writeExpr = getWriteExpr(reference);\n        const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\"; // Add a fresh read variable.\n\n        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n          segmentInfo.markAsRead(codePath.currentSegments, name);\n        }\n        /*\n         * Register the variable to verify after ESLint traversed the `writeExpr` node\n         * if this reference is an assignment to a variable which is referred from other clausure.\n         */\n\n\n        if (writeExpr && writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n        !isLocalVariableWithoutEscape(variable, isMemberAccess)) {\n          let refs = assignmentReferences.get(writeExpr);\n\n          if (!refs) {\n            refs = [];\n            assignmentReferences.set(writeExpr, refs);\n          }\n\n          refs.push(reference);\n        }\n      },\n\n      /*\n       * Verify assignments.\n       * If the reference exists in `outdatedReadVariableNames` list, report it.\n       */\n      \":expression:exit\"(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack; // referenceMap exists if this is in a resumable function scope.\n\n        if (!referenceMap) {\n          return;\n        } // Mark the read variables on this code path as outdated.\n\n\n        if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n          segmentInfo.makeOutdated(codePath.currentSegments);\n        } // Verify.\n\n\n        const references = assignmentReferences.get(node);\n\n        if (references) {\n          assignmentReferences.delete(node);\n\n          for (const reference of references) {\n            const name = reference.identifier.name;\n\n            if (segmentInfo.isOutdated(codePath.currentSegments, name)) {\n              context.report({\n                node: node.parent,\n                messageId: \"nonAtomicUpdate\",\n                data: {\n                  value: sourceCode.getText(node.parent.left)\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/require-atomic-updates.js"],"names":["createReferenceMap","scope","outReferenceMap","Map","reference","references","set","identifier","childScope","childScopes","type","getWriteExpr","writeExpr","node","t","parent","left","right","object","isLocalVariableWithoutEscape","variable","isMemberAccess","defs","some","d","functionScope","variableScope","every","from","SegmentInfo","constructor","info","WeakMap","initialize","segment","outdatedReadVariableNames","Set","freshReadVariableNames","prevSegment","prevSegments","get","forEach","prototype","add","markAsRead","segments","variableName","makeOutdated","clear","isOutdated","has","module","exports","meta","docs","description","category","recommended","url","fixable","schema","messages","nonAtomicUpdate","create","context","sourceCode","getSourceCode","assignmentReferences","segmentInfo","stack","onCodePathStart","codePath","getScope","shouldVerify","block","async","generator","upper","referenceMap","onCodePathEnd","onCodePathSegmentStart","Identifier","name","resolved","isRead","operator","currentSegments","refs","push","delete","report","messageId","data","value","getText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n    for (const reference of scope.references) {\n        outReferenceMap.set(reference.identifier, reference);\n    }\n    for (const childScope of scope.childScopes) {\n        if (childScope.type !== \"function\") {\n            createReferenceMap(childScope, outReferenceMap);\n        }\n    }\n\n    return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n    if (reference.writeExpr) {\n        return reference.writeExpr;\n    }\n    let node = reference.identifier;\n\n    while (node) {\n        const t = node.parent.type;\n\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\n            return node.parent.right;\n        }\n        if (t === \"MemberExpression\" && node.parent.object === node) {\n            node = node.parent;\n            continue;\n        }\n\n        break;\n    }\n\n    return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n    if (!variable) {\n        return false; // A global variable which was not defined.\n    }\n\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n        return false;\n    }\n\n    const functionScope = variable.scope.variableScope;\n\n    return variable.references.every(reference =>\n        reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n    constructor() {\n        this.info = new WeakMap();\n    }\n\n    /**\n     * Initialize the segment information.\n     * @param {PathSegment} segment The segment to initialize.\n     * @returns {void}\n     */\n    initialize(segment) {\n        const outdatedReadVariableNames = new Set();\n        const freshReadVariableNames = new Set();\n\n        for (const prevSegment of segment.prevSegments) {\n            const info = this.info.get(prevSegment);\n\n            if (info) {\n                info.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);\n                info.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);\n            }\n        }\n\n        this.info.set(segment, { outdatedReadVariableNames, freshReadVariableNames });\n    }\n\n    /**\n     * Mark a given variable as read on given segments.\n     * @param {PathSegment[]} segments The segments that it read the variable on.\n     * @param {string} variableName The variable name to be read.\n     * @returns {void}\n     */\n    markAsRead(segments, variableName) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariableNames.add(variableName);\n            }\n        }\n    }\n\n    /**\n     * Move `freshReadVariableNames` to `outdatedReadVariableNames`.\n     * @param {PathSegment[]} segments The segments to process.\n     * @returns {void}\n     */\n    makeOutdated(segments) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariableNames.forEach(Set.prototype.add, info.outdatedReadVariableNames);\n                info.freshReadVariableNames.clear();\n            }\n        }\n    }\n\n    /**\n     * Check if a given variable is outdated on the current segments.\n     * @param {PathSegment[]} segments The current segments.\n     * @param {string} variableName The variable name to check.\n     * @returns {boolean} `true` if the variable is outdated on the segments.\n     */\n    isOutdated(segments, variableName) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info && info.outdatedReadVariableNames.has(variableName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const assignmentReferences = new Map();\n        const segmentInfo = new SegmentInfo();\n        let stack = null;\n\n        return {\n            onCodePathStart(codePath) {\n                const scope = context.getScope();\n                const shouldVerify =\n                    scope.type === \"function\" &&\n                    (scope.block.async || scope.block.generator);\n\n                stack = {\n                    upper: stack,\n                    codePath,\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null\n                };\n            },\n            onCodePathEnd() {\n                stack = stack.upper;\n            },\n\n            // Initialize the segment information.\n            onCodePathSegmentStart(segment) {\n                segmentInfo.initialize(segment);\n            },\n\n            // Handle references to prepare verification.\n            Identifier(node) {\n                const { codePath, referenceMap } = stack;\n                const reference = referenceMap && referenceMap.get(node);\n\n                // Ignore if this is not a valid variable reference.\n                if (!reference) {\n                    return;\n                }\n                const name = reference.identifier.name;\n                const variable = reference.resolved;\n                const writeExpr = getWriteExpr(reference);\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n                // Add a fresh read variable.\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n                    segmentInfo.markAsRead(codePath.currentSegments, name);\n                }\n\n                /*\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\n                 * if this reference is an assignment to a variable which is referred from other clausure.\n                 */\n                if (writeExpr &&\n                    writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\n                ) {\n                    let refs = assignmentReferences.get(writeExpr);\n\n                    if (!refs) {\n                        refs = [];\n                        assignmentReferences.set(writeExpr, refs);\n                    }\n\n                    refs.push(reference);\n                }\n            },\n\n            /*\n             * Verify assignments.\n             * If the reference exists in `outdatedReadVariableNames` list, report it.\n             */\n            \":expression:exit\"(node) {\n                const { codePath, referenceMap } = stack;\n\n                // referenceMap exists if this is in a resumable function scope.\n                if (!referenceMap) {\n                    return;\n                }\n\n                // Mark the read variables on this code path as outdated.\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n                    segmentInfo.makeOutdated(codePath.currentSegments);\n                }\n\n                // Verify.\n                const references = assignmentReferences.get(node);\n\n                if (references) {\n                    assignmentReferences.delete(node);\n\n                    for (const reference of references) {\n                        const name = reference.identifier.name;\n\n                        if (segmentInfo.isOutdated(codePath.currentSegments, name)) {\n                            context.report({\n                                node: node.parent,\n                                messageId: \"nonAtomicUpdate\",\n                                data: {\n                                    value: sourceCode.getText(node.parent.left)\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}