{"ast":null,"code":"'use strict';\n\nconst openBracket = '{'.charCodeAt(0);\nconst closeBracket = '}'.charCodeAt(0);\nconst openParen = '('.charCodeAt(0);\nconst closeParen = ')'.charCodeAt(0);\nconst singleQuote = '\\''.charCodeAt(0);\nconst doubleQuote = '\"'.charCodeAt(0);\nconst backslash = '\\\\'.charCodeAt(0);\nconst slash = '/'.charCodeAt(0);\nconst period = '.'.charCodeAt(0);\nconst comma = ','.charCodeAt(0);\nconst colon = ':'.charCodeAt(0);\nconst asterisk = '*'.charCodeAt(0);\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\nconst pound = '#'.charCodeAt(0);\nconst newline = '\\n'.charCodeAt(0);\nconst space = ' '.charCodeAt(0);\nconst feed = '\\f'.charCodeAt(0);\nconst tab = '\\t'.charCodeAt(0);\nconst cr = '\\r'.charCodeAt(0);\nconst at = '@'.charCodeAt(0);\nconst lowerE = 'e'.charCodeAt(0);\nconst upperE = 'E'.charCodeAt(0);\nconst digit0 = '0'.charCodeAt(0);\nconst digit9 = '9'.charCodeAt(0);\nconst lowerU = 'u'.charCodeAt(0);\nconst upperU = 'U'.charCodeAt(0);\nconst atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;,/]/g;\nconst wordEnd = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\nconst wordEndNum = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\-\\+\\|~>,\\[\\]\\\\]|\\//g;\nconst alphaNum = /^[a-z0-9]/i;\nconst unicodeRange = /^[a-f0-9?\\-]/i;\n\nconst util = require('util');\n\nconst TokenizeError = require('./errors/TokenizeError');\n\nmodule.exports = function tokenize(input, options) {\n  options = options || {};\n  let tokens = [],\n      css = input.valueOf(),\n      length = css.length,\n      offset = -1,\n      line = 1,\n      pos = 0,\n      parentCount = 0,\n      isURLArg = null,\n      code,\n      next,\n      quote,\n      lines,\n      last,\n      content,\n      escape,\n      nextLine,\n      nextOffset,\n      escaped,\n      escapePos,\n      nextChar;\n\n  function unclosed(what) {\n    let message = util.format('Unclosed %s at line: %d, column: %d, token: %d', what, line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  function tokenizeError() {\n    let message = util.format('Syntax error at line: %d, column: %d, token: %d', line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  while (pos < length) {\n    code = css.charCodeAt(pos);\n\n    if (code === newline) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case newline:\n      case space:\n      case tab:\n      case cr:\n      case feed:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === space || code === newline || code === tab || code === cr || code === feed);\n\n        tokens.push(['space', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case colon:\n        next = pos + 1;\n        tokens.push(['colon', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case comma:\n        next = pos + 1;\n        tokens.push(['comma', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      case openBracket:\n        tokens.push(['{', '{', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeBracket:\n        tokens.push(['}', '}', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case openParen:\n        parentCount++;\n        isURLArg = !isURLArg && parentCount === 1 && tokens.length > 0 && tokens[tokens.length - 1][0] === \"word\" && tokens[tokens.length - 1][1] === \"url\";\n        tokens.push(['(', '(', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case closeParen:\n        parentCount--;\n        isURLArg = isURLArg && parentCount > 0;\n        tokens.push([')', ')', line, pos - offset, line, next - offset, pos]);\n        break;\n\n      case singleQuote:\n      case doubleQuote:\n        quote = code === singleQuote ? '\\'' : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case at:\n        atEnd.lastIndex = pos + 1;\n        atEnd.test(css);\n\n        if (atEnd.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = atEnd.lastIndex - 2;\n        }\n\n        tokens.push(['atword', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case backslash:\n        next = pos;\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n          next += 1;\n        }\n\n        tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n        pos = next;\n        break;\n\n      case plus:\n      case minus:\n      case asterisk:\n        next = pos + 1;\n        nextChar = css.slice(pos + 1, next + 1);\n        let prevChar = css.slice(pos - 1, pos); // if the operator is immediately followed by a word character, then we\n        // have a prefix of some kind, and should fall-through. eg. -webkit\n        // look for --* for custom variables\n\n        if (code === minus && nextChar.charCodeAt(0) === minus) {\n          next++;\n          tokens.push(['word', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n          break;\n        }\n\n        tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n        pos = next - 1;\n        break;\n\n      default:\n        if (code === slash && (css.charCodeAt(pos + 1) === asterisk || options.loose && !isURLArg && css.charCodeAt(pos + 1) === slash)) {\n          const isStandardComment = css.charCodeAt(pos + 1) === asterisk;\n\n          if (isStandardComment) {\n            next = css.indexOf('*/', pos + 2) + 1;\n\n            if (next === 0) {\n              unclosed('comment', '*/');\n            }\n          } else {\n            const newlinePos = css.indexOf('\\n', pos + 2);\n            next = newlinePos !== -1 ? newlinePos - 1 : length;\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else if (code === pound && !alphaNum.test(css.slice(pos + 1, pos + 2))) {\n          next = pos + 1;\n          tokens.push(['#', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n        } else if ((code === lowerU || code === upperU) && css.charCodeAt(pos + 1) === plus) {\n          next = pos + 2;\n\n          do {\n            next += 1;\n            code = css.charCodeAt(next);\n          } while (next < length && unicodeRange.test(css.slice(next, next + 1)));\n\n          tokens.push(['unicoderange', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n          pos = next - 1;\n        } // catch a regular slash, that isn't a comment\n        else if (code === slash) {\n            next = pos + 1;\n            tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n            pos = next - 1;\n          } else {\n            let regex = wordEnd; // we're dealing with a word that starts with a number\n            // those get treated differently\n\n            if (code >= digit0 && code <= digit9) {\n              regex = wordEndNum;\n            }\n\n            regex.lastIndex = pos + 1;\n            regex.test(css);\n\n            if (regex.lastIndex === 0) {\n              next = css.length - 1;\n            } else {\n              next = regex.lastIndex - 2;\n            } // Exponential number notation with minus or plus: 1e-10, 1e+10\n\n\n            if (regex === wordEndNum || code === period) {\n              let ncode = css.charCodeAt(next),\n                  ncode1 = css.charCodeAt(next + 1),\n                  ncode2 = css.charCodeAt(next + 2);\n\n              if ((ncode === lowerE || ncode === upperE) && (ncode1 === minus || ncode1 === plus) && ncode2 >= digit0 && ncode2 <= digit9) {\n                wordEndNum.lastIndex = next + 2;\n                wordEndNum.test(css);\n\n                if (wordEndNum.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = wordEndNum.lastIndex - 2;\n                }\n              }\n            }\n\n            tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n            pos = next;\n          }\n\n        break;\n    }\n\n    pos++;\n  }\n\n  return tokens;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-values-parser/lib/tokenize.js"],"names":["openBracket","charCodeAt","closeBracket","openParen","closeParen","singleQuote","doubleQuote","backslash","slash","period","comma","colon","asterisk","minus","plus","pound","newline","space","feed","tab","cr","at","lowerE","upperE","digit0","digit9","lowerU","upperU","atEnd","wordEnd","wordEndNum","alphaNum","unicodeRange","util","require","TokenizeError","module","exports","tokenize","input","options","tokens","css","valueOf","length","offset","line","pos","parentCount","isURLArg","code","next","quote","lines","last","content","escape","nextLine","nextOffset","escaped","escapePos","nextChar","unclosed","what","message","format","tokenizeError","push","slice","indexOf","lastIndex","test","prevChar","loose","isStandardComment","newlinePos","split","regex","ncode","ncode1","ncode2"],"mappings":"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","sourcesContent":["'use strict';\n\nconst openBracket = '{'.charCodeAt(0);\nconst closeBracket = '}'.charCodeAt(0);\nconst openParen = '('.charCodeAt(0);\nconst closeParen = ')'.charCodeAt(0);\nconst singleQuote = '\\''.charCodeAt(0);\nconst doubleQuote = '\"'.charCodeAt(0);\nconst backslash = '\\\\'.charCodeAt(0);\nconst slash = '/'.charCodeAt(0);\nconst period = '.'.charCodeAt(0);\nconst comma = ','.charCodeAt(0);\nconst colon = ':'.charCodeAt(0);\nconst asterisk = '*'.charCodeAt(0);\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\nconst pound = '#'.charCodeAt(0);\nconst newline = '\\n'.charCodeAt(0);\nconst space = ' '.charCodeAt(0);\nconst feed = '\\f'.charCodeAt(0);\nconst tab = '\\t'.charCodeAt(0);\nconst cr = '\\r'.charCodeAt(0);\nconst at = '@'.charCodeAt(0);\nconst lowerE = 'e'.charCodeAt(0);\nconst upperE = 'E'.charCodeAt(0);\nconst digit0 = '0'.charCodeAt(0);\nconst digit9 = '9'.charCodeAt(0);\nconst lowerU = 'u'.charCodeAt(0);\nconst upperU = 'U'.charCodeAt(0);\nconst atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;,/]/g;\nconst wordEnd = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\nconst wordEndNum = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\-\\+\\|~>,\\[\\]\\\\]|\\//g;\nconst alphaNum = /^[a-z0-9]/i;\nconst unicodeRange = /^[a-f0-9?\\-]/i;\n\nconst util = require('util');\nconst TokenizeError = require('./errors/TokenizeError');\n\nmodule.exports = function tokenize (input, options) {\n\n  options = options || {};\n\n  let tokens = [],\n    css = input.valueOf(),\n    length = css.length,\n    offset = -1,\n    line =  1,\n    pos =  0,\n    parentCount = 0,\n    isURLArg = null,\n\n    code, next, quote, lines, last, content, escape, nextLine, nextOffset,\n    escaped, escapePos, nextChar;\n\n  function unclosed (what) {\n    let message = util.format('Unclosed %s at line: %d, column: %d, token: %d', what, line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  function tokenizeError () {\n    let message = util.format('Syntax error at line: %d, column: %d, token: %d', line, pos - offset, pos);\n    throw new TokenizeError(message);\n  }\n\n  while (pos < length) {\n    code = css.charCodeAt(pos);\n\n    if (code === newline) {\n      offset = pos;\n      line  += 1;\n    }\n\n    switch (code) {\n      case newline:\n      case space:\n      case tab:\n      case cr:\n      case feed:\n        next = pos;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n          if (code === newline) {\n            offset = next;\n            line  += 1;\n          }\n        } while (code === space   ||\n          code === newline ||\n          code === tab     ||\n          code === cr      ||\n          code === feed);\n\n        tokens.push(['space', css.slice(pos, next),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n\n        pos = next - 1;\n        break;\n\n      case colon:\n        next = pos + 1;\n        tokens.push(['colon', css.slice(pos, next),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n\n        pos = next - 1;\n        break;\n\n      case comma:\n        next = pos + 1;\n        tokens.push(['comma', css.slice(pos, next),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n\n        pos = next - 1;\n        break;\n\n      case openBracket:\n        tokens.push(['{', '{',\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n        break;\n\n      case closeBracket:\n        tokens.push(['}', '}',\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n        break;\n\n      case openParen:\n        parentCount++;\n        isURLArg = !isURLArg && parentCount === 1 &&\n          tokens.length > 0 &&\n          tokens[tokens.length - 1][0] === \"word\" &&\n          tokens[tokens.length - 1][1] === \"url\";\n        tokens.push(['(', '(',\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n        break;\n\n      case closeParen:\n        parentCount--;\n        isURLArg = isURLArg && parentCount > 0;\n        tokens.push([')', ')',\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n        break;\n\n      case singleQuote:\n      case doubleQuote:\n        quote = code === singleQuote ? '\\'' : '\"';\n        next  = pos;\n        do {\n          escaped = false;\n          next    = css.indexOf(quote, next + 1);\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n          escapePos = next;\n          while (css.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokens.push(['string', css.slice(pos, next + 1),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n        pos = next;\n        break;\n\n      case at:\n        atEnd.lastIndex = pos + 1;\n        atEnd.test(css);\n\n        if (atEnd.lastIndex === 0) {\n          next = css.length - 1;\n        }\n        else {\n          next = atEnd.lastIndex - 2;\n        }\n\n        tokens.push(['atword', css.slice(pos, next + 1),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n        pos = next;\n        break;\n\n      case backslash:\n        next   = pos;\n        code = css.charCodeAt(next + 1);\n\n        if (escape && (code !== slash && code !== space &&\n                        code !== newline && code !== tab &&\n                        code !== cr && code !== feed)) {\n          next += 1;\n        }\n\n        tokens.push(['word', css.slice(pos, next + 1),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n\n        pos = next;\n        break;\n\n      case plus:\n      case minus:\n      case asterisk:\n        next = pos + 1;\n        nextChar = css.slice(pos + 1, next + 1);\n\n        let prevChar = css.slice(pos - 1, pos);\n\n        // if the operator is immediately followed by a word character, then we\n        // have a prefix of some kind, and should fall-through. eg. -webkit\n\n        // look for --* for custom variables\n        if (code === minus && nextChar.charCodeAt(0) === minus) {\n          next++;\n\n          tokens.push(['word', css.slice(pos, next),\n            line, pos  - offset,\n            line, next - offset,\n            pos\n          ]);\n\n          pos = next - 1;\n          break;\n        }\n\n        tokens.push(['operator', css.slice(pos, next),\n          line, pos  - offset,\n          line, next - offset,\n          pos\n        ]);\n\n        pos = next - 1;\n        break;\n\n      default:\n        if (code === slash && (css.charCodeAt(pos + 1) === asterisk || (options.loose && !isURLArg && css.charCodeAt(pos + 1) === slash))) {\n          const isStandardComment = css.charCodeAt(pos + 1) === asterisk;\n\n          if (isStandardComment) {\n            next = css.indexOf('*/', pos + 2) + 1;\n            if (next === 0) {\n              unclosed('comment', '*/');\n            }\n          }\n          else {\n            const newlinePos = css.indexOf('\\n', pos + 2);\n\n            next = newlinePos !== -1 ? newlinePos - 1 : length;\n          }\n\n          content = css.slice(pos, next + 1);\n          lines   = content.split('\\n');\n          last    = lines.length - 1;\n\n          if (last > 0) {\n            nextLine   = line + last;\n            nextOffset = next - lines[last].length;\n          }\n          else {\n            nextLine   = line;\n            nextOffset = offset;\n          }\n\n          tokens.push(['comment', content,\n            line,     pos  - offset,\n            nextLine, next - nextOffset,\n            pos\n          ]);\n\n          offset = nextOffset;\n          line   = nextLine;\n          pos    = next;\n\n        }\n        else if (code === pound && !alphaNum.test(css.slice(pos + 1, pos + 2))) {\n          next = pos + 1;\n\n          tokens.push(['#', css.slice(pos, next),\n            line, pos  - offset,\n            line, next - offset,\n            pos\n          ]);\n\n          pos = next - 1;\n        }\n        else if ((code === lowerU || code === upperU) && css.charCodeAt(pos + 1) === plus) {\n          next = pos + 2;\n\n          do {\n            next += 1;\n            code = css.charCodeAt(next);\n          } while (next < length && unicodeRange.test(css.slice(next, next + 1)));\n\n          tokens.push(['unicoderange', css.slice(pos, next),\n            line, pos  - offset,\n            line, next - offset,\n            pos\n          ]);\n          pos = next - 1;\n        }\n        // catch a regular slash, that isn't a comment\n        else if (code === slash) {\n          next = pos + 1;\n\n          tokens.push(['operator', css.slice(pos, next),\n            line, pos  - offset,\n            line, next - offset,\n            pos\n          ]);\n\n          pos = next - 1;\n        }\n        else {\n          let regex = wordEnd;\n\n          // we're dealing with a word that starts with a number\n          // those get treated differently\n          if (code >= digit0 && code <= digit9) {\n            regex = wordEndNum;\n          }\n\n          regex.lastIndex = pos + 1;\n          regex.test(css);\n\n          if (regex.lastIndex === 0) {\n            next = css.length - 1;\n          }\n          else {\n            next = regex.lastIndex - 2;\n          }\n\n          // Exponential number notation with minus or plus: 1e-10, 1e+10\n          if (regex === wordEndNum || code === period) {\n            let ncode = css.charCodeAt(next),\n              ncode1 = css.charCodeAt(next + 1),\n              ncode2 = css.charCodeAt(next + 2);\n\n            if (\n              (ncode === lowerE || ncode === upperE) &&\n              (ncode1 === minus || ncode1 === plus) &&\n              (ncode2 >= digit0 && ncode2 <= digit9)\n            ) {\n              wordEndNum.lastIndex = next + 2;\n              wordEndNum.test(css);\n\n              if (wordEndNum.lastIndex === 0) {\n                next = css.length - 1;\n              }\n              else {\n                next = wordEndNum.lastIndex - 2;\n              }\n            }\n          }\n\n          tokens.push(['word', css.slice(pos, next + 1),\n            line, pos  - offset,\n            line, next - offset,\n            pos\n          ]);\n          pos = next;\n        }\n        break;\n    }\n\n    pos ++;\n  }\n\n  return tokens;\n};\n"]},"metadata":{},"sourceType":"script"}