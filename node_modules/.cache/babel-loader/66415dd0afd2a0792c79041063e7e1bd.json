{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ts = require(\"typescript\");\n\nconst node_1 = require(\"../typeguard/node\");\n\nfunction endsControlFlow(statement) {\n  return getControlFlowEnd(statement).end;\n}\n\nexports.endsControlFlow = endsControlFlow;\nconst defaultControlFlowEnd = {\n  statements: [],\n  end: false\n};\n\nfunction getControlFlowEnd(statement) {\n  return node_1.isBlockLike(statement) ? handleBlock(statement) : getControlFlowEndWorker(statement);\n}\n\nexports.getControlFlowEnd = getControlFlowEnd;\n\nfunction getControlFlowEndWorker(statement) {\n  switch (statement.kind) {\n    case ts.SyntaxKind.ReturnStatement:\n    case ts.SyntaxKind.ThrowStatement:\n    case ts.SyntaxKind.ContinueStatement:\n    case ts.SyntaxKind.BreakStatement:\n      return {\n        statements: [statement],\n        end: true\n      };\n\n    case ts.SyntaxKind.Block:\n      return handleBlock(statement);\n\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.WhileStatement:\n      return handleForAndWhileStatement(statement);\n\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.ForInStatement:\n      return handleForInOrOfStatement(statement);\n\n    case ts.SyntaxKind.DoStatement:\n      return matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);\n\n    case ts.SyntaxKind.IfStatement:\n      return handleIfStatement(statement);\n\n    case ts.SyntaxKind.SwitchStatement:\n      return matchBreakOrContinue(handleSwitchStatement(statement), node_1.isBreakStatement);\n\n    case ts.SyntaxKind.TryStatement:\n      return handleTryStatement(statement);\n\n    case ts.SyntaxKind.LabeledStatement:\n      return matchLabel(getControlFlowEndWorker(statement.statement), statement.label);\n\n    case ts.SyntaxKind.WithStatement:\n      return getControlFlowEndWorker(statement.statement);\n\n    default:\n      return defaultControlFlowEnd;\n  }\n}\n\nfunction handleBlock(statement) {\n  const result = {\n    statements: [],\n    end: false\n  };\n\n  for (const s of statement.statements) {\n    const current = getControlFlowEndWorker(s);\n    result.statements.push(...current.statements);\n\n    if (current.end) {\n      result.end = true;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction handleForInOrOfStatement(statement) {\n  const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);\n  end.end = false;\n  return end;\n}\n\nfunction handleForAndWhileStatement(statement) {\n  const constantCondition = statement.kind === ts.SyntaxKind.WhileStatement ? getConstantCondition(statement.expression) : statement.condition === undefined || getConstantCondition(statement.condition);\n  if (constantCondition === false) return defaultControlFlowEnd;\n  const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);\n  if (constantCondition === undefined) end.end = false;\n  return end;\n}\n\nfunction getConstantCondition(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.TrueKeyword:\n      return true;\n\n    case ts.SyntaxKind.FalseKeyword:\n      return false;\n\n    default:\n      return;\n  }\n}\n\nfunction handleIfStatement(node) {\n  switch (getConstantCondition(node.expression)) {\n    case true:\n      return getControlFlowEndWorker(node.thenStatement);\n\n    case false:\n      return node.elseStatement === undefined ? defaultControlFlowEnd : getControlFlowEndWorker(node.elseStatement);\n  }\n\n  const then = getControlFlowEndWorker(node.thenStatement);\n  if (node.elseStatement === undefined) return {\n    statements: then.statements,\n    end: false\n  };\n  const elze = getControlFlowEndWorker(node.elseStatement);\n  return {\n    statements: [...then.statements, ...elze.statements],\n    end: then.end && elze.end\n  };\n}\n\nfunction handleSwitchStatement(node) {\n  let hasDefault = false;\n  const result = {\n    statements: [],\n    end: false\n  };\n\n  for (const clause of node.caseBlock.clauses) {\n    if (clause.kind === ts.SyntaxKind.DefaultClause) hasDefault = true;\n    const current = handleBlock(clause);\n    result.end = current.end;\n    result.statements.push(...current.statements);\n  }\n\n  if (!hasDefault) result.end = false;\n  return result;\n}\n\nfunction handleTryStatement(node) {\n  let finallyResult;\n\n  if (node.finallyBlock !== undefined) {\n    finallyResult = handleBlock(node.finallyBlock);\n    if (finallyResult.end) return finallyResult;\n  }\n\n  const tryResult = handleBlock(node.tryBlock);\n  if (node.catchClause === undefined) return {\n    statements: finallyResult.statements.concat(tryResult.statements),\n    end: tryResult.end\n  };\n  const catchResult = handleBlock(node.catchClause.block);\n  return {\n    statements: tryResult.statements.filter(s => s.kind !== ts.SyntaxKind.ThrowStatement).concat(catchResult.statements, finallyResult === undefined ? [] : finallyResult.statements),\n    end: tryResult.end && catchResult.end\n  };\n}\n\nfunction matchBreakOrContinue(current, pred) {\n  const result = {\n    statements: [],\n    end: current.end\n  };\n\n  for (const statement of current.statements) {\n    if (pred(statement) && statement.label === undefined) {\n      result.end = false;\n      continue;\n    }\n\n    result.statements.push(statement);\n  }\n\n  return result;\n}\n\nfunction matchLabel(current, label) {\n  const result = {\n    statements: [],\n    end: current.end\n  };\n  const labelText = label.text;\n\n  for (const statement of current.statements) {\n    switch (statement.kind) {\n      case ts.SyntaxKind.BreakStatement:\n      case ts.SyntaxKind.ContinueStatement:\n        if (statement.label !== undefined && statement.label.text === labelText) {\n          result.end = false;\n          continue;\n        }\n\n    }\n\n    result.statements.push(statement);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/tsutils/util/control-flow.js"],"names":["Object","defineProperty","exports","value","ts","require","node_1","endsControlFlow","statement","getControlFlowEnd","end","defaultControlFlowEnd","statements","isBlockLike","handleBlock","getControlFlowEndWorker","kind","SyntaxKind","ReturnStatement","ThrowStatement","ContinueStatement","BreakStatement","Block","ForStatement","WhileStatement","handleForAndWhileStatement","ForOfStatement","ForInStatement","handleForInOrOfStatement","DoStatement","matchBreakOrContinue","isBreakOrContinueStatement","IfStatement","handleIfStatement","SwitchStatement","handleSwitchStatement","isBreakStatement","TryStatement","handleTryStatement","LabeledStatement","matchLabel","label","WithStatement","result","s","current","push","constantCondition","getConstantCondition","expression","condition","undefined","node","TrueKeyword","FalseKeyword","thenStatement","elseStatement","then","elze","hasDefault","clause","caseBlock","clauses","DefaultClause","finallyResult","finallyBlock","tryResult","tryBlock","catchClause","concat","catchResult","block","filter","pred","labelText","text"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ts = require(\"typescript\");\nconst node_1 = require(\"../typeguard/node\");\nfunction endsControlFlow(statement) {\n    return getControlFlowEnd(statement).end;\n}\nexports.endsControlFlow = endsControlFlow;\nconst defaultControlFlowEnd = { statements: [], end: false };\nfunction getControlFlowEnd(statement) {\n    return node_1.isBlockLike(statement) ? handleBlock(statement) : getControlFlowEndWorker(statement);\n}\nexports.getControlFlowEnd = getControlFlowEnd;\nfunction getControlFlowEndWorker(statement) {\n    switch (statement.kind) {\n        case ts.SyntaxKind.ReturnStatement:\n        case ts.SyntaxKind.ThrowStatement:\n        case ts.SyntaxKind.ContinueStatement:\n        case ts.SyntaxKind.BreakStatement:\n            return { statements: [statement], end: true };\n        case ts.SyntaxKind.Block:\n            return handleBlock(statement);\n        case ts.SyntaxKind.ForStatement:\n        case ts.SyntaxKind.WhileStatement:\n            return handleForAndWhileStatement(statement);\n        case ts.SyntaxKind.ForOfStatement:\n        case ts.SyntaxKind.ForInStatement:\n            return handleForInOrOfStatement(statement);\n        case ts.SyntaxKind.DoStatement:\n            return matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);\n        case ts.SyntaxKind.IfStatement:\n            return handleIfStatement(statement);\n        case ts.SyntaxKind.SwitchStatement:\n            return matchBreakOrContinue(handleSwitchStatement(statement), node_1.isBreakStatement);\n        case ts.SyntaxKind.TryStatement:\n            return handleTryStatement(statement);\n        case ts.SyntaxKind.LabeledStatement:\n            return matchLabel(getControlFlowEndWorker(statement.statement), statement.label);\n        case ts.SyntaxKind.WithStatement:\n            return getControlFlowEndWorker(statement.statement);\n        default:\n            return defaultControlFlowEnd;\n    }\n}\nfunction handleBlock(statement) {\n    const result = { statements: [], end: false };\n    for (const s of statement.statements) {\n        const current = getControlFlowEndWorker(s);\n        result.statements.push(...current.statements);\n        if (current.end) {\n            result.end = true;\n            break;\n        }\n    }\n    return result;\n}\nfunction handleForInOrOfStatement(statement) {\n    const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);\n    end.end = false;\n    return end;\n}\nfunction handleForAndWhileStatement(statement) {\n    const constantCondition = statement.kind === ts.SyntaxKind.WhileStatement\n        ? getConstantCondition(statement.expression)\n        : statement.condition === undefined || getConstantCondition(statement.condition);\n    if (constantCondition === false)\n        return defaultControlFlowEnd;\n    const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);\n    if (constantCondition === undefined)\n        end.end = false;\n    return end;\n}\nfunction getConstantCondition(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.TrueKeyword:\n            return true;\n        case ts.SyntaxKind.FalseKeyword:\n            return false;\n        default:\n            return;\n    }\n}\nfunction handleIfStatement(node) {\n    switch (getConstantCondition(node.expression)) {\n        case true:\n            return getControlFlowEndWorker(node.thenStatement);\n        case false:\n            return node.elseStatement === undefined\n                ? defaultControlFlowEnd\n                : getControlFlowEndWorker(node.elseStatement);\n    }\n    const then = getControlFlowEndWorker(node.thenStatement);\n    if (node.elseStatement === undefined)\n        return {\n            statements: then.statements,\n            end: false,\n        };\n    const elze = getControlFlowEndWorker(node.elseStatement);\n    return {\n        statements: [...then.statements, ...elze.statements],\n        end: then.end && elze.end,\n    };\n}\nfunction handleSwitchStatement(node) {\n    let hasDefault = false;\n    const result = {\n        statements: [],\n        end: false,\n    };\n    for (const clause of node.caseBlock.clauses) {\n        if (clause.kind === ts.SyntaxKind.DefaultClause)\n            hasDefault = true;\n        const current = handleBlock(clause);\n        result.end = current.end;\n        result.statements.push(...current.statements);\n    }\n    if (!hasDefault)\n        result.end = false;\n    return result;\n}\nfunction handleTryStatement(node) {\n    let finallyResult;\n    if (node.finallyBlock !== undefined) {\n        finallyResult = handleBlock(node.finallyBlock);\n        if (finallyResult.end)\n            return finallyResult;\n    }\n    const tryResult = handleBlock(node.tryBlock);\n    if (node.catchClause === undefined)\n        return { statements: finallyResult.statements.concat(tryResult.statements), end: tryResult.end };\n    const catchResult = handleBlock(node.catchClause.block);\n    return {\n        statements: tryResult.statements\n            .filter((s) => s.kind !== ts.SyntaxKind.ThrowStatement)\n            .concat(catchResult.statements, finallyResult === undefined ? [] : finallyResult.statements),\n        end: tryResult.end && catchResult.end,\n    };\n}\nfunction matchBreakOrContinue(current, pred) {\n    const result = {\n        statements: [],\n        end: current.end,\n    };\n    for (const statement of current.statements) {\n        if (pred(statement) && statement.label === undefined) {\n            result.end = false;\n            continue;\n        }\n        result.statements.push(statement);\n    }\n    return result;\n}\nfunction matchLabel(current, label) {\n    const result = {\n        statements: [],\n        end: current.end,\n    };\n    const labelText = label.text;\n    for (const statement of current.statements) {\n        switch (statement.kind) {\n            case ts.SyntaxKind.BreakStatement:\n            case ts.SyntaxKind.ContinueStatement:\n                if (statement.label !== undefined && statement.label.text === labelText) {\n                    result.end = false;\n                    continue;\n                }\n        }\n        result.statements.push(statement);\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"script"}