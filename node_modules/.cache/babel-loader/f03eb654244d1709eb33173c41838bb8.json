{"ast":null,"code":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\"use strict\";\n\nconst {\n  escapeRegExp\n} = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified warning terms in comments\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          configuration = context.options[0] || {},\n          warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n          location = configuration.location || \"start\",\n          selfConfigRegEx = /\\bno-warning-comments\\b/u;\n    /**\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n     * require word boundaries on that side.\n     * @param {string} term A term to convert to a RegExp\n     * @returns {RegExp} The term converted to a RegExp\n     */\n\n    function convertToRegExp(term) {\n      const escaped = escapeRegExp(term);\n      const wordBoundary = \"\\\\b\";\n      const eitherOrWordBoundary = `|${wordBoundary}`;\n      let prefix;\n      /*\n       * If the term ends in a word character (a-z0-9_), ensure a word\n       * boundary at the end, so that substrings do not get falsely\n       * matched. eg \"todo\" in a string such as \"mastodon\".\n       * If the term ends in a non-word character, then \\b won't match on\n       * the boundary to the next non-word character, which would likely\n       * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n       * In these cases, use no bounding match. Same applies for the\n       * prefix, handled below.\n       */\n\n      const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n      if (location === \"start\") {\n        /*\n         * When matching at the start, ignore leading whitespace, and\n         * there's no need to worry about word boundaries.\n         */\n        prefix = \"^\\\\s*\";\n      } else if (/^\\w/u.test(term)) {\n        prefix = wordBoundary;\n      } else {\n        prefix = \"\";\n      }\n\n      if (location === \"start\") {\n        /*\n         * For location \"start\" the regex should be\n         * ^\\s*TERM\\b.  This checks the word boundary\n         * at the beginning of the comment.\n         */\n        return new RegExp(prefix + escaped + suffix, \"iu\");\n      }\n      /*\n       * For location \"anywhere\" the regex should be\n       * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n       * for the term.\n       */\n\n\n      return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, \"iu\");\n    }\n\n    const warningRegExps = warningTerms.map(convertToRegExp);\n    /**\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\n     * @param {string} comment The comment which is checked.\n     * @returns {Array} All matched warning terms for this comment.\n     */\n\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n    /**\n     * Checks the specified node for matching warning comments and reports them.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {void} undefined.\n     */\n\n\n    function checkComment(node) {\n      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n        return;\n      }\n\n      const matches = commentContainsWarningTerm(node.value);\n      matches.forEach(matchedTerm => {\n        context.report({\n          node,\n          message: \"Unexpected '{{matchedTerm}}' comment.\",\n          data: {\n            matchedTerm\n          }\n        });\n      });\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-warning-comments.js"],"names":["escapeRegExp","require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","terms","items","location","enum","additionalProperties","create","context","sourceCode","getSourceCode","configuration","options","warningTerms","selfConfigRegEx","convertToRegExp","term","escaped","wordBoundary","eitherOrWordBoundary","prefix","suffix","test","RegExp","warningRegExps","map","commentContainsWarningTerm","comment","matches","forEach","regex","index","push","checkComment","node","isDirectiveComment","value","matchedTerm","report","message","data","Program","comments","getAllComments","filter","token"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst { escapeRegExp } = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n            const wordBoundary = \"\\\\b\";\n            const eitherOrWordBoundary = `|${wordBoundary}`;\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            } else {\n                prefix = \"\";\n            }\n\n            if (location === \"start\") {\n\n                /*\n                 * For location \"start\" the regex should be\n                 * ^\\s*TERM\\b.  This checks the word boundary\n                 * at the beginning of the comment.\n                 */\n                return new RegExp(prefix + escaped + suffix, \"iu\");\n            }\n\n            /*\n             * For location \"anywhere\" the regex should be\n             * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n             * for the term.\n             */\n            return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, \"iu\");\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(node.value);\n\n            matches.forEach(matchedTerm => {\n                context.report({\n                    node,\n                    message: \"Unexpected '{{matchedTerm}}' comment.\",\n                    data: {\n                        matchedTerm\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}