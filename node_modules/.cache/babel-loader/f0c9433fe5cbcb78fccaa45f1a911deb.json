{"ast":null,"code":"import postcss from 'postcss';\nimport parser from 'postcss-values-parser';\nimport { lab2rgb } from '@csstools/convert-colors';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar index = postcss.plugin('postcss-color-gray', opts => root => {\n  // walk all declarations likely containing a gray() function\n  root.walkDecls(decl => {\n    if (hasGrayFunction(decl)) {\n      const originalValue = decl.value; // parse the declaration value\n\n      const ast = parser(originalValue).parse(); // walk every node in the value that contains a gray() function\n\n      ast.walk(node => {\n        const _getFunctionGrayArgs = getFunctionGrayArgs(node),\n              _getFunctionGrayArgs2 = _slicedToArray(_getFunctionGrayArgs, 2),\n              lightness = _getFunctionGrayArgs2[0],\n              alpha = _getFunctionGrayArgs2[1];\n\n        if (lightness !== undefined) {\n          // rename the gray() function to rgb()\n          node.value = 'rgb'; // convert the lab gray lightness into rgb\n\n          const _lab2rgb$map = lab2rgb(lightness, 0, 0).map(channel => Math.max(Math.min(Math.round(channel * 2.55), 255), 0)),\n                _lab2rgb$map2 = _slicedToArray(_lab2rgb$map, 3),\n                r = _lab2rgb$map2[0],\n                g = _lab2rgb$map2[1],\n                b = _lab2rgb$map2[2]; // preserve the slash nodes within rgb()\n\n\n          const openingSlash = node.first;\n          const closingSlash = node.last;\n          node.removeAll() // replace the contents of rgb with `(r,g,b`\n          .append(openingSlash).append(parser.number({\n            value: r\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: g\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: b\n          })); // if an alpha channel was defined\n\n          if (alpha < 1) {\n            // rename the rgb() function to rgba()\n            node.value += 'a';\n            node // append the contents of rgba with `,a`\n            .append(parser.comma({\n              value: ','\n            })).append(parser.number({\n              value: alpha\n            }));\n          } // append the contents of rgb/rgba with `)`\n\n\n          node.append(closingSlash);\n        }\n      });\n      const modifiedValue = ast.toString(); // if the modified value has changed from the original value\n\n      if (originalValue !== modifiedValue) {\n        // if the original gray() color is to be preserved\n        if (Object(opts).preserve) {\n          // insert the declaration value with the fallback before the current declaration\n          decl.cloneBefore({\n            value: modifiedValue\n          });\n        } else {\n          // otherwise, overwrite the declaration value with the fallback\n          decl.value = modifiedValue;\n        }\n      }\n    }\n  });\n}); // return whether a string contains a gray() function\n\nconst hasGrayFunctionRegExp = /(^|[^\\w-])gray\\(/i;\n\nconst hasGrayFunction = decl => hasGrayFunctionRegExp.test(Object(decl).value); // return whether a node matches a specific type\n\n\nconst isNumber = node => Object(node).type === 'number';\n\nconst isOperator = node => Object(node).type === 'operator';\n\nconst isFunction = node => Object(node).type === 'func';\n\nconst isCalcRegExp = /^calc$/i;\n\nconst isFunctionCalc = node => isFunction(node) && isCalcRegExp.test(node.value);\n\nconst isGrayRegExp = /^gray$/i;\n\nconst isFunctionGrayWithArgs = node => isFunction(node) && isGrayRegExp.test(node.value) && node.nodes && node.nodes.length;\n\nconst isNumberPercentage = node => isNumber(node) && node.unit === '%';\n\nconst isNumberUnitless = node => isNumber(node) && node.unit === '';\n\nconst isOperatorSlash = node => isOperator(node) && node.value === '/'; // return valid values from a node, otherwise undefined\n\n\nconst getNumberUnitless = node => isNumberUnitless(node) ? Number(node.value) : undefined;\n\nconst getOperatorSlash = node => isOperatorSlash(node) ? null : undefined;\n\nconst getAlpha = node => isFunctionCalc(node) ? String(node) : isNumberUnitless(node) ? Number(node.value) : isNumberPercentage(node) ? Number(node.value) / 100 : undefined; // return valid arguments from a gray() function\n\n\nconst functionalGrayArgs = [getNumberUnitless, getOperatorSlash, getAlpha];\n\nconst getFunctionGrayArgs = node => {\n  const validArgs = []; // if the node is a gray() function with arguments\n\n  if (isFunctionGrayWithArgs(node)) {\n    // get all the gray() function arguments between `(` and `)`\n    const nodes = node.nodes.slice(1, -1); // validate each argument\n\n    for (const index in nodes) {\n      const arg = typeof functionalGrayArgs[index] === 'function' ? functionalGrayArgs[index](nodes[index]) : undefined; // if the argument was validated\n\n      if (arg !== undefined) {\n        // push any non-null argument to the valid arguments array\n        if (arg !== null) {\n          validArgs.push(arg);\n        }\n      } else {\n        // otherwise, return an empty array\n        return [];\n      }\n    } // return the valid arguments array\n\n\n    return validArgs;\n  } else {\n    // otherwise, return an empty array\n    return [];\n  }\n};\n\nexport default index;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-color-gray/index.es.js"],"names":["postcss","parser","lab2rgb","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","Array","isArray","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","TypeError","index","plugin","opts","root","walkDecls","decl","hasGrayFunction","originalValue","ast","parse","walk","node","_getFunctionGrayArgs","getFunctionGrayArgs","_getFunctionGrayArgs2","lightness","alpha","_lab2rgb$map","map","channel","Math","max","min","round","_lab2rgb$map2","r","g","b","openingSlash","first","closingSlash","last","removeAll","append","number","comma","modifiedValue","toString","Object","preserve","cloneBefore","hasGrayFunctionRegExp","test","isNumber","type","isOperator","isFunction","isCalcRegExp","isFunctionCalc","isGrayRegExp","isFunctionGrayWithArgs","nodes","isNumberPercentage","unit","isNumberUnitless","isOperatorSlash","getNumberUnitless","Number","getOperatorSlash","getAlpha","String","functionalGrayArgs","validArgs","slice","arg"],"mappings":"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","sourcesContent":["import postcss from 'postcss';\nimport parser from 'postcss-values-parser';\nimport { lab2rgb } from '@csstools/convert-colors';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar index = postcss.plugin('postcss-color-gray', opts => root => {\n  // walk all declarations likely containing a gray() function\n  root.walkDecls(decl => {\n    if (hasGrayFunction(decl)) {\n      const originalValue = decl.value; // parse the declaration value\n\n      const ast = parser(originalValue).parse(); // walk every node in the value that contains a gray() function\n\n      ast.walk(node => {\n        const _getFunctionGrayArgs = getFunctionGrayArgs(node),\n              _getFunctionGrayArgs2 = _slicedToArray(_getFunctionGrayArgs, 2),\n              lightness = _getFunctionGrayArgs2[0],\n              alpha = _getFunctionGrayArgs2[1];\n\n        if (lightness !== undefined) {\n          // rename the gray() function to rgb()\n          node.value = 'rgb'; // convert the lab gray lightness into rgb\n\n          const _lab2rgb$map = lab2rgb(lightness, 0, 0).map(channel => Math.max(Math.min(Math.round(channel * 2.55), 255), 0)),\n                _lab2rgb$map2 = _slicedToArray(_lab2rgb$map, 3),\n                r = _lab2rgb$map2[0],\n                g = _lab2rgb$map2[1],\n                b = _lab2rgb$map2[2]; // preserve the slash nodes within rgb()\n\n\n          const openingSlash = node.first;\n          const closingSlash = node.last;\n          node.removeAll() // replace the contents of rgb with `(r,g,b`\n          .append(openingSlash).append(parser.number({\n            value: r\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: g\n          })).append(parser.comma({\n            value: ','\n          })).append(parser.number({\n            value: b\n          })); // if an alpha channel was defined\n\n          if (alpha < 1) {\n            // rename the rgb() function to rgba()\n            node.value += 'a';\n            node // append the contents of rgba with `,a`\n            .append(parser.comma({\n              value: ','\n            })).append(parser.number({\n              value: alpha\n            }));\n          } // append the contents of rgb/rgba with `)`\n\n\n          node.append(closingSlash);\n        }\n      });\n      const modifiedValue = ast.toString(); // if the modified value has changed from the original value\n\n      if (originalValue !== modifiedValue) {\n        // if the original gray() color is to be preserved\n        if (Object(opts).preserve) {\n          // insert the declaration value with the fallback before the current declaration\n          decl.cloneBefore({\n            value: modifiedValue\n          });\n        } else {\n          // otherwise, overwrite the declaration value with the fallback\n          decl.value = modifiedValue;\n        }\n      }\n    }\n  });\n}); // return whether a string contains a gray() function\n\nconst hasGrayFunctionRegExp = /(^|[^\\w-])gray\\(/i;\n\nconst hasGrayFunction = decl => hasGrayFunctionRegExp.test(Object(decl).value); // return whether a node matches a specific type\n\n\nconst isNumber = node => Object(node).type === 'number';\n\nconst isOperator = node => Object(node).type === 'operator';\n\nconst isFunction = node => Object(node).type === 'func';\n\nconst isCalcRegExp = /^calc$/i;\n\nconst isFunctionCalc = node => isFunction(node) && isCalcRegExp.test(node.value);\n\nconst isGrayRegExp = /^gray$/i;\n\nconst isFunctionGrayWithArgs = node => isFunction(node) && isGrayRegExp.test(node.value) && node.nodes && node.nodes.length;\n\nconst isNumberPercentage = node => isNumber(node) && node.unit === '%';\n\nconst isNumberUnitless = node => isNumber(node) && node.unit === '';\n\nconst isOperatorSlash = node => isOperator(node) && node.value === '/'; // return valid values from a node, otherwise undefined\n\n\nconst getNumberUnitless = node => isNumberUnitless(node) ? Number(node.value) : undefined;\n\nconst getOperatorSlash = node => isOperatorSlash(node) ? null : undefined;\n\nconst getAlpha = node => isFunctionCalc(node) ? String(node) : isNumberUnitless(node) ? Number(node.value) : isNumberPercentage(node) ? Number(node.value) / 100 : undefined; // return valid arguments from a gray() function\n\n\nconst functionalGrayArgs = [getNumberUnitless, getOperatorSlash, getAlpha];\n\nconst getFunctionGrayArgs = node => {\n  const validArgs = []; // if the node is a gray() function with arguments\n\n  if (isFunctionGrayWithArgs(node)) {\n    // get all the gray() function arguments between `(` and `)`\n    const nodes = node.nodes.slice(1, -1); // validate each argument\n\n    for (const index in nodes) {\n      const arg = typeof functionalGrayArgs[index] === 'function' ? functionalGrayArgs[index](nodes[index]) : undefined; // if the argument was validated\n\n      if (arg !== undefined) {\n        // push any non-null argument to the valid arguments array\n        if (arg !== null) {\n          validArgs.push(arg);\n        }\n      } else {\n        // otherwise, return an empty array\n        return [];\n      }\n    } // return the valid arguments array\n\n\n    return validArgs;\n  } else {\n    // otherwise, return an empty array\n    return [];\n  }\n};\n\nexport default index;\n"]},"metadata":{},"sourceType":"module"}