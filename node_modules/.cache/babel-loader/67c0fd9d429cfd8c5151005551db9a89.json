{"ast":null,"code":"/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n * @deprecated in ESLint v3.9.0\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `Reflect` methods where applicable\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-reflect\"\n    },\n    deprecated: true,\n    replacedBy: [],\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            enum: [\"apply\", \"call\", \"delete\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"getPrototypeOf\", \"setPrototypeOf\", \"isExtensible\", \"getOwnPropertyNames\", \"preventExtensions\"]\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const existingNames = {\n      apply: \"Function.prototype.apply\",\n      call: \"Function.prototype.call\",\n      defineProperty: \"Object.defineProperty\",\n      getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n      getPrototypeOf: \"Object.getPrototypeOf\",\n      setPrototypeOf: \"Object.setPrototypeOf\",\n      isExtensible: \"Object.isExtensible\",\n      getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n      preventExtensions: \"Object.preventExtensions\"\n    };\n    const reflectSubsitutes = {\n      apply: \"Reflect.apply\",\n      call: \"Reflect.apply\",\n      defineProperty: \"Reflect.defineProperty\",\n      getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n      getPrototypeOf: \"Reflect.getPrototypeOf\",\n      setPrototypeOf: \"Reflect.setPrototypeOf\",\n      isExtensible: \"Reflect.isExtensible\",\n      getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n      preventExtensions: \"Reflect.preventExtensions\"\n    };\n    const exceptions = (context.options[0] || {}).exceptions || [];\n    /**\n     * Reports the Reflect violation based on the `existing` and `substitute`\n     * @param {Object} node The node that violates the rule.\n     * @param {string} existing The existing method name that has been used.\n     * @param {string} substitute The Reflect substitute that should be used.\n     * @returns {void}\n     */\n\n    function report(node, existing, substitute) {\n      context.report({\n        node,\n        message: \"Avoid using {{existing}}, instead use {{substitute}}.\",\n        data: {\n          existing,\n          substitute\n        }\n      });\n    }\n\n    return {\n      CallExpression(node) {\n        const methodName = (node.callee.property || {}).name;\n        const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n        const hasReflectSubsitute = Object.prototype.hasOwnProperty.call(reflectSubsitutes, methodName);\n        const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n        if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {\n          report(node, existingNames[methodName], reflectSubsitutes[methodName]);\n        }\n      },\n\n      UnaryExpression(node) {\n        const isDeleteOperator = node.operator === \"delete\";\n        const targetsIdentifier = node.argument.type === \"Identifier\";\n        const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n        if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n          report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-reflect.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","deprecated","replacedBy","schema","properties","exceptions","items","enum","uniqueItems","additionalProperties","create","context","existingNames","apply","call","defineProperty","getOwnPropertyDescriptor","getPrototypeOf","setPrototypeOf","isExtensible","getOwnPropertyNames","preventExtensions","reflectSubsitutes","options","report","node","existing","substitute","message","data","CallExpression","methodName","callee","property","name","isReflectCall","object","hasReflectSubsitute","Object","prototype","hasOwnProperty","userConfiguredException","indexOf","UnaryExpression","isDeleteOperator","operator","targetsIdentifier","argument"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n * @deprecated in ESLint v3.9.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `Reflect` methods where applicable\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-reflect\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [],\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\n                                \"apply\",\n                                \"call\",\n                                \"delete\",\n                                \"defineProperty\",\n                                \"getOwnPropertyDescriptor\",\n                                \"getPrototypeOf\",\n                                \"setPrototypeOf\",\n                                \"isExtensible\",\n                                \"getOwnPropertyNames\",\n                                \"preventExtensions\"\n                            ]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const existingNames = {\n            apply: \"Function.prototype.apply\",\n            call: \"Function.prototype.call\",\n            defineProperty: \"Object.defineProperty\",\n            getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Object.getPrototypeOf\",\n            setPrototypeOf: \"Object.setPrototypeOf\",\n            isExtensible: \"Object.isExtensible\",\n            getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n            preventExtensions: \"Object.preventExtensions\"\n        };\n\n        const reflectSubsitutes = {\n            apply: \"Reflect.apply\",\n            call: \"Reflect.apply\",\n            defineProperty: \"Reflect.defineProperty\",\n            getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Reflect.getPrototypeOf\",\n            setPrototypeOf: \"Reflect.setPrototypeOf\",\n            isExtensible: \"Reflect.isExtensible\",\n            getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n            preventExtensions: \"Reflect.preventExtensions\"\n        };\n\n        const exceptions = (context.options[0] || {}).exceptions || [];\n\n        /**\n         * Reports the Reflect violation based on the `existing` and `substitute`\n         * @param {Object} node The node that violates the rule.\n         * @param {string} existing The existing method name that has been used.\n         * @param {string} substitute The Reflect substitute that should be used.\n         * @returns {void}\n         */\n        function report(node, existing, substitute) {\n            context.report({\n                node,\n                message: \"Avoid using {{existing}}, instead use {{substitute}}.\",\n                data: {\n                    existing,\n                    substitute\n                }\n            });\n        }\n\n        return {\n            CallExpression(node) {\n                const methodName = (node.callee.property || {}).name;\n                const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n                const hasReflectSubsitute = Object.prototype.hasOwnProperty.call(reflectSubsitutes, methodName);\n                const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {\n                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);\n                }\n            },\n            UnaryExpression(node) {\n                const isDeleteOperator = node.operator === \"delete\";\n                const targetsIdentifier = node.argument.type === \"Identifier\";\n                const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n                    report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}