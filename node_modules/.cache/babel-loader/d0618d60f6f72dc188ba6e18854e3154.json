{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.precaching = function (exports, assert_mjs, cacheNames_mjs, getFriendlyURL_mjs, logger_mjs, cacheWrapper_mjs, fetchWrapper_mjs, WorkboxError_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:precaching:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const plugins = [];\n  const precachePlugins = {\n    /*\n     * @return {Array}\n     * @private\n     */\n    get() {\n      return plugins;\n    },\n\n    /*\n     * @param {Array} newPlugins\n     * @private\n     */\n    add(newPlugins) {\n      plugins.push(...newPlugins);\n    }\n\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Adds plugins to precaching.\n   *\n   * @param {Array<Object>} newPlugins\n   *\n   * @alias workbox.precaching.addPlugins\n   */\n\n  const addPlugins = newPlugins => {\n    precachePlugins.add(newPlugins);\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * @param {Response} response\n   * @return {Response}\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  async function cleanRedirect(response) {\n    const clonedResponse = response.clone(); // Not all browsers support the Response.body stream, so fall back\n    // to reading the entire body into memory as a blob.\n\n    const bodyPromise = 'body' in clonedResponse ? Promise.resolve(clonedResponse.body) : clonedResponse.blob();\n    const body = await bodyPromise; // new Response() is happy when passed either a stream or a Blob.\n\n    return new Response(body, {\n      headers: clonedResponse.headers,\n      status: clonedResponse.status,\n      statusText: clonedResponse.statusText\n    });\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const REVISION_SEARCH_PARAM = '__WB_REVISION__';\n  /**\n   * Converts a manifest entry into a versioned URL suitable for precaching.\n   *\n   * @param {Object} entry\n   * @return {string} A URL with versioning info.\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  function createCacheKey(entry) {\n    if (!entry) {\n      throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-unexpected-type', {\n        entry\n      });\n    } // If a precache manifest entry is a string, it's assumed to be a versioned\n    // URL, like '/app.abcd1234.js'. Return as-is.\n\n\n    if (typeof entry === 'string') {\n      const urlObject = new URL(entry, location);\n      return {\n        cacheKey: urlObject.href,\n        url: urlObject.href\n      };\n    }\n\n    const {\n      revision,\n      url\n    } = entry;\n\n    if (!url) {\n      throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-unexpected-type', {\n        entry\n      });\n    } // If there's just a URL and no revision, then it's also assumed to be a\n    // versioned URL.\n\n\n    if (!revision) {\n      const urlObject = new URL(url, location);\n      return {\n        cacheKey: urlObject.href,\n        url: urlObject.href\n      };\n    } // Otherwise, construct a properly versioned URL using the custom Workbox\n    // search parameter along with the revision info.\n\n\n    const originalURL = new URL(url, location);\n    const cacheKeyURL = new URL(url, location);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n      cacheKey: cacheKeyURL.href,\n      url: originalURL.href\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const logGroup = (groupTitle, deletedURLs) => {\n    logger_mjs.logger.groupCollapsed(groupTitle);\n\n    for (const url of deletedURLs) {\n      logger_mjs.logger.log(url);\n    }\n\n    logger_mjs.logger.groupEnd();\n  };\n  /**\n   * @param {Array<string>} deletedURLs\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  function printCleanupDetails(deletedURLs) {\n    const deletionCount = deletedURLs.length;\n\n    if (deletionCount > 0) {\n      logger_mjs.logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n      logGroup('Deleted Cache Requests', deletedURLs);\n      logger_mjs.logger.groupEnd();\n    }\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * @param {string} groupTitle\n   * @param {Array<string>} urls\n   *\n   * @private\n   */\n\n\n  function _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n      return;\n    }\n\n    logger_mjs.logger.groupCollapsed(groupTitle);\n\n    for (const url of urls) {\n      logger_mjs.logger.log(url);\n    }\n\n    logger_mjs.logger.groupEnd();\n  }\n  /**\n   * @param {Array<string>} urlsToPrecache\n   * @param {Array<string>} urlsAlreadyPrecached\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n\n    if (precachedCount || alreadyPrecachedCount) {\n      let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n\n      if (alreadyPrecachedCount > 0) {\n        message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n      }\n\n      logger_mjs.logger.groupCollapsed(message);\n\n      _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n\n      _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n\n      logger_mjs.logger.groupEnd();\n    }\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Performs efficient precaching of assets.\n   *\n   * @memberof module:workbox-precaching\n   */\n\n\n  class PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n      this._cacheName = cacheNames_mjs.cacheNames.getPrecacheName(cacheName);\n      this._urlsToCacheKeys = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n\n\n    addToCacheList(entries) {\n      {\n        assert_mjs.assert.isArray(entries, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'addToCacheList',\n          paramName: 'entries'\n        });\n      }\n\n      for (const entry of entries) {\n        const {\n          cacheKey,\n          url\n        } = createCacheKey(entry);\n\n        if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n          throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-conflicting-entries', {\n            firstEntry: this._urlsToCacheKeys.get(url),\n            secondEntry: cacheKey\n          });\n        }\n\n        this._urlsToCacheKeys.set(url, cacheKey);\n      }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<workbox.precaching.InstallResult>}\n     */\n\n\n    async install({\n      event,\n      plugins\n    } = {}) {\n      {\n        if (plugins) {\n          assert_mjs.assert.isArray(plugins, {\n            moduleName: 'workbox-precaching',\n            className: 'PrecacheController',\n            funcName: 'install',\n            paramName: 'plugins'\n          });\n        }\n      }\n      const urlsToPrecache = [];\n      const urlsAlreadyPrecached = [];\n      const cache = await caches.open(this._cacheName);\n      const alreadyCachedRequests = await cache.keys();\n      const alreadyCachedURLs = new Set(alreadyCachedRequests.map(request => request.url));\n\n      for (const cacheKey of this._urlsToCacheKeys.values()) {\n        if (alreadyCachedURLs.has(cacheKey)) {\n          urlsAlreadyPrecached.push(cacheKey);\n        } else {\n          urlsToPrecache.push(cacheKey);\n        }\n      }\n\n      const precacheRequests = urlsToPrecache.map(url => {\n        return this._addURLToCache({\n          event,\n          plugins,\n          url\n        });\n      });\n      await Promise.all(precacheRequests);\n      {\n        printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n      }\n      return {\n        updatedURLs: urlsToPrecache,\n        notUpdatedURLs: urlsAlreadyPrecached\n      };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<workbox.precaching.CleanupResult>}\n     */\n\n\n    async activate() {\n      const cache = await caches.open(this._cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n\n      {\n        printCleanupDetails(deletedURLs);\n      }\n      return {\n        deletedURLs\n      };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     */\n\n\n    async _addURLToCache({\n      url,\n      event,\n      plugins\n    }) {\n      const request = new Request(url, {\n        credentials: 'same-origin'\n      });\n      let response = await fetchWrapper_mjs.fetchWrapper.fetch({\n        event,\n        plugins,\n        request\n      }); // Allow developers to override the default logic about what is and isn't\n      // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n      // a workbox.cacheableResponse.Plugin instance.\n\n      let cacheWillUpdateCallback;\n\n      for (const plugin of plugins || []) {\n        if ('cacheWillUpdate' in plugin) {\n          cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n        }\n      }\n\n      const isValidResponse = cacheWillUpdateCallback ? // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({\n        event,\n        request,\n        response\n      }) : // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400; // Consider this a failure, leading to the `install` handler failing, if\n      // we get back an invalid response.\n\n      if (!isValidResponse) {\n        throw new WorkboxError_mjs.WorkboxError('bad-precaching-response', {\n          url,\n          status: response.status\n        });\n      }\n\n      if (response.redirected) {\n        response = await cleanRedirect(response);\n      }\n\n      await cacheWrapper_mjs.cacheWrapper.put({\n        event,\n        plugins,\n        request,\n        response,\n        cacheName: this._cacheName,\n        matchOptions: {\n          ignoreSearch: true\n        }\n      });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n\n\n    getURLsToCacheKeys() {\n      return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n\n\n    getCachedURLs() {\n      return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n\n\n    getCacheKeyForURL(url) {\n      const urlObject = new URL(url, location);\n      return this._urlsToCacheKeys.get(urlObject.href);\n    }\n\n  }\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  let precacheController;\n  /**\n   * @return {PrecacheController}\n   * @private\n   */\n\n  const getOrCreatePrecacheController = () => {\n    if (!precacheController) {\n      precacheController = new PrecacheController();\n    }\n\n    return precacheController;\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Removes any URL search parameters that should be ignored.\n   *\n   * @param {URL} urlObject The original URL.\n   * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n   * each search parameter name. Matches mean that the search parameter should be\n   * ignored.\n   * @return {URL} The URL with any ignored search parameters removed.\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching) {\n    // Convert the iterable into an array at the start of the loop to make sure\n    // deletion doesn't mess up iteration.\n    for (const paramName of [...urlObject.searchParams.keys()]) {\n      if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n        urlObject.searchParams.delete(paramName);\n      }\n    }\n\n    return urlObject;\n  }\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Generator function that yields possible variations on the original URL to\n   * check, one at a time.\n   *\n   * @param {string} url\n   * @param {Object} options\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n\n  function* generateURLVariations(url, {\n    ignoreURLParametersMatching,\n    directoryIndex,\n    cleanURLs,\n    urlManipulation\n  } = {}) {\n    const urlObject = new URL(url, location);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n      const directoryURL = new URL(urlWithoutIgnoredParams);\n      directoryURL.pathname += directoryIndex;\n      yield directoryURL.href;\n    }\n\n    if (cleanURLs) {\n      const cleanURL = new URL(urlWithoutIgnoredParams);\n      cleanURL.pathname += '.html';\n      yield cleanURL.href;\n    }\n\n    if (urlManipulation) {\n      const additionalURLs = urlManipulation({\n        url: urlObject\n      });\n\n      for (const urlToAttempt of additionalURLs) {\n        yield urlToAttempt.href;\n      }\n    }\n  }\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This function will take the request URL and manipulate it based on the\n   * configuration options.\n   *\n   * @param {string} url\n   * @param {Object} options\n   * @return {string} Returns the URL in the cache that matches the request,\n   * if possible.\n   *\n   * @private\n   */\n\n\n  const getCacheKeyForURL = (url, options) => {\n    const precacheController = getOrCreatePrecacheController();\n    const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n\n    for (const possibleURL of generateURLVariations(url, options)) {\n      const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n\n      if (possibleCacheKey) {\n        return possibleCacheKey;\n      }\n    }\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Adds a `fetch` listener to the service worker that will\n   * respond to\n   * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n   * with precached assets.\n   *\n   * Requests for assets that aren't precached, the `FetchEvent` will not be\n   * responded to, allowing the event to fall through to other `fetch` event\n   * listeners.\n   *\n   * NOTE: when called more than once this method will replace the previously set\n   * configuration options. Calling it more than once is not recommended outside\n   * of tests.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URL's that should be checked for precache matches.\n   */\n\n\n  const addFetchListener = ({\n    ignoreURLParametersMatching = [/^utm_/],\n    directoryIndex = 'index.html',\n    cleanURLs = true,\n    urlManipulation = null\n  } = {}) => {\n    const cacheName = cacheNames_mjs.cacheNames.getPrecacheName();\n    addEventListener('fetch', event => {\n      const precachedURL = getCacheKeyForURL(event.request.url, {\n        cleanURLs,\n        directoryIndex,\n        ignoreURLParametersMatching,\n        urlManipulation\n      });\n\n      if (!precachedURL) {\n        {\n          logger_mjs.logger.debug(`Precaching did not find a match for ` + getFriendlyURL_mjs.getFriendlyURL(event.request.url));\n        }\n        return;\n      }\n\n      let responsePromise = caches.open(cacheName).then(cache => {\n        return cache.match(precachedURL);\n      }).then(cachedResponse => {\n        if (cachedResponse) {\n          return cachedResponse;\n        } // Fall back to the network if we don't have a cached response\n        // (perhaps due to manual cache cleanup).\n\n\n        {\n          logger_mjs.logger.warn(`The precached response for ` + `${getFriendlyURL_mjs.getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` + `Falling back to the network instead.`);\n        }\n        return fetch(precachedURL);\n      });\n      {\n        responsePromise = responsePromise.then(response => {\n          // Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger_mjs.logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL_mjs.getFriendlyURL(event.request.url));\n          logger_mjs.logger.log(`Serving the precached url: ${precachedURL}`);\n          logger_mjs.logger.groupCollapsed(`View request details here.`);\n          logger_mjs.logger.log(event.request);\n          logger_mjs.logger.groupEnd();\n          logger_mjs.logger.groupCollapsed(`View response details here.`);\n          logger_mjs.logger.log(response);\n          logger_mjs.logger.groupEnd();\n          logger_mjs.logger.groupEnd();\n          return response;\n        });\n      }\n      event.respondWith(responsePromise);\n    });\n  };\n  /*\n    Copyright 2019 Google LLC\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  let listenerAdded = false;\n  /**\n   * Add a `fetch` listener to the service worker that will\n   * respond to\n   * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n   * with precached assets.\n   *\n   * Requests for assets that aren't precached, the `FetchEvent` will not be\n   * responded to, allowing the event to fall through to other `fetch` event\n   * listeners.\n   *\n   * @param {Object} options\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URL's that should be checked for precache matches.\n   *\n   * @alias workbox.precaching.addRoute\n   */\n\n  const addRoute = options => {\n    if (!listenerAdded) {\n      addFetchListener(options);\n      listenerAdded = true;\n    }\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const SUBSTRING_TO_FIND = '-precache-';\n  /**\n   * Cleans up incompatible precaches that were created by older versions of\n   * Workbox, by a service worker registered under the current scope.\n   *\n   * This is meant to be called as part of the `activate` event.\n   *\n   * This should be safe to use as long as you don't include `substringToFind`\n   * (defaulting to `-precache-`) in your non-precache cache names.\n   *\n   * @param {string} currentPrecacheName The cache name currently in use for\n   * precaching. This cache won't be deleted.\n   * @param {string} [substringToFind='-precache-'] Cache names which include this\n   * substring will be deleted (excluding `currentPrecacheName`).\n   * @return {Array<string>} A list of all the cache names that were deleted.\n   *\n   * @private\n   * @memberof module:workbox-precaching\n   */\n\n  const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n    const cacheNames = await caches.keys();\n    const cacheNamesToDelete = cacheNames.filter(cacheName => {\n      return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n    });\n    await Promise.all(cacheNamesToDelete.map(cacheName => caches.delete(cacheName)));\n    return cacheNamesToDelete;\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Adds an `activate` event listener which will clean up incompatible\n   * precaches that were created by older versions of Workbox.\n   *\n   * @alias workbox.precaching.cleanupOutdatedCaches\n   */\n\n\n  const cleanupOutdatedCaches = () => {\n    addEventListener('activate', event => {\n      const cacheName = cacheNames_mjs.cacheNames.getPrecacheName();\n      event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {\n        {\n          if (cachesDeleted.length > 0) {\n            logger_mjs.logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);\n          }\n        }\n      }));\n    });\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Takes in a URL, and returns the corresponding URL that could be used to\n   * lookup the entry in the precache.\n   *\n   * If a relative URL is provided, the location of the service worker file will\n   * be used as the base.\n   *\n   * For precached entries without revision information, the cache key will be the\n   * same as the original URL.\n   *\n   * For precached entries with revision information, the cache key will be the\n   * original URL with the addition of a query parameter used for keeping track of\n   * the revision info.\n   *\n   * @param {string} url The URL whose cache key to look up.\n   * @return {string} The cache key that corresponds to that URL.\n   *\n   * @alias workbox.precaching.getCacheKeyForURL\n   */\n\n\n  const getCacheKeyForURL$1 = url => {\n    const precacheController = getOrCreatePrecacheController();\n    return precacheController.getCacheKeyForURL(url);\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const installListener = event => {\n    const precacheController = getOrCreatePrecacheController();\n    const plugins = precachePlugins.get();\n    event.waitUntil(precacheController.install({\n      event,\n      plugins\n    }).catch(error => {\n      {\n        logger_mjs.logger.error(`Service worker installation failed. It will ` + `be retried automatically during the next navigation.`);\n      } // Re-throw the error to ensure installation fails.\n\n      throw error;\n    }));\n  };\n\n  const activateListener = event => {\n    const precacheController = getOrCreatePrecacheController();\n    const plugins = precachePlugins.get();\n    event.waitUntil(precacheController.activate({\n      event,\n      plugins\n    }));\n  };\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * Please note: This method **will not** serve any of the cached files for you.\n   * It only precaches files. To respond to a network request you call\n   * [addRoute()]{@link module:workbox-precaching.addRoute}.\n   *\n   * If you have a single array of files to precache, you can just call\n   * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n   *\n   * @param {Array<Object|string>} entries Array of entries to precache.\n   *\n   * @alias workbox.precaching.precache\n   */\n\n\n  const precache = entries => {\n    const precacheController = getOrCreatePrecacheController();\n    precacheController.addToCacheList(entries);\n\n    if (entries.length > 0) {\n      // NOTE: these listeners will only be added once (even if the `precache()`\n      // method is called multiple times) because event listeners are implemented\n      // as a set, where each listener must be unique.\n      addEventListener('install', installListener);\n      addEventListener('activate', activateListener);\n    }\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This method will add entries to the precache list and add a route to\n   * respond to fetch events.\n   *\n   * This is a convenience method that will call\n   * [precache()]{@link module:workbox-precaching.precache} and\n   * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n   *\n   * @param {Array<Object|string>} entries Array of entries to precache.\n   * @param {Object} options See\n   * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n   *\n   * @alias workbox.precaching.precacheAndRoute\n   */\n\n\n  const precacheAndRoute = (entries, options) => {\n    precache(entries);\n    addRoute(options);\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  {\n    assert_mjs.assert.isSWEnv('workbox-precaching');\n  }\n  exports.addPlugins = addPlugins;\n  exports.addRoute = addRoute;\n  exports.cleanupOutdatedCaches = cleanupOutdatedCaches;\n  exports.getCacheKeyForURL = getCacheKeyForURL$1;\n  exports.precache = precache;\n  exports.precacheAndRoute = precacheAndRoute;\n  exports.PrecacheController = PrecacheController;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../utils/precachePlugins.mjs","../addPlugins.mjs","../utils/cleanRedirect.mjs","../utils/createCacheKey.mjs","../utils/printCleanupDetails.mjs","../utils/printInstallDetails.mjs","../PrecacheController.mjs","../utils/getOrCreatePrecacheController.mjs","../utils/removeIgnoredSearchParams.mjs","../utils/generateURLVariations.mjs","../utils/getCacheKeyForURL.mjs","../utils/addFetchListener.mjs","../addRoute.mjs","../utils/deleteOutdatedCaches.mjs","../cleanupOutdatedCaches.mjs","../getCacheKeyForURL.mjs","../precache.mjs","../precacheAndRoute.mjs","../index.mjs"],"names":["self","_","plugins","precachePlugins","get","add","addPlugins","newPlugins","clonedResponse","response","bodyPromise","Promise","body","headers","status","statusText","REVISION_SEARCH_PARAM","WorkboxError","entry","urlObject","cacheKey","url","href","originalURL","cacheKeyURL","logGroup","logger","deletionCount","deletedURLs","urls","precachedCount","urlsToPrecache","alreadyPrecachedCount","urlsAlreadyPrecached","message","_nestedGroup","constructor","cacheNames","addToCacheList","assert","moduleName","className","funcName","paramName","createCacheKey","firstEntry","secondEntry","cache","caches","alreadyCachedRequests","alreadyCachedURLs","request","precacheRequests","printInstallDetails","updatedURLs","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","printCleanupDetails","credentials","cacheWillUpdateCallback","plugin","isValidResponse","cleanRedirect","cacheName","matchOptions","ignoreSearch","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","getOrCreatePrecacheController","precacheController","ignoreURLParametersMatching","regExp","urlManipulation","urlWithoutIgnoredParams","removeIgnoredSearchParams","directoryIndex","directoryURL","cleanURL","additionalURLs","urlToAttempt","urlsToCacheKeys","generateURLVariations","possibleCacheKey","addFetchListener","cleanURLs","addEventListener","event","precachedURL","getFriendlyURL","responsePromise","cachedResponse","fetch","listenerAdded","addRoute","options","SUBSTRING_TO_FIND","deleteOutdatedCaches","substringToFind","cacheNamesToDelete","cleanupOutdatedCaches","cachesDeleted","installListener","error","activateListener","precache","entries","precacheAndRoute"],"mappings":";;;;;AAAA,MAAG;AAACA,IAAAA,IAAI,CAAJA,0BAAI,CAAJA,IAAkCC,CAAlCD,EAAAA;AAAJ,GAAA,CAA0C,OAAA,CAAA,EAAQ,CAAA,C,CAAA;;ACAlD;;;;;;;;AAWA,QAAME,OAAO,GAAb,EAAA;AAEO,QAAMC,eAAe,GAAG;AAC7B;;;;AAIAC,IAAAA,GAAG,GAAG;AACJ,aAAA,OAAA;AAN2B,KAAA;;AAS7B;;;;AAIAC,IAAAA,GAAG,CAAA,UAAA,EAAa;AACdH,MAAAA,OAAO,CAAPA,IAAAA,CAAa,GAAbA,UAAAA;AACD;;AAf4B,GAAxB;ACbP;;;;;;;AAYA;;;;;;;;AAOA,QAAMI,UAAU,GAAIC,UAAD,IAAgB;AACjCJ,IAAAA,eAAe,CAAfA,GAAAA,CAAAA,UAAAA;AADF,GAAA;ACnBA;;;;;;;AAUA;;;;;;;;;AAOO,iBAAA,aAAA,CAAA,QAAA,EAAuC;AAC5C,UAAMK,cAAc,GAAGC,QAAQ,CADa,KACrBA,EAAvB,CAD4C,CAAA;AAI5C;;AACA,UAAMC,WAAW,GAAG,UAAA,cAAA,GAClBC,OAAO,CAAPA,OAAAA,CAAgBH,cAAc,CADZ,IAClBG,CADkB,GAElBH,cAAc,CAFhB,IAEEA,EAFF;AAIA,UAAMI,IAAI,GAAG,MAT+B,WAS5C,CAT4C,CAAA;;AAY5C,WAAO,IAAA,QAAA,CAAA,IAAA,EAAmB;AACxBC,MAAAA,OAAO,EAAEL,cAAc,CADC,OAAA;AAExBM,MAAAA,MAAM,EAAEN,cAAc,CAFE,MAAA;AAGxBO,MAAAA,UAAU,EAAEP,cAAc,CAACO;AAHH,KAAnB,CAAP;AAKD;AClCD;;;;;;;;AAaA,QAAMC,qBAAqB,GAA3B,iBAAA;AAEA;;;;;;;;;;AASO,WAAA,cAAA,CAAA,KAAA,EAA+B;AACpC,QAAI,CAAJ,KAAA,EAAY;AACV,YAAM,IAAIC,gBAAAA,CAAJ,YAAA,CAAA,mCAAA,EAAsD;AAACC,QAAAA;AAAD,OAAtD,CAAN;AAFkC,KAAA,CAAA;AAMpC;;;AACA,QAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AAC7B,YAAMC,SAAS,GAAG,IAAA,GAAA,CAAA,KAAA,EAAlB,QAAkB,CAAlB;AACA,aAAO;AACLC,QAAAA,QAAQ,EAAED,SAAS,CADd,IAAA;AAELE,QAAAA,GAAG,EAAEF,SAAS,CAACG;AAFV,OAAP;AAID;;AAED,UAAM;AAAA,MAAA,QAAA;AAAWD,MAAAA;AAAX,QAAN,KAAA;;AACA,QAAI,CAAJ,GAAA,EAAU;AACR,YAAM,IAAIJ,gBAAAA,CAAJ,YAAA,CAAA,mCAAA,EAAsD;AAACC,QAAAA;AAAD,OAAtD,CAAN;AAjBkC,KAAA,CAAA;AAqBpC;;;AACA,QAAI,CAAJ,QAAA,EAAe;AACb,YAAMC,SAAS,GAAG,IAAA,GAAA,CAAA,GAAA,EAAlB,QAAkB,CAAlB;AACA,aAAO;AACLC,QAAAA,QAAQ,EAAED,SAAS,CADd,IAAA;AAELE,QAAAA,GAAG,EAAEF,SAAS,CAACG;AAFV,OAAP;AAxBkC,KAAA,CAAA;AA+BpC;;;AACA,UAAMC,WAAW,GAAG,IAAA,GAAA,CAAA,GAAA,EAApB,QAAoB,CAApB;AACA,UAAMC,WAAW,GAAG,IAAA,GAAA,CAAA,GAAA,EAApB,QAAoB,CAApB;AACAA,IAAAA,WAAW,CAAXA,YAAAA,CAAAA,GAAAA,CAAAA,qBAAAA,EAAAA,QAAAA;AACA,WAAO;AACLJ,MAAAA,QAAQ,EAAEI,WAAW,CADhB,IAAA;AAELH,MAAAA,GAAG,EAAEE,WAAW,CAACD;AAFZ,KAAP;AAID;AC/DD;;;;;;;;AAYA,QAAMG,QAAQ,GAAG,CAAA,UAAA,EAAA,WAAA,KAA6B;AAC5CC,IAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,UAAAA;;AAEA,SAAK,MAAL,GAAA,IAAA,WAAA,EAA+B;AAC7BA,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,GAAAA;AACD;;AAEDA,IAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AAPF,GAAA;AAUA;;;;;;;;AAMO,WAAA,mBAAA,CAAA,WAAA,EAA0C;AAC/C,UAAMC,aAAa,GAAGC,WAAW,CAAjC,MAAA;;AACA,QAAID,aAAa,GAAjB,CAAA,EAAuB;AACrBD,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAsB,6BAAC,GAClB,GAAEC,aADe,UAAC,GAElB,UAASA,aAAa,KAAbA,CAAAA,GAAAA,MAAAA,GAA+B,QAF7CD,WAAAA;AAGAD,MAAAA,QAAQ,CAAA,wBAAA,EAARA,WAAQ,CAARA;AACAC,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AACD;AACF;ACrCD;;;;;;;AAYA;;;;;;;;AAMA,WAAA,YAAA,CAAA,UAAA,EAAA,IAAA,EAAwC;AACtC,QAAIG,IAAI,CAAJA,MAAAA,KAAJ,CAAA,EAAuB;AACrB;AACD;;AAEDH,IAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,UAAAA;;AAEA,SAAK,MAAL,GAAA,IAAA,IAAA,EAAwB;AACtBA,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,GAAAA;AACD;;AAEDA,IAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AACD;AAED;;;;;;;;;AAOO,WAAA,mBAAA,CAAA,cAAA,EAAA,oBAAA,EAAmE;AACxE,UAAMI,cAAc,GAAGC,cAAc,CAArC,MAAA;AACA,UAAMC,qBAAqB,GAAGC,oBAAoB,CAAlD,MAAA;;AAEA,QAAIH,cAAc,IAAlB,qBAAA,EAA6C;AAC3C,UAAII,OAAO,GACN,cAAaJ,cAAe,QAAOA,cAAc,KAAdA,CAAAA,GAAAA,EAAAA,GAA4B,GADpE,GAAA;;AAGA,UAAIE,qBAAqB,GAAzB,CAAA,EAA+B;AAC7BE,QAAAA,OAAO,IAAK,IAAGF,qBAAJ,GAAC,GACT,OAAMA,qBAAqB,KAArBA,CAAAA,GAAAA,KAAAA,GAAsC,OAD/CE,kBAAAA;AAED;;AAEDR,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,OAAAA;;AAEAS,MAAAA,YAAY,CAAA,4BAAA,EAAZA,cAAY,CAAZA;;AACAA,MAAAA,YAAY,CAAA,iCAAA,EAAZA,oBAAY,CAAZA;;AACAT,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AACD;AACF;AC1DD;;;;;;;AAsBA;;;;;;;AAKA,QAAA,kBAAA,CAAyB;AACvB;;;;;;AAMAU,IAAAA,WAAW,CAAA,SAAA,EAAY;AACrB,WAAA,UAAA,GAAkBC,cAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAlB,SAAkBA,CAAlB;AACA,WAAA,gBAAA,GAAwB,IAAxB,GAAwB,EAAxB;AACD;AAED;;;;;;;;;;AAQAC,IAAAA,cAAc,CAAA,OAAA,EAAU;AACqB;AACzCC,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAAA,OAAAA,EAAwB;AACtBC,UAAAA,UAAU,EADY,oBAAA;AAEtBC,UAAAA,SAAS,EAFa,oBAAA;AAGtBC,UAAAA,QAAQ,EAHc,gBAAA;AAItBC,UAAAA,SAAS,EAAE;AAJW,SAAxBJ;AAMD;;AAED,WAAK,MAAL,KAAA,IAAA,OAAA,EAA6B;AAC3B,cAAM;AAAA,UAAA,QAAA;AAAWlB,UAAAA;AAAX,YAAkBuB,cAAc,CAAtC,KAAsC,CAAtC;;AACA,YAAI,KAAA,gBAAA,CAAA,GAAA,CAAA,GAAA,KACA,KAAA,gBAAA,CAAA,GAAA,CAAA,GAAA,MADJ,QAAA,EACiD;AAC/C,gBAAM,IAAI3B,gBAAAA,CAAJ,YAAA,CAAA,uCAAA,EAA0D;AAC9D4B,YAAAA,UAAU,EAAE,KAAA,gBAAA,CAAA,GAAA,CADkD,GAClD,CADkD;AAE9DC,YAAAA,WAAW,EAAE1B;AAFiD,WAA1D,CAAN;AAID;;AACD,aAAA,gBAAA,CAAA,GAAA,CAAA,GAAA,EAAA,QAAA;AACD;AACF;AAED;;;;;;;;;;;;AAUA,UAAA,OAAA,CAAc;AAAA,MAAA,KAAA;AAAQlB,MAAAA;AAAR,QAAd,EAAA,EAAqC;AACQ;AACzC,YAAA,OAAA,EAAa;AACXqC,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAAA,OAAAA,EAAwB;AACtBC,YAAAA,UAAU,EADY,oBAAA;AAEtBC,YAAAA,SAAS,EAFa,oBAAA;AAGtBC,YAAAA,QAAQ,EAHc,SAAA;AAItBC,YAAAA,SAAS,EAAE;AAJW,WAAxBJ;AAMD;AACF;AAED,YAAMR,cAAc,GAApB,EAAA;AACA,YAAME,oBAAoB,GAA1B,EAAA;AAEA,YAAMc,KAAK,GAAG,MAAMC,MAAM,CAANA,IAAAA,CAAY,KAAhC,UAAoBA,CAApB;AACA,YAAMC,qBAAqB,GAAG,MAAMF,KAAK,CAAzC,IAAoCA,EAApC;AACA,YAAMG,iBAAiB,GAAG,IAAA,GAAA,CAAQD,qBAAqB,CAArBA,GAAAA,CAC7BE,OAAD,IAAaA,OAAO,CADxB,GAAkCF,CAAR,CAA1B;;AAGA,WAAK,MAAL,QAAA,IAAuB,KAAA,gBAAA,CAAvB,MAAuB,EAAvB,EAAuD;AACrD,YAAIC,iBAAiB,CAAjBA,GAAAA,CAAJ,QAAIA,CAAJ,EAAqC;AACnCjB,UAAAA,oBAAoB,CAApBA,IAAAA,CAAAA,QAAAA;AADF,SAAA,MAEO;AACLF,UAAAA,cAAc,CAAdA,IAAAA,CAAAA,QAAAA;AACD;AACF;;AAED,YAAMqB,gBAAgB,GAAG,cAAc,CAAd,GAAA,CAAoB/B,GAAD,IAAS;AACnD,eAAO,KAAA,cAAA,CAAoB;AAAA,UAAA,KAAA;AAAA,UAAA,OAAA;AAAiBA,UAAAA;AAAjB,SAApB,CAAP;AADF,OAAyB,CAAzB;AAGA,YAAMV,OAAO,CAAPA,GAAAA,CAAN,gBAAMA,CAAN;AAE2C;AACzC0C,QAAAA,mBAAmB,CAAA,cAAA,EAAnBA,oBAAmB,CAAnBA;AACD;AAED,aAAO;AACLC,QAAAA,WAAW,EADN,cAAA;AAELC,QAAAA,cAAc,EAAEtB;AAFX,OAAP;AAID;AAED;;;;;;;;AAMA,UAAA,QAAA,GAAiB;AACf,YAAMc,KAAK,GAAG,MAAMC,MAAM,CAANA,IAAAA,CAAY,KAAhC,UAAoBA,CAApB;AACA,YAAMQ,uBAAuB,GAAG,MAAMT,KAAK,CAA3C,IAAsCA,EAAtC;AACA,YAAMU,iBAAiB,GAAG,IAAA,GAAA,CAAQ,KAAA,gBAAA,CAAlC,MAAkC,EAAR,CAA1B;AAEA,YAAM7B,WAAW,GAAjB,EAAA;;AACA,WAAK,MAAL,OAAA,IAAA,uBAAA,EAA+C;AAC7C,YAAI,CAAC6B,iBAAiB,CAAjBA,GAAAA,CAAsBN,OAAO,CAAlC,GAAKM,CAAL,EAAyC;AACvC,gBAAMV,KAAK,CAALA,MAAAA,CAAN,OAAMA,CAAN;AACAnB,UAAAA,WAAW,CAAXA,IAAAA,CAAiBuB,OAAO,CAAxBvB,GAAAA;AACD;AACF;;AAE0C;AACzC8B,QAAAA,mBAAmB,CAAnBA,WAAmB,CAAnBA;AACD;AAED,aAAO;AAAC9B,QAAAA;AAAD,OAAP;AACD;AAED;;;;;;;;;;;;;;;;;;AAgBA,UAAA,cAAA,CAAqB;AAAA,MAAA,GAAA;AAAA,MAAA,KAAA;AAAa1B,MAAAA;AAAb,KAArB,EAA4C;AAC1C,YAAMiD,OAAO,GAAG,IAAA,OAAA,CAAA,GAAA,EAAiB;AAACQ,QAAAA,WAAW,EAAE;AAAd,OAAjB,CAAhB;AACA,UAAIlD,QAAQ,GAAG,MAAM,gBAAA,CAAA,YAAA,CAAA,KAAA,CAAmB;AAAA,QAAA,KAAA;AAAA,QAAA,OAAA;AAGtC0C,QAAAA;AAHsC,OAAnB,CAArB,CAF0C,CAAA;AAS1C;AACA;;AACA,UAAA,uBAAA;;AACA,WAAK,MAAL,MAAA,IAAsBjD,OAAO,IAA7B,EAAA,EAAsC;AACpC,YAAI,qBAAJ,MAAA,EAAiC;AAC/B0D,UAAAA,uBAAuB,GAAGC,MAAM,CAANA,eAAAA,CAAAA,IAAAA,CAA1BD,MAA0BC,CAA1BD;AACD;AACF;;AAED,YAAME,eAAe,GAAGF,uBAAuB,GAAA;AAE7CA,MAAAA,uBAAuB,CAAC;AAAA,QAAA,KAAA;AAAA,QAAA,OAAA;AAAiBnD,QAAAA;AAAjB,OAAD,CAFsB,GAAA;AAI7C;AACAA,MAAAA,QAAQ,CAARA,MAAAA,GAvBwC,GAkB1C,CAlB0C,CAAA;AA0B1C;;AACA,UAAI,CAAJ,eAAA,EAAsB;AACpB,cAAM,IAAIQ,gBAAAA,CAAJ,YAAA,CAAA,yBAAA,EAA4C;AAAA,UAAA,GAAA;AAEhDH,UAAAA,MAAM,EAAEL,QAAQ,CAACK;AAF+B,SAA5C,CAAN;AAID;;AAED,UAAIL,QAAQ,CAAZ,UAAA,EAAyB;AACvBA,QAAAA,QAAQ,GAAG,MAAMsD,aAAa,CAA9BtD,QAA8B,CAA9BA;AACD;;AAED,YAAM,gBAAA,CAAA,YAAA,CAAA,GAAA,CAAiB;AAAA,QAAA,KAAA;AAAA,QAAA,OAAA;AAAA,QAAA,OAAA;AAAA,QAAA,QAAA;AAKrBuD,QAAAA,SAAS,EAAE,KALU,UAAA;AAMrBC,QAAAA,YAAY,EAAE;AACZC,UAAAA,YAAY,EAAE;AADF;AANO,OAAjB,CAAN;AAUD;AAED;;;;;;;;AAMAC,IAAAA,kBAAkB,GAAG;AACnB,aAAO,KAAP,gBAAA;AACD;AAED;;;;;;;;AAMAC,IAAAA,aAAa,GAAG;AACd,aAAO,CAAC,GAAG,KAAA,gBAAA,CAAX,IAAW,EAAJ,CAAP;AACD;AAED;;;;;;;;;;;AASAC,IAAAA,iBAAiB,CAAA,GAAA,EAAM;AACrB,YAAMlD,SAAS,GAAG,IAAA,GAAA,CAAA,GAAA,EAAlB,QAAkB,CAAlB;AACA,aAAO,KAAA,gBAAA,CAAA,GAAA,CAA0BA,SAAS,CAA1C,IAAO,CAAP;AACD;;AA5NsB;AC3BzB;;;;;;;;AAYA,MAAA,kBAAA;AAEA;;;;;AAIO,QAAMmD,6BAA6B,GAAG,MAAM;AACjD,QAAI,CAAJ,kBAAA,EAAyB;AACvBC,MAAAA,kBAAkB,GAAG,IAArBA,kBAAqB,EAArBA;AACD;;AACD,WAAA,kBAAA;AAJK,GAAA;AClBP;;;;;;;AAUA;;;;;;;;;;;;;;AAYO,WAAA,yBAAA,CAAA,SAAA,EAAA,2BAAA,EAC0B;AAC/B;AACA;AACA,SAAK,MAAL,SAAA,IAAwB,CAAC,GAAGpD,SAAS,CAATA,YAAAA,CAA5B,IAA4BA,EAAJ,CAAxB,EAA4D;AAC1D,UAAIqD,2BAA2B,CAA3BA,IAAAA,CAAkCC,MAAD,IAAYA,MAAM,CAANA,IAAAA,CAAjD,SAAiDA,CAA7CD,CAAJ,EAA0E;AACxErD,QAAAA,SAAS,CAATA,YAAAA,CAAAA,MAAAA,CAAAA,SAAAA;AACD;AACF;;AAED,WAAA,SAAA;AACD;ACjCD;;;;;;;AAYA;;;;;;;;;;;;AAUO,YAAA,qBAAA,CAAA,GAAA,EAAqC;AAAA,IAAA,2BAAA;AAAA,IAAA,cAAA;AAAA,IAAA,SAAA;AAI1CuD,IAAAA;AAJ0C,MAArC,EAAA,EAKC;AACN,UAAMvD,SAAS,GAAG,IAAA,GAAA,CAAA,GAAA,EAAlB,QAAkB,CAAlB;AACAA,IAAAA,SAAS,CAATA,IAAAA,GAAAA,EAAAA;AACA,UAAMA,SAAS,CAAf,IAAA;AAEA,UAAMwD,uBAAuB,GAAGC,yBAAyB,CAAA,SAAA,EAAzD,2BAAyD,CAAzD;AAEA,UAAMD,uBAAuB,CAA7B,IAAA;;AAEA,QAAIE,cAAc,IAAIF,uBAAuB,CAAvBA,QAAAA,CAAAA,QAAAA,CAAtB,GAAsBA,CAAtB,EAAsE;AACpE,YAAMG,YAAY,GAAG,IAAA,GAAA,CAArB,uBAAqB,CAArB;AACAA,MAAAA,YAAY,CAAZA,QAAAA,IAAAA,cAAAA;AACA,YAAMA,YAAY,CAAlB,IAAA;AACD;;AAED,QAAA,SAAA,EAAe;AACb,YAAMC,QAAQ,GAAG,IAAA,GAAA,CAAjB,uBAAiB,CAAjB;AACAA,MAAAA,QAAQ,CAARA,QAAAA,IAAAA,OAAAA;AACA,YAAMA,QAAQ,CAAd,IAAA;AACD;;AAED,QAAA,eAAA,EAAqB;AACnB,YAAMC,cAAc,GAAGN,eAAe,CAAC;AAACrD,QAAAA,GAAG,EAAEF;AAAN,OAAD,CAAtC;;AACA,WAAK,MAAL,YAAA,IAAA,cAAA,EAA2C;AACzC,cAAM8D,YAAY,CAAlB,IAAA;AACD;AACF;AACF;ACtDD;;;;;;;AAaA;;;;;;;;;;;;;AAWO,QAAMZ,iBAAiB,GAAG,CAAA,GAAA,EAAA,OAAA,KAAkB;AACjD,UAAME,kBAAkB,GAAGD,6BAA3B,EAAA;AAEA,UAAMY,eAAe,GAAGX,kBAAkB,CAA1C,kBAAwBA,EAAxB;;AACA,SAAK,MAAL,WAAA,IAA0BY,qBAAqB,CAAA,GAAA,EAA/C,OAA+C,CAA/C,EAA+D;AAC7D,YAAMC,gBAAgB,GAAGF,eAAe,CAAfA,GAAAA,CAAzB,WAAyBA,CAAzB;;AACA,UAAA,gBAAA,EAAsB;AACpB,eAAA,gBAAA;AACD;AACF;AATI,GAAA;ACxBP;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BO,QAAMG,gBAAgB,GAAG,CAAC;AAC/Bb,IAAAA,2BAA2B,GAAG,CADC,OACD,CADC;AAE/BK,IAAAA,cAAc,GAFiB,YAAA;AAG/BS,IAAAA,SAAS,GAHsB,IAAA;AAI/BZ,IAAAA,eAAe,GAAG;AAJa,MAAD,EAAA,KAKrB;AACT,UAAMV,SAAS,GAAG3B,cAAAA,CAAAA,UAAAA,CAAlB,eAAkBA,EAAlB;AAEAkD,IAAAA,gBAAgB,CAAA,OAAA,EAAWC,KAAD,IAAW;AACnC,YAAMC,YAAY,GAAGpB,iBAAiB,CAACmB,KAAK,CAALA,OAAAA,CAAD,GAAA,EAAoB;AAAA,QAAA,SAAA;AAAA,QAAA,cAAA;AAAA,QAAA,2BAAA;AAIxDd,QAAAA;AAJwD,OAApB,CAAtC;;AAMA,UAAI,CAAJ,YAAA,EAAmB;AAC0B;AACzChD,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAa,sCAAC,GACZgE,kBAAAA,CAAAA,cAAAA,CAAeF,KAAK,CAALA,OAAAA,CADjB9D,GACEgE,CADFhE;AAED;AACD;AACD;;AAED,UAAIiE,eAAe,GAAG,MAAM,CAAN,IAAA,CAAA,SAAA,EAAA,IAAA,CAA6B5C,KAAD,IAAW;AAC3D,eAAOA,KAAK,CAALA,KAAAA,CAAP,YAAOA,CAAP;AADoB,OAAA,EAAA,IAAA,CAEb6C,cAAD,IAAoB;AAC1B,YAAA,cAAA,EAAoB;AAClB,iBAAA,cAAA;AAFwB,SAAA,CAAA;AAM1B;;;AAC2C;AACzClE,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAY,6BAAC,GACZ,GAAEgE,kBAAAA,CAAAA,cAAAA,CAAc,YAAdA,CAA6B,OAAM1B,SAD1B,kBAAC,GAAbtC,sCAAAA;AAGD;AAED,eAAOmE,KAAK,CAAZ,YAAY,CAAZ;AAfF,OAAsB,CAAtB;AAkB2C;AACzCF,QAAAA,eAAe,GAAG,eAAe,CAAf,IAAA,CAAsBlF,QAAD,IAAc;AACnD;AACA;AACAiB,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAsB,+BAAC,GACrBgE,kBAAAA,CAAAA,cAAAA,CAAeF,KAAK,CAALA,OAAAA,CADjB9D,GACEgE,CADFhE;AAEAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAY,8BAA6B+D,YAAzC/D,EAAAA;AAEAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,4BAAAA;AACAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAW8D,KAAK,CAAhB9D,OAAAA;AACAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AAEAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,6BAAAA;AACAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,QAAAA;AACAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AAEAA,UAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AACA,iBAAA,QAAA;AAhBFiE,SAAkB,CAAlBA;AAkBD;AAEDH,MAAAA,KAAK,CAALA,WAAAA,CAAAA,eAAAA;AAtDFD,KAAgB,CAAhBA;AARK,GAAA;ACzCP;;;;;;;;AAWA,MAAIO,aAAa,GAAjB,KAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,QAAaC,QAAQ,GAAIC,OAAD,IAAa;AACnC,QAAI,CAAJ,aAAA,EAAoB;AAClBX,MAAAA,gBAAgB,CAAhBA,OAAgB,CAAhBA;AACAS,MAAAA,aAAa,GAAbA,IAAAA;AACD;AAJI,GAAP;ACtCA;;;;;;;;AAUA,QAAMG,iBAAiB,GAAvB,YAAA;AAEA;;;;;;;;;;;;;;;;;;;AAkBA,QAAMC,oBAAoB,GAAG,OAAA,mBAAA,EAE3BC,eAAe,GAFY,iBAAA,KAEa;AACxC,UAAM9D,UAAU,GAAG,MAAMW,MAAM,CAA/B,IAAyBA,EAAzB;AAEA,UAAMoD,kBAAkB,GAAG,UAAU,CAAV,MAAA,CAAmBpC,SAAD,IAAe;AAC1D,aAAOA,SAAS,CAATA,QAAAA,CAAAA,eAAAA,KACAA,SAAS,CAATA,QAAAA,CAAmBhE,IAAI,CAAJA,YAAAA,CADnBgE,KACAA,CADAA,IAEAA,SAAS,KAFhB,mBAAA;AADF,KAA2B,CAA3B;AAMA,UAAMrD,OAAO,CAAPA,GAAAA,CACFyF,kBAAkB,CAAlBA,GAAAA,CAAwBpC,SAAD,IAAehB,MAAM,CAANA,MAAAA,CAD1C,SAC0CA,CAAtCoD,CADEzF,CAAN;AAGA,WAAA,kBAAA;AAdF,GAAA;AC9BA;;;;;;;AAcA;;;;;;;;AAMA,QAAa0F,qBAAqB,GAAG,MAAM;AACzCd,IAAAA,gBAAgB,CAAA,UAAA,EAAcC,KAAD,IAAW;AACtC,YAAMxB,SAAS,GAAG3B,cAAAA,CAAAA,UAAAA,CAAlB,eAAkBA,EAAlB;AAEAmD,MAAAA,KAAK,CAALA,SAAAA,CAAgB,oBAAoB,CAApB,SAAoB,CAApB,CAAA,IAAA,CAAsCc,aAAD,IAAmB;AAC3B;AACzC,cAAIA,aAAa,CAAbA,MAAAA,GAAJ,CAAA,EAA8B;AAC5B5E,YAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAW,sDAAC,GAAZA,gBAAAA,EAAAA,aAAAA;AAED;AACF;AANH8D,OAAgB,CAAhBA;AAHFD,KAAgB,CAAhBA;AADK,GAAP;ACpBA;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;AAmBA,QAAalB,mBAAiB,GAAIhD,GAAD,IAAS;AACxC,UAAMkD,kBAAkB,GAAGD,6BAA3B,EAAA;AACA,WAAOC,kBAAkB,CAAlBA,iBAAAA,CAAP,GAAOA,CAAP;AAFK,GAAP;AChCA;;;;;;;;AAcA,QAAMgC,eAAe,GAAIf,KAAD,IAAW;AACjC,UAAMjB,kBAAkB,GAAGD,6BAA3B,EAAA;AACA,UAAMpE,OAAO,GAAGC,eAAe,CAA/B,GAAgBA,EAAhB;AAEAqF,IAAAA,KAAK,CAALA,SAAAA,CACI,kBAAkB,CAAlB,OAAA,CAA2B;AAAA,MAAA,KAAA;AAAQtF,MAAAA;AAAR,KAA3B,EAAA,KAAA,CACYsG,KAAD,IAAW;AAC2B;AACzC9E,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAa,8CAAC,GAAdA,sDAAAA;AAFc,OAAA,CAAA;;AAMhB,YAAA,KAAA;AARV8D,KACI,CADJA;AAJF,GAAA;;AAiBA,QAAMiB,gBAAgB,GAAIjB,KAAD,IAAW;AAClC,UAAMjB,kBAAkB,GAAGD,6BAA3B,EAAA;AACA,UAAMpE,OAAO,GAAGC,eAAe,CAA/B,GAAgBA,EAAhB;AAEAqF,IAAAA,KAAK,CAALA,SAAAA,CAAgB,kBAAkB,CAAlB,QAAA,CAA4B;AAAA,MAAA,KAAA;AAAQtF,MAAAA;AAAR,KAA5B,CAAhBsF;AAJF,GAAA;AAOA;;;;;;;;;;;;;;;;;;;;;AAmBA,QAAakB,QAAQ,GAAIC,OAAD,IAAa;AACnC,UAAMpC,kBAAkB,GAAGD,6BAA3B,EAAA;AACAC,IAAAA,kBAAkB,CAAlBA,cAAAA,CAAAA,OAAAA;;AAEA,QAAIoC,OAAO,CAAPA,MAAAA,GAAJ,CAAA,EAAwB;AACtB;AACA;AACA;AACApB,MAAAA,gBAAgB,CAAA,SAAA,EAAhBA,eAAgB,CAAhBA;AACAA,MAAAA,gBAAgB,CAAA,UAAA,EAAhBA,gBAAgB,CAAhBA;AACD;AAVI,GAAP;ACzDA;;;;;;;AAaA;;;;;;;;;;;;;;;;AAcA,QAAaqB,gBAAgB,GAAG,CAAA,OAAA,EAAA,OAAA,KAAsB;AACpDF,IAAAA,QAAQ,CAARA,OAAQ,CAARA;AACAX,IAAAA,QAAQ,CAARA,OAAQ,CAARA;AAFK,GAAP;AC3BA;;;;;;;;AAmB2C;AACzCxD,IAAAA,UAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAAA,oBAAAA;AACD","sourcesContent":["try{self['workbox:precaching:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst plugins = [];\n\nexport const precachePlugins = {\n  /*\n   * @return {Array}\n   * @private\n   */\n  get() {\n    return plugins;\n  },\n\n  /*\n   * @param {Array} newPlugins\n   * @private\n   */\n  add(newPlugins) {\n    plugins.push(...newPlugins);\n  },\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds plugins to precaching.\n *\n * @param {Array<Object>} newPlugins\n *\n * @alias workbox.precaching.addPlugins\n */\nconst addPlugins = (newPlugins) => {\n  precachePlugins.add(newPlugins);\n};\n\nexport {addPlugins};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * @param {Response} response\n * @return {Response}\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport async function cleanRedirect(response) {\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back\n  // to reading the entire body into memory as a blob.\n  const bodyPromise = 'body' in clonedResponse ?\n    Promise.resolve(clonedResponse.body) :\n    clonedResponse.blob();\n\n  const body = await bodyPromise;\n\n  // new Response() is happy when passed either a stream or a Blob.\n  return new Response(body, {\n    headers: clonedResponse.headers,\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText,\n  });\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport '../_version.mjs';\n\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  const {revision, url} = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {entry});\n  }\n\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href,\n    };\n  }\n\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const originalURL = new URL(url, location);\n  const cacheKeyURL = new URL(url, location);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href,\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport '../_version.mjs';\n\nconst logGroup = (groupTitle, deletedURLs) => {\n  logger.groupCollapsed(groupTitle);\n\n  for (const url of deletedURLs) {\n    logger.log(url);\n  }\n\n  logger.groupEnd();\n};\n\n/**\n * @param {Array<string>} deletedURLs\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function printCleanupDetails(deletedURLs) {\n  const deletionCount = deletedURLs.length;\n  if (deletionCount > 0) {\n    logger.groupCollapsed(`During precaching cleanup, ` +\n        `${deletionCount} cached ` +\n        `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n    logGroup('Deleted Cache Requests', deletedURLs);\n    logger.groupEnd();\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport '../_version.mjs';\n\n/**\n * @param {string} groupTitle\n * @param {Array<string>} urls\n *\n * @private\n */\nfunction _nestedGroup(groupTitle, urls) {\n  if (urls.length === 0) {\n    return;\n  }\n\n  logger.groupCollapsed(groupTitle);\n\n  for (const url of urls) {\n    logger.log(url);\n  }\n\n  logger.groupEnd();\n}\n\n/**\n * @param {Array<string>} urlsToPrecache\n * @param {Array<string>} urlsAlreadyPrecached\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n  const precachedCount = urlsToPrecache.length;\n  const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n\n  if (precachedCount || alreadyPrecachedCount) {\n    let message =\n        `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n\n    if (alreadyPrecachedCount > 0) {\n      message += ` ${alreadyPrecachedCount} ` +\n        `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n    }\n\n    logger.groupCollapsed(message);\n\n    _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n    _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n    logger.groupEnd();\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {cleanRedirect} from './utils/cleanRedirect.mjs';\nimport {createCacheKey} from './utils/createCacheKey.mjs';\nimport {printCleanupDetails} from './utils/printCleanupDetails.mjs';\nimport {printInstallDetails} from './utils/printInstallDetails.mjs';\n\nimport './_version.mjs';\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    for (const entry of entries) {\n      const {cacheKey, url} = createCacheKey(entry);\n      if (this._urlsToCacheKeys.has(url) &&\n          this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey,\n        });\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n  async install({event, plugins} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins',\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(\n        (request) => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map((url) => {\n      return this._addURLToCache({event, plugins, url});\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {deletedURLs};\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n  async _addURLToCache({url, event, plugins}) {\n    const request = new Request(url, {credentials: 'same-origin'});\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request,\n    });\n\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n    let cacheWillUpdateCallback;\n    for (const plugin of (plugins || [])) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ?\n      // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({event, request, response}) :\n      // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400;\n\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status,\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true,\n      },\n    });\n  }\n\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n}\n\nexport {PrecacheController};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {PrecacheController} from '../PrecacheController.mjs';\nimport '../_version.mjs';\n\n\nlet precacheController;\n\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject,\n    ignoreURLParametersMatching) {\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n\n  return urlObject;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {removeIgnoredSearchParams} from './removeIgnoredSearchParams.mjs';\n\nimport '../_version.mjs';\n\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function* generateURLVariations(url, {\n  ignoreURLParametersMatching,\n  directoryIndex,\n  cleanURLs,\n  urlManipulation,\n} = {}) {\n  const urlObject = new URL(url, location);\n  urlObject.hash = '';\n  yield urlObject.href;\n\n  const urlWithoutIgnoredParams = removeIgnoredSearchParams(\n      urlObject, ignoreURLParametersMatching);\n  yield urlWithoutIgnoredParams.href;\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    const directoryURL = new URL(urlWithoutIgnoredParams);\n    directoryURL.pathname += directoryIndex;\n    yield directoryURL.href;\n  }\n\n  if (cleanURLs) {\n    const cleanURL = new URL(urlWithoutIgnoredParams);\n    cleanURL.pathname += '.html';\n    yield cleanURL.href;\n  }\n\n  if (urlManipulation) {\n    const additionalURLs = urlManipulation({url: urlObject});\n    for (const urlToAttempt of additionalURLs) {\n      yield urlToAttempt.href;\n    }\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './getOrCreatePrecacheController.mjs';\nimport {generateURLVariations} from './generateURLVariations.mjs';\nimport '../_version.mjs';\n\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string} Returns the URL in the cache that matches the request,\n * if possible.\n *\n * @private\n */\nexport const getCacheKeyForURL = (url, options) => {\n  const precacheController = getOrCreatePrecacheController();\n\n  const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n  for (const possibleURL of generateURLVariations(url, options)) {\n    const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n    if (possibleCacheKey) {\n      return possibleCacheKey;\n    }\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getCacheKeyForURL} from './getCacheKeyForURL.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n */\nexport const addFetchListener = ({\n  ignoreURLParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation = null,\n} = {}) => {\n  const cacheName = cacheNames.getPrecacheName();\n\n  addEventListener('fetch', (event) => {\n    const precachedURL = getCacheKeyForURL(event.request.url, {\n      cleanURLs,\n      directoryIndex,\n      ignoreURLParametersMatching,\n      urlManipulation,\n    });\n    if (!precachedURL) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` +\n          getFriendlyURL(event.request.url));\n      }\n      return;\n    }\n\n    let responsePromise = caches.open(cacheName).then((cache) => {\n      return cache.match(precachedURL);\n    }).then((cachedResponse) => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n\n      // Fall back to the network if we don't have a cached response\n      // (perhaps due to manual cache cleanup).\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` +\n        `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n        `Falling back to the network instead.`);\n      }\n\n      return fetch(precachedURL);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then((response) => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(`Precaching is responding to: ` +\n          getFriendlyURL(event.request.url));\n        logger.log(`Serving the precached url: ${precachedURL}`);\n\n        logger.groupCollapsed(`View request details here.`);\n        logger.log(event.request);\n        logger.groupEnd();\n\n        logger.groupCollapsed(`View response details here.`);\n        logger.log(response);\n        logger.groupEnd();\n\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};\n","\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addFetchListener} from './utils/addFetchListener.mjs';\nimport './_version.mjs';\n\n\nlet listenerAdded = false;\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\nexport const addRoute = (options) => {\n  if (!listenerAdded) {\n    addFetchListener(options);\n    listenerAdded = true;\n  }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst SUBSTRING_TO_FIND = '-precache-';\n\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nconst deleteOutdatedCaches = async (\n  currentPrecacheName,\n  substringToFind = SUBSTRING_TO_FIND) => {\n  const cacheNames = await caches.keys();\n\n  const cacheNamesToDelete = cacheNames.filter((cacheName) => {\n    return cacheName.includes(substringToFind) &&\n           cacheName.includes(self.registration.scope) &&\n           cacheName !== currentPrecacheName;\n  });\n\n  await Promise.all(\n      cacheNamesToDelete.map((cacheName) => caches.delete(cacheName)));\n\n  return cacheNamesToDelete;\n};\n\nexport {deleteOutdatedCaches};\n\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {deleteOutdatedCaches} from './utils/deleteOutdatedCaches.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @alias workbox.precaching.cleanupOutdatedCaches\n */\nexport const cleanupOutdatedCaches = () => {\n  addEventListener('activate', (event) => {\n    const cacheName = cacheNames.getPrecacheName();\n\n    event.waitUntil(deleteOutdatedCaches(cacheName).then((cachesDeleted) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachesDeleted.length > 0) {\n          logger.log(`The following out-of-date precaches were cleaned up ` +\n              `automatically:`, cachesDeleted);\n        }\n      }\n    }));\n  });\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {getOrCreatePrecacheController}\n  from './utils/getOrCreatePrecacheController.mjs';\nimport './_version.mjs';\n\n\n/**\n * Takes in a URL, and returns the corresponding URL that could be used to\n * lookup the entry in the precache.\n *\n * If a relative URL is provided, the location of the service worker file will\n * be used as the base.\n *\n * For precached entries without revision information, the cache key will be the\n * same as the original URL.\n *\n * For precached entries with revision information, the cache key will be the\n * original URL with the addition of a query parameter used for keeping track of\n * the revision info.\n *\n * @param {string} url The URL whose cache key to look up.\n * @return {string} The cache key that corresponds to that URL.\n *\n * @alias workbox.precaching.getCacheKeyForURL\n */\nexport const getCacheKeyForURL = (url) => {\n  const precacheController = getOrCreatePrecacheController();\n  return precacheController.getCacheKeyForURL(url);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getOrCreatePrecacheController} from './utils/getOrCreatePrecacheController.mjs';\nimport {precachePlugins} from './utils/precachePlugins.mjs';\nimport './_version.mjs';\n\n\nconst installListener = (event) => {\n  const precacheController = getOrCreatePrecacheController();\n  const plugins = precachePlugins.get();\n\n  event.waitUntil(\n      precacheController.install({event, plugins})\n          .catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(`Service worker installation failed. It will ` +\n              `be retried automatically during the next navigation.`);\n            }\n            // Re-throw the error to ensure installation fails.\n            throw error;\n          })\n  );\n};\n\nconst activateListener = (event) => {\n  const precacheController = getOrCreatePrecacheController();\n  const plugins = precachePlugins.get();\n\n  event.waitUntil(precacheController.activate({event, plugins}));\n};\n\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nexport const precache = (entries) => {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.addToCacheList(entries);\n\n  if (entries.length > 0) {\n    // NOTE: these listeners will only be added once (even if the `precache()`\n    // method is called multiple times) because event listeners are implemented\n    // as a set, where each listener must be unique.\n    addEventListener('install', installListener);\n    addEventListener('activate', activateListener);\n  }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {addRoute} from './addRoute.mjs';\nimport {precache} from './precache.mjs';\nimport './_version.mjs';\n\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nexport const precacheAndRoute = (entries, options) => {\n  precache(entries);\n  addRoute(options);\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {addPlugins} from './addPlugins.mjs';\nimport {addRoute} from './addRoute.mjs';\nimport {cleanupOutdatedCaches} from './cleanupOutdatedCaches.mjs';\nimport {getCacheKeyForURL} from './getCacheKeyForURL.mjs';\nimport {precache} from './precache.mjs';\nimport {precacheAndRoute} from './precacheAndRoute.mjs';\nimport {PrecacheController} from './PrecacheController.mjs';\nimport './_version.mjs';\n\n\nif (process.env.NODE_ENV !== 'production') {\n  assert.isSWEnv('workbox-precaching');\n}\n\n/**\n * Most consumers of this module will want to use the\n * [precacheAndRoute()]{@link workbox.precaching.precacheAndRoute}\n * method to add assets to the Cache and respond to network requests with these\n * cached assets.\n *\n * If you require finer grained control, you can use the\n * [PrecacheController]{@link workbox.precaching.PrecacheController}\n * to determine when performed.\n *\n * @namespace workbox.precaching\n */\n\nexport {\n  addPlugins,\n  addRoute,\n  cleanupOutdatedCaches,\n  getCacheKeyForURL,\n  precache,\n  precacheAndRoute,\n  PrecacheController,\n};\n"]},"metadata":{},"sourceType":"script"}