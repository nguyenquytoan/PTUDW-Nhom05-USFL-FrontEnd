{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.core = function (e) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:core:4.3.1\"] && _();\n  } catch (e) {}\n\n  const t = (e, ...t) => {\n    let n = e;\n    return t.length > 0 && (n += ` :: ${JSON.stringify(t)}`), n;\n  };\n\n  class n extends Error {\n    constructor(e, n) {\n      super(t(e, n)), this.name = e, this.details = n;\n    }\n\n  }\n\n  const s = new Set();\n\n  const r = {\n    googleAnalytics: \"googleAnalytics\",\n    precache: \"precache-v2\",\n    prefix: \"workbox\",\n    runtime: \"runtime\",\n    suffix: self.registration.scope\n  },\n        a = e => [r.prefix, e, r.suffix].filter(e => e.length > 0).join(\"-\"),\n        i = {\n    updateDetails: e => {\n      Object.keys(r).forEach(t => {\n        void 0 !== e[t] && (r[t] = e[t]);\n      });\n    },\n    getGoogleAnalyticsName: e => e || a(r.googleAnalytics),\n    getPrecacheName: e => e || a(r.precache),\n    getPrefix: () => r.prefix,\n    getRuntimeName: e => e || a(r.runtime),\n    getSuffix: () => r.suffix\n  },\n        c = e => {\n    const t = new URL(e, location);\n    return t.origin === location.origin ? t.pathname : t.href;\n  };\n\n  async function o() {\n    for (const e of s) await e();\n  }\n\n  const l = \"cacheDidUpdate\",\n        u = \"cacheKeyWillBeUsed\",\n        h = \"cacheWillUpdate\",\n        f = \"cachedResponseWillBeUsed\",\n        w = \"fetchDidFail\",\n        g = \"fetchDidSucceed\",\n        d = \"requestWillFetch\",\n        p = (e, t) => e.filter(e => t in e),\n        y = async ({\n    cacheName: e,\n    request: t,\n    event: n,\n    matchOptions: s,\n    plugins: r = []\n  }) => {\n    const a = await caches.open(e),\n          i = await q({\n      plugins: r,\n      request: t,\n      mode: \"read\"\n    });\n    let c = await a.match(i, s);\n\n    for (const t of r) f in t && (c = await t[f].call(t, {\n      cacheName: e,\n      event: n,\n      matchOptions: s,\n      cachedResponse: c,\n      request: i\n    }));\n\n    return c;\n  },\n        m = async ({\n    request: e,\n    response: t,\n    event: n,\n    plugins: s\n  }) => {\n    let r = t,\n        a = !1;\n\n    for (let t of s) if (h in t && (a = !0, !(r = await t[h].call(t, {\n      request: e,\n      response: r,\n      event: n\n    })))) break;\n\n    return a || (r = 200 === r.status ? r : null), r || null;\n  },\n        q = async ({\n    request: e,\n    mode: t,\n    plugins: n\n  }) => {\n    const s = p(n, u);\n    let r = e;\n\n    for (const e of s) \"string\" == typeof (r = await e[u].call(e, {\n      mode: t,\n      request: r\n    })) && (r = new Request(r));\n\n    return r;\n  },\n        v = {\n    put: async ({\n      cacheName: e,\n      request: t,\n      response: s,\n      event: r,\n      plugins: a = [],\n      matchOptions: i\n    } = {}) => {\n      const u = await q({\n        plugins: a,\n        request: t,\n        mode: \"write\"\n      });\n      if (!s) throw new n(\"cache-put-with-no-response\", {\n        url: c(u.url)\n      });\n      let h = await m({\n        event: r,\n        plugins: a,\n        response: s,\n        request: u\n      });\n      if (!h) return;\n      const f = await caches.open(e),\n            w = p(a, l);\n      let g = w.length > 0 ? await y({\n        cacheName: e,\n        matchOptions: i,\n        request: u\n      }) : null;\n\n      try {\n        await f.put(u, h);\n      } catch (e) {\n        throw \"QuotaExceededError\" === e.name && (await o()), e;\n      }\n\n      for (let t of w) await t[l].call(t, {\n        cacheName: e,\n        event: r,\n        oldResponse: g,\n        newResponse: h,\n        request: u\n      });\n    },\n    match: y\n  };\n\n  class x {\n    constructor(e, t, {\n      onupgradeneeded: n,\n      onversionchange: s = this.t\n    } = {}) {\n      this.s = e, this.i = t, this.o = n, this.t = s, this.l = null;\n    }\n\n    get db() {\n      return this.l;\n    }\n\n    async open() {\n      if (!this.l) return this.l = await new Promise((e, t) => {\n        let n = !1;\n        setTimeout(() => {\n          n = !0, t(new Error(\"The open request was blocked and timed out\"));\n        }, this.OPEN_TIMEOUT);\n        const s = indexedDB.open(this.s, this.i);\n        s.onerror = () => t(s.error), s.onupgradeneeded = e => {\n          n ? (s.transaction.abort(), e.target.result.close()) : this.o && this.o(e);\n        }, s.onsuccess = ({\n          target: t\n        }) => {\n          const s = t.result;\n          n ? s.close() : (s.onversionchange = this.t.bind(this), e(s));\n        };\n      }), this;\n    }\n\n    async getKey(e, t) {\n      return (await this.getAllKeys(e, t, 1))[0];\n    }\n\n    async getAll(e, t, n) {\n      return await this.getAllMatching(e, {\n        query: t,\n        count: n\n      });\n    }\n\n    async getAllKeys(e, t, n) {\n      return (await this.getAllMatching(e, {\n        query: t,\n        count: n,\n        includeKeys: !0\n      })).map(({\n        key: e\n      }) => e);\n    }\n\n    async getAllMatching(e, {\n      index: t,\n      query: n = null,\n      direction: s = \"next\",\n      count: r,\n      includeKeys: a\n    } = {}) {\n      return await this.transaction([e], \"readonly\", (i, c) => {\n        const o = i.objectStore(e),\n              l = t ? o.index(t) : o,\n              u = [];\n\n        l.openCursor(n, s).onsuccess = ({\n          target: e\n        }) => {\n          const t = e.result;\n\n          if (t) {\n            const {\n              primaryKey: e,\n              key: n,\n              value: s\n            } = t;\n            u.push(a ? {\n              primaryKey: e,\n              key: n,\n              value: s\n            } : s), r && u.length >= r ? c(u) : t.continue();\n          } else c(u);\n        };\n      });\n    }\n\n    async transaction(e, t, n) {\n      return await this.open(), await new Promise((s, r) => {\n        const a = this.l.transaction(e, t);\n        a.onabort = ({\n          target: e\n        }) => r(e.error), a.oncomplete = () => s(), n(a, e => s(e));\n      });\n    }\n\n    async u(e, t, n, ...s) {\n      return await this.transaction([t], n, (n, r) => {\n        n.objectStore(t)[e](...s).onsuccess = ({\n          target: e\n        }) => {\n          r(e.result);\n        };\n      });\n    }\n\n    t() {\n      this.close();\n    }\n\n    close() {\n      this.l && (this.l.close(), this.l = null);\n    }\n\n  }\n\n  x.prototype.OPEN_TIMEOUT = 2e3;\n  const b = {\n    readonly: [\"get\", \"count\", \"getKey\", \"getAll\", \"getAllKeys\"],\n    readwrite: [\"add\", \"put\", \"clear\", \"delete\"]\n  };\n\n  for (const [e, t] of Object.entries(b)) for (const n of t) n in IDBObjectStore.prototype && (x.prototype[n] = async function (t, ...s) {\n    return await this.u(n, t, e, ...s);\n  });\n\n  const D = {\n    fetch: async ({\n      request: e,\n      fetchOptions: t,\n      event: s,\n      plugins: r = []\n    }) => {\n      if (s && s.preloadResponse) {\n        const e = await s.preloadResponse;\n        if (e) return e;\n      }\n\n      \"string\" == typeof e && (e = new Request(e));\n      const a = p(r, w),\n            i = a.length > 0 ? e.clone() : null;\n\n      try {\n        for (let t of r) d in t && (e = await t[d].call(t, {\n          request: e.clone(),\n          event: s\n        }));\n      } catch (e) {\n        throw new n(\"plugin-error-request-will-fetch\", {\n          thrownError: e\n        });\n      }\n\n      let c = e.clone();\n\n      try {\n        let n;\n        n = \"navigate\" === e.mode ? await fetch(e) : await fetch(e, t);\n\n        for (const e of r) g in e && (n = await e[g].call(e, {\n          event: s,\n          request: c,\n          response: n\n        }));\n\n        return n;\n      } catch (e) {\n        for (const t of a) await t[w].call(t, {\n          error: e,\n          event: s,\n          originalRequest: i.clone(),\n          request: c.clone()\n        });\n\n        throw e;\n      }\n    }\n  };\n  var E = Object.freeze({\n    assert: null,\n    cacheNames: i,\n    cacheWrapper: v,\n    DBWrapper: x,\n    Deferred: class {\n      constructor() {\n        this.promise = new Promise((e, t) => {\n          this.resolve = e, this.reject = t;\n        });\n      }\n\n    },\n    deleteDatabase: async e => {\n      await new Promise((t, n) => {\n        const s = indexedDB.deleteDatabase(e);\n        s.onerror = ({\n          target: e\n        }) => {\n          n(e.error);\n        }, s.onblocked = () => {\n          n(new Error(\"Delete blocked\"));\n        }, s.onsuccess = () => {\n          t();\n        };\n      });\n    },\n    executeQuotaErrorCallbacks: o,\n    fetchWrapper: D,\n    getFriendlyURL: c,\n    logger: null,\n    WorkboxError: n\n  });\n  const N = {\n    get googleAnalytics() {\n      return i.getGoogleAnalyticsName();\n    },\n\n    get precache() {\n      return i.getPrecacheName();\n    },\n\n    get prefix() {\n      return i.getPrefix();\n    },\n\n    get runtime() {\n      return i.getRuntimeName();\n    },\n\n    get suffix() {\n      return i.getSuffix();\n    }\n\n  };\n\n  try {\n    self.workbox.v = self.workbox.v || {};\n  } catch (e) {}\n\n  return e._private = E, e.clientsClaim = () => {\n    addEventListener(\"activate\", () => clients.claim());\n  }, e.cacheNames = N, e.registerQuotaErrorCallback = function (e) {\n    s.add(e);\n  }, e.setCacheNameDetails = e => {\n    i.updateDetails(e);\n  }, e.skipWaiting = () => {\n    addEventListener(\"install\", () => self.skipWaiting());\n  }, e;\n}({});","map":{"version":3,"sources":["../_version.mjs","../_private/logger.mjs","../models/messages/messageGenerator.mjs","../_private/WorkboxError.mjs","../_private/assert.mjs","../models/quotaErrorCallbacks.mjs","../_private/cacheNames.mjs","../_private/getFriendlyURL.mjs","../_private/executeQuotaErrorCallbacks.mjs","../models/pluginEvents.mjs","../utils/pluginUtils.mjs","../_private/cacheWrapper.mjs","../_private/DBWrapper.mjs","../_private/deleteDatabase.mjs","../_private/fetchWrapper.mjs","../_private/Deferred.mjs","../cacheNames.mjs","../index.mjs","../clientsClaim.mjs","../registerQuotaErrorCallback.mjs","../setCacheNameDetails.mjs","../skipWaiting.mjs"],"names":["self","_","e","process","code","args","msg","length","JSON","stringify","messageGenerator","WorkboxError","Error","constructor","errorCode","details","name","quotaErrorCallbacks","Set","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","value","join","cacheNames","updateDetails","Object","keys","forEach","key","getGoogleAnalyticsName","userCacheName","getPrecacheName","getPrefix","getRuntimeName","getSuffix","getFriendlyURL","url","urlObj","URL","location","origin","pathname","href","async","executeQuotaErrorCallbacks","callback","pluginEvents","pluginUtils","plugins","callbackName","plugin","request","response","event","matchOptions","effectiveRequest","_getEffectiveRequest","mode","responseToCache","_isResponseSafeToCache","cache","caches","open","updatePlugins","oldResponse","matchWrapper","put","error","call","newResponse","cachedResponse","match","pluginsUsed","status","cacheKeyWillBeUsedPlugins","Request","cacheWrapper","DBWrapper","version","onupgradeneeded","onversionchange","this","_onversionchange","_name","_version","_onupgradeneeded","_db","Promise","resolve","reject","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","onerror","evt","transaction","abort","target","result","close","onsuccess","db","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","map","index","direction","txn","done","store","objectStore","results","openCursor","cursor","primaryKey","push","continue","storeNames","type","onabort","oncomplete","method","prototype","methodsToWrap","methods","entries","IDBObjectStore","_call","deleteDatabase","onblocked","fetchOptions","preloadResponse","possiblePreloadResponse","failedFetchPlugins","originalRequest","clone","err","thrownError","pluginFilteredRequest","fetchResponse","fetch","fetchWrapper","promise","_cacheNames","workbox","v","errer","addEventListener","clients","claim","add","skipWaiting"],"mappings":"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","sourcesContent":["try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\nexport {logger};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messages} from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n    {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n    {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n    {moduleName, className, funcName,\n      paramName, isReturnValueProblem}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName, isReturnValueProblem});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n    {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSWEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalAssertExports as assert};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n// Callbacks to be executed whenever there's a quota error.\nconst quotaErrorCallbacks = new Set();\n\nexport {quotaErrorCallbacks};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: self.registration.scope,\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n      .filter((value) => value.length > 0)\n      .join('-');\n};\n\nexport const cacheNames = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from '../_private/logger.mjs';\nimport {quotaErrorCallbacks} from '../models/quotaErrorCallbacks.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` +\n        `callbacks to clean up caches.`);\n  }\n\n  for (const callback of quotaErrorCallbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\n\nexport {executeQuotaErrorCallbacks};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nexport const pluginEvents = {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const pluginUtils = {\n  filter: (plugins, callbackName) => {\n    return plugins.filter((plugin) => callbackName in plugin);\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\nimport {logger} from './logger.mjs';\nimport {executeQuotaErrorCallbacks} from './executeQuotaErrorCallbacks.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({\n  cacheName,\n  request,\n  response,\n  event,\n  plugins = [],\n  matchOptions,\n} = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method,\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'write'});\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` +\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url),\n    });\n  }\n\n  let responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest,\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n      `not be cached.`, responseToCache);\n    }\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\n      null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n    throw error;\n  }\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({\n  cacheName,\n  request,\n  event,\n  matchOptions,\n  plugins = [],\n}) => {\n  const cache = await caches.open(cacheName);\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins, request, mode: 'read'});\n\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n          .call(plugin, {\n            cacheName,\n            event,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n          });\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n          .call(plugin, {\n            request,\n            response: responseToCache,\n            event,\n          });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\n            isReturnValueProblem: true,\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.status === 200) {\n        if (responseToCache.status === 0) {\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n\n  let effectiveRequest = request;\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\n        plugin, {mode, request: effectiveRequest});\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n        isReturnValueProblem: true,\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   *\n   * @private\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = () => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = ({target}) => {\n        const db = target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {query, count});\n  }\n\n\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n  async getAllKeys(storeName, query, count) {\n    return (await this.getAllMatching(\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n  async getAllMatching(storeName, {\n    index,\n    query = null, // IE errors if query === `undefined`.\n    direction = 'next',\n    count,\n    includeKeys,\n  } = {}) {\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n\n      target.openCursor(query, direction).onsuccess = ({target}) => {\n        const cursor = target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(includeKeys ? {primaryKey, key, value} : value);\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      txn.onabort = ({target}) => reject(target.error);\n      txn.oncomplete = () => resolve();\n\n      callback(txn, (value) => resolve(value));\n    });\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n  async _call(method, storeName, type, ...args) {\n    const callback = (txn, done) => {\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\n        done(target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @private\n   */\n  _onversionchange() {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) {\n      this._db.close();\n      this._db = null;\n    }\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  'readwrite': ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Deletes the database.\n * Note: this is exported separately from the DBWrapper module because most\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\n * reused in tests to delete databases without creating DBWrapper instances.\n *\n * @param {string} name The database name.\n * @private\n */\nexport const deleteDatabase = async (name) => {\n  await new Promise((resolve, reject) => {\n    const request = indexedDB.deleteDatabase(name);\n    request.onerror = ({target}) => {\n      reject(target.error);\n    };\n    request.onblocked = () => {\n      reject(new Error('Delete blocked'));\n    };\n    request.onsuccess = () => {\n      resolve();\n    };\n  });\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {cacheNames as _cacheNames} from './_private/cacheNames.mjs';\nimport './_version.mjs';\n\n\n/**\n * Get the current cache names and prefix/suffix used by Workbox.\n *\n * `cacheNames.precache` is used for precached assets,\n * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\n *\n * `cacheNames.prefix` can be used to retrieve just the current prefix value.\n * `cacheNames.suffix` can be used to retrieve just the current suffix value.\n *\n * @return {Object} An object with `precache`, `runtime`, `prefix`, and\n *     `googleAnalytics` properties.\n *\n * @alias workbox.core.cacheNames\n */\nexport const cacheNames = {\n  get googleAnalytics() {\n    return _cacheNames.getGoogleAnalyticsName();\n  },\n  get precache() {\n    return _cacheNames.getPrecacheName();\n  },\n  get prefix() {\n    return _cacheNames.getPrefix();\n  },\n  get runtime() {\n    return _cacheNames.getRuntimeName();\n  },\n  get suffix() {\n    return _cacheNames.getSuffix();\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {registerQuotaErrorCallback} from './registerQuotaErrorCallback.mjs';\nimport * as _private from './_private.mjs';\nimport {clientsClaim} from './clientsClaim.mjs';\nimport {cacheNames} from './cacheNames.mjs';\nimport {setCacheNameDetails} from './setCacheNameDetails.mjs';\nimport {skipWaiting} from './skipWaiting.mjs';\nimport './_version.mjs';\n\n\n// Give our version strings something to hang off of.\ntry {\n  self.workbox.v = self.workbox.v || {};\n} catch (errer) {\n  // NOOP\n}\n\n/**\n * All of the Workbox service worker libraries use workbox-core for shared\n * code as well as setting default values that need to be shared (like cache\n * names).\n *\n * @namespace workbox.core\n */\n\nexport {\n  _private,\n  clientsClaim,\n  cacheNames,\n  registerQuotaErrorCallback,\n  setCacheNameDetails,\n  skipWaiting,\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @alias workbox.core.clientsClaim\n */\nexport const clientsClaim = () => {\n  addEventListener('activate', () => clients.claim());\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from './_private/logger.mjs';\nimport {assert} from './_private/assert.mjs';\nimport {quotaErrorCallbacks} from './models/quotaErrorCallbacks.mjs';\nimport './_version.mjs';\n\n\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox.core\n */\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback',\n    });\n  }\n\n  quotaErrorCallbacks.add(callback);\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\n\nexport {registerQuotaErrorCallback};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from './_private/assert.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport './_version.mjs';\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @alias workbox.core.setCacheNameDetails\n */\nexport const setCacheNameDetails = (details) => {\n  if (process.env.NODE_ENV !== 'production') {\n    Object.keys(details).forEach((key) => {\n      assert.isType(details[key], 'string', {\n        moduleName: 'workbox-core',\n        funcName: 'setCacheNameDetails',\n        paramName: `details.${key}`,\n      });\n    });\n\n    if ('precache' in details && details.precache.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'precache',\n        value: details.precache,\n      });\n    }\n\n    if ('runtime' in details && details.runtime.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'runtime',\n        value: details.runtime,\n      });\n    }\n\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n      throw new WorkboxError('invalid-cache-name', {\n        cacheNameId: 'googleAnalytics',\n        value: details.googleAnalytics,\n      });\n    }\n  }\n\n  cacheNames.updateDetails(details);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Force a service worker to become active, instead of waiting. This is\n * normally used in conjunction with `clientsClaim()`.\n *\n * @alias workbox.core.skipWaiting\n */\nexport const skipWaiting = () => {\n  // We need to explicitly call `self.skipWaiting()` here because we're\n  // shadowing `skipWaiting` with this local function.\n  addEventListener('install', () => self.skipWaiting());\n};\n"]},"metadata":{},"sourceType":"script"}