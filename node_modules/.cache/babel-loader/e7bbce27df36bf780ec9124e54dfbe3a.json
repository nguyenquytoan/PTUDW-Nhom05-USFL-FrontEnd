{"ast":null,"code":"/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\n\n\nfunction containsLineTerminator(str) {\n  return astUtils.LINEBREAK_MATCHER.test(str);\n}\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\n\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\n\n\nfunction isSingleLine(node) {\n  return node.loc.end.line === node.loc.start.line;\n}\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properies is on a single line.\n */\n\n\nfunction isSingleLineProperties(properties) {\n  const [firstProp] = properties,\n        lastProp = last(properties);\n  return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\n\n\nfunction initOptionProperty(toOptions, fromOptions) {\n  toOptions.mode = fromOptions.mode || \"strict\"; // Set value of beforeColon\n\n  if (typeof fromOptions.beforeColon !== \"undefined\") {\n    toOptions.beforeColon = +fromOptions.beforeColon;\n  } else {\n    toOptions.beforeColon = 0;\n  } // Set value of afterColon\n\n\n  if (typeof fromOptions.afterColon !== \"undefined\") {\n    toOptions.afterColon = +fromOptions.afterColon;\n  } else {\n    toOptions.afterColon = 1;\n  } // Set align if exists\n\n\n  if (typeof fromOptions.align !== \"undefined\") {\n    if (typeof fromOptions.align === \"object\") {\n      toOptions.align = fromOptions.align;\n    } else {\n      // \"string\"\n      toOptions.align = {\n        on: fromOptions.align,\n        mode: toOptions.mode,\n        beforeColon: toOptions.beforeColon,\n        afterColon: toOptions.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n}\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\n\n\nfunction initOptions(toOptions, fromOptions) {\n  if (typeof fromOptions.align === \"object\") {\n    // Initialize the alignment configuration\n    toOptions.align = initOptionProperty({}, fromOptions.align);\n    toOptions.align.on = fromOptions.align.on || \"colon\";\n    toOptions.align.mode = fromOptions.align.mode || \"strict\";\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n  } else {\n    // string or undefined\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions); // If alignment options are defined in multiLine, pull them out into the general align configuration\n\n    if (toOptions.multiLine.align) {\n      toOptions.align = {\n        on: toOptions.multiLine.align.on,\n        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n        beforeColon: toOptions.multiLine.align.beforeColon,\n        afterColon: toOptions.multiLine.align.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing between keys and values in object literal properties\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/key-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          align: {\n            anyOf: [{\n              enum: [\"colon\", \"value\"]\n            }, {\n              type: \"object\",\n              properties: {\n                mode: {\n                  enum: [\"strict\", \"minimum\"]\n                },\n                on: {\n                  enum: [\"colon\", \"value\"]\n                },\n                beforeColon: {\n                  type: \"boolean\"\n                },\n                afterColon: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            }]\n          },\n          mode: {\n            enum: [\"strict\", \"minimum\"]\n          },\n          beforeColon: {\n            type: \"boolean\"\n          },\n          afterColon: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              align: {\n                anyOf: [{\n                  enum: [\"colon\", \"value\"]\n                }, {\n                  type: \"object\",\n                  properties: {\n                    mode: {\n                      enum: [\"strict\", \"minimum\"]\n                    },\n                    on: {\n                      enum: [\"colon\", \"value\"]\n                    },\n                    beforeColon: {\n                      type: \"boolean\"\n                    },\n                    afterColon: {\n                      type: \"boolean\"\n                    }\n                  },\n                  additionalProperties: false\n                }]\n              },\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          align: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              on: {\n                enum: [\"colon\", \"value\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n      extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n      missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n      missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * OPTIONS\n     * \"key-spacing\": [2, {\n     *     beforeColon: false,\n     *     afterColon: true,\n     *     align: \"colon\" // Optional, or \"value\"\n     * }\n     */\n    const options = context.options[0] || {},\n          ruleOptions = initOptions({}, options),\n          multiLineOptions = ruleOptions.multiLine,\n          singleLineOptions = ruleOptions.singleLine,\n          alignmentOptions = ruleOptions.align || null;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Checks whether a property is a member of the property group it follows.\n     * @param {ASTNode} lastMember The last Property known to be in the group.\n     * @param {ASTNode} candidate The next Property that might be in the group.\n     * @returns {boolean} True if the candidate property is part of the group.\n     */\n\n    function continuesPropertyGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line,\n            candidateStartLine = candidate.loc.start.line;\n\n      if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n      }\n      /*\n       * Check that the first comment is adjacent to the end of the group, the\n       * last comment is adjacent to the candidate property, and that successive\n       * comments are adjacent to each other.\n       */\n\n\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Determines if the given property is key-value property.\n     * @param {ASTNode} property Property node to check.\n     * @returns {boolean} Whether the property is a key-value property.\n     */\n\n\n    function isKeyValueProperty(property) {\n      return !(property.method || property.shorthand || property.kind !== \"init\" || property.type !== \"Property\");\n    }\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the last token before a colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The last token before a colon punctuator.\n     */\n\n\n    function getLastTokenBeforeColon(node) {\n      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The colon punctuator.\n     */\n\n\n    function getNextColon(node) {\n      return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n    }\n    /**\n     * Gets an object literal property's key as the identifier name or string value.\n     * @param {ASTNode} property Property node whose key to retrieve.\n     * @returns {string} The property's key.\n     */\n\n\n    function getKey(property) {\n      const key = property.key;\n\n      if (property.computed) {\n        return sourceCode.getText().slice(key.range[0], key.range[1]);\n      }\n\n      return property.key.name || property.key.value;\n    }\n    /**\n     * Reports an appropriately-formatted error if spacing is incorrect on one\n     * side of the colon.\n     * @param {ASTNode} property Key-value pair in an object literal.\n     * @param {string} side Side being verified - either \"key\" or \"value\".\n     * @param {string} whitespace Actual whitespace string.\n     * @param {int} expected Expected whitespace length.\n     * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n     * @returns {void}\n     */\n\n\n    function report(property, side, whitespace, expected, mode) {\n      const diff = whitespace.length - expected,\n            nextColon = getNextColon(property.key),\n            tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {\n        includeComments: true\n      }),\n            tokenAfterColon = sourceCode.getTokenAfter(nextColon, {\n        includeComments: true\n      }),\n            isKeySide = side === \"key\",\n            locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,\n            isExtra = diff > 0,\n            diffAbs = Math.abs(diff),\n            spaces = Array(diffAbs + 1).join(\" \");\n\n      if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\" || diff > 0 && !expected && mode === \"minimum\") && !(expected && containsLineTerminator(whitespace))) {\n        let fix;\n\n        if (isExtra) {\n          let range; // Remove whitespace\n\n          if (isKeySide) {\n            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n          } else {\n            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n          }\n\n          fix = function (fixer) {\n            return fixer.removeRange(range);\n          };\n        } else {\n          // Add whitespace\n          if (isKeySide) {\n            fix = function (fixer) {\n              return fixer.insertTextAfter(tokenBeforeColon, spaces);\n            };\n          } else {\n            fix = function (fixer) {\n              return fixer.insertTextBefore(tokenAfterColon, spaces);\n            };\n          }\n        }\n\n        let messageId = \"\";\n\n        if (isExtra) {\n          messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n        } else {\n          messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n        }\n\n        context.report({\n          node: property[side],\n          loc: locStart,\n          messageId,\n          data: {\n            computed: property.computed ? \"computed \" : \"\",\n            key: getKey(property)\n          },\n          fix\n        });\n      }\n    }\n    /**\n     * Gets the number of characters in a key, including quotes around string\n     * keys and braces around computed property keys.\n     * @param {ASTNode} property Property of on object literal.\n     * @returns {int} Width of the key.\n     */\n\n\n    function getKeyWidth(property) {\n      const startToken = sourceCode.getFirstToken(property);\n      const endToken = getLastTokenBeforeColon(property.key);\n      return endToken.range[1] - startToken.range[0];\n    }\n    /**\n     * Gets the whitespace around the colon in an object literal property.\n     * @param {ASTNode} property Property node from an object literal.\n     * @returns {Object} Whitespace before and after the property's colon.\n     */\n\n\n    function getPropertyWhitespace(property) {\n      const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));\n\n      if (whitespace) {\n        return {\n          beforeColon: whitespace[1],\n          afterColon: whitespace[2]\n        };\n      }\n\n      return null;\n    }\n    /**\n     * Creates groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n     */\n\n\n    function createGroups(node) {\n      if (node.properties.length === 1) {\n        return [node.properties];\n      }\n\n      return node.properties.reduce((groups, property) => {\n        const currentGroup = last(groups),\n              prev = last(currentGroup);\n\n        if (!prev || continuesPropertyGroup(prev, property)) {\n          currentGroup.push(property);\n        } else {\n          groups.push([property]);\n        }\n\n        return groups;\n      }, [[]]);\n    }\n    /**\n     * Verifies correct vertical alignment of a group of properties.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @returns {void}\n     */\n\n\n    function verifyGroupAlignment(properties) {\n      const length = properties.length,\n            widths = properties.map(getKeyWidth),\n            // Width of keys, including quotes\n      align = alignmentOptions.on; // \"value\" or \"colon\"\n\n      let targetWidth = Math.max(...widths),\n          beforeColon,\n          afterColon,\n          mode;\n\n      if (alignmentOptions && length > 1) {\n        // When aligning values within a group, use the alignment configuration.\n        beforeColon = alignmentOptions.beforeColon;\n        afterColon = alignmentOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } else {\n        beforeColon = multiLineOptions.beforeColon;\n        afterColon = multiLineOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } // Conditionally include one space before or after colon\n\n\n      targetWidth += align === \"colon\" ? beforeColon : afterColon;\n\n      for (let i = 0; i < length; i++) {\n        const property = properties[i];\n        const whitespace = getPropertyWhitespace(property);\n\n        if (whitespace) {\n          // Object literal getters/setters lack a colon\n          const width = widths[i];\n\n          if (align === \"value\") {\n            report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n            report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n          } else {\n            // align = \"colon\"\n            report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n            report(property, \"value\", whitespace.afterColon, afterColon, mode);\n          }\n        }\n      }\n    }\n    /**\n     * Verifies spacing of property conforms to specified options.\n     * @param  {ASTNode} node Property node being evaluated.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n\n\n    function verifySpacing(node, lineOptions) {\n      const actual = getPropertyWhitespace(node);\n\n      if (actual) {\n        // Object literal getters/setters lack colons\n        report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n        report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n      }\n    }\n    /**\n     * Verifies spacing of each property in a list.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @param {Object} lineOptions Configured singleLine or multiLine options\n     * @returns {void}\n     */\n\n\n    function verifyListSpacing(properties, lineOptions) {\n      const length = properties.length;\n\n      for (let i = 0; i < length; i++) {\n        verifySpacing(properties[i], lineOptions);\n      }\n    }\n    /**\n     * Verifies vertical alignment, taking into account groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {void}\n     */\n\n\n    function verifyAlignment(node) {\n      createGroups(node).forEach(group => {\n        const properties = group.filter(isKeyValueProperty);\n\n        if (properties.length > 0 && isSingleLineProperties(properties)) {\n          verifyListSpacing(properties, multiLineOptions);\n        } else {\n          verifyGroupAlignment(properties);\n        }\n      });\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    if (alignmentOptions) {\n      // Verify vertical alignment\n      return {\n        ObjectExpression(node) {\n          if (isSingleLine(node)) {\n            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n          } else {\n            verifyAlignment(node);\n          }\n        }\n\n      };\n    } // Obey beforeColon and afterColon in each property as configured\n\n\n    return {\n      Property(node) {\n        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/key-spacing.js"],"names":["astUtils","require","containsLineTerminator","str","LINEBREAK_MATCHER","test","last","arr","length","isSingleLine","node","loc","end","line","start","isSingleLineProperties","properties","firstProp","lastProp","initOptionProperty","toOptions","fromOptions","mode","beforeColon","afterColon","align","on","initOptions","multiLine","singleLine","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","enum","additionalProperties","messages","extraKey","extraValue","missingKey","missingValue","create","context","options","ruleOptions","multiLineOptions","singleLineOptions","alignmentOptions","sourceCode","getSourceCode","continuesPropertyGroup","lastMember","candidate","groupEndLine","candidateStartLine","leadingComments","getCommentsBefore","i","isKeyValueProperty","property","method","shorthand","kind","getLastTokenBeforeColon","colonToken","getTokenAfter","isColonToken","getTokenBefore","getNextColon","getKey","key","computed","getText","slice","range","name","value","report","side","whitespace","expected","diff","nextColon","tokenBeforeColon","includeComments","tokenAfterColon","isKeySide","locStart","isExtra","diffAbs","Math","abs","spaces","Array","join","fix","fixer","removeRange","insertTextAfter","insertTextBefore","messageId","data","getKeyWidth","startToken","getFirstToken","endToken","getPropertyWhitespace","exec","createGroups","reduce","groups","currentGroup","prev","push","verifyGroupAlignment","widths","map","targetWidth","max","width","verifySpacing","lineOptions","actual","verifyListSpacing","verifyAlignment","forEach","group","filter","ObjectExpression","Property","parent"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properies is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n    const [firstProp] = properties,\n        lastProp = last(properties);\n\n    return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/key-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        messages: {\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateStartLine = candidate.loc.start.line;\n\n            if (candidateStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n\n            return property.key.name || property.key.value;\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                let messageId = \"\";\n\n                if (isExtra) {\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n                } else {\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n                }\n\n                context.report({\n                    node: property[side],\n                    loc: locStart,\n                    messageId,\n                    data: {\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max(...widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifyListSpacing(properties, lineOptions) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], lineOptions);\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                const properties = group.filter(isKeyValueProperty);\n\n                if (properties.length > 0 && isSingleLineProperties(properties)) {\n                    verifyListSpacing(properties, multiLineOptions);\n                } else {\n                    verifyGroupAlignment(properties);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}