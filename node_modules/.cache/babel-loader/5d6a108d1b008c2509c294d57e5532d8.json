{"ast":null,"code":"'use strict';\n\nvar regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,\n    regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/,\n    regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n/**\n * Convert transform string to JS representation.\n *\n * @param {String} transformString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\nexports.transform2js = function (transformString) {\n  // JS representation of the transform data\n  var transforms = [],\n      // current transform context\n  current; // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n\n  transformString.split(regTransformSplit).forEach(function (item) {\n    /*jshint -W084 */\n    var num;\n\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        transforms.push(current = {\n          name: item\n        }); // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        while (num = regNumericValues.exec(item)) {\n          num = Number(num);\n          if (current.data) current.data.push(num);else current.data = [num];\n        }\n      }\n    }\n  }); // return empty array if broken transform (no data)\n\n  return current && current.data ? transforms : [];\n};\n/**\n * Multiply transforms into one.\n *\n * @param {Array} input transforms array\n * @return {Array} output matrix array\n */\n\n\nexports.transformsMultiply = function (transforms) {\n  // convert transforms objects to the matrices\n  transforms = transforms.map(function (transform) {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n\n    return transformToMatrix(transform);\n  }); // multiply all matrices into one\n\n  transforms = {\n    name: 'matrix',\n    data: transforms.length > 0 ? transforms.reduce(multiplyTransformMatrices) : []\n  };\n  return transforms;\n};\n/**\n * Do math like a schoolgirl.\n *\n * @type {Object}\n */\n\n\nvar mth = exports.mth = {\n  rad: function (deg) {\n    return deg * Math.PI / 180;\n  },\n  deg: function (rad) {\n    return rad * 180 / Math.PI;\n  },\n  cos: function (deg) {\n    return Math.cos(this.rad(deg));\n  },\n  acos: function (val, floatPrecision) {\n    return +this.deg(Math.acos(val)).toFixed(floatPrecision);\n  },\n  sin: function (deg) {\n    return Math.sin(this.rad(deg));\n  },\n  asin: function (val, floatPrecision) {\n    return +this.deg(Math.asin(val)).toFixed(floatPrecision);\n  },\n  tan: function (deg) {\n    return Math.tan(this.rad(deg));\n  },\n  atan: function (val, floatPrecision) {\n    return +this.deg(Math.atan(val)).toFixed(floatPrecision);\n  }\n};\n/**\n * Decompose matrix into simple transforms. See\n * http://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @param {Object} data matrix transform object\n * @return {Object|Array} transforms array or original transform object\n */\n\nexports.matrixToTransform = function (transform, params) {\n  var floatPrecision = params.floatPrecision,\n      data = transform.data,\n      transforms = [],\n      sx = +Math.hypot(data[0], data[1]).toFixed(params.transformPrecision),\n      sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision),\n      colsSum = data[0] * data[2] + data[1] * data[3],\n      rowsSum = data[0] * data[1] + data[2] * data[3],\n      scaleBefore = rowsSum != 0 || sx == sy; // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5)\n    });\n  } // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n\n\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)]\n    }); // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)]\n    });\n    sx = data[0];\n    sy = data[3]; // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n      transforms.push({\n        name: 'scale',\n        data: [sx, sy]\n      });\n    }\n\n    var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n        rotate = [mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)];\n    if (rotate[0]) transforms.push({\n      name: 'rotate',\n      data: rotate\n    });\n    if (rowsSum && colsSum) transforms.push({\n      name: 'skewX',\n      data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n    }); // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n          sin = data[1] / (scaleBefore ? sx : sy),\n          x = data[4] * (scaleBefore || sy),\n          y = data[5] * (scaleBefore || sx),\n          denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    } // Too many transformations, return original matrix if it isn't just a scale/translate\n\n  } else if (data[1] || data[2]) {\n    return transform;\n  }\n\n  if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n    name: 'scale',\n    data: sx == sy ? [sx] : [sx, sy]\n  });\n  return transforms;\n};\n/**\n * Convert transform to the matrix data.\n *\n * @param {Object} transform transform object\n * @return {Array} matrix data\n */\n\n\nfunction transformToMatrix(transform) {\n  if (transform.name === 'matrix') return transform.data;\n  var matrix;\n\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n      break;\n\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      matrix = [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n      break;\n\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n          sin = mth.sin(transform.data[0]),\n          cx = transform.data[1] || 0,\n          cy = transform.data[2] || 0;\n      matrix = [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n      break;\n\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n      break;\n\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n      break;\n  }\n\n  return matrix;\n}\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @param {Array} arc [a, b, rotation in deg]\n * @param {Array} transform transformation matrix\n * @return {Array} arc transformed input arc\n */\n\n\nexports.transformArc = function (arc, transform) {\n  var a = arc[0],\n      b = arc[1],\n      rot = arc[2] * Math.PI / 180,\n      cos = Math.cos(rot),\n      sin = Math.sin(rot),\n      h = Math.pow(arc[5] * cos + arc[6] * sin, 2) / (4 * a * a) + Math.pow(arc[6] * cos - arc[5] * sin, 2) / (4 * b * b);\n\n  if (h > 1) {\n    h = Math.sqrt(h);\n    a *= h;\n    b *= h;\n  }\n\n  var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],\n      m = multiplyTransformMatrices(transform, ellipse),\n      // Decompose the new ellipse matrix\n  lastCol = m[2] * m[2] + m[3] * m[3],\n      squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,\n      root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    var majorAxisSqr = (squareSum + root) / 2,\n        minorAxisSqr = (squareSum - root) / 2,\n        major = Math.abs(majorAxisSqr - lastCol) > 1e-6,\n        sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,\n        rowsSum = m[0] * m[2] + m[1] * m[3],\n        term1 = m[0] * sub + m[2] * rowsSum,\n        term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;\n  }\n\n  if (transform[0] < 0 !== transform[3] < 0) {\n    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n    arc[4] = 1 - arc[4];\n  }\n\n  return arc;\n};\n/**\n * Multiply transformation matrices.\n *\n * @param {Array} a matrix A data\n * @param {Array} b matrix B data\n * @return {Array} result\n */\n\n\nfunction multiplyTransformMatrices(a, b) {\n  return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/svgo/plugins/_transforms.js"],"names":["regTransformTypes","regTransformSplit","regNumericValues","exports","transform2js","transformString","transforms","current","split","forEach","item","num","test","push","name","exec","Number","data","transformsMultiply","map","transform","transformToMatrix","length","reduce","multiplyTransformMatrices","mth","rad","deg","Math","PI","cos","acos","val","floatPrecision","toFixed","sin","asin","tan","atan","matrixToTransform","params","sx","hypot","transformPrecision","sy","colsSum","rowsSum","scaleBefore","slice","angle","min","max","rotate","shift","x","y","denom","pow","matrix","cx","cy","transformArc","arc","a","b","rot","h","sqrt","ellipse","m","lastCol","squareSum","root","majorAxisSqr","minorAxisSqr","major","abs","sub","term1","term2"],"mappings":"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","sourcesContent":["'use strict';\n\nvar regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,\n    regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/,\n    regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Convert transform string to JS representation.\n *\n * @param {String} transformString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.transform2js = function(transformString) {\n\n        // JS representation of the transform data\n    var transforms = [],\n        // current transform context\n        current;\n\n    // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n    transformString.split(regTransformSplit).forEach(function(item) {\n        /*jshint -W084 */\n        var num;\n\n        if (item) {\n            // if item is a translate function\n            if (regTransformTypes.test(item)) {\n                // then collect it and change current context\n                transforms.push(current = { name: item });\n            // else if item is data\n            } else {\n                // then split it into [10, 50] and collect as context.data\n                while (num = regNumericValues.exec(item)) {\n                    num = Number(num);\n                    if (current.data)\n                        current.data.push(num);\n                    else\n                        current.data = [num];\n                }\n            }\n        }\n    });\n\n    // return empty array if broken transform (no data)\n    return current && current.data ? transforms : [];\n};\n\n/**\n * Multiply transforms into one.\n *\n * @param {Array} input transforms array\n * @return {Array} output matrix array\n */\nexports.transformsMultiply = function(transforms) {\n\n    // convert transforms objects to the matrices\n    transforms = transforms.map(function(transform) {\n        if (transform.name === 'matrix') {\n            return transform.data;\n        }\n        return transformToMatrix(transform);\n    });\n\n    // multiply all matrices into one\n    transforms = {\n        name: 'matrix',\n        data: transforms.length > 0 ? transforms.reduce(multiplyTransformMatrices) : []\n    };\n\n    return transforms;\n\n};\n\n/**\n * Do math like a schoolgirl.\n *\n * @type {Object}\n */\nvar mth = exports.mth = {\n\n    rad: function(deg) {\n        return deg * Math.PI / 180;\n    },\n\n    deg: function(rad) {\n        return rad * 180 / Math.PI;\n    },\n\n    cos: function(deg) {\n        return Math.cos(this.rad(deg));\n    },\n\n    acos: function(val, floatPrecision) {\n        return +(this.deg(Math.acos(val)).toFixed(floatPrecision));\n    },\n\n    sin: function(deg) {\n        return Math.sin(this.rad(deg));\n    },\n\n    asin: function(val, floatPrecision) {\n        return +(this.deg(Math.asin(val)).toFixed(floatPrecision));\n    },\n\n    tan: function(deg) {\n        return Math.tan(this.rad(deg));\n    },\n\n    atan: function(val, floatPrecision) {\n        return +(this.deg(Math.atan(val)).toFixed(floatPrecision));\n    }\n\n};\n\n/**\n * Decompose matrix into simple transforms. See\n * http://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @param {Object} data matrix transform object\n * @return {Object|Array} transforms array or original transform object\n */\nexports.matrixToTransform = function(transform, params) {\n    var floatPrecision = params.floatPrecision,\n        data = transform.data,\n        transforms = [],\n        sx = +Math.hypot(data[0], data[1]).toFixed(params.transformPrecision),\n        sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision),\n        colsSum = data[0] * data[2] + data[1] * data[3],\n        rowsSum = data[0] * data[1] + data[2] * data[3],\n        scaleBefore = rowsSum != 0 || sx == sy;\n\n    // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n    if (data[4] || data[5]) {\n        transforms.push({ name: 'translate', data: data.slice(4, data[5] ? 6 : 5) });\n    }\n\n    // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n    if (!data[1] && data[2]) {\n        transforms.push({ name: 'skewX', data: [mth.atan(data[2] / sy, floatPrecision)] });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n    } else if (data[1] && !data[2]) {\n        transforms.push({ name: 'skewY', data: [mth.atan(data[1] / data[0], floatPrecision)] });\n        sx = data[0];\n        sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n    } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {\n        if (!scaleBefore) {\n            sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n            sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n            transforms.push({ name: 'scale', data: [sx, sy] });\n        }\n        var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n            rotate = [mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)];\n\n        if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });\n\n        if (rowsSum && colsSum) transforms.push({\n            name: 'skewX',\n            data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n        });\n\n        // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n        if (rotate[0] && (data[4] || data[5])) {\n            transforms.shift();\n            var cos = data[0] / sx,\n                sin = data[1] / (scaleBefore ? sx : sy),\n                x = data[4] * (scaleBefore || sy),\n                y = data[5] * (scaleBefore || sx),\n                denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);\n            rotate.push(((1 - cos) * x - sin * y) / denom);\n            rotate.push(((1 - cos) * y + sin * x) / denom);\n        }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n    } else if (data[1] || data[2]) {\n        return transform;\n    }\n\n    if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n        name: 'scale',\n        data: sx == sy ? [sx] : [sx, sy]\n    });\n\n    return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @param {Object} transform transform object\n * @return {Array} matrix data\n */\nfunction transformToMatrix(transform) {\n\n    if (transform.name === 'matrix') return transform.data;\n\n    var matrix;\n\n    switch (transform.name) {\n        case 'translate':\n            // [1, 0, 0, 1, tx, ty]\n            matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n            break;\n        case 'scale':\n            // [sx, 0, 0, sy, 0, 0]\n            matrix = [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n            break;\n        case 'rotate':\n            // [cos(a), sin(a), -sin(a), cos(a), x, y]\n            var cos = mth.cos(transform.data[0]),\n                sin = mth.sin(transform.data[0]),\n                cx = transform.data[1] || 0,\n                cy = transform.data[2] || 0;\n\n            matrix = [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n            break;\n        case 'skewX':\n            // [1, 0, tan(a), 1, 0, 0]\n            matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n            break;\n        case 'skewY':\n            // [1, tan(a), 0, 1, 0, 0]\n            matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n            break;\n    }\n\n    return matrix;\n\n}\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @param {Array} arc [a, b, rotation in deg]\n * @param {Array} transform transformation matrix\n * @return {Array} arc transformed input arc\n */\nexports.transformArc = function(arc, transform) {\n\n    var a = arc[0],\n        b = arc[1],\n        rot = arc[2] * Math.PI / 180,\n        cos = Math.cos(rot),\n        sin = Math.sin(rot),\n        h = Math.pow(arc[5] * cos + arc[6] * sin, 2) / (4 * a * a) +\n            Math.pow(arc[6] * cos - arc[5] * sin, 2) / (4 * b * b);\n    if (h > 1) {\n        h = Math.sqrt(h);\n        a *= h;\n        b *= h;\n    }\n    var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],\n        m = multiplyTransformMatrices(transform, ellipse),\n        // Decompose the new ellipse matrix\n        lastCol = m[2] * m[2] + m[3] * m[3],\n        squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,\n        root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n\n    if (!root) { // circle\n        arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n        arc[2] = 0;\n    } else {\n        var majorAxisSqr = (squareSum + root) / 2,\n            minorAxisSqr = (squareSum - root) / 2,\n            major = Math.abs(majorAxisSqr - lastCol) > 1e-6,\n            sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,\n            rowsSum = m[0] * m[2] + m[1] * m[3],\n            term1 = m[0] * sub + m[2] * rowsSum,\n            term2 = m[1] * sub + m[3] * rowsSum;\n        arc[0] = Math.sqrt(majorAxisSqr);\n        arc[1] = Math.sqrt(minorAxisSqr);\n        arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) *\n            Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;\n    }\n\n    if ((transform[0] < 0) !== (transform[3] < 0)) {\n        // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n        arc[4] = 1 - arc[4];\n    }\n\n    return arc;\n\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @param {Array} a matrix A data\n * @param {Array} b matrix B data\n * @return {Array} result\n */\nfunction multiplyTransformMatrices(a, b) {\n\n    return [\n        a[0] * b[0] + a[2] * b[1],\n        a[1] * b[0] + a[3] * b[1],\n        a[0] * b[2] + a[2] * b[3],\n        a[1] * b[2] + a[3] * b[3],\n        a[0] * b[4] + a[2] * b[5] + a[4],\n        a[1] * b[4] + a[3] * b[5] + a[5]\n    ];\n\n}\n"]},"metadata":{},"sourceType":"script"}