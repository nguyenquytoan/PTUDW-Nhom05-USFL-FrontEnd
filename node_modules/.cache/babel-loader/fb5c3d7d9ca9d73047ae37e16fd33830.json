{"ast":null,"code":"\"use strict\";\n\nconst {\n  minify: terserMinify\n} = require('terser');\n\nconst buildTerserOptions = ({\n  ecma,\n  warnings,\n  parse = {},\n  compress = {},\n  mangle,\n  module,\n  output,\n  toplevel,\n  nameCache,\n  ie8,\n\n  /* eslint-disable camelcase */\n  keep_classnames,\n  keep_fnames,\n\n  /* eslint-enable camelcase */\n  safari10\n} = {}) => ({\n  ecma,\n  warnings,\n  parse: { ...parse\n  },\n  compress: typeof compress === 'boolean' ? compress : { ...compress\n  },\n  // eslint-disable-next-line no-nested-ternary\n  mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : { ...mangle\n  },\n  output: {\n    beautify: false,\n    ...output\n  },\n  module,\n  // Ignoring sourceMap from options\n  sourceMap: null,\n  toplevel,\n  nameCache,\n  ie8,\n  keep_classnames,\n  keep_fnames,\n  safari10\n});\n\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nconst buildComments = (options, terserOptions, extractedComments) => {\n  const condition = {};\n  const commentsOpts = terserOptions.output.comments;\n  const {\n    extractComments\n  } = options;\n  condition.preserve = typeof commentsOpts !== 'undefined' ? commentsOpts : false;\n\n  if (typeof extractComments === 'boolean' && extractComments) {\n    condition.extract = 'some';\n  } else if (typeof extractComments === 'string' || extractComments instanceof RegExp) {\n    condition.extract = extractComments;\n  } else if (typeof extractComments === 'function') {\n    condition.extract = extractComments;\n  } else if (isObject(extractComments)) {\n    condition.extract = typeof extractComments.condition === 'boolean' && extractComments.condition ? 'some' : typeof extractComments.condition !== 'undefined' ? extractComments.condition : 'some';\n  } else {\n    // No extract\n    // Preserve using \"commentsOpts\" or \"some\"\n    condition.preserve = typeof commentsOpts !== 'undefined' ? commentsOpts : 'some';\n    condition.extract = false;\n  } // Ensure that both conditions are functions\n\n\n  ['preserve', 'extract'].forEach(key => {\n    let regexStr;\n    let regex;\n\n    switch (typeof condition[key]) {\n      case 'boolean':\n        condition[key] = condition[key] ? () => true : () => false;\n        break;\n\n      case 'function':\n        break;\n\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = () => true;\n\n          break;\n        }\n\n        if (condition[key] === 'some') {\n          condition[key] = (astNode, comment) => {\n            return comment.type === 'comment2' && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n          };\n\n          break;\n        }\n\n        regexStr = condition[key];\n\n        condition[key] = (astNode, comment) => {\n          return new RegExp(regexStr).test(comment.value);\n        };\n\n        break;\n\n      default:\n        regex = condition[key];\n\n        condition[key] = (astNode, comment) => regex.test(comment.value);\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return (astNode, comment) => {\n    if (condition.extract(astNode, comment)) {\n      const commentText = comment.type === 'comment2' ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return condition.preserve(astNode, comment);\n  };\n};\n\nconst minify = options => {\n  const {\n    file,\n    input,\n    inputSourceMap,\n    minify: minifyFn\n  } = options;\n\n  if (minifyFn) {\n    return minifyFn({\n      [file]: input\n    }, inputSourceMap);\n  } // Copy terser options\n\n\n  const terserOptions = buildTerserOptions(options.terserOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n\n  const extractedComments = [];\n  terserOptions.output.comments = buildComments(options, terserOptions, extractedComments);\n  const {\n    error,\n    map,\n    code,\n    warnings\n  } = terserMinify({\n    [file]: input\n  }, terserOptions);\n  return {\n    error,\n    map,\n    code,\n    warnings,\n    extractedComments\n  };\n};\n\nmodule.exports = minify;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/terser-webpack-plugin/dist/minify.js"],"names":["minify","terserMinify","require","buildTerserOptions","ecma","warnings","parse","compress","mangle","module","output","toplevel","nameCache","ie8","keep_classnames","keep_fnames","safari10","beautify","sourceMap","isObject","value","type","buildComments","options","terserOptions","extractedComments","condition","commentsOpts","comments","extractComments","preserve","extract","RegExp","forEach","key","regexStr","regex","astNode","comment","test","commentText","includes","push","file","input","inputSourceMap","minifyFn","asObject","error","map","code","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst {\n  minify: terserMinify\n} = require('terser');\n\nconst buildTerserOptions = ({\n  ecma,\n  warnings,\n  parse = {},\n  compress = {},\n  mangle,\n  module,\n  output,\n  toplevel,\n  nameCache,\n  ie8,\n\n  /* eslint-disable camelcase */\n  keep_classnames,\n  keep_fnames,\n\n  /* eslint-enable camelcase */\n  safari10\n} = {}) => ({\n  ecma,\n  warnings,\n  parse: { ...parse\n  },\n  compress: typeof compress === 'boolean' ? compress : { ...compress\n  },\n  // eslint-disable-next-line no-nested-ternary\n  mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : { ...mangle\n  },\n  output: {\n    beautify: false,\n    ...output\n  },\n  module,\n  // Ignoring sourceMap from options\n  sourceMap: null,\n  toplevel,\n  nameCache,\n  ie8,\n  keep_classnames,\n  keep_fnames,\n  safari10\n});\n\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nconst buildComments = (options, terserOptions, extractedComments) => {\n  const condition = {};\n  const commentsOpts = terserOptions.output.comments;\n  const {\n    extractComments\n  } = options;\n  condition.preserve = typeof commentsOpts !== 'undefined' ? commentsOpts : false;\n\n  if (typeof extractComments === 'boolean' && extractComments) {\n    condition.extract = 'some';\n  } else if (typeof extractComments === 'string' || extractComments instanceof RegExp) {\n    condition.extract = extractComments;\n  } else if (typeof extractComments === 'function') {\n    condition.extract = extractComments;\n  } else if (isObject(extractComments)) {\n    condition.extract = typeof extractComments.condition === 'boolean' && extractComments.condition ? 'some' : typeof extractComments.condition !== 'undefined' ? extractComments.condition : 'some';\n  } else {\n    // No extract\n    // Preserve using \"commentsOpts\" or \"some\"\n    condition.preserve = typeof commentsOpts !== 'undefined' ? commentsOpts : 'some';\n    condition.extract = false;\n  } // Ensure that both conditions are functions\n\n\n  ['preserve', 'extract'].forEach(key => {\n    let regexStr;\n    let regex;\n\n    switch (typeof condition[key]) {\n      case 'boolean':\n        condition[key] = condition[key] ? () => true : () => false;\n        break;\n\n      case 'function':\n        break;\n\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = () => true;\n\n          break;\n        }\n\n        if (condition[key] === 'some') {\n          condition[key] = (astNode, comment) => {\n            return comment.type === 'comment2' && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n          };\n\n          break;\n        }\n\n        regexStr = condition[key];\n\n        condition[key] = (astNode, comment) => {\n          return new RegExp(regexStr).test(comment.value);\n        };\n\n        break;\n\n      default:\n        regex = condition[key];\n\n        condition[key] = (astNode, comment) => regex.test(comment.value);\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return (astNode, comment) => {\n    if (condition.extract(astNode, comment)) {\n      const commentText = comment.type === 'comment2' ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return condition.preserve(astNode, comment);\n  };\n};\n\nconst minify = options => {\n  const {\n    file,\n    input,\n    inputSourceMap,\n    minify: minifyFn\n  } = options;\n\n  if (minifyFn) {\n    return minifyFn({\n      [file]: input\n    }, inputSourceMap);\n  } // Copy terser options\n\n\n  const terserOptions = buildTerserOptions(options.terserOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n\n  const extractedComments = [];\n  terserOptions.output.comments = buildComments(options, terserOptions, extractedComments);\n  const {\n    error,\n    map,\n    code,\n    warnings\n  } = terserMinify({\n    [file]: input\n  }, terserOptions);\n  return {\n    error,\n    map,\n    code,\n    warnings,\n    extractedComments\n  };\n};\n\nmodule.exports = minify;"]},"metadata":{},"sourceType":"script"}