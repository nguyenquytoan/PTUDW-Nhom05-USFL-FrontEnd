{"ast":null,"code":"'use strict';\n\nconst postcss = require('postcss');\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error(`composition is only allowed when selector is single :local class name not in \"${root}\"`);\n    }\n\n    node = node.nodes[0];\n\n    if (node.type !== 'pseudo' || node.value !== ':local' || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    node = node.first;\n\n    if (node.type !== 'selector' || node.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    node = node.first;\n\n    if (node.type !== 'class') {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\nconst unescapeRegExp = new RegExp('\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig');\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = '0x' + escaped - 0x10000; // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n\n    return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n    String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n  });\n}\n\nconst processor = postcss.plugin('postcss-modules-scope', function (options) {\n  return css => {\n    const generateScopedName = options && options.generateScopedName || processor.generateScopedName;\n    const generateExportEntry = options && options.generateExportEntry || processor.generateExportEntry;\n    const exportGlobals = options && options.exportGlobals;\n    const exports = Object.create(null);\n\n    function exportScopedName(name, rawName) {\n      const scopedName = generateScopedName(rawName ? rawName : name, css.source.input.from, css.source.input.css);\n      const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, css.source.input.from, css.source.input.css);\n      const {\n        key,\n        value\n      } = exportEntry;\n      exports[key] = exports[key] || [];\n\n      if (exports[key].indexOf(value) < 0) {\n        exports[key].push(value);\n      }\n\n      return scopedName;\n    }\n\n    function localizeNode(node) {\n      switch (node.type) {\n        case 'selector':\n          node.nodes = node.map(localizeNode);\n          return node;\n\n        case 'class':\n          return selectorParser.className({\n            value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n          });\n\n        case 'id':\n          {\n            return selectorParser.id({\n              value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n            });\n          }\n      }\n\n      throw new Error(`${node.type} (\"${node}\") is not allowed in a :local block`);\n    }\n\n    function traverseNode(node) {\n      switch (node.type) {\n        case 'pseudo':\n          if (node.value === ':local') {\n            if (node.nodes.length !== 1) {\n              throw new Error('Unexpected comma (\",\") in :local block');\n            }\n\n            const selector = localizeNode(node.first, node.spaces); // move the spaces that were around the psuedo selector to the first\n            // non-container node\n\n            selector.first.spaces = node.spaces;\n            const nextNode = node.next();\n\n            if (nextNode && nextNode.type === 'combinator' && nextNode.value === ' ' && /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)) {\n              selector.last.spaces.after = ' ';\n            }\n\n            node.replaceWith(selector);\n            return;\n          }\n\n        /* falls through */\n\n        case 'root':\n        case 'selector':\n          {\n            node.each(traverseNode);\n            break;\n          }\n\n        case 'id':\n        case 'class':\n          if (exportGlobals) {\n            exports[node.value] = [node.value];\n          }\n\n          break;\n      }\n\n      return node;\n    } // Find any :import and remember imported names\n\n\n    const importedNames = {};\n    css.walkRules(rule => {\n      if (/^:import\\(.+\\)$/.test(rule.selector)) {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      }\n    }); // Find any :local classes\n\n    css.walkRules(rule => {\n      if (rule.nodes && rule.selector.slice(0, 2) === '--' && rule.selector.slice(-1) === ':') {\n        // ignore custom property set\n        return;\n      }\n\n      let parsedSelector = selectorParser().astSync(rule);\n      rule.selector = traverseNode(parsedSelector.clone()).toString();\n      rule.walkDecls(/composes|compose-with/, decl => {\n        const localNames = getSingleLocalNamesForComposes(parsedSelector);\n        const classes = decl.value.split(/\\s+/);\n        classes.forEach(className => {\n          const global = /^global\\(([^\\)]+)\\)$/.exec(className);\n\n          if (global) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(global[1]);\n            });\n          } else if (hasOwnProperty.call(importedNames, className)) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(className);\n            });\n          } else if (hasOwnProperty.call(exports, className)) {\n            localNames.forEach(exportedName => {\n              exports[className].forEach(item => {\n                exports[exportedName].push(item);\n              });\n            });\n          } else {\n            throw decl.error(`referenced class name \"${className}\" in ${decl.prop} not found`);\n          }\n        });\n        decl.remove();\n      });\n      rule.walkDecls(decl => {\n        let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n        tokens = tokens.map((token, idx) => {\n          if (idx === 0 || tokens[idx - 1] === ',') {\n            const localMatch = /^(\\s*):local\\s*\\((.+?)\\)/.exec(token);\n\n            if (localMatch) {\n              return localMatch[1] + exportScopedName(localMatch[2]) + token.substr(localMatch[0].length);\n            } else {\n              return token;\n            }\n          } else {\n            return token;\n          }\n        });\n        decl.value = tokens.join('');\n      });\n    }); // Find any :local keyframes\n\n    css.walkAtRules(atrule => {\n      if (/keyframes$/i.test(atrule.name)) {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atrule.params);\n\n        if (localMatch) {\n          atrule.params = exportScopedName(localMatch[1]);\n        }\n      }\n    }); // If we found any :locals, insert an :export rule\n\n    const exportedNames = Object.keys(exports);\n\n    if (exportedNames.length > 0) {\n      const exportRule = postcss.rule({\n        selector: ':export'\n      });\n      exportedNames.forEach(exportedName => exportRule.append({\n        prop: exportedName,\n        value: exports[exportedName].join(' '),\n        raws: {\n          before: '\\n  '\n        }\n      }));\n      css.append(exportRule);\n    }\n  };\n});\n\nprocessor.generateScopedName = function (name, path) {\n  const sanitisedPath = path.replace(/\\.[^\\.\\/\\\\]+$/, '').replace(/[\\W_]+/g, '_').replace(/^_|_$/g, '');\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nprocessor.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName)\n  };\n};\n\nmodule.exports = processor;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-modules-scope/src/index.js"],"names":["postcss","require","selectorParser","hasOwnProperty","Object","prototype","getSingleLocalNamesForComposes","root","nodes","map","node","type","length","Error","value","first","whitespace","unescapeRegExp","RegExp","unescape","str","replace","_","escaped","escapedWhitespace","high","String","fromCharCode","processor","plugin","options","css","generateScopedName","generateExportEntry","exportGlobals","exports","create","exportScopedName","name","rawName","scopedName","source","input","from","exportEntry","key","indexOf","push","localizeNode","className","raws","id","traverseNode","selector","spaces","nextNode","next","test","last","after","replaceWith","each","importedNames","walkRules","rule","walkDecls","decl","prop","slice","parsedSelector","astSync","clone","toString","localNames","classes","split","forEach","global","exec","exportedName","call","item","error","remove","tokens","token","idx","localMatch","substr","join","walkAtRules","atrule","params","exportedNames","keys","exportRule","append","before","path","sanitisedPath","trim","module"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,yBAAD,CAA9B;;AAEA,MAAME,cAAc,GAAGC,MAAM,CAACC,SAAP,CAAiBF,cAAxC;;AAEA,SAASG,8BAAT,CAAwCC,IAAxC,EAA8C;AAC5C,SAAOA,IAAI,CAACC,KAAL,CAAWC,GAAX,CAAeC,IAAI,IAAI;AAC5B,QAAIA,IAAI,CAACC,IAAL,KAAc,UAAd,IAA4BD,IAAI,CAACF,KAAL,CAAWI,MAAX,KAAsB,CAAtD,EAAyD;AACvD,YAAM,IAAIC,KAAJ,CACH,iFAAgFN,IAAK,GADlF,CAAN;AAGD;;AAEDG,IAAAA,IAAI,GAAGA,IAAI,CAACF,KAAL,CAAW,CAAX,CAAP;;AAEA,QACEE,IAAI,CAACC,IAAL,KAAc,QAAd,IACAD,IAAI,CAACI,KAAL,KAAe,QADf,IAEAJ,IAAI,CAACF,KAAL,CAAWI,MAAX,KAAsB,CAHxB,EAIE;AACA,YAAM,IAAIC,KAAJ,CACJ,mFACEN,IADF,GAEE,MAFF,GAGEG,IAHF,GAIE,YALE,CAAN;AAOD;;AAEDA,IAAAA,IAAI,GAAGA,IAAI,CAACK,KAAZ;;AAEA,QAAIL,IAAI,CAACC,IAAL,KAAc,UAAd,IAA4BD,IAAI,CAACE,MAAL,KAAgB,CAAhD,EAAmD;AACjD,YAAM,IAAIC,KAAJ,CACJ,mFACEN,IADF,GAEE,MAFF,GAGEG,IAHF,GAIE,YALE,CAAN;AAOD;;AAEDA,IAAAA,IAAI,GAAGA,IAAI,CAACK,KAAZ;;AAEA,QAAIL,IAAI,CAACC,IAAL,KAAc,OAAlB,EAA2B;AACzB;AACA,YAAM,IAAIE,KAAJ,CACJ,mFACEN,IADF,GAEE,MAFF,GAGEG,IAHF,GAIE,YALE,CAAN;AAOD;;AAED,WAAOA,IAAI,CAACI,KAAZ;AACD,GAjDM,CAAP;AAkDD;;AAED,MAAME,UAAU,GAAG,qBAAnB;AACA,MAAMC,cAAc,GAAG,IAAIC,MAAJ,CACrB,uBAAuBF,UAAvB,GAAoC,KAApC,GAA4CA,UAA5C,GAAyD,MADpC,EAErB,IAFqB,CAAvB;;AAKA,SAASG,QAAT,CAAkBC,GAAlB,EAAuB;AACrB,SAAOA,GAAG,CAACC,OAAJ,CAAYJ,cAAZ,EAA4B,CAACK,CAAD,EAAIC,OAAJ,EAAaC,iBAAb,KAAmC;AACpE,UAAMC,IAAI,GAAG,OAAOF,OAAP,GAAiB,OAA9B,CADoE,CAGpE;AACA;;AACA,WAAOE,IAAI,KAAKA,IAAT,IAAiBD,iBAAjB,GACHD,OADG,GAEHE,IAAI,GAAG,CAAP,GACE;AACAC,IAAAA,MAAM,CAACC,YAAP,CAAoBF,IAAI,GAAG,OAA3B,CAFF,GAGE;AACAC,IAAAA,MAAM,CAACC,YAAP,CAAqBF,IAAI,IAAI,EAAT,GAAe,MAAnC,EAA4CA,IAAI,GAAG,KAAR,GAAiB,MAA5D,CANN;AAOD,GAZM,CAAP;AAaD;;AAED,MAAMG,SAAS,GAAG5B,OAAO,CAAC6B,MAAR,CAAe,uBAAf,EAAwC,UAASC,OAAT,EAAkB;AAC1E,SAAOC,GAAG,IAAI;AACZ,UAAMC,kBAAkB,GACrBF,OAAO,IAAIA,OAAO,CAACE,kBAApB,IAA2CJ,SAAS,CAACI,kBADvD;AAEA,UAAMC,mBAAmB,GACtBH,OAAO,IAAIA,OAAO,CAACG,mBAApB,IAA4CL,SAAS,CAACK,mBADxD;AAEA,UAAMC,aAAa,GAAGJ,OAAO,IAAIA,OAAO,CAACI,aAAzC;AAEA,UAAMC,OAAO,GAAG/B,MAAM,CAACgC,MAAP,CAAc,IAAd,CAAhB;;AAEA,aAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,OAAhC,EAAyC;AACvC,YAAMC,UAAU,GAAGR,kBAAkB,CACnCO,OAAO,GAAGA,OAAH,GAAaD,IADe,EAEnCP,GAAG,CAACU,MAAJ,CAAWC,KAAX,CAAiBC,IAFkB,EAGnCZ,GAAG,CAACU,MAAJ,CAAWC,KAAX,CAAiBX,GAHkB,CAArC;AAKA,YAAMa,WAAW,GAAGX,mBAAmB,CACrCM,OAAO,GAAGA,OAAH,GAAaD,IADiB,EAErCE,UAFqC,EAGrCT,GAAG,CAACU,MAAJ,CAAWC,KAAX,CAAiBC,IAHoB,EAIrCZ,GAAG,CAACU,MAAJ,CAAWC,KAAX,CAAiBX,GAJoB,CAAvC;AAMA,YAAM;AAAEc,QAAAA,GAAF;AAAO/B,QAAAA;AAAP,UAAiB8B,WAAvB;AAEAT,MAAAA,OAAO,CAACU,GAAD,CAAP,GAAeV,OAAO,CAACU,GAAD,CAAP,IAAgB,EAA/B;;AAEA,UAAIV,OAAO,CAACU,GAAD,CAAP,CAAaC,OAAb,CAAqBhC,KAArB,IAA8B,CAAlC,EAAqC;AACnCqB,QAAAA,OAAO,CAACU,GAAD,CAAP,CAAaE,IAAb,CAAkBjC,KAAlB;AACD;;AAED,aAAO0B,UAAP;AACD;;AAED,aAASQ,YAAT,CAAsBtC,IAAtB,EAA4B;AAC1B,cAAQA,IAAI,CAACC,IAAb;AACE,aAAK,UAAL;AACED,UAAAA,IAAI,CAACF,KAAL,GAAaE,IAAI,CAACD,GAAL,CAASuC,YAAT,CAAb;AACA,iBAAOtC,IAAP;;AACF,aAAK,OAAL;AACE,iBAAOR,cAAc,CAAC+C,SAAf,CAAyB;AAC9BnC,YAAAA,KAAK,EAAEuB,gBAAgB,CACrB3B,IAAI,CAACI,KADgB,EAErBJ,IAAI,CAACwC,IAAL,IAAaxC,IAAI,CAACwC,IAAL,CAAUpC,KAAvB,GAA+BJ,IAAI,CAACwC,IAAL,CAAUpC,KAAzC,GAAiD,IAF5B;AADO,WAAzB,CAAP;;AAMF,aAAK,IAAL;AAAW;AACT,mBAAOZ,cAAc,CAACiD,EAAf,CAAkB;AACvBrC,cAAAA,KAAK,EAAEuB,gBAAgB,CACrB3B,IAAI,CAACI,KADgB,EAErBJ,IAAI,CAACwC,IAAL,IAAaxC,IAAI,CAACwC,IAAL,CAAUpC,KAAvB,GAA+BJ,IAAI,CAACwC,IAAL,CAAUpC,KAAzC,GAAiD,IAF5B;AADA,aAAlB,CAAP;AAMD;AAlBH;;AAqBA,YAAM,IAAID,KAAJ,CACH,GAAEH,IAAI,CAACC,IAAK,MAAKD,IAAK,qCADnB,CAAN;AAGD;;AAED,aAAS0C,YAAT,CAAsB1C,IAAtB,EAA4B;AAC1B,cAAQA,IAAI,CAACC,IAAb;AACE,aAAK,QAAL;AACE,cAAID,IAAI,CAACI,KAAL,KAAe,QAAnB,EAA6B;AAC3B,gBAAIJ,IAAI,CAACF,KAAL,CAAWI,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,oBAAM,IAAIC,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,kBAAMwC,QAAQ,GAAGL,YAAY,CAACtC,IAAI,CAACK,KAAN,EAAaL,IAAI,CAAC4C,MAAlB,CAA7B,CAL2B,CAM3B;AACA;;AACAD,YAAAA,QAAQ,CAACtC,KAAT,CAAeuC,MAAf,GAAwB5C,IAAI,CAAC4C,MAA7B;AAEA,kBAAMC,QAAQ,GAAG7C,IAAI,CAAC8C,IAAL,EAAjB;;AAEA,gBACED,QAAQ,IACRA,QAAQ,CAAC5C,IAAT,KAAkB,YADlB,IAEA4C,QAAQ,CAACzC,KAAT,KAAmB,GAFnB,IAGA,mBAAmB2C,IAAnB,CAAwBJ,QAAQ,CAACK,IAAT,CAAc5C,KAAtC,CAJF,EAKE;AACAuC,cAAAA,QAAQ,CAACK,IAAT,CAAcJ,MAAd,CAAqBK,KAArB,GAA6B,GAA7B;AACD;;AAEDjD,YAAAA,IAAI,CAACkD,WAAL,CAAiBP,QAAjB;AAEA;AACD;;AACH;;AACA,aAAK,MAAL;AACA,aAAK,UAAL;AAAiB;AACf3C,YAAAA,IAAI,CAACmD,IAAL,CAAUT,YAAV;AACA;AACD;;AACD,aAAK,IAAL;AACA,aAAK,OAAL;AACE,cAAIlB,aAAJ,EAAmB;AACjBC,YAAAA,OAAO,CAACzB,IAAI,CAACI,KAAN,CAAP,GAAsB,CAACJ,IAAI,CAACI,KAAN,CAAtB;AACD;;AACD;AAtCJ;;AAwCA,aAAOJ,IAAP;AACD,KArGW,CAuGZ;;;AACA,UAAMoD,aAAa,GAAG,EAAtB;AAEA/B,IAAAA,GAAG,CAACgC,SAAJ,CAAcC,IAAI,IAAI;AACpB,UAAI,kBAAkBP,IAAlB,CAAuBO,IAAI,CAACX,QAA5B,CAAJ,EAA2C;AACzCW,QAAAA,IAAI,CAACC,SAAL,CAAeC,IAAI,IAAI;AACrBJ,UAAAA,aAAa,CAACI,IAAI,CAACC,IAAN,CAAb,GAA2B,IAA3B;AACD,SAFD;AAGD;AACF,KAND,EA1GY,CAkHZ;;AACApC,IAAAA,GAAG,CAACgC,SAAJ,CAAcC,IAAI,IAAI;AACpB,UACEA,IAAI,CAACxD,KAAL,IACAwD,IAAI,CAACX,QAAL,CAAce,KAAd,CAAoB,CAApB,EAAuB,CAAvB,MAA8B,IAD9B,IAEAJ,IAAI,CAACX,QAAL,CAAce,KAAd,CAAoB,CAAC,CAArB,MAA4B,GAH9B,EAIE;AACA;AACA;AACD;;AAED,UAAIC,cAAc,GAAGnE,cAAc,GAAGoE,OAAjB,CAAyBN,IAAzB,CAArB;AAEAA,MAAAA,IAAI,CAACX,QAAL,GAAgBD,YAAY,CAACiB,cAAc,CAACE,KAAf,EAAD,CAAZ,CAAqCC,QAArC,EAAhB;AAEAR,MAAAA,IAAI,CAACC,SAAL,CAAe,uBAAf,EAAwCC,IAAI,IAAI;AAC9C,cAAMO,UAAU,GAAGnE,8BAA8B,CAAC+D,cAAD,CAAjD;AACA,cAAMK,OAAO,GAAGR,IAAI,CAACpD,KAAL,CAAW6D,KAAX,CAAiB,KAAjB,CAAhB;AAEAD,QAAAA,OAAO,CAACE,OAAR,CAAgB3B,SAAS,IAAI;AAC3B,gBAAM4B,MAAM,GAAG,uBAAuBC,IAAvB,CAA4B7B,SAA5B,CAAf;;AAEA,cAAI4B,MAAJ,EAAY;AACVJ,YAAAA,UAAU,CAACG,OAAX,CAAmBG,YAAY,IAAI;AACjC5C,cAAAA,OAAO,CAAC4C,YAAD,CAAP,CAAsBhC,IAAtB,CAA2B8B,MAAM,CAAC,CAAD,CAAjC;AACD,aAFD;AAGD,WAJD,MAIO,IAAI1E,cAAc,CAAC6E,IAAf,CAAoBlB,aAApB,EAAmCb,SAAnC,CAAJ,EAAmD;AACxDwB,YAAAA,UAAU,CAACG,OAAX,CAAmBG,YAAY,IAAI;AACjC5C,cAAAA,OAAO,CAAC4C,YAAD,CAAP,CAAsBhC,IAAtB,CAA2BE,SAA3B;AACD,aAFD;AAGD,WAJM,MAIA,IAAI9C,cAAc,CAAC6E,IAAf,CAAoB7C,OAApB,EAA6Bc,SAA7B,CAAJ,EAA6C;AAClDwB,YAAAA,UAAU,CAACG,OAAX,CAAmBG,YAAY,IAAI;AACjC5C,cAAAA,OAAO,CAACc,SAAD,CAAP,CAAmB2B,OAAnB,CAA2BK,IAAI,IAAI;AACjC9C,gBAAAA,OAAO,CAAC4C,YAAD,CAAP,CAAsBhC,IAAtB,CAA2BkC,IAA3B;AACD,eAFD;AAGD,aAJD;AAKD,WANM,MAMA;AACL,kBAAMf,IAAI,CAACgB,KAAL,CACH,0BAAyBjC,SAAU,QAAOiB,IAAI,CAACC,IAAK,YADjD,CAAN;AAGD;AACF,SAtBD;AAwBAD,QAAAA,IAAI,CAACiB,MAAL;AACD,OA7BD;AA+BAnB,MAAAA,IAAI,CAACC,SAAL,CAAeC,IAAI,IAAI;AACrB,YAAIkB,MAAM,GAAGlB,IAAI,CAACpD,KAAL,CAAW6D,KAAX,CAAiB,qBAAjB,CAAb;AAEAS,QAAAA,MAAM,GAAGA,MAAM,CAAC3E,GAAP,CAAW,CAAC4E,KAAD,EAAQC,GAAR,KAAgB;AAClC,cAAIA,GAAG,KAAK,CAAR,IAAaF,MAAM,CAACE,GAAG,GAAG,CAAP,CAAN,KAAoB,GAArC,EAA0C;AACxC,kBAAMC,UAAU,GAAG,2BAA2BT,IAA3B,CAAgCO,KAAhC,CAAnB;;AAEA,gBAAIE,UAAJ,EAAgB;AACd,qBACEA,UAAU,CAAC,CAAD,CAAV,GACAlD,gBAAgB,CAACkD,UAAU,CAAC,CAAD,CAAX,CADhB,GAEAF,KAAK,CAACG,MAAN,CAAaD,UAAU,CAAC,CAAD,CAAV,CAAc3E,MAA3B,CAHF;AAKD,aAND,MAMO;AACL,qBAAOyE,KAAP;AACD;AACF,WAZD,MAYO;AACL,mBAAOA,KAAP;AACD;AACF,SAhBQ,CAAT;AAkBAnB,QAAAA,IAAI,CAACpD,KAAL,GAAasE,MAAM,CAACK,IAAP,CAAY,EAAZ,CAAb;AACD,OAtBD;AAuBD,KApED,EAnHY,CAyLZ;;AACA1D,IAAAA,GAAG,CAAC2D,WAAJ,CAAgBC,MAAM,IAAI;AACxB,UAAI,cAAclC,IAAd,CAAmBkC,MAAM,CAACrD,IAA1B,CAAJ,EAAqC;AACnC,cAAMiD,UAAU,GAAG,6BAA6BT,IAA7B,CAAkCa,MAAM,CAACC,MAAzC,CAAnB;;AAEA,YAAIL,UAAJ,EAAgB;AACdI,UAAAA,MAAM,CAACC,MAAP,GAAgBvD,gBAAgB,CAACkD,UAAU,CAAC,CAAD,CAAX,CAAhC;AACD;AACF;AACF,KARD,EA1LY,CAoMZ;;AACA,UAAMM,aAAa,GAAGzF,MAAM,CAAC0F,IAAP,CAAY3D,OAAZ,CAAtB;;AAEA,QAAI0D,aAAa,CAACjF,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,YAAMmF,UAAU,GAAG/F,OAAO,CAACgE,IAAR,CAAa;AAAEX,QAAAA,QAAQ,EAAE;AAAZ,OAAb,CAAnB;AAEAwC,MAAAA,aAAa,CAACjB,OAAd,CAAsBG,YAAY,IAChCgB,UAAU,CAACC,MAAX,CAAkB;AAChB7B,QAAAA,IAAI,EAAEY,YADU;AAEhBjE,QAAAA,KAAK,EAAEqB,OAAO,CAAC4C,YAAD,CAAP,CAAsBU,IAAtB,CAA2B,GAA3B,CAFS;AAGhBvC,QAAAA,IAAI,EAAE;AAAE+C,UAAAA,MAAM,EAAE;AAAV;AAHU,OAAlB,CADF;AAQAlE,MAAAA,GAAG,CAACiE,MAAJ,CAAWD,UAAX;AACD;AACF,GApND;AAqND,CAtNiB,CAAlB;;AAwNAnE,SAAS,CAACI,kBAAV,GAA+B,UAASM,IAAT,EAAe4D,IAAf,EAAqB;AAClD,QAAMC,aAAa,GAAGD,IAAI,CACvB7E,OADmB,CACX,eADW,EACM,EADN,EAEnBA,OAFmB,CAEX,SAFW,EAEA,GAFA,EAGnBA,OAHmB,CAGX,QAHW,EAGD,EAHC,CAAtB;AAKA,SAAQ,IAAG8E,aAAc,KAAI7D,IAAK,EAA3B,CAA6B8D,IAA7B,EAAP;AACD,CAPD;;AASAxE,SAAS,CAACK,mBAAV,GAAgC,UAASK,IAAT,EAAeE,UAAf,EAA2B;AACzD,SAAO;AACLK,IAAAA,GAAG,EAAE1B,QAAQ,CAACmB,IAAD,CADR;AAELxB,IAAAA,KAAK,EAAEK,QAAQ,CAACqB,UAAD;AAFV,GAAP;AAID,CALD;;AAOA6D,MAAM,CAAClE,OAAP,GAAiBP,SAAjB","sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst selectorParser = require('postcss-selector-parser');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== 'pseudo' ||\n      node.value !== ':local' ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== 'selector' || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== 'class') {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\nconst unescapeRegExp = new RegExp(\n  '\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)',\n  'ig'\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = '0x' + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n        ? // BMP codepoint\n          String.fromCharCode(high + 0x10000)\n        : // Supplemental Plane codepoint (surrogate pair)\n          String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst processor = postcss.plugin('postcss-modules-scope', function(options) {\n  return css => {\n    const generateScopedName =\n      (options && options.generateScopedName) || processor.generateScopedName;\n    const generateExportEntry =\n      (options && options.generateExportEntry) || processor.generateExportEntry;\n    const exportGlobals = options && options.exportGlobals;\n\n    const exports = Object.create(null);\n\n    function exportScopedName(name, rawName) {\n      const scopedName = generateScopedName(\n        rawName ? rawName : name,\n        css.source.input.from,\n        css.source.input.css\n      );\n      const exportEntry = generateExportEntry(\n        rawName ? rawName : name,\n        scopedName,\n        css.source.input.from,\n        css.source.input.css\n      );\n      const { key, value } = exportEntry;\n\n      exports[key] = exports[key] || [];\n\n      if (exports[key].indexOf(value) < 0) {\n        exports[key].push(value);\n      }\n\n      return scopedName;\n    }\n\n    function localizeNode(node) {\n      switch (node.type) {\n        case 'selector':\n          node.nodes = node.map(localizeNode);\n          return node;\n        case 'class':\n          return selectorParser.className({\n            value: exportScopedName(\n              node.value,\n              node.raws && node.raws.value ? node.raws.value : null\n            ),\n          });\n        case 'id': {\n          return selectorParser.id({\n            value: exportScopedName(\n              node.value,\n              node.raws && node.raws.value ? node.raws.value : null\n            ),\n          });\n        }\n      }\n\n      throw new Error(\n        `${node.type} (\"${node}\") is not allowed in a :local block`\n      );\n    }\n\n    function traverseNode(node) {\n      switch (node.type) {\n        case 'pseudo':\n          if (node.value === ':local') {\n            if (node.nodes.length !== 1) {\n              throw new Error('Unexpected comma (\",\") in :local block');\n            }\n\n            const selector = localizeNode(node.first, node.spaces);\n            // move the spaces that were around the psuedo selector to the first\n            // non-container node\n            selector.first.spaces = node.spaces;\n\n            const nextNode = node.next();\n\n            if (\n              nextNode &&\n              nextNode.type === 'combinator' &&\n              nextNode.value === ' ' &&\n              /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n            ) {\n              selector.last.spaces.after = ' ';\n            }\n\n            node.replaceWith(selector);\n\n            return;\n          }\n        /* falls through */\n        case 'root':\n        case 'selector': {\n          node.each(traverseNode);\n          break;\n        }\n        case 'id':\n        case 'class': \n          if (exportGlobals) {\n            exports[node.value] = [node.value];\n          }\n          break;\n      }\n      return node;\n    }\n\n    // Find any :import and remember imported names\n    const importedNames = {};\n\n    css.walkRules(rule => {\n      if (/^:import\\(.+\\)$/.test(rule.selector)) {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      }\n    });\n\n    // Find any :local classes\n    css.walkRules(rule => {\n      if (\n        rule.nodes &&\n        rule.selector.slice(0, 2) === '--' &&\n        rule.selector.slice(-1) === ':'\n      ) {\n        // ignore custom property set\n        return;\n      }\n\n      let parsedSelector = selectorParser().astSync(rule);\n\n      rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n      rule.walkDecls(/composes|compose-with/, decl => {\n        const localNames = getSingleLocalNamesForComposes(parsedSelector);\n        const classes = decl.value.split(/\\s+/);\n\n        classes.forEach(className => {\n          const global = /^global\\(([^\\)]+)\\)$/.exec(className);\n\n          if (global) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(global[1]);\n            });\n          } else if (hasOwnProperty.call(importedNames, className)) {\n            localNames.forEach(exportedName => {\n              exports[exportedName].push(className);\n            });\n          } else if (hasOwnProperty.call(exports, className)) {\n            localNames.forEach(exportedName => {\n              exports[className].forEach(item => {\n                exports[exportedName].push(item);\n              });\n            });\n          } else {\n            throw decl.error(\n              `referenced class name \"${className}\" in ${decl.prop} not found`\n            );\n          }\n        });\n\n        decl.remove();\n      });\n\n      rule.walkDecls(decl => {\n        let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n        tokens = tokens.map((token, idx) => {\n          if (idx === 0 || tokens[idx - 1] === ',') {\n            const localMatch = /^(\\s*):local\\s*\\((.+?)\\)/.exec(token);\n\n            if (localMatch) {\n              return (\n                localMatch[1] +\n                exportScopedName(localMatch[2]) +\n                token.substr(localMatch[0].length)\n              );\n            } else {\n              return token;\n            }\n          } else {\n            return token;\n          }\n        });\n\n        decl.value = tokens.join('');\n      });\n    });\n\n    // Find any :local keyframes\n    css.walkAtRules(atrule => {\n      if (/keyframes$/i.test(atrule.name)) {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atrule.params);\n\n        if (localMatch) {\n          atrule.params = exportScopedName(localMatch[1]);\n        }\n      }\n    });\n\n    // If we found any :locals, insert an :export rule\n    const exportedNames = Object.keys(exports);\n\n    if (exportedNames.length > 0) {\n      const exportRule = postcss.rule({ selector: ':export' });\n\n      exportedNames.forEach(exportedName =>\n        exportRule.append({\n          prop: exportedName,\n          value: exports[exportedName].join(' '),\n          raws: { before: '\\n  ' },\n        })\n      );\n\n      css.append(exportRule);\n    }\n  };\n});\n\nprocessor.generateScopedName = function(name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^\\.\\/\\\\]+$/, '')\n    .replace(/[\\W_]+/g, '_')\n    .replace(/^_|_$/g, '');\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nprocessor.generateExportEntry = function(name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nmodule.exports = processor;\n"]},"metadata":{},"sourceType":"script"}