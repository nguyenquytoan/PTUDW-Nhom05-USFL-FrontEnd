{"ast":null,"code":"'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\n\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    const o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\n\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      map[stringKey] = toJSON(this.value, stringKey, ctx);\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    }\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\n\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\n\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else {\n          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n    res += `\\n${indent}${text.slice(fold + 1, end)}`;\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, limit) {\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\n\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\n\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\n\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n} // on error, will return { str: string, errors: Error[] }\n\n\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/yaml/dist/resolveSeq-4a68b39b.js"],"names":["PlainValue","require","addCommentBefore","str","indent","comment","cc","replace","addComment","indexOf","Node","toJSON","value","arg","ctx","Array","isArray","map","v","i","String","anchor","anchors","get","onCreate","res","keep","Number","Scalar","constructor","toString","collectionFromPath","schema","path","length","k","o","isInteger","createNode","isEmptyPath","Symbol","iterator","next","done","Collection","_defineProperty","addIn","add","key","rest","node","undefined","set","Error","deleteIn","delete","getIn","keepScalar","hasAllNullValues","items","every","type","n","commentBefore","tag","hasIn","has","setIn","blockItem","flowChars","isMap","itemIndent","onComment","onChompKeep","indentStep","stringify","inFlow","Type","FLOW_MAP","FLOW_SEQ","allNullValues","Object","assign","chompKeep","hasItemWithNewLine","nodes","reduce","item","spaceBefore","push","match","forEach","line","includes","start","end","strings","sum","maxFlowStringSingleLineLength","s","join","shift","asItemIndex","idx","YAMLSeq","del","splice","it","_","seq","JSON","stringifyKey","jsKey","doc","inStringifyKey","Pair","PAIR","cb","msg","addToJSMap","Map","Set","stringKey","pair","mapAsMap","indentSize","indentSeq","simpleKeys","options","keyComment","explicitKey","BLOCK_FOLDED","BLOCK_LITERAL","implicitKey","vcb","valueComment","cs","indentAtStart","getName","substr","valueStr","ws","flow","MERGE_PAIR","getAliasCount","Alias","source","count","aliasCount","c","kc","vc","Math","max","range","keys","find","a","newName","ALIAS","t","maxAliasCount","cstNode","YAMLReferenceError","ReferenceError","findPair","YAMLMap","overwrite","prev","sortEntries","sortMapEntries","findIndex","MERGE_KEY","Merge","srcMap","prototype","hasOwnProperty","call","binaryOptions","defaultType","lineWidth","boolOptions","trueStr","falseStr","intOptions","asBigInt","nullOptions","nullStr","strOptions","PLAIN","doubleQuoted","jsonEncoding","minMultiLineLength","fold","minContentWidth","resolveScalar","tags","scalarFallback","format","test","resolve","apply","FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","consumeMoreIndentedLines","text","ch","foldFlowLines","mode","onFold","onOverflow","endStep","folds","escapedFolds","split","overflow","slice","getFoldOptions","containsDocumentMarker","lineLengthOverLimit","limit","strLen","doubleQuotedString","json","code","singleQuotedString","blockString","forceBlockIndent","literal","header","wsStart","wsEnd","m","body","plainString","actualString","resolved","stringifyString","_stringify","_type","QUOTE_DOUBLE","QUOTE_SINGLE","stringifyNumber","minFractionDigits","isFinite","isNaN","d","checkFlowCollectionEnd","errors","cst","char","name","YAMLSemanticError","lastItem","COMMENT","err","offset","checkFlowCommentSpace","context","src","getLongKeyError","sk","resolveComments","collection","comments","afterKey","before","resolveString","strValue","error","resolveTagHandle","handle","suffix","prefix","tagPrefixes","p","dtp","getDefaults","version","warnings","YAMLWarning","vocab","decodeURIComponent","resolveTagName","nonSpecific","verbatim","defaultTags","STR","MAP","SEQ","resolveByTagName","tagName","matchWithTest","getFallbackTagName","resolveTag","fallback","refError","message","stack","isCollectionItem","MAP_KEY","MAP_VALUE","SEQ_ITEM","resolveNodeProps","after","hasAnchor","hasTag","props","parent","concat","Char","commentHasRequiredWhitespace","valueRange","ANCHOR","TAG","resolveNodeValue","rawValue","getNode","_cstAliases","YAMLSyntaxError","resolveNode","keepCstNodes","keepNodeTypes","ca","resolveMap","resolveFlowMapItems","resolveBlockMapItems","hasCollectionKey","iKey","merge","sources","some","j","jKey","warn","valueHasPairComment","lineStart","resolvePairComment","getPropValue","found","startsWith","keyStart","BLANK_LINE","atLineStart","valueNode","pos","origStart","origPos","origEnd","nextItem","valueRangeContainsNewline","resolveSeq","resolveFlowSeqItems","resolveBlockSeqItems","hasProps","prevItem","pop","keyEnd","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    const o = Number.isInteger(k) && k >= 0 ? [] : {};\n    o[k] = v;\n    v = o;\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: {},\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      map[stringKey] = toJSON(this.value, stringKey, ctx);\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL);\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    }\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else {\n          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // i - 2 accounts for not-dropped last char + newline-escaping \\\n\n\n          folds.push(i - 2);\n          escapedFolds[i - 2] = true;\n          end = i - 2 + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n    res += `\\n${indent}${text.slice(fold + 1, end)}`;\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, limit) {\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n"]},"metadata":{},"sourceType":"script"}