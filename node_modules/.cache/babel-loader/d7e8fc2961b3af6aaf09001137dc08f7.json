{"ast":null,"code":"/**\n * @fileoverview `FileEnumerator` class.\n *\n * `FileEnumerator` class has two responsibilities:\n *\n * 1. Find target files by processing glob patterns.\n * 2. Tie each target file and appropriate configuration.\n *\n * It provies a method:\n *\n * - `iterateFiles(patterns)`\n *     Iterate files which are matched by given patterns together with the\n *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.\n *     While iterating files, it loads the configuration file of each directory\n *     before iterate files on the directory, so we can use the configuration\n *     files to determine target files.\n *\n * @example\n * const enumerator = new FileEnumerator();\n * const linter = new Linter();\n *\n * for (const { config, filePath } of enumerator.iterateFiles([\"*.js\"])) {\n *     const code = fs.readFileSync(filePath, \"utf8\");\n *     const messages = linter.verify(code, config, filePath);\n *\n *     console.log(messages);\n * }\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst getGlobParent = require(\"glob-parent\");\n\nconst isGlob = require(\"is-glob\");\n\nconst {\n  escapeRegExp\n} = require(\"lodash\");\n\nconst {\n  Minimatch\n} = require(\"minimatch\");\n\nconst {\n  IgnorePattern\n} = require(\"./config-array\");\n\nconst {\n  CascadingConfigArrayFactory\n} = require(\"./cascading-config-array-factory\");\n\nconst debug = require(\"debug\")(\"eslint:file-enumerator\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst minimatchOpts = {\n  dot: true,\n  matchBase: true\n};\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\nconst NONE = 0;\nconst IGNORED_SILENTLY = 1;\nconst IGNORED = 2; // For VSCode intellisense\n\n/** @typedef {ReturnType<CascadingConfigArrayFactory[\"getConfigArrayForFile\"]>} ConfigArray */\n\n/**\n * @typedef {Object} FileEnumeratorOptions\n * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string[]} [extensions] The extensions to match files for directory patterns.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] The flag to check ignored files.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n */\n\n/**\n * @typedef {Object} FileAndConfig\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEntry\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.\n * - `NONE` means the file is a target file.\n * - `IGNORED_SILENTLY` means the file should be ignored silently.\n * - `IGNORED` means the file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEnumeratorInternalSlots\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {RegExp} extensionRegExp The RegExp to test if a string ends with specific file extensions.\n * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} ignoreFlag The flag to check ignored files.\n * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.\n */\n\n/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */\n\nconst internalSlotsMap = new WeakMap();\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\n\nfunction isGlobPattern(pattern) {\n  return isGlob(path.sep === \"\\\\\" ? pattern.replace(/\\\\/gu, \"/\") : pattern);\n}\n/**\n * Get stats of a given path.\n * @param {string} filePath The path to target file.\n * @returns {fs.Stats|null} The stats.\n * @private\n */\n\n\nfunction statSafeSync(filePath) {\n  try {\n    return fs.statSync(filePath);\n  } catch (error) {\n    /* istanbul ignore next */\n    if (error.code !== \"ENOENT\") {\n      throw error;\n    }\n\n    return null;\n  }\n}\n/**\n * Get filenames in a given path to a directory.\n * @param {string} directoryPath The path to target directory.\n * @returns {string[]} The filenames.\n * @private\n */\n\n\nfunction readdirSafeSync(directoryPath) {\n  try {\n    return fs.readdirSync(directoryPath);\n  } catch (error) {\n    /* istanbul ignore next */\n    if (error.code !== \"ENOENT\") {\n      throw error;\n    }\n\n    return [];\n  }\n}\n/**\n * The error type when no files match a glob.\n */\n\n\nclass NoFilesFoundError extends Error {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.\n   */\n  constructor(pattern, globDisabled) {\n    super(`No files matching '${pattern}' were found${globDisabled ? \" (glob was disabled)\" : \"\"}.`);\n    this.messageTemplate = \"file-not-found\";\n    this.messageData = {\n      pattern,\n      globDisabled\n    };\n  }\n\n}\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\n\n\nclass AllFilesIgnoredError extends Error {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {string} pattern The glob pattern which was not found.\n   */\n  constructor(pattern) {\n    super(`All files matched by '${pattern}' are ignored.`);\n    this.messageTemplate = \"all-files-ignored\";\n    this.messageData = {\n      pattern\n    };\n  }\n\n}\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\n\n\nclass FileEnumerator {\n  /**\n   * Initialize this enumerator.\n   * @param {FileEnumeratorOptions} options The options.\n   */\n  constructor({\n    cwd = process.cwd(),\n    configArrayFactory = new CascadingConfigArrayFactory({\n      cwd\n    }),\n    extensions = [\".js\"],\n    globInputPaths = true,\n    errorOnUnmatchedPattern = true,\n    ignore = true\n  } = {}) {\n    internalSlotsMap.set(this, {\n      configArrayFactory,\n      cwd,\n      defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),\n      extensionRegExp: new RegExp(`.\\\\.(?:${extensions.map(ext => escapeRegExp(ext.startsWith(\".\") ? ext.slice(1) : ext)).join(\"|\")})$`, \"u\"),\n      globInputPaths,\n      errorOnUnmatchedPattern,\n      ignoreFlag: ignore\n    });\n  }\n  /**\n   * The `RegExp` object that tests if a file path has the allowed file extensions.\n   * @type {RegExp}\n   */\n\n\n  get extensionRegExp() {\n    return internalSlotsMap.get(this).extensionRegExp;\n  }\n  /**\n   * Iterate files which are matched by given glob patterns.\n   * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.\n   * @returns {IterableIterator<FileAndConfig>} The found files.\n   */\n\n\n  *iterateFiles(patternOrPatterns) {\n    const {\n      globInputPaths,\n      errorOnUnmatchedPattern\n    } = internalSlotsMap.get(this);\n    const patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];\n    debug(\"Start to iterate files: %o\", patterns); // The set of paths to remove duplicate.\n\n    const set = new Set();\n\n    for (const pattern of patterns) {\n      let foundRegardlessOfIgnored = false;\n      let found = false; // Skip empty string.\n\n      if (!pattern) {\n        continue;\n      } // Iterate files of this pttern.\n\n\n      for (const {\n        config,\n        filePath,\n        flag\n      } of this._iterateFiles(pattern)) {\n        foundRegardlessOfIgnored = true;\n\n        if (flag === IGNORED_SILENTLY) {\n          continue;\n        }\n\n        found = true; // Remove duplicate paths while yielding paths.\n\n        if (!set.has(filePath)) {\n          set.add(filePath);\n          yield {\n            config,\n            filePath,\n            ignored: flag === IGNORED\n          };\n        }\n      } // Raise an error if any files were not found.\n\n\n      if (errorOnUnmatchedPattern) {\n        if (!foundRegardlessOfIgnored) {\n          throw new NoFilesFoundError(pattern, !globInputPaths && isGlob(pattern));\n        }\n\n        if (!found) {\n          throw new AllFilesIgnoredError(pattern);\n        }\n      }\n    }\n\n    debug(`Complete iterating files: ${JSON.stringify(patterns)}`);\n  }\n  /**\n   * Iterate files which are matched by a given glob pattern.\n   * @param {string} pattern The glob pattern to iterate files.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   */\n\n\n  _iterateFiles(pattern) {\n    const {\n      cwd,\n      globInputPaths\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, pattern);\n    const isDot = dotfilesPattern.test(pattern);\n    const stat = statSafeSync(absolutePath);\n\n    if (stat && stat.isDirectory()) {\n      return this._iterateFilesWithDirectory(absolutePath, isDot);\n    }\n\n    if (stat && stat.isFile()) {\n      return this._iterateFilesWithFile(absolutePath);\n    }\n\n    if (globInputPaths && isGlobPattern(pattern)) {\n      return this._iterateFilesWithGlob(absolutePath, isDot);\n    }\n\n    return [];\n  }\n  /**\n   * Iterate a file which is matched by a given path.\n   * @param {string} filePath The path to the target file.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n\n\n  _iterateFilesWithFile(filePath) {\n    debug(`File: ${filePath}`);\n    const {\n      configArrayFactory\n    } = internalSlotsMap.get(this);\n    const config = configArrayFactory.getConfigArrayForFile(filePath);\n\n    const ignored = this._isIgnoredFile(filePath, {\n      config,\n      direct: true\n    });\n\n    const flag = ignored ? IGNORED : NONE;\n    return [{\n      config,\n      filePath,\n      flag\n    }];\n  }\n  /**\n   * Iterate files in a given path.\n   * @param {string} directoryPath The path to the target directory.\n   * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n\n\n  _iterateFilesWithDirectory(directoryPath, dotfiles) {\n    debug(`Directory: ${directoryPath}`);\n    return this._iterateFilesRecursive(directoryPath, {\n      dotfiles,\n      recursive: true,\n      selector: null\n    });\n  }\n  /**\n   * Iterate files which are matched by a given glob pattern.\n   * @param {string} pattern The glob pattern to iterate files.\n   * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n\n\n  _iterateFilesWithGlob(pattern, dotfiles) {\n    debug(`Glob: ${pattern}`);\n    const directoryPath = path.resolve(getGlobParent(pattern));\n    const globPart = pattern.slice(directoryPath.length + 1);\n    /*\n     * recursive if there are `**` or path separators in the glob part.\n     * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.\n     */\n\n    const recursive = /\\*\\*|\\/|\\\\/u.test(globPart);\n    const selector = new Minimatch(pattern, minimatchOpts);\n    debug(`recursive? ${recursive}`);\n    return this._iterateFilesRecursive(directoryPath, {\n      dotfiles,\n      recursive,\n      selector\n    });\n  }\n  /**\n   * Iterate files in a given path.\n   * @param {string} directoryPath The path to the target directory.\n   * @param {Object} options The options to iterate files.\n   * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.\n   * @param {boolean} [options.recursive] If `true` then it dives into sub directories.\n   * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.\n   * @returns {IterableIterator<FileEntry>} The found files.\n   * @private\n   */\n\n\n  *_iterateFilesRecursive(directoryPath, options) {\n    debug(`Enter the directory: ${directoryPath}`);\n    const {\n      configArrayFactory,\n      extensionRegExp\n    } = internalSlotsMap.get(this);\n    /** @type {ConfigArray|null} */\n\n    let config = null; // Enumerate the files of this directory.\n\n    for (const filename of readdirSafeSync(directoryPath)) {\n      const filePath = path.join(directoryPath, filename);\n      const stat = statSafeSync(filePath); // TODO: Use `withFileTypes` in the future.\n      // Check if the file is matched.\n\n      if (stat && stat.isFile()) {\n        if (!config) {\n          config = configArrayFactory.getConfigArrayForFile(filePath,\n          /*\n           * We must ignore `ConfigurationNotFoundError` at this\n           * point because we don't know if target files exist in\n           * this directory.\n           */\n          {\n            ignoreNotFoundError: true\n          });\n        }\n\n        const ignored = this._isIgnoredFile(filePath, { ...options,\n          config\n        });\n\n        const flag = ignored ? IGNORED_SILENTLY : NONE;\n        const matched = options.selector // Started with a glob pattern; choose by the pattern.\n        ? options.selector.match(filePath) // Started with a directory path; choose by file extensions.\n        : extensionRegExp.test(filePath);\n\n        if (matched) {\n          debug(`Yield: ${filename}${ignored ? \" but ignored\" : \"\"}`);\n          yield {\n            config: configArrayFactory.getConfigArrayForFile(filePath),\n            filePath,\n            flag\n          };\n        } else {\n          debug(`Didn't match: ${filename}`);\n        } // Dive into the sub directory.\n\n      } else if (options.recursive && stat && stat.isDirectory()) {\n        if (!config) {\n          config = configArrayFactory.getConfigArrayForFile(filePath, {\n            ignoreNotFoundError: true\n          });\n        }\n\n        const ignored = this._isIgnoredFile(filePath + path.sep, { ...options,\n          config\n        });\n\n        if (!ignored) {\n          yield* this._iterateFilesRecursive(filePath, options);\n        }\n      }\n    }\n\n    debug(`Leave the directory: ${directoryPath}`);\n  }\n  /**\n   * Check if a given file should be ignored.\n   * @param {string} filePath The path to a file to check.\n   * @param {Object} options Options\n   * @param {ConfigArray} [options.config] The config for this file.\n   * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.\n   * @param {boolean} [options.direct] If `true` then this is a direct specified file.\n   * @returns {boolean} `true` if the file should be ignored.\n   * @private\n   */\n\n\n  _isIgnoredFile(filePath, {\n    config: providedConfig,\n    dotfiles = false,\n    direct = false\n  }) {\n    const {\n      configArrayFactory,\n      defaultIgnores,\n      ignoreFlag\n    } = internalSlotsMap.get(this);\n\n    if (ignoreFlag) {\n      const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {\n        ignoreNotFoundError: true\n      });\n      const ignores = config.extractConfig(filePath).ignores || defaultIgnores;\n      return ignores(filePath, dotfiles);\n    }\n\n    return !direct && defaultIgnores(filePath, dotfiles);\n  }\n\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  FileEnumerator\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/cli-engine/file-enumerator.js"],"names":["fs","require","path","getGlobParent","isGlob","escapeRegExp","Minimatch","IgnorePattern","CascadingConfigArrayFactory","debug","minimatchOpts","dot","matchBase","dotfilesPattern","NONE","IGNORED_SILENTLY","IGNORED","internalSlotsMap","WeakMap","isGlobPattern","pattern","sep","replace","statSafeSync","filePath","statSync","error","code","readdirSafeSync","directoryPath","readdirSync","NoFilesFoundError","Error","constructor","globDisabled","messageTemplate","messageData","AllFilesIgnoredError","FileEnumerator","cwd","process","configArrayFactory","extensions","globInputPaths","errorOnUnmatchedPattern","ignore","set","defaultIgnores","createDefaultIgnore","extensionRegExp","RegExp","map","ext","startsWith","slice","join","ignoreFlag","get","iterateFiles","patternOrPatterns","patterns","Array","isArray","Set","foundRegardlessOfIgnored","found","config","flag","_iterateFiles","has","add","ignored","JSON","stringify","absolutePath","resolve","isDot","test","stat","isDirectory","_iterateFilesWithDirectory","isFile","_iterateFilesWithFile","_iterateFilesWithGlob","getConfigArrayForFile","_isIgnoredFile","direct","dotfiles","_iterateFilesRecursive","recursive","selector","globPart","length","options","filename","ignoreNotFoundError","matched","match","providedConfig","ignores","extractConfig","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview `FileEnumerator` class.\n *\n * `FileEnumerator` class has two responsibilities:\n *\n * 1. Find target files by processing glob patterns.\n * 2. Tie each target file and appropriate configuration.\n *\n * It provies a method:\n *\n * - `iterateFiles(patterns)`\n *     Iterate files which are matched by given patterns together with the\n *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.\n *     While iterating files, it loads the configuration file of each directory\n *     before iterate files on the directory, so we can use the configuration\n *     files to determine target files.\n *\n * @example\n * const enumerator = new FileEnumerator();\n * const linter = new Linter();\n *\n * for (const { config, filePath } of enumerator.iterateFiles([\"*.js\"])) {\n *     const code = fs.readFileSync(filePath, \"utf8\");\n *     const messages = linter.verify(code, config, filePath);\n *\n *     console.log(messages);\n * }\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst getGlobParent = require(\"glob-parent\");\nconst isGlob = require(\"is-glob\");\nconst { escapeRegExp } = require(\"lodash\");\nconst { Minimatch } = require(\"minimatch\");\nconst { IgnorePattern } = require(\"./config-array\");\nconst { CascadingConfigArrayFactory } = require(\"./cascading-config-array-factory\");\nconst debug = require(\"debug\")(\"eslint:file-enumerator\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst minimatchOpts = { dot: true, matchBase: true };\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\nconst NONE = 0;\nconst IGNORED_SILENTLY = 1;\nconst IGNORED = 2;\n\n// For VSCode intellisense\n/** @typedef {ReturnType<CascadingConfigArrayFactory[\"getConfigArrayForFile\"]>} ConfigArray */\n\n/**\n * @typedef {Object} FileEnumeratorOptions\n * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string[]} [extensions] The extensions to match files for directory patterns.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] The flag to check ignored files.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n */\n\n/**\n * @typedef {Object} FileAndConfig\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEntry\n * @property {string} filePath The path to a target file.\n * @property {ConfigArray} config The config entries of that file.\n * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.\n * - `NONE` means the file is a target file.\n * - `IGNORED_SILENTLY` means the file should be ignored silently.\n * - `IGNORED` means the file should be ignored and warned because it was directly specified.\n */\n\n/**\n * @typedef {Object} FileEnumeratorInternalSlots\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {RegExp} extensionRegExp The RegExp to test if a string ends with specific file extensions.\n * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} ignoreFlag The flag to check ignored files.\n * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.\n */\n\n/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n    return isGlob(path.sep === \"\\\\\" ? pattern.replace(/\\\\/gu, \"/\") : pattern);\n}\n\n/**\n * Get stats of a given path.\n * @param {string} filePath The path to target file.\n * @returns {fs.Stats|null} The stats.\n * @private\n */\nfunction statSafeSync(filePath) {\n    try {\n        return fs.statSync(filePath);\n    } catch (error) {\n        /* istanbul ignore next */\n        if (error.code !== \"ENOENT\") {\n            throw error;\n        }\n        return null;\n    }\n}\n\n/**\n * Get filenames in a given path to a directory.\n * @param {string} directoryPath The path to target directory.\n * @returns {string[]} The filenames.\n * @private\n */\nfunction readdirSafeSync(directoryPath) {\n    try {\n        return fs.readdirSync(directoryPath);\n    } catch (error) {\n        /* istanbul ignore next */\n        if (error.code !== \"ENOENT\") {\n            throw error;\n        }\n        return [];\n    }\n}\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.\n     */\n    constructor(pattern, globDisabled) {\n        super(`No files matching '${pattern}' were found${globDisabled ? \" (glob was disabled)\" : \"\"}.`);\n        this.messageTemplate = \"file-not-found\";\n        this.messageData = { pattern, globDisabled };\n    }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`All files matched by '${pattern}' are ignored.`);\n        this.messageTemplate = \"all-files-ignored\";\n        this.messageData = { pattern };\n    }\n}\n\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\nclass FileEnumerator {\n\n    /**\n     * Initialize this enumerator.\n     * @param {FileEnumeratorOptions} options The options.\n     */\n    constructor({\n        cwd = process.cwd(),\n        configArrayFactory = new CascadingConfigArrayFactory({ cwd }),\n        extensions = [\".js\"],\n        globInputPaths = true,\n        errorOnUnmatchedPattern = true,\n        ignore = true\n    } = {}) {\n        internalSlotsMap.set(this, {\n            configArrayFactory,\n            cwd,\n            defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),\n            extensionRegExp: new RegExp(\n                `.\\\\.(?:${extensions\n                    .map(ext => escapeRegExp(\n                        ext.startsWith(\".\")\n                            ? ext.slice(1)\n                            : ext\n                    ))\n                    .join(\"|\")\n                })$`,\n                \"u\"\n            ),\n            globInputPaths,\n            errorOnUnmatchedPattern,\n            ignoreFlag: ignore\n        });\n    }\n\n    /**\n     * The `RegExp` object that tests if a file path has the allowed file extensions.\n     * @type {RegExp}\n     */\n    get extensionRegExp() {\n        return internalSlotsMap.get(this).extensionRegExp;\n    }\n\n    /**\n     * Iterate files which are matched by given glob patterns.\n     * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.\n     * @returns {IterableIterator<FileAndConfig>} The found files.\n     */\n    *iterateFiles(patternOrPatterns) {\n        const { globInputPaths, errorOnUnmatchedPattern } = internalSlotsMap.get(this);\n        const patterns = Array.isArray(patternOrPatterns)\n            ? patternOrPatterns\n            : [patternOrPatterns];\n\n        debug(\"Start to iterate files: %o\", patterns);\n\n        // The set of paths to remove duplicate.\n        const set = new Set();\n\n        for (const pattern of patterns) {\n            let foundRegardlessOfIgnored = false;\n            let found = false;\n\n            // Skip empty string.\n            if (!pattern) {\n                continue;\n            }\n\n            // Iterate files of this pttern.\n            for (const { config, filePath, flag } of this._iterateFiles(pattern)) {\n                foundRegardlessOfIgnored = true;\n                if (flag === IGNORED_SILENTLY) {\n                    continue;\n                }\n                found = true;\n\n                // Remove duplicate paths while yielding paths.\n                if (!set.has(filePath)) {\n                    set.add(filePath);\n                    yield {\n                        config,\n                        filePath,\n                        ignored: flag === IGNORED\n                    };\n                }\n            }\n\n            // Raise an error if any files were not found.\n            if (errorOnUnmatchedPattern) {\n                if (!foundRegardlessOfIgnored) {\n                    throw new NoFilesFoundError(\n                        pattern,\n                        !globInputPaths && isGlob(pattern)\n                    );\n                }\n                if (!found) {\n                    throw new AllFilesIgnoredError(pattern);\n                }\n            }\n        }\n\n        debug(`Complete iterating files: ${JSON.stringify(patterns)}`);\n    }\n\n    /**\n     * Iterate files which are matched by a given glob pattern.\n     * @param {string} pattern The glob pattern to iterate files.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     */\n    _iterateFiles(pattern) {\n        const { cwd, globInputPaths } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, pattern);\n        const isDot = dotfilesPattern.test(pattern);\n        const stat = statSafeSync(absolutePath);\n\n        if (stat && stat.isDirectory()) {\n            return this._iterateFilesWithDirectory(absolutePath, isDot);\n        }\n        if (stat && stat.isFile()) {\n            return this._iterateFilesWithFile(absolutePath);\n        }\n        if (globInputPaths && isGlobPattern(pattern)) {\n            return this._iterateFilesWithGlob(absolutePath, isDot);\n        }\n\n        return [];\n    }\n\n    /**\n     * Iterate a file which is matched by a given path.\n     * @param {string} filePath The path to the target file.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    _iterateFilesWithFile(filePath) {\n        debug(`File: ${filePath}`);\n\n        const { configArrayFactory } = internalSlotsMap.get(this);\n        const config = configArrayFactory.getConfigArrayForFile(filePath);\n        const ignored = this._isIgnoredFile(filePath, { config, direct: true });\n        const flag = ignored ? IGNORED : NONE;\n\n        return [{ config, filePath, flag }];\n    }\n\n    /**\n     * Iterate files in a given path.\n     * @param {string} directoryPath The path to the target directory.\n     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    _iterateFilesWithDirectory(directoryPath, dotfiles) {\n        debug(`Directory: ${directoryPath}`);\n\n        return this._iterateFilesRecursive(\n            directoryPath,\n            { dotfiles, recursive: true, selector: null }\n        );\n    }\n\n    /**\n     * Iterate files which are matched by a given glob pattern.\n     * @param {string} pattern The glob pattern to iterate files.\n     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    _iterateFilesWithGlob(pattern, dotfiles) {\n        debug(`Glob: ${pattern}`);\n\n        const directoryPath = path.resolve(getGlobParent(pattern));\n        const globPart = pattern.slice(directoryPath.length + 1);\n\n        /*\n         * recursive if there are `**` or path separators in the glob part.\n         * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.\n         */\n        const recursive = /\\*\\*|\\/|\\\\/u.test(globPart);\n        const selector = new Minimatch(pattern, minimatchOpts);\n\n        debug(`recursive? ${recursive}`);\n\n        return this._iterateFilesRecursive(\n            directoryPath,\n            { dotfiles, recursive, selector }\n        );\n    }\n\n    /**\n     * Iterate files in a given path.\n     * @param {string} directoryPath The path to the target directory.\n     * @param {Object} options The options to iterate files.\n     * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.\n     * @param {boolean} [options.recursive] If `true` then it dives into sub directories.\n     * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.\n     * @returns {IterableIterator<FileEntry>} The found files.\n     * @private\n     */\n    *_iterateFilesRecursive(directoryPath, options) {\n        debug(`Enter the directory: ${directoryPath}`);\n        const { configArrayFactory, extensionRegExp } = internalSlotsMap.get(this);\n\n        /** @type {ConfigArray|null} */\n        let config = null;\n\n        // Enumerate the files of this directory.\n        for (const filename of readdirSafeSync(directoryPath)) {\n            const filePath = path.join(directoryPath, filename);\n            const stat = statSafeSync(filePath); // TODO: Use `withFileTypes` in the future.\n\n            // Check if the file is matched.\n            if (stat && stat.isFile()) {\n                if (!config) {\n                    config = configArrayFactory.getConfigArrayForFile(\n                        filePath,\n\n                        /*\n                         * We must ignore `ConfigurationNotFoundError` at this\n                         * point because we don't know if target files exist in\n                         * this directory.\n                         */\n                        { ignoreNotFoundError: true }\n                    );\n                }\n                const ignored = this._isIgnoredFile(filePath, { ...options, config });\n                const flag = ignored ? IGNORED_SILENTLY : NONE;\n                const matched = options.selector\n\n                    // Started with a glob pattern; choose by the pattern.\n                    ? options.selector.match(filePath)\n\n                    // Started with a directory path; choose by file extensions.\n                    : extensionRegExp.test(filePath);\n\n                if (matched) {\n                    debug(`Yield: ${filename}${ignored ? \" but ignored\" : \"\"}`);\n                    yield {\n                        config: configArrayFactory.getConfigArrayForFile(filePath),\n                        filePath,\n                        flag\n                    };\n                } else {\n                    debug(`Didn't match: ${filename}`);\n                }\n\n            // Dive into the sub directory.\n            } else if (options.recursive && stat && stat.isDirectory()) {\n                if (!config) {\n                    config = configArrayFactory.getConfigArrayForFile(\n                        filePath,\n                        { ignoreNotFoundError: true }\n                    );\n                }\n                const ignored = this._isIgnoredFile(\n                    filePath + path.sep,\n                    { ...options, config }\n                );\n\n                if (!ignored) {\n                    yield* this._iterateFilesRecursive(filePath, options);\n                }\n            }\n        }\n\n        debug(`Leave the directory: ${directoryPath}`);\n    }\n\n    /**\n     * Check if a given file should be ignored.\n     * @param {string} filePath The path to a file to check.\n     * @param {Object} options Options\n     * @param {ConfigArray} [options.config] The config for this file.\n     * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.\n     * @param {boolean} [options.direct] If `true` then this is a direct specified file.\n     * @returns {boolean} `true` if the file should be ignored.\n     * @private\n     */\n    _isIgnoredFile(filePath, {\n        config: providedConfig,\n        dotfiles = false,\n        direct = false\n    }) {\n        const {\n            configArrayFactory,\n            defaultIgnores,\n            ignoreFlag\n        } = internalSlotsMap.get(this);\n\n        if (ignoreFlag) {\n            const config =\n                providedConfig ||\n                configArrayFactory.getConfigArrayForFile(\n                    filePath,\n                    { ignoreNotFoundError: true }\n                );\n            const ignores =\n                config.extractConfig(filePath).ignores || defaultIgnores;\n\n            return ignores(filePath, dotfiles);\n        }\n\n        return !direct && defaultIgnores(filePath, dotfiles);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = { FileEnumerator };\n"]},"metadata":{},"sourceType":"script"}