{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function _istanbulLibReport() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function _istanbulReports() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function _istanbulLibCoverage() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function _istanbulLibSourceMaps() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function _jestWorker() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function _glob() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _base_reporter = _interopRequireDefault(require('./base_reporter'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _base_reporter.default {\n  constructor(globalConfig, options) {\n    super();\n\n    _defineProperty(this, '_coverageMap', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_sourceMapStore', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._options = options || {};\n  }\n\n  onTestResult(_test, testResult, _aggregatedResults) {\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n\n    const sourceMaps = testResult.sourceMaps;\n\n    if (sourceMaps) {\n      Object.keys(sourceMaps).forEach(sourcePath => {\n        let inputSourceMap;\n\n        try {\n          const coverage = this._coverageMap.fileCoverageFor(sourcePath);\n\n          inputSourceMap = coverage.toJSON().inputSourceMap;\n        } finally {\n          if (inputSourceMap) {\n            this._sourceMapStore.registerMap(sourcePath, inputSourceMap);\n          } else {\n            this._sourceMapStore.registerURL(sourcePath, sourceMaps[sourcePath]);\n          }\n        }\n      });\n    }\n  }\n\n  onRunComplete(contexts, aggregatedResults) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this._addUntestedFiles(_this._globalConfig, contexts);\n\n      const _this$_sourceMapStore = _this._sourceMapStore.transformCoverage(_this._coverageMap),\n            map = _this$_sourceMapStore.map,\n            sourceFinder = _this$_sourceMapStore.sourceFinder;\n\n      try {\n        const reportContext = _istanbulLibReport().default.createContext({\n          dir: _this._globalConfig.coverageDirectory,\n          sourceFinder\n        });\n\n        const coverageReporters = _this._globalConfig.coverageReporters || [];\n\n        if (!_this._globalConfig.useStderr && coverageReporters.length < 1) {\n          coverageReporters.push('text-summary');\n        }\n\n        const tree = _istanbulLibReport().default.summarizers.pkg(map);\n\n        coverageReporters.forEach(reporter => {\n          tree.visit(_istanbulReports().default.create(reporter, {}), reportContext);\n        });\n        aggregatedResults.coverageMap = map;\n      } catch (e) {\n        console.error(_chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `));\n      }\n\n      _this._checkThreshold(_this._globalConfig, map);\n    })();\n  }\n\n  _addUntestedFiles(globalConfig, contexts) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const files = [];\n      contexts.forEach(context => {\n        const config = context.config;\n\n        if (globalConfig.collectCoverageFrom && globalConfig.collectCoverageFrom.length) {\n          context.hasteFS.matchFilesWithGlob(globalConfig.collectCoverageFrom, config.rootDir).forEach(filePath => files.push({\n            config,\n            path: filePath\n          }));\n        }\n      });\n\n      if (!files.length) {\n        return;\n      }\n\n      if (_jestUtil().isInteractive) {\n        process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));\n      }\n\n      let worker;\n\n      if (_this2._globalConfig.maxWorkers <= 1) {\n        worker = require('./coverage_worker');\n      } else {\n        worker = new (_jestWorker().default)(require.resolve('./coverage_worker'), {\n          exposedMethods: ['worker'],\n          maxRetries: 2,\n          numWorkers: _this2._globalConfig.maxWorkers\n        });\n      }\n\n      const instrumentation = files.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (fileObj) {\n          const filename = fileObj.path;\n          const config = fileObj.config;\n\n          if (!_this2._coverageMap.data[filename] && 'worker' in worker) {\n            try {\n              const result = yield worker.worker({\n                config,\n                globalConfig,\n                options: _objectSpread({}, _this2._options, {\n                  changedFiles: _this2._options.changedFiles && Array.from(_this2._options.changedFiles)\n                }),\n                path: filename\n              });\n\n              if (result) {\n                _this2._coverageMap.addFileCoverage(result.coverage);\n\n                if (result.sourceMapPath) {\n                  _this2._sourceMapStore.registerURL(filename, result.sourceMapPath);\n                }\n              }\n            } catch (error) {\n              console.error(_chalk().default.red([`Failed to collect coverage from ${filename}`, `ERROR: ${error.message}`, `STACK: ${error.stack}`].join('\\n')));\n            }\n          }\n        });\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n\n      try {\n        yield Promise.all(instrumentation);\n      } catch (err) {// Do nothing; errors were reported earlier to the console.\n      }\n\n      if (_jestUtil().isInteractive) {\n        (0, _jestUtil().clearLine)(process.stderr);\n      }\n\n      if (worker && 'end' in worker && typeof worker.end === 'function') {\n        worker.end();\n      }\n    })();\n  }\n\n  _checkThreshold(globalConfig, map) {\n    if (globalConfig.coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n\n          if (threshold != null) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(`Jest: Uncovered count for ${key} (${actualUncovered})` + `exceeds ${name} threshold (${-1 * threshold})`);\n              }\n            } else if (actual < threshold) {\n              errors.push(`Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`);\n            }\n          }\n\n          return errors;\n        }, []);\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(globalConfig.coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce((agg, thresholdGroup) => {\n          const absoluteThresholdGroup = _path().default.resolve(thresholdGroup); // The threshold group might be a path:\n\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;\n            return agg.concat([[file, thresholdGroup]]);\n          } // If the threshold group is not a path it might be a glob:\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n\n\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = _glob().default.sync(absoluteThresholdGroup).map(filePath => _path().default.resolve(filePath));\n          }\n\n          if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n            groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;\n            return agg.concat([[file, thresholdGroup]]);\n          }\n\n          return agg;\n        }, []);\n\n        if (pathOrGlobMatches.length > 0) {\n          return files.concat(pathOrGlobMatches);\n        } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n\n        if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;\n          return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n        } // A covered file that doesn't have a threshold:\n\n\n        return files.concat([[file, undefined]]);\n      }, []);\n\n      const getFilesInThresholdGroup = thresholdGroup => coveredFilesSortedIntoThresholdGroup.filter(fileAndGroup => fileAndGroup[1] === thresholdGroup).map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths.map(filePath => map.fileCoverageFor(filePath)).reduce((combinedCoverage, nextFileCoverage) => {\n          if (combinedCoverage === undefined || combinedCoverage === null) {\n            return nextFileCoverage.toSummary();\n          }\n\n          return combinedCoverage.merge(nextFileCoverage.toSummary());\n        }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, globalConfig.coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.PATH:\n            {\n              const coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));\n\n              if (coverage) {\n                errors = errors.concat(check(thresholdGroup, globalConfig.coverageThreshold[thresholdGroup], coverage));\n              }\n\n              break;\n            }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(fileMatchingGlob => {\n              errors = errors.concat(check(fileMatchingGlob, globalConfig.coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));\n            });\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(`Jest: Coverage data for ${thresholdGroup} was not found.`);\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(err => err !== undefined && err !== null && err.length > 0);\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  } // Only exposed for the internal runner. Should not be used\n\n\n  getCoverageMap() {\n    return this._coverageMap;\n  }\n\n}\n\nexports.default = CoverageReporter;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@jest/reporters/build/coverage_reporter.js"],"names":["Object","defineProperty","exports","value","default","_path","data","_interopRequireDefault","require","_jestUtil","_istanbulLibReport","_istanbulReports","_chalk","_istanbulLibCoverage","_istanbulLibSourceMaps","_jestWorker","_glob","_base_reporter","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","args","apply","err","undefined","configurable","writable","FAIL_COLOR","bold","red","RUNNING_TEST_COLOR","dim","CoverageReporter","constructor","globalConfig","options","_coverageMap","createCoverageMap","_globalConfig","_sourceMapStore","createSourceMapStore","_options","onTestResult","_test","testResult","_aggregatedResults","coverage","merge","sourceMaps","sourcePath","inputSourceMap","fileCoverageFor","toJSON","registerMap","registerURL","onRunComplete","contexts","aggregatedResults","_this","_addUntestedFiles","_this$_sourceMapStore","transformCoverage","map","sourceFinder","reportContext","createContext","dir","coverageDirectory","coverageReporters","useStderr","push","tree","summarizers","pkg","reporter","visit","create","coverageMap","e","console","toString","stack","_checkThreshold","_this2","files","context","config","collectCoverageFrom","hasteFS","matchFilesWithGlob","rootDir","filePath","path","isInteractive","process","stderr","write","worker","maxWorkers","exposedMethods","maxRetries","numWorkers","instrumentation","_ref","fileObj","filename","result","changedFiles","Array","from","addFileCoverage","sourceMapPath","message","join","_x","all","clearLine","end","coverageThreshold","check","name","thresholds","actuals","reduce","errors","actual","pct","actualUncovered","total","covered","threshold","THRESHOLD_GROUP_TYPES","GLOB","GLOBAL","PATH","coveredFiles","thresholdGroups","groupTypeByThresholdGroup","filesByGlob","coveredFilesSortedIntoThresholdGroup","file","pathOrGlobMatches","agg","thresholdGroup","absoluteThresholdGroup","indexOf","sync","getFilesInThresholdGroup","fileAndGroup","combineCoverage","filePaths","combinedCoverage","nextFileCoverage","toSummary","fileMatchingGlob","log","_setError","Error","getCoverageMap"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibReport() {\n  const data = _interopRequireDefault(require('istanbul-lib-report'));\n\n  _istanbulLibReport = function _istanbulLibReport() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulReports() {\n  const data = _interopRequireDefault(require('istanbul-reports'));\n\n  _istanbulReports = function _istanbulReports() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibCoverage() {\n  const data = _interopRequireDefault(require('istanbul-lib-coverage'));\n\n  _istanbulLibCoverage = function _istanbulLibCoverage() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _istanbulLibSourceMaps() {\n  const data = _interopRequireDefault(require('istanbul-lib-source-maps'));\n\n  _istanbulLibSourceMaps = function _istanbulLibSourceMaps() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function _jestWorker() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function _glob() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _base_reporter = _interopRequireDefault(require('./base_reporter'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst FAIL_COLOR = _chalk().default.bold.red;\n\nconst RUNNING_TEST_COLOR = _chalk().default.bold.dim;\n\nclass CoverageReporter extends _base_reporter.default {\n  constructor(globalConfig, options) {\n    super();\n\n    _defineProperty(this, '_coverageMap', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_sourceMapStore', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    this._coverageMap = _istanbulLibCoverage().default.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = _istanbulLibSourceMaps().default.createSourceMapStore();\n    this._options = options || {};\n  }\n\n  onTestResult(_test, testResult, _aggregatedResults) {\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n\n    const sourceMaps = testResult.sourceMaps;\n\n    if (sourceMaps) {\n      Object.keys(sourceMaps).forEach(sourcePath => {\n        let inputSourceMap;\n\n        try {\n          const coverage = this._coverageMap.fileCoverageFor(sourcePath);\n\n          inputSourceMap = coverage.toJSON().inputSourceMap;\n        } finally {\n          if (inputSourceMap) {\n            this._sourceMapStore.registerMap(sourcePath, inputSourceMap);\n          } else {\n            this._sourceMapStore.registerURL(\n              sourcePath,\n              sourceMaps[sourcePath]\n            );\n          }\n        }\n      });\n    }\n  }\n\n  onRunComplete(contexts, aggregatedResults) {\n    var _this = this;\n\n    return _asyncToGenerator(function*() {\n      yield _this._addUntestedFiles(_this._globalConfig, contexts);\n\n      const _this$_sourceMapStore = _this._sourceMapStore.transformCoverage(\n          _this._coverageMap\n        ),\n        map = _this$_sourceMapStore.map,\n        sourceFinder = _this$_sourceMapStore.sourceFinder;\n\n      try {\n        const reportContext = _istanbulLibReport().default.createContext({\n          dir: _this._globalConfig.coverageDirectory,\n          sourceFinder\n        });\n\n        const coverageReporters = _this._globalConfig.coverageReporters || [];\n\n        if (!_this._globalConfig.useStderr && coverageReporters.length < 1) {\n          coverageReporters.push('text-summary');\n        }\n\n        const tree = _istanbulLibReport().default.summarizers.pkg(map);\n\n        coverageReporters.forEach(reporter => {\n          tree.visit(\n            _istanbulReports().default.create(reporter, {}),\n            reportContext\n          );\n        });\n        aggregatedResults.coverageMap = map;\n      } catch (e) {\n        console.error(\n          _chalk().default.red(`\n        Failed to write coverage reports:\n        ERROR: ${e.toString()}\n        STACK: ${e.stack}\n      `)\n        );\n      }\n\n      _this._checkThreshold(_this._globalConfig, map);\n    })();\n  }\n\n  _addUntestedFiles(globalConfig, contexts) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function*() {\n      const files = [];\n      contexts.forEach(context => {\n        const config = context.config;\n\n        if (\n          globalConfig.collectCoverageFrom &&\n          globalConfig.collectCoverageFrom.length\n        ) {\n          context.hasteFS\n            .matchFilesWithGlob(\n              globalConfig.collectCoverageFrom,\n              config.rootDir\n            )\n            .forEach(filePath =>\n              files.push({\n                config,\n                path: filePath\n              })\n            );\n        }\n      });\n\n      if (!files.length) {\n        return;\n      }\n\n      if (_jestUtil().isInteractive) {\n        process.stderr.write(\n          RUNNING_TEST_COLOR('Running coverage on untested files...')\n        );\n      }\n\n      let worker;\n\n      if (_this2._globalConfig.maxWorkers <= 1) {\n        worker = require('./coverage_worker');\n      } else {\n        worker = new (_jestWorker()).default(\n          require.resolve('./coverage_worker'),\n          {\n            exposedMethods: ['worker'],\n            maxRetries: 2,\n            numWorkers: _this2._globalConfig.maxWorkers\n          }\n        );\n      }\n\n      const instrumentation = files.map(\n        /*#__PURE__*/\n        (function() {\n          var _ref = _asyncToGenerator(function*(fileObj) {\n            const filename = fileObj.path;\n            const config = fileObj.config;\n\n            if (!_this2._coverageMap.data[filename] && 'worker' in worker) {\n              try {\n                const result = yield worker.worker({\n                  config,\n                  globalConfig,\n                  options: _objectSpread({}, _this2._options, {\n                    changedFiles:\n                      _this2._options.changedFiles &&\n                      Array.from(_this2._options.changedFiles)\n                  }),\n                  path: filename\n                });\n\n                if (result) {\n                  _this2._coverageMap.addFileCoverage(result.coverage);\n\n                  if (result.sourceMapPath) {\n                    _this2._sourceMapStore.registerURL(\n                      filename,\n                      result.sourceMapPath\n                    );\n                  }\n                }\n              } catch (error) {\n                console.error(\n                  _chalk().default.red(\n                    [\n                      `Failed to collect coverage from ${filename}`,\n                      `ERROR: ${error.message}`,\n                      `STACK: ${error.stack}`\n                    ].join('\\n')\n                  )\n                );\n              }\n            }\n          });\n\n          return function(_x) {\n            return _ref.apply(this, arguments);\n          };\n        })()\n      );\n\n      try {\n        yield Promise.all(instrumentation);\n      } catch (err) {\n        // Do nothing; errors were reported earlier to the console.\n      }\n\n      if (_jestUtil().isInteractive) {\n        (0, _jestUtil().clearLine)(process.stderr);\n      }\n\n      if (worker && 'end' in worker && typeof worker.end === 'function') {\n        worker.end();\n      }\n    })();\n  }\n\n  _checkThreshold(globalConfig, map) {\n    if (globalConfig.coverageThreshold) {\n      function check(name, thresholds, actuals) {\n        return ['statements', 'branches', 'lines', 'functions'].reduce(\n          (errors, key) => {\n            const actual = actuals[key].pct;\n            const actualUncovered = actuals[key].total - actuals[key].covered;\n            const threshold = thresholds[key];\n\n            if (threshold != null) {\n              if (threshold < 0) {\n                if (threshold * -1 < actualUncovered) {\n                  errors.push(\n                    `Jest: Uncovered count for ${key} (${actualUncovered})` +\n                      `exceeds ${name} threshold (${-1 * threshold})`\n                  );\n                }\n              } else if (actual < threshold) {\n                errors.push(\n                  `Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`\n                );\n              }\n            }\n\n            return errors;\n          },\n          []\n        );\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path'\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(globalConfig.coverageThreshold);\n      const groupTypeByThresholdGroup = {};\n      const filesByGlob = {};\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce(\n        (files, file) => {\n          const pathOrGlobMatches = thresholdGroups.reduce(\n            (agg, thresholdGroup) => {\n              const absoluteThresholdGroup = _path().default.resolve(\n                thresholdGroup\n              ); // The threshold group might be a path:\n\n              if (file.indexOf(absoluteThresholdGroup) === 0) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.PATH;\n                return agg.concat([[file, thresholdGroup]]);\n              } // If the threshold group is not a path it might be a glob:\n              // Note: glob.sync is slow. By memoizing the files matching each glob\n              // (rather than recalculating it for each covered file) we save a tonne\n              // of execution time.\n\n              if (filesByGlob[absoluteThresholdGroup] === undefined) {\n                filesByGlob[absoluteThresholdGroup] = _glob()\n                  .default.sync(absoluteThresholdGroup)\n                  .map(filePath => _path().default.resolve(filePath));\n              }\n\n              if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {\n                groupTypeByThresholdGroup[thresholdGroup] =\n                  THRESHOLD_GROUP_TYPES.GLOB;\n                return agg.concat([[file, thresholdGroup]]);\n              }\n\n              return agg;\n            },\n            []\n          );\n\n          if (pathOrGlobMatches.length > 0) {\n            return files.concat(pathOrGlobMatches);\n          } // Neither a glob or a path? Toss it in global if there's a global threshold:\n\n          if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {\n            groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] =\n              THRESHOLD_GROUP_TYPES.GLOBAL;\n            return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);\n          } // A covered file that doesn't have a threshold:\n\n          return files.concat([[file, undefined]]);\n        },\n        []\n      );\n\n      const getFilesInThresholdGroup = thresholdGroup =>\n        coveredFilesSortedIntoThresholdGroup\n          .filter(fileAndGroup => fileAndGroup[1] === thresholdGroup)\n          .map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths) {\n        return filePaths\n          .map(filePath => map.fileCoverageFor(filePath))\n          .reduce((combinedCoverage, nextFileCoverage) => {\n            if (combinedCoverage === undefined || combinedCoverage === null) {\n              return nextFileCoverage.toSummary();\n            }\n\n            return combinedCoverage.merge(nextFileCoverage.toSummary());\n          }, undefined);\n      }\n\n      let errors = [];\n      thresholdGroups.forEach(thresholdGroup => {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  globalConfig.coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.PATH: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(thresholdGroup)\n            );\n\n            if (coverage) {\n              errors = errors.concat(\n                check(\n                  thresholdGroup,\n                  globalConfig.coverageThreshold[thresholdGroup],\n                  coverage\n                )\n              );\n            }\n\n            break;\n          }\n\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            getFilesInThresholdGroup(thresholdGroup).forEach(\n              fileMatchingGlob => {\n                errors = errors.concat(\n                  check(\n                    fileMatchingGlob,\n                    globalConfig.coverageThreshold[thresholdGroup],\n                    map.fileCoverageFor(fileMatchingGlob).toSummary()\n                  )\n                );\n              }\n            );\n            break;\n\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = errors.concat(\n                `Jest: Coverage data for ${thresholdGroup} was not found.`\n              );\n            }\n\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      });\n      errors = errors.filter(\n        err => err !== undefined && err !== null && err.length > 0\n      );\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  } // Only exposed for the internal runner. Should not be used\n\n  getCoverageMap() {\n    return this._coverageMap;\n  }\n}\n\nexports.default = CoverageReporter;\n"]},"metadata":{},"sourceType":"script"}