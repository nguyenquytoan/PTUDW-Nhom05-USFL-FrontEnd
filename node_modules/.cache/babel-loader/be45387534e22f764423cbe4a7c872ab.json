{"ast":null,"code":"/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\n\nconst espree = require(\"espree\");\n\nconst lodash = require(\"lodash\");\n\nconst {\n  breakableTypePattern,\n  createGlobalLinebreakMatcher,\n  lineBreakPattern,\n  shebangPattern\n} = require(\"../../shared/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]); // A set of node types that can contain a list of statements\n\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\nconst DECIMAL_INTEGER_PATTERN = /^(0|[1-9]\\d*)$/u;\nconst OCTAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\[^0-7]|\\\\0(?![0-9]))*\\\\(?:[1-7]|0[0-9])/u;\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference A reference to check.\n * @param {int} index The index of the reference in the references.\n * @param {Reference[]} references The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\n\nfunction isModifyingReference(reference, index, references) {\n  const identifier = reference.identifier;\n  /*\n   * Destructuring assignments can have multiple default value, so\n   * possibly there are multiple writeable references for the same\n   * identifier.\n   */\n\n  const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;\n  return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;\n}\n/**\n * Checks whether the given string starts with uppercase or not.\n * @param {string} s The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\n\n\nfunction startsWithUpperCase(s) {\n  return s[0] !== s[0].toLocaleLowerCase();\n}\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\n\n\nfunction isES5Constructor(node) {\n  return node.id && startsWithUpperCase(node.id.name);\n}\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node A start node to find.\n * @returns {Node|null} A found function node.\n */\n\n\nfunction getUpperFunction(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (anyFunctionPattern.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n\n  return null;\n}\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\n\n\nfunction isFunction(node) {\n  return Boolean(node && anyFunctionPattern.test(node.type));\n}\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\n\n\nfunction isLoop(node) {\n  return Boolean(node && anyLoopPattern.test(node.type));\n}\n/**\n * Checks whether the given node is in a loop or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\n\n\nfunction isInLoop(node) {\n  for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n    if (isLoop(currentNode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\n\n\nfunction isNullOrUndefined(node) {\n  return module.exports.isNullLiteral(node) || node.type === \"Identifier\" && node.name === \"undefined\" || node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\n\n\nfunction isCallee(node) {\n  return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\n\n\nfunction isReflectApply(node) {\n  return node.type === \"MemberExpression\" && node.object.type === \"Identifier\" && node.object.name === \"Reflect\" && node.property.type === \"Identifier\" && node.property.name === \"apply\" && node.computed === false;\n}\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\n\n\nfunction isArrayFromMethod(node) {\n  return node.type === \"MemberExpression\" && node.object.type === \"Identifier\" && arrayOrTypedArrayPattern.test(node.object.name) && node.property.type === \"Identifier\" && node.property.name === \"from\" && node.computed === false;\n}\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\n\n\nfunction isMethodWhichHasThisArg(node) {\n  for (let currentNode = node; currentNode.type === \"MemberExpression\" && !currentNode.computed; currentNode = currentNode.property) {\n    if (currentNode.property.type === \"Identifier\") {\n      return arrayMethodPattern.test(currentNode.property.name);\n    }\n  }\n\n  return false;\n}\n/**\n * Creates the negate function of the given function.\n * @param {Function} f The function to negate.\n * @returns {Function} Negated function.\n */\n\n\nfunction negate(f) {\n  return token => !f(token);\n}\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node A node to check.\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\n\n\nfunction hasJSDocThisTag(node, sourceCode) {\n  const jsdocComment = sourceCode.getJSDocComment(node);\n\n  if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n    return true;\n  } // Checks `@this` in its leading comments for callbacks,\n  // because callbacks don't have its JSDoc comment.\n  // e.g.\n  //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n\n\n  return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\n\n\nfunction isParenthesised(sourceCode, node) {\n  const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n  return Boolean(previousToken && nextToken) && previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] && nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\n\n\nfunction isArrowToken(token) {\n  return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\n\n\nfunction isCommaToken(token) {\n  return token.value === \",\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a dot token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a dot token.\n */\n\n\nfunction isDotToken(token) {\n  return token.value === \".\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\n\n\nfunction isSemicolonToken(token) {\n  return token.value === \";\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\n\n\nfunction isColonToken(token) {\n  return token.value === \":\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\n\n\nfunction isOpeningParenToken(token) {\n  return token.value === \"(\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\n\n\nfunction isClosingParenToken(token) {\n  return token.value === \")\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\n\n\nfunction isOpeningBracketToken(token) {\n  return token.value === \"[\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\n\n\nfunction isClosingBracketToken(token) {\n  return token.value === \"]\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\n\n\nfunction isOpeningBraceToken(token) {\n  return token.value === \"{\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\n\n\nfunction isClosingBraceToken(token) {\n  return token.value === \"}\" && token.type === \"Punctuator\";\n}\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\n\n\nfunction isCommentToken(token) {\n  return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n/**\n * Checks if the given token is a keyword token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\n\n\nfunction isKeywordToken(token) {\n  return token.type === \"Keyword\";\n}\n/**\n * Gets the `(` token of the given function node.\n * @param {ASTNode} node The function node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} `(` token.\n */\n\n\nfunction getOpeningParenOfParams(node, sourceCode) {\n  return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left A node 1 to compare.\n * @param {ASTNode} right A node 2 to compare.\n * @param {SourceCode} sourceCode The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\n\n\nfunction equalTokens(left, right, sourceCode) {\n  const tokensL = sourceCode.getTokens(left);\n  const tokensR = sourceCode.getTokens(right);\n\n  if (tokensL.length !== tokensR.length) {\n    return false;\n  }\n\n  for (let i = 0; i < tokensL.length; ++i) {\n    if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {\n      return false;\n    }\n  }\n\n  return true;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  COMMENTS_IGNORE_PATTERN,\n  LINEBREAKS,\n  LINEBREAK_MATCHER: lineBreakPattern,\n  SHEBANG_MATCHER: shebangPattern,\n  STATEMENT_LIST_PARENTS,\n\n  /**\n   * Determines whether two adjacent tokens are on the same line.\n   * @param {Object} left The left token object.\n   * @param {Object} right The right token object.\n   * @returns {boolean} Whether or not the tokens are on the same line.\n   * @public\n   */\n  isTokenOnSameLine(left, right) {\n    return left.loc.end.line === right.loc.start.line;\n  },\n\n  isNullOrUndefined,\n  isCallee,\n  isES5Constructor,\n  getUpperFunction,\n  isFunction,\n  isLoop,\n  isInLoop,\n  isArrayFromMethod,\n  isParenthesised,\n  createGlobalLinebreakMatcher,\n  equalTokens,\n  isArrowToken,\n  isClosingBraceToken,\n  isClosingBracketToken,\n  isClosingParenToken,\n  isColonToken,\n  isCommaToken,\n  isCommentToken,\n  isDotToken,\n  isKeywordToken,\n  isNotClosingBraceToken: negate(isClosingBraceToken),\n  isNotClosingBracketToken: negate(isClosingBracketToken),\n  isNotClosingParenToken: negate(isClosingParenToken),\n  isNotColonToken: negate(isColonToken),\n  isNotCommaToken: negate(isCommaToken),\n  isNotDotToken: negate(isDotToken),\n  isNotOpeningBraceToken: negate(isOpeningBraceToken),\n  isNotOpeningBracketToken: negate(isOpeningBracketToken),\n  isNotOpeningParenToken: negate(isOpeningParenToken),\n  isNotSemicolonToken: negate(isSemicolonToken),\n  isOpeningBraceToken,\n  isOpeningBracketToken,\n  isOpeningParenToken,\n  isSemicolonToken,\n\n  /**\n   * Checks whether or not a given node is a string literal.\n   * @param {ASTNode} node A node to check.\n   * @returns {boolean} `true` if the node is a string literal.\n   */\n  isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\";\n  },\n\n  /**\n   * Checks whether a given node is a breakable statement or not.\n   * The node is breakable if the node is one of the following type:\n   *\n   * - DoWhileStatement\n   * - ForInStatement\n   * - ForOfStatement\n   * - ForStatement\n   * - SwitchStatement\n   * - WhileStatement\n   * @param {ASTNode} node A node to check.\n   * @returns {boolean} `true` if the node is breakable.\n   */\n  isBreakableStatement(node) {\n    return breakableTypePattern.test(node.type);\n  },\n\n  /**\n   * Gets references which are non initializer and writable.\n   * @param {Reference[]} references An array of references.\n   * @returns {Reference[]} An array of only references which are non initializer and writable.\n   * @public\n   */\n  getModifyingReferences(references) {\n    return references.filter(isModifyingReference);\n  },\n\n  /**\n   * Validate that a string passed in is surrounded by the specified character\n   * @param  {string} val The text to check.\n   * @param  {string} character The character to see if it's surrounded by.\n   * @returns {boolean} True if the text is surrounded by the character, false if not.\n   * @private\n   */\n  isSurroundedBy(val, character) {\n    return val[0] === character && val[val.length - 1] === character;\n  },\n\n  /**\n   * Returns whether the provided node is an ESLint directive comment or not\n   * @param {Line|Block} node The comment token to be checked\n   * @returns {boolean} `true` if the node is an ESLint directive comment\n   */\n  isDirectiveComment(node) {\n    const comment = node.value.trim();\n    return node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 || node.type === \"Block\" && (comment.indexOf(\"global \") === 0 || comment.indexOf(\"eslint \") === 0 || comment.indexOf(\"eslint-\") === 0);\n  },\n\n  /**\n   * Gets the trailing statement of a given node.\n   *\n   *     if (code)\n   *         consequent;\n   *\n   * When taking this `IfStatement`, returns `consequent;` statement.\n   * @param {ASTNode} A node to get.\n   * @returns {ASTNode|null} The trailing statement's node.\n   */\n  getTrailingStatement: esutils.ast.trailingStatement,\n\n  /**\n   * Finds the variable by a given name in a given scope and its upper scopes.\n   * @param {eslint-scope.Scope} initScope A scope to start find.\n   * @param {string} name A variable name to find.\n   * @returns {eslint-scope.Variable|null} A found variable or `null`.\n   */\n  getVariableByName(initScope, name) {\n    let scope = initScope;\n\n    while (scope) {\n      const variable = scope.set.get(name);\n\n      if (variable) {\n        return variable;\n      }\n\n      scope = scope.upper;\n    }\n\n    return null;\n  },\n\n  /**\n   * Checks whether or not a given function node is the default `this` binding.\n   *\n   * First, this checks the node:\n   *\n   * - The function name does not start with uppercase. It's a convention to capitalize the names\n   *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\n   * - The function does not have a JSDoc comment that has a @this tag.\n   *\n   * Next, this checks the location of the node.\n   * If the location is below, this judges `this` is valid.\n   *\n   * - The location is not on an object literal.\n   * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\n   *   functions only, as the name of the variable is considered to be the name of the function in this case.\n   *   This check is not performed if `capIsConstructor` is set to `false`.\n   * - The location is not on an ES2015 class.\n   * - Its `bind`/`call`/`apply` method is not called directly.\n   * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n   * @param {ASTNode} node A function node to check.\n   * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n   * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\n   * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\n   * @returns {boolean} The function node is the default `this` binding.\n   */\n  isDefaultThisBinding(node, sourceCode, {\n    capIsConstructor = true\n  } = {}) {\n    if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n      return false;\n    }\n\n    const isAnonymous = node.id === null;\n    let currentNode = node;\n\n    while (currentNode) {\n      const parent = currentNode.parent;\n\n      switch (parent.type) {\n        /*\n         * Looks up the destination.\n         * e.g., obj.foo = nativeFoo || function foo() { ... };\n         */\n        case \"LogicalExpression\":\n        case \"ConditionalExpression\":\n          currentNode = parent;\n          break;\n\n        /*\n         * If the upper function is IIFE, checks the destination of the return value.\n         * e.g.\n         *   obj.foo = (function() {\n         *     // setup...\n         *     return function foo() { ... };\n         *   })();\n         *   obj.foo = (() =>\n         *     function foo() { ... }\n         *   )();\n         */\n\n        case \"ReturnStatement\":\n          {\n            const func = getUpperFunction(parent);\n\n            if (func === null || !isCallee(func)) {\n              return true;\n            }\n\n            currentNode = func.parent;\n            break;\n          }\n\n        case \"ArrowFunctionExpression\":\n          if (currentNode !== parent.body || !isCallee(parent)) {\n            return true;\n          }\n\n          currentNode = parent.parent;\n          break;\n\n        /*\n         * e.g.\n         *   var obj = { foo() { ... } };\n         *   var obj = { foo: function() { ... } };\n         *   class A { constructor() { ... } }\n         *   class A { foo() { ... } }\n         *   class A { get foo() { ... } }\n         *   class A { set foo() { ... } }\n         *   class A { static foo() { ... } }\n         */\n\n        case \"Property\":\n        case \"MethodDefinition\":\n          return parent.value !== currentNode;\n\n        /*\n         * e.g.\n         *   obj.foo = function foo() { ... };\n         *   Foo = function() { ... };\n         *   [obj.foo = function foo() { ... }] = a;\n         *   [Foo = function() { ... }] = a;\n         */\n\n        case \"AssignmentExpression\":\n        case \"AssignmentPattern\":\n          if (parent.left.type === \"MemberExpression\") {\n            return false;\n          }\n\n          if (capIsConstructor && isAnonymous && parent.left.type === \"Identifier\" && startsWithUpperCase(parent.left.name)) {\n            return false;\n          }\n\n          return true;\n\n        /*\n         * e.g.\n         *   var Foo = function() { ... };\n         */\n\n        case \"VariableDeclarator\":\n          return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === \"Identifier\" && startsWithUpperCase(parent.id.name));\n\n        /*\n         * e.g.\n         *   var foo = function foo() { ... }.bind(obj);\n         *   (function foo() { ... }).call(obj);\n         *   (function foo() { ... }).apply(obj, []);\n         */\n\n        case \"MemberExpression\":\n          return parent.object !== currentNode || parent.property.type !== \"Identifier\" || !bindOrCallOrApplyPattern.test(parent.property.name) || !isCallee(parent) || parent.parent.arguments.length === 0 || isNullOrUndefined(parent.parent.arguments[0]);\n\n        /*\n         * e.g.\n         *   Reflect.apply(function() {}, obj, []);\n         *   Array.from([], function() {}, obj);\n         *   list.forEach(function() {}, obj);\n         */\n\n        case \"CallExpression\":\n          if (isReflectApply(parent.callee)) {\n            return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n          }\n\n          if (isArrayFromMethod(parent.callee)) {\n            return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);\n          }\n\n          if (isMethodWhichHasThisArg(parent.callee)) {\n            return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n          }\n\n          return true;\n        // Otherwise `this` is default.\n\n        default:\n          return true;\n      }\n    }\n    /* istanbul ignore next */\n\n\n    return true;\n  },\n\n  /**\n   * Get the precedence level based on the node type\n   * @param {ASTNode} node node to evaluate\n   * @returns {int} precedence level\n   * @private\n   */\n  getPrecedence(node) {\n    switch (node.type) {\n      case \"SequenceExpression\":\n        return 0;\n\n      case \"AssignmentExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"YieldExpression\":\n        return 1;\n\n      case \"ConditionalExpression\":\n        return 3;\n\n      case \"LogicalExpression\":\n        switch (node.operator) {\n          case \"||\":\n            return 4;\n\n          case \"&&\":\n            return 5;\n          // no default\n        }\n\n      /* falls through */\n\n      case \"BinaryExpression\":\n        switch (node.operator) {\n          case \"|\":\n            return 6;\n\n          case \"^\":\n            return 7;\n\n          case \"&\":\n            return 8;\n\n          case \"==\":\n          case \"!=\":\n          case \"===\":\n          case \"!==\":\n            return 9;\n\n          case \"<\":\n          case \"<=\":\n          case \">\":\n          case \">=\":\n          case \"in\":\n          case \"instanceof\":\n            return 10;\n\n          case \"<<\":\n          case \">>\":\n          case \">>>\":\n            return 11;\n\n          case \"+\":\n          case \"-\":\n            return 12;\n\n          case \"*\":\n          case \"/\":\n          case \"%\":\n            return 13;\n\n          case \"**\":\n            return 15;\n          // no default\n        }\n\n      /* falls through */\n\n      case \"UnaryExpression\":\n      case \"AwaitExpression\":\n        return 16;\n\n      case \"UpdateExpression\":\n        return 17;\n\n      case \"CallExpression\":\n      case \"ImportExpression\":\n        return 18;\n\n      case \"NewExpression\":\n        return 19;\n\n      default:\n        return 20;\n    }\n  },\n\n  /**\n   * Checks whether the given node is an empty block node or not.\n   * @param {ASTNode|null} node The node to check.\n   * @returns {boolean} `true` if the node is an empty block.\n   */\n  isEmptyBlock(node) {\n    return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n  },\n\n  /**\n   * Checks whether the given node is an empty function node or not.\n   * @param {ASTNode|null} node The node to check.\n   * @returns {boolean} `true` if the node is an empty function.\n   */\n  isEmptyFunction(node) {\n    return isFunction(node) && module.exports.isEmptyBlock(node.body);\n  },\n\n  /**\n   * Gets the property name of a given node.\n   * The node can be a MemberExpression, a Property, or a MethodDefinition.\n   *\n   * If the name is dynamic, this returns `null`.\n   *\n   * For examples:\n   *\n   *     a.b           // => \"b\"\n   *     a[\"b\"]        // => \"b\"\n   *     a['b']        // => \"b\"\n   *     a[`b`]        // => \"b\"\n   *     a[100]        // => \"100\"\n   *     a[b]          // => null\n   *     a[\"a\" + \"b\"]  // => null\n   *     a[tag`b`]     // => null\n   *     a[`${b}`]     // => null\n   *\n   *     let a = {b: 1}            // => \"b\"\n   *     let a = {[\"b\"]: 1}        // => \"b\"\n   *     let a = {['b']: 1}        // => \"b\"\n   *     let a = {[`b`]: 1}        // => \"b\"\n   *     let a = {[100]: 1}        // => \"100\"\n   *     let a = {[b]: 1}          // => null\n   *     let a = {[\"a\" + \"b\"]: 1}  // => null\n   *     let a = {[tag`b`]: 1}     // => null\n   *     let a = {[`${b}`]: 1}     // => null\n   * @param {ASTNode} node The node to get.\n   * @returns {string|null} The property name if static. Otherwise, null.\n   */\n  getStaticPropertyName(node) {\n    let prop;\n\n    switch (node && node.type) {\n      case \"Property\":\n      case \"MethodDefinition\":\n        prop = node.key;\n        break;\n\n      case \"MemberExpression\":\n        prop = node.property;\n        break;\n      // no default\n    }\n\n    switch (prop && prop.type) {\n      case \"Literal\":\n        return String(prop.value);\n\n      case \"TemplateLiteral\":\n        if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n          return prop.quasis[0].value.cooked;\n        }\n\n        break;\n\n      case \"Identifier\":\n        if (!node.computed) {\n          return prop.name;\n        }\n\n        break;\n      // no default\n    }\n\n    return null;\n  },\n\n  /**\n   * Get directives from directive prologue of a Program or Function node.\n   * @param {ASTNode} node The node to check.\n   * @returns {ASTNode[]} The directives found in the directive prologue.\n   */\n  getDirectivePrologue(node) {\n    const directives = []; // Directive prologues only occur at the top of files or functions.\n\n    if (node.type === \"Program\" || node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\" ||\n    /*\n     * Do not check arrow functions with implicit return.\n     * `() => \"use strict\";` returns the string `\"use strict\"`.\n     */\n    node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\") {\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n      for (const statement of statements) {\n        if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\") {\n          directives.push(statement);\n        } else {\n          break;\n        }\n      }\n    }\n\n    return directives;\n  },\n\n  /**\n   * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n   * after the node will be parsed as a decimal point, rather than a property-access dot.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if this node is a decimal integer.\n   * @example\n   *\n   * 5       // true\n   * 5.      // false\n   * 5.0     // false\n   * 05      // false\n   * 0x5     // false\n   * 0b101   // false\n   * 0o5     // false\n   * 5e0     // false\n   * '5'     // false\n   */\n  isDecimalInteger(node) {\n    return node.type === \"Literal\" && typeof node.value === \"number\" && DECIMAL_INTEGER_PATTERN.test(node.raw);\n  },\n\n  /**\n   * Determines whether this token is a decimal integer numeric token.\n   * This is similar to isDecimalInteger(), but for tokens.\n   * @param {Token} token The token to check.\n   * @returns {boolean} `true` if this token is a decimal integer.\n   */\n  isDecimalIntegerNumericToken(token) {\n    return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n  },\n\n  /**\n   * Gets the name and kind of the given function node.\n   *\n   * - `function foo() {}`  .................... `function 'foo'`\n   * - `(function foo() {})`  .................. `function 'foo'`\n   * - `(function() {})`  ...................... `function`\n   * - `function* foo() {}`  ................... `generator function 'foo'`\n   * - `(function* foo() {})`  ................. `generator function 'foo'`\n   * - `(function*() {})`  ..................... `generator function`\n   * - `() => {}`  ............................. `arrow function`\n   * - `async () => {}`  ....................... `async arrow function`\n   * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n   * - `({ foo: function() {} })`  ............. `method 'foo'`\n   * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n   * - `({ [foo]: function() {} })`  ........... `method`\n   * - `({ foo() {} })`  ....................... `method 'foo'`\n   * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n   * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n   * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n   * - `({ [foo]: function*() {} })`  .......... `generator method`\n   * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n   * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n   * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n   * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n   * - `({ [foo]: async function() {} })`  ..... `async method`\n   * - `({ async foo() {} })`  ................. `async method 'foo'`\n   * - `({ get foo() {} })`  ................... `getter 'foo'`\n   * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n   * - `class A { constructor() {} }`  ......... `constructor`\n   * - `class A { foo() {} }`  ................. `method 'foo'`\n   * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n   * - `class A { async foo() {} }`  ........... `async method 'foo'`\n   * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n   * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n   * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n   * - `class A { [foo]() {} }`  ............... `method`\n   * - `class A { *[foo]() {} }`  .............. `generator method`\n   * - `class A { async [foo]() {} }`  ......... `async method`\n   * - `class A { get foo() {} }`  ............. `getter 'foo'`\n   * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n   * - `class A { static foo() {} }`  .......... `static method 'foo'`\n   * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n   * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n   * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n   * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n   * @param {ASTNode} node The function node to get.\n   * @returns {string} The name and kind of the function node.\n   */\n  getFunctionNameWithKind(node) {\n    const parent = node.parent;\n    const tokens = [];\n\n    if (parent.type === \"MethodDefinition\" && parent.static) {\n      tokens.push(\"static\");\n    }\n\n    if (node.async) {\n      tokens.push(\"async\");\n    }\n\n    if (node.generator) {\n      tokens.push(\"generator\");\n    }\n\n    if (node.type === \"ArrowFunctionExpression\") {\n      tokens.push(\"arrow\", \"function\");\n    } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n      if (parent.kind === \"constructor\") {\n        return \"constructor\";\n      }\n\n      if (parent.kind === \"get\") {\n        tokens.push(\"getter\");\n      } else if (parent.kind === \"set\") {\n        tokens.push(\"setter\");\n      } else {\n        tokens.push(\"method\");\n      }\n    } else {\n      tokens.push(\"function\");\n    }\n\n    if (node.id) {\n      tokens.push(`'${node.id.name}'`);\n    } else {\n      const name = module.exports.getStaticPropertyName(parent);\n\n      if (name !== null) {\n        tokens.push(`'${name}'`);\n      }\n    }\n\n    return tokens.join(\" \");\n  },\n\n  /**\n   * Gets the location of the given function node for reporting.\n   *\n   * - `function foo() {}`\n   *    ^^^^^^^^^^^^\n   * - `(function foo() {})`\n   *     ^^^^^^^^^^^^\n   * - `(function() {})`\n   *     ^^^^^^^^\n   * - `function* foo() {}`\n   *    ^^^^^^^^^^^^^\n   * - `(function* foo() {})`\n   *     ^^^^^^^^^^^^^\n   * - `(function*() {})`\n   *     ^^^^^^^^^\n   * - `() => {}`\n   *       ^^\n   * - `async () => {}`\n   *             ^^\n   * - `({ foo: function foo() {} })`\n   *       ^^^^^^^^^^^^^^^^^\n   * - `({ foo: function() {} })`\n   *       ^^^^^^^^^^^^^\n   * - `({ ['foo']: function() {} })`\n   *       ^^^^^^^^^^^^^^^^^\n   * - `({ [foo]: function() {} })`\n   *       ^^^^^^^^^^^^^^^\n   * - `({ foo() {} })`\n   *       ^^^\n   * - `({ foo: function* foo() {} })`\n   *       ^^^^^^^^^^^^^^^^^^\n   * - `({ foo: function*() {} })`\n   *       ^^^^^^^^^^^^^^\n   * - `({ ['foo']: function*() {} })`\n   *       ^^^^^^^^^^^^^^^^^^\n   * - `({ [foo]: function*() {} })`\n   *       ^^^^^^^^^^^^^^^^\n   * - `({ *foo() {} })`\n   *       ^^^^\n   * - `({ foo: async function foo() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^^^^^\n   * - `({ foo: async function() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^\n   * - `({ ['foo']: async function() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^^^^^\n   * - `({ [foo]: async function() {} })`\n   *       ^^^^^^^^^^^^^^^^^^^^^\n   * - `({ async foo() {} })`\n   *       ^^^^^^^^^\n   * - `({ get foo() {} })`\n   *       ^^^^^^^\n   * - `({ set foo(a) {} })`\n   *       ^^^^^^^\n   * - `class A { constructor() {} }`\n   *              ^^^^^^^^^^^\n   * - `class A { foo() {} }`\n   *              ^^^\n   * - `class A { *foo() {} }`\n   *              ^^^^\n   * - `class A { async foo() {} }`\n   *              ^^^^^^^^^\n   * - `class A { ['foo']() {} }`\n   *              ^^^^^^^\n   * - `class A { *['foo']() {} }`\n   *              ^^^^^^^^\n   * - `class A { async ['foo']() {} }`\n   *              ^^^^^^^^^^^^^\n   * - `class A { [foo]() {} }`\n   *              ^^^^^\n   * - `class A { *[foo]() {} }`\n   *              ^^^^^^\n   * - `class A { async [foo]() {} }`\n   *              ^^^^^^^^^^^\n   * - `class A { get foo() {} }`\n   *              ^^^^^^^\n   * - `class A { set foo(a) {} }`\n   *              ^^^^^^^\n   * - `class A { static foo() {} }`\n   *              ^^^^^^^^^^\n   * - `class A { static *foo() {} }`\n   *              ^^^^^^^^^^^\n   * - `class A { static async foo() {} }`\n   *              ^^^^^^^^^^^^^^^^\n   * - `class A { static get foo() {} }`\n   *              ^^^^^^^^^^^^^^\n   * - `class A { static set foo(a) {} }`\n   *              ^^^^^^^^^^^^^^\n   * @param {ASTNode} node The function node to get.\n   * @param {SourceCode} sourceCode The source code object to get tokens.\n   * @returns {string} The location of the function node for reporting.\n   */\n  getFunctionHeadLoc(node, sourceCode) {\n    const parent = node.parent;\n    let start = null;\n    let end = null;\n\n    if (node.type === \"ArrowFunctionExpression\") {\n      const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n      start = arrowToken.loc.start;\n      end = arrowToken.loc.end;\n    } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n      start = parent.loc.start;\n      end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    } else {\n      start = node.loc.start;\n      end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n\n    return {\n      start: Object.assign({}, start),\n      end: Object.assign({}, end)\n    };\n  },\n\n  /**\n   * Gets next location when the result is not out of bound, otherwise returns null.\n   * @param {SourceCode} sourceCode The sourceCode\n   * @param {{line: number, column: number}} location The location\n   * @returns {{line: number, column: number} | null} Next location\n   */\n  getNextLocation(sourceCode, location) {\n    const index = sourceCode.getIndexFromLoc(location); // Avoid out of bound location\n\n    if (index + 1 > sourceCode.text.length) {\n      return null;\n    }\n\n    return sourceCode.getLocFromIndex(index + 1);\n  },\n\n  /**\n   * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n   * surrounding the node.\n   * @param {SourceCode} sourceCode The source code object\n   * @param {ASTNode} node An expression node\n   * @returns {string} The text representing the node, with all surrounding parentheses included\n   */\n  getParenthesisedText(sourceCode, node) {\n    let leftToken = sourceCode.getFirstToken(node);\n    let rightToken = sourceCode.getLastToken(node);\n\n    while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" && sourceCode.getTokenBefore(leftToken).value === \"(\" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" && sourceCode.getTokenAfter(rightToken).value === \")\") {\n      leftToken = sourceCode.getTokenBefore(leftToken);\n      rightToken = sourceCode.getTokenAfter(rightToken);\n    }\n\n    return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n  },\n\n  /*\n   * Determine if a node has a possiblity to be an Error object\n   * @param  {ASTNode} node  ASTNode to check\n   * @returns {boolean} True if there is a chance it contains an Error obj\n   */\n  couldBeError(node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"CallExpression\":\n      case \"NewExpression\":\n      case \"MemberExpression\":\n      case \"TaggedTemplateExpression\":\n      case \"YieldExpression\":\n      case \"AwaitExpression\":\n        return true;\n      // possibly an error object.\n\n      case \"AssignmentExpression\":\n        return module.exports.couldBeError(node.right);\n\n      case \"SequenceExpression\":\n        {\n          const exprs = node.expressions;\n          return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n        }\n\n      case \"LogicalExpression\":\n        return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n      case \"ConditionalExpression\":\n        return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\n   * Determines whether the given node is a `null` literal.\n   * @param {ASTNode} node The node to check\n   * @returns {boolean} `true` if the node is a `null` literal\n   */\n  isNullLiteral(node) {\n    /*\n     * Checking `node.value === null` does not guarantee that a literal is a null literal.\n     * When parsing values that cannot be represented in the current environment (e.g. unicode\n     * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n     * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n     * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n     */\n    return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n  },\n\n  /**\n   * Determines whether two tokens can safely be placed next to each other without merging into a single token\n   * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\n   * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\n   * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\n   * next to each other, behavior is undefined (although it should return `true` in most cases).\n   */\n  canTokensBeAdjacent(leftValue, rightValue) {\n    let leftToken;\n\n    if (typeof leftValue === \"string\") {\n      const leftTokens = espree.tokenize(leftValue, {\n        ecmaVersion: 2015\n      });\n      leftToken = leftTokens[leftTokens.length - 1];\n    } else {\n      leftToken = leftValue;\n    }\n\n    const rightToken = typeof rightValue === \"string\" ? espree.tokenize(rightValue, {\n      ecmaVersion: 2015\n    })[0] : rightValue;\n\n    if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n      if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n        const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n        const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n        return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));\n      }\n\n      return true;\n    }\n\n    if (leftToken.type === \"String\" || rightToken.type === \"String\" || leftToken.type === \"Template\" || rightToken.type === \"Template\") {\n      return true;\n    }\n\n    if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Get the `loc` object of a given name in a `/*globals` directive comment.\n   * @param {SourceCode} sourceCode The source code to convert index to loc.\n   * @param {Comment} comment The `/*globals` directive comment which include the name.\n   * @param {string} name The name to find.\n   * @returns {SourceLocation} The `loc` object.\n   */\n  getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n    const namePattern = new RegExp(`[\\\\s,]${lodash.escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\"); // To ignore the first text \"global\".\n\n    namePattern.lastIndex = comment.value.indexOf(\"global\") + 6; // Search a given variable name.\n\n    const match = namePattern.exec(comment.value); // Convert the index to loc.\n\n    return sourceCode.getLocFromIndex(comment.range[0] + \"/*\".length + (match ? match.index + 1 : 0));\n  },\n\n  /**\n   * Determines whether the given raw string contains an octal escape sequence.\n   *\n   * \"\\1\", \"\\2\" ... \"\\7\"\n   * \"\\00\", \"\\01\" ... \"\\09\"\n   *\n   * \"\\0\", when not followed by a digit, is not an octal escape sequence.\n   * @param {string} rawString A string in its raw representation.\n   * @returns {boolean} `true` if the string contains at least one octal escape sequence.\n   */\n  hasOctalEscapeSequence(rawString) {\n    return OCTAL_ESCAPE_PATTERN.test(rawString);\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/utils/ast-utils.js"],"names":["esutils","require","espree","lodash","breakableTypePattern","createGlobalLinebreakMatcher","lineBreakPattern","shebangPattern","anyFunctionPattern","anyLoopPattern","arrayOrTypedArrayPattern","arrayMethodPattern","bindOrCallOrApplyPattern","thisTagPattern","COMMENTS_IGNORE_PATTERN","LINEBREAKS","Set","STATEMENT_LIST_PARENTS","DECIMAL_INTEGER_PATTERN","OCTAL_ESCAPE_PATTERN","isModifyingReference","reference","index","references","identifier","modifyingDifferentIdentifier","init","isWrite","startsWithUpperCase","s","toLocaleLowerCase","isES5Constructor","node","id","name","getUpperFunction","currentNode","parent","test","type","isFunction","Boolean","isLoop","isInLoop","isNullOrUndefined","module","exports","isNullLiteral","operator","isCallee","callee","isReflectApply","object","property","computed","isArrayFromMethod","isMethodWhichHasThisArg","negate","f","token","hasJSDocThisTag","sourceCode","jsdocComment","getJSDocComment","value","getCommentsBefore","some","comment","isParenthesised","previousToken","getTokenBefore","nextToken","getTokenAfter","range","isArrowToken","isCommaToken","isDotToken","isSemicolonToken","isColonToken","isOpeningParenToken","isClosingParenToken","isOpeningBracketToken","isClosingBracketToken","isOpeningBraceToken","isClosingBraceToken","isCommentToken","isKeywordToken","getOpeningParenOfParams","getFirstToken","equalTokens","left","right","tokensL","getTokens","tokensR","length","i","LINEBREAK_MATCHER","SHEBANG_MATCHER","isTokenOnSameLine","loc","end","line","start","isNotClosingBraceToken","isNotClosingBracketToken","isNotClosingParenToken","isNotColonToken","isNotCommaToken","isNotDotToken","isNotOpeningBraceToken","isNotOpeningBracketToken","isNotOpeningParenToken","isNotSemicolonToken","isStringLiteral","isBreakableStatement","getModifyingReferences","filter","isSurroundedBy","val","character","isDirectiveComment","trim","indexOf","getTrailingStatement","ast","trailingStatement","getVariableByName","initScope","scope","variable","set","get","upper","isDefaultThisBinding","capIsConstructor","isAnonymous","func","body","arguments","getPrecedence","isEmptyBlock","isEmptyFunction","getStaticPropertyName","prop","key","String","expressions","quasis","cooked","getDirectivePrologue","directives","statements","statement","expression","push","isDecimalInteger","raw","isDecimalIntegerNumericToken","getFunctionNameWithKind","tokens","static","async","generator","kind","join","getFunctionHeadLoc","arrowToken","Object","assign","getNextLocation","location","getIndexFromLoc","text","getLocFromIndex","getParenthesisedText","leftToken","rightToken","getLastToken","getText","slice","couldBeError","exprs","consequent","alternate","regex","bigint","canTokensBeAdjacent","leftValue","rightValue","leftTokens","tokenize","ecmaVersion","PLUS_TOKENS","MINUS_TOKENS","has","startsWith","getNameLocationInGlobalDirectiveComment","namePattern","RegExp","escapeRegExp","lastIndex","match","exec","hasOctalEscapeSequence","rawString"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\nconst espree = require(\"espree\");\nconst lodash = require(\"lodash\");\nconst {\n    breakableTypePattern,\n    createGlobalLinebreakMatcher,\n    lineBreakPattern,\n    shebangPattern\n} = require(\"../../shared/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\n\n\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\n\nconst DECIMAL_INTEGER_PATTERN = /^(0|[1-9]\\d*)$/u;\nconst OCTAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\[^0-7]|\\\\0(?![0-9]))*\\\\(?:[1-7]|0[0-9])/u;\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference A reference to check.\n * @param {int} index The index of the reference in the references.\n * @param {Reference[]} references The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n * @param {string} s The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (anyFunctionPattern.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n    return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n    return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n        if (isLoop(currentNode)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        module.exports.isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    for (\n        let currentNode = node;\n        currentNode.type === \"MemberExpression\" && !currentNode.computed;\n        currentNode = currentNode.property\n    ) {\n        if (currentNode.property.type === \"Identifier\") {\n            return arrayMethodPattern.test(currentNode.property.name);\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n    return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node A node to check.\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a dot token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a dot token.\n */\nfunction isDotToken(token) {\n    return token.value === \".\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n    return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n * @param {ASTNode} node The function node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left A node 1 to compare.\n * @param {ASTNode} right A node 2 to compare.\n * @param {SourceCode} sourceCode The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    COMMENTS_IGNORE_PATTERN,\n    LINEBREAKS,\n    LINEBREAK_MATCHER: lineBreakPattern,\n    SHEBANG_MATCHER: shebangPattern,\n    STATEMENT_LIST_PARENTS,\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left The left token object.\n     * @param {Object} right The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop,\n    isArrayFromMethod,\n    isParenthesised,\n    createGlobalLinebreakMatcher,\n    equalTokens,\n\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isDotToken,\n    isKeywordToken,\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotDotToken: negate(isDotToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {Line|Block} node The comment token to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     * @param {eslint-scope.Scope} initScope A scope to start find.\n     * @param {string} name A variable name to find.\n     * @returns {eslint-scope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase. It's a convention to capitalize the names\n     *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\n     *   functions only, as the name of the variable is considered to be the name of the function in this case.\n     *   This check is not performed if `capIsConstructor` is set to `false`.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     * @param {ASTNode} node A function node to check.\n     * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n     * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\n     * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode, { capIsConstructor = true } = {}) {\n        if (\n            (capIsConstructor && isES5Constructor(node)) ||\n            hasJSDocThisTag(node, sourceCode)\n        ) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n        let currentNode = node;\n\n        while (currentNode) {\n            const parent = currentNode.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    currentNode = parent;\n                    break;\n\n                /*\n                 * If the upper function is IIFE, checks the destination of the return value.\n                 * e.g.\n                 *   obj.foo = (function() {\n                 *     // setup...\n                 *     return function foo() { ... };\n                 *   })();\n                 *   obj.foo = (() =>\n                 *     function foo() { ... }\n                 *   )();\n                 */\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    currentNode = func.parent;\n                    break;\n                }\n                case \"ArrowFunctionExpression\":\n                    if (currentNode !== parent.body || !isCallee(parent)) {\n                        return true;\n                    }\n                    currentNode = parent.parent;\n                    break;\n\n                /*\n                 * e.g.\n                 *   var obj = { foo() { ... } };\n                 *   var obj = { foo: function() { ... } };\n                 *   class A { constructor() { ... } }\n                 *   class A { foo() { ... } }\n                 *   class A { get foo() { ... } }\n                 *   class A { set foo() { ... } }\n                 *   class A { static foo() { ... } }\n                 */\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.value !== currentNode;\n\n                /*\n                 * e.g.\n                 *   obj.foo = function foo() { ... };\n                 *   Foo = function() { ... };\n                 *   [obj.foo = function foo() { ... }] = a;\n                 *   [Foo = function() { ... }] = a;\n                 */\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.left.type === \"MemberExpression\") {\n                        return false;\n                    }\n                    if (\n                        capIsConstructor &&\n                        isAnonymous &&\n                        parent.left.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.left.name)\n                    ) {\n                        return false;\n                    }\n                    return true;\n\n                /*\n                 * e.g.\n                 *   var Foo = function() { ... };\n                 */\n                case \"VariableDeclarator\":\n                    return !(\n                        capIsConstructor &&\n                        isAnonymous &&\n                        parent.init === currentNode &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                /*\n                 * e.g.\n                 *   var foo = function foo() { ... }.bind(obj);\n                 *   (function foo() { ... }).call(obj);\n                 *   (function foo() { ... }).apply(obj, []);\n                 */\n                case \"MemberExpression\":\n                    return (\n                        parent.object !== currentNode ||\n                        parent.property.type !== \"Identifier\" ||\n                        !bindOrCallOrApplyPattern.test(parent.property.name) ||\n                        !isCallee(parent) ||\n                        parent.parent.arguments.length === 0 ||\n                        isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                /*\n                 * e.g.\n                 *   Reflect.apply(function() {}, obj, []);\n                 *   Array.from([], function() {}, obj);\n                 *   list.forEach(function() {}, obj);\n                 */\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    case \"**\":\n                        return 15;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 16;\n\n            case \"UpdateExpression\":\n                return 17;\n\n            case \"CallExpression\":\n            case \"ImportExpression\":\n                return 18;\n\n            case \"NewExpression\":\n                return 19;\n\n            default:\n                return 20;\n        }\n    },\n\n    /**\n     * Checks whether the given node is an empty block node or not.\n     * @param {ASTNode|null} node The node to check.\n     * @returns {boolean} `true` if the node is an empty block.\n     */\n    isEmptyBlock(node) {\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    /**\n     * Checks whether the given node is an empty function node or not.\n     * @param {ASTNode|null} node The node to check.\n     * @returns {boolean} `true` if the node is an empty function.\n     */\n    isEmptyFunction(node) {\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    /**\n     * Gets the property name of a given node.\n     * The node can be a MemberExpression, a Property, or a MethodDefinition.\n     *\n     * If the name is dynamic, this returns `null`.\n     *\n     * For examples:\n     *\n     *     a.b           // => \"b\"\n     *     a[\"b\"]        // => \"b\"\n     *     a['b']        // => \"b\"\n     *     a[`b`]        // => \"b\"\n     *     a[100]        // => \"100\"\n     *     a[b]          // => null\n     *     a[\"a\" + \"b\"]  // => null\n     *     a[tag`b`]     // => null\n     *     a[`${b}`]     // => null\n     *\n     *     let a = {b: 1}            // => \"b\"\n     *     let a = {[\"b\"]: 1}        // => \"b\"\n     *     let a = {['b']: 1}        // => \"b\"\n     *     let a = {[`b`]: 1}        // => \"b\"\n     *     let a = {[100]: 1}        // => \"100\"\n     *     let a = {[b]: 1}          // => null\n     *     let a = {[\"a\" + \"b\"]: 1}  // => null\n     *     let a = {[tag`b`]: 1}     // => null\n     *     let a = {[`${b}`]: 1}     // => null\n     * @param {ASTNode} node The node to get.\n     * @returns {string|null} The property name if static. Otherwise, null.\n     */\n    getStaticPropertyName(node) {\n        let prop;\n\n        switch (node && node.type) {\n            case \"Property\":\n            case \"MethodDefinition\":\n                prop = node.key;\n                break;\n\n            case \"MemberExpression\":\n                prop = node.property;\n                break;\n\n            // no default\n        }\n\n        switch (prop && prop.type) {\n            case \"Literal\":\n                return String(prop.value);\n\n            case \"TemplateLiteral\":\n                if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n                    return prop.quasis[0].value.cooked;\n                }\n                break;\n\n            case \"Identifier\":\n                if (!node.computed) {\n                    return prop.name;\n                }\n                break;\n\n            // no default\n        }\n\n        return null;\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            /*\n             * Do not check arrow functions with implicit return.\n             * `() => \"use strict\";` returns the string `\"use strict\"`.\n             */\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     * after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 5       // true\n     * 5.      // false\n     * 5.0     // false\n     * 05      // false\n     * 0x5     // false\n     * 0b101   // false\n     * 0o5     // false\n     * 5e0     // false\n     * '5'     // false\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" &&\n            DECIMAL_INTEGER_PATTERN.test(node.raw);\n    },\n\n    /**\n     * Determines whether this token is a decimal integer numeric token.\n     * This is similar to isDecimalInteger(), but for tokens.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if this token is a decimal integer.\n     */\n    isDecimalIntegerNumericToken(token) {\n        return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n    },\n\n    /**\n     * Gets the name and kind of the given function node.\n     *\n     * - `function foo() {}`  .................... `function 'foo'`\n     * - `(function foo() {})`  .................. `function 'foo'`\n     * - `(function() {})`  ...................... `function`\n     * - `function* foo() {}`  ................... `generator function 'foo'`\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\n     * - `(function*() {})`  ..................... `generator function`\n     * - `() => {}`  ............................. `arrow function`\n     * - `async () => {}`  ....................... `async arrow function`\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n     * - `({ [foo]: function() {} })`  ........... `method`\n     * - `({ foo() {} })`  ....................... `method 'foo'`\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n     * - `({ [foo]: async function() {} })`  ..... `async method`\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n     * - `class A { constructor() {} }`  ......... `constructor`\n     * - `class A { foo() {} }`  ................. `method 'foo'`\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n     * - `class A { [foo]() {} }`  ............... `method`\n     * - `class A { *[foo]() {} }`  .............. `generator method`\n     * - `class A { async [foo]() {} }`  ......... `async method`\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n     * @param {ASTNode} node The function node to get.\n     * @returns {string} The name and kind of the function node.\n     */\n    getFunctionNameWithKind(node) {\n        const parent = node.parent;\n        const tokens = [];\n\n        if (parent.type === \"MethodDefinition\" && parent.static) {\n            tokens.push(\"static\");\n        }\n        if (node.async) {\n            tokens.push(\"async\");\n        }\n        if (node.generator) {\n            tokens.push(\"generator\");\n        }\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            tokens.push(\"arrow\", \"function\");\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            if (parent.kind === \"constructor\") {\n                return \"constructor\";\n            }\n            if (parent.kind === \"get\") {\n                tokens.push(\"getter\");\n            } else if (parent.kind === \"set\") {\n                tokens.push(\"setter\");\n            } else {\n                tokens.push(\"method\");\n            }\n        } else {\n            tokens.push(\"function\");\n        }\n\n        if (node.id) {\n            tokens.push(`'${node.id.name}'`);\n        } else {\n            const name = module.exports.getStaticPropertyName(parent);\n\n            if (name !== null) {\n                tokens.push(`'${name}'`);\n            }\n        }\n\n        return tokens.join(\" \");\n    },\n\n    /**\n     * Gets the location of the given function node for reporting.\n     *\n     * - `function foo() {}`\n     *    ^^^^^^^^^^^^\n     * - `(function foo() {})`\n     *     ^^^^^^^^^^^^\n     * - `(function() {})`\n     *     ^^^^^^^^\n     * - `function* foo() {}`\n     *    ^^^^^^^^^^^^^\n     * - `(function* foo() {})`\n     *     ^^^^^^^^^^^^^\n     * - `(function*() {})`\n     *     ^^^^^^^^^\n     * - `() => {}`\n     *       ^^\n     * - `async () => {}`\n     *             ^^\n     * - `({ foo: function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ foo: function() {} })`\n     *       ^^^^^^^^^^^^^\n     * - `({ ['foo']: function() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function() {} })`\n     *       ^^^^^^^^^^^^^^^\n     * - `({ foo() {} })`\n     *       ^^^\n     * - `({ foo: function* foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ foo: function*() {} })`\n     *       ^^^^^^^^^^^^^^\n     * - `({ ['foo']: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^\n     * - `({ *foo() {} })`\n     *       ^^^^\n     * - `({ foo: async function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ foo: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^\n     * - `({ ['foo']: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^\n     * - `({ async foo() {} })`\n     *       ^^^^^^^^^\n     * - `({ get foo() {} })`\n     *       ^^^^^^^\n     * - `({ set foo(a) {} })`\n     *       ^^^^^^^\n     * - `class A { constructor() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { foo() {} }`\n     *              ^^^\n     * - `class A { *foo() {} }`\n     *              ^^^^\n     * - `class A { async foo() {} }`\n     *              ^^^^^^^^^\n     * - `class A { ['foo']() {} }`\n     *              ^^^^^^^\n     * - `class A { *['foo']() {} }`\n     *              ^^^^^^^^\n     * - `class A { async ['foo']() {} }`\n     *              ^^^^^^^^^^^^^\n     * - `class A { [foo]() {} }`\n     *              ^^^^^\n     * - `class A { *[foo]() {} }`\n     *              ^^^^^^\n     * - `class A { async [foo]() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { get foo() {} }`\n     *              ^^^^^^^\n     * - `class A { set foo(a) {} }`\n     *              ^^^^^^^\n     * - `class A { static foo() {} }`\n     *              ^^^^^^^^^^\n     * - `class A { static *foo() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { static async foo() {} }`\n     *              ^^^^^^^^^^^^^^^^\n     * - `class A { static get foo() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static set foo(a) {} }`\n     *              ^^^^^^^^^^^^^^\n     * @param {ASTNode} node The function node to get.\n     * @param {SourceCode} sourceCode The source code object to get tokens.\n     * @returns {string} The location of the function node for reporting.\n     */\n    getFunctionHeadLoc(node, sourceCode) {\n        const parent = node.parent;\n        let start = null;\n        let end = null;\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n            start = arrowToken.loc.start;\n            end = arrowToken.loc.end;\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            start = parent.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        } else {\n            start = node.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        }\n\n        return {\n            start: Object.assign({}, start),\n            end: Object.assign({}, end)\n        };\n    },\n\n    /**\n     * Gets next location when the result is not out of bound, otherwise returns null.\n     * @param {SourceCode} sourceCode The sourceCode\n     * @param {{line: number, column: number}} location The location\n     * @returns {{line: number, column: number} | null} Next location\n     */\n    getNextLocation(sourceCode, location) {\n        const index = sourceCode.getIndexFromLoc(location);\n\n        // Avoid out of bound location\n        if (index + 1 > sourceCode.text.length) {\n            return null;\n        }\n\n        return sourceCode.getLocFromIndex(index + 1);\n    },\n\n    /**\n     * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n     * surrounding the node.\n     * @param {SourceCode} sourceCode The source code object\n     * @param {ASTNode} node An expression node\n     * @returns {string} The text representing the node, with all surrounding parentheses included\n     */\n    getParenthesisedText(sourceCode, node) {\n        let leftToken = sourceCode.getFirstToken(node);\n        let rightToken = sourceCode.getLastToken(node);\n\n        while (\n            sourceCode.getTokenBefore(leftToken) &&\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\n            sourceCode.getTokenAfter(rightToken) &&\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\n            sourceCode.getTokenAfter(rightToken).value === \")\"\n        ) {\n            leftToken = sourceCode.getTokenBefore(leftToken);\n            rightToken = sourceCode.getTokenAfter(rightToken);\n        }\n\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    /*\n     * Determine if a node has a possiblity to be an Error object\n     * @param  {ASTNode} node  ASTNode to check\n     * @returns {boolean} True if there is a chance it contains an Error obj\n     */\n    couldBeError(node) {\n        switch (node.type) {\n            case \"Identifier\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"YieldExpression\":\n            case \"AwaitExpression\":\n                return true; // possibly an error object.\n\n            case \"AssignmentExpression\":\n                return module.exports.couldBeError(node.right);\n\n            case \"SequenceExpression\": {\n                const exprs = node.expressions;\n\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n            }\n\n            case \"LogicalExpression\":\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n            case \"ConditionalExpression\":\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n            default:\n                return false;\n        }\n    },\n\n    /**\n     * Determines whether the given node is a `null` literal.\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a `null` literal\n     */\n    isNullLiteral(node) {\n\n        /*\n         * Checking `node.value === null` does not guarantee that a literal is a null literal.\n         * When parsing values that cannot be represented in the current environment (e.g. unicode\n         * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n         * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n         * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n         */\n        return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n    },\n\n    /**\n     * Determines whether two tokens can safely be placed next to each other without merging into a single token\n     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\n     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\n     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\n     * next to each other, behavior is undefined (although it should return `true` in most cases).\n     */\n    canTokensBeAdjacent(leftValue, rightValue) {\n        let leftToken;\n\n        if (typeof leftValue === \"string\") {\n            const leftTokens = espree.tokenize(leftValue, { ecmaVersion: 2015 });\n\n            leftToken = leftTokens[leftTokens.length - 1];\n        } else {\n            leftToken = leftValue;\n        }\n\n        const rightToken = typeof rightValue === \"string\" ? espree.tokenize(rightValue, { ecmaVersion: 2015 })[0] : rightValue;\n\n        if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n            if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n                const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n                const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n\n                return !(\n                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||\n                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)\n                );\n            }\n            return true;\n        }\n\n        if (\n            leftToken.type === \"String\" || rightToken.type === \"String\" ||\n            leftToken.type === \"Template\" || rightToken.type === \"Template\"\n        ) {\n            return true;\n        }\n\n        if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Get the `loc` object of a given name in a `/*globals` directive comment.\n     * @param {SourceCode} sourceCode The source code to convert index to loc.\n     * @param {Comment} comment The `/*globals` directive comment which include the name.\n     * @param {string} name The name to find.\n     * @returns {SourceLocation} The `loc` object.\n     */\n    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n        const namePattern = new RegExp(`[\\\\s,]${lodash.escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\");\n\n        // To ignore the first text \"global\".\n        namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n        // Search a given variable name.\n        const match = namePattern.exec(comment.value);\n\n        // Convert the index to loc.\n        return sourceCode.getLocFromIndex(\n            comment.range[0] +\n            \"/*\".length +\n            (match ? match.index + 1 : 0)\n        );\n    },\n\n    /**\n     * Determines whether the given raw string contains an octal escape sequence.\n     *\n     * \"\\1\", \"\\2\" ... \"\\7\"\n     * \"\\00\", \"\\01\" ... \"\\09\"\n     *\n     * \"\\0\", when not followed by a digit, is not an octal escape sequence.\n     * @param {string} rawString A string in its raw representation.\n     * @returns {boolean} `true` if the string contains at least one octal escape sequence.\n     */\n    hasOctalEscapeSequence(rawString) {\n        return OCTAL_ESCAPE_PATTERN.test(rawString);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}