{"ast":null,"code":"/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\n\n\nfunction isCommutativeOperatorWithShorthand(operator) {\n  return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\n\n\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n  return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\n\n\nfunction same(a, b) {\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  switch (a.type) {\n    case \"Identifier\":\n      return a.name === b.name;\n\n    case \"Literal\":\n      return a.value === b.value;\n\n    case \"MemberExpression\":\n      /*\n       * x[0] = x[0]\n       * x[y] = x[y]\n       * x.y = x.y\n       */\n      return same(a.object, b.object) && same(a.property, b.property);\n\n    case \"ThisExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\n\n\nfunction canBeFixed(node) {\n  return node.type === \"Identifier\" || node.type === \"MemberExpression\" && (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") && (!node.computed || node.property.type === \"Literal\");\n}\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow assignment operator shorthand where possible\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-assignment\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      replaced: \"Assignment can be replaced with operator assignment.\",\n      unexpected: \"Unexpected operator assignment shorthand.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Returns the operator token of an AssignmentExpression or BinaryExpression\n     * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n     * @returns {Token} The operator token in the node\n     */\n\n    function getOperatorToken(node) {\n      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n    }\n    /**\n     * Ensures that an assignment uses the shorthand form where possible.\n     * @param   {ASTNode} node An AssignmentExpression node.\n     * @returns {void}\n     */\n\n\n    function verify(node) {\n      if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n        return;\n      }\n\n      const left = node.left;\n      const expr = node.right;\n      const operator = expr.operator;\n\n      if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n        if (same(left, expr.left)) {\n          context.report({\n            node,\n            messageId: \"replaced\",\n\n            fix(fixer) {\n              if (canBeFixed(left)) {\n                const equalsToken = getOperatorToken(node);\n                const operatorToken = getOperatorToken(expr);\n                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]); // Check for comments that would be removed.\n\n                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n              }\n\n              return null;\n            }\n\n          });\n        } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {\n          /*\n           * This case can't be fixed safely.\n           * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n           * change the execution order of the valueOf() functions.\n           */\n          context.report({\n            node,\n            messageId: \"replaced\"\n          });\n        }\n      }\n    }\n    /**\n     * Warns if an assignment expression uses operator assignment shorthand.\n     * @param   {ASTNode} node An AssignmentExpression node.\n     * @returns {void}\n     */\n\n\n    function prohibit(node) {\n      if (node.operator !== \"=\") {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            if (canBeFixed(node.left)) {\n              const firstToken = sourceCode.getFirstToken(node);\n              const operatorToken = getOperatorToken(node);\n              const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n              const newOperator = node.operator.slice(0, -1);\n              let rightText; // Check for comments that would be duplicated.\n\n              if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                return null;\n              } // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n\n\n              if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({\n                type: \"BinaryExpression\",\n                operator: newOperator\n              }) && !astUtils.isParenthesised(sourceCode, node.right)) {\n                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n              } else {\n                const firstRightToken = sourceCode.getFirstToken(node.right);\n                let rightTextPrefix = \"\";\n\n                if (operatorToken.range[1] === firstRightToken.range[0] && !astUtils.canTokensBeAdjacent(newOperator, firstRightToken)) {\n                  rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                }\n\n                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n              }\n\n              return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n            }\n\n            return null;\n          }\n\n        });\n      }\n    }\n\n    return {\n      AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/operator-assignment.js"],"names":["astUtils","require","isCommutativeOperatorWithShorthand","operator","indexOf","isNonCommutativeOperatorWithShorthand","same","a","b","type","name","value","object","property","canBeFixed","node","computed","module","exports","meta","docs","description","category","recommended","url","schema","enum","fixable","messages","replaced","unexpected","create","context","sourceCode","getSourceCode","getOperatorToken","getFirstTokenBetween","left","right","token","verify","expr","report","messageId","fix","fixer","equalsToken","operatorToken","leftText","getText","slice","range","rightText","commentsExistBetween","replaceText","prohibit","firstToken","getFirstToken","newOperator","getPrecedence","isParenthesised","text","firstRightToken","rightTextPrefix","canTokensBeAdjacent","AssignmentExpression","options"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;;;;;;;;;AAOA,SAASC,kCAAT,CAA4CC,QAA5C,EAAsD;AAClD,SAAO,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqBC,OAArB,CAA6BD,QAA7B,KAA0C,CAAjD;AACH;AAED;;;;;;;;;AAOA,SAASE,qCAAT,CAA+CF,QAA/C,EAAyD;AACrD,SAAO,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,IAArB,EAA2B,IAA3B,EAAiC,KAAjC,EAAwC,IAAxC,EAA8CC,OAA9C,CAAsDD,QAAtD,KAAmE,CAA1E;AACH,C,CAED;AACA;AACA;;AAEA;;;;;;;;;;;;AAUA,SAASG,IAAT,CAAcC,CAAd,EAAiBC,CAAjB,EAAoB;AAChB,MAAID,CAAC,CAACE,IAAF,KAAWD,CAAC,CAACC,IAAjB,EAAuB;AACnB,WAAO,KAAP;AACH;;AAED,UAAQF,CAAC,CAACE,IAAV;AACI,SAAK,YAAL;AACI,aAAOF,CAAC,CAACG,IAAF,KAAWF,CAAC,CAACE,IAApB;;AAEJ,SAAK,SAAL;AACI,aAAOH,CAAC,CAACI,KAAF,KAAYH,CAAC,CAACG,KAArB;;AAEJ,SAAK,kBAAL;AAEI;;;;;AAKA,aAAOL,IAAI,CAACC,CAAC,CAACK,MAAH,EAAWJ,CAAC,CAACI,MAAb,CAAJ,IAA4BN,IAAI,CAACC,CAAC,CAACM,QAAH,EAAaL,CAAC,CAACK,QAAf,CAAvC;;AAEJ,SAAK,gBAAL;AACI,aAAO,IAAP;;AAEJ;AACI,aAAO,KAAP;AApBR;AAsBH;AAED;;;;;;;;AAMA,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtB,SACIA,IAAI,CAACN,IAAL,KAAc,YAAd,IAEIM,IAAI,CAACN,IAAL,KAAc,kBAAd,KACCM,IAAI,CAACH,MAAL,CAAYH,IAAZ,KAAqB,YAArB,IAAqCM,IAAI,CAACH,MAAL,CAAYH,IAAZ,KAAqB,gBAD3D,MAEC,CAACM,IAAI,CAACC,QAAN,IAAkBD,IAAI,CAACF,QAAL,CAAcJ,IAAd,KAAuB,SAF1C,CAHR;AAQH;;AAEDQ,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFV,IAAAA,IAAI,EAAE,YADJ;AAGFW,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,kEADX;AAEFC,MAAAA,QAAQ,EAAE,kBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;AADV,KADI,CAVN;AAgBFC,IAAAA,OAAO,EAAE,MAhBP;AAiBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,EAAE,sDADJ;AAENC,MAAAA,UAAU,EAAE;AAFN;AAjBR,GADO;;AAwBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AAEA;;;;;;AAKA,aAASC,gBAAT,CAA0BpB,IAA1B,EAAgC;AAC5B,aAAOkB,UAAU,CAACG,oBAAX,CAAgCrB,IAAI,CAACsB,IAArC,EAA2CtB,IAAI,CAACuB,KAAhD,EAAuDC,KAAK,IAAIA,KAAK,CAAC5B,KAAN,KAAgBI,IAAI,CAACZ,QAArF,CAAP;AACH;AAED;;;;;;;AAKA,aAASqC,MAAT,CAAgBzB,IAAhB,EAAsB;AAClB,UAAIA,IAAI,CAACZ,QAAL,KAAkB,GAAlB,IAAyBY,IAAI,CAACuB,KAAL,CAAW7B,IAAX,KAAoB,kBAAjD,EAAqE;AACjE;AACH;;AAED,YAAM4B,IAAI,GAAGtB,IAAI,CAACsB,IAAlB;AACA,YAAMI,IAAI,GAAG1B,IAAI,CAACuB,KAAlB;AACA,YAAMnC,QAAQ,GAAGsC,IAAI,CAACtC,QAAtB;;AAEA,UAAID,kCAAkC,CAACC,QAAD,CAAlC,IAAgDE,qCAAqC,CAACF,QAAD,CAAzF,EAAqG;AACjG,YAAIG,IAAI,CAAC+B,IAAD,EAAOI,IAAI,CAACJ,IAAZ,CAAR,EAA2B;AACvBL,UAAAA,OAAO,CAACU,MAAR,CAAe;AACX3B,YAAAA,IADW;AAEX4B,YAAAA,SAAS,EAAE,UAFA;;AAGXC,YAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,kBAAI/B,UAAU,CAACuB,IAAD,CAAd,EAAsB;AAClB,sBAAMS,WAAW,GAAGX,gBAAgB,CAACpB,IAAD,CAApC;AACA,sBAAMgC,aAAa,GAAGZ,gBAAgB,CAACM,IAAD,CAAtC;AACA,sBAAMO,QAAQ,GAAGf,UAAU,CAACgB,OAAX,GAAqBC,KAArB,CAA2BnC,IAAI,CAACoC,KAAL,CAAW,CAAX,CAA3B,EAA0CL,WAAW,CAACK,KAAZ,CAAkB,CAAlB,CAA1C,CAAjB;AACA,sBAAMC,SAAS,GAAGnB,UAAU,CAACgB,OAAX,GAAqBC,KAArB,CAA2BH,aAAa,CAACI,KAAd,CAAoB,CAApB,CAA3B,EAAmDpC,IAAI,CAACuB,KAAL,CAAWa,KAAX,CAAiB,CAAjB,CAAnD,CAAlB,CAJkB,CAMlB;;AACA,oBAAIlB,UAAU,CAACoB,oBAAX,CAAgCP,WAAhC,EAA6CC,aAA7C,CAAJ,EAAiE;AAC7D,yBAAO,IAAP;AACH;;AAED,uBAAOF,KAAK,CAACS,WAAN,CAAkBvC,IAAlB,EAAyB,GAAEiC,QAAS,GAAEP,IAAI,CAACtC,QAAS,IAAGiD,SAAU,EAAjE,CAAP;AACH;;AACD,qBAAO,IAAP;AACH;;AAlBU,WAAf;AAoBH,SArBD,MAqBO,IAAI9C,IAAI,CAAC+B,IAAD,EAAOI,IAAI,CAACH,KAAZ,CAAJ,IAA0BpC,kCAAkC,CAACC,QAAD,CAAhE,EAA4E;AAE/E;;;;;AAKA6B,UAAAA,OAAO,CAACU,MAAR,CAAe;AACX3B,YAAAA,IADW;AAEX4B,YAAAA,SAAS,EAAE;AAFA,WAAf;AAIH;AACJ;AACJ;AAED;;;;;;;AAKA,aAASY,QAAT,CAAkBxC,IAAlB,EAAwB;AACpB,UAAIA,IAAI,CAACZ,QAAL,KAAkB,GAAtB,EAA2B;AACvB6B,QAAAA,OAAO,CAACU,MAAR,CAAe;AACX3B,UAAAA,IADW;AAEX4B,UAAAA,SAAS,EAAE,YAFA;;AAGXC,UAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,gBAAI/B,UAAU,CAACC,IAAI,CAACsB,IAAN,CAAd,EAA2B;AACvB,oBAAMmB,UAAU,GAAGvB,UAAU,CAACwB,aAAX,CAAyB1C,IAAzB,CAAnB;AACA,oBAAMgC,aAAa,GAAGZ,gBAAgB,CAACpB,IAAD,CAAtC;AACA,oBAAMiC,QAAQ,GAAGf,UAAU,CAACgB,OAAX,GAAqBC,KAArB,CAA2BnC,IAAI,CAACoC,KAAL,CAAW,CAAX,CAA3B,EAA0CJ,aAAa,CAACI,KAAd,CAAoB,CAApB,CAA1C,CAAjB;AACA,oBAAMO,WAAW,GAAG3C,IAAI,CAACZ,QAAL,CAAc+C,KAAd,CAAoB,CAApB,EAAuB,CAAC,CAAxB,CAApB;AACA,kBAAIE,SAAJ,CALuB,CAOvB;;AACA,kBAAInB,UAAU,CAACoB,oBAAX,CAAgCG,UAAhC,EAA4CT,aAA5C,CAAJ,EAAgE;AAC5D,uBAAO,IAAP;AACH,eAVsB,CAYvB;;;AACA,kBACI/C,QAAQ,CAAC2D,aAAT,CAAuB5C,IAAI,CAACuB,KAA5B,KAAsCtC,QAAQ,CAAC2D,aAAT,CAAuB;AAAElD,gBAAAA,IAAI,EAAE,kBAAR;AAA4BN,gBAAAA,QAAQ,EAAEuD;AAAtC,eAAvB,CAAtC,IACA,CAAC1D,QAAQ,CAAC4D,eAAT,CAAyB3B,UAAzB,EAAqClB,IAAI,CAACuB,KAA1C,CAFL,EAGE;AACEc,gBAAAA,SAAS,GAAI,GAAEnB,UAAU,CAAC4B,IAAX,CAAgBX,KAAhB,CAAsBH,aAAa,CAACI,KAAd,CAAoB,CAApB,CAAtB,EAA8CpC,IAAI,CAACuB,KAAL,CAAWa,KAAX,CAAiB,CAAjB,CAA9C,CAAmE,IAAGlB,UAAU,CAACgB,OAAX,CAAmBlC,IAAI,CAACuB,KAAxB,CAA+B,GAApH;AACH,eALD,MAKO;AACH,sBAAMwB,eAAe,GAAG7B,UAAU,CAACwB,aAAX,CAAyB1C,IAAI,CAACuB,KAA9B,CAAxB;AACA,oBAAIyB,eAAe,GAAG,EAAtB;;AAEA,oBACIhB,aAAa,CAACI,KAAd,CAAoB,CAApB,MAA2BW,eAAe,CAACX,KAAhB,CAAsB,CAAtB,CAA3B,IACA,CAACnD,QAAQ,CAACgE,mBAAT,CAA6BN,WAA7B,EAA0CI,eAA1C,CAFL,EAGE;AACEC,kBAAAA,eAAe,GAAG,GAAlB,CADF,CACyB;AAC1B;;AAEDX,gBAAAA,SAAS,GAAI,GAAEW,eAAgB,GAAE9B,UAAU,CAAC4B,IAAX,CAAgBX,KAAhB,CAAsBH,aAAa,CAACI,KAAd,CAAoB,CAApB,CAAtB,EAA8CpC,IAAI,CAACoC,KAAL,CAAW,CAAX,CAA9C,CAA6D,EAA9F;AACH;;AAED,qBAAON,KAAK,CAACS,WAAN,CAAkBvC,IAAlB,EAAyB,GAAEiC,QAAS,KAAIA,QAAS,GAAEU,WAAY,GAAEN,SAAU,EAA3E,CAAP;AACH;;AACD,mBAAO,IAAP;AACH;;AAvCU,SAAf;AAyCH;AACJ;;AAED,WAAO;AACHa,MAAAA,oBAAoB,EAAEjC,OAAO,CAACkC,OAAR,CAAgB,CAAhB,MAAuB,OAAvB,GAAiC1B,MAAjC,GAA0Ce;AAD7D,KAAP;AAIH;;AA/IY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\":\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return same(a.object, b.object) && same(a.property, b.property);\n\n        case \"ThisExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\nfunction canBeFixed(node) {\n    return (\n        node.type === \"Identifier\" ||\n        (\n            node.type === \"MemberExpression\" &&\n            (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") &&\n            (!node.computed || node.property.type === \"Literal\")\n        )\n    );\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow assignment operator shorthand where possible\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-assignment\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            replaced: \"Assignment can be replaced with operator assignment.\",\n            unexpected: \"Unexpected operator assignment shorthand.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the operator token of an AssignmentExpression or BinaryExpression\n         * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n         * @returns {Token} The operator token in the node\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                if (same(left, expr.left)) {\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        fix(fixer) {\n                            if (canBeFixed(left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                // Check for comments that would be removed.\n                                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        messageId: \"replaced\"\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\") {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const firstToken = sourceCode.getFirstToken(node);\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // Check for comments that would be duplicated.\n                            if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                                return null;\n                            }\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                const firstRightToken = sourceCode.getFirstToken(node.right);\n                                let rightTextPrefix = \"\";\n\n                                if (\n                                    operatorToken.range[1] === firstRightToken.range[0] &&\n                                    !astUtils.canTokensBeAdjacent(newOperator, firstRightToken)\n                                ) {\n                                    rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                                }\n\n                                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}