{"ast":null,"code":"'use strict';\n\nconst tape = require('tape'),\n      child_process = require('child_process'),\n      workerFarm = require('../'),\n      childPath = require.resolve('./child'),\n      fs = require('fs'),\n      os = require('os');\n\nfunction uniq(ar) {\n  let a = [],\n      i,\n      j;\n\n  o: for (i = 0; i < ar.length; ++i) {\n    for (j = 0; j < a.length; ++j) if (a[j] == ar[i]) continue o;\n\n    a[a.length] = ar[i];\n  }\n\n  return a;\n} // a child where module.exports = function ...\n\n\ntape('simple, exports=function test', function (t) {\n  t.plan(4);\n  let child = workerFarm(childPath);\n  child(0, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense');\n    t.ok(pid < process.pid + 750, 'pid makes sense');\n    t.ok(rnd >= 0 && rnd < 1, 'rnd result makes sense');\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n}); // a child where we have module.exports.fn = function ...\n\ntape('simple, exports.fn test', function (t) {\n  t.plan(4);\n  let child = workerFarm(childPath, ['run0']);\n  child.run0(function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense');\n    t.ok(pid < process.pid + 750, 'pid makes sense');\n    t.ok(rnd >= 0 && rnd < 1, 'rnd result makes sense');\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('on child', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    onChild: function (subprocess) {\n      childPid = subprocess.pid;\n    }\n  }, childPath),\n      childPid = null;\n  child(0, function (err, pid) {\n    t.equal(childPid, pid);\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n}); // use the returned pids to check that we're using a single child process\n// when maxConcurrentWorkers = 1\n\ntape('single worker', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 1\n  }, childPath),\n      pids = [],\n      i = 10;\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid);\n\n      if (pids.length == 10) {\n        t.equal(1, uniq(pids).length, 'only a single process (by pid)');\n      } else if (pids.length > 10) t.fail('too many callbacks!');\n    });\n  }\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n}); // use the returned pids to check that we're using two child processes\n// when maxConcurrentWorkers = 2\n\ntape('two workers', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 2\n  }, childPath),\n      pids = [],\n      i = 10;\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid);\n\n      if (pids.length == 10) {\n        t.equal(2, uniq(pids).length, 'only two child processes (by pid)');\n      } else if (pids.length > 10) t.fail('too many callbacks!');\n    });\n  }\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n}); // use the returned pids to check that we're using a child process per\n// call when maxConcurrentWorkers = 10\n\ntape('many workers', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 10\n  }, childPath),\n      pids = [],\n      i = 10;\n\n  while (i--) {\n    child(1, function (err, pid) {\n      pids.push(pid);\n\n      if (pids.length == 10) {\n        t.equal(10, uniq(pids).length, 'pids are all the same (by pid)');\n      } else if (pids.length > 10) t.fail('too many callbacks!');\n    });\n  }\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('auto start workers', function (t) {\n  let child = workerFarm({\n    maxConcurrentWorkers: 3,\n    autoStart: true\n  }, childPath, ['uptime']),\n      pids = [],\n      count = 5,\n      i = count,\n      delay = 250;\n  t.plan(count + 1);\n  setTimeout(function () {\n    while (i--) child.uptime(function (err, uptime) {\n      t.ok(uptime > 10, 'child has been up before the request (' + uptime + 'ms)');\n    });\n\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended');\n    });\n  }, delay);\n}); // use the returned pids to check that we're using a child process per\n// call when we set maxCallsPerWorker = 1 even when we have maxConcurrentWorkers = 1\n\ntape('single call per worker', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxConcurrentCallsPerWorker: Infinity,\n    maxCallsPerWorker: 1,\n    autoStart: true\n  }, childPath),\n      pids = [],\n      count = 25,\n      i = count;\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid);\n\n      if (pids.length == count) {\n        t.equal(count, uniq(pids).length, 'one process for each call (by pid)');\n        workerFarm.end(child, function () {\n          t.ok(true, 'workerFarm ended');\n        });\n      } else if (pids.length > count) t.fail('too many callbacks!');\n    });\n  }\n}); // use the returned pids to check that we're using a child process per\n// two-calls when we set maxCallsPerWorker = 2 even when we have maxConcurrentWorkers = 1\n\ntape('two calls per worker', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxConcurrentCallsPerWorker: Infinity,\n    maxCallsPerWorker: 2,\n    autoStart: true\n  }, childPath),\n      pids = [],\n      count = 20,\n      i = count;\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid);\n\n      if (pids.length == count) {\n        t.equal(count / 2, uniq(pids).length, 'one process for each call (by pid)');\n        workerFarm.end(child, function () {\n          t.ok(true, 'workerFarm ended');\n        });\n      } else if (pids.length > count) t.fail('too many callbacks!');\n    });\n  }\n}); // use timing to confirm that one worker will process calls sequentially\n\ntape('many concurrent calls', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxConcurrentCallsPerWorker: Infinity,\n    maxCallsPerWorker: Infinity,\n    autoStart: true\n  }, childPath),\n      defer = 200,\n      count = 200,\n      i = count,\n      cbc = 0;\n  setTimeout(function () {\n    let start = Date.now();\n\n    while (i--) {\n      child(defer, function () {\n        if (++cbc == count) {\n          let time = Date.now() - start; // upper-limit not tied to `count` at all\n\n          t.ok(time > defer && time < defer * 2.5, 'processed tasks concurrently (' + time + 'ms)');\n          workerFarm.end(child, function () {\n            t.ok(true, 'workerFarm ended');\n          });\n        } else if (cbc > count) t.fail('too many callbacks!');\n      });\n    }\n  }, 250);\n}); // use timing to confirm that one child processes calls sequentially with\n// maxConcurrentCallsPerWorker = 1\n\ntape('single concurrent call', function (t) {\n  t.plan(2);\n  let child = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxConcurrentCallsPerWorker: 1,\n    maxCallsPerWorker: Infinity,\n    autoStart: true\n  }, childPath),\n      defer = 20,\n      count = 100,\n      i = count,\n      cbc = 0;\n  setTimeout(function () {\n    let start = Date.now();\n\n    while (i--) {\n      child(defer, function () {\n        if (++cbc == count) {\n          let time = Date.now() - start; // upper-limit tied closely to `count`, 1.3 is generous but accounts for all the timers\n          // coming back at the same time and the IPC overhead\n\n          t.ok(time > defer * count && time < defer * count * 1.3, 'processed tasks sequentially (' + time + ')');\n          workerFarm.end(child, function () {\n            t.ok(true, 'workerFarm ended');\n          });\n        } else if (cbc > count) t.fail('too many callbacks!');\n      });\n    }\n  }, 250);\n}); // use timing to confirm that one child processes *only* 5 calls concurrently\n\ntape('multiple concurrent calls', function (t) {\n  t.plan(2);\n  let callsPerWorker = 5,\n      child = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxConcurrentCallsPerWorker: callsPerWorker,\n    maxCallsPerWorker: Infinity,\n    autoStart: true\n  }, childPath),\n      defer = 100,\n      count = 100,\n      i = count,\n      cbc = 0;\n  setTimeout(function () {\n    let start = Date.now();\n\n    while (i--) {\n      child(defer, function () {\n        if (++cbc == count) {\n          let time = Date.now() - start;\n          let min = defer * 1.5; // (defer * (count / callsPerWorker + 2)) - if precise it'd be count/callsPerWorker\n          // but accounting for IPC and other overhead, we need to give it a bit of extra time,\n          // hence the +2\n\n          let max = defer * (count / callsPerWorker + 2);\n          t.ok(time > min && time < max, 'processed tasks concurrently (' + time + ' > ' + min + ' && ' + time + ' < ' + max + ')');\n          workerFarm.end(child, function () {\n            t.ok(true, 'workerFarm ended');\n          });\n        } else if (cbc > count) t.fail('too many callbacks!');\n      });\n    }\n  }, 250);\n}); // call a method that will die with a probability of 0.5 but expect that\n// we'll get results for each of our calls anyway\n\ntape('durability', function (t) {\n  t.plan(3);\n  let child = workerFarm({\n    maxConcurrentWorkers: 2\n  }, childPath, ['killable']),\n      ids = [],\n      pids = [],\n      count = 20,\n      i = count;\n\n  while (i--) {\n    child.killable(i, function (err, id, pid) {\n      ids.push(id);\n      pids.push(pid);\n\n      if (ids.length == count) {\n        t.ok(uniq(pids).length > 2, 'processed by many (' + uniq(pids).length + ') workers, but got there in the end!');\n        t.ok(uniq(ids).length == count, 'received a single result for each unique call');\n        workerFarm.end(child, function () {\n          t.ok(true, 'workerFarm ended');\n        });\n      } else if (ids.length > count) t.fail('too many callbacks!');\n    });\n  }\n}); // a callback provided to .end() can and will be called (uses \"simple, exports=function test\" to create a child)\n\ntape('simple, end callback', function (t) {\n  t.plan(4);\n  let child = workerFarm(childPath);\n  child(0, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid);\n    t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid);\n    t.ok(rnd >= 0 && rnd < 1, 'rnd result makes sense');\n  });\n  workerFarm.end(child, function () {\n    t.pass('an .end() callback was successfully called');\n  });\n});\ntape('call timeout test', function (t) {\n  t.plan(3 + 3 + 4 + 4 + 4 + 3 + 1);\n  let child = workerFarm({\n    maxCallTime: 250,\n    maxConcurrentWorkers: 1\n  }, childPath); // should come back ok\n\n  child(50, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid);\n    t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid);\n    t.ok(rnd > 0 && rnd < 1, 'rnd result makes sense ' + rnd);\n  }); // should come back ok\n\n  child(50, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid);\n    t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid);\n    t.ok(rnd > 0 && rnd < 1, 'rnd result makes sense ' + rnd);\n  }); // should die\n\n  child(500, function (err, pid, rnd) {\n    t.ok(err, 'got an error');\n    t.equal(err.type, 'TimeoutError', 'correct error type');\n    t.ok(pid === undefined, 'no pid');\n    t.ok(rnd === undefined, 'no rnd');\n  }); // should die\n\n  child(1000, function (err, pid, rnd) {\n    t.ok(err, 'got an error');\n    t.equal(err.type, 'TimeoutError', 'correct error type');\n    t.ok(pid === undefined, 'no pid');\n    t.ok(rnd === undefined, 'no rnd');\n  }); // should die even though it is only a 100ms task, it'll get caught up\n  // in a dying worker\n\n  setTimeout(function () {\n    child(100, function (err, pid, rnd) {\n      t.ok(err, 'got an error');\n      t.equal(err.type, 'TimeoutError', 'correct error type');\n      t.ok(pid === undefined, 'no pid');\n      t.ok(rnd === undefined, 'no rnd');\n    });\n  }, 200); // should be ok, new worker\n\n  setTimeout(function () {\n    child(50, function (err, pid, rnd) {\n      t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid);\n      t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid);\n      t.ok(rnd > 0 && rnd < 1, 'rnd result makes sense ' + rnd);\n    });\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended');\n    });\n  }, 400);\n});\ntape('test error passing', function (t) {\n  t.plan(10);\n  let child = workerFarm(childPath, ['err']);\n  child.err('Error', 'this is an Error', function (err) {\n    t.ok(err instanceof Error, 'is an Error object');\n    t.equal('Error', err.type, 'correct type');\n    t.equal('this is an Error', err.message, 'correct message');\n  });\n  child.err('TypeError', 'this is a TypeError', function (err) {\n    t.ok(err instanceof Error, 'is a TypeError object');\n    t.equal('TypeError', err.type, 'correct type');\n    t.equal('this is a TypeError', err.message, 'correct message');\n  });\n  child.err('Error', 'this is an Error with custom props', {\n    foo: 'bar',\n    'baz': 1\n  }, function (err) {\n    t.ok(err instanceof Error, 'is an Error object');\n    t.equal(err.foo, 'bar', 'passes data');\n    t.equal(err.baz, 1, 'passes data');\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('test maxConcurrentCalls', function (t) {\n  t.plan(10);\n  let child = workerFarm({\n    maxConcurrentCalls: 5\n  }, childPath);\n  child(50, function (err) {\n    t.notOk(err, 'no error');\n  });\n  child(50, function (err) {\n    t.notOk(err, 'no error');\n  });\n  child(50, function (err) {\n    t.notOk(err, 'no error');\n  });\n  child(50, function (err) {\n    t.notOk(err, 'no error');\n  });\n  child(50, function (err) {\n    t.notOk(err, 'no error');\n  });\n  child(50, function (err) {\n    t.ok(err);\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type');\n  });\n  child(50, function (err) {\n    t.ok(err);\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type');\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('test maxConcurrentCalls + queue', function (t) {\n  t.plan(13);\n  let child = workerFarm({\n    maxConcurrentCalls: 4,\n    maxConcurrentWorkers: 2,\n    maxConcurrentCallsPerWorker: 1\n  }, childPath);\n  child(20, function (err) {\n    console.log('ended short1');\n    t.notOk(err, 'no error, short call 1');\n  });\n  child(20, function (err) {\n    console.log('ended short2');\n    t.notOk(err, 'no error, short call 2');\n  });\n  child(300, function (err) {\n    t.notOk(err, 'no error, long call 1');\n  });\n  child(300, function (err) {\n    t.notOk(err, 'no error, long call 2');\n  });\n  child(20, function (err) {\n    t.ok(err, 'short call 3 should error');\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type');\n  });\n  child(20, function (err) {\n    t.ok(err, 'short call 4 should error');\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type');\n  }); // cross fingers and hope the two short jobs have ended\n\n  setTimeout(function () {\n    child(20, function (err) {\n      t.notOk(err, 'no error, delayed short call 1');\n    });\n    child(20, function (err) {\n      t.notOk(err, 'no error, delayed short call 2');\n    });\n    child(20, function (err) {\n      t.ok(err, 'delayed short call 3 should error');\n      t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type');\n    });\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended');\n    });\n  }, 250);\n}); // this test should not keep the process running! if the test process\n// doesn't die then the problem is here\n\ntape('test timeout kill', function (t) {\n  t.plan(3);\n  let child = workerFarm({\n    maxCallTime: 250,\n    maxConcurrentWorkers: 1\n  }, childPath, ['block']);\n  child.block(function (err) {\n    t.ok(err, 'got an error');\n    t.equal(err.type, 'TimeoutError', 'correct error type');\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('test max retries after process terminate', function (t) {\n  t.plan(7); // temporary file is used to store the number of retries among terminating workers\n\n  let filepath1 = '.retries1';\n  let child1 = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxRetries: 5\n  }, childPath, ['stubborn']);\n  child1.stubborn(filepath1, function (err, result) {\n    t.notOk(err, 'no error');\n    t.equal(result, 12, 'correct result');\n  });\n  workerFarm.end(child1, function () {\n    fs.unlinkSync(filepath1);\n    t.ok(true, 'workerFarm ended');\n  });\n  let filepath2 = '.retries2';\n  let child2 = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxRetries: 3\n  }, childPath, ['stubborn']);\n  child2.stubborn(filepath2, function (err, result) {\n    t.ok(err, 'got an error');\n    t.equal(err.type, 'ProcessTerminatedError', 'correct error type');\n    t.equal(err.message, 'cancel after 3 retries!', 'correct message and number of retries');\n  });\n  workerFarm.end(child2, function () {\n    fs.unlinkSync(filepath2);\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('custom arguments can be passed to \"fork\"', function (t) {\n  t.plan(3); // allocate a real, valid path, in any OS\n\n  let cwd = fs.realpathSync(os.tmpdir()),\n      workerOptions = {\n    cwd: cwd,\n    execArgv: ['--expose-gc']\n  },\n      child = workerFarm({\n    maxConcurrentWorkers: 1,\n    maxRetries: 5,\n    workerOptions: workerOptions\n  }, childPath, ['args']);\n  child.args(function (err, result) {\n    t.equal(result.execArgv[0], '--expose-gc', 'flags passed (overridden default)');\n    t.equal(result.cwd, cwd, 'correct cwd folder');\n  });\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended');\n  });\n});\ntape('ensure --debug/--inspect not propagated to children', function (t) {\n  t.plan(3);\n  let script = __dirname + '/debug.js',\n      debugArg = process.version.replace(/^v(\\d+)\\..*$/, '$1') >= 8 ? '--inspect' : '--debug=8881',\n      child = child_process.spawn(process.execPath, [debugArg, script]),\n      stdout = '';\n  child.stdout.on('data', function (data) {\n    stdout += data.toString();\n  });\n  child.on('close', function (code) {\n    t.equal(code, 0, 'exited without error (' + code + ')');\n    t.ok(stdout.indexOf('FINISHED') > -1, 'process finished');\n    t.ok(stdout.indexOf('--debug') === -1, 'child does not receive debug flag');\n  });\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/worker-farm/tests/index.js"],"names":["tape","require","child_process","workerFarm","childPath","resolve","fs","os","uniq","ar","a","i","j","o","length","t","plan","child","err","pid","rnd","ok","process","end","run0","onChild","subprocess","childPid","equal","maxConcurrentWorkers","pids","push","fail","autoStart","count","delay","setTimeout","uptime","maxConcurrentCallsPerWorker","Infinity","maxCallsPerWorker","defer","cbc","start","Date","now","time","callsPerWorker","min","max","ids","killable","id","pass","maxCallTime","type","undefined","Error","message","foo","baz","maxConcurrentCalls","notOk","console","log","block","filepath1","child1","maxRetries","stubborn","result","unlinkSync","filepath2","child2","cwd","realpathSync","tmpdir","workerOptions","execArgv","args","script","__dirname","debugArg","version","replace","spawn","execPath","stdout","on","data","toString","code","indexOf"],"mappings":"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","sourcesContent":["'use strict'\n\nconst tape          = require('tape')\n    , child_process = require('child_process')\n    , workerFarm    = require('../')\n    , childPath     = require.resolve('./child')\n    , fs            = require('fs')\n    , os            = require('os')\n\nfunction uniq (ar) {\n  let a = [], i, j\n  o: for (i = 0; i < ar.length; ++i) {\n    for (j = 0; j < a.length; ++j) if (a[j] == ar[i]) continue o\n    a[a.length] = ar[i]\n  }\n  return a\n}\n\n\n// a child where module.exports = function ...\ntape('simple, exports=function test', function (t) {\n  t.plan(4)\n\n  let child = workerFarm(childPath)\n  child(0, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense')\n    t.ok(pid < process.pid + 750, 'pid makes sense')\n    t.ok(rnd >= 0 && rnd < 1, 'rnd result makes sense')\n  })\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\n// a child where we have module.exports.fn = function ...\ntape('simple, exports.fn test', function (t) {\n  t.plan(4)\n\n  let child = workerFarm(childPath, [ 'run0' ])\n  child.run0(function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense')\n    t.ok(pid < process.pid + 750, 'pid makes sense')\n    t.ok(rnd >= 0 && rnd < 1, 'rnd result makes sense')\n  })\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('on child', function (t) {\n    t.plan(2)\n\n    let child = workerFarm({ onChild: function(subprocess) { childPid = subprocess.pid } }, childPath)\n      , childPid = null;\n\n    child(0, function(err, pid) {\n      t.equal(childPid, pid)\n    })\n\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended')\n    })\n})\n\n\n// use the returned pids to check that we're using a single child process\n// when maxConcurrentWorkers = 1\ntape('single worker', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({ maxConcurrentWorkers: 1 }, childPath)\n    , pids  = []\n    , i     = 10\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid)\n      if (pids.length == 10) {\n        t.equal(1, uniq(pids).length, 'only a single process (by pid)')\n      } else if (pids.length > 10)\n        t.fail('too many callbacks!')\n    })\n  }\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\n// use the returned pids to check that we're using two child processes\n// when maxConcurrentWorkers = 2\ntape('two workers', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({ maxConcurrentWorkers: 2 }, childPath)\n    , pids  = []\n    , i     = 10\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid)\n      if (pids.length == 10) {\n        t.equal(2, uniq(pids).length, 'only two child processes (by pid)')\n      } else if (pids.length > 10)\n        t.fail('too many callbacks!')\n    })\n  }\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\n// use the returned pids to check that we're using a child process per\n// call when maxConcurrentWorkers = 10\ntape('many workers', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({ maxConcurrentWorkers: 10 }, childPath)\n    , pids  = []\n    , i     = 10\n\n  while (i--) {\n    child(1, function (err, pid) {\n      pids.push(pid)\n      if (pids.length == 10) {\n        t.equal(10, uniq(pids).length, 'pids are all the same (by pid)')\n      } else if (pids.length > 10)\n        t.fail('too many callbacks!')\n    })\n  }\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('auto start workers', function (t) {\n  let child = workerFarm({ maxConcurrentWorkers: 3, autoStart: true }, childPath, ['uptime'])\n    , pids  = []\n    , count = 5\n    , i     = count\n    , delay = 250\n\n  t.plan(count + 1)\n\n  setTimeout(function() {\n    while (i--)\n      child.uptime(function (err, uptime) {\n        t.ok(uptime > 10, 'child has been up before the request (' + uptime + 'ms)')\n      })\n\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended')\n    })\n  }, delay)\n})\n\n\n// use the returned pids to check that we're using a child process per\n// call when we set maxCallsPerWorker = 1 even when we have maxConcurrentWorkers = 1\ntape('single call per worker', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({\n          maxConcurrentWorkers: 1\n        , maxConcurrentCallsPerWorker: Infinity\n        , maxCallsPerWorker: 1\n        , autoStart: true\n      }, childPath)\n    , pids  = []\n    , count = 25\n    , i     = count\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid)\n      if (pids.length == count) {\n        t.equal(count, uniq(pids).length, 'one process for each call (by pid)')\n        workerFarm.end(child, function () {\n          t.ok(true, 'workerFarm ended')\n        })\n      } else if (pids.length > count)\n        t.fail('too many callbacks!')\n    })\n  }\n})\n\n\n// use the returned pids to check that we're using a child process per\n// two-calls when we set maxCallsPerWorker = 2 even when we have maxConcurrentWorkers = 1\ntape('two calls per worker', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({\n          maxConcurrentWorkers: 1\n        , maxConcurrentCallsPerWorker: Infinity\n        , maxCallsPerWorker: 2\n        , autoStart: true\n      }, childPath)\n    , pids  = []\n    , count = 20\n    , i     = count\n\n  while (i--) {\n    child(0, function (err, pid) {\n      pids.push(pid)\n      if (pids.length == count) {\n        t.equal(count / 2, uniq(pids).length, 'one process for each call (by pid)')\n        workerFarm.end(child, function () {\n          t.ok(true, 'workerFarm ended')\n        })\n      } else if (pids.length > count)\n        t.fail('too many callbacks!')\n    })\n  }\n})\n\n\n// use timing to confirm that one worker will process calls sequentially\ntape('many concurrent calls', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({\n          maxConcurrentWorkers: 1\n        , maxConcurrentCallsPerWorker: Infinity\n        , maxCallsPerWorker: Infinity\n        , autoStart: true\n      }, childPath)\n    , defer = 200\n    , count = 200\n    , i     = count\n    , cbc   = 0\n\n  setTimeout(function () {\n    let start = Date.now()\n\n    while (i--) {\n      child(defer, function () {\n        if (++cbc == count) {\n          let time = Date.now() - start\n          // upper-limit not tied to `count` at all\n          t.ok(time > defer && time < (defer * 2.5), 'processed tasks concurrently (' + time + 'ms)')\n          workerFarm.end(child, function () {\n            t.ok(true, 'workerFarm ended')\n          })\n        } else if (cbc > count)\n          t.fail('too many callbacks!')\n      })\n    }\n  }, 250)\n})\n\n\n// use timing to confirm that one child processes calls sequentially with\n// maxConcurrentCallsPerWorker = 1\ntape('single concurrent call', function (t) {\n  t.plan(2)\n\n  let child = workerFarm({\n          maxConcurrentWorkers: 1\n        , maxConcurrentCallsPerWorker: 1\n        , maxCallsPerWorker: Infinity\n        , autoStart: true\n      }, childPath)\n    , defer = 20\n    , count = 100\n    , i     = count\n    , cbc   = 0\n\n  setTimeout(function () {\n    let start = Date.now()\n\n    while (i--) {\n      child(defer, function () {\n        if (++cbc == count) {\n          let time = Date.now() - start\n          // upper-limit tied closely to `count`, 1.3 is generous but accounts for all the timers\n          // coming back at the same time and the IPC overhead\n          t.ok(time > (defer * count) && time < (defer * count * 1.3), 'processed tasks sequentially (' + time + ')')\n          workerFarm.end(child, function () {\n            t.ok(true, 'workerFarm ended')\n          })\n        } else if (cbc > count)\n          t.fail('too many callbacks!')\n      })\n    }\n  }, 250)\n})\n\n\n// use timing to confirm that one child processes *only* 5 calls concurrently\ntape('multiple concurrent calls', function (t) {\n  t.plan(2)\n\n  let callsPerWorker = 5\n    , child = workerFarm({\n          maxConcurrentWorkers: 1\n        , maxConcurrentCallsPerWorker: callsPerWorker\n        , maxCallsPerWorker: Infinity\n        , autoStart: true\n      }, childPath)\n    , defer = 100\n    , count = 100\n    , i     = count\n    , cbc   = 0\n\n  setTimeout(function () {\n    let start = Date.now()\n\n    while (i--) {\n      child(defer, function () {\n        if (++cbc == count) {\n          let time = Date.now() - start\n          let min = defer * 1.5\n          // (defer * (count / callsPerWorker + 2)) - if precise it'd be count/callsPerWorker\n          // but accounting for IPC and other overhead, we need to give it a bit of extra time,\n          // hence the +2\n          let max = defer * (count / callsPerWorker + 2)\n          t.ok(time > min && time < max, 'processed tasks concurrently (' + time + ' > ' + min + ' && ' + time + ' < ' + max + ')')\n          workerFarm.end(child, function () {\n            t.ok(true, 'workerFarm ended')\n          })\n        } else if (cbc > count)\n          t.fail('too many callbacks!')\n      })\n    }\n  }, 250)\n})\n\n\n// call a method that will die with a probability of 0.5 but expect that\n// we'll get results for each of our calls anyway\ntape('durability', function (t) {\n  t.plan(3)\n\n  let child = workerFarm({ maxConcurrentWorkers: 2 }, childPath, [ 'killable' ])\n    , ids   = []\n    , pids  = []\n    , count = 20\n    , i     = count\n\n  while (i--) {\n    child.killable(i, function (err, id, pid) {\n      ids.push(id)\n      pids.push(pid)\n      if (ids.length == count) {\n        t.ok(uniq(pids).length > 2, 'processed by many (' + uniq(pids).length + ') workers, but got there in the end!')\n        t.ok(uniq(ids).length == count, 'received a single result for each unique call')\n        workerFarm.end(child, function () {\n          t.ok(true, 'workerFarm ended')\n        })\n      } else if (ids.length > count)\n        t.fail('too many callbacks!')\n    })\n  }\n})\n\n\n// a callback provided to .end() can and will be called (uses \"simple, exports=function test\" to create a child)\ntape('simple, end callback', function (t) {\n  t.plan(4)\n\n  let child = workerFarm(childPath)\n  child(0, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid)\n    t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid)\n    t.ok(rnd >= 0 && rnd < 1, 'rnd result makes sense')\n  })\n\n  workerFarm.end(child, function() {\n    t.pass('an .end() callback was successfully called')\n  })\n})\n\n\ntape('call timeout test', function (t) {\n  t.plan(3 + 3 + 4 + 4 + 4 + 3 + 1)\n\n  let child = workerFarm({ maxCallTime: 250, maxConcurrentWorkers: 1 }, childPath)\n\n  // should come back ok\n  child(50, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid)\n    t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid)\n    t.ok(rnd > 0 && rnd < 1, 'rnd result makes sense ' + rnd)\n  })\n\n  // should come back ok\n  child(50, function (err, pid, rnd) {\n    t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid)\n    t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid)\n    t.ok(rnd > 0 && rnd < 1, 'rnd result makes sense ' + rnd)\n  })\n\n  // should die\n  child(500, function (err, pid, rnd) {\n    t.ok(err, 'got an error')\n    t.equal(err.type, 'TimeoutError', 'correct error type')\n    t.ok(pid === undefined, 'no pid')\n    t.ok(rnd === undefined, 'no rnd')\n  })\n\n  // should die\n  child(1000, function (err, pid, rnd) {\n    t.ok(err, 'got an error')\n    t.equal(err.type, 'TimeoutError', 'correct error type')\n    t.ok(pid === undefined, 'no pid')\n    t.ok(rnd === undefined, 'no rnd')\n  })\n\n  // should die even though it is only a 100ms task, it'll get caught up\n  // in a dying worker\n  setTimeout(function () {\n    child(100, function (err, pid, rnd) {\n      t.ok(err, 'got an error')\n      t.equal(err.type, 'TimeoutError', 'correct error type')\n      t.ok(pid === undefined, 'no pid')\n      t.ok(rnd === undefined, 'no rnd')\n    })\n  }, 200)\n\n  // should be ok, new worker\n  setTimeout(function () {\n    child(50, function (err, pid, rnd) {\n      t.ok(pid > process.pid, 'pid makes sense ' + pid + ' vs ' + process.pid)\n      t.ok(pid < process.pid + 750, 'pid makes sense ' + pid + ' vs ' + process.pid)\n      t.ok(rnd > 0 && rnd < 1, 'rnd result makes sense ' + rnd)\n    })\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended')\n    })\n  }, 400)\n})\n\n\ntape('test error passing', function (t) {\n  t.plan(10)\n\n  let child = workerFarm(childPath, [ 'err' ])\n  child.err('Error', 'this is an Error', function (err) {\n    t.ok(err instanceof Error, 'is an Error object')\n    t.equal('Error', err.type, 'correct type')\n    t.equal('this is an Error', err.message, 'correct message')\n  })\n  child.err('TypeError', 'this is a TypeError', function (err) {\n    t.ok(err instanceof Error, 'is a TypeError object')\n    t.equal('TypeError', err.type, 'correct type')\n    t.equal('this is a TypeError', err.message, 'correct message')\n  })\n  child.err('Error', 'this is an Error with custom props', {foo: 'bar', 'baz': 1}, function (err) {\n    t.ok(err instanceof Error, 'is an Error object')\n    t.equal(err.foo, 'bar', 'passes data')\n    t.equal(err.baz, 1, 'passes data')\n  })\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('test maxConcurrentCalls', function (t) {\n  t.plan(10)\n\n  let child = workerFarm({ maxConcurrentCalls: 5 }, childPath)\n\n  child(50, function (err) { t.notOk(err, 'no error') })\n  child(50, function (err) { t.notOk(err, 'no error') })\n  child(50, function (err) { t.notOk(err, 'no error') })\n  child(50, function (err) { t.notOk(err, 'no error') })\n  child(50, function (err) { t.notOk(err, 'no error') })\n  child(50, function (err) {\n    t.ok(err)\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type')\n  })\n  child(50, function (err) {\n    t.ok(err)\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type')\n  })\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('test maxConcurrentCalls + queue', function (t) {\n  t.plan(13)\n\n  let child = workerFarm({ maxConcurrentCalls: 4, maxConcurrentWorkers: 2, maxConcurrentCallsPerWorker: 1 }, childPath)\n\n  child(20, function (err) { console.log('ended short1'); t.notOk(err, 'no error, short call 1') })\n  child(20, function (err) { console.log('ended short2'); t.notOk(err, 'no error, short call 2') })\n  child(300, function (err) { t.notOk(err, 'no error, long call 1') })\n  child(300, function (err) { t.notOk(err, 'no error, long call 2') })\n  child(20, function (err) {\n    t.ok(err, 'short call 3 should error')\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type')\n  })\n  child(20, function (err) {\n    t.ok(err, 'short call 4 should error')\n    t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type')\n  })\n\n  // cross fingers and hope the two short jobs have ended\n  setTimeout(function () {\n    child(20, function (err) { t.notOk(err, 'no error, delayed short call 1') })\n    child(20, function (err) { t.notOk(err, 'no error, delayed short call 2') })\n    child(20, function (err) {\n      t.ok(err, 'delayed short call 3 should error')\n      t.equal(err.type, 'MaxConcurrentCallsError', 'correct error type')\n    })\n\n    workerFarm.end(child, function () {\n      t.ok(true, 'workerFarm ended')\n    })\n  }, 250)\n})\n\n\n// this test should not keep the process running! if the test process\n// doesn't die then the problem is here\ntape('test timeout kill', function (t) {\n  t.plan(3)\n\n  let child = workerFarm({ maxCallTime: 250, maxConcurrentWorkers: 1 }, childPath, [ 'block' ])\n  child.block(function (err) {\n    t.ok(err, 'got an error')\n    t.equal(err.type, 'TimeoutError', 'correct error type')\n  })\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('test max retries after process terminate', function (t) {\n  t.plan(7)\n\n  // temporary file is used to store the number of retries among terminating workers\n  let filepath1 = '.retries1'\n  let child1 = workerFarm({ maxConcurrentWorkers: 1, maxRetries: 5}, childPath, [ 'stubborn' ])\n  child1.stubborn(filepath1, function (err, result) {\n    t.notOk(err, 'no error')\n    t.equal(result, 12, 'correct result')\n  })\n\n  workerFarm.end(child1, function () {\n    fs.unlinkSync(filepath1)\n    t.ok(true, 'workerFarm ended')\n  })\n\n  let filepath2 = '.retries2'\n  let child2 = workerFarm({ maxConcurrentWorkers: 1, maxRetries: 3}, childPath, [ 'stubborn' ])\n  child2.stubborn(filepath2, function (err, result) {\n    t.ok(err, 'got an error')\n    t.equal(err.type, 'ProcessTerminatedError', 'correct error type')\n    t.equal(err.message, 'cancel after 3 retries!', 'correct message and number of retries')\n  })\n\n  workerFarm.end(child2, function () {\n    fs.unlinkSync(filepath2)\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('custom arguments can be passed to \"fork\"', function (t) {\n  t.plan(3)\n\n  // allocate a real, valid path, in any OS\n  let cwd = fs.realpathSync(os.tmpdir())\n    , workerOptions = {\n        cwd      : cwd\n      , execArgv : ['--expose-gc']\n    }\n    , child = workerFarm({ maxConcurrentWorkers: 1, maxRetries: 5, workerOptions: workerOptions}, childPath, ['args'])\n\n  child.args(function (err, result) {\n    t.equal(result.execArgv[0], '--expose-gc', 'flags passed (overridden default)')\n    t.equal(result.cwd, cwd, 'correct cwd folder')\n  })\n\n  workerFarm.end(child, function () {\n    t.ok(true, 'workerFarm ended')\n  })\n})\n\n\ntape('ensure --debug/--inspect not propagated to children', function (t) {\n  t.plan(3)\n\n  let script   = __dirname + '/debug.js'\n    , debugArg = process.version.replace(/^v(\\d+)\\..*$/, '$1') >= 8 ? '--inspect' : '--debug=8881'\n    , child    = child_process.spawn(process.execPath, [ debugArg, script ])\n    , stdout   = ''\n\n  child.stdout.on('data', function (data) {\n    stdout += data.toString()\n  })\n\n  child.on('close', function (code) {\n    t.equal(code, 0, 'exited without error (' + code + ')')\n    t.ok(stdout.indexOf('FINISHED') > -1, 'process finished')\n    t.ok(stdout.indexOf('--debug') === -1, 'child does not receive debug flag')\n  })\n})\n"]},"metadata":{},"sourceType":"script"}