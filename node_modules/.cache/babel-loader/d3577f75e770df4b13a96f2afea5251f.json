{"ast":null,"code":"import { tokTypes, SourceLocation, Node, lineBreak, isNewLine, Parser, Token, getLineInfo, lineBreakG, defaultOptions } from 'acorn';\n\nfunction noop() {}\n\nvar LooseParser = function LooseParser(input, options) {\n  if (options === void 0) options = {};\n  this.toks = this.constructor.BaseParser.tokenizer(input, options);\n  this.options = this.toks.options;\n  this.input = this.toks.input;\n  this.tok = this.last = {\n    type: tokTypes.eof,\n    start: 0,\n    end: 0\n  };\n  this.tok.validateRegExpFlags = noop;\n  this.tok.validateRegExpPattern = noop;\n\n  if (this.options.locations) {\n    var here = this.toks.curPosition();\n    this.tok.loc = new SourceLocation(this.toks, here, here);\n  }\n\n  this.ahead = []; // Tokens ahead\n\n  this.context = []; // Indentation contexted\n\n  this.curIndent = 0;\n  this.curLineStart = 0;\n  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n  this.inAsync = false;\n  this.inFunction = false;\n};\n\nLooseParser.prototype.startNode = function startNode() {\n  return new Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);\n};\n\nLooseParser.prototype.storeCurrentPos = function storeCurrentPos() {\n  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;\n};\n\nLooseParser.prototype.startNodeAt = function startNodeAt(pos) {\n  if (this.options.locations) {\n    return new Node(this.toks, pos[0], pos[1]);\n  } else {\n    return new Node(this.toks, pos);\n  }\n};\n\nLooseParser.prototype.finishNode = function finishNode(node, type) {\n  node.type = type;\n  node.end = this.last.end;\n\n  if (this.options.locations) {\n    node.loc.end = this.last.loc.end;\n  }\n\n  if (this.options.ranges) {\n    node.range[1] = this.last.end;\n  }\n\n  return node;\n};\n\nLooseParser.prototype.dummyNode = function dummyNode(type) {\n  var dummy = this.startNode();\n  dummy.type = type;\n  dummy.end = dummy.start;\n\n  if (this.options.locations) {\n    dummy.loc.end = dummy.loc.start;\n  }\n\n  if (this.options.ranges) {\n    dummy.range[1] = dummy.start;\n  }\n\n  this.last = {\n    type: tokTypes.name,\n    start: dummy.start,\n    end: dummy.start,\n    loc: dummy.loc\n  };\n  return dummy;\n};\n\nLooseParser.prototype.dummyIdent = function dummyIdent() {\n  var dummy = this.dummyNode(\"Identifier\");\n  dummy.name = \"✖\";\n  return dummy;\n};\n\nLooseParser.prototype.dummyString = function dummyString() {\n  var dummy = this.dummyNode(\"Literal\");\n  dummy.value = dummy.raw = \"✖\";\n  return dummy;\n};\n\nLooseParser.prototype.eat = function eat(type) {\n  if (this.tok.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n};\n\nLooseParser.prototype.isContextual = function isContextual(name) {\n  return this.tok.type === tokTypes.name && this.tok.value === name;\n};\n\nLooseParser.prototype.eatContextual = function eatContextual(name) {\n  return this.tok.value === name && this.eat(tokTypes.name);\n};\n\nLooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {\n  return this.tok.type === tokTypes.eof || this.tok.type === tokTypes.braceR || lineBreak.test(this.input.slice(this.last.end, this.tok.start));\n};\n\nLooseParser.prototype.semicolon = function semicolon() {\n  return this.eat(tokTypes.semi);\n};\n\nLooseParser.prototype.expect = function expect(type) {\n  if (this.eat(type)) {\n    return true;\n  }\n\n  for (var i = 1; i <= 2; i++) {\n    if (this.lookAhead(i).type === type) {\n      for (var j = 0; j < i; j++) {\n        this.next();\n      }\n\n      return true;\n    }\n  }\n};\n\nLooseParser.prototype.pushCx = function pushCx() {\n  this.context.push(this.curIndent);\n};\n\nLooseParser.prototype.popCx = function popCx() {\n  this.curIndent = this.context.pop();\n};\n\nLooseParser.prototype.lineEnd = function lineEnd(pos) {\n  while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) {\n    ++pos;\n  }\n\n  return pos;\n};\n\nLooseParser.prototype.indentationAfter = function indentationAfter(pos) {\n  for (var count = 0;; ++pos) {\n    var ch = this.input.charCodeAt(pos);\n\n    if (ch === 32) {\n      ++count;\n    } else if (ch === 9) {\n      count += this.options.tabSize;\n    } else {\n      return count;\n    }\n  }\n};\n\nLooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {\n  if (this.tok.type === closeTok || this.tok.type === tokTypes.eof) {\n    return true;\n  }\n\n  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);\n};\n\nLooseParser.prototype.tokenStartsLine = function tokenStartsLine() {\n  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n    var ch = this.input.charCodeAt(p);\n\n    if (ch !== 9 && ch !== 32) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nLooseParser.prototype.extend = function extend(name, f) {\n  this[name] = f(this[name]);\n};\n\nLooseParser.prototype.parse = function parse() {\n  this.next();\n  return this.parseTopLevel();\n};\n\nLooseParser.extend = function extend() {\n  var plugins = [],\n      len = arguments.length;\n\n  while (len--) plugins[len] = arguments[len];\n\n  var cls = this;\n\n  for (var i = 0; i < plugins.length; i++) {\n    cls = plugins[i](cls);\n  }\n\n  return cls;\n};\n\nLooseParser.parse = function parse(input, options) {\n  return new this(input, options).parse();\n}; // Allows plugins to extend the base parser / tokenizer used\n\n\nLooseParser.BaseParser = Parser;\nvar lp = LooseParser.prototype;\n\nfunction isSpace(ch) {\n  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || isNewLine(ch);\n}\n\nlp.next = function () {\n  this.last = this.tok;\n\n  if (this.ahead.length) {\n    this.tok = this.ahead.shift();\n  } else {\n    this.tok = this.readToken();\n  }\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart;\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    }\n\n    this.curIndent = this.indentationAfter(this.curLineStart);\n  }\n};\n\nlp.readToken = function () {\n  for (;;) {\n    try {\n      this.toks.next();\n\n      if (this.toks.type === tokTypes.dot && this.input.substr(this.toks.end, 1) === \".\" && this.options.ecmaVersion >= 6) {\n        this.toks.end++;\n        this.toks.type = tokTypes.ellipsis;\n      }\n\n      return new Token(this.toks);\n    } catch (e) {\n      if (!(e instanceof SyntaxError)) {\n        throw e;\n      } // Try to skip some text, based on the error message, and then continue\n\n\n      var msg = e.message,\n          pos = e.raisedAt,\n          replace = true;\n\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1);\n\n        if (/string/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: tokTypes.string,\n            value: this.input.slice(e.pos + 1, pos)\n          };\n        } else if (/regular expr/i.test(msg)) {\n          var re = this.input.slice(e.pos, pos);\n\n          try {\n            re = new RegExp(re);\n          } catch (e) {\n            /* ignore compilation error due to new syntax */\n          }\n\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: tokTypes.regexp,\n            value: re\n          };\n        } else if (/template/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: tokTypes.template,\n            value: this.input.slice(e.pos, pos)\n          };\n        } else {\n          replace = false;\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) {\n          ++pos;\n        }\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          var ch = this.input.charCodeAt(pos++);\n\n          if (ch === 34 || ch === 39 || isNewLine(ch)) {\n            break;\n          }\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++;\n        replace = false;\n      } else if (/regular expression/i.test(msg)) {\n        replace = true;\n      } else {\n        throw e;\n      }\n\n      this.resetTo(pos);\n\n      if (replace === true) {\n        replace = {\n          start: pos,\n          end: pos,\n          type: tokTypes.name,\n          value: \"✖\"\n        };\n      }\n\n      if (replace) {\n        if (this.options.locations) {\n          replace.loc = new SourceLocation(this.toks, getLineInfo(this.input, replace.start), getLineInfo(this.input, replace.end));\n        }\n\n        return replace;\n      }\n    }\n  }\n};\n\nlp.resetTo = function (pos) {\n  this.toks.pos = pos;\n  var ch = this.input.charAt(pos - 1);\n  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n  if (this.options.locations) {\n    this.toks.curLine = 1;\n    this.toks.lineStart = lineBreakG.lastIndex = 0;\n    var match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine;\n      this.toks.lineStart = match.index + match[0].length;\n    }\n  }\n};\n\nlp.lookAhead = function (n) {\n  while (n > this.ahead.length) {\n    this.ahead.push(this.readToken());\n  }\n\n  return this.ahead[n - 1];\n};\n\nfunction isDummy(node) {\n  return node.name === \"✖\";\n}\n\nvar lp$1 = LooseParser.prototype;\n\nlp$1.parseTopLevel = function () {\n  var node = this.startNodeAt(this.options.locations ? [0, getLineInfo(this.input, 0)] : 0);\n  node.body = [];\n\n  while (this.tok.type !== tokTypes.eof) {\n    node.body.push(this.parseStatement());\n  }\n\n  this.toks.adaptDirectivePrologue(node.body);\n  this.last = this.tok;\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\");\n};\n\nlp$1.parseStatement = function () {\n  var starttype = this.tok.type,\n      node = this.startNode(),\n      kind;\n\n  if (this.toks.isLet()) {\n    starttype = tokTypes._var;\n    kind = \"let\";\n  }\n\n  switch (starttype) {\n    case tokTypes._break:\n    case tokTypes._continue:\n      this.next();\n      var isBreak = starttype === tokTypes._break;\n\n      if (this.semicolon() || this.canInsertSemicolon()) {\n        node.label = null;\n      } else {\n        node.label = this.tok.type === tokTypes.name ? this.parseIdent() : null;\n        this.semicolon();\n      }\n\n      return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n    case tokTypes._debugger:\n      this.next();\n      this.semicolon();\n      return this.finishNode(node, \"DebuggerStatement\");\n\n    case tokTypes._do:\n      this.next();\n      node.body = this.parseStatement();\n      node.test = this.eat(tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n      this.semicolon();\n      return this.finishNode(node, \"DoWhileStatement\");\n\n    case tokTypes._for:\n      this.next(); // `for` keyword\n\n      var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n      this.pushCx();\n      this.expect(tokTypes.parenL);\n\n      if (this.tok.type === tokTypes.semi) {\n        return this.parseFor(node, null);\n      }\n\n      var isLet = this.toks.isLet();\n\n      if (isLet || this.tok.type === tokTypes._var || this.tok.type === tokTypes._const) {\n        var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n\n        if (init$1.declarations.length === 1 && (this.tok.type === tokTypes._in || this.isContextual(\"of\"))) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n            node.await = isAwait;\n          }\n\n          return this.parseForIn(node, init$1);\n        }\n\n        return this.parseFor(node, init$1);\n      }\n\n      var init = this.parseExpression(true);\n\n      if (this.tok.type === tokTypes._in || this.isContextual(\"of\")) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n          node.await = isAwait;\n        }\n\n        return this.parseForIn(node, this.toAssignable(init));\n      }\n\n      return this.parseFor(node, init);\n\n    case tokTypes._function:\n      this.next();\n      return this.parseFunction(node, true);\n\n    case tokTypes._if:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.consequent = this.parseStatement();\n      node.alternate = this.eat(tokTypes._else) ? this.parseStatement() : null;\n      return this.finishNode(node, \"IfStatement\");\n\n    case tokTypes._return:\n      this.next();\n\n      if (this.eat(tokTypes.semi) || this.canInsertSemicolon()) {\n        node.argument = null;\n      } else {\n        node.argument = this.parseExpression();\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ReturnStatement\");\n\n    case tokTypes._switch:\n      var blockIndent = this.curIndent,\n          line = this.curLineStart;\n      this.next();\n      node.discriminant = this.parseParenExpression();\n      node.cases = [];\n      this.pushCx();\n      this.expect(tokTypes.braceL);\n      var cur;\n\n      while (!this.closes(tokTypes.braceR, blockIndent, line, true)) {\n        if (this.tok.type === tokTypes._case || this.tok.type === tokTypes._default) {\n          var isCase = this.tok.type === tokTypes._case;\n\n          if (cur) {\n            this.finishNode(cur, \"SwitchCase\");\n          }\n\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          this.next();\n\n          if (isCase) {\n            cur.test = this.parseExpression();\n          } else {\n            cur.test = null;\n          }\n\n          this.expect(tokTypes.colon);\n        } else {\n          if (!cur) {\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            cur.test = null;\n          }\n\n          cur.consequent.push(this.parseStatement());\n        }\n      }\n\n      if (cur) {\n        this.finishNode(cur, \"SwitchCase\");\n      }\n\n      this.popCx();\n      this.eat(tokTypes.braceR);\n      return this.finishNode(node, \"SwitchStatement\");\n\n    case tokTypes._throw:\n      this.next();\n      node.argument = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ThrowStatement\");\n\n    case tokTypes._try:\n      this.next();\n      node.block = this.parseBlock();\n      node.handler = null;\n\n      if (this.tok.type === tokTypes._catch) {\n        var clause = this.startNode();\n        this.next();\n\n        if (this.eat(tokTypes.parenL)) {\n          clause.param = this.toAssignable(this.parseExprAtom(), true);\n          this.expect(tokTypes.parenR);\n        } else {\n          clause.param = null;\n        }\n\n        clause.body = this.parseBlock();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n      }\n\n      node.finalizer = this.eat(tokTypes._finally) ? this.parseBlock() : null;\n\n      if (!node.handler && !node.finalizer) {\n        return node.block;\n      }\n\n      return this.finishNode(node, \"TryStatement\");\n\n    case tokTypes._var:\n    case tokTypes._const:\n      return this.parseVar(node, false, kind || this.tok.value);\n\n    case tokTypes._while:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WhileStatement\");\n\n    case tokTypes._with:\n      this.next();\n      node.object = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WithStatement\");\n\n    case tokTypes.braceL:\n      return this.parseBlock();\n\n    case tokTypes.semi:\n      this.next();\n      return this.finishNode(node, \"EmptyStatement\");\n\n    case tokTypes._class:\n      return this.parseClass(true);\n\n    case tokTypes._import:\n      if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === tokTypes.parenL) {\n        node.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n      }\n\n      return this.parseImport();\n\n    case tokTypes._export:\n      return this.parseExport();\n\n    default:\n      if (this.toks.isAsyncFunction()) {\n        this.next();\n        this.next();\n        return this.parseFunction(node, true, true);\n      }\n\n      var expr = this.parseExpression();\n\n      if (isDummy(expr)) {\n        this.next();\n\n        if (this.tok.type === tokTypes.eof) {\n          return this.finishNode(node, \"EmptyStatement\");\n        }\n\n        return this.parseStatement();\n      } else if (starttype === tokTypes.name && expr.type === \"Identifier\" && this.eat(tokTypes.colon)) {\n        node.body = this.parseStatement();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\");\n      } else {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n      }\n\n  }\n};\n\nlp$1.parseBlock = function () {\n  var node = this.startNode();\n  this.pushCx();\n  this.expect(tokTypes.braceL);\n  var blockIndent = this.curIndent,\n      line = this.curLineStart;\n  node.body = [];\n\n  while (!this.closes(tokTypes.braceR, blockIndent, line, true)) {\n    node.body.push(this.parseStatement());\n  }\n\n  this.popCx();\n  this.eat(tokTypes.braceR);\n  return this.finishNode(node, \"BlockStatement\");\n};\n\nlp$1.parseFor = function (node, init) {\n  node.init = init;\n  node.test = node.update = null;\n\n  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.semi) {\n    node.test = this.parseExpression();\n  }\n\n  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.parenR) {\n    node.update = this.parseExpression();\n  }\n\n  this.popCx();\n  this.expect(tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, \"ForStatement\");\n};\n\nlp$1.parseForIn = function (node, init) {\n  var type = this.tok.type === tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.popCx();\n  this.expect(tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, type);\n};\n\nlp$1.parseVar = function (node, noIn, kind) {\n  node.kind = kind;\n  this.next();\n  node.declarations = [];\n\n  do {\n    var decl = this.startNode();\n    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n    decl.init = this.eat(tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n  } while (this.eat(tokTypes.comma));\n\n  if (!node.declarations.length) {\n    var decl$1 = this.startNode();\n    decl$1.id = this.dummyIdent();\n    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n  }\n\n  if (!noIn) {\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\nlp$1.parseClass = function (isStatement) {\n  var node = this.startNode();\n  this.next();\n\n  if (this.tok.type === tokTypes.name) {\n    node.id = this.parseIdent();\n  } else if (isStatement === true) {\n    node.id = this.dummyIdent();\n  } else {\n    node.id = null;\n  }\n\n  node.superClass = this.eat(tokTypes._extends) ? this.parseExpression() : null;\n  node.body = this.startNode();\n  node.body.body = [];\n  this.pushCx();\n  var indent = this.curIndent + 1,\n      line = this.curLineStart;\n  this.eat(tokTypes.braceL);\n\n  if (this.curIndent + 1 < indent) {\n    indent = this.curIndent;\n    line = this.curLineStart;\n  }\n\n  while (!this.closes(tokTypes.braceR, indent, line)) {\n    if (this.semicolon()) {\n      continue;\n    }\n\n    var method = this.startNode(),\n        isGenerator = void 0,\n        isAsync = void 0;\n\n    if (this.options.ecmaVersion >= 6) {\n      method.static = false;\n      isGenerator = this.eat(tokTypes.star);\n    }\n\n    this.parsePropertyName(method);\n\n    if (isDummy(method.key)) {\n      if (isDummy(this.parseMaybeAssign())) {\n        this.next();\n      }\n\n      this.eat(tokTypes.comma);\n      continue;\n    }\n\n    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" && this.tok.type !== tokTypes.parenL && this.tok.type !== tokTypes.braceL) {\n      method.static = true;\n      isGenerator = this.eat(tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      method.static = false;\n    }\n\n    if (!method.computed && method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== tokTypes.parenL && !this.canInsertSemicolon()) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      isAsync = false;\n    }\n\n    if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" && !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") && this.tok.type !== tokTypes.parenL && this.tok.type !== tokTypes.braceL) {\n      method.kind = method.key.name;\n      this.parsePropertyName(method);\n      method.value = this.parseMethod(false);\n    } else {\n      if (!method.computed && !method.static && !isGenerator && !isAsync && (method.key.type === \"Identifier\" && method.key.name === \"constructor\" || method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n        method.kind = \"constructor\";\n      } else {\n        method.kind = \"method\";\n      }\n\n      method.value = this.parseMethod(isGenerator, isAsync);\n    }\n\n    node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n  }\n\n  this.popCx();\n\n  if (!this.eat(tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n\n    if (this.options.locations) {\n      this.last.loc.end = this.tok.loc.start;\n    }\n  }\n\n  this.semicolon();\n  this.finishNode(node.body, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\nlp$1.parseFunction = function (node, isStatement, isAsync) {\n  var oldInAsync = this.inAsync,\n      oldInFunction = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = this.eat(tokTypes.star);\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  if (this.tok.type === tokTypes.name) {\n    node.id = this.parseIdent();\n  } else if (isStatement === true) {\n    node.id = this.dummyIdent();\n  }\n\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\nlp$1.parseExport = function () {\n  var node = this.startNode();\n  this.next();\n\n  if (this.eat(tokTypes.star)) {\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n\n  if (this.eat(tokTypes._default)) {\n    // export default (function foo() {}) // This is FunctionExpression.\n    var isAsync;\n\n    if (this.tok.type === tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n    } else if (this.tok.type === tokTypes._class) {\n      node.declaration = this.parseClass(\"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  }\n\n  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n    node.declaration = this.parseStatement();\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifierList();\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\nlp$1.parseImport = function () {\n  var node = this.startNode();\n  this.next();\n\n  if (this.tok.type === tokTypes.string) {\n    node.specifiers = [];\n    node.source = this.parseExprAtom();\n  } else {\n    var elt;\n\n    if (this.tok.type === tokTypes.name && this.tok.value !== \"from\") {\n      elt = this.startNode();\n      elt.local = this.parseIdent();\n      this.finishNode(elt, \"ImportDefaultSpecifier\");\n      this.eat(tokTypes.comma);\n    }\n\n    node.specifiers = this.parseImportSpecifiers();\n    node.source = this.eatContextual(\"from\") && this.tok.type === tokTypes.string ? this.parseExprAtom() : this.dummyString();\n\n    if (elt) {\n      node.specifiers.unshift(elt);\n    }\n  }\n\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\nlp$1.parseImportSpecifiers = function () {\n  var elts = [];\n\n  if (this.tok.type === tokTypes.star) {\n    var elt = this.startNode();\n    this.next();\n    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n  } else {\n    var indent = this.curIndent,\n        line = this.curLineStart,\n        continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(tokTypes.braceL);\n\n    if (this.curLineStart > continuedLine) {\n      continuedLine = this.curLineStart;\n    }\n\n    while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      var elt$1 = this.startNode();\n\n      if (this.eat(tokTypes.star)) {\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n        this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n      } else {\n        if (this.isContextual(\"from\")) {\n          break;\n        }\n\n        elt$1.imported = this.parseIdent();\n\n        if (isDummy(elt$1.imported)) {\n          break;\n        }\n\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n        this.finishNode(elt$1, \"ImportSpecifier\");\n      }\n\n      elts.push(elt$1);\n      this.eat(tokTypes.comma);\n    }\n\n    this.eat(tokTypes.braceR);\n    this.popCx();\n  }\n\n  return elts;\n};\n\nlp$1.parseExportSpecifierList = function () {\n  var elts = [];\n  var indent = this.curIndent,\n      line = this.curLineStart,\n      continuedLine = this.nextLineStart;\n  this.pushCx();\n  this.eat(tokTypes.braceL);\n\n  if (this.curLineStart > continuedLine) {\n    continuedLine = this.curLineStart;\n  }\n\n  while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n    if (this.isContextual(\"from\")) {\n      break;\n    }\n\n    var elt = this.startNode();\n    elt.local = this.parseIdent();\n\n    if (isDummy(elt.local)) {\n      break;\n    }\n\n    elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n    this.finishNode(elt, \"ExportSpecifier\");\n    elts.push(elt);\n    this.eat(tokTypes.comma);\n  }\n\n  this.eat(tokTypes.braceR);\n  this.popCx();\n  return elts;\n};\n\nvar lp$2 = LooseParser.prototype;\n\nlp$2.checkLVal = function (expr) {\n  if (!expr) {\n    return expr;\n  }\n\n  switch (expr.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n      return expr;\n\n    case \"ParenthesizedExpression\":\n      expr.expression = this.checkLVal(expr.expression);\n      return expr;\n\n    default:\n      return this.dummyIdent();\n  }\n};\n\nlp$2.parseExpression = function (noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseMaybeAssign(noIn);\n\n  if (this.tok.type === tokTypes.comma) {\n    var node = this.startNodeAt(start);\n    node.expressions = [expr];\n\n    while (this.eat(tokTypes.comma)) {\n      node.expressions.push(this.parseMaybeAssign(noIn));\n    }\n\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n\n  return expr;\n};\n\nlp$2.parseParenExpression = function () {\n  this.pushCx();\n  this.expect(tokTypes.parenL);\n  var val = this.parseExpression();\n  this.popCx();\n  this.expect(tokTypes.parenR);\n  return val;\n};\n\nlp$2.parseMaybeAssign = function (noIn) {\n  if (this.toks.isContextual(\"yield\")) {\n    var node = this.startNode();\n    this.next();\n\n    if (this.semicolon() || this.canInsertSemicolon() || this.tok.type !== tokTypes.star && !this.tok.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(tokTypes.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  var start = this.storeCurrentPos();\n  var left = this.parseMaybeConditional(noIn);\n\n  if (this.tok.type.isAssign) {\n    var node$1 = this.startNodeAt(start);\n    node$1.operator = this.tok.value;\n    node$1.left = this.tok.type === tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n    this.next();\n    node$1.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node$1, \"AssignmentExpression\");\n  }\n\n  return left;\n};\n\nlp$2.parseMaybeConditional = function (noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseExprOps(noIn);\n\n  if (this.eat(tokTypes.question)) {\n    var node = this.startNodeAt(start);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    node.alternate = this.expect(tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  return expr;\n};\n\nlp$2.parseExprOps = function (noIn) {\n  var start = this.storeCurrentPos();\n  var indent = this.curIndent,\n      line = this.curLineStart;\n  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);\n};\n\nlp$2.parseExprOp = function (left, start, minPrec, noIn, indent, line) {\n  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n    return left;\n  }\n\n  var prec = this.tok.type.binop;\n\n  if (prec != null && (!noIn || this.tok.type !== tokTypes._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(start);\n      node.left = left;\n      node.operator = this.tok.value;\n      this.next();\n\n      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n        node.right = this.dummyIdent();\n      } else {\n        var rightStart = this.storeCurrentPos();\n        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n      }\n\n      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, start, minPrec, noIn, indent, line);\n    }\n  }\n\n  return left;\n};\n\nlp$2.parseMaybeUnary = function (sawUnary) {\n  var start = this.storeCurrentPos(),\n      expr;\n\n  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.tok.type.prefix) {\n    var node = this.startNode(),\n        update = this.tok.type === tokTypes.incDec;\n\n    if (!update) {\n      sawUnary = true;\n    }\n\n    node.operator = this.tok.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(true);\n\n    if (update) {\n      node.argument = this.checkLVal(node.argument);\n    }\n\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (this.tok.type === tokTypes.ellipsis) {\n    var node$1 = this.startNode();\n    this.next();\n    node$1.argument = this.parseMaybeUnary(sawUnary);\n    expr = this.finishNode(node$1, \"SpreadElement\");\n  } else {\n    expr = this.parseExprSubscripts();\n\n    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n      var node$2 = this.startNodeAt(start);\n      node$2.operator = this.tok.value;\n      node$2.prefix = false;\n      node$2.argument = this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$2, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(tokTypes.starstar)) {\n    var node$3 = this.startNodeAt(start);\n    node$3.operator = \"**\";\n    node$3.left = expr;\n    node$3.right = this.parseMaybeUnary(false);\n    return this.finishNode(node$3, \"BinaryExpression\");\n  }\n\n  return expr;\n};\n\nlp$2.parseExprSubscripts = function () {\n  var start = this.storeCurrentPos();\n  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);\n};\n\nlp$2.parseSubscripts = function (base, start, noCalls, startIndent, line) {\n  for (;;) {\n    if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n      if (this.tok.type === tokTypes.dot && this.curIndent === startIndent) {\n        --startIndent;\n      } else {\n        return base;\n      }\n    }\n\n    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n    if (this.eat(tokTypes.dot)) {\n      var node = this.startNodeAt(start);\n      node.object = base;\n\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        node.property = this.dummyIdent();\n      } else {\n        node.property = this.parsePropertyAccessor() || this.dummyIdent();\n      }\n\n      node.computed = false;\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (this.tok.type === tokTypes.bracketL) {\n      this.pushCx();\n      this.next();\n      var node$1 = this.startNodeAt(start);\n      node$1.object = base;\n      node$1.property = this.parseExpression();\n      node$1.computed = true;\n      this.popCx();\n      this.expect(tokTypes.bracketR);\n      base = this.finishNode(node$1, \"MemberExpression\");\n    } else if (!noCalls && this.tok.type === tokTypes.parenL) {\n      var exprList = this.parseExprList(tokTypes.parenR);\n\n      if (maybeAsyncArrow && this.eat(tokTypes.arrow)) {\n        return this.parseArrowExpression(this.startNodeAt(start), exprList, true);\n      }\n\n      var node$2 = this.startNodeAt(start);\n      node$2.callee = base;\n      node$2.arguments = exprList;\n      base = this.finishNode(node$2, \"CallExpression\");\n    } else if (this.tok.type === tokTypes.backQuote) {\n      var node$3 = this.startNodeAt(start);\n      node$3.tag = base;\n      node$3.quasi = this.parseTemplate();\n      base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\nlp$2.parseExprAtom = function () {\n  var node;\n\n  switch (this.tok.type) {\n    case tokTypes._this:\n    case tokTypes._super:\n      var type = this.tok.type === tokTypes._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type);\n\n    case tokTypes.name:\n      var start = this.storeCurrentPos();\n      var id = this.parseIdent();\n      var isAsync = false;\n\n      if (id.name === \"async\" && !this.canInsertSemicolon()) {\n        if (this.eat(tokTypes._function)) {\n          return this.parseFunction(this.startNodeAt(start), false, true);\n        }\n\n        if (this.tok.type === tokTypes.name) {\n          id = this.parseIdent();\n          isAsync = true;\n        }\n      }\n\n      return this.eat(tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id;\n\n    case tokTypes.regexp:\n      node = this.startNode();\n      var val = this.tok.value;\n      node.regex = {\n        pattern: val.pattern,\n        flags: val.flags\n      };\n      node.value = val.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case tokTypes.num:\n    case tokTypes.string:\n      node = this.startNode();\n      node.value = this.tok.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n\n      if (this.tok.type === tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) {\n        node.bigint = node.raw.slice(0, -1);\n      }\n\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case tokTypes._null:\n    case tokTypes._true:\n    case tokTypes._false:\n      node = this.startNode();\n      node.value = this.tok.type === tokTypes._null ? null : this.tok.type === tokTypes._true;\n      node.raw = this.tok.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case tokTypes.parenL:\n      var parenStart = this.storeCurrentPos();\n      this.next();\n      var inner = this.parseExpression();\n      this.expect(tokTypes.parenR);\n\n      if (this.eat(tokTypes.arrow)) {\n        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n        var params = inner.expressions || [inner];\n\n        if (params.length && isDummy(params[params.length - 1])) {\n          params.pop();\n        }\n\n        return this.parseArrowExpression(this.startNodeAt(parenStart), params);\n      }\n\n      if (this.options.preserveParens) {\n        var par = this.startNodeAt(parenStart);\n        par.expression = inner;\n        inner = this.finishNode(par, \"ParenthesizedExpression\");\n      }\n\n      return inner;\n\n    case tokTypes.bracketL:\n      node = this.startNode();\n      node.elements = this.parseExprList(tokTypes.bracketR, true);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case tokTypes.braceL:\n      return this.parseObj();\n\n    case tokTypes._class:\n      return this.parseClass(false);\n\n    case tokTypes._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false);\n\n    case tokTypes._new:\n      return this.parseNew();\n\n    case tokTypes.backQuote:\n      return this.parseTemplate();\n\n    case tokTypes._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport();\n      } else {\n        return this.dummyIdent();\n      }\n\n    default:\n      return this.dummyIdent();\n  }\n};\n\nlp$2.parseDynamicImport = function () {\n  var node = this.startNode();\n  this.next();\n  return this.finishNode(node, \"Import\");\n};\n\nlp$2.parseNew = function () {\n  var node = this.startNode(),\n      startIndent = this.curIndent,\n      line = this.curLineStart;\n  var meta = this.parseIdent(true);\n\n  if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  var start = this.storeCurrentPos();\n  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n\n  if (this.tok.type === tokTypes.parenL) {\n    node.arguments = this.parseExprList(tokTypes.parenR);\n  } else {\n    node.arguments = [];\n  }\n\n  return this.finishNode(node, \"NewExpression\");\n};\n\nlp$2.parseTemplateElement = function () {\n  var elem = this.startNode(); // The loose parser accepts invalid unicode escapes even in untagged templates.\n\n  if (this.tok.type === tokTypes.invalidTemplate) {\n    elem.value = {\n      raw: this.tok.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.tok.value\n    };\n  }\n\n  this.next();\n  elem.tail = this.tok.type === tokTypes.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\nlp$2.parseTemplate = function () {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement();\n  node.quasis = [curElt];\n\n  while (!curElt.tail) {\n    this.next();\n    node.expressions.push(this.parseExpression());\n\n    if (this.expect(tokTypes.braceR)) {\n      curElt = this.parseTemplateElement();\n    } else {\n      curElt = this.startNode();\n      curElt.value = {\n        cooked: \"\",\n        raw: \"\"\n      };\n      curElt.tail = true;\n      this.finishNode(curElt, \"TemplateElement\");\n    }\n\n    node.quasis.push(curElt);\n  }\n\n  this.expect(tokTypes.backQuote);\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\nlp$2.parseObj = function () {\n  var node = this.startNode();\n  node.properties = [];\n  this.pushCx();\n  var indent = this.curIndent + 1,\n      line = this.curLineStart;\n  this.eat(tokTypes.braceL);\n\n  if (this.curIndent + 1 < indent) {\n    indent = this.curIndent;\n    line = this.curLineStart;\n  }\n\n  while (!this.closes(tokTypes.braceR, indent, line)) {\n    var prop = this.startNode(),\n        isGenerator = void 0,\n        isAsync = void 0,\n        start = void 0;\n\n    if (this.options.ecmaVersion >= 9 && this.eat(tokTypes.ellipsis)) {\n      prop.argument = this.parseMaybeAssign();\n      node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n      this.eat(tokTypes.comma);\n      continue;\n    }\n\n    if (this.options.ecmaVersion >= 6) {\n      start = this.storeCurrentPos();\n      prop.method = false;\n      prop.shorthand = false;\n      isGenerator = this.eat(tokTypes.star);\n    }\n\n    this.parsePropertyName(prop);\n\n    if (this.toks.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(tokTypes.star);\n      this.parsePropertyName(prop);\n    } else {\n      isAsync = false;\n    }\n\n    if (isDummy(prop.key)) {\n      if (isDummy(this.parseMaybeAssign())) {\n        this.next();\n      }\n\n      this.eat(tokTypes.comma);\n      continue;\n    }\n\n    if (this.eat(tokTypes.colon)) {\n      prop.kind = \"init\";\n      prop.value = this.parseMaybeAssign();\n    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === tokTypes.parenL || this.tok.type === tokTypes.braceL)) {\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" && !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.tok.type !== tokTypes.comma && this.tok.type !== tokTypes.braceR && this.tok.type !== tokTypes.eq) {\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n    } else {\n      prop.kind = \"init\";\n\n      if (this.options.ecmaVersion >= 6) {\n        if (this.eat(tokTypes.eq)) {\n          var assign = this.startNodeAt(start);\n          assign.operator = \"=\";\n          assign.left = prop.key;\n          assign.right = this.parseMaybeAssign();\n          prop.value = this.finishNode(assign, \"AssignmentExpression\");\n        } else {\n          prop.value = prop.key;\n        }\n      } else {\n        prop.value = this.dummyIdent();\n      }\n\n      prop.shorthand = true;\n    }\n\n    node.properties.push(this.finishNode(prop, \"Property\"));\n    this.eat(tokTypes.comma);\n  }\n\n  this.popCx();\n\n  if (!this.eat(tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n\n    if (this.options.locations) {\n      this.last.loc.end = this.tok.loc.start;\n    }\n  }\n\n  return this.finishNode(node, \"ObjectExpression\");\n};\n\nlp$2.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tokTypes.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseExpression();\n      this.expect(tokTypes.bracketR);\n      return;\n    } else {\n      prop.computed = false;\n    }\n  }\n\n  var key = this.tok.type === tokTypes.num || this.tok.type === tokTypes.string ? this.parseExprAtom() : this.parseIdent();\n  prop.key = key || this.dummyIdent();\n};\n\nlp$2.parsePropertyAccessor = function () {\n  if (this.tok.type === tokTypes.name || this.tok.type.keyword) {\n    return this.parseIdent();\n  }\n};\n\nlp$2.parseIdent = function () {\n  var name = this.tok.type === tokTypes.name ? this.tok.value : this.tok.type.keyword;\n\n  if (!name) {\n    return this.dummyIdent();\n  }\n\n  var node = this.startNode();\n  this.next();\n  node.name = name;\n  return this.finishNode(node, \"Identifier\");\n};\n\nlp$2.initFunction = function (node) {\n  node.id = null;\n  node.params = [];\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = false;\n  }\n}; // Convert existing expression atom to assignable pattern\n// if possible.\n\n\nlp$2.toAssignable = function (node, binding) {\n  if (!node || node.type === \"Identifier\" || node.type === \"MemberExpression\" && !binding) ;else if (node.type === \"ParenthesizedExpression\") {\n    this.toAssignable(node.expression, binding);\n  } else if (this.options.ecmaVersion < 6) {\n    return this.dummyIdent();\n  } else if (node.type === \"ObjectExpression\") {\n    node.type = \"ObjectPattern\";\n\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      this.toAssignable(prop, binding);\n    }\n  } else if (node.type === \"ArrayExpression\") {\n    node.type = \"ArrayPattern\";\n    this.toAssignableList(node.elements, binding);\n  } else if (node.type === \"Property\") {\n    this.toAssignable(node.value, binding);\n  } else if (node.type === \"SpreadElement\") {\n    node.type = \"RestElement\";\n    this.toAssignable(node.argument, binding);\n  } else if (node.type === \"AssignmentExpression\") {\n    node.type = \"AssignmentPattern\";\n    delete node.operator;\n  } else {\n    return this.dummyIdent();\n  }\n  return node;\n};\n\nlp$2.toAssignableList = function (exprList, binding) {\n  for (var i = 0, list = exprList; i < list.length; i += 1) {\n    var expr = list[i];\n    this.toAssignable(expr, binding);\n  }\n\n  return exprList;\n};\n\nlp$2.parseFunctionParams = function (params) {\n  params = this.parseExprList(tokTypes.parenR);\n  return this.toAssignableList(params, true);\n};\n\nlp$2.parseMethod = function (isGenerator, isAsync) {\n  var node = this.startNode(),\n      oldInAsync = this.inAsync,\n      oldInFunction = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = !!isGenerator;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"FunctionExpression\");\n};\n\nlp$2.parseArrowExpression = function (node, params, isAsync) {\n  var oldInAsync = this.inAsync,\n      oldInFunction = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.toAssignableList(params, true);\n  node.expression = this.tok.type !== tokTypes.braceL;\n\n  if (node.expression) {\n    node.body = this.parseMaybeAssign();\n  } else {\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n  }\n\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\nlp$2.parseExprList = function (close, allowEmpty) {\n  this.pushCx();\n  var indent = this.curIndent,\n      line = this.curLineStart,\n      elts = [];\n  this.next(); // Opening bracket\n\n  while (!this.closes(close, indent + 1, line)) {\n    if (this.eat(tokTypes.comma)) {\n      elts.push(allowEmpty ? null : this.dummyIdent());\n      continue;\n    }\n\n    var elt = this.parseMaybeAssign();\n\n    if (isDummy(elt)) {\n      if (this.closes(close, indent, line)) {\n        break;\n      }\n\n      this.next();\n    } else {\n      elts.push(elt);\n    }\n\n    this.eat(tokTypes.comma);\n  }\n\n  this.popCx();\n\n  if (!this.eat(close)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n\n    if (this.options.locations) {\n      this.last.loc.end = this.tok.loc.start;\n    }\n  }\n\n  return elts;\n};\n\nlp$2.parseAwait = function () {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary();\n  return this.finishNode(node, \"AwaitExpression\");\n}; // Acorn: Loose parser\n\n\ndefaultOptions.tabSize = 4;\n\nfunction parse(input, options) {\n  return LooseParser.parse(input, options);\n}\n\nexport { LooseParser, parse };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsdom/node_modules/acorn/acorn-loose/dist/acorn-loose.mjs"],"names":["tokTypes","SourceLocation","Node","lineBreak","isNewLine","Parser","Token","getLineInfo","lineBreakG","defaultOptions","noop","LooseParser","input","options","toks","constructor","BaseParser","tokenizer","tok","last","type","eof","start","end","validateRegExpFlags","validateRegExpPattern","locations","here","curPosition","loc","ahead","context","curIndent","curLineStart","nextLineStart","lineEnd","inAsync","inFunction","prototype","startNode","storeCurrentPos","startNodeAt","pos","finishNode","node","ranges","range","dummyNode","dummy","name","dummyIdent","dummyString","value","raw","eat","next","isContextual","eatContextual","canInsertSemicolon","braceR","test","slice","semicolon","semi","expect","i","lookAhead","j","pushCx","push","popCx","pop","length","charCodeAt","indentationAfter","count","ch","tabSize","closes","closeTok","indent","line","blockHeuristic","tokenStartsLine","p","extend","f","parse","parseTopLevel","plugins","len","arguments","cls","lp","isSpace","shift","readToken","dot","substr","ecmaVersion","ellipsis","e","SyntaxError","msg","message","raisedAt","replace","string","re","RegExp","regexp","template","resetTo","charAt","exprAllowed","curLine","lineStart","lastIndex","match","exec","index","n","isDummy","lp$1","body","parseStatement","adaptDirectivePrologue","sourceType","starttype","kind","isLet","_var","_break","_continue","isBreak","label","parseIdent","_debugger","_do","_while","parseParenExpression","_for","isAwait","parenL","parseFor","_const","init$1","parseVar","declarations","_in","await","parseForIn","init","parseExpression","toAssignable","_function","parseFunction","_if","consequent","alternate","_else","_return","argument","_switch","blockIndent","discriminant","cases","braceL","cur","_case","_default","isCase","colon","_throw","_try","block","parseBlock","handler","_catch","clause","param","parseExprAtom","parenR","finalizer","_finally","_with","object","_class","parseClass","_import","expression","parseImport","_export","parseExport","isAsyncFunction","expr","update","left","right","noIn","decl","id","eq","parseMaybeAssign","comma","decl$1","isStatement","superClass","_extends","method","isGenerator","isAsync","static","star","parsePropertyName","key","computed","parseMethod","oldInAsync","oldInFunction","initFunction","generator","async","params","parseFunctionParams","source","fNode","declaration","keyword","specifiers","parseExportSpecifierList","elt","local","parseImportSpecifiers","unshift","elts","continuedLine","elt$1","imported","exported","lp$2","checkLVal","expressions","val","startsExpr","delegate","parseMaybeConditional","isAssign","node$1","operator","parseExprOps","question","parseExprOp","parseMaybeUnary","minPrec","prec","binop","rightStart","sawUnary","allowAwaitOutsideFunction","parseAwait","prefix","incDec","parseExprSubscripts","postfix","node$2","starstar","node$3","parseSubscripts","base","noCalls","startIndent","maybeAsyncArrow","property","parsePropertyAccessor","bracketL","bracketR","exprList","parseExprList","arrow","parseArrowExpression","callee","backQuote","tag","quasi","parseTemplate","_this","_super","regex","pattern","flags","num","bigint","_null","_true","_false","parenStart","inner","preserveParens","par","elements","parseObj","_new","parseNew","parseDynamicImport","meta","parseTemplateElement","elem","invalidTemplate","cooked","tail","curElt","quasis","properties","prop","shorthand","isAsyncProp","assign","binding","list","toAssignableList","close","allowEmpty"],"mappings":"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","sourcesContent":["import { tokTypes, SourceLocation, Node, lineBreak, isNewLine, Parser, Token, getLineInfo, lineBreakG, defaultOptions } from 'acorn';\n\nfunction noop() {}\n\nvar LooseParser = function LooseParser(input, options) {\n  if ( options === void 0 ) options = {};\n\n  this.toks = this.constructor.BaseParser.tokenizer(input, options);\n  this.options = this.toks.options;\n  this.input = this.toks.input;\n  this.tok = this.last = {type: tokTypes.eof, start: 0, end: 0};\n  this.tok.validateRegExpFlags = noop;\n  this.tok.validateRegExpPattern = noop;\n  if (this.options.locations) {\n    var here = this.toks.curPosition();\n    this.tok.loc = new SourceLocation(this.toks, here, here);\n  }\n  this.ahead = []; // Tokens ahead\n  this.context = []; // Indentation contexted\n  this.curIndent = 0;\n  this.curLineStart = 0;\n  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n  this.inAsync = false;\n  this.inFunction = false;\n};\n\nLooseParser.prototype.startNode = function startNode () {\n  return new Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n};\n\nLooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n};\n\nLooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n  if (this.options.locations) {\n    return new Node(this.toks, pos[0], pos[1])\n  } else {\n    return new Node(this.toks, pos)\n  }\n};\n\nLooseParser.prototype.finishNode = function finishNode (node, type) {\n  node.type = type;\n  node.end = this.last.end;\n  if (this.options.locations)\n    { node.loc.end = this.last.loc.end; }\n  if (this.options.ranges)\n    { node.range[1] = this.last.end; }\n  return node\n};\n\nLooseParser.prototype.dummyNode = function dummyNode (type) {\n  var dummy = this.startNode();\n  dummy.type = type;\n  dummy.end = dummy.start;\n  if (this.options.locations)\n    { dummy.loc.end = dummy.loc.start; }\n  if (this.options.ranges)\n    { dummy.range[1] = dummy.start; }\n  this.last = {type: tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n  return dummy\n};\n\nLooseParser.prototype.dummyIdent = function dummyIdent () {\n  var dummy = this.dummyNode(\"Identifier\");\n  dummy.name = \"✖\";\n  return dummy\n};\n\nLooseParser.prototype.dummyString = function dummyString () {\n  var dummy = this.dummyNode(\"Literal\");\n  dummy.value = dummy.raw = \"✖\";\n  return dummy\n};\n\nLooseParser.prototype.eat = function eat (type) {\n  if (this.tok.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\nLooseParser.prototype.isContextual = function isContextual (name) {\n  return this.tok.type === tokTypes.name && this.tok.value === name\n};\n\nLooseParser.prototype.eatContextual = function eatContextual (name) {\n  return this.tok.value === name && this.eat(tokTypes.name)\n};\n\nLooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n  return this.tok.type === tokTypes.eof || this.tok.type === tokTypes.braceR ||\n    lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n};\n\nLooseParser.prototype.semicolon = function semicolon () {\n  return this.eat(tokTypes.semi)\n};\n\nLooseParser.prototype.expect = function expect (type) {\n  if (this.eat(type)) { return true }\n  for (var i = 1; i <= 2; i++) {\n    if (this.lookAhead(i).type === type) {\n      for (var j = 0; j < i; j++) { this.next(); }\n      return true\n    }\n  }\n};\n\nLooseParser.prototype.pushCx = function pushCx () {\n  this.context.push(this.curIndent);\n};\n\nLooseParser.prototype.popCx = function popCx () {\n  this.curIndent = this.context.pop();\n};\n\nLooseParser.prototype.lineEnd = function lineEnd (pos) {\n  while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n  return pos\n};\n\nLooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n  for (var count = 0;; ++pos) {\n    var ch = this.input.charCodeAt(pos);\n    if (ch === 32) { ++count; }\n    else if (ch === 9) { count += this.options.tabSize; }\n    else { return count }\n  }\n};\n\nLooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n  if (this.tok.type === closeTok || this.tok.type === tokTypes.eof) { return true }\n  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n     this.indentationAfter(this.nextLineStart) < indent)\n};\n\nLooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n    var ch = this.input.charCodeAt(p);\n    if (ch !== 9 && ch !== 32) { return false }\n  }\n  return true\n};\n\nLooseParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nLooseParser.prototype.parse = function parse () {\n  this.next();\n  return this.parseTopLevel()\n};\n\nLooseParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nLooseParser.parse = function parse (input, options) {\n  return new this(input, options).parse()\n};\n\n// Allows plugins to extend the base parser / tokenizer used\nLooseParser.BaseParser = Parser;\n\nvar lp = LooseParser.prototype;\n\nfunction isSpace(ch) {\n  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)\n}\n\nlp.next = function() {\n  this.last = this.tok;\n  if (this.ahead.length)\n    { this.tok = this.ahead.shift(); }\n  else\n    { this.tok = this.readToken(); }\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart;\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    }\n    this.curIndent = this.indentationAfter(this.curLineStart);\n  }\n};\n\nlp.readToken = function() {\n  for (;;) {\n    try {\n      this.toks.next();\n      if (this.toks.type === tokTypes.dot &&\n          this.input.substr(this.toks.end, 1) === \".\" &&\n          this.options.ecmaVersion >= 6) {\n        this.toks.end++;\n        this.toks.type = tokTypes.ellipsis;\n      }\n      return new Token(this.toks)\n    } catch (e) {\n      if (!(e instanceof SyntaxError)) { throw e }\n\n      // Try to skip some text, based on the error message, and then continue\n      var msg = e.message, pos = e.raisedAt, replace = true;\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1);\n        if (/string/.test(msg)) {\n          replace = {start: e.pos, end: pos, type: tokTypes.string, value: this.input.slice(e.pos + 1, pos)};\n        } else if (/regular expr/i.test(msg)) {\n          var re = this.input.slice(e.pos, pos);\n          try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n          replace = {start: e.pos, end: pos, type: tokTypes.regexp, value: re};\n        } else if (/template/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: tokTypes.template,\n            value: this.input.slice(e.pos, pos)\n          };\n        } else {\n          replace = false;\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          var ch = this.input.charCodeAt(pos++);\n          if (ch === 34 || ch === 39 || isNewLine(ch)) { break }\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++;\n        replace = false;\n      } else if (/regular expression/i.test(msg)) {\n        replace = true;\n      } else {\n        throw e\n      }\n      this.resetTo(pos);\n      if (replace === true) { replace = {start: pos, end: pos, type: tokTypes.name, value: \"✖\"}; }\n      if (replace) {\n        if (this.options.locations)\n          { replace.loc = new SourceLocation(\n            this.toks,\n            getLineInfo(this.input, replace.start),\n            getLineInfo(this.input, replace.end)); }\n        return replace\n      }\n    }\n  }\n};\n\nlp.resetTo = function(pos) {\n  this.toks.pos = pos;\n  var ch = this.input.charAt(pos - 1);\n  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n    /[enwfd]/.test(ch) &&\n    /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n  if (this.options.locations) {\n    this.toks.curLine = 1;\n    this.toks.lineStart = lineBreakG.lastIndex = 0;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine;\n      this.toks.lineStart = match.index + match[0].length;\n    }\n  }\n};\n\nlp.lookAhead = function(n) {\n  while (n > this.ahead.length)\n    { this.ahead.push(this.readToken()); }\n  return this.ahead[n - 1]\n};\n\nfunction isDummy(node) { return node.name === \"✖\" }\n\nvar lp$1 = LooseParser.prototype;\n\nlp$1.parseTopLevel = function() {\n  var node = this.startNodeAt(this.options.locations ? [0, getLineInfo(this.input, 0)] : 0);\n  node.body = [];\n  while (this.tok.type !== tokTypes.eof) { node.body.push(this.parseStatement()); }\n  this.toks.adaptDirectivePrologue(node.body);\n  this.last = this.tok;\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nlp$1.parseStatement = function() {\n  var starttype = this.tok.type, node = this.startNode(), kind;\n\n  if (this.toks.isLet()) {\n    starttype = tokTypes._var;\n    kind = \"let\";\n  }\n\n  switch (starttype) {\n  case tokTypes._break: case tokTypes._continue:\n    this.next();\n    var isBreak = starttype === tokTypes._break;\n    if (this.semicolon() || this.canInsertSemicolon()) {\n      node.label = null;\n    } else {\n      node.label = this.tok.type === tokTypes.name ? this.parseIdent() : null;\n      this.semicolon();\n    }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n  case tokTypes._debugger:\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n\n  case tokTypes._do:\n    this.next();\n    node.body = this.parseStatement();\n    node.test = this.eat(tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n    this.semicolon();\n    return this.finishNode(node, \"DoWhileStatement\")\n\n  case tokTypes._for:\n    this.next(); // `for` keyword\n    var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n\n    this.pushCx();\n    this.expect(tokTypes.parenL);\n    if (this.tok.type === tokTypes.semi) { return this.parseFor(node, null) }\n    var isLet = this.toks.isLet();\n    if (isLet || this.tok.type === tokTypes._var || this.tok.type === tokTypes._const) {\n      var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n      if (init$1.declarations.length === 1 && (this.tok.type === tokTypes._in || this.isContextual(\"of\"))) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n          node.await = isAwait;\n        }\n        return this.parseForIn(node, init$1)\n      }\n      return this.parseFor(node, init$1)\n    }\n    var init = this.parseExpression(true);\n    if (this.tok.type === tokTypes._in || this.isContextual(\"of\")) {\n      if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n        node.await = isAwait;\n      }\n      return this.parseForIn(node, this.toAssignable(init))\n    }\n    return this.parseFor(node, init)\n\n  case tokTypes._function:\n    this.next();\n    return this.parseFunction(node, true)\n\n  case tokTypes._if:\n    this.next();\n    node.test = this.parseParenExpression();\n    node.consequent = this.parseStatement();\n    node.alternate = this.eat(tokTypes._else) ? this.parseStatement() : null;\n    return this.finishNode(node, \"IfStatement\")\n\n  case tokTypes._return:\n    this.next();\n    if (this.eat(tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n\n  case tokTypes._switch:\n    var blockIndent = this.curIndent, line = this.curLineStart;\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.pushCx();\n    this.expect(tokTypes.braceL);\n\n    var cur;\n    while (!this.closes(tokTypes.braceR, blockIndent, line, true)) {\n      if (this.tok.type === tokTypes._case || this.tok.type === tokTypes._default) {\n        var isCase = this.tok.type === tokTypes._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) { cur.test = this.parseExpression(); }\n        else { cur.test = null; }\n        this.expect(tokTypes.colon);\n      } else {\n        if (!cur) {\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          cur.test = null;\n        }\n        cur.consequent.push(this.parseStatement());\n      }\n    }\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.popCx();\n    this.eat(tokTypes.braceR);\n    return this.finishNode(node, \"SwitchStatement\")\n\n  case tokTypes._throw:\n    this.next();\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n\n  case tokTypes._try:\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.tok.type === tokTypes._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(tokTypes.parenL)) {\n        clause.param = this.toAssignable(this.parseExprAtom(), true);\n        this.expect(tokTypes.parenR);\n      } else {\n        clause.param = null;\n      }\n      clause.body = this.parseBlock();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(tokTypes._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) { return node.block }\n    return this.finishNode(node, \"TryStatement\")\n\n  case tokTypes._var:\n  case tokTypes._const:\n    return this.parseVar(node, false, kind || this.tok.value)\n\n  case tokTypes._while:\n    this.next();\n    node.test = this.parseParenExpression();\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"WhileStatement\")\n\n  case tokTypes._with:\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"WithStatement\")\n\n  case tokTypes.braceL:\n    return this.parseBlock()\n\n  case tokTypes.semi:\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n\n  case tokTypes._class:\n    return this.parseClass(true)\n\n  case tokTypes._import:\n    if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === tokTypes.parenL) {\n      node.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ExpressionStatement\")\n    }\n\n    return this.parseImport()\n\n  case tokTypes._export:\n    return this.parseExport()\n\n  default:\n    if (this.toks.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(node, true, true)\n    }\n    var expr = this.parseExpression();\n    if (isDummy(expr)) {\n      this.next();\n      if (this.tok.type === tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n      return this.parseStatement()\n    } else if (starttype === tokTypes.name && expr.type === \"Identifier\" && this.eat(tokTypes.colon)) {\n      node.body = this.parseStatement();\n      node.label = expr;\n      return this.finishNode(node, \"LabeledStatement\")\n    } else {\n      node.expression = expr;\n      this.semicolon();\n      return this.finishNode(node, \"ExpressionStatement\")\n    }\n  }\n};\n\nlp$1.parseBlock = function() {\n  var node = this.startNode();\n  this.pushCx();\n  this.expect(tokTypes.braceL);\n  var blockIndent = this.curIndent, line = this.curLineStart;\n  node.body = [];\n  while (!this.closes(tokTypes.braceR, blockIndent, line, true))\n    { node.body.push(this.parseStatement()); }\n  this.popCx();\n  this.eat(tokTypes.braceR);\n  return this.finishNode(node, \"BlockStatement\")\n};\n\nlp$1.parseFor = function(node, init) {\n  node.init = init;\n  node.test = node.update = null;\n  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.semi) { node.test = this.parseExpression(); }\n  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.parenR) { node.update = this.parseExpression(); }\n  this.popCx();\n  this.expect(tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, \"ForStatement\")\n};\n\nlp$1.parseForIn = function(node, init) {\n  var type = this.tok.type === tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.popCx();\n  this.expect(tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, type)\n};\n\nlp$1.parseVar = function(node, noIn, kind) {\n  node.kind = kind;\n  this.next();\n  node.declarations = [];\n  do {\n    var decl = this.startNode();\n    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n    decl.init = this.eat(tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n  } while (this.eat(tokTypes.comma))\n  if (!node.declarations.length) {\n    var decl$1 = this.startNode();\n    decl$1.id = this.dummyIdent();\n    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n  }\n  if (!noIn) { this.semicolon(); }\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\nlp$1.parseClass = function(isStatement) {\n  var node = this.startNode();\n  this.next();\n  if (this.tok.type === tokTypes.name) { node.id = this.parseIdent(); }\n  else if (isStatement === true) { node.id = this.dummyIdent(); }\n  else { node.id = null; }\n  node.superClass = this.eat(tokTypes._extends) ? this.parseExpression() : null;\n  node.body = this.startNode();\n  node.body.body = [];\n  this.pushCx();\n  var indent = this.curIndent + 1, line = this.curLineStart;\n  this.eat(tokTypes.braceL);\n  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n  while (!this.closes(tokTypes.braceR, indent, line)) {\n    if (this.semicolon()) { continue }\n    var method = this.startNode(), isGenerator = (void 0), isAsync = (void 0);\n    if (this.options.ecmaVersion >= 6) {\n      method.static = false;\n      isGenerator = this.eat(tokTypes.star);\n    }\n    this.parsePropertyName(method);\n    if (isDummy(method.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(tokTypes.comma); continue }\n    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n        (this.tok.type !== tokTypes.parenL && this.tok.type !== tokTypes.braceL)) {\n      method.static = true;\n      isGenerator = this.eat(tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      method.static = false;\n    }\n    if (!method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== tokTypes.parenL &&\n        !this.canInsertSemicolon()) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      isAsync = false;\n    }\n    if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n        this.tok.type !== tokTypes.parenL && this.tok.type !== tokTypes.braceL) {\n      method.kind = method.key.name;\n      this.parsePropertyName(method);\n      method.value = this.parseMethod(false);\n    } else {\n      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n        method.kind = \"constructor\";\n      } else {\n        method.kind = \"method\";\n      }\n      method.value = this.parseMethod(isGenerator, isAsync);\n    }\n    node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n  }\n  this.popCx();\n  if (!this.eat(tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n  }\n  this.semicolon();\n  this.finishNode(node.body, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\nlp$1.parseFunction = function(node, isStatement, isAsync) {\n  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = this.eat(tokTypes.star);\n  }\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n  if (this.tok.type === tokTypes.name) { node.id = this.parseIdent(); }\n  else if (isStatement === true) { node.id = this.dummyIdent(); }\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\nlp$1.parseExport = function() {\n  var node = this.startNode();\n  this.next();\n  if (this.eat(tokTypes.star)) {\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tokTypes._default)) {\n    // export default (function foo() {}) // This is FunctionExpression.\n    var isAsync;\n    if (this.tok.type === tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n    } else if (this.tok.type === tokTypes._class) {\n      node.declaration = this.parseClass(\"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n    node.declaration = this.parseStatement();\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifierList();\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\nlp$1.parseImport = function() {\n  var node = this.startNode();\n  this.next();\n  if (this.tok.type === tokTypes.string) {\n    node.specifiers = [];\n    node.source = this.parseExprAtom();\n  } else {\n    var elt;\n    if (this.tok.type === tokTypes.name && this.tok.value !== \"from\") {\n      elt = this.startNode();\n      elt.local = this.parseIdent();\n      this.finishNode(elt, \"ImportDefaultSpecifier\");\n      this.eat(tokTypes.comma);\n    }\n    node.specifiers = this.parseImportSpecifiers();\n    node.source = this.eatContextual(\"from\") && this.tok.type === tokTypes.string ? this.parseExprAtom() : this.dummyString();\n    if (elt) { node.specifiers.unshift(elt); }\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\nlp$1.parseImportSpecifiers = function() {\n  var elts = [];\n  if (this.tok.type === tokTypes.star) {\n    var elt = this.startNode();\n    this.next();\n    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n  } else {\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(tokTypes.braceL);\n    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n    while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      var elt$1 = this.startNode();\n      if (this.eat(tokTypes.star)) {\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n        this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n      } else {\n        if (this.isContextual(\"from\")) { break }\n        elt$1.imported = this.parseIdent();\n        if (isDummy(elt$1.imported)) { break }\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n        this.finishNode(elt$1, \"ImportSpecifier\");\n      }\n      elts.push(elt$1);\n      this.eat(tokTypes.comma);\n    }\n    this.eat(tokTypes.braceR);\n    this.popCx();\n  }\n  return elts\n};\n\nlp$1.parseExportSpecifierList = function() {\n  var elts = [];\n  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n  this.pushCx();\n  this.eat(tokTypes.braceL);\n  if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n  while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n    if (this.isContextual(\"from\")) { break }\n    var elt = this.startNode();\n    elt.local = this.parseIdent();\n    if (isDummy(elt.local)) { break }\n    elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n    this.finishNode(elt, \"ExportSpecifier\");\n    elts.push(elt);\n    this.eat(tokTypes.comma);\n  }\n  this.eat(tokTypes.braceR);\n  this.popCx();\n  return elts\n};\n\nvar lp$2 = LooseParser.prototype;\n\nlp$2.checkLVal = function(expr) {\n  if (!expr) { return expr }\n  switch (expr.type) {\n  case \"Identifier\":\n  case \"MemberExpression\":\n    return expr\n\n  case \"ParenthesizedExpression\":\n    expr.expression = this.checkLVal(expr.expression);\n    return expr\n\n  default:\n    return this.dummyIdent()\n  }\n};\n\nlp$2.parseExpression = function(noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseMaybeAssign(noIn);\n  if (this.tok.type === tokTypes.comma) {\n    var node = this.startNodeAt(start);\n    node.expressions = [expr];\n    while (this.eat(tokTypes.comma)) { node.expressions.push(this.parseMaybeAssign(noIn)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\nlp$2.parseParenExpression = function() {\n  this.pushCx();\n  this.expect(tokTypes.parenL);\n  var val = this.parseExpression();\n  this.popCx();\n  this.expect(tokTypes.parenR);\n  return val\n};\n\nlp$2.parseMaybeAssign = function(noIn) {\n  if (this.toks.isContextual(\"yield\")) {\n    var node = this.startNode();\n    this.next();\n    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== tokTypes.star && !this.tok.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(tokTypes.star);\n      node.argument = this.parseMaybeAssign();\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  }\n\n  var start = this.storeCurrentPos();\n  var left = this.parseMaybeConditional(noIn);\n  if (this.tok.type.isAssign) {\n    var node$1 = this.startNodeAt(start);\n    node$1.operator = this.tok.value;\n    node$1.left = this.tok.type === tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n    this.next();\n    node$1.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node$1, \"AssignmentExpression\")\n  }\n  return left\n};\n\nlp$2.parseMaybeConditional = function(noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseExprOps(noIn);\n  if (this.eat(tokTypes.question)) {\n    var node = this.startNodeAt(start);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    node.alternate = this.expect(tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\nlp$2.parseExprOps = function(noIn) {\n  var start = this.storeCurrentPos();\n  var indent = this.curIndent, line = this.curLineStart;\n  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n};\n\nlp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n  var prec = this.tok.type.binop;\n  if (prec != null && (!noIn || this.tok.type !== tokTypes._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(start);\n      node.left = left;\n      node.operator = this.tok.value;\n      this.next();\n      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n        node.right = this.dummyIdent();\n      } else {\n        var rightStart = this.storeCurrentPos();\n        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n      }\n      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n    }\n  }\n  return left\n};\n\nlp$2.parseMaybeUnary = function(sawUnary) {\n  var start = this.storeCurrentPos(), expr;\n  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n    (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n  ) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.tok.type.prefix) {\n    var node = this.startNode(), update = this.tok.type === tokTypes.incDec;\n    if (!update) { sawUnary = true; }\n    node.operator = this.tok.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(true);\n    if (update) { node.argument = this.checkLVal(node.argument); }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (this.tok.type === tokTypes.ellipsis) {\n    var node$1 = this.startNode();\n    this.next();\n    node$1.argument = this.parseMaybeUnary(sawUnary);\n    expr = this.finishNode(node$1, \"SpreadElement\");\n  } else {\n    expr = this.parseExprSubscripts();\n    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n      var node$2 = this.startNodeAt(start);\n      node$2.operator = this.tok.value;\n      node$2.prefix = false;\n      node$2.argument = this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$2, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(tokTypes.starstar)) {\n    var node$3 = this.startNodeAt(start);\n    node$3.operator = \"**\";\n    node$3.left = expr;\n    node$3.right = this.parseMaybeUnary(false);\n    return this.finishNode(node$3, \"BinaryExpression\")\n  }\n\n  return expr\n};\n\nlp$2.parseExprSubscripts = function() {\n  var start = this.storeCurrentPos();\n  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n};\n\nlp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n  for (;;) {\n    if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n      if (this.tok.type === tokTypes.dot && this.curIndent === startIndent)\n        { --startIndent; }\n      else\n        { return base }\n    }\n\n    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n    if (this.eat(tokTypes.dot)) {\n      var node = this.startNodeAt(start);\n      node.object = base;\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine())\n        { node.property = this.dummyIdent(); }\n      else\n        { node.property = this.parsePropertyAccessor() || this.dummyIdent(); }\n      node.computed = false;\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (this.tok.type === tokTypes.bracketL) {\n      this.pushCx();\n      this.next();\n      var node$1 = this.startNodeAt(start);\n      node$1.object = base;\n      node$1.property = this.parseExpression();\n      node$1.computed = true;\n      this.popCx();\n      this.expect(tokTypes.bracketR);\n      base = this.finishNode(node$1, \"MemberExpression\");\n    } else if (!noCalls && this.tok.type === tokTypes.parenL) {\n      var exprList = this.parseExprList(tokTypes.parenR);\n      if (maybeAsyncArrow && this.eat(tokTypes.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(start), exprList, true) }\n      var node$2 = this.startNodeAt(start);\n      node$2.callee = base;\n      node$2.arguments = exprList;\n      base = this.finishNode(node$2, \"CallExpression\");\n    } else if (this.tok.type === tokTypes.backQuote) {\n      var node$3 = this.startNodeAt(start);\n      node$3.tag = base;\n      node$3.quasi = this.parseTemplate();\n      base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\nlp$2.parseExprAtom = function() {\n  var node;\n  switch (this.tok.type) {\n  case tokTypes._this:\n  case tokTypes._super:\n    var type = this.tok.type === tokTypes._this ? \"ThisExpression\" : \"Super\";\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, type)\n\n  case tokTypes.name:\n    var start = this.storeCurrentPos();\n    var id = this.parseIdent();\n    var isAsync = false;\n    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n      if (this.eat(tokTypes._function))\n        { return this.parseFunction(this.startNodeAt(start), false, true) }\n      if (this.tok.type === tokTypes.name) {\n        id = this.parseIdent();\n        isAsync = true;\n      }\n    }\n    return this.eat(tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n  case tokTypes.regexp:\n    node = this.startNode();\n    var val = this.tok.value;\n    node.regex = {pattern: val.pattern, flags: val.flags};\n    node.value = val.value;\n    node.raw = this.input.slice(this.tok.start, this.tok.end);\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case tokTypes.num: case tokTypes.string:\n    node = this.startNode();\n    node.value = this.tok.value;\n    node.raw = this.input.slice(this.tok.start, this.tok.end);\n    if (this.tok.type === tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case tokTypes._null: case tokTypes._true: case tokTypes._false:\n    node = this.startNode();\n    node.value = this.tok.type === tokTypes._null ? null : this.tok.type === tokTypes._true;\n    node.raw = this.tok.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case tokTypes.parenL:\n    var parenStart = this.storeCurrentPos();\n    this.next();\n    var inner = this.parseExpression();\n    this.expect(tokTypes.parenR);\n    if (this.eat(tokTypes.arrow)) {\n      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n      var params = inner.expressions || [inner];\n      if (params.length && isDummy(params[params.length - 1]))\n        { params.pop(); }\n      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n    }\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(parenStart);\n      par.expression = inner;\n      inner = this.finishNode(par, \"ParenthesizedExpression\");\n    }\n    return inner\n\n  case tokTypes.bracketL:\n    node = this.startNode();\n    node.elements = this.parseExprList(tokTypes.bracketR, true);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tokTypes.braceL:\n    return this.parseObj()\n\n  case tokTypes._class:\n    return this.parseClass(false)\n\n  case tokTypes._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case tokTypes._new:\n    return this.parseNew()\n\n  case tokTypes.backQuote:\n    return this.parseTemplate()\n\n  case tokTypes._import:\n    if (this.options.ecmaVersion > 10) {\n      return this.parseDynamicImport()\n    } else {\n      return this.dummyIdent()\n    }\n\n  default:\n    return this.dummyIdent()\n  }\n};\n\nlp$2.parseDynamicImport = function() {\n  var node = this.startNode();\n  this.next();\n  return this.finishNode(node, \"Import\")\n};\n\nlp$2.parseNew = function() {\n  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var start = this.storeCurrentPos();\n  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n  if (this.tok.type === tokTypes.parenL) {\n    node.arguments = this.parseExprList(tokTypes.parenR);\n  } else {\n    node.arguments = [];\n  }\n  return this.finishNode(node, \"NewExpression\")\n};\n\nlp$2.parseTemplateElement = function() {\n  var elem = this.startNode();\n\n  // The loose parser accepts invalid unicode escapes even in untagged templates.\n  if (this.tok.type === tokTypes.invalidTemplate) {\n    elem.value = {\n      raw: this.tok.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.tok.value\n    };\n  }\n  this.next();\n  elem.tail = this.tok.type === tokTypes.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\nlp$2.parseTemplate = function() {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement();\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this.next();\n    node.expressions.push(this.parseExpression());\n    if (this.expect(tokTypes.braceR)) {\n      curElt = this.parseTemplateElement();\n    } else {\n      curElt = this.startNode();\n      curElt.value = {cooked: \"\", raw: \"\"};\n      curElt.tail = true;\n      this.finishNode(curElt, \"TemplateElement\");\n    }\n    node.quasis.push(curElt);\n  }\n  this.expect(tokTypes.backQuote);\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\nlp$2.parseObj = function() {\n  var node = this.startNode();\n  node.properties = [];\n  this.pushCx();\n  var indent = this.curIndent + 1, line = this.curLineStart;\n  this.eat(tokTypes.braceL);\n  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n  while (!this.closes(tokTypes.braceR, indent, line)) {\n    var prop = this.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n    if (this.options.ecmaVersion >= 9 && this.eat(tokTypes.ellipsis)) {\n      prop.argument = this.parseMaybeAssign();\n      node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n      this.eat(tokTypes.comma);\n      continue\n    }\n    if (this.options.ecmaVersion >= 6) {\n      start = this.storeCurrentPos();\n      prop.method = false;\n      prop.shorthand = false;\n      isGenerator = this.eat(tokTypes.star);\n    }\n    this.parsePropertyName(prop);\n    if (this.toks.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(tokTypes.star);\n      this.parsePropertyName(prop);\n    } else {\n      isAsync = false;\n    }\n    if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(tokTypes.comma); continue }\n    if (this.eat(tokTypes.colon)) {\n      prop.kind = \"init\";\n      prop.value = this.parseMaybeAssign();\n    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === tokTypes.parenL || this.tok.type === tokTypes.braceL)) {\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.tok.type !== tokTypes.comma && this.tok.type !== tokTypes.braceR && this.tok.type !== tokTypes.eq)) {\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n    } else {\n      prop.kind = \"init\";\n      if (this.options.ecmaVersion >= 6) {\n        if (this.eat(tokTypes.eq)) {\n          var assign = this.startNodeAt(start);\n          assign.operator = \"=\";\n          assign.left = prop.key;\n          assign.right = this.parseMaybeAssign();\n          prop.value = this.finishNode(assign, \"AssignmentExpression\");\n        } else {\n          prop.value = prop.key;\n        }\n      } else {\n        prop.value = this.dummyIdent();\n      }\n      prop.shorthand = true;\n    }\n    node.properties.push(this.finishNode(prop, \"Property\"));\n    this.eat(tokTypes.comma);\n  }\n  this.popCx();\n  if (!this.eat(tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n  }\n  return this.finishNode(node, \"ObjectExpression\")\n};\n\nlp$2.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tokTypes.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseExpression();\n      this.expect(tokTypes.bracketR);\n      return\n    } else {\n      prop.computed = false;\n    }\n  }\n  var key = (this.tok.type === tokTypes.num || this.tok.type === tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n  prop.key = key || this.dummyIdent();\n};\n\nlp$2.parsePropertyAccessor = function() {\n  if (this.tok.type === tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n};\n\nlp$2.parseIdent = function() {\n  var name = this.tok.type === tokTypes.name ? this.tok.value : this.tok.type.keyword;\n  if (!name) { return this.dummyIdent() }\n  var node = this.startNode();\n  this.next();\n  node.name = name;\n  return this.finishNode(node, \"Identifier\")\n};\n\nlp$2.initFunction = function(node) {\n  node.id = null;\n  node.params = [];\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\nlp$2.toAssignable = function(node, binding) {\n  if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) ; else if (node.type === \"ParenthesizedExpression\") {\n    this.toAssignable(node.expression, binding);\n  } else if (this.options.ecmaVersion < 6) {\n    return this.dummyIdent()\n  } else if (node.type === \"ObjectExpression\") {\n    node.type = \"ObjectPattern\";\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      this.toAssignable(prop, binding);\n    }\n  } else if (node.type === \"ArrayExpression\") {\n    node.type = \"ArrayPattern\";\n    this.toAssignableList(node.elements, binding);\n  } else if (node.type === \"Property\") {\n    this.toAssignable(node.value, binding);\n  } else if (node.type === \"SpreadElement\") {\n    node.type = \"RestElement\";\n    this.toAssignable(node.argument, binding);\n  } else if (node.type === \"AssignmentExpression\") {\n    node.type = \"AssignmentPattern\";\n    delete node.operator;\n  } else {\n    return this.dummyIdent()\n  }\n  return node\n};\n\nlp$2.toAssignableList = function(exprList, binding) {\n  for (var i = 0, list = exprList; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    this.toAssignable(expr, binding);\n  }\n  return exprList\n};\n\nlp$2.parseFunctionParams = function(params) {\n  params = this.parseExprList(tokTypes.parenR);\n  return this.toAssignableList(params, true)\n};\n\nlp$2.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = !!isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\nlp$2.parseArrowExpression = function(node, params, isAsync) {\n  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.toAssignableList(params, true);\n  node.expression = this.tok.type !== tokTypes.braceL;\n  if (node.expression) {\n    node.body = this.parseMaybeAssign();\n  } else {\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n  }\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\nlp$2.parseExprList = function(close, allowEmpty) {\n  this.pushCx();\n  var indent = this.curIndent, line = this.curLineStart, elts = [];\n  this.next(); // Opening bracket\n  while (!this.closes(close, indent + 1, line)) {\n    if (this.eat(tokTypes.comma)) {\n      elts.push(allowEmpty ? null : this.dummyIdent());\n      continue\n    }\n    var elt = this.parseMaybeAssign();\n    if (isDummy(elt)) {\n      if (this.closes(close, indent, line)) { break }\n      this.next();\n    } else {\n      elts.push(elt);\n    }\n    this.eat(tokTypes.comma);\n  }\n  this.popCx();\n  if (!this.eat(close)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n  }\n  return elts\n};\n\nlp$2.parseAwait = function() {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary();\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\n// Acorn: Loose parser\n\ndefaultOptions.tabSize = 4;\n\nfunction parse(input, options) {\n  return LooseParser.parse(input, options)\n}\n\nexport { LooseParser, parse };\n"]},"metadata":{},"sourceType":"module"}