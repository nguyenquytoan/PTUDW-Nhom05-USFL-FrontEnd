{"ast":null,"code":"const Minipass = require('minipass');\n\nconst _data = Symbol('_data');\n\nconst _length = Symbol('_length');\n\nclass Collect extends Minipass {\n  constructor(options) {\n    super(options);\n    this[_data] = [];\n    this[_length] = 0;\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n\n    this[_data].push(c);\n\n    this[_length] += c.length;\n    if (cb) cb();\n    return true;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    const result = Buffer.concat(this[_data], this[_length]);\n    super.write(result);\n    return super.end(cb);\n  }\n\n}\n\nmodule.exports = Collect; // it would be possible to DRY this a bit by doing something like\n// this.collector = new Collect() and listening on its data event,\n// but it's not much code, and we may as well save the extra obj\n\nclass CollectPassThrough extends Minipass {\n  constructor(options) {\n    super(options);\n    this[_data] = [];\n    this[_length] = 0;\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n\n    this[_data].push(c);\n\n    this[_length] += c.length;\n    return super.write(chunk, encoding, cb);\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    const result = Buffer.concat(this[_data], this[_length]);\n    this.emit('collect', result);\n    return super.end(cb);\n  }\n\n}\n\nmodule.exports.PassThrough = CollectPassThrough;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/minipass-collect/index.js"],"names":["Minipass","require","_data","Symbol","_length","Collect","constructor","options","write","chunk","encoding","cb","c","Buffer","isBuffer","from","push","length","end","result","concat","module","exports","CollectPassThrough","emit","PassThrough"],"mappings":"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","sourcesContent":["const Minipass = require('minipass')\nconst _data = Symbol('_data')\nconst _length = Symbol('_length')\nclass Collect extends Minipass {\n  constructor (options) {\n    super(options)\n    this[_data] = []\n    this[_length] = 0\n  }\n  write (chunk, encoding, cb) {\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding)\n    this[_data].push(c)\n    this[_length] += c.length\n    if (cb)\n      cb()\n    return true\n  }\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    const result = Buffer.concat(this[_data], this[_length])\n    super.write(result)\n    return super.end(cb)\n  }\n}\nmodule.exports = Collect\n\n// it would be possible to DRY this a bit by doing something like\n// this.collector = new Collect() and listening on its data event,\n// but it's not much code, and we may as well save the extra obj\nclass CollectPassThrough extends Minipass {\n  constructor (options) {\n    super(options)\n    this[_data] = []\n    this[_length] = 0\n  }\n  write (chunk, encoding, cb) {\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding)\n    this[_data].push(c)\n    this[_length] += c.length\n    return super.write(chunk, encoding, cb)\n  }\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    const result = Buffer.concat(this[_data], this[_length])\n    this.emit('collect', result)\n    return super.end(cb)\n  }\n}\nmodule.exports.PassThrough = CollectPassThrough\n"]},"metadata":{},"sourceType":"script"}