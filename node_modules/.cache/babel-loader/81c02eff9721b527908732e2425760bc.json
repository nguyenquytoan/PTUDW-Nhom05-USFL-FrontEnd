{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.strategies = function (e, t, s, n, r) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:strategies:4.3.1\"] && _();\n  } catch (e) {}\n\n  class i {\n    constructor(e = {}) {\n      this.t = t.cacheNames.getRuntimeName(e.cacheName), this.s = e.plugins || [], this.i = e.fetchOptions || null, this.h = e.matchOptions || null;\n    }\n\n    async handle({\n      event: e,\n      request: t\n    }) {\n      return this.makeRequest({\n        event: e,\n        request: t || e.request\n      });\n    }\n\n    async makeRequest({\n      event: e,\n      request: t\n    }) {\n      \"string\" == typeof t && (t = new Request(t));\n      let n,\n          i = await s.cacheWrapper.match({\n        cacheName: this.t,\n        request: t,\n        event: e,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n      if (!i) try {\n        i = await this.u(t, e);\n      } catch (e) {\n        n = e;\n      }\n      if (!i) throw new r.WorkboxError(\"no-response\", {\n        url: t.url,\n        error: n\n      });\n      return i;\n    }\n\n    async u(e, t) {\n      const r = await n.fetchWrapper.fetch({\n        request: e,\n        event: t,\n        fetchOptions: this.i,\n        plugins: this.s\n      }),\n            i = r.clone(),\n            h = s.cacheWrapper.put({\n        cacheName: this.t,\n        request: e,\n        response: i,\n        event: t,\n        plugins: this.s\n      });\n      if (t) try {\n        t.waitUntil(h);\n      } catch (e) {}\n      return r;\n    }\n\n  }\n\n  class h {\n    constructor(e = {}) {\n      this.t = t.cacheNames.getRuntimeName(e.cacheName), this.s = e.plugins || [], this.h = e.matchOptions || null;\n    }\n\n    async handle({\n      event: e,\n      request: t\n    }) {\n      return this.makeRequest({\n        event: e,\n        request: t || e.request\n      });\n    }\n\n    async makeRequest({\n      event: e,\n      request: t\n    }) {\n      \"string\" == typeof t && (t = new Request(t));\n      const n = await s.cacheWrapper.match({\n        cacheName: this.t,\n        request: t,\n        event: e,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n      if (!n) throw new r.WorkboxError(\"no-response\", {\n        url: t.url\n      });\n      return n;\n    }\n\n  }\n\n  const u = {\n    cacheWillUpdate: ({\n      response: e\n    }) => 200 === e.status || 0 === e.status ? e : null\n  };\n\n  class a {\n    constructor(e = {}) {\n      if (this.t = t.cacheNames.getRuntimeName(e.cacheName), e.plugins) {\n        let t = e.plugins.some(e => !!e.cacheWillUpdate);\n        this.s = t ? e.plugins : [u, ...e.plugins];\n      } else this.s = [u];\n\n      this.o = e.networkTimeoutSeconds, this.i = e.fetchOptions || null, this.h = e.matchOptions || null;\n    }\n\n    async handle({\n      event: e,\n      request: t\n    }) {\n      return this.makeRequest({\n        event: e,\n        request: t || e.request\n      });\n    }\n\n    async makeRequest({\n      event: e,\n      request: t\n    }) {\n      const s = [];\n      \"string\" == typeof t && (t = new Request(t));\n      const n = [];\n      let i;\n\n      if (this.o) {\n        const {\n          id: r,\n          promise: h\n        } = this.l({\n          request: t,\n          event: e,\n          logs: s\n        });\n        i = r, n.push(h);\n      }\n\n      const h = this.q({\n        timeoutId: i,\n        request: t,\n        event: e,\n        logs: s\n      });\n      n.push(h);\n      let u = await Promise.race(n);\n      if (u || (u = await h), !u) throw new r.WorkboxError(\"no-response\", {\n        url: t.url\n      });\n      return u;\n    }\n\n    l({\n      request: e,\n      logs: t,\n      event: s\n    }) {\n      let n;\n      return {\n        promise: new Promise(t => {\n          n = setTimeout(async () => {\n            t(await this.p({\n              request: e,\n              event: s\n            }));\n          }, 1e3 * this.o);\n        }),\n        id: n\n      };\n    }\n\n    async q({\n      timeoutId: e,\n      request: t,\n      logs: r,\n      event: i\n    }) {\n      let h, u;\n\n      try {\n        u = await n.fetchWrapper.fetch({\n          request: t,\n          event: i,\n          fetchOptions: this.i,\n          plugins: this.s\n        });\n      } catch (e) {\n        h = e;\n      }\n\n      if (e && clearTimeout(e), h || !u) u = await this.p({\n        request: t,\n        event: i\n      });else {\n        const e = u.clone(),\n              n = s.cacheWrapper.put({\n          cacheName: this.t,\n          request: t,\n          response: e,\n          event: i,\n          plugins: this.s\n        });\n        if (i) try {\n          i.waitUntil(n);\n        } catch (e) {}\n      }\n      return u;\n    }\n\n    p({\n      event: e,\n      request: t\n    }) {\n      return s.cacheWrapper.match({\n        cacheName: this.t,\n        request: t,\n        event: e,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n    }\n\n  }\n\n  class c {\n    constructor(e = {}) {\n      this.t = t.cacheNames.getRuntimeName(e.cacheName), this.s = e.plugins || [], this.i = e.fetchOptions || null;\n    }\n\n    async handle({\n      event: e,\n      request: t\n    }) {\n      return this.makeRequest({\n        event: e,\n        request: t || e.request\n      });\n    }\n\n    async makeRequest({\n      event: e,\n      request: t\n    }) {\n      let s, i;\n      \"string\" == typeof t && (t = new Request(t));\n\n      try {\n        i = await n.fetchWrapper.fetch({\n          request: t,\n          event: e,\n          fetchOptions: this.i,\n          plugins: this.s\n        });\n      } catch (e) {\n        s = e;\n      }\n\n      if (!i) throw new r.WorkboxError(\"no-response\", {\n        url: t.url,\n        error: s\n      });\n      return i;\n    }\n\n  }\n\n  class o {\n    constructor(e = {}) {\n      if (this.t = t.cacheNames.getRuntimeName(e.cacheName), this.s = e.plugins || [], e.plugins) {\n        let t = e.plugins.some(e => !!e.cacheWillUpdate);\n        this.s = t ? e.plugins : [u, ...e.plugins];\n      } else this.s = [u];\n\n      this.i = e.fetchOptions || null, this.h = e.matchOptions || null;\n    }\n\n    async handle({\n      event: e,\n      request: t\n    }) {\n      return this.makeRequest({\n        event: e,\n        request: t || e.request\n      });\n    }\n\n    async makeRequest({\n      event: e,\n      request: t\n    }) {\n      \"string\" == typeof t && (t = new Request(t));\n      const n = this.u({\n        request: t,\n        event: e\n      });\n      let i,\n          h = await s.cacheWrapper.match({\n        cacheName: this.t,\n        request: t,\n        event: e,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n\n      if (h) {\n        if (e) try {\n          e.waitUntil(n);\n        } catch (i) {}\n      } else try {\n        h = await n;\n      } catch (e) {\n        i = e;\n      }\n\n      if (!h) throw new r.WorkboxError(\"no-response\", {\n        url: t.url,\n        error: i\n      });\n      return h;\n    }\n\n    async u({\n      request: e,\n      event: t\n    }) {\n      const r = await n.fetchWrapper.fetch({\n        request: e,\n        event: t,\n        fetchOptions: this.i,\n        plugins: this.s\n      }),\n            i = s.cacheWrapper.put({\n        cacheName: this.t,\n        request: e,\n        response: r.clone(),\n        event: t,\n        plugins: this.s\n      });\n      if (t) try {\n        t.waitUntil(i);\n      } catch (e) {}\n      return r;\n    }\n\n  }\n\n  const l = {\n    cacheFirst: i,\n    cacheOnly: h,\n    networkFirst: a,\n    networkOnly: c,\n    staleWhileRevalidate: o\n  },\n        q = e => {\n    const t = l[e];\n    return e => new t(e);\n  },\n        w = q(\"cacheFirst\"),\n        p = q(\"cacheOnly\"),\n        v = q(\"networkFirst\"),\n        y = q(\"networkOnly\"),\n        m = q(\"staleWhileRevalidate\");\n\n  return e.CacheFirst = i, e.CacheOnly = h, e.NetworkFirst = a, e.NetworkOnly = c, e.StaleWhileRevalidate = o, e.cacheFirst = w, e.cacheOnly = p, e.networkFirst = v, e.networkOnly = y, e.staleWhileRevalidate = m, e;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../CacheFirst.mjs","../CacheOnly.mjs","../plugins/cacheOkAndOpaquePlugin.mjs","../NetworkFirst.mjs","../NetworkOnly.mjs","../StaleWhileRevalidate.mjs","../index.mjs"],"names":["self","_","e","CacheFirst","constructor","options","_cacheName","cacheNames","getRuntimeName","cacheName","_plugins","plugins","_fetchOptions","fetchOptions","_matchOptions","matchOptions","event","request","this","makeRequest","Request","response","cacheWrapper","match","error","_getFromNetwork","err","WorkboxError","url","fetchWrapper","fetch","responseClone","clone","cachePutPromise","put","waitUntil","CacheOnly","cacheOkAndOpaquePlugin","cacheWillUpdate","status","NetworkFirst","isUsingCacheWillUpdate","some","plugin","_networkTimeoutSeconds","networkTimeoutSeconds","logs","promises","timeoutId","id","promise","_getTimeoutPromise","push","networkPromise","_getNetworkPromise","Promise","race","resolve","async","_respondFromCache","setTimeout","clearTimeout","cachePut","NetworkOnly","StaleWhileRevalidate","fetchAndCachePromise","mapping","cacheFirst","cacheOnly","networkFirst","networkOnly","staleWhileRevalidate","deprecate","strategy","StrategyCtr"],"mappings":"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","sourcesContent":["try{self['workbox:strategies:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {CacheFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheOnly {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheOnly',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    const response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheOnly', request));\n      if (response) {\n        logger.log(`Found a cached response in the '${this._cacheName}'` +\n          ` cache.`);\n        messages.printFinalResponse(response);\n      } else {\n        logger.log(`No response found in the '${this._cacheName}' cache.`);\n      }\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url});\n    }\n    return response;\n  }\n}\n\nexport {CacheOnly};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: ({response}) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   * @param {number} options.networkTimeoutSeconds If set, any network requests\n   * that fail to respond within the timeout will fallback to the cache.\n   *\n   * This option can be used to combat\n   * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n   * scenarios.\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._networkTimeoutSeconds) {\n        assert.isType(this._networkTimeoutSeconds, 'number', {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'constructor',\n          paramName: 'networkTimeoutSeconds',\n        });\n      }\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'NetworkFirst',\n        funcName: 'handle',\n        paramName: 'makeRequest',\n      });\n    }\n\n    const promises = [];\n    let timeoutId;\n\n    if (this._networkTimeoutSeconds) {\n      const {id, promise} = this._getTimeoutPromise({request, event, logs});\n      timeoutId = id;\n      promises.push(promise);\n    }\n\n    const networkPromise =\n        this._getNetworkPromise({timeoutId, request, event, logs});\n    promises.push(networkPromise);\n\n    // Promise.race() will resolve as soon as the first promise resolves.\n    let response = await Promise.race(promises);\n    // If Promise.race() resolved with null, it might be due to a network\n    // timeout + a cache miss. If that were to happen, we'd rather wait until\n    // the networkPromise resolves instead of returning null.\n    // Note that it's fine to await an already-resolved promise, so we don't\n    // have to check to see if it's still \"in flight\".\n    if (!response) {\n      response = await networkPromise;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('NetworkFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs array\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  _getTimeoutPromise({request, logs, event}) {\n    let timeoutId;\n    const timeoutPromise = new Promise((resolve) => {\n      const onNetworkTimeout = async () => {\n        if (process.env.NODE_ENV !== 'production') {\n          logs.push(`Timing out the network response at ` +\n            `${this._networkTimeoutSeconds} seconds.`);\n        }\n\n        resolve(await this._respondFromCache({request, event}));\n      };\n\n      timeoutId = setTimeout(\n          onNetworkTimeout,\n          this._networkTimeoutSeconds * 1000,\n      );\n    });\n\n    return {\n      promise: timeoutPromise,\n      id: timeoutId,\n    };\n  }\n\n  /**\n   * @param {Object} options\n   * @param {number|undefined} options.timeoutId\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs Array.\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getNetworkPromise({timeoutId, request, logs, event}) {\n    let error;\n    let response;\n    try {\n      response = await fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins,\n      });\n    } catch (err) {\n      error = err;\n    }\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (response) {\n        logs.push(`Got response from network.`);\n      } else {\n        logs.push(`Unable to get a response from the network. Will respond ` +\n          `with a cached response.`);\n      }\n    }\n\n    if (error || !response) {\n      response = await this._respondFromCache({request, event});\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Found a cached response in the '${this._cacheName}'` +\n            ` cache.`);\n        } else {\n          logs.push(`No response found in the '${this._cacheName}' cache.`);\n        }\n      }\n    } else {\n      // Keep the service worker alive while we put the request in the cache\n      const responseClone = response.clone();\n      const cachePut = cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: responseClone,\n        event,\n        plugins: this._plugins,\n      });\n\n      if (event) {\n        try {\n          // The event has been responded to so we can keep the SW alive to\n          // respond to the request\n          event.waitUntil(cachePut);\n        } catch (err) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Used if the network timeouts or fails to make the request.\n   *\n   * @param {Object} options\n   * @param {Request} request The request to match in the cache\n   * @param {Event} [options.event]\n   * @return {Promise<Object>}\n   *\n   * @private\n   */\n  _respondFromCache({event, request}) {\n    return cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n  }\n}\n\nexport {NetworkFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkOnly {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'NetworkOnly',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    let error;\n    let response;\n    try {\n      response = await fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins,\n      });\n    } catch (err) {\n      error = err;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('NetworkOnly', request));\n      if (response) {\n        logger.log(`Got response from network.`);\n      } else {\n        logger.log(`Unable to get a response from the network.`);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n}\n\nexport {NetworkOnly};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'StaleWhileRevalidate',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n    let error;\n    if (response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\n          ` cache. Will update with the network response in the background.`);\n      }\n\n      if (event) {\n        try {\n          event.waitUntil(fetchAndCachePromise);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\n          `Will wait for the network response.`);\n      }\n      try {\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('StaleWhileRevalidate', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork({request, event}) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: response.clone(),\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {StaleWhileRevalidate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {CacheFirst} from './CacheFirst.mjs';\nimport {CacheOnly} from './CacheOnly.mjs';\nimport {NetworkFirst} from './NetworkFirst.mjs';\nimport {NetworkOnly} from './NetworkOnly.mjs';\nimport {StaleWhileRevalidate} from './StaleWhileRevalidate.mjs';\nimport './_version.mjs';\n\n\nconst mapping = {\n  cacheFirst: CacheFirst,\n  cacheOnly: CacheOnly,\n  networkFirst: NetworkFirst,\n  networkOnly: NetworkOnly,\n  staleWhileRevalidate: StaleWhileRevalidate,\n};\n\nconst deprecate = (strategy) => {\n  const StrategyCtr = mapping[strategy];\n\n  return (options) => {\n    if (process.env.NODE_ENV !== 'production') {\n      const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\n      logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` +\n          `deprecated and will be removed in a future version of Workbox.\\n` +\n          `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\n    }\n    return new StrategyCtr(options);\n  };\n};\n\n/**\n * @function workbox.strategies.cacheFirst\n * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheFirst = deprecate('cacheFirst');\n\n/**\n * @function workbox.strategies.cacheOnly\n * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheOnly = deprecate('cacheOnly');\n\n/**\n * @function workbox.strategies.networkFirst\n * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkFirst = deprecate('networkFirst');\n\n/**\n * @function workbox.strategies.networkOnly\n * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkOnly = deprecate('networkOnly');\n\n/**\n * @function workbox.strategies.staleWhileRevalidate\n * @param {Object} options See the\n * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n * @deprecated since v4.0.0\n */\nconst staleWhileRevalidate = deprecate('staleWhileRevalidate');\n\n/**\n * There are common caching strategies that most service workers will need\n * and use. This module provides simple implementations of these strategies.\n *\n * @namespace workbox.strategies\n */\n\nexport {\n  CacheFirst,\n  CacheOnly,\n  NetworkFirst,\n  NetworkOnly,\n  StaleWhileRevalidate,\n\n  // Deprecated...\n  cacheFirst,\n  cacheOnly,\n  networkFirst,\n  networkOnly,\n  staleWhileRevalidate,\n};\n\n"]},"metadata":{},"sourceType":"script"}