{"ast":null,"code":"function getLocator(source, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var offsetLine = options.offsetLine || 0;\n  var offsetColumn = options.offsetColumn || 0;\n  var originalLines = source.split('\\n');\n  var start = 0;\n  var lineRanges = originalLines.map(function (line, i) {\n    var end = start + line.length + 1;\n    var range = {\n      start: start,\n      end: end,\n      line: i\n    };\n    start = end;\n    return range;\n  });\n  var i = 0;\n\n  function rangeContains(range, index) {\n    return range.start <= index && index < range.end;\n  }\n\n  function getLocation(range, index) {\n    return {\n      line: offsetLine + range.line,\n      column: offsetColumn + index - range.start,\n      character: index\n    };\n  }\n\n  function locate(search, startIndex) {\n    if (typeof search === 'string') {\n      search = source.indexOf(search, startIndex || 0);\n    }\n\n    var range = lineRanges[i];\n    var d = search >= range.end ? 1 : -1;\n\n    while (range) {\n      if (rangeContains(range, search)) return getLocation(range, search);\n      i += d;\n      range = lineRanges[i];\n    }\n  }\n\n  return locate;\n}\n\nfunction locate(source, search, options) {\n  if (typeof options === 'number') {\n    throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n  }\n\n  return getLocator(source, options)(search, options && options.startIndex);\n}\n\nvar validNameCharacters = /[a-zA-Z0-9:_-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n  var result = '';\n\n  while (i--) {\n    result += str;\n  }\n\n  return result;\n}\n\nfunction parse(source) {\n  var header = '';\n  var stack = [];\n  var state = metadata;\n  var currentElement = null;\n  var root = null;\n\n  function error(message) {\n    var ref = locate(source, i);\n    var line = ref.line;\n    var column = ref.column;\n    var before = source.slice(0, i);\n    var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n    var after = source.slice(i);\n    var afterLine = /.*(\\n|$)/.exec(after)[0];\n    var snippet = \"\" + beforeLine + afterLine + \"\\n\" + repeat(' ', beforeLine.length) + \"^\";\n    throw new Error(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues â€“ thanks!\\n\\n\" + snippet);\n  }\n\n  function metadata() {\n    while (i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])) {\n      header += source[i++];\n    }\n\n    return neutral();\n  }\n\n  function neutral() {\n    var text = '';\n\n    while (i < source.length && source[i] !== '<') {\n      text += source[i++];\n    }\n\n    if (/\\S/.test(text)) {\n      currentElement.children.push({\n        type: 'text',\n        value: text\n      });\n    }\n\n    if (source[i] === '<') {\n      return tag;\n    }\n\n    return neutral;\n  }\n\n  function tag() {\n    var char = source[i];\n\n    if (char === '?') {\n      return neutral;\n    } // <?xml...\n\n\n    if (char === '!') {\n      if (source.slice(i + 1, i + 3) === '--') {\n        return comment;\n      }\n\n      if (source.slice(i + 1, i + 8) === '[CDATA[') {\n        return cdata;\n      }\n\n      if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n        return neutral;\n      }\n    }\n\n    if (char === '/') {\n      return closingTag;\n    }\n\n    var tagName = getName();\n    var element = {\n      type: 'element',\n      tagName: tagName,\n      properties: {},\n      children: []\n    };\n\n    if (currentElement) {\n      currentElement.children.push(element);\n    } else {\n      root = element;\n    }\n\n    var attribute;\n\n    while (i < source.length && (attribute = getAttribute())) {\n      element.properties[attribute.name] = attribute.value;\n    }\n\n    var selfClosing = false;\n\n    if (source[i] === '/') {\n      i += 1;\n      selfClosing = true;\n    }\n\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n\n    if (!selfClosing) {\n      currentElement = element;\n      stack.push(element);\n    }\n\n    return neutral;\n  }\n\n  function comment() {\n    var index = source.indexOf('-->', i);\n\n    if (!~index) {\n      error('expected -->');\n    }\n\n    i = index + 2;\n    return neutral;\n  }\n\n  function cdata() {\n    var index = source.indexOf(']]>', i);\n\n    if (!~index) {\n      error('expected ]]>');\n    }\n\n    currentElement.children.push(source.slice(i + 7, index));\n    i = index + 2;\n    return neutral;\n  }\n\n  function closingTag() {\n    var tagName = getName();\n\n    if (!tagName) {\n      error('Expected tag name');\n    }\n\n    if (tagName !== currentElement.tagName) {\n      error(\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + currentElement.tagName + \">\");\n    }\n\n    allowSpaces();\n\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n\n    stack.pop();\n    currentElement = stack[stack.length - 1];\n    return neutral;\n  }\n\n  function getName() {\n    var name = '';\n\n    while (i < source.length && validNameCharacters.test(source[i])) {\n      name += source[i++];\n    }\n\n    return name;\n  }\n\n  function getAttribute() {\n    if (!whitespace.test(source[i])) {\n      return null;\n    }\n\n    allowSpaces();\n    var name = getName();\n\n    if (!name) {\n      return null;\n    }\n\n    var value = true;\n    allowSpaces();\n\n    if (source[i] === '=') {\n      i += 1;\n      allowSpaces();\n      value = getAttributeValue();\n\n      if (!isNaN(value) && value.trim() !== '') {\n        value = +value;\n      } // TODO whitelist numeric attributes?\n\n    }\n\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  function getAttributeValue() {\n    return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n  }\n\n  function getUnquotedAttributeValue() {\n    var value = '';\n\n    do {\n      var char = source[i];\n\n      if (char === ' ' || char === '>' || char === '/') {\n        return value;\n      }\n\n      value += char;\n      i += 1;\n    } while (i < source.length);\n\n    return value;\n  }\n\n  function getQuotedAttributeValue() {\n    var quotemark = source[i++];\n    var value = '';\n    var escaped = false;\n\n    while (i < source.length) {\n      var char = source[i++];\n\n      if (char === quotemark && !escaped) {\n        return value;\n      }\n\n      if (char === '\\\\' && !escaped) {\n        escaped = true;\n      }\n\n      value += escaped ? \"\\\\\" + char : char;\n      escaped = false;\n    }\n  }\n\n  function allowSpaces() {\n    while (i < source.length && whitespace.test(source[i])) {\n      i += 1;\n    }\n  }\n\n  var i = metadata.length;\n\n  while (i < source.length) {\n    if (!state) {\n      error('Unexpected character');\n    }\n\n    state = state();\n    i += 1;\n  }\n\n  if (state !== neutral) {\n    error('Unexpected end of input');\n  }\n\n  if (root.tagName === 'svg') {\n    root.metadata = header;\n  }\n\n  return {\n    type: 'root',\n    children: [root]\n  };\n}\n\nexport { parse };","map":{"version":3,"sources":["../node_modules/locate-character/dist/locate-character.es.js","../src/index.js"],"names":["const","let"],"mappings":"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","sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues â€“ thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}