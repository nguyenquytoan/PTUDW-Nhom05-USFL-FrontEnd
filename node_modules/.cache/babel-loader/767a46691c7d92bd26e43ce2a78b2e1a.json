{"ast":null,"code":"/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst assert = require(\"assert\");\n\nconst path = require(\"path\");\n\nconst util = require(\"util\");\n\nconst {\n  Minimatch\n} = require(\"minimatch\");\n\nconst minimatchOpts = {\n  dot: true,\n  matchBase: true\n};\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\n\nfunction normalizePatterns(patterns) {\n  if (Array.isArray(patterns)) {\n    return patterns.filter(Boolean);\n  }\n\n  if (typeof patterns === \"string\" && patterns) {\n    return [patterns];\n  }\n\n  return [];\n}\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\n\n\nfunction toMatcher(patterns) {\n  if (patterns.length === 0) {\n    return null;\n  }\n\n  return patterns.map(pattern => {\n    if (/^\\.[/\\\\]/u.test(pattern)) {\n      return new Minimatch(pattern.slice(2), // `./*.js` should not match with `subdir/foo.js`\n      { ...minimatchOpts,\n        matchBase: false\n      });\n    }\n\n    return new Minimatch(pattern, minimatchOpts);\n  });\n}\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\n\n\nfunction patternToJson({\n  includes,\n  excludes\n}) {\n  return {\n    includes: includes && includes.map(m => m.pattern),\n    excludes: excludes && excludes.map(m => m.pattern)\n  };\n}\n/**\n * The class to test given paths are matched by the patterns.\n */\n\n\nclass OverrideTester {\n  /**\n   * Create a tester with given criteria.\n   * If there are no criteria, returns `null`.\n   * @param {string|string[]} files The glob patterns for included files.\n   * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n   * @param {string} basePath The path to the base directory to test paths.\n   * @returns {OverrideTester|null} The created instance or `null`.\n   */\n  static create(files, excludedFiles, basePath) {\n    const includePatterns = normalizePatterns(files);\n    const excludePatterns = normalizePatterns(excludedFiles);\n    const allPatterns = includePatterns.concat(excludePatterns);\n\n    if (allPatterns.length === 0) {\n      return null;\n    } // Rejects absolute paths or relative paths to parents.\n\n\n    for (const pattern of allPatterns) {\n      if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n        throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n      }\n    }\n\n    const includes = toMatcher(includePatterns);\n    const excludes = toMatcher(excludePatterns);\n    return new OverrideTester([{\n      includes,\n      excludes\n    }], basePath);\n  }\n  /**\n   * Combine two testers by logical and.\n   * If either of the testers was `null`, returns the other tester.\n   * The `basePath` property of the two must be the same value.\n   * @param {OverrideTester|null} a A tester.\n   * @param {OverrideTester|null} b Another tester.\n   * @returns {OverrideTester|null} Combined tester.\n   */\n\n\n  static and(a, b) {\n    if (!b) {\n      return a && new OverrideTester(a.patterns, a.basePath);\n    }\n\n    if (!a) {\n      return new OverrideTester(b.patterns, b.basePath);\n    }\n\n    assert.strictEqual(a.basePath, b.basePath);\n    return new OverrideTester(a.patterns.concat(b.patterns), a.basePath);\n  }\n  /**\n   * Initialize this instance.\n   * @param {Pattern[]} patterns The matchers.\n   * @param {string} basePath The base path.\n   */\n\n\n  constructor(patterns, basePath) {\n    /** @type {Pattern[]} */\n    this.patterns = patterns;\n    /** @type {string} */\n\n    this.basePath = basePath;\n  }\n  /**\n   * Test if a given path is matched or not.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {boolean} `true` if the path was matched.\n   */\n\n\n  test(filePath) {\n    if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n      throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n    }\n\n    const relativePath = path.relative(this.basePath, filePath);\n    return this.patterns.every(({\n      includes,\n      excludes\n    }) => (!includes || includes.some(m => m.match(relativePath))) && (!excludes || !excludes.some(m => m.match(relativePath))));\n  } // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @returns {Object} a JSON compatible object.\n   */\n\n\n  toJSON() {\n    if (this.patterns.length === 1) {\n      return { ...patternToJson(this.patterns[0]),\n        basePath: this.basePath\n      };\n    }\n\n    return {\n      AND: this.patterns.map(patternToJson),\n      basePath: this.basePath\n    };\n  } // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @returns {Object} an object to display by `console.log()`.\n   */\n\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = {\n  OverrideTester\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/cli-engine/config-array/override-tester.js"],"names":["assert","require","path","util","Minimatch","minimatchOpts","dot","matchBase","normalizePatterns","patterns","Array","isArray","filter","Boolean","toMatcher","length","map","pattern","test","slice","patternToJson","includes","excludes","m","OverrideTester","create","files","excludedFiles","basePath","includePatterns","excludePatterns","allPatterns","concat","isAbsolute","Error","and","a","b","strictEqual","constructor","filePath","relativePath","relative","every","some","match","toJSON","AND","inspect","custom","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst util = require(\"util\");\nconst { Minimatch } = require(\"minimatch\");\nconst minimatchOpts = { dot: true, matchBase: true };\n\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\nfunction normalizePatterns(patterns) {\n    if (Array.isArray(patterns)) {\n        return patterns.filter(Boolean);\n    }\n    if (typeof patterns === \"string\" && patterns) {\n        return [patterns];\n    }\n    return [];\n}\n\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\nfunction toMatcher(patterns) {\n    if (patterns.length === 0) {\n        return null;\n    }\n    return patterns.map(pattern => {\n        if (/^\\.[/\\\\]/u.test(pattern)) {\n            return new Minimatch(\n                pattern.slice(2),\n\n                // `./*.js` should not match with `subdir/foo.js`\n                { ...minimatchOpts, matchBase: false }\n            );\n        }\n        return new Minimatch(pattern, minimatchOpts);\n    });\n}\n\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\nfunction patternToJson({ includes, excludes }) {\n    return {\n        includes: includes && includes.map(m => m.pattern),\n        excludes: excludes && excludes.map(m => m.pattern)\n    };\n}\n\n/**\n * The class to test given paths are matched by the patterns.\n */\nclass OverrideTester {\n\n    /**\n     * Create a tester with given criteria.\n     * If there are no criteria, returns `null`.\n     * @param {string|string[]} files The glob patterns for included files.\n     * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n     * @param {string} basePath The path to the base directory to test paths.\n     * @returns {OverrideTester|null} The created instance or `null`.\n     */\n    static create(files, excludedFiles, basePath) {\n        const includePatterns = normalizePatterns(files);\n        const excludePatterns = normalizePatterns(excludedFiles);\n        const allPatterns = includePatterns.concat(excludePatterns);\n\n        if (allPatterns.length === 0) {\n            return null;\n        }\n\n        // Rejects absolute paths or relative paths to parents.\n        for (const pattern of allPatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n        }\n\n        const includes = toMatcher(includePatterns);\n        const excludes = toMatcher(excludePatterns);\n\n        return new OverrideTester([{ includes, excludes }], basePath);\n    }\n\n    /**\n     * Combine two testers by logical and.\n     * If either of the testers was `null`, returns the other tester.\n     * The `basePath` property of the two must be the same value.\n     * @param {OverrideTester|null} a A tester.\n     * @param {OverrideTester|null} b Another tester.\n     * @returns {OverrideTester|null} Combined tester.\n     */\n    static and(a, b) {\n        if (!b) {\n            return a && new OverrideTester(a.patterns, a.basePath);\n        }\n        if (!a) {\n            return new OverrideTester(b.patterns, b.basePath);\n        }\n\n        assert.strictEqual(a.basePath, b.basePath);\n        return new OverrideTester(a.patterns.concat(b.patterns), a.basePath);\n    }\n\n    /**\n     * Initialize this instance.\n     * @param {Pattern[]} patterns The matchers.\n     * @param {string} basePath The base path.\n     */\n    constructor(patterns, basePath) {\n\n        /** @type {Pattern[]} */\n        this.patterns = patterns;\n\n        /** @type {string} */\n        this.basePath = basePath;\n    }\n\n    /**\n     * Test if a given path is matched or not.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the path was matched.\n     */\n    test(filePath) {\n        if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n            throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n        }\n        const relativePath = path.relative(this.basePath, filePath);\n\n        return this.patterns.every(({ includes, excludes }) => (\n            (!includes || includes.some(m => m.match(relativePath))) &&\n            (!excludes || !excludes.some(m => m.match(relativePath)))\n        ));\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        if (this.patterns.length === 1) {\n            return {\n                ...patternToJson(this.patterns[0]),\n                basePath: this.basePath\n            };\n        }\n        return {\n            AND: this.patterns.map(patternToJson),\n            basePath: this.basePath\n        };\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        return this.toJSON();\n    }\n}\n\nmodule.exports = { OverrideTester };\n"]},"metadata":{},"sourceType":"script"}