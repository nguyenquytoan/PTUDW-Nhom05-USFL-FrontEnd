{"ast":null,"code":"/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\nexport const SCHEMES = {};\nexport function pctEncChar(chr) {\n  const c = chr.charCodeAt(0);\n  let e;\n  if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n  return e;\n}\nexport function pctDecChars(str) {\n  let newStr = \"\";\n  let i = 0;\n  const il = str.length;\n\n  while (i < il) {\n    const c = parseInt(str.substr(i + 1, 2), 16);\n\n    if (c < 128) {\n      newStr += String.fromCharCode(c);\n      i += 3;\n    } else if (c >= 194 && c < 224) {\n      if (il - i >= 6) {\n        const c2 = parseInt(str.substr(i + 4, 2), 16);\n        newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n      } else {\n        newStr += str.substr(i, 6);\n      }\n\n      i += 6;\n    } else if (c >= 224) {\n      if (il - i >= 9) {\n        const c2 = parseInt(str.substr(i + 4, 2), 16);\n        const c3 = parseInt(str.substr(i + 7, 2), 16);\n        newStr += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n      } else {\n        newStr += str.substr(i, 9);\n      }\n\n      i += 9;\n    } else {\n      newStr += str.substr(i, 3);\n      i += 3;\n    }\n  }\n\n  return newStr;\n}\n\nfunction _normalizeComponentEncoding(components, protocol) {\n  function decodeUnreserved(str) {\n    const decStr = pctDecChars(str);\n    return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n  }\n\n  if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n  if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n  return components;\n}\n\n;\n\nfunction _stripLeadingZeros(str) {\n  return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host, protocol) {\n  const matches = host.match(protocol.IPV4ADDRESS) || [];\n  const [, address] = matches;\n\n  if (address) {\n    return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n  } else {\n    return host;\n  }\n}\n\nfunction _normalizeIPv6(host, protocol) {\n  const matches = host.match(protocol.IPV6ADDRESS) || [];\n  const [, address, zone] = matches;\n\n  if (address) {\n    const [last, first] = address.toLowerCase().split('::').reverse();\n    const firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n    const lastFields = last.split(\":\").map(_stripLeadingZeros);\n    const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n    const fieldCount = isLastFieldIPv4Address ? 7 : 8;\n    const lastFieldsStart = lastFields.length - fieldCount;\n    const fields = Array(fieldCount);\n\n    for (let x = 0; x < fieldCount; ++x) {\n      fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n    }\n\n    if (isLastFieldIPv4Address) {\n      fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n    }\n\n    const allZeroFields = fields.reduce((acc, field, index) => {\n      if (!field || field === \"0\") {\n        const lastLongest = acc[acc.length - 1];\n\n        if (lastLongest && lastLongest.index + lastLongest.length === index) {\n          lastLongest.length++;\n        } else {\n          acc.push({\n            index,\n            length: 1\n          });\n        }\n      }\n\n      return acc;\n    }, []);\n    const longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n    let newHost;\n\n    if (longestZeroFields && longestZeroFields.length > 1) {\n      const newFirst = fields.slice(0, longestZeroFields.index);\n      const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n      newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n    } else {\n      newHost = fields.join(\":\");\n    }\n\n    if (zone) {\n      newHost += \"%\" + zone;\n    }\n\n    return newHost;\n  } else {\n    return host;\n  }\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nexport function parse(uriString, options = {}) {\n  const components = {};\n  const protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n  if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n  const matches = uriString.match(URI_PARSE);\n\n  if (matches) {\n    if (NO_MATCH_IS_UNDEFINED) {\n      //store each component\n      components.scheme = matches[1];\n      components.userinfo = matches[3];\n      components.host = matches[4];\n      components.port = parseInt(matches[5], 10);\n      components.path = matches[6] || \"\";\n      components.query = matches[7];\n      components.fragment = matches[8]; //fix port number\n\n      if (isNaN(components.port)) {\n        components.port = matches[5];\n      }\n    } else {\n      //IE FIX for improper RegExp matching\n      //store each component\n      components.scheme = matches[1] || undefined;\n      components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n      components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n      components.port = parseInt(matches[5], 10);\n      components.path = matches[6] || \"\";\n      components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n      components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined; //fix port number\n\n      if (isNaN(components.port)) {\n        components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n      }\n    }\n\n    if (components.host) {\n      //normalize IP hosts\n      components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n    } //determine reference type\n\n\n    if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n      components.reference = \"same-document\";\n    } else if (components.scheme === undefined) {\n      components.reference = \"relative\";\n    } else if (components.fragment === undefined) {\n      components.reference = \"absolute\";\n    } else {\n      components.reference = \"uri\";\n    } //check for reference errors\n\n\n    if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n      components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n    } //find scheme handler\n\n\n    const schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()]; //check if scheme can't handle IRIs\n\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      //if host component is a domain name\n      if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n        //convert Unicode IDN -> ASCII IDN\n        try {\n          components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n        } catch (e) {\n          components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n        }\n      } //convert IRI -> URI\n\n\n      _normalizeComponentEncoding(components, URI_PROTOCOL);\n    } else {\n      //normalize encodings\n      _normalizeComponentEncoding(components, protocol);\n    } //perform scheme specific parsing\n\n\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(components, options);\n    }\n  } else {\n    components.error = components.error || \"URI can not be parsed.\";\n  }\n\n  return components;\n}\n;\n\nfunction _recomposeAuthority(components, options) {\n  const protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n  const uriTokens = [];\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo);\n    uriTokens.push(\"@\");\n  }\n\n  if (components.host !== undefined) {\n    //normalize IP hosts, add brackets and escape zone separator for IPv6\n    uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n  }\n\n  if (typeof components.port === \"number\") {\n    uriTokens.push(\":\");\n    uriTokens.push(components.port.toString(10));\n  }\n\n  return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\n;\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nexport function removeDotSegments(input) {\n  const output = [];\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, \"\");\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, \"/\");\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, \"/\");\n      output.pop();\n    } else if (input === \".\" || input === \"..\") {\n      input = \"\";\n    } else {\n      const im = input.match(RDS5);\n\n      if (im) {\n        const s = im[0];\n        input = input.slice(s.length);\n        output.push(s);\n      } else {\n        throw new Error(\"Unexpected dot segment condition\");\n      }\n    }\n  }\n\n  return output.join(\"\");\n}\n;\nexport function serialize(components, options = {}) {\n  const protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n  const uriTokens = []; //find scheme handler\n\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()]; //perform scheme specific serialization\n\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n  if (components.host) {\n    //if host component is an IPv6 address\n    if (protocol.IPV6ADDRESS.test(components.host)) {} //TODO: normalize IPv6 address as per RFC 5952\n    //if host component is a domain name\n    else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n        //convert IDN via punycode\n        try {\n          components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n        } catch (e) {\n          components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n        }\n      }\n  } //normalize encoding\n\n\n  _normalizeComponentEncoding(components, protocol);\n\n  if (options.reference !== \"suffix\" && components.scheme) {\n    uriTokens.push(components.scheme);\n    uriTokens.push(\":\");\n  }\n\n  const authority = _recomposeAuthority(components, options);\n\n  if (authority !== undefined) {\n    if (options.reference !== \"suffix\") {\n      uriTokens.push(\"//\");\n    }\n\n    uriTokens.push(authority);\n\n    if (components.path && components.path.charAt(0) !== \"/\") {\n      uriTokens.push(\"/\");\n    }\n  }\n\n  if (components.path !== undefined) {\n    let s = components.path;\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s);\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s);\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push(\"?\");\n    uriTokens.push(components.query);\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push(\"#\");\n    uriTokens.push(components.fragment);\n  }\n\n  return uriTokens.join(\"\"); //merge tokens into a string\n}\n;\nexport function resolveComponents(base, relative, options = {}, skipNormalization) {\n  const target = {};\n\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options); //normalize base components\n\n    relative = parse(serialize(relative, options), options); //normalize relative components\n  }\n\n  options = options || {};\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme; //target.authority = relative.authority;\n\n    target.userinfo = relative.userinfo;\n    target.host = relative.host;\n    target.port = relative.port;\n    target.path = removeDotSegments(relative.path || \"\");\n    target.query = relative.query;\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      //target.authority = relative.authority;\n      target.userinfo = relative.userinfo;\n      target.host = relative.host;\n      target.port = relative.port;\n      target.path = removeDotSegments(relative.path || \"\");\n      target.query = relative.query;\n    } else {\n      if (!relative.path) {\n        target.path = base.path;\n\n        if (relative.query !== undefined) {\n          target.query = relative.query;\n        } else {\n          target.query = base.query;\n        }\n      } else {\n        if (relative.path.charAt(0) === \"/\") {\n          target.path = removeDotSegments(relative.path);\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = \"/\" + relative.path;\n          } else if (!base.path) {\n            target.path = relative.path;\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n          }\n\n          target.path = removeDotSegments(target.path);\n        }\n\n        target.query = relative.query;\n      } //target.authority = base.authority;\n\n\n      target.userinfo = base.userinfo;\n      target.host = base.host;\n      target.port = base.port;\n    }\n\n    target.scheme = base.scheme;\n  }\n\n  target.fragment = relative.fragment;\n  return target;\n}\n;\nexport function resolve(baseURI, relativeURI, options) {\n  const schemelessOptions = assign({\n    scheme: 'null'\n  }, options);\n  return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n;\nexport function normalize(uri, options) {\n  if (typeof uri === \"string\") {\n    uri = serialize(parse(uri, options), options);\n  } else if (typeOf(uri) === \"object\") {\n    uri = parse(serialize(uri, options), options);\n  }\n\n  return uri;\n}\n;\nexport function equal(uriA, uriB, options) {\n  if (typeof uriA === \"string\") {\n    uriA = serialize(parse(uriA, options), options);\n  } else if (typeOf(uriA) === \"object\") {\n    uriA = serialize(uriA, options);\n  }\n\n  if (typeof uriB === \"string\") {\n    uriB = serialize(parse(uriB, options), options);\n  } else if (typeOf(uriB) === \"object\") {\n    uriB = serialize(uriB, options);\n  }\n\n  return uriA === uriB;\n}\n;\nexport function escapeComponent(str, options) {\n  return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n;\nexport function unescapeComponent(str, options) {\n  return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n;","map":{"version":3,"sources":["../../src/uri.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\nexport const SCHEMES = {};\nexport function pctEncChar(chr) {\n    const c = chr.charCodeAt(0);\n    let e;\n    if (c < 16)\n        e = \"%0\" + c.toString(16).toUpperCase();\n    else if (c < 128)\n        e = \"%\" + c.toString(16).toUpperCase();\n    else if (c < 2048)\n        e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n    else\n        e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n    return e;\n}\nexport function pctDecChars(str) {\n    let newStr = \"\";\n    let i = 0;\n    const il = str.length;\n    while (i < il) {\n        const c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        }\n        else if (c >= 194 && c < 224) {\n            if ((il - i) >= 6) {\n                const c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n            }\n            else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        }\n        else if (c >= 224) {\n            if ((il - i) >= 9) {\n                const c2 = parseInt(str.substr(i + 4, 2), 16);\n                const c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n            }\n            else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        }\n        else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        const decStr = pctDecChars(str);\n        return (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n    }\n    if (components.scheme)\n        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined)\n        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined)\n        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined)\n        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined)\n        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined)\n        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n;\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    const matches = host.match(protocol.IPV4ADDRESS) || [];\n    const [, address] = matches;\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    }\n    else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    const matches = host.match(protocol.IPV6ADDRESS) || [];\n    const [, address, zone] = matches;\n    if (address) {\n        const [last, first] = address.toLowerCase().split('::').reverse();\n        const firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        const lastFields = last.split(\":\").map(_stripLeadingZeros);\n        const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        const fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        const lastFieldsStart = lastFields.length - fieldCount;\n        const fields = Array(fieldCount);\n        for (let x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        const allZeroFields = fields.reduce((acc, field, index) => {\n            if (!field || field === \"0\") {\n                const lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                }\n                else {\n                    acc.push({ index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        const longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n        let newHost;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            const newFirst = fields.slice(0, longestZeroFields.index);\n            const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        }\n        else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    }\n    else {\n        return host;\n    }\n}\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (\"\").match(/(){0}/)[1] === undefined;\nexport function parse(uriString, options = {}) {\n    const components = {};\n    const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n    if (options.reference === \"suffix\")\n        uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    const matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        }\n        else { //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n            components.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n            components.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        }\n        else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        }\n        else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        }\n        else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        const schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                }\n                catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        }\n        else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    }\n    else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n;\nfunction _recomposeAuthority(components, options) {\n    const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n    const uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n    }\n    if (typeof components.port === \"number\") {\n        uriTokens.push(\":\");\n        uriTokens.push(components.port.toString(10));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n;\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nexport function removeDotSegments(input) {\n    const output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        }\n        else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        }\n        else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        }\n        else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        }\n        else {\n            const im = input.match(RDS5);\n            if (im) {\n                const s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            }\n            else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n;\nexport function serialize(components, options = {}) {\n    const protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n    const uriTokens = [];\n    //find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize)\n        schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {\n            //TODO: normalize IPv6 address as per RFC 5952\n        }\n        //if host component is a domain name\n        else if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n            //convert IDN via punycode\n            try {\n                components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n            }\n            catch (e) {\n                components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n            }\n        }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    const authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        let s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n;\nexport function resolveComponents(base, relative, options = {}, skipNormalization) {\n    const target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    }\n    else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        }\n        else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                }\n                else {\n                    target.query = base.query;\n                }\n            }\n            else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                }\n                else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    }\n                    else if (!base.path) {\n                        target.path = relative.path;\n                    }\n                    else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n;\nexport function resolve(baseURI, relativeURI, options) {\n    const schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n;\nexport function normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    }\n    else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n;\nexport function equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    }\n    else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    }\n    else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n;\nexport function escapeComponent(str, options) {\n    return str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n}\n;\nexport function unescapeComponent(str, options) {\n    return str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n}\n;\n//# sourceMappingURL=uri.js.map"]},"metadata":{},"sourceType":"module"}