{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst chalk = require('chalk');\n\nconst stripAnsi = require('strip-ansi');\n\nconst table = require('text-table');\n\nfunction isError(message) {\n  if (message.fatal || message.severity === 2) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction formatter(results) {\n  let output = '\\n';\n  let hasErrors = false;\n  let reportContainsErrorRuleIDs = false;\n  results.forEach(result => {\n    let messages = result.messages;\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    messages = messages.map(message => {\n      let messageType;\n\n      if (isError(message)) {\n        messageType = 'error';\n        hasErrors = true;\n\n        if (message.ruleId) {\n          reportContainsErrorRuleIDs = true;\n        }\n      } else {\n        messageType = 'warn';\n      }\n\n      let line = message.line || 0;\n\n      if (message.column) {\n        line += ':' + message.column;\n      }\n\n      let position = chalk.bold('Line ' + line + ':');\n      return ['', position, messageType, message.message.replace(/\\.$/, ''), chalk.underline(message.ruleId || '')];\n    }); // if there are error messages, we want to show only errors\n\n    if (hasErrors) {\n      messages = messages.filter(m => m[2] === 'error');\n    } // add color to rule keywords\n\n\n    messages.forEach(m => {\n      m[4] = m[2] === 'error' ? chalk.red(m[4]) : chalk.yellow(m[4]);\n      m.splice(2, 1);\n    });\n    let outputTable = table(messages, {\n      align: ['l', 'l', 'l'],\n\n      stringLength(str) {\n        return stripAnsi(str).length;\n      }\n\n    });\n    output += `${outputTable}\\n\\n`;\n  });\n\n  if (reportContainsErrorRuleIDs) {\n    // Unlike with warnings, we have to do it here.\n    // We have similar code in react-scripts for warnings,\n    // but warnings can appear in multiple files so we only\n    // print it once at the end. For errors, however, we print\n    // it here because we always show at most one error, and\n    // we can only be sure it's an ESLint error before exiting\n    // this function.\n    output += 'Search for the ' + chalk.underline(chalk.red('keywords')) + ' to learn more about each error.';\n  }\n\n  return output;\n}\n\nmodule.exports = formatter;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/react-dev-utils/eslintFormatter.js"],"names":["chalk","require","stripAnsi","table","isError","message","fatal","severity","formatter","results","output","hasErrors","reportContainsErrorRuleIDs","forEach","result","messages","length","map","messageType","ruleId","line","column","position","bold","replace","underline","filter","m","red","yellow","splice","outputTable","align","stringLength","str","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst chalk = require('chalk');\nconst stripAnsi = require('strip-ansi');\nconst table = require('text-table');\n\nfunction isError(message) {\n  if (message.fatal || message.severity === 2) {\n    return true;\n  }\n  return false;\n}\n\nfunction formatter(results) {\n  let output = '\\n';\n  let hasErrors = false;\n  let reportContainsErrorRuleIDs = false;\n\n  results.forEach(result => {\n    let messages = result.messages;\n    if (messages.length === 0) {\n      return;\n    }\n\n    messages = messages.map(message => {\n      let messageType;\n      if (isError(message)) {\n        messageType = 'error';\n        hasErrors = true;\n        if (message.ruleId) {\n          reportContainsErrorRuleIDs = true;\n        }\n      } else {\n        messageType = 'warn';\n      }\n\n      let line = message.line || 0;\n      if (message.column) {\n        line += ':' + message.column;\n      }\n      let position = chalk.bold('Line ' + line + ':');\n      return [\n        '',\n        position,\n        messageType,\n        message.message.replace(/\\.$/, ''),\n        chalk.underline(message.ruleId || ''),\n      ];\n    });\n\n    // if there are error messages, we want to show only errors\n    if (hasErrors) {\n      messages = messages.filter(m => m[2] === 'error');\n    }\n\n    // add color to rule keywords\n    messages.forEach(m => {\n      m[4] = m[2] === 'error' ? chalk.red(m[4]) : chalk.yellow(m[4]);\n      m.splice(2, 1);\n    });\n\n    let outputTable = table(messages, {\n      align: ['l', 'l', 'l'],\n      stringLength(str) {\n        return stripAnsi(str).length;\n      },\n    });\n\n    output += `${outputTable}\\n\\n`;\n  });\n\n  if (reportContainsErrorRuleIDs) {\n    // Unlike with warnings, we have to do it here.\n    // We have similar code in react-scripts for warnings,\n    // but warnings can appear in multiple files so we only\n    // print it once at the end. For errors, however, we print\n    // it here because we always show at most one error, and\n    // we can only be sure it's an ESLint error before exiting\n    // this function.\n    output +=\n      'Search for the ' +\n      chalk.underline(chalk.red('keywords')) +\n      ' to learn more about each error.';\n  }\n\n  return output;\n}\n\nmodule.exports = formatter;\n"]},"metadata":{},"sourceType":"script"}