{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = tokenize;\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar t = _interopRequireWildcard(_tokenTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar wordEnd = /[ \\n\\t\\r\\(\\)\\*:;!&'\"\\+\\|~>,=$^\\[\\]\\\\]|\\/(?=\\*)/g;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code = void 0,\n      content = void 0,\n      endColumn = void 0,\n      endLine = void 0,\n      escaped = void 0,\n      escapePos = void 0,\n      last = void 0,\n      lines = void 0,\n      next = void 0,\n      nextLine = void 0,\n      nextOffset = void 0,\n      quote = void 0,\n      tokenType = void 0;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.newline:\n      case t.space:\n      case t.tab:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.backslash:\n        next = start;\n        escaped = true;\n\n        while (css.charCodeAt(next + 1) === t.backslash) {\n          next += 1;\n          escaped = !escaped;\n        }\n\n        code = css.charCodeAt(next + 1);\n\n        if (escaped && code !== t.slash && code !== t.space && code !== t.newline && code !== t.tab && code !== t.cr && code !== t.feed) {\n          next += 1;\n        }\n\n        tokenType = t.word;\n        endLine = line;\n        endColumn = next - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else {\n          wordEnd.lastIndex = start + 1;\n          wordEnd.test(css);\n\n          if (wordEnd.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = wordEnd.lastIndex - 2;\n          }\n\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end] // [6] End position\n    ); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-minify-selectors/node_modules/postcss-selector-parser/dist/tokenize.js"],"names":["exports","__esModule","default","tokenize","_tokenTypes","require","t","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","wordEnd","input","tokens","css","valueOf","_css","length","offset","line","start","end","code","content","endColumn","endLine","escaped","escapePos","last","lines","next","nextLine","nextOffset","quote","tokenType","unclosed","what","fix","safe","error","charCodeAt","newline","space","tab","cr","feed","plus","greaterThan","tilde","pipe","combinator","asterisk","ampersand","comma","equals","dollar","caret","openSquare","closeSquare","colon","semicolon","openParenthesis","closeParenthesis","singleQuote","doubleQuote","indexOf","backslash","str","slash","word","slice","split","comment","lastIndex","test","push","module"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.default = tokenize;\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar t = _interopRequireWildcard(_tokenTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar wordEnd = /[ \\n\\t\\r\\(\\)\\*:;!&'\"\\+\\|~>,=$^\\[\\]\\\\]|\\/(?=\\*)/g;\n\nfunction tokenize(input) {\n    var tokens = [];\n    var css = input.css.valueOf();\n    var _css = css,\n        length = _css.length;\n\n    var offset = -1;\n    var line = 1;\n    var start = 0;\n    var end = 0;\n\n    var code = void 0,\n        content = void 0,\n        endColumn = void 0,\n        endLine = void 0,\n        escaped = void 0,\n        escapePos = void 0,\n        last = void 0,\n        lines = void 0,\n        next = void 0,\n        nextLine = void 0,\n        nextOffset = void 0,\n        quote = void 0,\n        tokenType = void 0;\n\n    function unclosed(what, fix) {\n        if (input.safe) {\n            // fyi: this is never set to true.\n            css += fix;\n            next = css.length - 1;\n        } else {\n            throw input.error('Unclosed ' + what, line, start - offset, start);\n        }\n    }\n\n    while (start < length) {\n        code = css.charCodeAt(start);\n\n        if (code === t.newline) {\n            offset = start;\n            line += 1;\n        }\n\n        switch (code) {\n            case t.newline:\n            case t.space:\n            case t.tab:\n            case t.cr:\n            case t.feed:\n                next = start;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                    if (code === t.newline) {\n                        offset = next;\n                        line += 1;\n                    }\n                } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n                tokenType = t.space;\n                endLine = line;\n                endColumn = start - offset;\n                end = next;\n                break;\n\n            case t.plus:\n            case t.greaterThan:\n            case t.tilde:\n            case t.pipe:\n                next = start;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n                tokenType = t.combinator;\n                endLine = line;\n                endColumn = start - offset;\n                end = next;\n                break;\n\n            // Consume these characters as single tokens.\n            case t.asterisk:\n            case t.ampersand:\n            case t.comma:\n            case t.equals:\n            case t.dollar:\n            case t.caret:\n            case t.openSquare:\n            case t.closeSquare:\n            case t.colon:\n            case t.semicolon:\n            case t.openParenthesis:\n            case t.closeParenthesis:\n                next = start;\n                tokenType = code;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n                break;\n\n            case t.singleQuote:\n            case t.doubleQuote:\n                quote = code === t.singleQuote ? \"'\" : '\"';\n                next = start;\n                do {\n                    escaped = false;\n                    next = css.indexOf(quote, next + 1);\n                    if (next === -1) {\n                        unclosed('quote', quote);\n                    }\n                    escapePos = next;\n                    while (css.charCodeAt(escapePos - 1) === t.backslash) {\n                        escapePos -= 1;\n                        escaped = !escaped;\n                    }\n                } while (escaped);\n\n                tokenType = t.str;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n                break;\n\n            case t.backslash:\n                next = start;\n                escaped = true;\n                while (css.charCodeAt(next + 1) === t.backslash) {\n                    next += 1;\n                    escaped = !escaped;\n                }\n                code = css.charCodeAt(next + 1);\n                if (escaped && code !== t.slash && code !== t.space && code !== t.newline && code !== t.tab && code !== t.cr && code !== t.feed) {\n                    next += 1;\n                }\n\n                tokenType = t.word;\n                endLine = line;\n                endColumn = next - offset;\n                end = next + 1;\n                break;\n\n            default:\n                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n                    next = css.indexOf('*/', start + 2) + 1;\n                    if (next === 0) {\n                        unclosed('comment', '*/');\n                    }\n\n                    content = css.slice(start, next + 1);\n                    lines = content.split('\\n');\n                    last = lines.length - 1;\n\n                    if (last > 0) {\n                        nextLine = line + last;\n                        nextOffset = next - lines[last].length;\n                    } else {\n                        nextLine = line;\n                        nextOffset = offset;\n                    }\n\n                    tokenType = t.comment;\n                    line = nextLine;\n                    endLine = nextLine;\n                    endColumn = next - nextOffset;\n                } else {\n                    wordEnd.lastIndex = start + 1;\n                    wordEnd.test(css);\n                    if (wordEnd.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = wordEnd.lastIndex - 2;\n                    }\n\n                    tokenType = t.word;\n                    endLine = line;\n                    endColumn = next - offset;\n                }\n\n                end = next + 1;\n                break;\n        }\n\n        // Ensure that the token structure remains consistent\n        tokens.push([tokenType, // [0] Token type\n        line, // [1] Starting line\n        start - offset, // [2] Starting column\n        endLine, // [3] Ending line\n        endColumn, // [4] Ending column\n        start, // [5] Start position / Source index\n        end] // [6] End position\n        );\n\n        // Reset offset for the next token\n        if (nextOffset) {\n            offset = nextOffset;\n            nextOffset = null;\n        }\n\n        start = end;\n    }\n\n    return tokens;\n}\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}