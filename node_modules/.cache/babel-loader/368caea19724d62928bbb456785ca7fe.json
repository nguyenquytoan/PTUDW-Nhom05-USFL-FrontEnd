{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\"),\n      keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require quotes around object literal property names\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quote-props\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            keywords: {\n              type: \"boolean\"\n            },\n            unnecessary: {\n              type: \"boolean\"\n            },\n            numbers: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const MODE = context.options[0],\n          KEYWORDS = context.options[1] && context.options[1].keywords,\n          CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n          NUMBERS = context.options[1] && context.options[1].numbers,\n          MESSAGE_UNNECESSARY = \"Unnecessarily quoted property '{{property}}' found.\",\n          MESSAGE_UNQUOTED = \"Unquoted property '{{property}}' found.\",\n          MESSAGE_NUMERIC = \"Unquoted number literal '{{property}}' used as key.\",\n          MESSAGE_RESERVED = \"Unquoted reserved word '{{property}}' used as key.\",\n          sourceCode = context.getSourceCode();\n    /**\n     * Checks whether a certain string constitutes an ES3 token\n     * @param   {string} tokenStr The string to be checked.\n     * @returns {boolean} `true` if it is an ES3 token.\n     */\n\n    function isKeyword(tokenStr) {\n      return keywords.indexOf(tokenStr) >= 0;\n    }\n    /**\n     * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n     * @param   {string} rawKey The raw key value from the source\n     * @param   {espreeTokens} tokens The espree-tokenized node key\n     * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n     * @returns {boolean} Whether or not a key has redundant quotes.\n     * @private\n     */\n\n\n    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 || tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);\n    }\n    /**\n     * Returns a string representation of a property node with quotes removed\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\n     * @returns {string} A replacement string for this property\n     */\n\n\n    function getUnquotedKey(key) {\n      return key.type === \"Identifier\" ? key.name : key.value;\n    }\n    /**\n     * Returns a string representation of a property node with quotes added\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\n     * @returns {string} A replacement string for this property\n     */\n\n\n    function getQuotedKey(key) {\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        // If the key is already a string literal, don't replace the quotes with double quotes.\n        return sourceCode.getText(key);\n      } // Otherwise, the key is either an identifier or a number literal.\n\n\n      return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n    }\n    /**\n     * Ensures that a property's key is quoted only when necessary\n     * @param   {ASTNode} node Property AST node\n     * @returns {void}\n     */\n\n\n    function checkUnnecessaryQuotes(node) {\n      const key = node.key;\n\n      if (node.method || node.computed || node.shorthand) {\n        return;\n      }\n\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        let tokens;\n\n        try {\n          tokens = espree.tokenize(key.value);\n        } catch (e) {\n          return;\n        }\n\n        if (tokens.length !== 1) {\n          return;\n        }\n\n        const isKeywordToken = isKeyword(tokens[0].value);\n\n        if (isKeywordToken && KEYWORDS) {\n          return;\n        }\n\n        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n          context.report({\n            node,\n            message: MESSAGE_UNNECESSARY,\n            data: {\n              property: key.value\n            },\n            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n          });\n        }\n      } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n        context.report({\n          node,\n          message: MESSAGE_RESERVED,\n          data: {\n            property: key.name\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      } else if (NUMBERS && key.type === \"Literal\" && typeof key.value === \"number\") {\n        context.report({\n          node,\n          message: MESSAGE_NUMERIC,\n          data: {\n            property: key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n    /**\n     * Ensures that a property's key is quoted\n     * @param   {ASTNode} node Property AST node\n     * @returns {void}\n     */\n\n\n    function checkOmittedQuotes(node) {\n      const key = node.key;\n\n      if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n        context.report({\n          node,\n          message: MESSAGE_UNQUOTED,\n          data: {\n            property: key.name || key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n    /**\n     * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n     * @param   {ASTNode} node Property AST node\n     * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n     * @returns {void}\n     */\n\n\n    function checkConsistency(node, checkQuotesRedundancy) {\n      const quotedProps = [],\n            unquotedProps = [];\n      let keywordKeyName = null,\n          necessaryQuotes = false;\n      node.properties.forEach(property => {\n        const key = property.key;\n\n        if (!key || property.method || property.computed || property.shorthand) {\n          return;\n        }\n\n        if (key.type === \"Literal\" && typeof key.value === \"string\") {\n          quotedProps.push(property);\n\n          if (checkQuotesRedundancy) {\n            let tokens;\n\n            try {\n              tokens = espree.tokenize(key.value);\n            } catch (e) {\n              necessaryQuotes = true;\n              return;\n            }\n\n            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n          }\n        } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n          unquotedProps.push(property);\n          necessaryQuotes = true;\n          keywordKeyName = key.name;\n        } else {\n          unquotedProps.push(property);\n        }\n      });\n\n      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n        quotedProps.forEach(property => {\n          context.report({\n            node: property,\n            message: \"Properties shouldn't be quoted as all quotes are redundant.\",\n            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n          });\n        });\n      } else if (unquotedProps.length && keywordKeyName) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            message: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n            data: {\n              property: keywordKeyName\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      } else if (quotedProps.length && unquotedProps.length) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            message: \"Inconsistently quoted property '{{key}}' found.\",\n            data: {\n              key: property.key.name || property.key.value\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      }\n    }\n\n    return {\n      Property(node) {\n        if (MODE === \"always\" || !MODE) {\n          checkOmittedQuotes(node);\n        }\n\n        if (MODE === \"as-needed\") {\n          checkUnnecessaryQuotes(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        if (MODE === \"consistent\") {\n          checkConsistency(node, false);\n        }\n\n        if (MODE === \"consistent-as-needed\") {\n          checkConsistency(node, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/quote-props.js"],"names":["espree","require","keywords","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","unnecessary","numbers","additionalProperties","fixable","create","context","MODE","options","KEYWORDS","CHECK_UNNECESSARY","NUMBERS","MESSAGE_UNNECESSARY","MESSAGE_UNQUOTED","MESSAGE_NUMERIC","MESSAGE_RESERVED","sourceCode","getSourceCode","isKeyword","tokenStr","indexOf","areQuotesRedundant","rawKey","tokens","skipNumberLiterals","length","start","end","String","value","getUnquotedKey","key","name","getQuotedKey","getText","checkUnnecessaryQuotes","node","method","computed","shorthand","tokenize","e","isKeywordToken","report","message","data","property","fix","fixer","replaceText","checkOmittedQuotes","checkConsistency","checkQuotesRedundancy","quotedProps","unquotedProps","keywordKeyName","necessaryQuotes","forEach","push","Property","ObjectExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\"),\n    keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quote-props\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            MESSAGE_UNNECESSARY = \"Unnecessarily quoted property '{{property}}' found.\",\n            MESSAGE_UNQUOTED = \"Unquoted property '{{property}}' found.\",\n            MESSAGE_NUMERIC = \"Unquoted number literal '{{property}}' used as key.\",\n            MESSAGE_RESERVED = \"Unquoted reserved word '{{property}}' used as key.\",\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes removed\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes added\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                let tokens;\n\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch (e) {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY,\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    message: MESSAGE_RESERVED,\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && typeof key.value === \"number\") {\n                context.report({\n                    node,\n                    message: MESSAGE_NUMERIC,\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    message: MESSAGE_UNQUOTED,\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        let tokens;\n\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch (e) {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties shouldn't be quoted as all quotes are redundant.\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Inconsistently quoted property '{{key}}' found.\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}