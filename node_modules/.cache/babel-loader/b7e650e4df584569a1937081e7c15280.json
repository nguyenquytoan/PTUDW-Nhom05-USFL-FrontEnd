{"ast":null,"code":"'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function _fbWatchman() {\n    return data;\n  };\n\n  return data;\n}\n\nvar fastPath = _interopRequireWildcard(require('../lib/fast_path'));\n\nvar _normalizePathSep = _interopRequireDefault(require('../lib/normalizePathSep'));\n\nvar _constants = _interopRequireDefault(require('../constants'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting.html';\n\nfunction WatchmanError(error) {\n  error.message = `Watchman error: ${error.message.trim()}. Make sure watchman ` + `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  var _watchmanCrawl = _asyncToGenerator(function* (options) {\n    const fields = ['name', 'exists', 'mtime_ms', 'size'];\n    const data = options.data,\n          extensions = options.extensions,\n          ignore = options.ignore,\n          rootDir = options.rootDir,\n          roots = options.roots;\n    const defaultWatchExpression = ['allof', ['type', 'f'], ['anyof', ...extensions.map(extension => ['suffix', extension])]];\n    const clocks = data.clocks;\n    const client = new (_fbWatchman().default.Client)();\n    let clientError;\n    client.on('error', error => clientError = WatchmanError(error)); // TODO: type better than `any`\n\n    const cmd = (...args) => new Promise((resolve, reject) => client.command(args, (error, result) => error ? reject(WatchmanError(error)) : resolve(result)));\n\n    if (options.computeSha1) {\n      const _ref = yield cmd('list-capabilities'),\n            capabilities = _ref.capabilities;\n\n      if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n        fields.push('content.sha1hex');\n      }\n    }\n\n    function getWatchmanRoots(_x2) {\n      return _getWatchmanRoots.apply(this, arguments);\n    }\n\n    function _getWatchmanRoots() {\n      _getWatchmanRoots = _asyncToGenerator(function* (roots) {\n        const watchmanRoots = new Map();\n        yield Promise.all(roots.map( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (root) {\n            const response = yield cmd('watch-project', root);\n            const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n            // relative_path before.\n\n            const canBeFiltered = !existing || existing.length > 0;\n\n            if (canBeFiltered) {\n              if (response.relative_path) {\n                watchmanRoots.set(response.watch, (existing || []).concat(response.relative_path));\n              } else {\n                // Make the filter directories an empty array to signal that this\n                // root was already seen and needs to be watched for all files or\n                // directories.\n                watchmanRoots.set(response.watch, []);\n              }\n            }\n          });\n\n          return function (_x4) {\n            return _ref2.apply(this, arguments);\n          };\n        }()));\n        return watchmanRoots;\n      });\n      return _getWatchmanRoots.apply(this, arguments);\n    }\n\n    function queryWatchmanForDirs(_x3) {\n      return _queryWatchmanForDirs.apply(this, arguments);\n    }\n\n    function _queryWatchmanForDirs() {\n      _queryWatchmanForDirs = _asyncToGenerator(function* (rootProjectDirMappings) {\n        const files = new Map();\n        let isFresh = false;\n        yield Promise.all(Array.from(rootProjectDirMappings).map( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* ([root, directoryFilters]) {\n            const expression = Array.from(defaultWatchExpression);\n            const glob = [];\n\n            if (directoryFilters.length > 0) {\n              expression.push(['anyof', ...directoryFilters.map(dir => ['dirname', dir])]);\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n\n              try {\n                for (var _iterator2 = directoryFilters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  const directory = _step2.value;\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n\n                  try {\n                    for (var _iterator3 = extensions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      const extension = _step3.value;\n                      glob.push(`${directory}/**/*.${extension}`);\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            } else {\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  const extension = _step4.value;\n                  glob.push(`**/*.${extension}`);\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n            }\n\n            const relativeRoot = fastPath.relative(rootDir, root);\n            const query = clocks.has(relativeRoot) // Use the `since` generator if we have a clock available\n            ? {\n              expression,\n              fields,\n              since: clocks.get(relativeRoot)\n            } // Otherwise use the `glob` filter\n            : {\n              expression,\n              fields,\n              glob\n            };\n            const response = yield cmd('query', root, query);\n\n            if ('warning' in response) {\n              console.warn('watchman warning: ', response.warning);\n            }\n\n            isFresh = isFresh || response.is_fresh_instance;\n            files.set(root, response);\n          });\n\n          return function (_x5) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));\n        return {\n          files,\n          isFresh\n        };\n      });\n      return _queryWatchmanForDirs.apply(this, arguments);\n    }\n\n    let files = data.files;\n    let removedFiles = new Map();\n    const changedFiles = new Map();\n    let watchmanFiles;\n    let isFresh = false;\n\n    try {\n      const watchmanRoots = yield getWatchmanRoots(roots);\n      const watchmanFileResults = yield queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n      // files.\n\n      if (watchmanFileResults.isFresh) {\n        files = new Map();\n        removedFiles = new Map(data.files);\n        isFresh = true;\n      }\n\n      watchmanFiles = watchmanFileResults.files;\n    } finally {\n      client.end();\n    }\n\n    if (clientError) {\n      throw clientError;\n    } // TODO: remove non-null\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = watchmanFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              watchRoot = _step$value[0],\n              response = _step$value[1];\n\n        const fsRoot = (0, _normalizePathSep.default)(watchRoot);\n        const relativeFsRoot = fastPath.relative(rootDir, fsRoot);\n        clocks.set(relativeFsRoot, response.clock);\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = response.files[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            const fileData = _step5.value;\n            const filePath = fsRoot + _path().default.sep + (0, _normalizePathSep.default)(fileData.name);\n            const relativeFilePath = fastPath.relative(rootDir, filePath);\n            const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n            // and we remove them as we verify they still exist.\n\n            if (isFresh && existingFileData && fileData.exists) {\n              removedFiles.delete(relativeFilePath);\n            }\n\n            if (!fileData.exists) {\n              // No need to act on files that do not exist and were not tracked.\n              if (existingFileData) {\n                files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n                // deleted since we last ran and can track only those files.\n\n                if (!isFresh) {\n                  removedFiles.set(relativeFilePath, existingFileData);\n                }\n              }\n            } else if (!ignore(filePath)) {\n              const mtime = typeof fileData.mtime_ms === 'number' ? fileData.mtime_ms : fileData.mtime_ms.toNumber();\n              const size = fileData.size;\n              let sha1hex = fileData['content.sha1hex'];\n\n              if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n                sha1hex = null;\n              }\n\n              let nextData;\n\n              if (existingFileData && existingFileData[_constants.default.MTIME] === mtime) {\n                nextData = existingFileData;\n              } else if (existingFileData && sha1hex && existingFileData[_constants.default.SHA1] === sha1hex) {\n                nextData = [existingFileData[0], mtime, existingFileData[2], existingFileData[3], existingFileData[4], existingFileData[5]];\n              } else {\n                // See ../constants.ts\n                nextData = ['', mtime, size, 0, '', sha1hex];\n              }\n\n              const mappings = options.mapper ? options.mapper(filePath) : null;\n\n              if (mappings) {\n                var _iteratorNormalCompletion6 = true;\n                var _didIteratorError6 = false;\n                var _iteratorError6 = undefined;\n\n                try {\n                  for (var _iterator6 = mappings[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    const absoluteVirtualFilePath = _step6.value;\n\n                    if (!ignore(absoluteVirtualFilePath)) {\n                      const relativeVirtualFilePath = fastPath.relative(rootDir, absoluteVirtualFilePath);\n                      files.set(relativeVirtualFilePath, nextData);\n                      changedFiles.set(relativeVirtualFilePath, nextData);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError6 = true;\n                  _iteratorError6 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                      _iterator6.return();\n                    }\n                  } finally {\n                    if (_didIteratorError6) {\n                      throw _iteratorError6;\n                    }\n                  }\n                }\n              } else {\n                files.set(relativeFilePath, nextData);\n                changedFiles.set(relativeFilePath, nextData);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    data.files = files;\n    return {\n      changedFiles: isFresh ? undefined : changedFiles,\n      hasteMap: data,\n      removedFiles\n    };\n  });\n\n  function watchmanCrawl(_x) {\n    return _watchmanCrawl.apply(this, arguments);\n  }\n\n  return watchmanCrawl;\n}();","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-haste-map/build/crawlers/watchman.js"],"names":["_path","data","_interopRequireDefault","require","_fbWatchman","fastPath","_interopRequireWildcard","_normalizePathSep","_constants","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","desc","defineProperty","getOwnPropertyDescriptor","get","set","default","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","watchmanURL","WatchmanError","message","trim","module","exports","_watchmanCrawl","options","fields","extensions","ignore","rootDir","roots","defaultWatchExpression","map","extension","clocks","client","Client","clientError","on","cmd","command","result","computeSha1","_ref","capabilities","indexOf","getWatchmanRoots","_x2","_getWatchmanRoots","watchmanRoots","Map","all","_ref2","root","response","existing","watch","canBeFiltered","relative_path","concat","_x4","queryWatchmanForDirs","_x3","_queryWatchmanForDirs","rootProjectDirMappings","files","isFresh","from","_ref3","directoryFilters","expression","glob","dir","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","directory","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","return","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","relativeRoot","relative","query","has","since","console","warn","warning","is_fresh_instance","_x5","removedFiles","changedFiles","watchmanFiles","watchmanFileResults","end","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_step$value","watchRoot","fsRoot","relativeFsRoot","clock","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","fileData","filePath","sep","name","relativeFilePath","existingFileData","exists","delete","mtime","mtime_ms","toNumber","size","sha1hex","nextData","MTIME","SHA1","mappings","mapper","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","absoluteVirtualFilePath","relativeVirtualFilePath","hasteMap","watchmanCrawl","_x"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function _fbWatchman() {\n    return data;\n  };\n\n  return data;\n}\n\nvar fastPath = _interopRequireWildcard(require('../lib/fast_path'));\n\nvar _normalizePathSep = _interopRequireDefault(\n  require('../lib/normalizePathSep')\n);\n\nvar _constants = _interopRequireDefault(require('../constants'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc =\n            Object.defineProperty && Object.getOwnPropertyDescriptor\n              ? Object.getOwnPropertyDescriptor(obj, key)\n              : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()\n  );\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (\n      var _i = arr[Symbol.iterator](), _s;\n      !(_n = (_s = _i.next()).done);\n      _n = true\n    ) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nconst watchmanURL =\n  'https://facebook.github.io/watchman/docs/troubleshooting.html';\n\nfunction WatchmanError(error) {\n  error.message =\n    `Watchman error: ${error.message.trim()}. Make sure watchman ` +\n    `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n\nmodule.exports =\n  /*#__PURE__*/\n  (function() {\n    var _watchmanCrawl = _asyncToGenerator(function*(options) {\n      const fields = ['name', 'exists', 'mtime_ms', 'size'];\n      const data = options.data,\n        extensions = options.extensions,\n        ignore = options.ignore,\n        rootDir = options.rootDir,\n        roots = options.roots;\n      const defaultWatchExpression = [\n        'allof',\n        ['type', 'f'],\n        ['anyof', ...extensions.map(extension => ['suffix', extension])]\n      ];\n      const clocks = data.clocks;\n      const client = new (_fbWatchman()).default.Client();\n      let clientError;\n      client.on('error', error => (clientError = WatchmanError(error))); // TODO: type better than `any`\n\n      const cmd = (...args) =>\n        new Promise((resolve, reject) =>\n          client.command(args, (error, result) =>\n            error ? reject(WatchmanError(error)) : resolve(result)\n          )\n        );\n\n      if (options.computeSha1) {\n        const _ref = yield cmd('list-capabilities'),\n          capabilities = _ref.capabilities;\n\n        if (capabilities.indexOf('field-content.sha1hex') !== -1) {\n          fields.push('content.sha1hex');\n        }\n      }\n\n      function getWatchmanRoots(_x2) {\n        return _getWatchmanRoots.apply(this, arguments);\n      }\n\n      function _getWatchmanRoots() {\n        _getWatchmanRoots = _asyncToGenerator(function*(roots) {\n          const watchmanRoots = new Map();\n          yield Promise.all(\n            roots.map(\n              /*#__PURE__*/\n              (function() {\n                var _ref2 = _asyncToGenerator(function*(root) {\n                  const response = yield cmd('watch-project', root);\n                  const existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a\n                  // relative_path before.\n\n                  const canBeFiltered = !existing || existing.length > 0;\n\n                  if (canBeFiltered) {\n                    if (response.relative_path) {\n                      watchmanRoots.set(\n                        response.watch,\n                        (existing || []).concat(response.relative_path)\n                      );\n                    } else {\n                      // Make the filter directories an empty array to signal that this\n                      // root was already seen and needs to be watched for all files or\n                      // directories.\n                      watchmanRoots.set(response.watch, []);\n                    }\n                  }\n                });\n\n                return function(_x4) {\n                  return _ref2.apply(this, arguments);\n                };\n              })()\n            )\n          );\n          return watchmanRoots;\n        });\n        return _getWatchmanRoots.apply(this, arguments);\n      }\n\n      function queryWatchmanForDirs(_x3) {\n        return _queryWatchmanForDirs.apply(this, arguments);\n      }\n\n      function _queryWatchmanForDirs() {\n        _queryWatchmanForDirs = _asyncToGenerator(function*(\n          rootProjectDirMappings\n        ) {\n          const files = new Map();\n          let isFresh = false;\n          yield Promise.all(\n            Array.from(rootProjectDirMappings).map(\n              /*#__PURE__*/\n              (function() {\n                var _ref3 = _asyncToGenerator(function*([\n                  root,\n                  directoryFilters\n                ]) {\n                  const expression = Array.from(defaultWatchExpression);\n                  const glob = [];\n\n                  if (directoryFilters.length > 0) {\n                    expression.push([\n                      'anyof',\n                      ...directoryFilters.map(dir => ['dirname', dir])\n                    ]);\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                      for (\n                        var _iterator2 = directoryFilters[Symbol.iterator](),\n                          _step2;\n                        !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next())\n                          .done);\n                        _iteratorNormalCompletion2 = true\n                      ) {\n                        const directory = _step2.value;\n                        var _iteratorNormalCompletion3 = true;\n                        var _didIteratorError3 = false;\n                        var _iteratorError3 = undefined;\n\n                        try {\n                          for (\n                            var _iterator3 = extensions[Symbol.iterator](),\n                              _step3;\n                            !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next())\n                              .done);\n                            _iteratorNormalCompletion3 = true\n                          ) {\n                            const extension = _step3.value;\n                            glob.push(`${directory}/**/*.${extension}`);\n                          }\n                        } catch (err) {\n                          _didIteratorError3 = true;\n                          _iteratorError3 = err;\n                        } finally {\n                          try {\n                            if (\n                              !_iteratorNormalCompletion3 &&\n                              _iterator3.return != null\n                            ) {\n                              _iterator3.return();\n                            }\n                          } finally {\n                            if (_didIteratorError3) {\n                              throw _iteratorError3;\n                            }\n                          }\n                        }\n                      }\n                    } catch (err) {\n                      _didIteratorError2 = true;\n                      _iteratorError2 = err;\n                    } finally {\n                      try {\n                        if (\n                          !_iteratorNormalCompletion2 &&\n                          _iterator2.return != null\n                        ) {\n                          _iterator2.return();\n                        }\n                      } finally {\n                        if (_didIteratorError2) {\n                          throw _iteratorError2;\n                        }\n                      }\n                    }\n                  } else {\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                      for (\n                        var _iterator4 = extensions[Symbol.iterator](), _step4;\n                        !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next())\n                          .done);\n                        _iteratorNormalCompletion4 = true\n                      ) {\n                        const extension = _step4.value;\n                        glob.push(`**/*.${extension}`);\n                      }\n                    } catch (err) {\n                      _didIteratorError4 = true;\n                      _iteratorError4 = err;\n                    } finally {\n                      try {\n                        if (\n                          !_iteratorNormalCompletion4 &&\n                          _iterator4.return != null\n                        ) {\n                          _iterator4.return();\n                        }\n                      } finally {\n                        if (_didIteratorError4) {\n                          throw _iteratorError4;\n                        }\n                      }\n                    }\n                  }\n\n                  const relativeRoot = fastPath.relative(rootDir, root);\n                  const query = clocks.has(relativeRoot) // Use the `since` generator if we have a clock available\n                    ? {\n                        expression,\n                        fields,\n                        since: clocks.get(relativeRoot)\n                      } // Otherwise use the `glob` filter\n                    : {\n                        expression,\n                        fields,\n                        glob\n                      };\n                  const response = yield cmd('query', root, query);\n\n                  if ('warning' in response) {\n                    console.warn('watchman warning: ', response.warning);\n                  }\n\n                  isFresh = isFresh || response.is_fresh_instance;\n                  files.set(root, response);\n                });\n\n                return function(_x5) {\n                  return _ref3.apply(this, arguments);\n                };\n              })()\n            )\n          );\n          return {\n            files,\n            isFresh\n          };\n        });\n        return _queryWatchmanForDirs.apply(this, arguments);\n      }\n\n      let files = data.files;\n      let removedFiles = new Map();\n      const changedFiles = new Map();\n      let watchmanFiles;\n      let isFresh = false;\n\n      try {\n        const watchmanRoots = yield getWatchmanRoots(roots);\n        const watchmanFileResults = yield queryWatchmanForDirs(watchmanRoots); // Reset the file map if watchman was restarted and sends us a list of\n        // files.\n\n        if (watchmanFileResults.isFresh) {\n          files = new Map();\n          removedFiles = new Map(data.files);\n          isFresh = true;\n        }\n\n        watchmanFiles = watchmanFileResults.files;\n      } finally {\n        client.end();\n      }\n\n      if (clientError) {\n        throw clientError;\n      } // TODO: remove non-null\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (\n          var _iterator = watchmanFiles[Symbol.iterator](), _step;\n          !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n          _iteratorNormalCompletion = true\n        ) {\n          const _step$value = _slicedToArray(_step.value, 2),\n            watchRoot = _step$value[0],\n            response = _step$value[1];\n\n          const fsRoot = (0, _normalizePathSep.default)(watchRoot);\n          const relativeFsRoot = fastPath.relative(rootDir, fsRoot);\n          clocks.set(relativeFsRoot, response.clock);\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (\n              var _iterator5 = response.files[Symbol.iterator](), _step5;\n              !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done);\n              _iteratorNormalCompletion5 = true\n            ) {\n              const fileData = _step5.value;\n              const filePath =\n                fsRoot +\n                _path().default.sep +\n                (0, _normalizePathSep.default)(fileData.name);\n              const relativeFilePath = fastPath.relative(rootDir, filePath);\n              const existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files\n              // and we remove them as we verify they still exist.\n\n              if (isFresh && existingFileData && fileData.exists) {\n                removedFiles.delete(relativeFilePath);\n              }\n\n              if (!fileData.exists) {\n                // No need to act on files that do not exist and were not tracked.\n                if (existingFileData) {\n                  files.delete(relativeFilePath); // If watchman is not fresh, we will know what specific files were\n                  // deleted since we last ran and can track only those files.\n\n                  if (!isFresh) {\n                    removedFiles.set(relativeFilePath, existingFileData);\n                  }\n                }\n              } else if (!ignore(filePath)) {\n                const mtime =\n                  typeof fileData.mtime_ms === 'number'\n                    ? fileData.mtime_ms\n                    : fileData.mtime_ms.toNumber();\n                const size = fileData.size;\n                let sha1hex = fileData['content.sha1hex'];\n\n                if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n                  sha1hex = null;\n                }\n\n                let nextData;\n\n                if (\n                  existingFileData &&\n                  existingFileData[_constants.default.MTIME] === mtime\n                ) {\n                  nextData = existingFileData;\n                } else if (\n                  existingFileData &&\n                  sha1hex &&\n                  existingFileData[_constants.default.SHA1] === sha1hex\n                ) {\n                  nextData = [\n                    existingFileData[0],\n                    mtime,\n                    existingFileData[2],\n                    existingFileData[3],\n                    existingFileData[4],\n                    existingFileData[5]\n                  ];\n                } else {\n                  // See ../constants.ts\n                  nextData = ['', mtime, size, 0, '', sha1hex];\n                }\n\n                const mappings = options.mapper\n                  ? options.mapper(filePath)\n                  : null;\n\n                if (mappings) {\n                  var _iteratorNormalCompletion6 = true;\n                  var _didIteratorError6 = false;\n                  var _iteratorError6 = undefined;\n\n                  try {\n                    for (\n                      var _iterator6 = mappings[Symbol.iterator](), _step6;\n                      !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next())\n                        .done);\n                      _iteratorNormalCompletion6 = true\n                    ) {\n                      const absoluteVirtualFilePath = _step6.value;\n\n                      if (!ignore(absoluteVirtualFilePath)) {\n                        const relativeVirtualFilePath = fastPath.relative(\n                          rootDir,\n                          absoluteVirtualFilePath\n                        );\n                        files.set(relativeVirtualFilePath, nextData);\n                        changedFiles.set(relativeVirtualFilePath, nextData);\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError6 = true;\n                    _iteratorError6 = err;\n                  } finally {\n                    try {\n                      if (\n                        !_iteratorNormalCompletion6 &&\n                        _iterator6.return != null\n                      ) {\n                        _iterator6.return();\n                      }\n                    } finally {\n                      if (_didIteratorError6) {\n                        throw _iteratorError6;\n                      }\n                    }\n                  }\n                } else {\n                  files.set(relativeFilePath, nextData);\n                  changedFiles.set(relativeFilePath, nextData);\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      data.files = files;\n      return {\n        changedFiles: isFresh ? undefined : changedFiles,\n        hasteMap: data,\n        removedFiles\n      };\n    });\n\n    function watchmanCrawl(_x) {\n      return _watchmanCrawl.apply(this, arguments);\n    }\n\n    return watchmanCrawl;\n  })();\n"]},"metadata":{},"sourceType":"script"}