{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-param-reassign*/\n\nconst TokenTranslator = require(\"./token-translator\");\n\nconst {\n  normalizeOptions\n} = require(\"./options\");\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\n\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n  const comment = {\n    type: block ? \"Block\" : \"Line\",\n    value: text\n  };\n\n  if (typeof start === \"number\") {\n    comment.start = start;\n    comment.end = end;\n    comment.range = [start, end];\n  }\n\n  if (typeof startLoc === \"object\") {\n    comment.loc = {\n      start: startLoc,\n      end: endLoc\n    };\n  }\n\n  return comment;\n}\n\nmodule.exports = () => Parser => {\n  const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n  if (Parser.acornJsx) {\n    Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n  }\n\n  return class Espree extends Parser {\n    constructor(opts, code) {\n      if (typeof opts !== \"object\" || opts === null) {\n        opts = {};\n      }\n\n      if (typeof code !== \"string\" && !(code instanceof String)) {\n        code = String(code);\n      }\n\n      const options = normalizeOptions(opts);\n      const ecmaFeatures = options.ecmaFeatures || {};\n      const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null; // Initialize acorn parser.\n\n      super({\n        // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n        ecmaVersion: options.ecmaVersion,\n        sourceType: options.sourceType,\n        ranges: options.ranges,\n        locations: options.locations,\n        // Truthy value is true for backward compatibility.\n        allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n        // Collect tokens\n        onToken: token => {\n          if (tokenTranslator) {\n            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n            tokenTranslator.onToken(token, this[STATE]);\n          }\n\n          if (token.type !== tokTypes.eof) {\n            this[STATE].lastToken = token;\n          }\n        },\n        // Collect comments\n        onComment: (block, text, start, end, startLoc, endLoc) => {\n          if (this[STATE].comments) {\n            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n            this[STATE].comments.push(comment);\n          }\n        }\n      }, code); // Initialize internal state.\n\n      this[STATE] = {\n        tokens: tokenTranslator ? [] : null,\n        comments: options.comment === true ? [] : null,\n        impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n        ecmaVersion: this.options.ecmaVersion,\n        jsxAttrValueToken: false,\n        lastToken: null\n      };\n    }\n\n    tokenize() {\n      do {\n        this.next();\n      } while (this.type !== tokTypes.eof); // Consume the final eof token\n\n\n      this.next();\n      const extra = this[STATE];\n      const tokens = extra.tokens;\n\n      if (extra.comments) {\n        tokens.comments = extra.comments;\n      }\n\n      return tokens;\n    }\n\n    finishNode(...args) {\n      const result = super.finishNode(...args);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n\n    finishNodeAt(...args) {\n      const result = super.finishNodeAt(...args);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n\n    parse() {\n      const extra = this[STATE];\n      const program = super.parse();\n      program.sourceType = this.options.sourceType;\n\n      if (extra.comments) {\n        program.comments = extra.comments;\n      }\n\n      if (extra.tokens) {\n        program.tokens = extra.tokens;\n      }\n      /*\n       * Adjust opening and closing position of program to match Esprima.\n       * Acorn always starts programs at range 0 whereas Esprima starts at the\n       * first AST node's start (the only real difference is when there's leading\n       * whitespace or leading comments). Acorn also counts trailing whitespace\n       * as part of the program whereas Esprima only counts up to the last token.\n       */\n\n\n      if (program.range) {\n        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n        program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n      }\n\n      if (program.loc) {\n        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n        program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n      }\n\n      return program;\n    }\n\n    parseTopLevel(node) {\n      if (this[STATE].impliedStrict) {\n        this.strict = true;\n      }\n\n      return super.parseTopLevel(node);\n    }\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    raise(pos, message) {\n      const loc = Parser.acorn.getLineInfo(this.input, pos);\n      const err = new SyntaxError(message);\n      err.index = pos;\n      err.lineNumber = loc.line;\n      err.column = loc.column + 1; // acorn uses 0-based columns\n\n      throw err;\n    }\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    raiseRecoverable(pos, message) {\n      this.raise(pos, message);\n    }\n    /**\n     * Overwrites the default unexpected method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    unexpected(pos) {\n      let message = \"Unexpected token\";\n\n      if (pos !== null && pos !== void 0) {\n        this.pos = pos;\n\n        if (this.options.locations) {\n          while (this.pos < this.lineStart) {\n            this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n            --this.curLine;\n          }\n        }\n\n        this.nextToken();\n      }\n\n      if (this.end > this.start) {\n        message += ` ${this.input.slice(this.start, this.end)}`;\n      }\n\n      this.raise(this.start, message);\n    }\n    /*\n    * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n    * uses regular tt.string without any distinction between this and regular JS\n    * strings. As such, we intercept an attempt to read a JSX string and set a flag\n    * on extra so that when tokens are converted, the next token will be switched\n    * to JSXText via onToken.\n    */\n\n\n    jsx_readString(quote) {\n      // eslint-disable-line camelcase\n      const result = super.jsx_readString(quote);\n\n      if (this.type === tokTypes.string) {\n        this[STATE].jsxAttrValueToken = true;\n      }\n\n      return result;\n    }\n    /**\n     * Performs last-minute Esprima-specific compatibility checks and fixes.\n     * @param {ASTNode} result The node to check.\n     * @returns {ASTNode} The finished node.\n     */\n\n\n    [ESPRIMA_FINISH_NODE](result) {\n      // Acorn doesn't count the opening and closing backticks as part of templates\n      // so we have to adjust ranges/locations appropriately.\n      if (result.type === \"TemplateElement\") {\n        // additional adjustment needed if ${ is the last token\n        const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n\n        if (result.range) {\n          result.range[0]--;\n          result.range[1] += terminalDollarBraceL ? 2 : 1;\n        }\n\n        if (result.loc) {\n          result.loc.start.column--;\n          result.loc.end.column += terminalDollarBraceL ? 2 : 1;\n        }\n      }\n\n      if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n        result.generator = false;\n      }\n\n      return result;\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/espree/lib/espree.js"],"names":["TokenTranslator","require","normalizeOptions","STATE","Symbol","ESPRIMA_FINISH_NODE","convertAcornCommentToEsprimaComment","block","text","start","end","startLoc","endLoc","comment","type","value","range","loc","module","exports","Parser","tokTypes","Object","assign","acorn","acornJsx","Espree","constructor","opts","code","String","options","ecmaFeatures","tokenTranslator","tokens","ecmaVersion","sourceType","ranges","locations","allowReturnOutsideFunction","Boolean","globalReturn","onToken","token","eof","lastToken","onComment","comments","push","impliedStrict","jsxAttrValueToken","tokenize","next","extra","finishNode","args","result","finishNodeAt","parse","program","body","length","parseTopLevel","node","strict","raise","pos","message","getLineInfo","input","err","SyntaxError","index","lineNumber","line","column","raiseRecoverable","unexpected","lineStart","lastIndexOf","curLine","nextToken","slice","jsx_readString","quote","string","terminalDollarBraceL","indexOf","generator"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/* eslint-disable no-param-reassign*/\nconst TokenTranslator = require(\"./token-translator\");\nconst { normalizeOptions } = require(\"./options\");\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @returns {Object} The comment object.\n * @private\n */\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text\n    };\n\n    if (typeof start === \"number\") {\n        comment.start = start;\n        comment.end = end;\n        comment.range = [start, end];\n    }\n\n    if (typeof startLoc === \"object\") {\n        comment.loc = {\n            start: startLoc,\n            end: endLoc\n        };\n    }\n\n    return comment;\n}\n\nmodule.exports = () => Parser => {\n    const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n    if (Parser.acornJsx) {\n        Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n    }\n\n    return class Espree extends Parser {\n        constructor(opts, code) {\n            if (typeof opts !== \"object\" || opts === null) {\n                opts = {};\n            }\n            if (typeof code !== \"string\" && !(code instanceof String)) {\n                code = String(code);\n            }\n\n            const options = normalizeOptions(opts);\n            const ecmaFeatures = options.ecmaFeatures || {};\n            const tokenTranslator =\n                options.tokens === true\n                    ? new TokenTranslator(tokTypes, code)\n                    : null;\n\n            // Initialize acorn parser.\n            super({\n\n                // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).\n                ecmaVersion: options.ecmaVersion,\n                sourceType: options.sourceType,\n                ranges: options.ranges,\n                locations: options.locations,\n\n                // Truthy value is true for backward compatibility.\n                allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n\n                // Collect tokens\n                onToken: token => {\n                    if (tokenTranslator) {\n\n                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                        tokenTranslator.onToken(token, this[STATE]);\n                    }\n                    if (token.type !== tokTypes.eof) {\n                        this[STATE].lastToken = token;\n                    }\n                },\n\n                // Collect comments\n                onComment: (block, text, start, end, startLoc, endLoc) => {\n                    if (this[STATE].comments) {\n                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n\n                        this[STATE].comments.push(comment);\n                    }\n                }\n            }, code);\n\n            // Initialize internal state.\n            this[STATE] = {\n                tokens: tokenTranslator ? [] : null,\n                comments: options.comment === true ? [] : null,\n                impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n                ecmaVersion: this.options.ecmaVersion,\n                jsxAttrValueToken: false,\n                lastToken: null\n            };\n        }\n\n        tokenize() {\n            do {\n                this.next();\n            } while (this.type !== tokTypes.eof);\n\n            // Consume the final eof token\n            this.next();\n\n            const extra = this[STATE];\n            const tokens = extra.tokens;\n\n            if (extra.comments) {\n                tokens.comments = extra.comments;\n            }\n\n            return tokens;\n        }\n\n        finishNode(...args) {\n            const result = super.finishNode(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        finishNodeAt(...args) {\n            const result = super.finishNodeAt(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        parse() {\n            const extra = this[STATE];\n            const program = super.parse();\n\n            program.sourceType = this.options.sourceType;\n\n            if (extra.comments) {\n                program.comments = extra.comments;\n            }\n            if (extra.tokens) {\n                program.tokens = extra.tokens;\n            }\n\n            /*\n             * Adjust opening and closing position of program to match Esprima.\n             * Acorn always starts programs at range 0 whereas Esprima starts at the\n             * first AST node's start (the only real difference is when there's leading\n             * whitespace or leading comments). Acorn also counts trailing whitespace\n             * as part of the program whereas Esprima only counts up to the last token.\n             */\n            if (program.range) {\n                program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n                program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n            }\n            if (program.loc) {\n                program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n                program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n            }\n\n            return program;\n        }\n\n        parseTopLevel(node) {\n            if (this[STATE].impliedStrict) {\n                this.strict = true;\n            }\n            return super.parseTopLevel(node);\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raise(pos, message) {\n            const loc = Parser.acorn.getLineInfo(this.input, pos);\n            const err = new SyntaxError(message);\n\n            err.index = pos;\n            err.lineNumber = loc.line;\n            err.column = loc.column + 1; // acorn uses 0-based columns\n            throw err;\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raiseRecoverable(pos, message) {\n            this.raise(pos, message);\n        }\n\n        /**\n         * Overwrites the default unexpected method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        unexpected(pos) {\n            let message = \"Unexpected token\";\n\n            if (pos !== null && pos !== void 0) {\n                this.pos = pos;\n\n                if (this.options.locations) {\n                    while (this.pos < this.lineStart) {\n                        this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                        --this.curLine;\n                    }\n                }\n\n                this.nextToken();\n            }\n\n            if (this.end > this.start) {\n                message += ` ${this.input.slice(this.start, this.end)}`;\n            }\n\n            this.raise(this.start, message);\n        }\n\n        /*\n        * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n        * uses regular tt.string without any distinction between this and regular JS\n        * strings. As such, we intercept an attempt to read a JSX string and set a flag\n        * on extra so that when tokens are converted, the next token will be switched\n        * to JSXText via onToken.\n        */\n        jsx_readString(quote) { // eslint-disable-line camelcase\n            const result = super.jsx_readString(quote);\n\n            if (this.type === tokTypes.string) {\n                this[STATE].jsxAttrValueToken = true;\n            }\n            return result;\n        }\n\n        /**\n         * Performs last-minute Esprima-specific compatibility checks and fixes.\n         * @param {ASTNode} result The node to check.\n         * @returns {ASTNode} The finished node.\n         */\n        [ESPRIMA_FINISH_NODE](result) {\n\n            // Acorn doesn't count the opening and closing backticks as part of templates\n            // so we have to adjust ranges/locations appropriately.\n            if (result.type === \"TemplateElement\") {\n\n                // additional adjustment needed if ${ is the last token\n                const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n\n                if (result.range) {\n                    result.range[0]--;\n                    result.range[1] += (terminalDollarBraceL ? 2 : 1);\n                }\n\n                if (result.loc) {\n                    result.loc.start.column--;\n                    result.loc.end.column += (terminalDollarBraceL ? 2 : 1);\n                }\n            }\n\n            if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n                result.generator = false;\n            }\n\n            return result;\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"script"}