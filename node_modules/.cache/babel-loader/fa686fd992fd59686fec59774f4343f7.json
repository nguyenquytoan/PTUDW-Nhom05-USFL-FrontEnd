{"ast":null,"code":"'use strict';\n\nexports.type = 'perItem';\nexports.active = false;\nexports.description = 'removes elements that are drawn outside of the viewbox (disabled by default)';\n\nvar SVGO = require('../lib/svgo.js'),\n    _path = require('./_path.js'),\n    intersects = _path.intersects,\n    path2js = _path.path2js,\n    viewBox,\n    viewBoxJS;\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @param {Object} item current iteration item\n * @return {Boolean} if false, item will be filtered out\n *\n * @author JoshyPHP\n */\n\n\nexports.fn = function (item) {\n  if (item.isElem('path') && item.hasAttr('d') && typeof viewBox !== 'undefined') {\n    // Consider that any item with a transform attribute or a M instruction\n    // within the viewBox is visible\n    if (hasTransform(item) || pathMovesWithinViewBox(item.attr('d').value)) {\n      return true;\n    }\n\n    var pathJS = path2js(item);\n\n    if (pathJS.length === 2) {\n      // Use a closed clone of the path if it's too short for intersects()\n      pathJS = JSON.parse(JSON.stringify(pathJS));\n      pathJS.push({\n        instruction: 'z'\n      });\n    }\n\n    return intersects(viewBoxJS, pathJS);\n  }\n\n  if (item.isElem('svg')) {\n    parseViewBox(item);\n  }\n\n  return true;\n};\n/**\n * Test whether given item or any of its ancestors has a transform attribute.\n *\n * @param {String} path\n * @return {Boolean}\n */\n\n\nfunction hasTransform(item) {\n  return item.hasAttr('transform') || item.parentNode && hasTransform(item.parentNode);\n}\n/**\n * Parse the viewBox coordinates and compute the JS representation of its path.\n *\n * @param {Object} svg svg element item\n */\n\n\nfunction parseViewBox(svg) {\n  var viewBoxData = '';\n\n  if (svg.hasAttr('viewBox')) {\n    // Remove commas and plus signs, normalize and trim whitespace\n    viewBoxData = svg.attr('viewBox').value;\n  } else if (svg.hasAttr('height') && svg.hasAttr('width')) {\n    viewBoxData = '0 0 ' + svg.attr('width').value + ' ' + svg.attr('height').value;\n  } // Remove commas and plus signs, normalize and trim whitespace\n\n\n  viewBoxData = viewBoxData.replace(/[,+]|px/g, ' ').replace(/\\s+/g, ' ').replace(/^\\s*|\\s*$/g, ''); // Ensure that the dimensions are 4 values separated by space\n\n  var m = /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(viewBoxData);\n\n  if (!m) {\n    return;\n  } // Store the viewBox boundaries\n\n\n  viewBox = {\n    left: parseFloat(m[1]),\n    top: parseFloat(m[2]),\n    right: parseFloat(m[1]) + parseFloat(m[3]),\n    bottom: parseFloat(m[2]) + parseFloat(m[4])\n  };\n  var path = new SVGO().createContentItem({\n    elem: 'path',\n    prefix: '',\n    local: 'path'\n  });\n  path.addAttr({\n    name: 'd',\n    prefix: '',\n    local: 'd',\n    value: 'M' + m[1] + ' ' + m[2] + 'h' + m[3] + 'v' + m[4] + 'H' + m[1] + 'z'\n  });\n  viewBoxJS = path2js(path);\n}\n/**\n * Test whether given path has a M instruction with coordinates within the viewBox.\n *\n * @param {String} path\n * @return {Boolean}\n */\n\n\nfunction pathMovesWithinViewBox(path) {\n  var regexp = /M\\s*(-?\\d*\\.?\\d+)(?!\\d)\\s*(-?\\d*\\.?\\d+)/g,\n      m;\n\n  while (null !== (m = regexp.exec(path))) {\n    if (m[1] >= viewBox.left && m[1] <= viewBox.right && m[2] >= viewBox.top && m[2] <= viewBox.bottom) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/svgo/plugins/removeOffCanvasPaths.js"],"names":["exports","type","active","description","SVGO","require","_path","intersects","path2js","viewBox","viewBoxJS","fn","item","isElem","hasAttr","hasTransform","pathMovesWithinViewBox","attr","value","pathJS","length","JSON","parse","stringify","push","instruction","parseViewBox","parentNode","svg","viewBoxData","replace","m","exec","left","parseFloat","top","right","bottom","path","createContentItem","elem","prefix","local","addAttr","name","regexp"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.type = 'perItem';\n\nexports.active = false;\n\nexports.description = 'removes elements that are drawn outside of the viewbox (disabled by default)';\n\nvar SVGO       = require('../lib/svgo.js'),\n\t_path      = require('./_path.js'),\n\tintersects = _path.intersects,\n\tpath2js    = _path.path2js,\n\tviewBox,\n\tviewBoxJS;\n\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @param {Object} item current iteration item\n * @return {Boolean} if false, item will be filtered out\n *\n * @author JoshyPHP\n */\nexports.fn = function(item) {\n\n\tif (item.isElem('path') && item.hasAttr('d') && typeof viewBox !== 'undefined')\n\t{\n\t\t// Consider that any item with a transform attribute or a M instruction\n\t\t// within the viewBox is visible\n\t\tif (hasTransform(item) || pathMovesWithinViewBox(item.attr('d').value))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tvar pathJS = path2js(item);\n\t\tif (pathJS.length === 2)\n\t\t{\n\t\t\t// Use a closed clone of the path if it's too short for intersects()\n\t\t\tpathJS = JSON.parse(JSON.stringify(pathJS));\n\t\t\tpathJS.push({ instruction: 'z' });\n\t\t}\n\n\t\treturn intersects(viewBoxJS, pathJS);\n\t}\n\tif (item.isElem('svg'))\n\t{\n\t\tparseViewBox(item);\n\t}\n\n\treturn true;\n};\n\n/**\n * Test whether given item or any of its ancestors has a transform attribute.\n *\n * @param {String} path\n * @return {Boolean}\n */\nfunction hasTransform(item)\n{\n\treturn item.hasAttr('transform') || (item.parentNode && hasTransform(item.parentNode));\n}\n\n/**\n * Parse the viewBox coordinates and compute the JS representation of its path.\n *\n * @param {Object} svg svg element item\n */\nfunction parseViewBox(svg)\n{\n\tvar viewBoxData = '';\n\tif (svg.hasAttr('viewBox'))\n\t{\n\t\t// Remove commas and plus signs, normalize and trim whitespace\n\t\tviewBoxData = svg.attr('viewBox').value;\n\t}\n\telse if (svg.hasAttr('height') && svg.hasAttr('width'))\n\t{\n\t\tviewBoxData = '0 0 ' + svg.attr('width').value + ' ' + svg.attr('height').value;\n\t}\n\n\t// Remove commas and plus signs, normalize and trim whitespace\n\tviewBoxData = viewBoxData.replace(/[,+]|px/g, ' ').replace(/\\s+/g, ' ').replace(/^\\s*|\\s*$/g, '');\n\n\t// Ensure that the dimensions are 4 values separated by space\n\tvar m = /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(viewBoxData);\n\tif (!m)\n\t{\n\t\treturn;\n\t}\n\n\t// Store the viewBox boundaries\n\tviewBox = {\n\t\tleft:   parseFloat(m[1]),\n\t\ttop:    parseFloat(m[2]),\n\t\tright:  parseFloat(m[1]) + parseFloat(m[3]),\n\t\tbottom: parseFloat(m[2]) + parseFloat(m[4])\n\t};\n\n\tvar path = new SVGO().createContentItem({\n\t\telem:   'path',\n\t\tprefix: '',\n\t\tlocal:  'path'\n\t});\n\tpath.addAttr({\n\t\tname:   'd',\n\t\tprefix: '',\n\t\tlocal:  'd',\n\t\tvalue:  'M' + m[1] + ' ' + m[2] + 'h' + m[3] + 'v' + m[4] + 'H' + m[1] + 'z'\n\t});\n\n\tviewBoxJS = path2js(path);\n}\n\n/**\n * Test whether given path has a M instruction with coordinates within the viewBox.\n *\n * @param {String} path\n * @return {Boolean}\n */\nfunction pathMovesWithinViewBox(path)\n{\n\tvar regexp = /M\\s*(-?\\d*\\.?\\d+)(?!\\d)\\s*(-?\\d*\\.?\\d+)/g, m;\n\twhile (null !== (m = regexp.exec(path)))\n\t{\n\t\tif (m[1] >= viewBox.left && m[1] <= viewBox.right && m[2] >= viewBox.top && m[2] <= viewBox.bottom)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"]},"metadata":{},"sourceType":"script"}