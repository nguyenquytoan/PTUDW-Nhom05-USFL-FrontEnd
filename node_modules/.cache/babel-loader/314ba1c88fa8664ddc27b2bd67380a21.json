{"ast":null,"code":"/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n      category: \"Variables\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-shadow\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        builtinGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        hoist: {\n          enum: [\"all\", \"functions\", \"never\"],\n          default: \"functions\"\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = {\n      builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n      hoist: context.options[0] && context.options[0].hoist || \"functions\",\n      allow: context.options[0] && context.options[0].allow || []\n    };\n    /**\n     * Check if variable name is allowed.\n     * @param  {ASTNode} variable The variable to check.\n     * @returns {boolean} Whether or not the variable name is allowed.\n     */\n\n    function isAllowed(variable) {\n      return options.allow.indexOf(variable.name) !== -1;\n    }\n    /**\n     * Checks if a variable of the class name in the class scope of ClassDeclaration.\n     *\n     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n     * So we should ignore the variable in the class scope.\n     * @param {Object} variable The variable to check.\n     * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n     */\n\n\n    function isDuplicatedClassNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n    }\n    /**\n     * Checks if a variable is inside the initializer of scopeVar.\n     *\n     * To avoid reporting at declarations such as `var a = function a() {};`.\n     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n     * @param {Object} variable The variable to check.\n     * @param {Object} scopeVar The scope variable to look for.\n     * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n     */\n\n\n    function isOnInitializer(variable, scopeVar) {\n      const outerScope = scopeVar.scope;\n      const outerDef = scopeVar.defs[0];\n      const outer = outerDef && outerDef.parent && outerDef.parent.range;\n      const innerScope = variable.scope;\n      const innerDef = variable.defs[0];\n      const inner = innerDef && innerDef.name.range;\n      return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\" || innerDef.node.type === \"ClassExpression\") && outerScope === innerScope.upper;\n    }\n    /**\n     * Get a range of a variable's identifier node.\n     * @param {Object} variable The variable to get.\n     * @returns {Array|undefined} The range of the variable's identifier node.\n     */\n\n\n    function getNameRange(variable) {\n      const def = variable.defs[0];\n      return def && def.name.range;\n    }\n    /**\n     * Checks if a variable is in TDZ of scopeVar.\n     * @param {Object} variable The variable to check.\n     * @param {Object} scopeVar The variable of TDZ.\n     * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n     */\n\n\n    function isInTdz(variable, scopeVar) {\n      const outerDef = scopeVar.defs[0];\n      const inner = getNameRange(variable);\n      const outer = getNameRange(scopeVar);\n      return inner && outer && inner[1] < outer[0] && ( // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n      options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\");\n    }\n    /**\n     * Checks the current context for shadowed variables.\n     * @param {Scope} scope Fixme\n     * @returns {void}\n     */\n\n\n    function checkForShadows(scope) {\n      const variables = scope.variables;\n\n      for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i]; // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n\n        if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {\n          continue;\n        } // Gets shadowed variable.\n\n\n        const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n        if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && \"writeable\" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== \"all\" && isInTdz(variable, shadowed))) {\n          context.report({\n            node: variable.identifiers[0],\n            message: \"'{{name}}' is already declared in the upper scope.\",\n            data: variable\n          });\n        }\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const stack = globalScope.childScopes.slice();\n\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkForShadows(scope);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-shadow.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","builtinGlobals","default","hoist","enum","allow","items","additionalProperties","create","context","options","isAllowed","variable","indexOf","name","isDuplicatedClassNameVariable","block","scope","id","identifiers","isOnInitializer","scopeVar","outerScope","outerDef","defs","outer","parent","range","innerScope","innerDef","inner","node","upper","getNameRange","def","isInTdz","checkForShadows","variables","i","length","shadowed","getVariableByName","report","message","data","globalScope","getScope","stack","childScopes","slice","pop","push"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-shadow\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\", default: false },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"], default: \"functions\" },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = {\n            builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\n            allow: (context.options[0] && context.options[0].allow) || []\n        };\n\n        /**\n         * Check if variable name is allowed.\n         * @param  {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return options.allow.indexOf(variable.name) !== -1;\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                inner &&\n                outer[0] < inner[0] &&\n                inner[1] < outer[1] &&\n                ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                outer &&\n                inner[1] < outer[0] &&\n\n                // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                    isDuplicatedClassNameVariable(variable) ||\n                    isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\n                    !isOnInitializer(variable, shadowed) &&\n                    !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    context.report({\n                        node: variable.identifiers[0],\n                        message: \"'{{name}}' is already declared in the upper scope.\",\n                        data: variable\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}