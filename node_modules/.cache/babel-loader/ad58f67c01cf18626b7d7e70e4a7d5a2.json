{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar patternUtils = require(\"../utils/pattern\");\n/**\r\n * Generate tasks based on parent directory of each pattern.\r\n */\n\n\nfunction generate(patterns, options) {\n  var unixPatterns = patterns.map(patternUtils.unixifyPattern);\n  var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);\n  var positivePatterns = getPositivePatterns(unixPatterns);\n  var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);\n  /**\r\n   * When the `case` option is disabled, all patterns must be marked as dynamic, because we cannot check filepath\r\n   * directly (without read directory).\r\n   */\n\n  var staticPatterns = !options.case ? [] : positivePatterns.filter(patternUtils.isStaticPattern);\n  var dynamicPatterns = !options.case ? positivePatterns : positivePatterns.filter(patternUtils.isDynamicPattern);\n  var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns,\n  /* dynamic */\n  false);\n  var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns,\n  /* dynamic */\n  true);\n  return staticTasks.concat(dynamicTasks);\n}\n\nexports.generate = generate;\n/**\r\n * Convert patterns to tasks based on parent directory of each pattern.\r\n */\n\nfunction convertPatternsToTasks(positive, negative, dynamic) {\n  var positivePatternsGroup = groupPatternsByBaseDirectory(positive); // When we have a global group – there is no reason to divide the patterns into independent tasks.\n  // In this case, the global task covers the rest.\n\n  if ('.' in positivePatternsGroup) {\n    var task = convertPatternGroupToTask('.', positive, negative, dynamic);\n    return [task];\n  }\n\n  return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);\n}\n\nexports.convertPatternsToTasks = convertPatternsToTasks;\n/**\r\n * Return only positive patterns.\r\n */\n\nfunction getPositivePatterns(patterns) {\n  return patternUtils.getPositivePatterns(patterns);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\r\n * Return only negative patterns.\r\n */\n\nfunction getNegativePatternsAsPositive(patterns, ignore) {\n  var negative = patternUtils.getNegativePatterns(patterns).concat(ignore);\n  var positive = negative.map(patternUtils.convertToPositivePattern);\n  return positive;\n}\n\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\n/**\r\n * Group patterns by base directory of each pattern.\r\n */\n\nfunction groupPatternsByBaseDirectory(patterns) {\n  return patterns.reduce(function (collection, pattern) {\n    var base = patternUtils.getBaseDirectory(pattern);\n\n    if (base in collection) {\n      collection[base].push(pattern);\n    } else {\n      collection[base] = [pattern];\n    }\n\n    return collection;\n  }, {});\n}\n\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\n/**\r\n * Convert group of patterns to tasks.\r\n */\n\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\n  return Object.keys(positive).map(function (base) {\n    return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n  });\n}\n\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\n/**\r\n * Create a task for positive and negative patterns.\r\n */\n\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\n  return {\n    base: base,\n    dynamic: dynamic,\n    positive: positive,\n    negative: negative,\n    patterns: [].concat(positive, negative.map(patternUtils.convertToNegativePattern))\n  };\n}\n\nexports.convertPatternGroupToTask = convertPatternGroupToTask;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/fast-glob/out/managers/tasks.js"],"names":["Object","defineProperty","exports","value","patternUtils","require","generate","patterns","options","unixPatterns","map","unixifyPattern","unixIgnore","ignore","positivePatterns","getPositivePatterns","negativePatterns","getNegativePatternsAsPositive","staticPatterns","case","filter","isStaticPattern","dynamicPatterns","isDynamicPattern","staticTasks","convertPatternsToTasks","dynamicTasks","concat","positive","negative","dynamic","positivePatternsGroup","groupPatternsByBaseDirectory","task","convertPatternGroupToTask","convertPatternGroupsToTasks","getNegativePatterns","convertToPositivePattern","reduce","collection","pattern","base","getBaseDirectory","push","keys","convertToNegativePattern"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar patternUtils = require(\"../utils/pattern\");\r\n/**\r\n * Generate tasks based on parent directory of each pattern.\r\n */\r\nfunction generate(patterns, options) {\r\n    var unixPatterns = patterns.map(patternUtils.unixifyPattern);\r\n    var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);\r\n    var positivePatterns = getPositivePatterns(unixPatterns);\r\n    var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);\r\n    /**\r\n     * When the `case` option is disabled, all patterns must be marked as dynamic, because we cannot check filepath\r\n     * directly (without read directory).\r\n     */\r\n    var staticPatterns = !options.case ? [] : positivePatterns.filter(patternUtils.isStaticPattern);\r\n    var dynamicPatterns = !options.case ? positivePatterns : positivePatterns.filter(patternUtils.isDynamicPattern);\r\n    var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\r\n    var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\r\n    return staticTasks.concat(dynamicTasks);\r\n}\r\nexports.generate = generate;\r\n/**\r\n * Convert patterns to tasks based on parent directory of each pattern.\r\n */\r\nfunction convertPatternsToTasks(positive, negative, dynamic) {\r\n    var positivePatternsGroup = groupPatternsByBaseDirectory(positive);\r\n    // When we have a global group – there is no reason to divide the patterns into independent tasks.\r\n    // In this case, the global task covers the rest.\r\n    if ('.' in positivePatternsGroup) {\r\n        var task = convertPatternGroupToTask('.', positive, negative, dynamic);\r\n        return [task];\r\n    }\r\n    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);\r\n}\r\nexports.convertPatternsToTasks = convertPatternsToTasks;\r\n/**\r\n * Return only positive patterns.\r\n */\r\nfunction getPositivePatterns(patterns) {\r\n    return patternUtils.getPositivePatterns(patterns);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\n/**\r\n * Return only negative patterns.\r\n */\r\nfunction getNegativePatternsAsPositive(patterns, ignore) {\r\n    var negative = patternUtils.getNegativePatterns(patterns).concat(ignore);\r\n    var positive = negative.map(patternUtils.convertToPositivePattern);\r\n    return positive;\r\n}\r\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\r\n/**\r\n * Group patterns by base directory of each pattern.\r\n */\r\nfunction groupPatternsByBaseDirectory(patterns) {\r\n    return patterns.reduce(function (collection, pattern) {\r\n        var base = patternUtils.getBaseDirectory(pattern);\r\n        if (base in collection) {\r\n            collection[base].push(pattern);\r\n        }\r\n        else {\r\n            collection[base] = [pattern];\r\n        }\r\n        return collection;\r\n    }, {});\r\n}\r\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\r\n/**\r\n * Convert group of patterns to tasks.\r\n */\r\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\r\n    return Object.keys(positive).map(function (base) {\r\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\r\n    });\r\n}\r\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\r\n/**\r\n * Create a task for positive and negative patterns.\r\n */\r\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\r\n    return {\r\n        base: base,\r\n        dynamic: dynamic,\r\n        positive: positive,\r\n        negative: negative,\r\n        patterns: [].concat(positive, negative.map(patternUtils.convertToNegativePattern))\r\n    };\r\n}\r\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\r\n"]},"metadata":{},"sourceType":"script"}