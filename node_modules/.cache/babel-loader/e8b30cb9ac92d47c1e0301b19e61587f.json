{"ast":null,"code":"'use strict';\n\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n} // the input can also be a promise, so we `Promise.all()` them both\n\n\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n  opts = Object.assign({\n    concurrency: Infinity,\n    preserveOrder: true\n  }, opts);\n  const limit = pLimit(opts.concurrency); // start all the promises concurrently with optional limit\n\n  const items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]); // check the promises either serially or concurrently\n\n  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n  return Promise.all(items.map(el => checkLimit(() => finder(el)))).then(() => {}).catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","Error","constructor","value","finder","el","Promise","all","then","val","reject","module","exports","iterable","tester","opts","Object","assign","concurrency","Infinity","preserveOrder","limit","items","Array","from","map","resolve","checkLimit","catch","err"],"mappings":"AAAA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AAEA,MAAMC,QAAN,SAAuBC,KAAvB,CAA6B;AAC5BC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AAClB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA;;AAJ2B,C,CAO7B;;;AACA,MAAMC,MAAM,GAAGC,EAAE,IAAIC,OAAO,CAACC,GAAR,CAAYF,EAAZ,EAAgBG,IAAhB,CAAqBC,GAAG,IAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,IAAX,IAAmBH,OAAO,CAACI,MAAR,CAAe,IAAIV,QAAJ,CAAaS,GAAG,CAAC,CAAD,CAAhB,CAAf,CAA/C,CAArB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,CAACC,QAAD,EAAWC,MAAX,EAAmBC,IAAnB,KAA4B;AAC5CA,EAAAA,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;AACpBC,IAAAA,WAAW,EAAEC,QADO;AAEpBC,IAAAA,aAAa,EAAE;AAFK,GAAd,EAGJL,IAHI,CAAP;AAKA,QAAMM,KAAK,GAAGvB,MAAM,CAACiB,IAAI,CAACG,WAAN,CAApB,CAN4C,CAQ5C;;AACA,QAAMI,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWX,QAAX,EAAqBY,GAArB,CAAyBpB,EAAE,IAAI,CAACA,EAAD,EAAKgB,KAAK,CAAC,MAAMf,OAAO,CAACoB,OAAR,CAAgBrB,EAAhB,EAAoBG,IAApB,CAAyBM,MAAzB,CAAP,CAAV,CAA/B,CAAd,CAT4C,CAW5C;;AACA,QAAMa,UAAU,GAAG7B,MAAM,CAACiB,IAAI,CAACK,aAAL,GAAqB,CAArB,GAAyBD,QAA1B,CAAzB;AAEA,SAAOb,OAAO,CAACC,GAAR,CAAYe,KAAK,CAACG,GAAN,CAAUpB,EAAE,IAAIsB,UAAU,CAAC,MAAMvB,MAAM,CAACC,EAAD,CAAb,CAA1B,CAAZ,EACLG,IADK,CACA,MAAM,CAAE,CADR,EAELoB,KAFK,CAECC,GAAG,IAAIA,GAAG,YAAY7B,QAAf,GAA0B6B,GAAG,CAAC1B,KAA9B,GAAsCG,OAAO,CAACI,MAAR,CAAemB,GAAf,CAF9C,CAAP;AAGA,CAjBD","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// the input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true\n\t}, opts);\n\n\tconst limit = pLimit(opts.concurrency);\n\n\t// start all the promises concurrently with optional limit\n\tconst items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]);\n\n\t// check the promises either serially or concurrently\n\tconst checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n\n\treturn Promise.all(items.map(el => checkLimit(() => finder(el))))\n\t\t.then(() => {})\n\t\t.catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};\n"]},"metadata":{},"sourceType":"script"}