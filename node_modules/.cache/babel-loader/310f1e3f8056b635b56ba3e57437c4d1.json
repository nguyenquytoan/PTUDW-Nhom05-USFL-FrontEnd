{"ast":null,"code":"import Promise from './promise';\nimport { MapEnumerator } from './map';\nimport { fulfill, REJECTED } from './-internal';\nconst EMPTY_OBJECT = {};\n\nclass FilterEnumerator extends MapEnumerator {\n  _checkFullfillment() {\n    if (this._remaining === 0 && this._result !== null) {\n      let result = this._result.filter(val => val !== EMPTY_OBJECT);\n\n      fulfill(this.promise, result);\n      this._result = null;\n    }\n  }\n\n  _setResultAt(state, i, value, firstPass) {\n    if (firstPass) {\n      this._result[i] = value;\n      let val,\n          succeeded = true;\n\n      try {\n        val = this._mapFn(value, i);\n      } catch (error) {\n        succeeded = false;\n\n        this._settledAt(REJECTED, i, error, false);\n      }\n\n      if (succeeded) {\n        this._eachEntry(val, i, false);\n      }\n    } else {\n      this._remaining--;\n\n      if (!value) {\n        this._result[i] = EMPTY_OBJECT;\n      }\n    }\n  }\n\n}\n/**\n `filter` is similar to JavaScript's native `filter` method.\n `filterFn` is eagerly called meaning that as soon as any promise\n  resolves its value will be passed to `filterFn`. `filter` returns\n  a promise that will become fulfilled with the result of running\n  `filterFn` on the values the promises become fulfilled with.\n\n  For example:\n\n  ```javascript\n  import { filter, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n\n  let promises = [promise1, promise2, promise3];\n\n  let filterFn = function(item){\n    return item > 1;\n  };\n\n  filter(promises, filterFn).then(function(result){\n    // result is [ 2, 3 ]\n  });\n  ```\n\n  If any of the `promises` given to `filter` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promise's\n  rejection handler. For example:\n\n  ```javascript\n  import { filter, reject, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error('2'));\n  let promise3 = reject(new Error('3'));\n  let promises = [ promise1, promise2, promise3 ];\n\n  let filterFn = function(item){\n    return item > 1;\n  };\n\n  filter(promises, filterFn).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(reason) {\n    // reason.message === '2'\n  });\n  ```\n\n  `filter` will also wait for any promises returned from `filterFn`.\n  For instance, you may want to fetch a list of users then return a subset\n  of those users based on some asynchronous operation:\n\n  ```javascript\n  import { filter, resolve } from 'rsvp';\n\n  let alice = { name: 'alice' };\n  let bob   = { name: 'bob' };\n  let users = [ alice, bob ];\n\n  let promises = users.map(function(user){\n    return resolve(user);\n  });\n\n  let filterFn = function(user){\n    // Here, Alice has permissions to create a blog post, but Bob does not.\n    return getPrivilegesForUser(user).then(function(privs){\n      return privs.can_create_blog_post === true;\n    });\n  };\n  filter(promises, filterFn).then(function(users){\n    // true, because the server told us only Alice can create a blog post.\n    users.length === 1;\n    // false, because Alice is the only user present in `users`\n    users[0] === bob;\n  });\n  ```\n\n  @method filter\n  @public\n  @static\n  @for rsvp\n  @param {Array} promises\n  @param {Function} filterFn - function to be called on each resolved value to\n  filter the final results.\n  @param {String} [label] optional string describing the promise. Useful for\n  tooling.\n  @return {Promise}\n*/\n\n\nexport default function filter(promises, filterFn, label) {\n  if (typeof filterFn !== 'function') {\n    return Promise.reject(new TypeError(\"filter expects function as a second argument\"), label);\n  }\n\n  return Promise.resolve(promises, label).then(function (promises) {\n    if (!Array.isArray(promises)) {\n      throw new TypeError(\"filter must be called with an array\");\n    }\n\n    return new FilterEnumerator(Promise, promises, filterFn, label).promise;\n  });\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/rsvp/lib/rsvp/filter.js"],"names":["Promise","MapEnumerator","fulfill","REJECTED","EMPTY_OBJECT","FilterEnumerator","_checkFullfillment","_remaining","_result","result","filter","val","promise","_setResultAt","state","i","value","firstPass","succeeded","_mapFn","error","_settledAt","_eachEntry","promises","filterFn","label","reject","TypeError","resolve","then","Array","isArray"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,SAASC,aAAT,QAA8B,OAA9B;AACA,SACEC,OADF,EAEEC,QAFF,QAGO,aAHP;AAKA,MAAMC,YAAY,GAAG,EAArB;;AAEA,MAAMC,gBAAN,SAA+BJ,aAA/B,CAA6C;AAE3CK,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAKC,UAAL,KAAoB,CAApB,IAAyB,KAAKC,OAAL,KAAiB,IAA9C,EAAoD;AAClD,UAAIC,MAAM,GAAG,KAAKD,OAAL,CAAaE,MAAb,CAAqBC,GAAD,IAASA,GAAG,KAAKP,YAArC,CAAb;;AACAF,MAAAA,OAAO,CAAC,KAAKU,OAAN,EAAeH,MAAf,CAAP;AACA,WAAKD,OAAL,GAAe,IAAf;AACD;AACF;;AAEDK,EAAAA,YAAY,CAACC,KAAD,EAAQC,CAAR,EAAWC,KAAX,EAAkBC,SAAlB,EAA6B;AACvC,QAAIA,SAAJ,EAAe;AACb,WAAKT,OAAL,CAAaO,CAAb,IAAkBC,KAAlB;AACA,UAAIL,GAAJ;AAAA,UAASO,SAAS,GAAG,IAArB;;AACA,UAAI;AACFP,QAAAA,GAAG,GAAG,KAAKQ,MAAL,CAAYH,KAAZ,EAAmBD,CAAnB,CAAN;AACD,OAFD,CAEE,OAAOK,KAAP,EAAc;AACdF,QAAAA,SAAS,GAAG,KAAZ;;AACA,aAAKG,UAAL,CAAgBlB,QAAhB,EAA0BY,CAA1B,EAA6BK,KAA7B,EAAoC,KAApC;AACD;;AACD,UAAIF,SAAJ,EAAe;AACb,aAAKI,UAAL,CAAgBX,GAAhB,EAAqBI,CAArB,EAAwB,KAAxB;AACD;AACF,KAZD,MAYO;AACL,WAAKR,UAAL;;AACA,UAAI,CAACS,KAAL,EAAY;AACV,aAAKR,OAAL,CAAaO,CAAb,IAAkBX,YAAlB;AACD;AACF;AACF;;AA7B0C;AAgC7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA,eAAe,SAASM,MAAT,CAAgBa,QAAhB,EAA0BC,QAA1B,EAAoCC,KAApC,EAA2C;AACxD,MAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;AAClC,WAAOxB,OAAO,CAAC0B,MAAR,CAAe,IAAIC,SAAJ,CAAc,8CAAd,CAAf,EAA8EF,KAA9E,CAAP;AACD;;AAED,SAAOzB,OAAO,CAAC4B,OAAR,CAAgBL,QAAhB,EAA0BE,KAA1B,EACJI,IADI,CACC,UAASN,QAAT,EAAmB;AACvB,QAAI,CAACO,KAAK,CAACC,OAAN,CAAcR,QAAd,CAAL,EAA8B;AAC5B,YAAM,IAAII,SAAJ,CAAc,qCAAd,CAAN;AACD;;AACD,WAAO,IAAItB,gBAAJ,CAAqBL,OAArB,EAA8BuB,QAA9B,EAAwCC,QAAxC,EAAkDC,KAAlD,EAAyDb,OAAhE;AACD,GANI,CAAP;AAOD","sourcesContent":["import Promise from './promise';\nimport { MapEnumerator } from './map';\nimport {\n  fulfill,\n  REJECTED\n} from './-internal';\n\nconst EMPTY_OBJECT = {};\n\nclass FilterEnumerator extends MapEnumerator {\n\n  _checkFullfillment() {\n    if (this._remaining === 0 && this._result !== null) {\n      let result = this._result.filter((val) => val !== EMPTY_OBJECT);\n      fulfill(this.promise, result);\n      this._result = null;\n    }\n  }\n\n  _setResultAt(state, i, value, firstPass) {\n    if (firstPass) {\n      this._result[i] = value;\n      let val, succeeded = true;\n      try {\n        val = this._mapFn(value, i);\n      } catch (error) {\n        succeeded = false;\n        this._settledAt(REJECTED, i, error, false);\n      }\n      if (succeeded) {\n        this._eachEntry(val, i, false);\n      }\n    } else {\n      this._remaining--;\n      if (!value) {\n        this._result[i] = EMPTY_OBJECT;\n      }\n    }\n  }\n}\n\n/**\n `filter` is similar to JavaScript's native `filter` method.\n `filterFn` is eagerly called meaning that as soon as any promise\n  resolves its value will be passed to `filterFn`. `filter` returns\n  a promise that will become fulfilled with the result of running\n  `filterFn` on the values the promises become fulfilled with.\n\n  For example:\n\n  ```javascript\n  import { filter, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n\n  let promises = [promise1, promise2, promise3];\n\n  let filterFn = function(item){\n    return item > 1;\n  };\n\n  filter(promises, filterFn).then(function(result){\n    // result is [ 2, 3 ]\n  });\n  ```\n\n  If any of the `promises` given to `filter` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promise's\n  rejection handler. For example:\n\n  ```javascript\n  import { filter, reject, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error('2'));\n  let promise3 = reject(new Error('3'));\n  let promises = [ promise1, promise2, promise3 ];\n\n  let filterFn = function(item){\n    return item > 1;\n  };\n\n  filter(promises, filterFn).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(reason) {\n    // reason.message === '2'\n  });\n  ```\n\n  `filter` will also wait for any promises returned from `filterFn`.\n  For instance, you may want to fetch a list of users then return a subset\n  of those users based on some asynchronous operation:\n\n  ```javascript\n  import { filter, resolve } from 'rsvp';\n\n  let alice = { name: 'alice' };\n  let bob   = { name: 'bob' };\n  let users = [ alice, bob ];\n\n  let promises = users.map(function(user){\n    return resolve(user);\n  });\n\n  let filterFn = function(user){\n    // Here, Alice has permissions to create a blog post, but Bob does not.\n    return getPrivilegesForUser(user).then(function(privs){\n      return privs.can_create_blog_post === true;\n    });\n  };\n  filter(promises, filterFn).then(function(users){\n    // true, because the server told us only Alice can create a blog post.\n    users.length === 1;\n    // false, because Alice is the only user present in `users`\n    users[0] === bob;\n  });\n  ```\n\n  @method filter\n  @public\n  @static\n  @for rsvp\n  @param {Array} promises\n  @param {Function} filterFn - function to be called on each resolved value to\n  filter the final results.\n  @param {String} [label] optional string describing the promise. Useful for\n  tooling.\n  @return {Promise}\n*/\n\nexport default function filter(promises, filterFn, label) {\n  if (typeof filterFn !== 'function') {\n    return Promise.reject(new TypeError(\"filter expects function as a second argument\"), label);\n  }\n\n  return Promise.resolve(promises, label)\n    .then(function(promises) {\n      if (!Array.isArray(promises)) {\n        throw new TypeError(\"filter must be called with an array\");\n      }\n      return new FilterEnumerator(Promise, promises, filterFn, label).promise;\n    });\n}\n"]},"metadata":{},"sourceType":"module"}