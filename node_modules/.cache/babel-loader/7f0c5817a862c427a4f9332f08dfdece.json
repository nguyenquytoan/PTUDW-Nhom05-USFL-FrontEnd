{"ast":null,"code":"'use strict';\n\nconst retry = require('retry');\n\nclass AbortError extends Error {\n  constructor(message) {\n    super();\n\n    if (message instanceof Error) {\n      this.originalError = message;\n      ({\n        message\n      } = message);\n    } else {\n      this.originalError = new Error(message);\n      this.originalError.stack = this.stack;\n    }\n\n    this.name = 'AbortError';\n    this.message = message;\n  }\n\n}\n\nfunction decorateErrorWithCounts(error, attemptNumber, options) {\n  // Minus 1 from attemptNumber because the first attempt does not count as a retry\n  const retriesLeft = options.retries - (attemptNumber - 1);\n  error.attemptNumber = attemptNumber;\n  error.retriesLeft = retriesLeft;\n  return error;\n}\n\nmodule.exports = (input, options) => new Promise((resolve, reject) => {\n  options = Object.assign({\n    onFailedAttempt: () => {},\n    retries: 10\n  }, options);\n  const operation = retry.operation(options);\n  operation.attempt(attemptNumber => Promise.resolve(attemptNumber).then(input).then(resolve, error => {\n    if (error instanceof AbortError) {\n      operation.stop();\n      reject(error.originalError);\n    } else if (error instanceof TypeError) {\n      operation.stop();\n      reject(error);\n    } else if (operation.retry(error)) {\n      decorateErrorWithCounts(error, attemptNumber, options);\n      options.onFailedAttempt(error);\n    } else {\n      decorateErrorWithCounts(error, attemptNumber, options);\n      options.onFailedAttempt(error);\n      reject(operation.mainError());\n    }\n  }));\n});\n\nmodule.exports.AbortError = AbortError;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/p-retry/index.js"],"names":["retry","require","AbortError","Error","constructor","message","originalError","stack","name","decorateErrorWithCounts","error","attemptNumber","options","retriesLeft","retries","module","exports","input","Promise","resolve","reject","Object","assign","onFailedAttempt","operation","attempt","then","stop","TypeError","mainError"],"mappings":"AAAA;;AACA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMC,UAAN,SAAyBC,KAAzB,CAA+B;AAC9BC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACpB;;AAEA,QAAIA,OAAO,YAAYF,KAAvB,EAA8B;AAC7B,WAAKG,aAAL,GAAqBD,OAArB;AACA,OAAC;AAACA,QAAAA;AAAD,UAAYA,OAAb;AACA,KAHD,MAGO;AACN,WAAKC,aAAL,GAAqB,IAAIH,KAAJ,CAAUE,OAAV,CAArB;AACA,WAAKC,aAAL,CAAmBC,KAAnB,GAA2B,KAAKA,KAAhC;AACA;;AAED,SAAKC,IAAL,GAAY,YAAZ;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA;;AAd6B;;AAiB/B,SAASI,uBAAT,CAAiCC,KAAjC,EAAwCC,aAAxC,EAAuDC,OAAvD,EAAgE;AAC/D;AACA,QAAMC,WAAW,GAAGD,OAAO,CAACE,OAAR,IAAmBH,aAAa,GAAG,CAAnC,CAApB;AAEAD,EAAAA,KAAK,CAACC,aAAN,GAAsBA,aAAtB;AACAD,EAAAA,KAAK,CAACG,WAAN,GAAoBA,WAApB;AAEA,SAAOH,KAAP;AACA;;AAEDK,MAAM,CAACC,OAAP,GAAiB,CAACC,KAAD,EAAQL,OAAR,KAAoB,IAAIM,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrER,EAAAA,OAAO,GAAGS,MAAM,CAACC,MAAP,CAAc;AACvBC,IAAAA,eAAe,EAAE,MAAM,CAAE,CADF;AAEvBT,IAAAA,OAAO,EAAE;AAFc,GAAd,EAGPF,OAHO,CAAV;AAKA,QAAMY,SAAS,GAAGxB,KAAK,CAACwB,SAAN,CAAgBZ,OAAhB,CAAlB;AAEAY,EAAAA,SAAS,CAACC,OAAV,CAAkBd,aAAa,IAAIO,OAAO,CAACC,OAAR,CAAgBR,aAAhB,EACjCe,IADiC,CAC5BT,KAD4B,EAEjCS,IAFiC,CAE5BP,OAF4B,EAEnBT,KAAK,IAAI;AACvB,QAAIA,KAAK,YAAYR,UAArB,EAAiC;AAChCsB,MAAAA,SAAS,CAACG,IAAV;AACAP,MAAAA,MAAM,CAACV,KAAK,CAACJ,aAAP,CAAN;AACA,KAHD,MAGO,IAAII,KAAK,YAAYkB,SAArB,EAAgC;AACtCJ,MAAAA,SAAS,CAACG,IAAV;AACAP,MAAAA,MAAM,CAACV,KAAD,CAAN;AACA,KAHM,MAGA,IAAIc,SAAS,CAACxB,KAAV,CAAgBU,KAAhB,CAAJ,EAA4B;AAClCD,MAAAA,uBAAuB,CAACC,KAAD,EAAQC,aAAR,EAAuBC,OAAvB,CAAvB;AACAA,MAAAA,OAAO,CAACW,eAAR,CAAwBb,KAAxB;AACA,KAHM,MAGA;AACND,MAAAA,uBAAuB,CAACC,KAAD,EAAQC,aAAR,EAAuBC,OAAvB,CAAvB;AACAA,MAAAA,OAAO,CAACW,eAAR,CAAwBb,KAAxB;AACAU,MAAAA,MAAM,CAACI,SAAS,CAACK,SAAV,EAAD,CAAN;AACA;AACD,GAjBiC,CAAnC;AAmBA,CA3BoC,CAArC;;AA6BAd,MAAM,CAACC,OAAP,CAAed,UAAf,GAA4BA,UAA5B","sourcesContent":["'use strict';\nconst retry = require('retry');\n\nclass AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nfunction decorateErrorWithCounts(error, attemptNumber, options) {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\n\treturn error;\n}\n\nmodule.exports = (input, options) => new Promise((resolve, reject) => {\n\toptions = Object.assign({\n\t\tonFailedAttempt: () => {},\n\t\tretries: 10\n\t}, options);\n\n\tconst operation = retry.operation(options);\n\n\toperation.attempt(attemptNumber => Promise.resolve(attemptNumber)\n\t\t.then(input)\n\t\t.then(resolve, error => {\n\t\t\tif (error instanceof AbortError) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error.originalError);\n\t\t\t} else if (error instanceof TypeError) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error);\n\t\t\t} else if (operation.retry(error)) {\n\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\t\t\t\toptions.onFailedAttempt(error);\n\t\t\t} else {\n\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\t\t\t\toptions.onFailedAttempt(error);\n\t\t\t\treject(operation.mainError());\n\t\t\t}\n\t\t})\n\t);\n});\n\nmodule.exports.AbortError = AbortError;\n"]},"metadata":{},"sourceType":"script"}