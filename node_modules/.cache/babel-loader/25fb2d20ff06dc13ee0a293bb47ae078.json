{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\n\nmodule.exports._cleanupOnExit = cleanupOnExit;\n\nvar fs = require('graceful-fs');\n\nvar MurmurHash3 = require('imurmurhash');\n\nvar onExit = require('signal-exit');\n\nvar path = require('path');\n\nvar activeFiles = {}; // if we run inside of a worker_thread, `process.pid` is not unique\n\n/* istanbul ignore next */\n\nvar threadId = function getId() {\n  try {\n    var workerThreads = require('worker_threads'); /// if we are in main thread, this is set to `0`\n\n\n    return workerThreads.threadId;\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0;\n  }\n}();\n\nvar invocations = 0;\n\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();\n}\n\nfunction cleanupOnExit(tmpfile) {\n  return function () {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);\n    } catch (_) {}\n  };\n}\n\nfunction writeFile(filename, data, options, callback) {\n  if (options) {\n    if (options instanceof Function) {\n      callback = options;\n      options = {};\n    } else if (typeof options === 'string') {\n      options = {\n        encoding: options\n      };\n    }\n  } else {\n    options = {};\n  }\n\n  var Promise = options.Promise || global.Promise;\n  var truename;\n  var fd;\n  var tmpfile;\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n\n  var removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));\n  var absoluteName = path.resolve(filename);\n  new Promise(function serializeSameFile(resolve) {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = [];\n    activeFiles[absoluteName].push(resolve); // add this job to the queue\n\n    if (activeFiles[absoluteName].length === 1) resolve(); // kick off the first one\n  }).then(function getRealPath() {\n    return new Promise(function (resolve) {\n      fs.realpath(filename, function (_, realname) {\n        truename = realname || filename;\n        tmpfile = getTmpname(truename);\n        resolve();\n      });\n    });\n  }).then(function stat() {\n    return new Promise(function stat(resolve) {\n      if (options.mode && options.chown) resolve();else {\n        // Either mode or chown is not explicitly set\n        // Default behavior is to copy it from original file\n        fs.stat(truename, function (err, stats) {\n          if (err || !stats) resolve();else {\n            options = Object.assign({}, options);\n\n            if (options.mode == null) {\n              options.mode = stats.mode;\n            }\n\n            if (options.chown == null && process.getuid) {\n              options.chown = {\n                uid: stats.uid,\n                gid: stats.gid\n              };\n            }\n\n            resolve();\n          }\n        });\n      }\n    });\n  }).then(function thenWriteFile() {\n    return new Promise(function (resolve, reject) {\n      fs.open(tmpfile, 'w', options.mode, function (err, _fd) {\n        fd = _fd;\n        if (err) reject(err);else resolve();\n      });\n    });\n  }).then(function write() {\n    return new Promise(function (resolve, reject) {\n      if (Buffer.isBuffer(data)) {\n        fs.write(fd, data, 0, data.length, 0, function (err) {\n          if (err) reject(err);else resolve();\n        });\n      } else if (data != null) {\n        fs.write(fd, String(data), 0, String(options.encoding || 'utf8'), function (err) {\n          if (err) reject(err);else resolve();\n        });\n      } else resolve();\n    });\n  }).then(function syncAndClose() {\n    if (options.fsync !== false) {\n      return new Promise(function (resolve, reject) {\n        fs.fsync(fd, function (err) {\n          if (err) reject(err);else fs.close(fd, resolve);\n        });\n      });\n    }\n  }).then(function chown() {\n    if (options.chown) {\n      return new Promise(function (resolve, reject) {\n        fs.chown(tmpfile, options.chown.uid, options.chown.gid, function (err) {\n          if (err) reject(err);else resolve();\n        });\n      });\n    }\n  }).then(function chmod() {\n    if (options.mode) {\n      return new Promise(function (resolve, reject) {\n        fs.chmod(tmpfile, options.mode, function (err) {\n          if (err) reject(err);else resolve();\n        });\n      });\n    }\n  }).then(function rename() {\n    return new Promise(function (resolve, reject) {\n      fs.rename(tmpfile, truename, function (err) {\n        if (err) reject(err);else resolve();\n      });\n    });\n  }).then(function success() {\n    removeOnExitHandler();\n    callback();\n  }, function fail(err) {\n    removeOnExitHandler();\n    fs.unlink(tmpfile, function () {\n      callback(err);\n    });\n  }).then(function checkQueue() {\n    activeFiles[absoluteName].shift(); // remove the element added by serializeSameFile\n\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0](); // start next job if one is pending\n    } else delete activeFiles[absoluteName];\n  });\n}\n\nfunction writeFileSync(filename, data, options) {\n  if (typeof options === 'string') options = {\n    encoding: options\n  };else if (!options) options = {};\n\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {// it's ok, it'll happen on a not yet existing file\n  }\n\n  var tmpfile = getTmpname(filename);\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename);\n        options = Object.assign({}, options);\n\n        if (!options.mode) {\n          options.mode = stats.mode;\n        }\n\n        if (!options.chown && process.getuid) {\n          options.chown = {\n            uid: stats.uid,\n            gid: stats.gid\n          };\n        }\n      } catch (ex) {// ignore stat errors\n      }\n    }\n\n    var cleanup = cleanupOnExit(tmpfile);\n    var removeOnExitHandler = onExit(cleanup);\n    var fd = fs.openSync(tmpfile, 'w', options.mode);\n\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd);\n    }\n\n    fs.closeSync(fd);\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n    if (options.mode) fs.chmodSync(tmpfile, options.mode);\n    fs.renameSync(tmpfile, filename);\n    removeOnExitHandler();\n  } catch (err) {\n    removeOnExitHandler();\n    cleanup();\n    throw err;\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/write-file-atomic/index.js"],"names":["module","exports","writeFile","sync","writeFileSync","_getTmpname","getTmpname","_cleanupOnExit","cleanupOnExit","fs","require","MurmurHash3","onExit","path","activeFiles","threadId","getId","workerThreads","e","invocations","filename","__filename","hash","String","process","pid","result","tmpfile","unlinkSync","_","data","options","callback","Function","encoding","Promise","global","truename","fd","removeOnExitHandler","absoluteName","resolve","serializeSameFile","push","length","then","getRealPath","realpath","realname","stat","mode","chown","err","stats","Object","assign","getuid","uid","gid","thenWriteFile","reject","open","_fd","write","Buffer","isBuffer","syncAndClose","fsync","close","chmod","rename","success","fail","unlink","checkQueue","shift","realpathSync","ex","statSync","cleanup","openSync","writeSync","fsyncSync","closeSync","chownSync","chmodSync","renameSync"],"mappings":"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","sourcesContent":["'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit\n\nvar fs = require('graceful-fs')\nvar MurmurHash3 = require('imurmurhash')\nvar onExit = require('signal-exit')\nvar path = require('path')\nvar activeFiles = {}\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nvar threadId = (function getId () {\n  try {\n    var workerThreads = require('worker_threads')\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0\n  }\n})()\n\nvar invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(threadId))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction cleanupOnExit (tmpfile) {\n  return function () {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)\n    } catch (_) {}\n  }\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options) {\n    if (options instanceof Function) {\n      callback = options\n      options = {}\n    } else if (typeof options === 'string') {\n      options = { encoding: options }\n    }\n  } else {\n    options = {}\n  }\n\n  var Promise = options.Promise || global.Promise\n  var truename\n  var fd\n  var tmpfile\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  var removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))\n  var absoluteName = path.resolve(filename)\n\n  new Promise(function serializeSameFile (resolve) {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = []\n\n    activeFiles[absoluteName].push(resolve) // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) resolve() // kick off the first one\n  }).then(function getRealPath () {\n    return new Promise(function (resolve) {\n      fs.realpath(filename, function (_, realname) {\n        truename = realname || filename\n        tmpfile = getTmpname(truename)\n        resolve()\n      })\n    })\n  }).then(function stat () {\n    return new Promise(function stat (resolve) {\n      if (options.mode && options.chown) resolve()\n      else {\n        // Either mode or chown is not explicitly set\n        // Default behavior is to copy it from original file\n        fs.stat(truename, function (err, stats) {\n          if (err || !stats) resolve()\n          else {\n            options = Object.assign({}, options)\n\n            if (options.mode == null) {\n              options.mode = stats.mode\n            }\n            if (options.chown == null && process.getuid) {\n              options.chown = { uid: stats.uid, gid: stats.gid }\n            }\n            resolve()\n          }\n        })\n      }\n    })\n  }).then(function thenWriteFile () {\n    return new Promise(function (resolve, reject) {\n      fs.open(tmpfile, 'w', options.mode, function (err, _fd) {\n        fd = _fd\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }).then(function write () {\n    return new Promise(function (resolve, reject) {\n      if (Buffer.isBuffer(data)) {\n        fs.write(fd, data, 0, data.length, 0, function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      } else if (data != null) {\n        fs.write(fd, String(data), 0, String(options.encoding || 'utf8'), function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      } else resolve()\n    })\n  }).then(function syncAndClose () {\n    if (options.fsync !== false) {\n      return new Promise(function (resolve, reject) {\n        fs.fsync(fd, function (err) {\n          if (err) reject(err)\n          else fs.close(fd, resolve)\n        })\n      })\n    }\n  }).then(function chown () {\n    if (options.chown) {\n      return new Promise(function (resolve, reject) {\n        fs.chown(tmpfile, options.chown.uid, options.chown.gid, function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      })\n    }\n  }).then(function chmod () {\n    if (options.mode) {\n      return new Promise(function (resolve, reject) {\n        fs.chmod(tmpfile, options.mode, function (err) {\n          if (err) reject(err)\n          else resolve()\n        })\n      })\n    }\n  }).then(function rename () {\n    return new Promise(function (resolve, reject) {\n      fs.rename(tmpfile, truename, function (err) {\n        if (err) reject(err)\n        else resolve()\n      })\n    })\n  }).then(function success () {\n    removeOnExitHandler()\n    callback()\n  }, function fail (err) {\n    removeOnExitHandler()\n    fs.unlink(tmpfile, function () {\n      callback(err)\n    })\n  }).then(function checkQueue () {\n    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0]() // start next job if one is pending\n    } else delete activeFiles[absoluteName]\n  })\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (typeof options === 'string') options = { encoding: options }\n  else if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename)\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename)\n        options = Object.assign({}, options)\n        if (!options.mode) {\n          options.mode = stats.mode\n        }\n        if (!options.chown && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      } catch (ex) {\n        // ignore stat errors\n      }\n    }\n\n    var cleanup = cleanupOnExit(tmpfile)\n    var removeOnExitHandler = onExit(cleanup)\n    var fd = fs.openSync(tmpfile, 'w', options.mode)\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd)\n    }\n    fs.closeSync(fd)\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n    if (options.mode) fs.chmodSync(tmpfile, options.mode)\n    fs.renameSync(tmpfile, filename)\n    removeOnExitHandler()\n  } catch (err) {\n    removeOnExitHandler()\n    cleanup()\n    throw err\n  }\n}\n"]},"metadata":{},"sourceType":"script"}