{"ast":null,"code":"\"use strict\";\n\nvar isPrototype = require(\"../prototype/is\"),\n    isPlainObject = require(\"../plain-object/is\");\n\nvar objectToString = Object.prototype.toString; // Recognize host specific errors (e.g. DOMException)\n\nvar errorTaggedStringRe = /^\\[object .*(?:Error|Exception)\\]$/,\n    errorNameRe = /^[^\\s]*(?:Error|Exception)$/;\n\nmodule.exports = function (value) {\n  if (!value) return false;\n  var name; // Sanity check (reject objects which do not expose common Error interface)\n\n  try {\n    name = value.name;\n    if (typeof name !== \"string\") return false;\n    if (typeof value.message !== \"string\") return false;\n  } catch (error) {\n    return false;\n  } // Ensure its a native-like Error object\n  // (has [[ErrorData]] slot, or was created to resemble one)\n  // Note: It's not a 100% bulletproof check of confirming that as:\n  // - In ES2015+ string tag can be overriden via Symbol.toStringTag property\n  // - Host errors do not share native error tag. Still we rely on assumption that\n  //   tag for each error will end either with `Error` or `Exception` string\n  // - In pre ES2015 era, no custom errors will share the error tag.\n\n\n  if (!errorTaggedStringRe.test(objectToString.call(value))) {\n    // Definitely not an ES2015 error instance, but could still be an error\n    // (created via e.g. CustomError.prototype = Object.create(Error.prototype))\n    try {\n      if (name !== value.constructor.name) return false;\n    } catch (error) {\n      return false;\n    }\n\n    if (!errorNameRe.test(name)) return false;\n    if (isPlainObject(value)) return false;\n  }\n\n  return !isPrototype(value);\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/type/error/is.js"],"names":["isPrototype","require","isPlainObject","objectToString","Object","prototype","toString","errorTaggedStringRe","errorNameRe","module","exports","value","name","message","error","test","call","constructor"],"mappings":"AAAA;;AAEA,IAAIA,WAAW,GAAKC,OAAO,CAAC,iBAAD,CAA3B;AAAA,IACIC,aAAa,GAAGD,OAAO,CAAC,oBAAD,CAD3B;;AAGA,IAAIE,cAAc,GAAGC,MAAM,CAACC,SAAP,CAAiBC,QAAtC,C,CAEA;;AACA,IAAIC,mBAAmB,GAAG,oCAA1B;AAAA,IACIC,WAAW,GAAG,6BADlB;;AAGAC,MAAM,CAACC,OAAP,GAAiB,UAAUC,KAAV,EAAiB;AACjC,MAAI,CAACA,KAAL,EAAY,OAAO,KAAP;AAEZ,MAAIC,IAAJ,CAHiC,CAIjC;;AACA,MAAI;AACHA,IAAAA,IAAI,GAAGD,KAAK,CAACC,IAAb;AACA,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B,OAAO,KAAP;AAC9B,QAAI,OAAOD,KAAK,CAACE,OAAb,KAAyB,QAA7B,EAAuC,OAAO,KAAP;AACvC,GAJD,CAIE,OAAOC,KAAP,EAAc;AACf,WAAO,KAAP;AACA,GAXgC,CAajC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAI,CAACP,mBAAmB,CAACQ,IAApB,CAAyBZ,cAAc,CAACa,IAAf,CAAoBL,KAApB,CAAzB,CAAL,EAA2D;AAC1D;AACA;AACA,QAAI;AACH,UAAIC,IAAI,KAAKD,KAAK,CAACM,WAAN,CAAkBL,IAA/B,EAAqC,OAAO,KAAP;AACrC,KAFD,CAEE,OAAOE,KAAP,EAAc;AACf,aAAO,KAAP;AACA;;AACD,QAAI,CAACN,WAAW,CAACO,IAAZ,CAAiBH,IAAjB,CAAL,EAA6B,OAAO,KAAP;AAC7B,QAAIV,aAAa,CAACS,KAAD,CAAjB,EAA0B,OAAO,KAAP;AAC1B;;AAED,SAAO,CAACX,WAAW,CAACW,KAAD,CAAnB;AACA,CAjCD","sourcesContent":["\"use strict\";\n\nvar isPrototype   = require(\"../prototype/is\")\n  , isPlainObject = require(\"../plain-object/is\");\n\nvar objectToString = Object.prototype.toString;\n\n// Recognize host specific errors (e.g. DOMException)\nvar errorTaggedStringRe = /^\\[object .*(?:Error|Exception)\\]$/\n  , errorNameRe = /^[^\\s]*(?:Error|Exception)$/;\n\nmodule.exports = function (value) {\n\tif (!value) return false;\n\n\tvar name;\n\t// Sanity check (reject objects which do not expose common Error interface)\n\ttry {\n\t\tname = value.name;\n\t\tif (typeof name !== \"string\") return false;\n\t\tif (typeof value.message !== \"string\") return false;\n\t} catch (error) {\n\t\treturn false;\n\t}\n\n\t// Ensure its a native-like Error object\n\t// (has [[ErrorData]] slot, or was created to resemble one)\n\t// Note: It's not a 100% bulletproof check of confirming that as:\n\t// - In ES2015+ string tag can be overriden via Symbol.toStringTag property\n\t// - Host errors do not share native error tag. Still we rely on assumption that\n\t//   tag for each error will end either with `Error` or `Exception` string\n\t// - In pre ES2015 era, no custom errors will share the error tag.\n\tif (!errorTaggedStringRe.test(objectToString.call(value))) {\n\t\t// Definitely not an ES2015 error instance, but could still be an error\n\t\t// (created via e.g. CustomError.prototype = Object.create(Error.prototype))\n\t\ttry {\n\t\t\tif (name !== value.constructor.name) return false;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!errorNameRe.test(name)) return false;\n\t\tif (isPlainObject(value)) return false;\n\t}\n\n\treturn !isPrototype(value);\n};\n"]},"metadata":{},"sourceType":"script"}