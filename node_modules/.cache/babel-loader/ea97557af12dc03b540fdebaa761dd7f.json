{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = WatchmanWatcher;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _assert() {\n  const data = _interopRequireDefault(require('assert'));\n\n  _assert = function _assert() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function _fbWatchman() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _common() {\n  const data = _interopRequireDefault(require('sane/src/common'));\n\n  _common = function _common() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _recrawlWarningDedupe() {\n  const data = _interopRequireDefault(require('sane/src/utils/recrawl-warning-dedupe'));\n\n  _recrawlWarningDedupe = function _recrawlWarningDedupe() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst CHANGE_EVENT = _common().default.CHANGE_EVENT;\n\nconst DELETE_EVENT = _common().default.DELETE_EVENT;\n\nconst ADD_EVENT = _common().default.ADD_EVENT;\n\nconst ALL_EVENT = _common().default.ALL_EVENT;\n\nconst SUB_NAME = 'sane-sub';\n/**\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  _common().default.assignOptions(this, opts);\n\n  this.root = _path().default.resolve(dir);\n  this.init();\n} // eslint-disable-next-line no-proto\n\n\nWatchmanWatcher.prototype.__proto__ = _events().EventEmitter.prototype;\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype.init = function () {\n  if (this.client) {\n    this.client.removeAllListeners();\n  }\n\n  const self = this;\n  this.client = new (_fbWatchman().default.Client)();\n  this.client.on('error', error => {\n    self.emit('error', error);\n  });\n  this.client.on('subscription', this.handleChangeEvent.bind(this));\n  this.client.on('end', () => {\n    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');\n    self.init();\n  });\n  this.watchProjectInfo = null;\n\n  function getWatchRoot() {\n    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;\n  }\n\n  function onCapability(error, resp) {\n    if (handleError(self, error)) {\n      // The Watchman watcher is unusable on this system, we cannot continue\n      return;\n    }\n\n    handleWarning(resp);\n    self.capabilities = resp.capabilities;\n\n    if (self.capabilities.relative_root) {\n      self.client.command(['watch-project', getWatchRoot()], onWatchProject);\n    } else {\n      self.client.command(['watch', getWatchRoot()], onWatch);\n    }\n  }\n\n  function onWatchProject(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.watchProjectInfo = {\n      relativePath: resp.relative_path ? resp.relative_path : '',\n      root: resp.watch\n    };\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onWatch(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onClock(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    const options = {\n      fields: ['name', 'exists', 'new'],\n      since: resp.clock\n    }; // If the server has the wildmatch capability available it supports\n    // the recursive **/*.foo style match and we can offload our globs\n    // to the watchman server.  This saves both on data size to be\n    // communicated back to us and compute for evaluating the globs\n    // in our node process.\n\n    if (self.capabilities.wildmatch) {\n      if (self.globs.length === 0) {\n        if (!self.dot) {\n          // Make sure we honor the dot option if even we're not using globs.\n          options.expression = ['match', '**', 'wholename', {\n            includedotfiles: false\n          }];\n        }\n      } else {\n        options.expression = ['anyof'];\n\n        for (const i in self.globs) {\n          options.expression.push(['match', self.globs[i], 'wholename', {\n            includedotfiles: self.dot\n          }]);\n        }\n      }\n    }\n\n    if (self.capabilities.relative_root) {\n      options.relative_root = self.watchProjectInfo.relativePath;\n    }\n\n    self.client.command(['subscribe', getWatchRoot(), SUB_NAME, options], onSubscribe);\n  }\n\n  function onSubscribe(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.emit('ready');\n  }\n\n  self.client.capabilityCheck({\n    optional: ['wildmatch', 'relative_root']\n  }, onCapability);\n};\n/**\n * Handles a change event coming from the subscription.\n *\n * @param {Object} resp\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleChangeEvent = function (resp) {\n  _assert().default.equal(resp.subscription, SUB_NAME, 'Invalid subscription event.');\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\n\nWatchmanWatcher.prototype.handleFileChange = function (changeDescriptor) {\n  const self = this;\n  let absPath;\n  let relativePath;\n\n  if (this.capabilities.relative_root) {\n    relativePath = changeDescriptor.name;\n    absPath = _path().default.join(this.watchProjectInfo.root, this.watchProjectInfo.relativePath, relativePath);\n  } else {\n    absPath = _path().default.join(this.root, changeDescriptor.name);\n    relativePath = changeDescriptor.name;\n  }\n\n  if (!(self.capabilities.wildmatch && !this.hasIgnore) && !_common().default.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    self.emitEvent(DELETE_EVENT, relativePath, self.root);\n  } else {\n    _fs().default.lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (handleError(self, error)) {\n        return;\n      }\n\n      const eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT; // Change event on dirs are mostly useless.\n\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        self.emitEvent(eventType, relativePath, self.root, stat);\n      }\n    });\n  }\n};\n/**\n * Dispatches the event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\n\nWatchmanWatcher.prototype.emitEvent = function (eventType, filepath, root, stat) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n/**\n * Closes the watcher.\n *\n * @param {function} callback\n * @private\n */\n\n\nWatchmanWatcher.prototype.close = function (callback) {\n  this.client.removeAllListeners();\n  this.client.end();\n  callback && callback(null, true);\n};\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\n\nfunction handleError(self, error) {\n  if (error != null) {\n    self.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\n\nfunction handleWarning(resp) {\n  if ('warning' in resp) {\n    if (_recrawlWarningDedupe().default.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-haste-map/build/lib/WatchmanWatcher.js"],"names":["Object","defineProperty","exports","value","default","WatchmanWatcher","_fs","data","_interopRequireDefault","require","_path","_assert","_events","_fbWatchman","_common","_recrawlWarningDedupe","obj","__esModule","CHANGE_EVENT","DELETE_EVENT","ADD_EVENT","ALL_EVENT","SUB_NAME","dir","opts","assignOptions","root","resolve","init","prototype","__proto__","EventEmitter","client","removeAllListeners","self","Client","on","error","emit","handleChangeEvent","bind","console","warn","watchProjectInfo","getWatchRoot","onCapability","resp","handleError","handleWarning","capabilities","relative_root","command","onWatchProject","onWatch","relativePath","relative_path","watch","onClock","options","fields","since","clock","wildmatch","globs","length","dot","expression","includedotfiles","i","push","onSubscribe","capabilityCheck","optional","equal","subscription","is_fresh_instance","Array","isArray","files","forEach","handleFileChange","changeDescriptor","absPath","name","join","hasIgnore","isFileIncluded","doIgnore","exists","emitEvent","lstat","stat","code","eventType","new","isDirectory","filepath","close","callback","end","isRecrawlWarningDupe","warning"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = WatchmanWatcher;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require('fs'));\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _assert() {\n  const data = _interopRequireDefault(require('assert'));\n\n  _assert = function _assert() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = require('events');\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fbWatchman() {\n  const data = _interopRequireDefault(require('fb-watchman'));\n\n  _fbWatchman = function _fbWatchman() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _common() {\n  const data = _interopRequireDefault(require('sane/src/common'));\n\n  _common = function _common() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _recrawlWarningDedupe() {\n  const data = _interopRequireDefault(\n    require('sane/src/utils/recrawl-warning-dedupe')\n  );\n\n  _recrawlWarningDedupe = function _recrawlWarningDedupe() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst CHANGE_EVENT = _common().default.CHANGE_EVENT;\n\nconst DELETE_EVENT = _common().default.DELETE_EVENT;\n\nconst ADD_EVENT = _common().default.ADD_EVENT;\n\nconst ALL_EVENT = _common().default.ALL_EVENT;\n\nconst SUB_NAME = 'sane-sub';\n/**\n * Watches `dir`.\n *\n * @class PollWatcher\n * @param String dir\n * @param {Object} opts\n * @public\n */\n\nfunction WatchmanWatcher(dir, opts) {\n  _common().default.assignOptions(this, opts);\n\n  this.root = _path().default.resolve(dir);\n  this.init();\n} // eslint-disable-next-line no-proto\n\nWatchmanWatcher.prototype.__proto__ = _events().EventEmitter.prototype;\n/**\n * Run the watchman `watch` command on the root and subscribe to changes.\n *\n * @private\n */\n\nWatchmanWatcher.prototype.init = function() {\n  if (this.client) {\n    this.client.removeAllListeners();\n  }\n\n  const self = this;\n  this.client = new (_fbWatchman()).default.Client();\n  this.client.on('error', error => {\n    self.emit('error', error);\n  });\n  this.client.on('subscription', this.handleChangeEvent.bind(this));\n  this.client.on('end', () => {\n    console.warn('[sane] Warning: Lost connection to watchman, reconnecting..');\n    self.init();\n  });\n  this.watchProjectInfo = null;\n\n  function getWatchRoot() {\n    return self.watchProjectInfo ? self.watchProjectInfo.root : self.root;\n  }\n\n  function onCapability(error, resp) {\n    if (handleError(self, error)) {\n      // The Watchman watcher is unusable on this system, we cannot continue\n      return;\n    }\n\n    handleWarning(resp);\n    self.capabilities = resp.capabilities;\n\n    if (self.capabilities.relative_root) {\n      self.client.command(['watch-project', getWatchRoot()], onWatchProject);\n    } else {\n      self.client.command(['watch', getWatchRoot()], onWatch);\n    }\n  }\n\n  function onWatchProject(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.watchProjectInfo = {\n      relativePath: resp.relative_path ? resp.relative_path : '',\n      root: resp.watch\n    };\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onWatch(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.client.command(['clock', getWatchRoot()], onClock);\n  }\n\n  function onClock(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    const options = {\n      fields: ['name', 'exists', 'new'],\n      since: resp.clock\n    }; // If the server has the wildmatch capability available it supports\n    // the recursive **/*.foo style match and we can offload our globs\n    // to the watchman server.  This saves both on data size to be\n    // communicated back to us and compute for evaluating the globs\n    // in our node process.\n\n    if (self.capabilities.wildmatch) {\n      if (self.globs.length === 0) {\n        if (!self.dot) {\n          // Make sure we honor the dot option if even we're not using globs.\n          options.expression = [\n            'match',\n            '**',\n            'wholename',\n            {\n              includedotfiles: false\n            }\n          ];\n        }\n      } else {\n        options.expression = ['anyof'];\n\n        for (const i in self.globs) {\n          options.expression.push([\n            'match',\n            self.globs[i],\n            'wholename',\n            {\n              includedotfiles: self.dot\n            }\n          ]);\n        }\n      }\n    }\n\n    if (self.capabilities.relative_root) {\n      options.relative_root = self.watchProjectInfo.relativePath;\n    }\n\n    self.client.command(\n      ['subscribe', getWatchRoot(), SUB_NAME, options],\n      onSubscribe\n    );\n  }\n\n  function onSubscribe(error, resp) {\n    if (handleError(self, error)) {\n      return;\n    }\n\n    handleWarning(resp);\n    self.emit('ready');\n  }\n\n  self.client.capabilityCheck(\n    {\n      optional: ['wildmatch', 'relative_root']\n    },\n    onCapability\n  );\n};\n/**\n * Handles a change event coming from the subscription.\n *\n * @param {Object} resp\n * @private\n */\n\nWatchmanWatcher.prototype.handleChangeEvent = function(resp) {\n  _assert().default.equal(\n    resp.subscription,\n    SUB_NAME,\n    'Invalid subscription event.'\n  );\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (resp.is_fresh_instance) {\n    this.emit('fresh_instance');\n  }\n\n  if (Array.isArray(resp.files)) {\n    resp.files.forEach(this.handleFileChange, this);\n  }\n};\n/**\n * Handles a single change event record.\n *\n * @param {Object} changeDescriptor\n * @private\n */\n\nWatchmanWatcher.prototype.handleFileChange = function(changeDescriptor) {\n  const self = this;\n  let absPath;\n  let relativePath;\n\n  if (this.capabilities.relative_root) {\n    relativePath = changeDescriptor.name;\n    absPath = _path().default.join(\n      this.watchProjectInfo.root,\n      this.watchProjectInfo.relativePath,\n      relativePath\n    );\n  } else {\n    absPath = _path().default.join(this.root, changeDescriptor.name);\n    relativePath = changeDescriptor.name;\n  }\n\n  if (\n    !(self.capabilities.wildmatch && !this.hasIgnore) &&\n    !_common().default.isFileIncluded(\n      this.globs,\n      this.dot,\n      this.doIgnore,\n      relativePath\n    )\n  ) {\n    return;\n  }\n\n  if (!changeDescriptor.exists) {\n    self.emitEvent(DELETE_EVENT, relativePath, self.root);\n  } else {\n    _fs().default.lstat(absPath, (error, stat) => {\n      // Files can be deleted between the event and the lstat call\n      // the most reliable thing to do here is to ignore the event.\n      if (error && error.code === 'ENOENT') {\n        return;\n      }\n\n      if (handleError(self, error)) {\n        return;\n      }\n\n      const eventType = changeDescriptor.new ? ADD_EVENT : CHANGE_EVENT; // Change event on dirs are mostly useless.\n\n      if (!(eventType === CHANGE_EVENT && stat.isDirectory())) {\n        self.emitEvent(eventType, relativePath, self.root, stat);\n      }\n    });\n  }\n};\n/**\n * Dispatches the event.\n *\n * @param {string} eventType\n * @param {string} filepath\n * @param {string} root\n * @param {fs.Stat} stat\n * @private\n */\n\nWatchmanWatcher.prototype.emitEvent = function(\n  eventType,\n  filepath,\n  root,\n  stat\n) {\n  this.emit(eventType, filepath, root, stat);\n  this.emit(ALL_EVENT, eventType, filepath, root, stat);\n};\n/**\n * Closes the watcher.\n *\n * @param {function} callback\n * @private\n */\n\nWatchmanWatcher.prototype.close = function(callback) {\n  this.client.removeAllListeners();\n  this.client.end();\n  callback && callback(null, true);\n};\n/**\n * Handles an error and returns true if exists.\n *\n * @param {WatchmanWatcher} self\n * @param {Error} error\n * @private\n */\n\nfunction handleError(self, error) {\n  if (error != null) {\n    self.emit('error', error);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Handles a warning in the watchman resp object.\n *\n * @param {object} resp\n * @private\n */\n\nfunction handleWarning(resp) {\n  if ('warning' in resp) {\n    if (_recrawlWarningDedupe().default.isRecrawlWarningDupe(resp.warning)) {\n      return true;\n    }\n\n    console.warn(resp.warning);\n    return true;\n  } else {\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}