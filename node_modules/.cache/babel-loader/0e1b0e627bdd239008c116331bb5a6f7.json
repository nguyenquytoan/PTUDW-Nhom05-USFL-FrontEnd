{"ast":null,"code":"const Minipass = require('minipass');\n\nconst _flush = Symbol('_flush');\n\nconst _flushed = Symbol('_flushed');\n\nconst _flushing = Symbol('_flushing');\n\nclass Flush extends Minipass {\n  constructor(opt = {}) {\n    if (typeof opt === 'function') opt = {\n      flush: opt\n    };\n    super(opt); // or extend this class and provide a 'flush' method in your subclass\n\n    if (typeof opt.flush !== 'function' && typeof this.flush !== 'function') throw new TypeError('must provide flush function in options');\n    this[_flush] = opt.flush || this.flush;\n  }\n\n  emit(ev, ...data) {\n    if (ev !== 'end' && ev !== 'finish' || this[_flushed]) return super.emit(ev, ...data);\n    if (this[_flushing]) return;\n    this[_flushing] = true;\n\n    const afterFlush = er => {\n      this[_flushed] = true;\n      er ? super.emit('error', er) : super.emit('end');\n    };\n\n    const ret = this[_flush](afterFlush);\n\n    if (ret && ret.then) ret.then(() => afterFlush(), er => afterFlush(er));\n  }\n\n}\n\nmodule.exports = Flush;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/minipass-flush/index.js"],"names":["Minipass","require","_flush","Symbol","_flushed","_flushing","Flush","constructor","opt","flush","TypeError","emit","ev","data","afterFlush","er","ret","then","module","exports"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGC,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,MAAM,CAAC,UAAD,CAAvB;;AACA,MAAME,SAAS,GAAGF,MAAM,CAAC,WAAD,CAAxB;;AACA,MAAMG,KAAN,SAAoBN,QAApB,CAA6B;AAC3BO,EAAAA,WAAW,CAAEC,GAAG,GAAG,EAAR,EAAY;AACrB,QAAI,OAAOA,GAAP,KAAe,UAAnB,EACEA,GAAG,GAAG;AAAEC,MAAAA,KAAK,EAAED;AAAT,KAAN;AAEF,UAAMA,GAAN,EAJqB,CAMrB;;AACA,QAAI,OAAOA,GAAG,CAACC,KAAX,KAAqB,UAArB,IAAmC,OAAO,KAAKA,KAAZ,KAAsB,UAA7D,EACE,MAAM,IAAIC,SAAJ,CAAc,wCAAd,CAAN;AAEF,SAAKR,MAAL,IAAeM,GAAG,CAACC,KAAJ,IAAa,KAAKA,KAAjC;AACD;;AAEDE,EAAAA,IAAI,CAAEC,EAAF,EAAM,GAAGC,IAAT,EAAe;AACjB,QAAKD,EAAE,KAAK,KAAP,IAAgBA,EAAE,KAAK,QAAxB,IAAqC,KAAKR,QAAL,CAAzC,EACE,OAAO,MAAMO,IAAN,CAAWC,EAAX,EAAe,GAAGC,IAAlB,CAAP;AAEF,QAAI,KAAKR,SAAL,CAAJ,EACE;AAEF,SAAKA,SAAL,IAAkB,IAAlB;;AAEA,UAAMS,UAAU,GAAGC,EAAE,IAAI;AACvB,WAAKX,QAAL,IAAiB,IAAjB;AACAW,MAAAA,EAAE,GAAG,MAAMJ,IAAN,CAAW,OAAX,EAAoBI,EAApB,CAAH,GAA6B,MAAMJ,IAAN,CAAW,KAAX,CAA/B;AACD,KAHD;;AAKA,UAAMK,GAAG,GAAG,KAAKd,MAAL,EAAaY,UAAb,CAAZ;;AACA,QAAIE,GAAG,IAAIA,GAAG,CAACC,IAAf,EACED,GAAG,CAACC,IAAJ,CAAS,MAAMH,UAAU,EAAzB,EAA6BC,EAAE,IAAID,UAAU,CAACC,EAAD,CAA7C;AACH;;AA/B0B;;AAkC7BG,MAAM,CAACC,OAAP,GAAiBb,KAAjB","sourcesContent":["const Minipass = require('minipass')\nconst _flush = Symbol('_flush')\nconst _flushed = Symbol('_flushed')\nconst _flushing = Symbol('_flushing')\nclass Flush extends Minipass {\n  constructor (opt = {}) {\n    if (typeof opt === 'function')\n      opt = { flush: opt }\n\n    super(opt)\n\n    // or extend this class and provide a 'flush' method in your subclass\n    if (typeof opt.flush !== 'function' && typeof this.flush !== 'function')\n      throw new TypeError('must provide flush function in options')\n\n    this[_flush] = opt.flush || this.flush\n  }\n\n  emit (ev, ...data) {\n    if ((ev !== 'end' && ev !== 'finish') || this[_flushed])\n      return super.emit(ev, ...data)\n\n    if (this[_flushing])\n      return\n\n    this[_flushing] = true\n\n    const afterFlush = er => {\n      this[_flushed] = true\n      er ? super.emit('error', er) : super.emit('end')\n    }\n\n    const ret = this[_flush](afterFlush)\n    if (ret && ret.then)\n      ret.then(() => afterFlush(), er => afterFlush(er))\n  }\n}\n\nmodule.exports = Flush\n"]},"metadata":{},"sourceType":"script"}