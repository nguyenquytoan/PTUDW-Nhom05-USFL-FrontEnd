{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst assert = require('assert');\n\nconst path = require('path');\n\nconst _require = require('workbox-build'),\n      getManifest = _require.getManifest;\n\nconst convertStringToAsset = require('./lib/convert-string-to-asset');\n\nconst getDefaultConfig = require('./lib/get-default-config');\n\nconst formatManifestFilename = require('./lib/format-manifest-filename');\n\nconst getAssetHash = require('./lib/get-asset-hash');\n\nconst getManifestEntriesFromCompilation = require('./lib/get-manifest-entries-from-compilation');\n\nconst getWorkboxSWImports = require('./lib/get-workbox-sw-imports');\n\nconst readFileWrapper = require('./lib/read-file-wrapper');\n\nconst relativeToOutputPath = require('./lib/relative-to-output-path');\n\nconst sanitizeConfig = require('./lib/sanitize-config');\n\nconst stringifyManifest = require('./lib/stringify-manifest');\n\nconst warnAboutConfig = require('./lib/warn-about-config');\n/**\n * This class supports taking an existing service worker file which already\n * uses Workbox, and injecting a reference to a [precache manifest]() into it,\n * allowing it to efficiently precache the assets created by a webpack build.\n *\n * Use an instance of `InjectManifest` in the\n * [`plugins` array](https://webpack.js.org/concepts/plugins/#usage) of a\n * webpack config.\n *\n * @module workbox-webpack-plugin\n */\n\n\nclass InjectManifest {\n  /**\n   * Creates an instance of InjectManifest.\n   *\n   * @param {Object} [config] See the\n   * [configuration guide](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#configuration)\n   * for all supported options and defaults.\n   */\n  constructor(config = {}) {\n    assert(typeof config.swSrc === 'string', `swSrc must be set to the path ` + `to an existing service worker file.`);\n    this.config = Object.assign(getDefaultConfig(), {\n      // Default to using the same filename as the swSrc file, since that's\n      // provided here. (In GenerateSW, that's not available.)\n      swDest: path.basename(config.swSrc)\n    }, config);\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Function} readFile The function to use when reading files,\n   * derived from compiler.inputFileSystem.\n   * @private\n   */\n\n\n  handleEmit(compilation, readFile) {\n    var _this = this;\n\n    return (0, _asyncToGenerator2.default)(function* () {\n      const configWarning = warnAboutConfig(_this.config);\n\n      if (configWarning) {\n        compilation.warnings.push(configWarning);\n      }\n\n      const workboxSWImports = yield getWorkboxSWImports(compilation, _this.config); // this.config.modulePathPrefix may or may not have been set by\n      // getWorkboxSWImports(), depending on the other config options. If it was\n      // set, we need to pull it out and make use of it later, as it can't be\n      // used by the underlying workbox-build getManifest() method.\n\n      const modulePathPrefix = _this.config.modulePathPrefix;\n      delete _this.config.modulePathPrefix;\n      let entries = getManifestEntriesFromCompilation(compilation, _this.config);\n      const importScriptsArray = [].concat(_this.config.importScripts);\n      const sanitizedConfig = sanitizeConfig.forGetManifest(_this.config); // If there are any \"extra\" config options remaining after we remove the\n      // ones that are used natively by the plugin, then assume that they should\n      // be passed on to workbox-build.getManifest() to generate extra entries.\n\n      if (Object.keys(sanitizedConfig).length > 0) {\n        // If globPatterns isn't explicitly set, then default to [], instead of\n        // the workbox-build.getManifest() default.\n        sanitizedConfig.globPatterns = sanitizedConfig.globPatterns || [];\n\n        const _ref = yield getManifest(sanitizedConfig),\n              manifestEntries = _ref.manifestEntries,\n              warnings = _ref.warnings;\n\n        compilation.warnings = compilation.warnings.concat(warnings || []);\n        entries = entries.concat(manifestEntries);\n      }\n\n      const manifestString = stringifyManifest(entries);\n      const manifestAsset = convertStringToAsset(manifestString);\n      const manifestHash = getAssetHash(manifestAsset);\n      const manifestFilename = formatManifestFilename(_this.config.precacheManifestFilename, manifestHash);\n      const pathToManifestFile = relativeToOutputPath(compilation, path.join(_this.config.importsDirectory, manifestFilename));\n      compilation.assets[pathToManifestFile] = manifestAsset;\n      importScriptsArray.push((compilation.options.output.publicPath || '') + pathToManifestFile.split(path.sep).join('/')); // workboxSWImports might be null if importWorkboxFrom is 'disabled'.\n\n      if (workboxSWImports) {\n        importScriptsArray.push(...workboxSWImports);\n      }\n\n      let originalSWString;\n      /**\n       * Check if the mentioned file name is in the webpack assets itself\n       * or fallback to filesystem.\n       */\n\n      if (compilation.assets[_this.config.swSrc]) {\n        originalSWString = compilation.assets[_this.config.swSrc].source();\n      } else {\n        originalSWString = yield readFileWrapper(readFile, _this.config.swSrc);\n      } // compilation.fileDependencies needs absolute paths.\n\n\n      const absoluteSwSrc = path.resolve(_this.config.swSrc);\n\n      if (Array.isArray(compilation.fileDependencies)) {\n        // webpack v3\n        if (compilation.fileDependencies.indexOf(absoluteSwSrc) === -1) {\n          compilation.fileDependencies.push(absoluteSwSrc);\n        }\n      } else if ('add' in compilation.fileDependencies) {\n        // webpack v4; no need to check for membership first, since it's a Set.\n        compilation.fileDependencies.add(absoluteSwSrc);\n      }\n\n      const importScriptsString = importScriptsArray.map(JSON.stringify).join(', ');\n      const setConfigString = modulePathPrefix ? `workbox.setConfig({modulePathPrefix: ` + `${JSON.stringify(modulePathPrefix)}});` : '';\n      const postInjectionSWString = `importScripts(${importScriptsString});\n${setConfigString}\n${originalSWString}\n`;\n      const relSwDest = relativeToOutputPath(compilation, _this.config.swDest);\n      compilation.assets[relSwDest] = convertStringToAsset(postInjectionSWString);\n    })();\n  }\n  /**\n   * @param {Object} [compiler] default compiler object passed from webpack\n   *\n   * @private\n   */\n\n\n  apply(compiler) {\n    const readFile = compiler.inputFileSystem.readFile.bind(compiler.inputFileSystem);\n\n    if ('hooks' in compiler) {\n      // We're in webpack 4+.\n      compiler.hooks.emit.tapPromise(this.constructor.name, compilation => this.handleEmit(compilation, readFile));\n    } else {\n      // We're in webpack 2 or 3.\n      compiler.plugin('emit', (compilation, callback) => {\n        this.handleEmit(compilation, readFile).then(callback).catch(callback);\n      });\n    }\n  }\n\n}\n\nmodule.exports = InjectManifest;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-webpack-plugin/build/inject-manifest.js"],"names":["_interopRequireDefault","require","_asyncToGenerator2","assert","path","_require","getManifest","convertStringToAsset","getDefaultConfig","formatManifestFilename","getAssetHash","getManifestEntriesFromCompilation","getWorkboxSWImports","readFileWrapper","relativeToOutputPath","sanitizeConfig","stringifyManifest","warnAboutConfig","InjectManifest","constructor","config","swSrc","Object","assign","swDest","basename","handleEmit","compilation","readFile","_this","default","configWarning","warnings","push","workboxSWImports","modulePathPrefix","entries","importScriptsArray","concat","importScripts","sanitizedConfig","forGetManifest","keys","length","globPatterns","_ref","manifestEntries","manifestString","manifestAsset","manifestHash","manifestFilename","precacheManifestFilename","pathToManifestFile","join","importsDirectory","assets","options","output","publicPath","split","sep","originalSWString","source","absoluteSwSrc","resolve","Array","isArray","fileDependencies","indexOf","add","importScriptsString","map","JSON","stringify","setConfigString","postInjectionSWString","relSwDest","apply","compiler","inputFileSystem","bind","hooks","emit","tapPromise","name","plugin","callback","then","catch","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst assert = require('assert');\n\nconst path = require('path');\n\nconst _require = require('workbox-build'),\n      getManifest = _require.getManifest;\n\nconst convertStringToAsset = require('./lib/convert-string-to-asset');\n\nconst getDefaultConfig = require('./lib/get-default-config');\n\nconst formatManifestFilename = require('./lib/format-manifest-filename');\n\nconst getAssetHash = require('./lib/get-asset-hash');\n\nconst getManifestEntriesFromCompilation = require('./lib/get-manifest-entries-from-compilation');\n\nconst getWorkboxSWImports = require('./lib/get-workbox-sw-imports');\n\nconst readFileWrapper = require('./lib/read-file-wrapper');\n\nconst relativeToOutputPath = require('./lib/relative-to-output-path');\n\nconst sanitizeConfig = require('./lib/sanitize-config');\n\nconst stringifyManifest = require('./lib/stringify-manifest');\n\nconst warnAboutConfig = require('./lib/warn-about-config');\n/**\n * This class supports taking an existing service worker file which already\n * uses Workbox, and injecting a reference to a [precache manifest]() into it,\n * allowing it to efficiently precache the assets created by a webpack build.\n *\n * Use an instance of `InjectManifest` in the\n * [`plugins` array](https://webpack.js.org/concepts/plugins/#usage) of a\n * webpack config.\n *\n * @module workbox-webpack-plugin\n */\n\n\nclass InjectManifest {\n  /**\n   * Creates an instance of InjectManifest.\n   *\n   * @param {Object} [config] See the\n   * [configuration guide](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#configuration)\n   * for all supported options and defaults.\n   */\n  constructor(config = {}) {\n    assert(typeof config.swSrc === 'string', `swSrc must be set to the path ` + `to an existing service worker file.`);\n    this.config = Object.assign(getDefaultConfig(), {\n      // Default to using the same filename as the swSrc file, since that's\n      // provided here. (In GenerateSW, that's not available.)\n      swDest: path.basename(config.swSrc)\n    }, config);\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Function} readFile The function to use when reading files,\n   * derived from compiler.inputFileSystem.\n   * @private\n   */\n\n\n  handleEmit(compilation, readFile) {\n    var _this = this;\n\n    return (0, _asyncToGenerator2.default)(function* () {\n      const configWarning = warnAboutConfig(_this.config);\n\n      if (configWarning) {\n        compilation.warnings.push(configWarning);\n      }\n\n      const workboxSWImports = yield getWorkboxSWImports(compilation, _this.config); // this.config.modulePathPrefix may or may not have been set by\n      // getWorkboxSWImports(), depending on the other config options. If it was\n      // set, we need to pull it out and make use of it later, as it can't be\n      // used by the underlying workbox-build getManifest() method.\n\n      const modulePathPrefix = _this.config.modulePathPrefix;\n      delete _this.config.modulePathPrefix;\n      let entries = getManifestEntriesFromCompilation(compilation, _this.config);\n      const importScriptsArray = [].concat(_this.config.importScripts);\n      const sanitizedConfig = sanitizeConfig.forGetManifest(_this.config); // If there are any \"extra\" config options remaining after we remove the\n      // ones that are used natively by the plugin, then assume that they should\n      // be passed on to workbox-build.getManifest() to generate extra entries.\n\n      if (Object.keys(sanitizedConfig).length > 0) {\n        // If globPatterns isn't explicitly set, then default to [], instead of\n        // the workbox-build.getManifest() default.\n        sanitizedConfig.globPatterns = sanitizedConfig.globPatterns || [];\n\n        const _ref = yield getManifest(sanitizedConfig),\n              manifestEntries = _ref.manifestEntries,\n              warnings = _ref.warnings;\n\n        compilation.warnings = compilation.warnings.concat(warnings || []);\n        entries = entries.concat(manifestEntries);\n      }\n\n      const manifestString = stringifyManifest(entries);\n      const manifestAsset = convertStringToAsset(manifestString);\n      const manifestHash = getAssetHash(manifestAsset);\n      const manifestFilename = formatManifestFilename(_this.config.precacheManifestFilename, manifestHash);\n      const pathToManifestFile = relativeToOutputPath(compilation, path.join(_this.config.importsDirectory, manifestFilename));\n      compilation.assets[pathToManifestFile] = manifestAsset;\n      importScriptsArray.push((compilation.options.output.publicPath || '') + pathToManifestFile.split(path.sep).join('/')); // workboxSWImports might be null if importWorkboxFrom is 'disabled'.\n\n      if (workboxSWImports) {\n        importScriptsArray.push(...workboxSWImports);\n      }\n\n      let originalSWString;\n      /**\n       * Check if the mentioned file name is in the webpack assets itself\n       * or fallback to filesystem.\n       */\n\n      if (compilation.assets[_this.config.swSrc]) {\n        originalSWString = compilation.assets[_this.config.swSrc].source();\n      } else {\n        originalSWString = yield readFileWrapper(readFile, _this.config.swSrc);\n      } // compilation.fileDependencies needs absolute paths.\n\n\n      const absoluteSwSrc = path.resolve(_this.config.swSrc);\n\n      if (Array.isArray(compilation.fileDependencies)) {\n        // webpack v3\n        if (compilation.fileDependencies.indexOf(absoluteSwSrc) === -1) {\n          compilation.fileDependencies.push(absoluteSwSrc);\n        }\n      } else if ('add' in compilation.fileDependencies) {\n        // webpack v4; no need to check for membership first, since it's a Set.\n        compilation.fileDependencies.add(absoluteSwSrc);\n      }\n\n      const importScriptsString = importScriptsArray.map(JSON.stringify).join(', ');\n      const setConfigString = modulePathPrefix ? `workbox.setConfig({modulePathPrefix: ` + `${JSON.stringify(modulePathPrefix)}});` : '';\n      const postInjectionSWString = `importScripts(${importScriptsString});\n${setConfigString}\n${originalSWString}\n`;\n      const relSwDest = relativeToOutputPath(compilation, _this.config.swDest);\n      compilation.assets[relSwDest] = convertStringToAsset(postInjectionSWString);\n    })();\n  }\n  /**\n   * @param {Object} [compiler] default compiler object passed from webpack\n   *\n   * @private\n   */\n\n\n  apply(compiler) {\n    const readFile = compiler.inputFileSystem.readFile.bind(compiler.inputFileSystem);\n\n    if ('hooks' in compiler) {\n      // We're in webpack 4+.\n      compiler.hooks.emit.tapPromise(this.constructor.name, compilation => this.handleEmit(compilation, readFile));\n    } else {\n      // We're in webpack 2 or 3.\n      compiler.plugin('emit', (compilation, callback) => {\n        this.handleEmit(compilation, readFile).then(callback).catch(callback);\n      });\n    }\n  }\n\n}\n\nmodule.exports = InjectManifest;"]},"metadata":{},"sourceType":"script"}