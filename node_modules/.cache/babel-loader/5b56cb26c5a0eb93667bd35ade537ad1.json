{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst pathutils = require('./pathutils');\n\nconst {\n  GREATEST_LOWER_BOUND,\n  LEAST_UPPER_BOUND\n} = require('source-map').SourceMapConsumer;\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\n\n\nfunction originalEndPositionFor(sourceMap, generatedEnd) {\n  // Given the generated location, find the original location of the mapping\n  // that corresponds to a range on the generated file that overlaps the\n  // generated file end location. Note however that this position on its\n  // own is not useful because it is the position of the _start_ of the range\n  // on the original file, and we want the _end_ of the range.\n  const beforeEndMapping = originalPositionTryBoth(sourceMap, generatedEnd.line, generatedEnd.column - 1);\n\n  if (beforeEndMapping.source === null) {\n    return null;\n  } // Convert that original position back to a generated one, with a bump\n  // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n  // for mappings in the original-order sorted list, this will find the\n  // mapping that corresponds to the one immediately after the\n  // beforeEndMapping mapping.\n\n\n  const afterEndMapping = sourceMap.generatedPositionFor({\n    source: beforeEndMapping.source,\n    line: beforeEndMapping.line,\n    column: beforeEndMapping.column + 1,\n    bias: LEAST_UPPER_BOUND\n  });\n\n  if ( // If this is null, it means that we've hit the end of the file,\n  // so we can use Infinity as the end column.\n  afterEndMapping.line === null || // If these don't match, it means that the call to\n  // 'generatedPositionFor' didn't find any other original mappings on\n  // the line we gave, so consider the binding to extend to infinity.\n  sourceMap.originalPositionFor(afterEndMapping).line !== beforeEndMapping.line) {\n    return {\n      source: beforeEndMapping.source,\n      line: beforeEndMapping.line,\n      column: Infinity\n    };\n  } // Convert the end mapping into the real original position.\n\n\n  return sourceMap.originalPositionFor(afterEndMapping);\n}\n/**\n * Attempts to determine the original source position, first\n * returning the closest element to the left (GREATEST_LOWER_BOUND),\n * and next returning the closest element to the right (LEAST_UPPER_BOUND).\n */\n\n\nfunction originalPositionTryBoth(sourceMap, line, column) {\n  const mapping = sourceMap.originalPositionFor({\n    line,\n    column,\n    bias: GREATEST_LOWER_BOUND\n  });\n\n  if (mapping.source === null) {\n    return sourceMap.originalPositionFor({\n      line,\n      column,\n      bias: LEAST_UPPER_BOUND\n    });\n  } else {\n    return mapping;\n  }\n}\n\nfunction isInvalidPosition(pos) {\n  return !pos || typeof pos.line !== 'number' || typeof pos.column !== 'number' || pos.line < 0 || pos.column < 0;\n}\n/**\n * determines the original position for a given location\n * @param  {SourceMapConsumer} sourceMap the source map\n * @param  {Object} generatedLocation the original location Object\n * @returns {Object} the remapped location Object\n */\n\n\nfunction getMapping(sourceMap, generatedLocation, origFile) {\n  if (!generatedLocation) {\n    return null;\n  }\n\n  if (isInvalidPosition(generatedLocation.start) || isInvalidPosition(generatedLocation.end)) {\n    return null;\n  }\n\n  const start = originalPositionTryBoth(sourceMap, generatedLocation.start.line, generatedLocation.start.column);\n  let end = originalEndPositionFor(sourceMap, generatedLocation.end);\n  /* istanbul ignore if: edge case too hard to test for */\n\n  if (!(start && end)) {\n    return null;\n  }\n\n  if (!(start.source && end.source)) {\n    return null;\n  }\n\n  if (start.source !== end.source) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n\n\n  if (start.line === null || start.column === null) {\n    return null;\n  }\n  /* istanbul ignore if: edge case too hard to test for */\n\n\n  if (end.line === null || end.column === null) {\n    return null;\n  }\n\n  if (start.line === end.line && start.column === end.column) {\n    end = sourceMap.originalPositionFor({\n      line: generatedLocation.end.line,\n      column: generatedLocation.end.column,\n      bias: LEAST_UPPER_BOUND\n    });\n    end.column -= 1;\n  }\n\n  return {\n    source: pathutils.relativeTo(start.source, origFile),\n    loc: {\n      start: {\n        line: start.line,\n        column: start.column\n      },\n      end: {\n        line: end.line,\n        column: end.column\n      }\n    }\n  };\n}\n\nmodule.exports = getMapping;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-source-maps/lib/get-mapping.js"],"names":["pathutils","require","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","SourceMapConsumer","originalEndPositionFor","sourceMap","generatedEnd","beforeEndMapping","originalPositionTryBoth","line","column","source","afterEndMapping","generatedPositionFor","bias","originalPositionFor","Infinity","mapping","isInvalidPosition","pos","getMapping","generatedLocation","origFile","start","end","relativeTo","loc","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst pathutils = require('./pathutils');\nconst {\n    GREATEST_LOWER_BOUND,\n    LEAST_UPPER_BOUND\n} = require('source-map').SourceMapConsumer;\n\n/**\n * AST ranges are inclusive for start positions and exclusive for end positions.\n * Source maps are also logically ranges over text, though interacting with\n * them is generally achieved by working with explicit positions.\n *\n * When finding the _end_ location of an AST item, the range behavior is\n * important because what we're asking for is the _end_ of whatever range\n * corresponds to the end location we seek.\n *\n * This boils down to the following steps, conceptually, though the source-map\n * library doesn't expose primitives to do this nicely:\n *\n * 1. Find the range on the generated file that ends at, or exclusively\n *    contains the end position of the AST node.\n * 2. Find the range on the original file that corresponds to\n *    that generated range.\n * 3. Find the _end_ location of that original range.\n */\nfunction originalEndPositionFor(sourceMap, generatedEnd) {\n    // Given the generated location, find the original location of the mapping\n    // that corresponds to a range on the generated file that overlaps the\n    // generated file end location. Note however that this position on its\n    // own is not useful because it is the position of the _start_ of the range\n    // on the original file, and we want the _end_ of the range.\n    const beforeEndMapping = originalPositionTryBoth(\n        sourceMap,\n        generatedEnd.line,\n        generatedEnd.column - 1\n    );\n    if (beforeEndMapping.source === null) {\n        return null;\n    }\n\n    // Convert that original position back to a generated one, with a bump\n    // to the right, and a rightward bias. Since 'generatedPositionFor' searches\n    // for mappings in the original-order sorted list, this will find the\n    // mapping that corresponds to the one immediately after the\n    // beforeEndMapping mapping.\n    const afterEndMapping = sourceMap.generatedPositionFor({\n        source: beforeEndMapping.source,\n        line: beforeEndMapping.line,\n        column: beforeEndMapping.column + 1,\n        bias: LEAST_UPPER_BOUND\n    });\n    if (\n        // If this is null, it means that we've hit the end of the file,\n        // so we can use Infinity as the end column.\n        afterEndMapping.line === null ||\n        // If these don't match, it means that the call to\n        // 'generatedPositionFor' didn't find any other original mappings on\n        // the line we gave, so consider the binding to extend to infinity.\n        sourceMap.originalPositionFor(afterEndMapping).line !==\n            beforeEndMapping.line\n    ) {\n        return {\n            source: beforeEndMapping.source,\n            line: beforeEndMapping.line,\n            column: Infinity\n        };\n    }\n\n    // Convert the end mapping into the real original position.\n    return sourceMap.originalPositionFor(afterEndMapping);\n}\n\n/**\n * Attempts to determine the original source position, first\n * returning the closest element to the left (GREATEST_LOWER_BOUND),\n * and next returning the closest element to the right (LEAST_UPPER_BOUND).\n */\nfunction originalPositionTryBoth(sourceMap, line, column) {\n    const mapping = sourceMap.originalPositionFor({\n        line,\n        column,\n        bias: GREATEST_LOWER_BOUND\n    });\n    if (mapping.source === null) {\n        return sourceMap.originalPositionFor({\n            line,\n            column,\n            bias: LEAST_UPPER_BOUND\n        });\n    } else {\n        return mapping;\n    }\n}\n\nfunction isInvalidPosition(pos) {\n    return (\n        !pos ||\n        typeof pos.line !== 'number' ||\n        typeof pos.column !== 'number' ||\n        pos.line < 0 ||\n        pos.column < 0\n    );\n}\n\n/**\n * determines the original position for a given location\n * @param  {SourceMapConsumer} sourceMap the source map\n * @param  {Object} generatedLocation the original location Object\n * @returns {Object} the remapped location Object\n */\nfunction getMapping(sourceMap, generatedLocation, origFile) {\n    if (!generatedLocation) {\n        return null;\n    }\n\n    if (\n        isInvalidPosition(generatedLocation.start) ||\n        isInvalidPosition(generatedLocation.end)\n    ) {\n        return null;\n    }\n\n    const start = originalPositionTryBoth(\n        sourceMap,\n        generatedLocation.start.line,\n        generatedLocation.start.column\n    );\n    let end = originalEndPositionFor(sourceMap, generatedLocation.end);\n\n    /* istanbul ignore if: edge case too hard to test for */\n    if (!(start && end)) {\n        return null;\n    }\n\n    if (!(start.source && end.source)) {\n        return null;\n    }\n\n    if (start.source !== end.source) {\n        return null;\n    }\n\n    /* istanbul ignore if: edge case too hard to test for */\n    if (start.line === null || start.column === null) {\n        return null;\n    }\n\n    /* istanbul ignore if: edge case too hard to test for */\n    if (end.line === null || end.column === null) {\n        return null;\n    }\n\n    if (start.line === end.line && start.column === end.column) {\n        end = sourceMap.originalPositionFor({\n            line: generatedLocation.end.line,\n            column: generatedLocation.end.column,\n            bias: LEAST_UPPER_BOUND\n        });\n        end.column -= 1;\n    }\n\n    return {\n        source: pathutils.relativeTo(start.source, origFile),\n        loc: {\n            start: {\n                line: start.line,\n                column: start.column\n            },\n            end: {\n                line: end.line,\n                column: end.column\n            }\n        }\n    };\n}\n\nmodule.exports = getMapping;\n"]},"metadata":{},"sourceType":"script"}