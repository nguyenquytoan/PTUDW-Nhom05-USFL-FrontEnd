{"ast":null,"code":"/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n      ForkContext = require(\"./fork-context\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\n\n\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    dest.push(segment);\n\n    if (others.indexOf(segment) === -1) {\n      all.push(segment);\n    }\n  }\n}\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\n\n\nfunction getContinueContext(state, label) {\n  if (!label) {\n    return state.loopContext;\n  }\n\n  let context = state.loopContext;\n\n  while (context) {\n    if (context.label === label) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n  /* istanbul ignore next: foolproof (syntax error) */\n\n\n  return null;\n}\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\n\n\nfunction getBreakContext(state, label) {\n  let context = state.breakContext;\n\n  while (context) {\n    if (label ? context.label === label : context.breakable) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n  /* istanbul ignore next: foolproof (syntax error) */\n\n\n  return null;\n}\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\n\n\nfunction getReturnContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.hasFinalizer && context.position !== \"finally\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\n\n\nfunction getThrowContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.position === \"try\" || context.hasFinalizer && context.position === \"catch\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\n\n\nfunction remove(xs, x) {\n  xs.splice(xs.indexOf(x), 1);\n}\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\n\n\nfunction removeConnection(prevSegments, nextSegments) {\n  for (let i = 0; i < prevSegments.length; ++i) {\n    const prevSegment = prevSegments[i];\n    const nextSegment = nextSegments[i];\n    remove(prevSegment.nextSegments, nextSegment);\n    remove(prevSegment.allNextSegments, nextSegment);\n    remove(nextSegment.prevSegments, prevSegment);\n    remove(nextSegment.allPrevSegments, prevSegment);\n  }\n}\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\n\n\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n  const end = Math.min(fromSegments.length, toSegments.length);\n\n  for (let i = 0; i < end; ++i) {\n    const fromSegment = fromSegments[i];\n    const toSegment = toSegments[i];\n\n    if (toSegment.reachable) {\n      fromSegment.nextSegments.push(toSegment);\n    }\n\n    if (fromSegment.reachable) {\n      toSegment.prevSegments.push(fromSegment);\n    }\n\n    fromSegment.allNextSegments.push(toSegment);\n    toSegment.allPrevSegments.push(fromSegment);\n\n    if (toSegment.allPrevSegments.length >= 2) {\n      CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n    }\n\n    state.notifyLooped(fromSegment, toSegment);\n  }\n}\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\n\n\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n  if (!choiceContext.processed) {\n    choiceContext.trueForkContext.add(head);\n    choiceContext.falseForkContext.add(head);\n  }\n\n  if (context.test !== true) {\n    context.brokenForkContext.addAll(choiceContext.falseForkContext);\n  }\n\n  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\n\n\nclass CodePathState {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {IdGenerator} idGenerator An id generator to generate id for code\n   *   path segments.\n   * @param {Function} onLooped A callback function to notify looping.\n   */\n  constructor(idGenerator, onLooped) {\n    this.idGenerator = idGenerator;\n    this.notifyLooped = onLooped;\n    this.forkContext = ForkContext.newRoot(idGenerator);\n    this.choiceContext = null;\n    this.switchContext = null;\n    this.tryContext = null;\n    this.loopContext = null;\n    this.breakContext = null;\n    this.currentSegments = [];\n    this.initialSegment = this.forkContext.head[0]; // returnedSegments and thrownSegments push elements into finalSegments also.\n\n    const final = this.finalSegments = [];\n    const returned = this.returnedForkContext = [];\n    const thrown = this.thrownForkContext = [];\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n  }\n  /**\n   * The head segments.\n   * @type {CodePathSegment[]}\n   */\n\n\n  get headSegments() {\n    return this.forkContext.head;\n  }\n  /**\n   * The parent forking context.\n   * This is used for the root of new forks.\n   * @type {ForkContext}\n   */\n\n\n  get parentForkContext() {\n    const current = this.forkContext;\n    return current && current.upper;\n  }\n  /**\n   * Creates and stacks new forking context.\n   * @param {boolean} forkLeavingPath A flag which shows being in a\n   *   \"finally\" block.\n   * @returns {ForkContext} The created context.\n   */\n\n\n  pushForkContext(forkLeavingPath) {\n    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);\n    return this.forkContext;\n  }\n  /**\n   * Pops and merges the last forking context.\n   * @returns {ForkContext} The last context.\n   */\n\n\n  popForkContext() {\n    const lastContext = this.forkContext;\n    this.forkContext = lastContext.upper;\n    this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n    return lastContext;\n  }\n  /**\n   * Creates a new path.\n   * @returns {void}\n   */\n\n\n  forkPath() {\n    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n  }\n  /**\n   * Creates a bypass path.\n   * This is used for such as IfStatement which does not have \"else\" chunk.\n   * @returns {void}\n   */\n\n\n  forkBypassPath() {\n    this.forkContext.add(this.parentForkContext.head);\n  } //--------------------------------------------------------------------------\n  // ConditionalExpression, LogicalExpression, IfStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context for ConditionalExpression, LogicalExpression,\n   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n   *\n   * LogicalExpressions have cases that it goes different paths between the\n   * `true` case and the `false` case.\n   *\n   * For Example:\n   *\n   *     if (a || b) {\n   *         foo();\n   *     } else {\n   *         bar();\n   *     }\n   *\n   * In this case, `b` is evaluated always in the code path of the `else`\n   * block, but it's not so in the code path of the `if` block.\n   * So there are 3 paths.\n   *\n   *     a -> foo();\n   *     a -> b -> foo();\n   *     a -> b -> bar();\n   * @param {string} kind A kind string.\n   *   If the new context is LogicalExpression's, this is `\"&&\"` or `\"||\"`.\n   *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n   *   Otherwise, this is `\"loop\"`.\n   * @param {boolean} isForkingAsResult A flag that shows that goes different\n   *   paths between `true` and `false`.\n   * @returns {void}\n   */\n\n\n  pushChoiceContext(kind, isForkingAsResult) {\n    this.choiceContext = {\n      upper: this.choiceContext,\n      kind,\n      isForkingAsResult,\n      trueForkContext: ForkContext.newEmpty(this.forkContext),\n      falseForkContext: ForkContext.newEmpty(this.forkContext),\n      processed: false\n    };\n  }\n  /**\n   * Pops the last choice context and finalizes it.\n   * @returns {ChoiceContext} The popped context.\n   */\n\n\n  popChoiceContext() {\n    const context = this.choiceContext;\n    this.choiceContext = context.upper;\n    const forkContext = this.forkContext;\n    const headSegments = forkContext.head;\n\n    switch (context.kind) {\n      case \"&&\":\n      case \"||\":\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the right-hand operand.\n         */\n        if (!context.processed) {\n          context.trueForkContext.add(headSegments);\n          context.falseForkContext.add(headSegments);\n        }\n        /*\n         * Transfers results to upper context if this context is in\n         * test chunk.\n         */\n\n\n        if (context.isForkingAsResult) {\n          const parentContext = this.choiceContext;\n          parentContext.trueForkContext.addAll(context.trueForkContext);\n          parentContext.falseForkContext.addAll(context.falseForkContext);\n          parentContext.processed = true;\n          return context;\n        }\n\n        break;\n\n      case \"test\":\n        if (!context.processed) {\n          /*\n           * The head segments are the path of the `if` block here.\n           * Updates the `true` path with the end of the `if` block.\n           */\n          context.trueForkContext.clear();\n          context.trueForkContext.add(headSegments);\n        } else {\n          /*\n           * The head segments are the path of the `else` block here.\n           * Updates the `false` path with the end of the `else`\n           * block.\n           */\n          context.falseForkContext.clear();\n          context.falseForkContext.add(headSegments);\n        }\n\n        break;\n\n      case \"loop\":\n        /*\n         * Loops are addressed in popLoopContext().\n         * This is called from popLoopContext().\n         */\n        return context;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(\"unreachable\");\n    } // Merges all paths.\n\n\n    const prevForkContext = context.trueForkContext;\n    prevForkContext.addAll(context.falseForkContext);\n    forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n    return context;\n  }\n  /**\n   * Makes a code path segment of the right-hand operand of a logical\n   * expression.\n   * @returns {void}\n   */\n\n\n  makeLogicalRight() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (context.processed) {\n      /*\n       * This got segments already from the child choice context.\n       * Creates the next path from own true/false fork context.\n       */\n      const prevForkContext = context.kind === \"&&\" ? context.trueForkContext\n      /* kind === \"||\" */\n      : context.falseForkContext;\n      forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n      prevForkContext.clear();\n      context.processed = false;\n    } else {\n      /*\n       * This did not get segments from the child choice context.\n       * So addresses the head segments.\n       * The head segments are the path of the left-hand operand.\n       */\n      if (context.kind === \"&&\") {\n        // The path does short-circuit if false.\n        context.falseForkContext.add(forkContext.head);\n      } else {\n        // The path does short-circuit if true.\n        context.trueForkContext.add(forkContext.head);\n      }\n\n      forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n  }\n  /**\n   * Makes a code path segment of the `if` block.\n   * @returns {void}\n   */\n\n\n  makeIfConsequent() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    /*\n     * If any result were not transferred from child contexts,\n     * this sets the head segments to both cases.\n     * The head segments are the path of the test expression.\n     */\n\n    if (!context.processed) {\n      context.trueForkContext.add(forkContext.head);\n      context.falseForkContext.add(forkContext.head);\n    }\n\n    context.processed = false; // Creates new path from the `true` case.\n\n    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));\n  }\n  /**\n   * Makes a code path segment of the `else` block.\n   * @returns {void}\n   */\n\n\n  makeIfAlternate() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    /*\n     * The head segments are the path of the `if` block.\n     * Updates the `true` path with the end of the `if` block.\n     */\n\n    context.trueForkContext.clear();\n    context.trueForkContext.add(forkContext.head);\n    context.processed = true; // Creates new path from the `false` case.\n\n    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));\n  } //--------------------------------------------------------------------------\n  // SwitchStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of SwitchStatement and stacks it.\n   * @param {boolean} hasCase `true` if the switch statement has one or more\n   *   case parts.\n   * @param {string|null} label The label text.\n   * @returns {void}\n   */\n\n\n  pushSwitchContext(hasCase, label) {\n    this.switchContext = {\n      upper: this.switchContext,\n      hasCase,\n      defaultSegments: null,\n      defaultBodySegments: null,\n      foundDefault: false,\n      lastIsDefault: false,\n      countForks: 0\n    };\n    this.pushBreakContext(true, label);\n  }\n  /**\n   * Pops the last context of SwitchStatement and finalizes it.\n   *\n   * - Disposes all forking stack for `case` and `default`.\n   * - Creates the next code path segment from `context.brokenForkContext`.\n   * - If the last `SwitchCase` node is not a `default` part, creates a path\n   *   to the `default` body.\n   * @returns {void}\n   */\n\n\n  popSwitchContext() {\n    const context = this.switchContext;\n    this.switchContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    if (context.countForks === 0) {\n      /*\n       * When there is only one `default` chunk and there is one or more\n       * `break` statements, even if forks are nothing, it needs to merge\n       * those.\n       */\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.makeNext(-1, -1));\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n\n      return;\n    }\n\n    const lastSegments = forkContext.head;\n    this.forkBypassPath();\n    const lastCaseSegments = forkContext.head;\n    /*\n     * `brokenForkContext` is used to make the next segment.\n     * It must add the last segment into `brokenForkContext`.\n     */\n\n    brokenForkContext.add(lastSegments);\n    /*\n     * A path which is failed in all case test should be connected to path\n     * of `default` chunk.\n     */\n\n    if (!context.lastIsDefault) {\n      if (context.defaultBodySegments) {\n        /*\n         * Remove a link from `default` label to its chunk.\n         * It's false route.\n         */\n        removeConnection(context.defaultSegments, context.defaultBodySegments);\n        makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n      } else {\n        /*\n         * It handles the last case body as broken if `default` chunk\n         * does not exist.\n         */\n        brokenForkContext.add(lastCaseSegments);\n      }\n    } // Pops the segment context stack until the entry segment.\n\n\n    for (let i = 0; i < context.countForks; ++i) {\n      this.forkContext = this.forkContext.upper;\n    }\n    /*\n     * Creates a path from all brokenForkContext paths.\n     * This is a path after switch statement.\n     */\n\n\n    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n  }\n  /**\n   * Makes a code path segment for a `SwitchCase` node.\n   * @param {boolean} isEmpty `true` if the body is empty.\n   * @param {boolean} isDefault `true` if the body is the default case.\n   * @returns {void}\n   */\n\n\n  makeSwitchCaseBody(isEmpty, isDefault) {\n    const context = this.switchContext;\n\n    if (!context.hasCase) {\n      return;\n    }\n    /*\n     * Merge forks.\n     * The parent fork context has two segments.\n     * Those are from the current case and the body of the previous case.\n     */\n\n\n    const parentForkContext = this.forkContext;\n    const forkContext = this.pushForkContext();\n    forkContext.add(parentForkContext.makeNext(0, -1));\n    /*\n     * Save `default` chunk info.\n     * If the `default` label is not at the last, we must make a path from\n     * the last `case` to the `default` chunk.\n     */\n\n    if (isDefault) {\n      context.defaultSegments = parentForkContext.head;\n\n      if (isEmpty) {\n        context.foundDefault = true;\n      } else {\n        context.defaultBodySegments = forkContext.head;\n      }\n    } else {\n      if (!isEmpty && context.foundDefault) {\n        context.foundDefault = false;\n        context.defaultBodySegments = forkContext.head;\n      }\n    }\n\n    context.lastIsDefault = isDefault;\n    context.countForks += 1;\n  } //--------------------------------------------------------------------------\n  // TryStatement\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of TryStatement and stacks it.\n   * @param {boolean} hasFinalizer `true` if the try statement has a\n   *   `finally` block.\n   * @returns {void}\n   */\n\n\n  pushTryContext(hasFinalizer) {\n    this.tryContext = {\n      upper: this.tryContext,\n      position: \"try\",\n      hasFinalizer,\n      returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,\n      thrownForkContext: ForkContext.newEmpty(this.forkContext),\n      lastOfTryIsReachable: false,\n      lastOfCatchIsReachable: false\n    };\n  }\n  /**\n   * Pops the last context of TryStatement and finalizes it.\n   * @returns {void}\n   */\n\n\n  popTryContext() {\n    const context = this.tryContext;\n    this.tryContext = context.upper;\n\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block merely.\n      this.popForkContext();\n      return;\n    }\n    /*\n     * The following process is executed only when there is the `finally`\n     * block.\n     */\n\n\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n\n    if (returned.empty && thrown.empty) {\n      return;\n    } // Separate head to normal paths and leaving paths.\n\n\n    const headSegments = this.forkContext.head;\n    this.forkContext = this.forkContext.upper;\n    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0); // Forwards the leaving path to upper contexts.\n\n    if (!returned.empty) {\n      getReturnContext(this).returnedForkContext.add(leavingSegments);\n    }\n\n    if (!thrown.empty) {\n      getThrowContext(this).thrownForkContext.add(leavingSegments);\n    } // Sets the normal path as the next.\n\n\n    this.forkContext.replaceHead(normalSegments);\n    /*\n     * If both paths of the `try` block and the `catch` block are\n     * unreachable, the next path becomes unreachable as well.\n     */\n\n    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n      this.forkContext.makeUnreachable();\n    }\n  }\n  /**\n   * Makes a code path segment for a `catch` block.\n   * @returns {void}\n   */\n\n\n  makeCatchBlock() {\n    const context = this.tryContext;\n    const forkContext = this.forkContext;\n    const thrown = context.thrownForkContext; // Update state.\n\n    context.position = \"catch\";\n    context.thrownForkContext = ForkContext.newEmpty(forkContext);\n    context.lastOfTryIsReachable = forkContext.reachable; // Merge thrown paths.\n\n    thrown.add(forkContext.head);\n    const thrownSegments = thrown.makeNext(0, -1); // Fork to a bypass and the merged thrown path.\n\n    this.pushForkContext();\n    this.forkBypassPath();\n    this.forkContext.add(thrownSegments);\n  }\n  /**\n   * Makes a code path segment for a `finally` block.\n   *\n   * In the `finally` block, parallel paths are created. The parallel paths\n   * are used as leaving-paths. The leaving-paths are paths from `return`\n   * statements and `throw` statements in a `try` block or a `catch` block.\n   * @returns {void}\n   */\n\n\n  makeFinallyBlock() {\n    const context = this.tryContext;\n    let forkContext = this.forkContext;\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n    const headOfLeavingSegments = forkContext.head; // Update state.\n\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block.\n      this.popForkContext();\n      forkContext = this.forkContext;\n      context.lastOfCatchIsReachable = forkContext.reachable;\n    } else {\n      context.lastOfTryIsReachable = forkContext.reachable;\n    }\n\n    context.position = \"finally\";\n\n    if (returned.empty && thrown.empty) {\n      // This path does not leave.\n      return;\n    }\n    /*\n     * Create a parallel segment from merging returned and thrown.\n     * This segment will leave at the end of this finally block.\n     */\n\n\n    const segments = forkContext.makeNext(-1, -1);\n\n    for (let i = 0; i < forkContext.count; ++i) {\n      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n      for (let j = 0; j < returned.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n      }\n\n      for (let j = 0; j < thrown.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n      }\n\n      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));\n    }\n\n    this.pushForkContext(true);\n    this.forkContext.add(segments);\n  }\n  /**\n   * Makes a code path segment from the first throwable node to the `catch`\n   * block or the `finally` block.\n   * @returns {void}\n   */\n\n\n  makeFirstThrowablePathInTryBlock() {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getThrowContext(this);\n\n    if (context === this || context.position !== \"try\" || !context.thrownForkContext.empty) {\n      return;\n    }\n\n    context.thrownForkContext.add(forkContext.head);\n    forkContext.replaceHead(forkContext.makeNext(-1, -1));\n  } //--------------------------------------------------------------------------\n  // Loop Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates a context object of a loop statement and stacks it.\n   * @param {string} type The type of the node which was triggered. One of\n   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n   *   and `ForStatement`.\n   * @param {string|null} label A label of the node which was triggered.\n   * @returns {void}\n   */\n\n\n  pushLoopContext(type, label) {\n    const forkContext = this.forkContext;\n    const breakContext = this.pushBreakContext(true, label);\n\n    switch (type) {\n      case \"WhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"DoWhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          entrySegments: null,\n          continueForkContext: ForkContext.newEmpty(forkContext),\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          endOfInitSegments: null,\n          testSegments: null,\n          endOfTestSegments: null,\n          updateSegments: null,\n          endOfUpdateSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          prevSegments: null,\n          leftSegments: null,\n          endOfLeftSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(`unknown type: \"${type}\"`);\n    }\n  }\n  /**\n   * Pops the last context of a loop statement and finalizes it.\n   * @returns {void}\n   */\n\n\n  popLoopContext() {\n    const context = this.loopContext;\n    this.loopContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext; // Creates a looped path.\n\n    switch (context.type) {\n      case \"WhileStatement\":\n      case \"ForStatement\":\n        this.popChoiceContext();\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n        break;\n\n      case \"DoWhileStatement\":\n        {\n          const choiceContext = this.popChoiceContext();\n\n          if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n          }\n\n          if (context.test !== true) {\n            brokenForkContext.addAll(choiceContext.falseForkContext);\n          } // `true` paths go to looping.\n\n\n          const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n          for (let i = 0; i < segmentsList.length; ++i) {\n            makeLooped(this, segmentsList[i], context.entrySegments);\n          }\n\n          break;\n        }\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        brokenForkContext.add(forkContext.head);\n        makeLooped(this, forkContext.head, context.leftSegments);\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(\"unreachable\");\n    } // Go next.\n\n\n    if (brokenForkContext.empty) {\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    } else {\n      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n  }\n  /**\n   * Makes a code path segment for the test part of a WhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n\n\n  makeWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const testSegments = forkContext.makeNext(0, -1); // Update state.\n\n    context.test = test;\n    context.continueDestSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n  /**\n   * Makes a code path segment for the body part of a WhileStatement.\n   * @returns {void}\n   */\n\n\n  makeWhileBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (!choiceContext.processed) {\n      choiceContext.trueForkContext.add(forkContext.head);\n      choiceContext.falseForkContext.add(forkContext.head);\n    } // Update state.\n\n\n    if (context.test !== true) {\n      context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n\n    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n  }\n  /**\n   * Makes a code path segment for the body part of a DoWhileStatement.\n   * @returns {void}\n   */\n\n\n  makeDoWhileBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const bodySegments = forkContext.makeNext(-1, -1); // Update state.\n\n    context.entrySegments = bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n  /**\n   * Makes a code path segment for the test part of a DoWhileStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n\n\n  makeDoWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    context.test = test; // Creates paths of `continue` statements.\n\n    if (!context.continueForkContext.empty) {\n      context.continueForkContext.add(forkContext.head);\n      const testSegments = context.continueForkContext.makeNext(0, -1);\n      forkContext.replaceHead(testSegments);\n    }\n  }\n  /**\n   * Makes a code path segment for the test part of a ForStatement.\n   * @param {boolean|undefined} test The test value (only when constant).\n   * @returns {void}\n   */\n\n\n  makeForTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const endOfInitSegments = forkContext.head;\n    const testSegments = forkContext.makeNext(-1, -1); // Update state.\n\n    context.test = test;\n    context.endOfInitSegments = endOfInitSegments;\n    context.continueDestSegments = context.testSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n  /**\n   * Makes a code path segment for the update part of a ForStatement.\n   * @returns {void}\n   */\n\n\n  makeForUpdate() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext; // Make the next paths of the test.\n\n    if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    } // Update state.\n\n\n    const updateSegments = forkContext.makeDisconnected(-1, -1);\n    context.continueDestSegments = context.updateSegments = updateSegments;\n    forkContext.replaceHead(updateSegments);\n  }\n  /**\n   * Makes a code path segment for the body part of a ForStatement.\n   * @returns {void}\n   */\n\n\n  makeForBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext; // Update state.\n\n    if (context.updateSegments) {\n      context.endOfUpdateSegments = forkContext.head; // `update` -> `test`\n\n      if (context.testSegments) {\n        makeLooped(this, context.endOfUpdateSegments, context.testSegments);\n      }\n    } else if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n\n    let bodySegments = context.endOfTestSegments;\n\n    if (!bodySegments) {\n      /*\n       * If there is not the `test` part, the `body` path comes from the\n       * `init` part and the `update` part.\n       */\n      const prevForkContext = ForkContext.newEmpty(forkContext);\n      prevForkContext.add(context.endOfInitSegments);\n\n      if (context.endOfUpdateSegments) {\n        prevForkContext.add(context.endOfUpdateSegments);\n      }\n\n      bodySegments = prevForkContext.makeNext(0, -1);\n    }\n\n    context.continueDestSegments = context.continueDestSegments || bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n  /**\n   * Makes a code path segment for the left part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n\n\n  makeForInOfLeft() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const leftSegments = forkContext.makeDisconnected(-1, -1); // Update state.\n\n    context.prevSegments = forkContext.head;\n    context.leftSegments = context.continueDestSegments = leftSegments;\n    forkContext.replaceHead(leftSegments);\n  }\n  /**\n   * Makes a code path segment for the right part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n\n\n  makeForInOfRight() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.prevSegments);\n    const rightSegments = temp.makeNext(-1, -1); // Update state.\n\n    context.endOfLeftSegments = forkContext.head;\n    forkContext.replaceHead(rightSegments);\n  }\n  /**\n   * Makes a code path segment for the body part of a ForInStatement and a\n   * ForOfStatement.\n   * @returns {void}\n   */\n\n\n  makeForInOfBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.endOfLeftSegments);\n    const bodySegments = temp.makeNext(-1, -1); // Make a path: `right` -> `left`.\n\n    makeLooped(this, forkContext.head, context.leftSegments); // Update state.\n\n    context.brokenForkContext.add(forkContext.head);\n    forkContext.replaceHead(bodySegments);\n  } //--------------------------------------------------------------------------\n  // Control Statements\n  //--------------------------------------------------------------------------\n\n  /**\n   * Creates new context for BreakStatement.\n   * @param {boolean} breakable The flag to indicate it can break by\n   *      an unlabeled BreakStatement.\n   * @param {string|null} label The label of this context.\n   * @returns {Object} The new context.\n   */\n\n\n  pushBreakContext(breakable, label) {\n    this.breakContext = {\n      upper: this.breakContext,\n      breakable,\n      label,\n      brokenForkContext: ForkContext.newEmpty(this.forkContext)\n    };\n    return this.breakContext;\n  }\n  /**\n   * Removes the top item of the break context stack.\n   * @returns {Object} The removed context.\n   */\n\n\n  popBreakContext() {\n    const context = this.breakContext;\n    const forkContext = this.forkContext;\n    this.breakContext = context.upper; // Process this context here for other than switches and loops.\n\n    if (!context.breakable) {\n      const brokenForkContext = context.brokenForkContext;\n\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n    }\n\n    return context;\n  }\n  /**\n   * Makes a path for a `break` statement.\n   *\n   * It registers the head segment to a context of `break`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string} label A label of the break statement.\n   * @returns {void}\n   */\n\n\n  makeBreak(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getBreakContext(this, label);\n    /* istanbul ignore else: foolproof (syntax error) */\n\n    if (context) {\n      context.brokenForkContext.add(forkContext.head);\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n  /**\n   * Makes a path for a `continue` statement.\n   *\n   * It makes a looping path.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @param {string} label A label of the continue statement.\n   * @returns {void}\n   */\n\n\n  makeContinue(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getContinueContext(this, label);\n    /* istanbul ignore else: foolproof (syntax error) */\n\n    if (context) {\n      if (context.continueDestSegments) {\n        makeLooped(this, forkContext.head, context.continueDestSegments); // If the context is a for-in/of loop, this effects a break also.\n\n        if (context.type === \"ForInStatement\" || context.type === \"ForOfStatement\") {\n          context.brokenForkContext.add(forkContext.head);\n        }\n      } else {\n        context.continueForkContext.add(forkContext.head);\n      }\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n  /**\n   * Makes a path for a `return` statement.\n   *\n   * It registers the head segment to a context of `return`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n\n\n  makeReturn() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getReturnContext(this).returnedForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n  /**\n   * Makes a path for a `throw` statement.\n   *\n   * It registers the head segment to a context of `throw`.\n   * It makes new unreachable segment, then it set the head with the segment.\n   * @returns {void}\n   */\n\n\n  makeThrow() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getThrowContext(this).thrownForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n  /**\n   * Makes the final path.\n   * @returns {void}\n   */\n\n\n  makeFinal() {\n    const segments = this.currentSegments;\n\n    if (segments.length > 0 && segments[0].reachable) {\n      this.returnedForkContext.add(segments);\n    }\n  }\n\n}\n\nmodule.exports = CodePathState;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js"],"names":["CodePathSegment","require","ForkContext","addToReturnedOrThrown","dest","others","all","segments","i","length","segment","push","indexOf","getContinueContext","state","label","loopContext","context","upper","getBreakContext","breakContext","breakable","getReturnContext","tryContext","hasFinalizer","position","getThrowContext","remove","xs","x","splice","removeConnection","prevSegments","nextSegments","prevSegment","nextSegment","allNextSegments","allPrevSegments","makeLooped","unflattenedFromSegments","unflattenedToSegments","fromSegments","flattenUnusedSegments","toSegments","end","Math","min","fromSegment","toSegment","reachable","markPrevSegmentAsLooped","notifyLooped","finalizeTestSegmentsOfFor","choiceContext","head","processed","trueForkContext","add","falseForkContext","test","brokenForkContext","addAll","endOfTestSegments","makeNext","CodePathState","constructor","idGenerator","onLooped","forkContext","newRoot","switchContext","currentSegments","initialSegment","final","finalSegments","returned","returnedForkContext","thrown","thrownForkContext","bind","headSegments","parentForkContext","current","pushForkContext","forkLeavingPath","newEmpty","popForkContext","lastContext","replaceHead","forkPath","forkBypassPath","pushChoiceContext","kind","isForkingAsResult","popChoiceContext","parentContext","clear","Error","prevForkContext","makeLogicalRight","makeIfConsequent","makeIfAlternate","pushSwitchContext","hasCase","defaultSegments","defaultBodySegments","foundDefault","lastIsDefault","countForks","pushBreakContext","popSwitchContext","popBreakContext","empty","lastSegments","lastCaseSegments","makeSwitchCaseBody","isEmpty","isDefault","pushTryContext","lastOfTryIsReachable","lastOfCatchIsReachable","popTryContext","normalSegments","slice","leavingSegments","makeUnreachable","makeCatchBlock","thrownSegments","makeFinallyBlock","headOfLeavingSegments","count","prevSegsOfLeavingSegment","j","segmentsList","newNext","next","makeFirstThrowablePathInTryBlock","pushLoopContext","type","continueDestSegments","entrySegments","continueForkContext","endOfInitSegments","testSegments","updateSegments","endOfUpdateSegments","leftSegments","endOfLeftSegments","popLoopContext","makeWhileTest","makeWhileBody","makeDoWhileBody","bodySegments","makeDoWhileTest","makeForTest","makeForUpdate","makeDisconnected","makeForBody","makeForInOfLeft","makeForInOfRight","temp","rightSegments","makeForInOfBody","makeBreak","makeContinue","makeReturn","makeThrow","makeFinal","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[0];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     * @param {boolean} forkLeavingPath A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression,\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     * @param {string} kind A kind string.\n     *   If the new context is LogicalExpression's, this is `\"&&\"` or `\"||\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            const prevForkContext =\n                context.kind === \"&&\" ? context.trueForkContext\n                /* kind === \"||\" */ : context.falseForkContext;\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            if (context.kind === \"&&\") {\n\n                // The path does short-circuit if false.\n                context.falseForkContext.add(forkContext.head);\n            } else {\n\n                // The path does short-circuit if true.\n                context.trueForkContext.add(forkContext.head);\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     * @param {boolean} hasCase `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     * @param {boolean} isEmpty `true` if the body is empty.\n     * @param {boolean} isDefault `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     * @param {boolean} hasFinalizer `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (let j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (let j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(\n                CodePathSegment.newNext(\n                    this.idGenerator.next(),\n                    prevSegsOfLeavingSegment\n                )\n            );\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     * @param {string} type The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments\n                );\n                break;\n\n            case \"DoWhileStatement\": {\n                const choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments\n                    );\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments\n                );\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments\n                );\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     * @param {boolean} breakable The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n"]},"metadata":{},"sourceType":"script"}