{"ast":null,"code":"/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          keywords: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          functions: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\", \"off\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let alwaysFunctions = true,\n        alwaysKeywords = true,\n        alwaysClasses = true,\n        neverFunctions = false,\n        neverKeywords = false,\n        neverClasses = false;\n\n    if (typeof config === \"object\") {\n      alwaysFunctions = config.functions === \"always\";\n      alwaysKeywords = config.keywords === \"always\";\n      alwaysClasses = config.classes === \"always\";\n      neverFunctions = config.functions === \"never\";\n      neverKeywords = config.keywords === \"never\";\n      neverClasses = config.classes === \"never\";\n    } else if (config === \"never\") {\n      alwaysFunctions = false;\n      alwaysKeywords = false;\n      alwaysClasses = false;\n      neverFunctions = true;\n      neverKeywords = true;\n      neverClasses = true;\n    }\n    /**\n     * Checks whether or not a given token is an arrow operator (=>) or a keyword\n     * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.\n     * @param {Token} token A token to check.\n     * @returns {boolean} `true` if the token is an arrow operator.\n     */\n\n\n    function isConflicted(token) {\n      return token.type === \"Punctuator\" && token.value === \"=>\" || token.type === \"Keyword\";\n    }\n    /**\n     * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n     * @param {ASTNode|Token} node The AST node of a BlockStatement.\n     * @returns {void} undefined.\n     */\n\n\n    function checkPrecedingSpace(node) {\n      const precedingToken = sourceCode.getTokenBefore(node);\n\n      if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n        const parent = context.getAncestors().pop();\n        let requireSpace;\n        let requireNoSpace;\n\n        if (parent.type === \"FunctionExpression\" || parent.type === \"FunctionDeclaration\") {\n          requireSpace = alwaysFunctions;\n          requireNoSpace = neverFunctions;\n        } else if (node.type === \"ClassBody\") {\n          requireSpace = alwaysClasses;\n          requireNoSpace = neverClasses;\n        } else {\n          requireSpace = alwaysKeywords;\n          requireNoSpace = neverKeywords;\n        }\n\n        if (requireSpace && !hasSpace) {\n          context.report({\n            node,\n            message: \"Missing space before opening brace.\",\n\n            fix(fixer) {\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n          });\n        } else if (requireNoSpace && hasSpace) {\n          context.report({\n            node,\n            message: \"Unexpected space before opening brace.\",\n\n            fix(fixer) {\n              return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n     * @param {ASTNode} node The node of a SwitchStatement.\n     * @returns {void} undefined.\n     */\n\n\n    function checkSpaceBeforeCaseBlock(node) {\n      const cases = node.cases;\n      let openingBrace;\n\n      if (cases.length > 0) {\n        openingBrace = sourceCode.getTokenBefore(cases[0]);\n      } else {\n        openingBrace = sourceCode.getLastToken(node, 1);\n      }\n\n      checkPrecedingSpace(openingBrace);\n    }\n\n    return {\n      BlockStatement: checkPrecedingSpace,\n      ClassBody: checkPrecedingSpace,\n      SwitchStatement: checkSpaceBeforeCaseBlock\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/space-before-blocks.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","keywords","functions","classes","additionalProperties","create","context","config","options","sourceCode","getSourceCode","alwaysFunctions","alwaysKeywords","alwaysClasses","neverFunctions","neverKeywords","neverClasses","isConflicted","token","value","checkPrecedingSpace","node","precedingToken","getTokenBefore","isTokenOnSameLine","hasSpace","isSpaceBetweenTokens","parent","getAncestors","pop","requireSpace","requireNoSpace","report","message","fix","fixer","insertTextBefore","removeRange","range","checkSpaceBeforeCaseBlock","cases","openingBrace","length","getLastToken","BlockStatement","ClassBody","SwitchStatement"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let alwaysFunctions = true,\n            alwaysKeywords = true,\n            alwaysClasses = true,\n            neverFunctions = false,\n            neverKeywords = false,\n            neverClasses = false;\n\n        if (typeof config === \"object\") {\n            alwaysFunctions = config.functions === \"always\";\n            alwaysKeywords = config.keywords === \"always\";\n            alwaysClasses = config.classes === \"always\";\n            neverFunctions = config.functions === \"never\";\n            neverKeywords = config.keywords === \"never\";\n            neverClasses = config.classes === \"never\";\n        } else if (config === \"never\") {\n            alwaysFunctions = false;\n            alwaysKeywords = false;\n            alwaysClasses = false;\n            neverFunctions = true;\n            neverKeywords = true;\n            neverClasses = true;\n        }\n\n        /**\n         * Checks whether or not a given token is an arrow operator (=>) or a keyword\n         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.\n         * @param {Token} token A token to check.\n         * @returns {boolean} `true` if the token is an arrow operator.\n         */\n        function isConflicted(token) {\n            return (token.type === \"Punctuator\" && token.value === \"=>\") || token.type === \"Keyword\";\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n\n            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                const parent = context.getAncestors().pop();\n                let requireSpace;\n                let requireNoSpace;\n\n                if (parent.type === \"FunctionExpression\" || parent.type === \"FunctionDeclaration\") {\n                    requireSpace = alwaysFunctions;\n                    requireNoSpace = neverFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = alwaysClasses;\n                    requireNoSpace = neverClasses;\n                } else {\n                    requireSpace = alwaysKeywords;\n                    requireNoSpace = neverKeywords;\n                }\n\n                if (requireSpace && !hasSpace) {\n                    context.report({\n                        node,\n                        message: \"Missing space before opening brace.\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                    });\n                } else if (requireNoSpace && hasSpace) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space before opening brace.\",\n                        fix(fixer) {\n                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}