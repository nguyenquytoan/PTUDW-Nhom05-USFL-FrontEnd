{"ast":null,"code":"/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements after callbacks\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/callback-return\"\n    },\n    schema: [{\n      type: \"array\",\n      items: {\n        type: \"string\"\n      }\n    }],\n    messages: {\n      missingReturn: \"Expected return with your callback function.\"\n    }\n  },\n\n  create(context) {\n    const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n          sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Find the closest parent matching a list of types.\n     * @param {ASTNode} node The node whose parents we are searching\n     * @param {Array} types The node types to match\n     * @returns {ASTNode} The matched node or undefined.\n     */\n\n    function findClosestParentOfType(node, types) {\n      if (!node.parent) {\n        return null;\n      }\n\n      if (types.indexOf(node.parent.type) === -1) {\n        return findClosestParentOfType(node.parent, types);\n      }\n\n      return node.parent;\n    }\n    /**\n     * Check to see if a node contains only identifers\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} Whether or not the node contains only identifers\n     */\n\n\n    function containsOnlyIdentifiers(node) {\n      if (node.type === \"Identifier\") {\n        return true;\n      }\n\n      if (node.type === \"MemberExpression\") {\n        if (node.object.type === \"Identifier\") {\n          return true;\n        }\n\n        if (node.object.type === \"MemberExpression\") {\n          return containsOnlyIdentifiers(node.object);\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check to see if a CallExpression is in our callback list.\n     * @param {ASTNode} node The node to check against our callback names list.\n     * @returns {boolean} Whether or not this function matches our callback name.\n     */\n\n\n    function isCallback(node) {\n      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n    }\n    /**\n     * Determines whether or not the callback is part of a callback expression.\n     * @param {ASTNode} node The callback node\n     * @param {ASTNode} parentNode The expression node\n     * @returns {boolean} Whether or not this is part of a callback expression\n     */\n\n\n    function isCallbackExpression(node, parentNode) {\n      // ensure the parent node exists and is an expression\n      if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n        return false;\n      } // cb()\n\n\n      if (parentNode.expression === node) {\n        return true;\n      } // special case for cb && cb() and similar\n\n\n      if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n        if (parentNode.expression.right === node) {\n          return true;\n        }\n      }\n\n      return false;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      CallExpression(node) {\n        // if we're not a callback we can return\n        if (!isCallback(node)) {\n          return;\n        } // find the closest block, return or loop\n\n\n        const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {}; // if our parent is a return we know we're ok\n\n        if (closestBlock.type === \"ReturnStatement\") {\n          return;\n        } // arrow functions don't always have blocks and implicitly return\n\n\n        if (closestBlock.type === \"ArrowFunctionExpression\") {\n          return;\n        } // block statements are part of functions and most if statements\n\n\n        if (closestBlock.type === \"BlockStatement\") {\n          // find the last item in the block\n          const lastItem = closestBlock.body[closestBlock.body.length - 1]; // if the callback is the last thing in a block that might be ok\n\n          if (isCallbackExpression(node, lastItem)) {\n            const parentType = closestBlock.parent.type; // but only if the block is part of a function\n\n            if (parentType === \"FunctionExpression\" || parentType === \"FunctionDeclaration\" || parentType === \"ArrowFunctionExpression\") {\n              return;\n            }\n          } // ending a block with a return is also ok\n\n\n          if (lastItem.type === \"ReturnStatement\") {\n            // but only if the callback is immediately before\n            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n              return;\n            }\n          }\n        } // as long as you're the child of a function at this point you should be asked to return\n\n\n        if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          context.report({\n            node,\n            messageId: \"missingReturn\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/callback-return.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","items","messages","missingReturn","create","context","callbacks","options","sourceCode","getSourceCode","findClosestParentOfType","node","types","parent","indexOf","containsOnlyIdentifiers","object","isCallback","callee","getText","isCallbackExpression","parentNode","expression","right","CallExpression","closestBlock","lastItem","body","length","parentType","report","messageId"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,6CADX;AAEFC,MAAAA,QAAQ,EAAE,sBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,CAAC;AACLN,MAAAA,IAAI,EAAE,OADD;AAELO,MAAAA,KAAK,EAAE;AAAEP,QAAAA,IAAI,EAAE;AAAR;AAFF,KAAD,CAVN;AAeFQ,IAAAA,QAAQ,EAAE;AACNC,MAAAA,aAAa,EAAE;AADT;AAfR,GADO;;AAqBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ,UAAMC,SAAS,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsB,CAAC,UAAD,EAAa,IAAb,EAAmB,MAAnB,CAAxC;AAAA,UACIC,UAAU,GAAGH,OAAO,CAACI,aAAR,EADjB,CAFY,CAKZ;AACA;AACA;;AAEA;;;;;;;AAMA,aAASC,uBAAT,CAAiCC,IAAjC,EAAuCC,KAAvC,EAA8C;AAC1C,UAAI,CAACD,IAAI,CAACE,MAAV,EAAkB;AACd,eAAO,IAAP;AACH;;AACD,UAAID,KAAK,CAACE,OAAN,CAAcH,IAAI,CAACE,MAAL,CAAYnB,IAA1B,MAAoC,CAAC,CAAzC,EAA4C;AACxC,eAAOgB,uBAAuB,CAACC,IAAI,CAACE,MAAN,EAAcD,KAAd,CAA9B;AACH;;AACD,aAAOD,IAAI,CAACE,MAAZ;AACH;AAED;;;;;;;AAKA,aAASE,uBAAT,CAAiCJ,IAAjC,EAAuC;AACnC,UAAIA,IAAI,CAACjB,IAAL,KAAc,YAAlB,EAAgC;AAC5B,eAAO,IAAP;AACH;;AAED,UAAIiB,IAAI,CAACjB,IAAL,KAAc,kBAAlB,EAAsC;AAClC,YAAIiB,IAAI,CAACK,MAAL,CAAYtB,IAAZ,KAAqB,YAAzB,EAAuC;AACnC,iBAAO,IAAP;AACH;;AACD,YAAIiB,IAAI,CAACK,MAAL,CAAYtB,IAAZ,KAAqB,kBAAzB,EAA6C;AACzC,iBAAOqB,uBAAuB,CAACJ,IAAI,CAACK,MAAN,CAA9B;AACH;AACJ;;AAED,aAAO,KAAP;AACH;AAED;;;;;;;AAKA,aAASC,UAAT,CAAoBN,IAApB,EAA0B;AACtB,aAAOI,uBAAuB,CAACJ,IAAI,CAACO,MAAN,CAAvB,IAAwCZ,SAAS,CAACQ,OAAV,CAAkBN,UAAU,CAACW,OAAX,CAAmBR,IAAI,CAACO,MAAxB,CAAlB,IAAqD,CAAC,CAArG;AACH;AAED;;;;;;;;AAMA,aAASE,oBAAT,CAA8BT,IAA9B,EAAoCU,UAApC,EAAgD;AAE5C;AACA,UAAI,CAACA,UAAD,IAAeA,UAAU,CAAC3B,IAAX,KAAoB,qBAAvC,EAA8D;AAC1D,eAAO,KAAP;AACH,OAL2C,CAO5C;;;AACA,UAAI2B,UAAU,CAACC,UAAX,KAA0BX,IAA9B,EAAoC;AAChC,eAAO,IAAP;AACH,OAV2C,CAY5C;;;AACA,UAAIU,UAAU,CAACC,UAAX,CAAsB5B,IAAtB,KAA+B,kBAA/B,IAAqD2B,UAAU,CAACC,UAAX,CAAsB5B,IAAtB,KAA+B,mBAAxF,EAA6G;AACzG,YAAI2B,UAAU,CAACC,UAAX,CAAsBC,KAAtB,KAAgCZ,IAApC,EAA0C;AACtC,iBAAO,IAAP;AACH;AACJ;;AAED,aAAO,KAAP;AACH,KAlFW,CAoFZ;AACA;AACA;;;AAEA,WAAO;AACHa,MAAAA,cAAc,CAACb,IAAD,EAAO;AAEjB;AACA,YAAI,CAACM,UAAU,CAACN,IAAD,CAAf,EAAuB;AACnB;AACH,SALgB,CAOjB;;;AACA,cAAMc,YAAY,GAAGf,uBAAuB,CAACC,IAAD,EAAO,CAAC,gBAAD,EAAmB,iBAAnB,EAAsC,yBAAtC,CAAP,CAAvB,IAAmG,EAAxH,CARiB,CAUjB;;AACA,YAAIc,YAAY,CAAC/B,IAAb,KAAsB,iBAA1B,EAA6C;AACzC;AACH,SAbgB,CAejB;;;AACA,YAAI+B,YAAY,CAAC/B,IAAb,KAAsB,yBAA1B,EAAqD;AACjD;AACH,SAlBgB,CAoBjB;;;AACA,YAAI+B,YAAY,CAAC/B,IAAb,KAAsB,gBAA1B,EAA4C;AAExC;AACA,gBAAMgC,QAAQ,GAAGD,YAAY,CAACE,IAAb,CAAkBF,YAAY,CAACE,IAAb,CAAkBC,MAAlB,GAA2B,CAA7C,CAAjB,CAHwC,CAKxC;;AACA,cAAIR,oBAAoB,CAACT,IAAD,EAAOe,QAAP,CAAxB,EAA0C;AAEtC,kBAAMG,UAAU,GAAGJ,YAAY,CAACZ,MAAb,CAAoBnB,IAAvC,CAFsC,CAItC;;AACA,gBAAImC,UAAU,KAAK,oBAAf,IACAA,UAAU,KAAK,qBADf,IAEAA,UAAU,KAAK,yBAFnB,EAGE;AACE;AACH;AAEJ,WAlBuC,CAoBxC;;;AACA,cAAIH,QAAQ,CAAChC,IAAT,KAAkB,iBAAtB,EAAyC;AAErC;AACA,gBAAI0B,oBAAoB,CAACT,IAAD,EAAOc,YAAY,CAACE,IAAb,CAAkBF,YAAY,CAACE,IAAb,CAAkBC,MAAlB,GAA2B,CAA7C,CAAP,CAAxB,EAAiF;AAC7E;AACH;AACJ;AAEJ,SAlDgB,CAoDjB;;;AACA,YAAIlB,uBAAuB,CAACC,IAAD,EAAO,CAAC,qBAAD,EAAwB,oBAAxB,EAA8C,yBAA9C,CAAP,CAA3B,EAA6G;AACzGN,UAAAA,OAAO,CAACyB,MAAR,CAAe;AAAEnB,YAAAA,IAAF;AAAQoB,YAAAA,SAAS,EAAE;AAAnB,WAAf;AACH;AAEJ;;AA1DE,KAAP;AA6DH;;AA1KY,CAAjB","sourcesContent":["/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/callback-return\"\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }],\n\n        messages: {\n            missingReturn: \"Expected return with your callback function.\"\n        }\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                }\n                if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, messageId: \"missingReturn\" });\n                }\n\n            }\n\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}