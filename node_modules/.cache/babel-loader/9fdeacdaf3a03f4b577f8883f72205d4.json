{"ast":null,"code":"/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent naming when capturing the current execution context\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-this\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        minLength: 1\n      },\n      uniqueItems: true\n    },\n    messages: {\n      aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n      unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n    }\n  },\n\n  create(context) {\n    let aliases = [];\n\n    if (context.options.length === 0) {\n      aliases.push(\"that\");\n    } else {\n      aliases = context.options;\n    }\n    /**\n     * Reports that a variable declarator or assignment expression is assigning\n     * a non-'this' value to the specified alias.\n     * @param {ASTNode} node The assigning node.\n     * @param {string}  name the name of the alias that was incorrectly used.\n     * @returns {void}\n     */\n\n\n    function reportBadAssignment(node, name) {\n      context.report({\n        node,\n        messageId: \"aliasNotAssignedToThis\",\n        data: {\n          name\n        }\n      });\n    }\n    /**\n     * Checks that an assignment to an identifier only assigns 'this' to the\n     * appropriate alias, and the alias is only assigned to 'this'.\n     * @param {ASTNode} node The assigning node.\n     * @param {Identifier} name The name of the variable assigned to.\n     * @param {Expression} value The value of the assignment.\n     * @returns {void}\n     */\n\n\n    function checkAssignment(node, name, value) {\n      const isThis = value.type === \"ThisExpression\";\n\n      if (aliases.indexOf(name) !== -1) {\n        if (!isThis || node.operator && node.operator !== \"=\") {\n          reportBadAssignment(node, name);\n        }\n      } else if (isThis) {\n        context.report({\n          node,\n          messageId: \"unexpectedAlias\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n    /**\n     * Ensures that a variable declaration of the alias in a program or function\n     * is assigned to the correct value.\n     * @param {string} alias alias the check the assignment of.\n     * @param {Object} scope scope of the current code we are checking.\n     * @private\n     * @returns {void}\n     */\n\n\n    function checkWasAssigned(alias, scope) {\n      const variable = scope.set.get(alias);\n\n      if (!variable) {\n        return;\n      }\n\n      if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" && def.node.init !== null)) {\n        return;\n      }\n      /*\n       * The alias has been declared and not assigned: check it was\n       * assigned later in the same scope.\n       */\n\n\n      if (!variable.references.some(reference => {\n        const write = reference.writeExpr;\n        return reference.from === scope && write && write.type === \"ThisExpression\" && write.parent.operator === \"=\";\n      })) {\n        variable.defs.map(def => def.node).forEach(node => {\n          reportBadAssignment(node, alias);\n        });\n      }\n    }\n    /**\n     * Check each alias to ensure that is was assinged to the correct value.\n     * @returns {void}\n     */\n\n\n    function ensureWasAssigned() {\n      const scope = context.getScope();\n      aliases.forEach(alias => {\n        checkWasAssigned(alias, scope);\n      });\n    }\n\n    return {\n      \"Program:exit\": ensureWasAssigned,\n      \"FunctionExpression:exit\": ensureWasAssigned,\n      \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n      VariableDeclarator(node) {\n        const id = node.id;\n        const isDestructuring = id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n        if (node.init !== null && !isDestructuring) {\n          checkAssignment(node, id.name, node.init);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.left.type === \"Identifier\") {\n          checkAssignment(node, node.left.name, node.right);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/consistent-this.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","items","minLength","uniqueItems","messages","aliasNotAssignedToThis","unexpectedAlias","create","context","aliases","options","length","push","reportBadAssignment","node","name","report","messageId","data","checkAssignment","value","isThis","indexOf","operator","checkWasAssigned","alias","scope","variable","set","get","defs","some","def","init","references","reference","write","writeExpr","from","parent","map","forEach","ensureWasAssigned","getScope","VariableDeclarator","id","isDestructuring","AssignmentExpression","left","right"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent naming when capturing the current execution context\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-this\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        },\n\n        messages: {\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node The assigning node.\n         * @param {string}  name the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, name) {\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node The assigning node.\n         * @param {Identifier} name The name of the variable assigned to.\n         * @param {Expression} value The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.indexOf(name) !== -1) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            /*\n             * The alias has been declared and not assigned: check it was\n             * assigned later in the same scope.\n             */\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assinged to the correct value.\n         * @returns {void}\n         */\n        function ensureWasAssigned() {\n            const scope = context.getScope();\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}