{"ast":null,"code":"/**\n * @fileoverview `Map` to load rules lazily.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst debug = require(\"debug\")(\"eslint:rules\");\n/** @typedef {import(\"./types\").Rule} Rule */\n\n/**\n * The `Map` object that loads each rule when it's accessed.\n * @example\n * const rules = new LazyLoadingRuleMap([\n *     [\"eqeqeq\", () => require(\"eqeqeq\")],\n *     [\"semi\", () => require(\"semi\")],\n *     [\"no-unused-vars\", () => require(\"no-unused-vars\")],\n * ])\n *\n * rules.get(\"semi\") // call `() => require(\"semi\")` here.\n *\n * @extends {Map<string, () => Rule>}\n */\n\n\nclass LazyLoadingRuleMap extends Map {\n  /**\n   * Initialize this map.\n   * @param {Array<[string, function(): Rule]>} loaders The rule loaders.\n   */\n  constructor(loaders) {\n    let remaining = loaders.length;\n    super(debug.enabled ? loaders.map(([ruleId, load]) => {\n      let cache = null;\n      return [ruleId, () => {\n        if (!cache) {\n          debug(\"Loading rule %o (remaining=%d)\", ruleId, --remaining);\n          cache = load();\n        }\n\n        return cache;\n      }];\n    }) : loaders); // `super(...iterable)` uses `this.set()`, so disable it here.\n\n    Object.defineProperty(LazyLoadingRuleMap.prototype, \"set\", {\n      configurable: true,\n      value: void 0\n    });\n  }\n  /**\n   * Get a rule.\n   * Each rule will be loaded on the first access.\n   * @param {string} ruleId The rule ID to get.\n   * @returns {Rule|undefined} The rule.\n   */\n\n\n  get(ruleId) {\n    const load = super.get(ruleId);\n    return load && load();\n  }\n  /**\n   * Iterate rules.\n   * @returns {IterableIterator<Rule>} Rules.\n   */\n\n\n  *values() {\n    for (const load of super.values()) {\n      yield load();\n    }\n  }\n  /**\n   * Iterate rules.\n   * @returns {IterableIterator<[string, Rule]>} Rules.\n   */\n\n\n  *entries() {\n    for (const [ruleId, load] of super.entries()) {\n      yield [ruleId, load()];\n    }\n  }\n  /**\n   * Call a function with each rule.\n   * @param {Function} callbackFn The callback function.\n   * @param {any} [thisArg] The object to pass to `this` of the callback function.\n   * @returns {void}\n   */\n\n\n  forEach(callbackFn, thisArg) {\n    for (const [ruleId, load] of super.entries()) {\n      callbackFn.call(thisArg, load(), ruleId, this);\n    }\n  }\n\n} // Forbid mutation.\n\n\nObject.defineProperties(LazyLoadingRuleMap.prototype, {\n  clear: {\n    configurable: true,\n    value: void 0\n  },\n  delete: {\n    configurable: true,\n    value: void 0\n  },\n  [Symbol.iterator]: {\n    configurable: true,\n    writable: true,\n    value: LazyLoadingRuleMap.prototype.entries\n  }\n});\nmodule.exports = {\n  LazyLoadingRuleMap\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/utils/lazy-loading-rule-map.js"],"names":["debug","require","LazyLoadingRuleMap","Map","constructor","loaders","remaining","length","enabled","map","ruleId","load","cache","Object","defineProperty","prototype","configurable","value","get","values","entries","forEach","callbackFn","thisArg","call","defineProperties","clear","delete","Symbol","iterator","writable","module","exports"],"mappings":"AAAA;;;;AAIA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,cAAjB,CAAd;AAEA;;AAEA;;;;;;;;;;;;;;;AAaA,MAAMC,kBAAN,SAAiCC,GAAjC,CAAqC;AAEjC;;;;AAIAC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,QAAIC,SAAS,GAAGD,OAAO,CAACE,MAAxB;AAEA,UACIP,KAAK,CAACQ,OAAN,GACMH,OAAO,CAACI,GAAR,CAAY,CAAC,CAACC,MAAD,EAASC,IAAT,CAAD,KAAoB;AAC9B,UAAIC,KAAK,GAAG,IAAZ;AAEA,aAAO,CACHF,MADG,EAEH,MAAM;AACF,YAAI,CAACE,KAAL,EAAY;AACRZ,UAAAA,KAAK,CAAC,gCAAD,EAAmCU,MAAnC,EAA2C,EAAEJ,SAA7C,CAAL;AACAM,UAAAA,KAAK,GAAGD,IAAI,EAAZ;AACH;;AACD,eAAOC,KAAP;AACH,OARE,CAAP;AAUH,KAbC,CADN,GAeMP,OAhBV,EAHiB,CAsBjB;;AACAQ,IAAAA,MAAM,CAACC,cAAP,CAAsBZ,kBAAkB,CAACa,SAAzC,EAAoD,KAApD,EAA2D;AACvDC,MAAAA,YAAY,EAAE,IADyC;AAEvDC,MAAAA,KAAK,EAAE,KAAK;AAF2C,KAA3D;AAIH;AAED;;;;;;;;AAMAC,EAAAA,GAAG,CAACR,MAAD,EAAS;AACR,UAAMC,IAAI,GAAG,MAAMO,GAAN,CAAUR,MAAV,CAAb;AAEA,WAAOC,IAAI,IAAIA,IAAI,EAAnB;AACH;AAED;;;;;;AAIA,GAACQ,MAAD,GAAU;AACN,SAAK,MAAMR,IAAX,IAAmB,MAAMQ,MAAN,EAAnB,EAAmC;AAC/B,YAAMR,IAAI,EAAV;AACH;AACJ;AAED;;;;;;AAIA,GAACS,OAAD,GAAW;AACP,SAAK,MAAM,CAACV,MAAD,EAASC,IAAT,CAAX,IAA6B,MAAMS,OAAN,EAA7B,EAA8C;AAC1C,YAAM,CAACV,MAAD,EAASC,IAAI,EAAb,CAAN;AACH;AACJ;AAED;;;;;;;;AAMAU,EAAAA,OAAO,CAACC,UAAD,EAAaC,OAAb,EAAsB;AACzB,SAAK,MAAM,CAACb,MAAD,EAASC,IAAT,CAAX,IAA6B,MAAMS,OAAN,EAA7B,EAA8C;AAC1CE,MAAAA,UAAU,CAACE,IAAX,CAAgBD,OAAhB,EAAyBZ,IAAI,EAA7B,EAAiCD,MAAjC,EAAyC,IAAzC;AACH;AACJ;;AA7EgC,C,CAgFrC;;;AACAG,MAAM,CAACY,gBAAP,CAAwBvB,kBAAkB,CAACa,SAA3C,EAAsD;AAClDW,EAAAA,KAAK,EAAE;AAAEV,IAAAA,YAAY,EAAE,IAAhB;AAAsBC,IAAAA,KAAK,EAAE,KAAK;AAAlC,GAD2C;AAElDU,EAAAA,MAAM,EAAE;AAAEX,IAAAA,YAAY,EAAE,IAAhB;AAAsBC,IAAAA,KAAK,EAAE,KAAK;AAAlC,GAF0C;AAGlD,GAACW,MAAM,CAACC,QAAR,GAAmB;AACfb,IAAAA,YAAY,EAAE,IADC;AAEfc,IAAAA,QAAQ,EAAE,IAFK;AAGfb,IAAAA,KAAK,EAAEf,kBAAkB,CAACa,SAAnB,CAA6BK;AAHrB;AAH+B,CAAtD;AAUAW,MAAM,CAACC,OAAP,GAAiB;AAAE9B,EAAAA;AAAF,CAAjB","sourcesContent":["/**\n * @fileoverview `Map` to load rules lazily.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst debug = require(\"debug\")(\"eslint:rules\");\n\n/** @typedef {import(\"./types\").Rule} Rule */\n\n/**\n * The `Map` object that loads each rule when it's accessed.\n * @example\n * const rules = new LazyLoadingRuleMap([\n *     [\"eqeqeq\", () => require(\"eqeqeq\")],\n *     [\"semi\", () => require(\"semi\")],\n *     [\"no-unused-vars\", () => require(\"no-unused-vars\")],\n * ])\n *\n * rules.get(\"semi\") // call `() => require(\"semi\")` here.\n *\n * @extends {Map<string, () => Rule>}\n */\nclass LazyLoadingRuleMap extends Map {\n\n    /**\n     * Initialize this map.\n     * @param {Array<[string, function(): Rule]>} loaders The rule loaders.\n     */\n    constructor(loaders) {\n        let remaining = loaders.length;\n\n        super(\n            debug.enabled\n                ? loaders.map(([ruleId, load]) => {\n                    let cache = null;\n\n                    return [\n                        ruleId,\n                        () => {\n                            if (!cache) {\n                                debug(\"Loading rule %o (remaining=%d)\", ruleId, --remaining);\n                                cache = load();\n                            }\n                            return cache;\n                        }\n                    ];\n                })\n                : loaders\n        );\n\n        // `super(...iterable)` uses `this.set()`, so disable it here.\n        Object.defineProperty(LazyLoadingRuleMap.prototype, \"set\", {\n            configurable: true,\n            value: void 0\n        });\n    }\n\n    /**\n     * Get a rule.\n     * Each rule will be loaded on the first access.\n     * @param {string} ruleId The rule ID to get.\n     * @returns {Rule|undefined} The rule.\n     */\n    get(ruleId) {\n        const load = super.get(ruleId);\n\n        return load && load();\n    }\n\n    /**\n     * Iterate rules.\n     * @returns {IterableIterator<Rule>} Rules.\n     */\n    *values() {\n        for (const load of super.values()) {\n            yield load();\n        }\n    }\n\n    /**\n     * Iterate rules.\n     * @returns {IterableIterator<[string, Rule]>} Rules.\n     */\n    *entries() {\n        for (const [ruleId, load] of super.entries()) {\n            yield [ruleId, load()];\n        }\n    }\n\n    /**\n     * Call a function with each rule.\n     * @param {Function} callbackFn The callback function.\n     * @param {any} [thisArg] The object to pass to `this` of the callback function.\n     * @returns {void}\n     */\n    forEach(callbackFn, thisArg) {\n        for (const [ruleId, load] of super.entries()) {\n            callbackFn.call(thisArg, load(), ruleId, this);\n        }\n    }\n}\n\n// Forbid mutation.\nObject.defineProperties(LazyLoadingRuleMap.prototype, {\n    clear: { configurable: true, value: void 0 },\n    delete: { configurable: true, value: void 0 },\n    [Symbol.iterator]: {\n        configurable: true,\n        writable: true,\n        value: LazyLoadingRuleMap.prototype.entries\n    }\n});\n\nmodule.exports = { LazyLoadingRuleMap };\n"]},"metadata":{},"sourceType":"script"}