{"ast":null,"code":"/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce valid JSDoc comments\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        prefer: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        preferType: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        requireReturn: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        requireReturnDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        matchDescription: {\n          type: \"string\"\n        },\n        requireReturnType: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamType: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n      expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n      use: \"Use @{{name}} instead.\",\n      useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n      syntaxError: \"JSDoc syntax error.\",\n      missingBrace: \"JSDoc type missing brace.\",\n      missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n      missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n      missingReturnType: \"Missing JSDoc return type.\",\n      missingReturnDesc: \"Missing JSDoc return description.\",\n      missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n      missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n      duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n      unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n    },\n    deprecated: true,\n    replacedBy: []\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          prefer = options.prefer || {},\n          sourceCode = context.getSourceCode(),\n          // these both default to true, so you have to explicitly make them false\n    requireReturn = options.requireReturn !== false,\n          requireParamDescription = options.requireParamDescription !== false,\n          requireReturnDescription = options.requireReturnDescription !== false,\n          requireReturnType = options.requireReturnType !== false,\n          requireParamType = options.requireParamType !== false,\n          preferType = options.preferType || {},\n          checkPreferType = Object.keys(preferType).length !== 0; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // Using a stack to store if a function returns or not (handling nested functions)\n\n    const fns = [];\n    /**\n     * Check if node type is a Class\n     * @param {ASTNode} node node to check.\n     * @returns {boolean} True is its a class\n     * @private\n     */\n\n    function isTypeClass(node) {\n      return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n    }\n    /**\n     * When parsing a new function, store it in our function stack.\n     * @param {ASTNode} node A function node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function startFunction(node) {\n      fns.push({\n        returnPresent: node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\" || isTypeClass(node) || node.async\n      });\n    }\n    /**\n     * Indicate that return has been found in the current function.\n     * @param {ASTNode} node The return node.\n     * @returns {void}\n     * @private\n     */\n\n\n    function addReturn(node) {\n      const functionState = fns[fns.length - 1];\n\n      if (functionState && node.argument !== null) {\n        functionState.returnPresent = true;\n      }\n    }\n    /**\n     * Check if return tag type is void or undefined\n     * @param {Object} tag JSDoc tag\n     * @returns {boolean} True if its of type void or undefined\n     * @private\n     */\n\n\n    function isValidReturnType(tag) {\n      return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n    }\n    /**\n     * Check if type should be validated based on some exceptions\n     * @param {Object} type JSDoc tag\n     * @returns {boolean} True if it can be validated\n     * @private\n     */\n\n\n    function canTypeBeValidated(type) {\n      return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n      type !== \"NullLiteral\" && // {null}\n      type !== \"NullableLiteral\" && // {?}\n      type !== \"FunctionType\" && // {function(a)}\n      type !== \"AllLiteral\"; // {*}\n    }\n    /**\n     * Extract the current and expected type based on the input type object\n     * @param {Object} type JSDoc tag\n     * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n     * the expected name of the annotation\n     * @private\n     */\n\n\n    function getCurrentExpectedTypes(type) {\n      let currentType;\n\n      if (type.name) {\n        currentType = type;\n      } else if (type.expression) {\n        currentType = type.expression;\n      }\n\n      return {\n        currentType,\n        expectedTypeName: currentType && preferType[currentType.name]\n      };\n    }\n    /**\n     * Gets the location of a JSDoc node in a file\n     * @param {Token} jsdocComment The comment that this node is parsed from\n     * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n     * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n     */\n\n\n    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n      return {\n        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n      };\n    }\n    /**\n     * Validate type for a given JSDoc node\n     * @param {Object} jsdocNode JSDoc node\n     * @param {Object} type JSDoc tag\n     * @returns {void}\n     * @private\n     */\n\n\n    function validateType(jsdocNode, type) {\n      if (!type || !canTypeBeValidated(type.type)) {\n        return;\n      }\n\n      const typesToCheck = [];\n      let elements = [];\n\n      switch (type.type) {\n        case \"TypeApplication\":\n          // {Array.<String>}\n          elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n          typesToCheck.push(getCurrentExpectedTypes(type));\n          break;\n\n        case \"RecordType\":\n          // {{20:String}}\n          elements = type.fields;\n          break;\n\n        case \"UnionType\": // {String|number|Test}\n\n        case \"ArrayType\":\n          // {[String, number, Test]}\n          elements = type.elements;\n          break;\n\n        case \"FieldType\":\n          // Array.<{count: number, votes: number}>\n          if (type.value) {\n            typesToCheck.push(getCurrentExpectedTypes(type.value));\n          }\n\n          break;\n\n        default:\n          typesToCheck.push(getCurrentExpectedTypes(type));\n      }\n\n      elements.forEach(validateType.bind(null, jsdocNode));\n      typesToCheck.forEach(typeToCheck => {\n        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n          context.report({\n            node: jsdocNode,\n            messageId: \"useType\",\n            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n            data: {\n              currentTypeName: typeToCheck.currentType.name,\n              expectedTypeName: typeToCheck.expectedTypeName\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);\n            }\n\n          });\n        }\n      });\n    }\n    /**\n     * Validate the JSDoc node and output warnings if anything is wrong.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkJSDoc(node) {\n      const jsdocNode = sourceCode.getJSDocComment(node),\n            functionData = fns.pop(),\n            paramTagsByName = Object.create(null),\n            paramTags = [];\n      let hasReturns = false,\n          returnsTag,\n          hasConstructor = false,\n          isInterface = false,\n          isOverride = false,\n          isAbstract = false; // make sure only to validate JSDoc comments\n\n      if (jsdocNode) {\n        let jsdoc;\n\n        try {\n          jsdoc = doctrine.parse(jsdocNode.value, {\n            strict: true,\n            unwrap: true,\n            sloppy: true,\n            range: true\n          });\n        } catch (ex) {\n          if (/braces/iu.test(ex.message)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingBrace\"\n            });\n          } else {\n            context.report({\n              node: jsdocNode,\n              messageId: \"syntaxError\"\n            });\n          }\n\n          return;\n        }\n\n        jsdoc.tags.forEach(tag => {\n          switch (tag.title.toLowerCase()) {\n            case \"param\":\n            case \"arg\":\n            case \"argument\":\n              paramTags.push(tag);\n              break;\n\n            case \"return\":\n            case \"returns\":\n              hasReturns = true;\n              returnsTag = tag;\n              break;\n\n            case \"constructor\":\n            case \"class\":\n              hasConstructor = true;\n              break;\n\n            case \"override\":\n            case \"inheritdoc\":\n              isOverride = true;\n              break;\n\n            case \"abstract\":\n            case \"virtual\":\n              isAbstract = true;\n              break;\n\n            case \"interface\":\n              isInterface = true;\n              break;\n            // no default\n          } // check tag preferences\n\n\n          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n            const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n            context.report({\n              node: jsdocNode,\n              messageId: \"use\",\n              loc: {\n                start: entireTagRange.start,\n                end: {\n                  line: entireTagRange.start.line,\n                  column: entireTagRange.start.column + `@${tag.title}`.length\n                }\n              },\n              data: {\n                name: prefer[tag.title]\n              },\n\n              fix(fixer) {\n                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);\n              }\n\n            });\n          } // validate the types\n\n\n          if (checkPreferType && tag.type) {\n            validateType(jsdocNode, tag.type);\n          }\n        });\n        paramTags.forEach(param => {\n          if (requireParamType && !param.type) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamType\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (!param.description && requireParamDescription) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamDesc\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (paramTagsByName[param.name]) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"duplicateParam\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          } else if (param.name.indexOf(\".\") === -1) {\n            paramTagsByName[param.name] = param;\n          }\n        });\n\n        if (hasReturns) {\n          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unexpectedTag\",\n              loc: getAbsoluteRange(jsdocNode, returnsTag),\n              data: {\n                title: returnsTag.title\n              }\n            });\n          } else {\n            if (requireReturnType && !returnsTag.type) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnType\"\n              });\n            }\n\n            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnDesc\"\n              });\n            }\n          }\n        } // check for functions missing @returns\n\n\n        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" && node.parent.kind !== \"set\" && !isTypeClass(node)) {\n          if (requireReturn || functionData.returnPresent && !node.async) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingReturn\",\n              data: {\n                returns: prefer.returns || \"returns\"\n              }\n            });\n          }\n        } // check the parameters\n\n\n        const jsdocParamNames = Object.keys(paramTagsByName);\n\n        if (node.params) {\n          node.params.forEach((param, paramsIndex) => {\n            const bindingParam = param.type === \"AssignmentPattern\" ? param.left : param; // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n\n            if (bindingParam.type === \"Identifier\") {\n              const name = bindingParam.name;\n\n              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"expected\",\n                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                  data: {\n                    name,\n                    jsdocName: jsdocParamNames[paramsIndex]\n                  }\n                });\n              } else if (!paramTagsByName[name] && !isOverride) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"missingParam\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          });\n        }\n\n        if (options.matchDescription) {\n          const regex = new RegExp(options.matchDescription, \"u\");\n\n          if (!regex.test(jsdoc.description)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unsatisfiedDesc\"\n            });\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ArrowFunctionExpression: startFunction,\n      FunctionExpression: startFunction,\n      FunctionDeclaration: startFunction,\n      ClassExpression: startFunction,\n      ClassDeclaration: startFunction,\n      \"ArrowFunctionExpression:exit\": checkJSDoc,\n      \"FunctionExpression:exit\": checkJSDoc,\n      \"FunctionDeclaration:exit\": checkJSDoc,\n      \"ClassExpression:exit\": checkJSDoc,\n      \"ClassDeclaration:exit\": checkJSDoc,\n      ReturnStatement: addReturn\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/valid-jsdoc.js"],"names":["doctrine","require","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","prefer","additionalProperties","preferType","requireReturn","default","requireParamDescription","requireReturnDescription","matchDescription","requireReturnType","requireParamType","fixable","messages","unexpectedTag","expected","use","useType","syntaxError","missingBrace","missingParamDesc","missingParamType","missingReturnType","missingReturnDesc","missingReturn","missingParam","duplicateParam","unsatisfiedDesc","deprecated","replacedBy","create","context","options","sourceCode","getSourceCode","checkPreferType","Object","keys","length","fns","isTypeClass","node","startFunction","push","returnPresent","body","async","addReturn","functionState","argument","isValidReturnType","tag","name","canTypeBeValidated","getCurrentExpectedTypes","currentType","expression","expectedTypeName","getAbsoluteRange","jsdocComment","parsedJsdocNode","start","getLocFromIndex","range","end","validateType","jsdocNode","typesToCheck","elements","applications","fields","value","forEach","bind","typeToCheck","report","messageId","loc","data","currentTypeName","fix","fixer","replaceTextRange","map","indexInComment","checkJSDoc","getJSDocComment","functionData","pop","paramTagsByName","paramTags","hasReturns","returnsTag","hasConstructor","isInterface","isOverride","isAbstract","jsdoc","parse","strict","unwrap","sloppy","ex","test","message","tags","title","toLowerCase","prototype","hasOwnProperty","call","entireTagRange","line","column","param","indexOf","parent","kind","returns","jsdocParamNames","params","paramsIndex","bindingParam","left","jsdocName","regex","RegExp","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","ClassExpression","ClassDeclaration","ReturnStatement"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,8BADX;AAEFC,MAAAA,QAAQ,EAAE,iBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,CACJ;AACIN,MAAAA,IAAI,EAAE,QADV;AAEIO,MAAAA,UAAU,EAAE;AACRC,QAAAA,MAAM,EAAE;AACJR,UAAAA,IAAI,EAAE,QADF;AAEJS,UAAAA,oBAAoB,EAAE;AAClBT,YAAAA,IAAI,EAAE;AADY;AAFlB,SADA;AAORU,QAAAA,UAAU,EAAE;AACRV,UAAAA,IAAI,EAAE,QADE;AAERS,UAAAA,oBAAoB,EAAE;AAClBT,YAAAA,IAAI,EAAE;AADY;AAFd,SAPJ;AAaRW,QAAAA,aAAa,EAAE;AACXX,UAAAA,IAAI,EAAE,SADK;AAEXY,UAAAA,OAAO,EAAE;AAFE,SAbP;AAiBRC,QAAAA,uBAAuB,EAAE;AACrBb,UAAAA,IAAI,EAAE,SADe;AAErBY,UAAAA,OAAO,EAAE;AAFY,SAjBjB;AAqBRE,QAAAA,wBAAwB,EAAE;AACtBd,UAAAA,IAAI,EAAE,SADgB;AAEtBY,UAAAA,OAAO,EAAE;AAFa,SArBlB;AAyBRG,QAAAA,gBAAgB,EAAE;AACdf,UAAAA,IAAI,EAAE;AADQ,SAzBV;AA4BRgB,QAAAA,iBAAiB,EAAE;AACfhB,UAAAA,IAAI,EAAE,SADS;AAEfY,UAAAA,OAAO,EAAE;AAFM,SA5BX;AAgCRK,QAAAA,gBAAgB,EAAE;AACdjB,UAAAA,IAAI,EAAE,SADQ;AAEdY,UAAAA,OAAO,EAAE;AAFK;AAhCV,OAFhB;AAuCIH,MAAAA,oBAAoB,EAAE;AAvC1B,KADI,CAVN;AAsDFS,IAAAA,OAAO,EAAE,MAtDP;AAuDFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,aAAa,EAAE,8DADT;AAENC,MAAAA,QAAQ,EAAE,0DAFJ;AAGNC,MAAAA,GAAG,EAAE,wBAHC;AAINC,MAAAA,OAAO,EAAE,8DAJH;AAKNC,MAAAA,WAAW,EAAE,qBALP;AAMNC,MAAAA,YAAY,EAAE,2BANR;AAONC,MAAAA,gBAAgB,EAAE,qDAPZ;AAQNC,MAAAA,gBAAgB,EAAE,8CARZ;AASNC,MAAAA,iBAAiB,EAAE,4BATb;AAUNC,MAAAA,iBAAiB,EAAE,mCAVb;AAWNC,MAAAA,aAAa,EAAE,0CAXT;AAYNC,MAAAA,YAAY,EAAE,yCAZR;AAaNC,MAAAA,cAAc,EAAE,uCAbV;AAcNC,MAAAA,eAAe,EAAE;AAdX,KAvDR;AAwEFC,IAAAA,UAAU,EAAE,IAxEV;AAyEFC,IAAAA,UAAU,EAAE;AAzEV,GADO;;AA6EbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ,UAAMC,OAAO,GAAGD,OAAO,CAACC,OAAR,CAAgB,CAAhB,KAAsB,EAAtC;AAAA,UACI9B,MAAM,GAAG8B,OAAO,CAAC9B,MAAR,IAAkB,EAD/B;AAAA,UAEI+B,UAAU,GAAGF,OAAO,CAACG,aAAR,EAFjB;AAAA,UAII;AACA7B,IAAAA,aAAa,GAAG2B,OAAO,CAAC3B,aAAR,KAA0B,KAL9C;AAAA,UAMIE,uBAAuB,GAAGyB,OAAO,CAACzB,uBAAR,KAAoC,KANlE;AAAA,UAOIC,wBAAwB,GAAGwB,OAAO,CAACxB,wBAAR,KAAqC,KAPpE;AAAA,UAQIE,iBAAiB,GAAGsB,OAAO,CAACtB,iBAAR,KAA8B,KARtD;AAAA,UASIC,gBAAgB,GAAGqB,OAAO,CAACrB,gBAAR,KAA6B,KATpD;AAAA,UAUIP,UAAU,GAAG4B,OAAO,CAAC5B,UAAR,IAAsB,EAVvC;AAAA,UAWI+B,eAAe,GAAGC,MAAM,CAACC,IAAP,CAAYjC,UAAZ,EAAwBkC,MAAxB,KAAmC,CAXzD,CAFY,CAeZ;AACA;AACA;AAEA;;AACA,UAAMC,GAAG,GAAG,EAAZ;AAEA;;;;;;;AAMA,aAASC,WAAT,CAAqBC,IAArB,EAA2B;AACvB,aAAOA,IAAI,CAAC/C,IAAL,KAAc,iBAAd,IAAmC+C,IAAI,CAAC/C,IAAL,KAAc,kBAAxD;AACH;AAED;;;;;;;;AAMA,aAASgD,aAAT,CAAuBD,IAAvB,EAA6B;AACzBF,MAAAA,GAAG,CAACI,IAAJ,CAAS;AACLC,QAAAA,aAAa,EAAGH,IAAI,CAAC/C,IAAL,KAAc,yBAAd,IAA2C+C,IAAI,CAACI,IAAL,CAAUnD,IAAV,KAAmB,gBAA/D,IACX8C,WAAW,CAACC,IAAD,CADA,IACUA,IAAI,CAACK;AAFzB,OAAT;AAIH;AAED;;;;;;;;AAMA,aAASC,SAAT,CAAmBN,IAAnB,EAAyB;AACrB,YAAMO,aAAa,GAAGT,GAAG,CAACA,GAAG,CAACD,MAAJ,GAAa,CAAd,CAAzB;;AAEA,UAAIU,aAAa,IAAIP,IAAI,CAACQ,QAAL,KAAkB,IAAvC,EAA6C;AACzCD,QAAAA,aAAa,CAACJ,aAAd,GAA8B,IAA9B;AACH;AACJ;AAED;;;;;;;;AAMA,aAASM,iBAAT,CAA2BC,GAA3B,EAAgC;AAC5B,aAAOA,GAAG,CAACzD,IAAJ,KAAa,IAAb,IAAqByD,GAAG,CAACzD,IAAJ,CAAS0D,IAAT,KAAkB,MAAvC,IAAiDD,GAAG,CAACzD,IAAJ,CAASA,IAAT,KAAkB,kBAA1E;AACH;AAED;;;;;;;;AAMA,aAAS2D,kBAAT,CAA4B3D,IAA5B,EAAkC;AAC9B,aAAOA,IAAI,KAAK,kBAAT,IAA+B;AAC/BA,MAAAA,IAAI,KAAK,aADT,IAC0B;AAC1BA,MAAAA,IAAI,KAAK,iBAFT,IAE8B;AAC9BA,MAAAA,IAAI,KAAK,cAHT,IAG2B;AAC3BA,MAAAA,IAAI,KAAK,YAJhB,CAD8B,CAKA;AACjC;AAED;;;;;;;;;AAOA,aAAS4D,uBAAT,CAAiC5D,IAAjC,EAAuC;AACnC,UAAI6D,WAAJ;;AAEA,UAAI7D,IAAI,CAAC0D,IAAT,EAAe;AACXG,QAAAA,WAAW,GAAG7D,IAAd;AACH,OAFD,MAEO,IAAIA,IAAI,CAAC8D,UAAT,EAAqB;AACxBD,QAAAA,WAAW,GAAG7D,IAAI,CAAC8D,UAAnB;AACH;;AAED,aAAO;AACHD,QAAAA,WADG;AAEHE,QAAAA,gBAAgB,EAAEF,WAAW,IAAInD,UAAU,CAACmD,WAAW,CAACH,IAAb;AAFxC,OAAP;AAIH;AAED;;;;;;;;AAMA,aAASM,gBAAT,CAA0BC,YAA1B,EAAwCC,eAAxC,EAAyD;AACrD,aAAO;AACHC,QAAAA,KAAK,EAAE5B,UAAU,CAAC6B,eAAX,CAA2BH,YAAY,CAACI,KAAb,CAAmB,CAAnB,IAAwB,CAAxB,GAA4BH,eAAe,CAACG,KAAhB,CAAsB,CAAtB,CAAvD,CADJ;AAEHC,QAAAA,GAAG,EAAE/B,UAAU,CAAC6B,eAAX,CAA2BH,YAAY,CAACI,KAAb,CAAmB,CAAnB,IAAwB,CAAxB,GAA4BH,eAAe,CAACG,KAAhB,CAAsB,CAAtB,CAAvD;AAFF,OAAP;AAIH;AAED;;;;;;;;;AAOA,aAASE,YAAT,CAAsBC,SAAtB,EAAiCxE,IAAjC,EAAuC;AACnC,UAAI,CAACA,IAAD,IAAS,CAAC2D,kBAAkB,CAAC3D,IAAI,CAACA,IAAN,CAAhC,EAA6C;AACzC;AACH;;AAED,YAAMyE,YAAY,GAAG,EAArB;AACA,UAAIC,QAAQ,GAAG,EAAf;;AAEA,cAAQ1E,IAAI,CAACA,IAAb;AACI,aAAK,iBAAL;AAAwB;AACpB0E,UAAAA,QAAQ,GAAG1E,IAAI,CAAC2E,YAAL,CAAkB,CAAlB,EAAqB3E,IAArB,KAA8B,WAA9B,GAA4CA,IAAI,CAAC2E,YAAL,CAAkB,CAAlB,EAAqBD,QAAjE,GAA4E1E,IAAI,CAAC2E,YAA5F;AACAF,UAAAA,YAAY,CAACxB,IAAb,CAAkBW,uBAAuB,CAAC5D,IAAD,CAAzC;AACA;;AACJ,aAAK,YAAL;AAAmB;AACf0E,UAAAA,QAAQ,GAAG1E,IAAI,CAAC4E,MAAhB;AACA;;AACJ,aAAK,WAAL,CARJ,CAQsB;;AAClB,aAAK,WAAL;AAAkB;AACdF,UAAAA,QAAQ,GAAG1E,IAAI,CAAC0E,QAAhB;AACA;;AACJ,aAAK,WAAL;AAAkB;AACd,cAAI1E,IAAI,CAAC6E,KAAT,EAAgB;AACZJ,YAAAA,YAAY,CAACxB,IAAb,CAAkBW,uBAAuB,CAAC5D,IAAI,CAAC6E,KAAN,CAAzC;AACH;;AACD;;AACJ;AACIJ,UAAAA,YAAY,CAACxB,IAAb,CAAkBW,uBAAuB,CAAC5D,IAAD,CAAzC;AAlBR;;AAqBA0E,MAAAA,QAAQ,CAACI,OAAT,CAAiBP,YAAY,CAACQ,IAAb,CAAkB,IAAlB,EAAwBP,SAAxB,CAAjB;AAEAC,MAAAA,YAAY,CAACK,OAAb,CAAqBE,WAAW,IAAI;AAChC,YAAIA,WAAW,CAACjB,gBAAZ,IACAiB,WAAW,CAACjB,gBAAZ,KAAiCiB,WAAW,CAACnB,WAAZ,CAAwBH,IAD7D,EACmE;AAC/DrB,UAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,YAAAA,IAAI,EAAEyB,SADK;AAEXU,YAAAA,SAAS,EAAE,SAFA;AAGXC,YAAAA,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYQ,WAAW,CAACnB,WAAxB,CAHV;AAIXuB,YAAAA,IAAI,EAAE;AACFC,cAAAA,eAAe,EAAEL,WAAW,CAACnB,WAAZ,CAAwBH,IADvC;AAEFK,cAAAA,gBAAgB,EAAEiB,WAAW,CAACjB;AAF5B,aAJK;;AAQXuB,YAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,qBAAOA,KAAK,CAACC,gBAAN,CACHR,WAAW,CAACnB,WAAZ,CAAwBQ,KAAxB,CAA8BoB,GAA9B,CAAkCC,cAAc,IAAIlB,SAAS,CAACH,KAAV,CAAgB,CAAhB,IAAqB,CAArB,GAAyBqB,cAA7E,CADG,EAEHV,WAAW,CAACjB,gBAFT,CAAP;AAIH;;AAbU,WAAf;AAeH;AACJ,OAnBD;AAoBH;AAED;;;;;;;;AAMA,aAAS4B,UAAT,CAAoB5C,IAApB,EAA0B;AACtB,YAAMyB,SAAS,GAAGjC,UAAU,CAACqD,eAAX,CAA2B7C,IAA3B,CAAlB;AAAA,YACI8C,YAAY,GAAGhD,GAAG,CAACiD,GAAJ,EADnB;AAAA,YAEIC,eAAe,GAAGrD,MAAM,CAACN,MAAP,CAAc,IAAd,CAFtB;AAAA,YAGI4D,SAAS,GAAG,EAHhB;AAIA,UAAIC,UAAU,GAAG,KAAjB;AAAA,UACIC,UADJ;AAAA,UAEIC,cAAc,GAAG,KAFrB;AAAA,UAGIC,WAAW,GAAG,KAHlB;AAAA,UAIIC,UAAU,GAAG,KAJjB;AAAA,UAKIC,UAAU,GAAG,KALjB,CALsB,CAYtB;;AACA,UAAI9B,SAAJ,EAAe;AACX,YAAI+B,KAAJ;;AAEA,YAAI;AACAA,UAAAA,KAAK,GAAG5G,QAAQ,CAAC6G,KAAT,CAAehC,SAAS,CAACK,KAAzB,EAAgC;AACpC4B,YAAAA,MAAM,EAAE,IAD4B;AAEpCC,YAAAA,MAAM,EAAE,IAF4B;AAGpCC,YAAAA,MAAM,EAAE,IAH4B;AAIpCtC,YAAAA,KAAK,EAAE;AAJ6B,WAAhC,CAAR;AAMH,SAPD,CAOE,OAAOuC,EAAP,EAAW;AAET,cAAI,WAAWC,IAAX,CAAgBD,EAAE,CAACE,OAAnB,CAAJ,EAAiC;AAC7BzE,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AAAElC,cAAAA,IAAI,EAAEyB,SAAR;AAAmBU,cAAAA,SAAS,EAAE;AAA9B,aAAf;AACH,WAFD,MAEO;AACH7C,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AAAElC,cAAAA,IAAI,EAAEyB,SAAR;AAAmBU,cAAAA,SAAS,EAAE;AAA9B,aAAf;AACH;;AAED;AACH;;AAEDqB,QAAAA,KAAK,CAACQ,IAAN,CAAWjC,OAAX,CAAmBrB,GAAG,IAAI;AAEtB,kBAAQA,GAAG,CAACuD,KAAJ,CAAUC,WAAV,EAAR;AAEI,iBAAK,OAAL;AACA,iBAAK,KAAL;AACA,iBAAK,UAAL;AACIjB,cAAAA,SAAS,CAAC/C,IAAV,CAAeQ,GAAf;AACA;;AAEJ,iBAAK,QAAL;AACA,iBAAK,SAAL;AACIwC,cAAAA,UAAU,GAAG,IAAb;AACAC,cAAAA,UAAU,GAAGzC,GAAb;AACA;;AAEJ,iBAAK,aAAL;AACA,iBAAK,OAAL;AACI0C,cAAAA,cAAc,GAAG,IAAjB;AACA;;AAEJ,iBAAK,UAAL;AACA,iBAAK,YAAL;AACIE,cAAAA,UAAU,GAAG,IAAb;AACA;;AAEJ,iBAAK,UAAL;AACA,iBAAK,SAAL;AACIC,cAAAA,UAAU,GAAG,IAAb;AACA;;AAEJ,iBAAK,WAAL;AACIF,cAAAA,WAAW,GAAG,IAAd;AACA;AAEJ;AAjCJ,WAFsB,CAsCtB;;;AACA,cAAI1D,MAAM,CAACwE,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC5G,MAArC,EAA6CiD,GAAG,CAACuD,KAAjD,KAA2DvD,GAAG,CAACuD,KAAJ,KAAcxG,MAAM,CAACiD,GAAG,CAACuD,KAAL,CAAnF,EAAgG;AAC5F,kBAAMK,cAAc,GAAGrD,gBAAgB,CAACQ,SAAD,EAAYf,GAAZ,CAAvC;AAEApB,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,cAAAA,IAAI,EAAEyB,SADK;AAEXU,cAAAA,SAAS,EAAE,KAFA;AAGXC,cAAAA,GAAG,EAAE;AACDhB,gBAAAA,KAAK,EAAEkD,cAAc,CAAClD,KADrB;AAEDG,gBAAAA,GAAG,EAAE;AACDgD,kBAAAA,IAAI,EAAED,cAAc,CAAClD,KAAf,CAAqBmD,IAD1B;AAEDC,kBAAAA,MAAM,EAAEF,cAAc,CAAClD,KAAf,CAAqBoD,MAArB,GAA+B,IAAG9D,GAAG,CAACuD,KAAM,EAAd,CAAgBpE;AAFrD;AAFJ,eAHM;AAUXwC,cAAAA,IAAI,EAAE;AAAE1B,gBAAAA,IAAI,EAAElD,MAAM,CAACiD,GAAG,CAACuD,KAAL;AAAd,eAVK;;AAWX1B,cAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,uBAAOA,KAAK,CAACC,gBAAN,CACH,CACIhB,SAAS,CAACH,KAAV,CAAgB,CAAhB,IAAqBZ,GAAG,CAACY,KAAJ,CAAU,CAAV,CAArB,GAAoC,CADxC,EAEIG,SAAS,CAACH,KAAV,CAAgB,CAAhB,IAAqBZ,GAAG,CAACY,KAAJ,CAAU,CAAV,CAArB,GAAoCZ,GAAG,CAACuD,KAAJ,CAAUpE,MAA9C,GAAuD,CAF3D,CADG,EAKHpC,MAAM,CAACiD,GAAG,CAACuD,KAAL,CALH,CAAP;AAOH;;AAnBU,aAAf;AAqBH,WA/DqB,CAiEtB;;;AACA,cAAIvE,eAAe,IAAIgB,GAAG,CAACzD,IAA3B,EAAiC;AAC7BuE,YAAAA,YAAY,CAACC,SAAD,EAAYf,GAAG,CAACzD,IAAhB,CAAZ;AACH;AACJ,SArED;AAuEAgG,QAAAA,SAAS,CAAClB,OAAV,CAAkB0C,KAAK,IAAI;AACvB,cAAIvG,gBAAgB,IAAI,CAACuG,KAAK,CAACxH,IAA/B,EAAqC;AACjCqC,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,cAAAA,IAAI,EAAEyB,SADK;AAEXU,cAAAA,SAAS,EAAE,kBAFA;AAGXC,cAAAA,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYgD,KAAZ,CAHV;AAIXpC,cAAAA,IAAI,EAAE;AAAE1B,gBAAAA,IAAI,EAAE8D,KAAK,CAAC9D;AAAd;AAJK,aAAf;AAMH;;AACD,cAAI,CAAC8D,KAAK,CAACtH,WAAP,IAAsBW,uBAA1B,EAAmD;AAC/CwB,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,cAAAA,IAAI,EAAEyB,SADK;AAEXU,cAAAA,SAAS,EAAE,kBAFA;AAGXC,cAAAA,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYgD,KAAZ,CAHV;AAIXpC,cAAAA,IAAI,EAAE;AAAE1B,gBAAAA,IAAI,EAAE8D,KAAK,CAAC9D;AAAd;AAJK,aAAf;AAMH;;AACD,cAAIqC,eAAe,CAACyB,KAAK,CAAC9D,IAAP,CAAnB,EAAiC;AAC7BrB,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,cAAAA,IAAI,EAAEyB,SADK;AAEXU,cAAAA,SAAS,EAAE,gBAFA;AAGXC,cAAAA,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYgD,KAAZ,CAHV;AAIXpC,cAAAA,IAAI,EAAE;AAAE1B,gBAAAA,IAAI,EAAE8D,KAAK,CAAC9D;AAAd;AAJK,aAAf;AAMH,WAPD,MAOO,IAAI8D,KAAK,CAAC9D,IAAN,CAAW+D,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;AACvC1B,YAAAA,eAAe,CAACyB,KAAK,CAAC9D,IAAP,CAAf,GAA8B8D,KAA9B;AACH;AACJ,SA3BD;;AA6BA,YAAIvB,UAAJ,EAAgB;AACZ,cAAI,CAACtF,aAAD,IAAkB,CAACkF,YAAY,CAAC3C,aAAhC,KAAkDgD,UAAU,CAAClG,IAAX,KAAoB,IAApB,IAA4B,CAACwD,iBAAiB,CAAC0C,UAAD,CAAhG,KAAiH,CAACI,UAAtH,EAAkI;AAC9HjE,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,cAAAA,IAAI,EAAEyB,SADK;AAEXU,cAAAA,SAAS,EAAE,eAFA;AAGXC,cAAAA,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAY0B,UAAZ,CAHV;AAIXd,cAAAA,IAAI,EAAE;AACF4B,gBAAAA,KAAK,EAAEd,UAAU,CAACc;AADhB;AAJK,aAAf;AAQH,WATD,MASO;AACH,gBAAIhG,iBAAiB,IAAI,CAACkF,UAAU,CAAClG,IAArC,EAA2C;AACvCqC,cAAAA,OAAO,CAAC4C,MAAR,CAAe;AAAElC,gBAAAA,IAAI,EAAEyB,SAAR;AAAmBU,gBAAAA,SAAS,EAAE;AAA9B,eAAf;AACH;;AAED,gBAAI,CAAC1B,iBAAiB,CAAC0C,UAAD,CAAlB,IAAkC,CAACA,UAAU,CAAChG,WAA9C,IAA6DY,wBAAjE,EAA2F;AACvFuB,cAAAA,OAAO,CAAC4C,MAAR,CAAe;AAAElC,gBAAAA,IAAI,EAAEyB,SAAR;AAAmBU,gBAAAA,SAAS,EAAE;AAA9B,eAAf;AACH;AACJ;AACJ,SA5IU,CA8IX;;;AACA,YAAI,CAACmB,UAAD,IAAe,CAACJ,UAAhB,IAA8B,CAACE,cAA/B,IAAiD,CAACC,WAAlD,IACArD,IAAI,CAAC2E,MAAL,CAAYC,IAAZ,KAAqB,KADrB,IAC8B5E,IAAI,CAAC2E,MAAL,CAAYC,IAAZ,KAAqB,aADnD,IAEA5E,IAAI,CAAC2E,MAAL,CAAYC,IAAZ,KAAqB,KAFrB,IAE8B,CAAC7E,WAAW,CAACC,IAAD,CAF9C,EAEsD;AAClD,cAAIpC,aAAa,IAAKkF,YAAY,CAAC3C,aAAb,IAA8B,CAACH,IAAI,CAACK,KAA1D,EAAkE;AAC9Df,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,cAAAA,IAAI,EAAEyB,SADK;AAEXU,cAAAA,SAAS,EAAE,eAFA;AAGXE,cAAAA,IAAI,EAAE;AACFwC,gBAAAA,OAAO,EAAEpH,MAAM,CAACoH,OAAP,IAAkB;AADzB;AAHK,aAAf;AAOH;AACJ,SA3JU,CA6JX;;;AACA,cAAMC,eAAe,GAAGnF,MAAM,CAACC,IAAP,CAAYoD,eAAZ,CAAxB;;AAEA,YAAIhD,IAAI,CAAC+E,MAAT,EAAiB;AACb/E,UAAAA,IAAI,CAAC+E,MAAL,CAAYhD,OAAZ,CAAoB,CAAC0C,KAAD,EAAQO,WAAR,KAAwB;AACxC,kBAAMC,YAAY,GAAGR,KAAK,CAACxH,IAAN,KAAe,mBAAf,GACfwH,KAAK,CAACS,IADS,GAEfT,KAFN,CADwC,CAKxC;;AACA,gBAAIQ,YAAY,CAAChI,IAAb,KAAsB,YAA1B,EAAwC;AACpC,oBAAM0D,IAAI,GAAGsE,YAAY,CAACtE,IAA1B;;AAEA,kBAAImE,eAAe,CAACE,WAAD,CAAf,IAAiCrE,IAAI,KAAKmE,eAAe,CAACE,WAAD,CAA7D,EAA6E;AACzE1F,gBAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,kBAAAA,IAAI,EAAEyB,SADK;AAEXU,kBAAAA,SAAS,EAAE,UAFA;AAGXC,kBAAAA,GAAG,EAAEnB,gBAAgB,CAACQ,SAAD,EAAYuB,eAAe,CAAC8B,eAAe,CAACE,WAAD,CAAhB,CAA3B,CAHV;AAIX3C,kBAAAA,IAAI,EAAE;AACF1B,oBAAAA,IADE;AAEFwE,oBAAAA,SAAS,EAAEL,eAAe,CAACE,WAAD;AAFxB;AAJK,iBAAf;AASH,eAVD,MAUO,IAAI,CAAChC,eAAe,CAACrC,IAAD,CAAhB,IAA0B,CAAC2C,UAA/B,EAA2C;AAC9ChE,gBAAAA,OAAO,CAAC4C,MAAR,CAAe;AACXlC,kBAAAA,IAAI,EAAEyB,SADK;AAEXU,kBAAAA,SAAS,EAAE,cAFA;AAGXE,kBAAAA,IAAI,EAAE;AACF1B,oBAAAA;AADE;AAHK,iBAAf;AAOH;AACJ;AACJ,WA7BD;AA8BH;;AAED,YAAIpB,OAAO,CAACvB,gBAAZ,EAA8B;AAC1B,gBAAMoH,KAAK,GAAG,IAAIC,MAAJ,CAAW9F,OAAO,CAACvB,gBAAnB,EAAqC,GAArC,CAAd;;AAEA,cAAI,CAACoH,KAAK,CAACtB,IAAN,CAAWN,KAAK,CAACrG,WAAjB,CAAL,EAAoC;AAChCmC,YAAAA,OAAO,CAAC4C,MAAR,CAAe;AAAElC,cAAAA,IAAI,EAAEyB,SAAR;AAAmBU,cAAAA,SAAS,EAAE;AAA9B,aAAf;AACH;AACJ;AAEJ;AAEJ,KAhZW,CAkZZ;AACA;AACA;;;AAEA,WAAO;AACHmD,MAAAA,uBAAuB,EAAErF,aADtB;AAEHsF,MAAAA,kBAAkB,EAAEtF,aAFjB;AAGHuF,MAAAA,mBAAmB,EAAEvF,aAHlB;AAIHwF,MAAAA,eAAe,EAAExF,aAJd;AAKHyF,MAAAA,gBAAgB,EAAEzF,aALf;AAMH,sCAAgC2C,UAN7B;AAOH,iCAA2BA,UAPxB;AAQH,kCAA4BA,UARzB;AASH,8BAAwBA,UATrB;AAUH,+BAAyBA,UAVtB;AAWH+C,MAAAA,eAAe,EAAErF;AAXd,KAAP;AAcH;;AAjfY,CAAjB","sourcesContent":["/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamType: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n            expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n            use: \"Use @{{name}} instead.\",\n            useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n            syntaxError: \"JSDoc syntax error.\",\n            missingBrace: \"JSDoc type missing brace.\",\n            missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n            missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n            missingReturnType: \"Missing JSDoc return type.\",\n            missingReturnDesc: \"Missing JSDoc return description.\",\n            missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n            missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n            duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n            unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n        },\n\n        deprecated: true,\n        replacedBy: []\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            requireParamType = options.requireParamType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node) || node.async\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n         * the expected name of the annotation\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type;\n            } else if (type.expression) {\n                currentType = type.expression;\n            }\n\n            return {\n                currentType,\n                expectedTypeName: currentType && preferType[currentType.name]\n            };\n        }\n\n        /**\n         * Gets the location of a JSDoc node in a file\n         * @param {Token} jsdocComment The comment that this node is parsed from\n         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n         */\n        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n            return {\n                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\": // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\": // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\": // {String|number|Test}\n                case \"ArrayType\": // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\": // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedTypeName &&\n                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n                    context.report({\n                        node: jsdocNode,\n                        messageId: \"useType\",\n                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n                        data: {\n                            currentTypeName: typeToCheck.currentType.name,\n                            expectedTypeName: typeToCheck.expectedTypeName\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),\n                                typeToCheck.expectedTypeName\n                            );\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                paramTagsByName = Object.create(null),\n                paramTags = [];\n            let hasReturns = false,\n                returnsTag,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n                let jsdoc;\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true,\n                        range: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/iu.test(ex.message)) {\n                        context.report({ node: jsdocNode, messageId: \"missingBrace\" });\n                    } else {\n                        context.report({ node: jsdocNode, messageId: \"syntaxError\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            paramTags.push(tag);\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n                            returnsTag = tag;\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"use\",\n                            loc: {\n                                start: entireTagRange.start,\n                                end: {\n                                    line: entireTagRange.start.line,\n                                    column: entireTagRange.start.column + `@${tag.title}`.length\n                                }\n                            },\n                            data: { name: prefer[tag.title] },\n                            fix(fixer) {\n                                return fixer.replaceTextRange(\n                                    [\n                                        jsdocNode.range[0] + tag.range[0] + 3,\n                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3\n                                    ],\n                                    prefer[tag.title]\n                                );\n                            }\n                        });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                paramTags.forEach(param => {\n                    if (requireParamType && !param.type) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamType\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (!param.description && requireParamDescription) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamDesc\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (paramTagsByName[param.name]) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"duplicateParam\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    } else if (param.name.indexOf(\".\") === -1) {\n                        paramTagsByName[param.name] = param;\n                    }\n                });\n\n                if (hasReturns) {\n                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"unexpectedTag\",\n                            loc: getAbsoluteRange(jsdocNode, returnsTag),\n                            data: {\n                                title: returnsTag.title\n                            }\n                        });\n                    } else {\n                        if (requireReturnType && !returnsTag.type) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnType\" });\n                        }\n\n                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnDesc\" });\n                        }\n                    }\n                }\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || (functionData.returnPresent && !node.async)) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingReturn\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParamNames = Object.keys(paramTagsByName);\n\n                if (node.params) {\n                    node.params.forEach((param, paramsIndex) => {\n                        const bindingParam = param.type === \"AssignmentPattern\"\n                            ? param.left\n                            : param;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (bindingParam.type === \"Identifier\") {\n                            const name = bindingParam.name;\n\n                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"expected\",\n                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                                    data: {\n                                        name,\n                                        jsdocName: jsdocParamNames[paramsIndex]\n                                    }\n                                });\n                            } else if (!paramTagsByName[name] && !isOverride) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"missingParam\",\n                                    data: {\n                                        name\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription, \"u\");\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, messageId: \"unsatisfiedDesc\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}