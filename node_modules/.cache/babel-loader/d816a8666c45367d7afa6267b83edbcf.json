{"ast":null,"code":"'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\n\nvar Schema = require('./Schema-42e9705c.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: {},\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/yaml/dist/Document-2cf6b08c.js"],"names":["PlainValue","require","resolveSeq","Schema","defaultOptions","anchorPrefix","customTags","indent","indentSeq","keepCstNodes","keepNodeTypes","keepBlobsInJSON","mapAsMap","maxAliasCount","prettyErrors","simpleKeys","version","scalarOptions","binary","binaryOptions","opt","Object","assign","bool","boolOptions","int","intOptions","null","nullOptions","str","strOptions","documentOptions","schema","merge","tagPrefixes","handle","prefix","defaultTagPrefix","stringifyTag","doc","tag","options","priv","match","vocab","replace","p","find","indexOf","dtp","getDefaults","suffix","substr","length","ch","getTagObject","tags","item","Alias","filter","t","format","tagObj","obj","Scalar","value","identify","class","nodeClass","name","constructor","Error","stringifyProps","node","anchors","props","anchor","getName","push","default","join","stringify","ctx","onComment","onChompKeep","Node","createCtx","aliasNodes","onTagObj","o","prevObjects","Map","createNode","alias","source","newName","map","Pair","toString","indentAtStart","stringifyString","Anchors","validAnchorNode","YAMLSeq","YAMLMap","_defineProperty","createAlias","setAnchor","createMergePair","sources","Merge","items","s","keys","a","getNames","getNode","names","i","includes","resolveNodes","_cstAliases","forEach","resolved","test","prev","visit","Collection","n","key","listTagNames","parseContents","contents","comments","before","after","body","undefined","spaceBefore","valueRange","msg","errors","YAMLSyntaxError","res","resolveNode","comment","cc","type","Type","BLANK_LINE","commentBefore","concat","cb","cbNode","resolveTagDirective","directive","parameters","YAMLSemanticError","some","resolveYamlDirective","v0","warnings","YAMLWarning","parseDirectives","directives","prevDoc","directiveComments","hasDirectives","error","copyTagPrefix","assertCollection","Document","directivesEndMarker","add","addIn","path","delete","deleteIn","isEmptyPath","defaults","get","keepScalar","getIn","has","hasIn","set","setIn","setSchema","id","toFixed","Array","isArray","parse","cstNode","range","start","end","YAMLError","makePretty","warn","listNonDefaultTags","defaultPrefix","setTagPrefix","toJSON","arg","onAnchor","keep","indentStep","anchorNames","aliasCount","count","values","indentSize","Number","isInteger","JSON","lines","vd","tagNames","unshift","repeat","chompKeep","contentComment","forceBlockIndent","addComment","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-4a68b39b.js');\nvar Schema = require('./Schema-42e9705c.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  '1.1': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  '1.2': {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", {});\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: {},\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n"]},"metadata":{},"sourceType":"script"}