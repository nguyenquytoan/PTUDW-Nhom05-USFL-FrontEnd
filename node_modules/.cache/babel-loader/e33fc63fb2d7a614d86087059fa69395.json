{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst debug = require('debug')('istanbuljs');\n\nconst libCoverage = require('istanbul-lib-coverage');\n\nconst {\n  MappedCoverage\n} = require('./mapped');\n\nconst getMapping = require('./get-mapping');\n\nconst {\n  getUniqueKey,\n  getOutput\n} = require('./transform-utils');\n\nclass SourceMapTransformer {\n  constructor(finder, opts = {}) {\n    this.finder = finder;\n    this.baseDir = opts.baseDir || process.cwd();\n  }\n\n  processFile(fc, sourceMap, coverageMapper) {\n    let changes = 0;\n    Object.keys(fc.statementMap).forEach(s => {\n      const loc = fc.statementMap[s];\n      const hits = fc.s[s];\n      const mapping = getMapping(sourceMap, loc, fc.path);\n\n      if (mapping) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(mapping.source);\n        mappedCoverage.addStatement(mapping.loc, hits);\n      }\n    });\n    Object.keys(fc.fnMap).forEach(f => {\n      const fnMeta = fc.fnMap[f];\n      const hits = fc.f[f];\n      const mapping = getMapping(sourceMap, fnMeta.decl, fc.path);\n      const spanMapping = getMapping(sourceMap, fnMeta.loc, fc.path);\n\n      if (mapping && spanMapping && mapping.source === spanMapping.source) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(mapping.source);\n        mappedCoverage.addFunction(fnMeta.name, mapping.loc, spanMapping.loc, hits);\n      }\n    });\n    Object.keys(fc.branchMap).forEach(b => {\n      const branchMeta = fc.branchMap[b];\n      const hits = fc.b[b];\n      const locs = [];\n      const mappedHits = [];\n      let source;\n      let skip;\n      branchMeta.locations.forEach((loc, i) => {\n        const mapping = getMapping(sourceMap, loc, fc.path);\n\n        if (mapping) {\n          if (!source) {\n            source = mapping.source;\n          }\n\n          if (mapping.source !== source) {\n            skip = true;\n          }\n\n          locs.push(mapping.loc);\n          mappedHits.push(hits[i]);\n        }\n      });\n\n      if (!skip && locs.length > 0) {\n        changes += 1;\n        const mappedCoverage = coverageMapper(source);\n        mappedCoverage.addBranch(branchMeta.type, locs[0]\n        /* XXX */\n        , locs, mappedHits);\n      }\n    });\n    return changes > 0;\n  }\n\n  transform(coverageMap) {\n    const uniqueFiles = {};\n\n    const getMappedCoverage = file => {\n      const key = getUniqueKey(file);\n\n      if (!uniqueFiles[key]) {\n        uniqueFiles[key] = {\n          file,\n          mappedCoverage: new MappedCoverage(file)\n        };\n      }\n\n      return uniqueFiles[key].mappedCoverage;\n    };\n\n    coverageMap.files().forEach(file => {\n      const fc = coverageMap.fileCoverageFor(file);\n      const sourceMap = this.finder(file);\n\n      if (!sourceMap) {\n        uniqueFiles[getUniqueKey(file)] = {\n          file,\n          mappedCoverage: fc\n        };\n        return;\n      }\n\n      const changed = this.processFile(fc, sourceMap, getMappedCoverage);\n\n      if (!changed) {\n        debug(`File [${file}] ignored, nothing could be mapped`);\n      }\n    });\n    return libCoverage.createCoverageMap(getOutput(uniqueFiles));\n  }\n\n}\n\nmodule.exports = {\n  create(finder, opts) {\n    return new SourceMapTransformer(finder, opts);\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-source-maps/lib/transformer.js"],"names":["debug","require","libCoverage","MappedCoverage","getMapping","getUniqueKey","getOutput","SourceMapTransformer","constructor","finder","opts","baseDir","process","cwd","processFile","fc","sourceMap","coverageMapper","changes","Object","keys","statementMap","forEach","s","loc","hits","mapping","path","mappedCoverage","source","addStatement","fnMap","f","fnMeta","decl","spanMapping","addFunction","name","branchMap","b","branchMeta","locs","mappedHits","skip","locations","i","push","length","addBranch","type","transform","coverageMap","uniqueFiles","getMappedCoverage","file","key","files","fileCoverageFor","changed","createCoverageMap","module","exports","create"],"mappings":"AAAA;;;;AAIA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,YAAjB,CAAd;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,uBAAD,CAA3B;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAqBF,OAAO,CAAC,UAAD,CAAlC;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;AAAEI,EAAAA,YAAF;AAAgBC,EAAAA;AAAhB,IAA8BL,OAAO,CAAC,mBAAD,CAA3C;;AAEA,MAAMM,oBAAN,CAA2B;AACvBC,EAAAA,WAAW,CAACC,MAAD,EAASC,IAAI,GAAG,EAAhB,EAAoB;AAC3B,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKE,OAAL,GAAeD,IAAI,CAACC,OAAL,IAAgBC,OAAO,CAACC,GAAR,EAA/B;AACH;;AAEDC,EAAAA,WAAW,CAACC,EAAD,EAAKC,SAAL,EAAgBC,cAAhB,EAAgC;AACvC,QAAIC,OAAO,GAAG,CAAd;AAEAC,IAAAA,MAAM,CAACC,IAAP,CAAYL,EAAE,CAACM,YAAf,EAA6BC,OAA7B,CAAqCC,CAAC,IAAI;AACtC,YAAMC,GAAG,GAAGT,EAAE,CAACM,YAAH,CAAgBE,CAAhB,CAAZ;AACA,YAAME,IAAI,GAAGV,EAAE,CAACQ,CAAH,CAAKA,CAAL,CAAb;AACA,YAAMG,OAAO,GAAGtB,UAAU,CAACY,SAAD,EAAYQ,GAAZ,EAAiBT,EAAE,CAACY,IAApB,CAA1B;;AAEA,UAAID,OAAJ,EAAa;AACTR,QAAAA,OAAO,IAAI,CAAX;AACA,cAAMU,cAAc,GAAGX,cAAc,CAACS,OAAO,CAACG,MAAT,CAArC;AACAD,QAAAA,cAAc,CAACE,YAAf,CAA4BJ,OAAO,CAACF,GAApC,EAAyCC,IAAzC;AACH;AACJ,KAVD;AAYAN,IAAAA,MAAM,CAACC,IAAP,CAAYL,EAAE,CAACgB,KAAf,EAAsBT,OAAtB,CAA8BU,CAAC,IAAI;AAC/B,YAAMC,MAAM,GAAGlB,EAAE,CAACgB,KAAH,CAASC,CAAT,CAAf;AACA,YAAMP,IAAI,GAAGV,EAAE,CAACiB,CAAH,CAAKA,CAAL,CAAb;AACA,YAAMN,OAAO,GAAGtB,UAAU,CAACY,SAAD,EAAYiB,MAAM,CAACC,IAAnB,EAAyBnB,EAAE,CAACY,IAA5B,CAA1B;AACA,YAAMQ,WAAW,GAAG/B,UAAU,CAACY,SAAD,EAAYiB,MAAM,CAACT,GAAnB,EAAwBT,EAAE,CAACY,IAA3B,CAA9B;;AAEA,UACID,OAAO,IACPS,WADA,IAEAT,OAAO,CAACG,MAAR,KAAmBM,WAAW,CAACN,MAHnC,EAIE;AACEX,QAAAA,OAAO,IAAI,CAAX;AACA,cAAMU,cAAc,GAAGX,cAAc,CAACS,OAAO,CAACG,MAAT,CAArC;AACAD,QAAAA,cAAc,CAACQ,WAAf,CACIH,MAAM,CAACI,IADX,EAEIX,OAAO,CAACF,GAFZ,EAGIW,WAAW,CAACX,GAHhB,EAIIC,IAJJ;AAMH;AACJ,KApBD;AAsBAN,IAAAA,MAAM,CAACC,IAAP,CAAYL,EAAE,CAACuB,SAAf,EAA0BhB,OAA1B,CAAkCiB,CAAC,IAAI;AACnC,YAAMC,UAAU,GAAGzB,EAAE,CAACuB,SAAH,CAAaC,CAAb,CAAnB;AACA,YAAMd,IAAI,GAAGV,EAAE,CAACwB,CAAH,CAAKA,CAAL,CAAb;AACA,YAAME,IAAI,GAAG,EAAb;AACA,YAAMC,UAAU,GAAG,EAAnB;AACA,UAAIb,MAAJ;AACA,UAAIc,IAAJ;AAEAH,MAAAA,UAAU,CAACI,SAAX,CAAqBtB,OAArB,CAA6B,CAACE,GAAD,EAAMqB,CAAN,KAAY;AACrC,cAAMnB,OAAO,GAAGtB,UAAU,CAACY,SAAD,EAAYQ,GAAZ,EAAiBT,EAAE,CAACY,IAApB,CAA1B;;AACA,YAAID,OAAJ,EAAa;AACT,cAAI,CAACG,MAAL,EAAa;AACTA,YAAAA,MAAM,GAAGH,OAAO,CAACG,MAAjB;AACH;;AAED,cAAIH,OAAO,CAACG,MAAR,KAAmBA,MAAvB,EAA+B;AAC3Bc,YAAAA,IAAI,GAAG,IAAP;AACH;;AAEDF,UAAAA,IAAI,CAACK,IAAL,CAAUpB,OAAO,CAACF,GAAlB;AACAkB,UAAAA,UAAU,CAACI,IAAX,CAAgBrB,IAAI,CAACoB,CAAD,CAApB;AACH;AACJ,OAdD;;AAgBA,UAAI,CAACF,IAAD,IAASF,IAAI,CAACM,MAAL,GAAc,CAA3B,EAA8B;AAC1B7B,QAAAA,OAAO,IAAI,CAAX;AACA,cAAMU,cAAc,GAAGX,cAAc,CAACY,MAAD,CAArC;AACAD,QAAAA,cAAc,CAACoB,SAAf,CACIR,UAAU,CAACS,IADf,EAEIR,IAAI,CAAC,CAAD;AAAI;AAFZ,UAGIA,IAHJ,EAIIC,UAJJ;AAMH;AACJ,KAlCD;AAoCA,WAAOxB,OAAO,GAAG,CAAjB;AACH;;AAEDgC,EAAAA,SAAS,CAACC,WAAD,EAAc;AACnB,UAAMC,WAAW,GAAG,EAApB;;AACA,UAAMC,iBAAiB,GAAGC,IAAI,IAAI;AAC9B,YAAMC,GAAG,GAAGlD,YAAY,CAACiD,IAAD,CAAxB;;AACA,UAAI,CAACF,WAAW,CAACG,GAAD,CAAhB,EAAuB;AACnBH,QAAAA,WAAW,CAACG,GAAD,CAAX,GAAmB;AACfD,UAAAA,IADe;AAEf1B,UAAAA,cAAc,EAAE,IAAIzB,cAAJ,CAAmBmD,IAAnB;AAFD,SAAnB;AAIH;;AAED,aAAOF,WAAW,CAACG,GAAD,CAAX,CAAiB3B,cAAxB;AACH,KAVD;;AAYAuB,IAAAA,WAAW,CAACK,KAAZ,GAAoBlC,OAApB,CAA4BgC,IAAI,IAAI;AAChC,YAAMvC,EAAE,GAAGoC,WAAW,CAACM,eAAZ,CAA4BH,IAA5B,CAAX;AACA,YAAMtC,SAAS,GAAG,KAAKP,MAAL,CAAY6C,IAAZ,CAAlB;;AACA,UAAI,CAACtC,SAAL,EAAgB;AACZoC,QAAAA,WAAW,CAAC/C,YAAY,CAACiD,IAAD,CAAb,CAAX,GAAkC;AAC9BA,UAAAA,IAD8B;AAE9B1B,UAAAA,cAAc,EAAEb;AAFc,SAAlC;AAIA;AACH;;AAED,YAAM2C,OAAO,GAAG,KAAK5C,WAAL,CAAiBC,EAAjB,EAAqBC,SAArB,EAAgCqC,iBAAhC,CAAhB;;AACA,UAAI,CAACK,OAAL,EAAc;AACV1D,QAAAA,KAAK,CAAE,SAAQsD,IAAK,oCAAf,CAAL;AACH;AACJ,KAfD;AAiBA,WAAOpD,WAAW,CAACyD,iBAAZ,CAA8BrD,SAAS,CAAC8C,WAAD,CAAvC,CAAP;AACH;;AAlHsB;;AAqH3BQ,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,MAAM,CAACrD,MAAD,EAASC,IAAT,EAAe;AACjB,WAAO,IAAIH,oBAAJ,CAAyBE,MAAzB,EAAiCC,IAAjC,CAAP;AACH;;AAHY,CAAjB","sourcesContent":["/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst debug = require('debug')('istanbuljs');\nconst libCoverage = require('istanbul-lib-coverage');\nconst { MappedCoverage } = require('./mapped');\nconst getMapping = require('./get-mapping');\nconst { getUniqueKey, getOutput } = require('./transform-utils');\n\nclass SourceMapTransformer {\n    constructor(finder, opts = {}) {\n        this.finder = finder;\n        this.baseDir = opts.baseDir || process.cwd();\n    }\n\n    processFile(fc, sourceMap, coverageMapper) {\n        let changes = 0;\n\n        Object.keys(fc.statementMap).forEach(s => {\n            const loc = fc.statementMap[s];\n            const hits = fc.s[s];\n            const mapping = getMapping(sourceMap, loc, fc.path);\n\n            if (mapping) {\n                changes += 1;\n                const mappedCoverage = coverageMapper(mapping.source);\n                mappedCoverage.addStatement(mapping.loc, hits);\n            }\n        });\n\n        Object.keys(fc.fnMap).forEach(f => {\n            const fnMeta = fc.fnMap[f];\n            const hits = fc.f[f];\n            const mapping = getMapping(sourceMap, fnMeta.decl, fc.path);\n            const spanMapping = getMapping(sourceMap, fnMeta.loc, fc.path);\n\n            if (\n                mapping &&\n                spanMapping &&\n                mapping.source === spanMapping.source\n            ) {\n                changes += 1;\n                const mappedCoverage = coverageMapper(mapping.source);\n                mappedCoverage.addFunction(\n                    fnMeta.name,\n                    mapping.loc,\n                    spanMapping.loc,\n                    hits\n                );\n            }\n        });\n\n        Object.keys(fc.branchMap).forEach(b => {\n            const branchMeta = fc.branchMap[b];\n            const hits = fc.b[b];\n            const locs = [];\n            const mappedHits = [];\n            let source;\n            let skip;\n\n            branchMeta.locations.forEach((loc, i) => {\n                const mapping = getMapping(sourceMap, loc, fc.path);\n                if (mapping) {\n                    if (!source) {\n                        source = mapping.source;\n                    }\n\n                    if (mapping.source !== source) {\n                        skip = true;\n                    }\n\n                    locs.push(mapping.loc);\n                    mappedHits.push(hits[i]);\n                }\n            });\n\n            if (!skip && locs.length > 0) {\n                changes += 1;\n                const mappedCoverage = coverageMapper(source);\n                mappedCoverage.addBranch(\n                    branchMeta.type,\n                    locs[0] /* XXX */,\n                    locs,\n                    mappedHits\n                );\n            }\n        });\n\n        return changes > 0;\n    }\n\n    transform(coverageMap) {\n        const uniqueFiles = {};\n        const getMappedCoverage = file => {\n            const key = getUniqueKey(file);\n            if (!uniqueFiles[key]) {\n                uniqueFiles[key] = {\n                    file,\n                    mappedCoverage: new MappedCoverage(file)\n                };\n            }\n\n            return uniqueFiles[key].mappedCoverage;\n        };\n\n        coverageMap.files().forEach(file => {\n            const fc = coverageMap.fileCoverageFor(file);\n            const sourceMap = this.finder(file);\n            if (!sourceMap) {\n                uniqueFiles[getUniqueKey(file)] = {\n                    file,\n                    mappedCoverage: fc\n                };\n                return;\n            }\n\n            const changed = this.processFile(fc, sourceMap, getMappedCoverage);\n            if (!changed) {\n                debug(`File [${file}] ignored, nothing could be mapped`);\n            }\n        });\n\n        return libCoverage.createCoverageMap(getOutput(uniqueFiles));\n    }\n}\n\nmodule.exports = {\n    create(finder, opts) {\n        return new SourceMapTransformer(finder, opts);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}