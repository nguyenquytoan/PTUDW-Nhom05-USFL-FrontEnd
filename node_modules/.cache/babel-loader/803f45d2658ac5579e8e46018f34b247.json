{"ast":null,"code":"/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          anonymous: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          named: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          asyncArrow: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n    /**\n     * Determines whether a function has a name.\n     * @param {ASTNode} node The function node.\n     * @returns {boolean} Whether the function has a name.\n     */\n\n    function isNamedFunction(node) {\n      if (node.id) {\n        return true;\n      }\n\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.kind === \"get\" || parent.kind === \"set\" || parent.method);\n    }\n    /**\n     * Gets the config for a given function\n     * @param {ASTNode} node The function node\n     * @returns {string} \"always\", \"never\", or \"ignore\"\n     */\n\n\n    function getConfigForFunction(node) {\n      if (node.type === \"ArrowFunctionExpression\") {\n        // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n        if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {\n          skip: 1\n        }))) {\n          return overrideConfig.asyncArrow || baseConfig;\n        }\n      } else if (isNamedFunction(node)) {\n        return overrideConfig.named || baseConfig; // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n      } else if (!node.generator) {\n        return overrideConfig.anonymous || baseConfig;\n      }\n\n      return \"ignore\";\n    }\n    /**\n     * Checks the parens of a function node\n     * @param {ASTNode} node A function node\n     * @returns {void}\n     */\n\n\n    function checkFunction(node) {\n      const functionConfig = getConfigForFunction(node);\n\n      if (functionConfig === \"ignore\") {\n        return;\n      }\n\n      const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n      const leftToken = sourceCode.getTokenBefore(rightToken);\n      const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n      if (hasSpacing && functionConfig === \"never\") {\n        context.report({\n          node,\n          loc: leftToken.loc.end,\n          message: \"Unexpected space before function parentheses.\",\n\n          fix(fixer) {\n            const comments = sourceCode.getCommentsBefore(rightToken); // Don't fix anything if there's a single line comment between the left and the right token\n\n            if (comments.some(comment => comment.type === \"Line\")) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\"));\n          }\n\n        });\n      } else if (!hasSpacing && functionConfig === \"always\") {\n        context.report({\n          node,\n          loc: leftToken.loc.end,\n          message: \"Missing space before function parentheses.\",\n          fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkFunction,\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/space-before-function-paren.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","anonymous","named","asyncArrow","additionalProperties","create","context","sourceCode","getSourceCode","baseConfig","options","overrideConfig","isNamedFunction","node","id","parent","kind","method","getConfigForFunction","async","isOpeningParenToken","getFirstToken","skip","generator","checkFunction","functionConfig","rightToken","leftToken","getTokenBefore","hasSpacing","isSpaceBetweenTokens","report","loc","end","message","fix","fixer","comments","getCommentsBefore","some","comment","replaceTextRange","range","reduce","text","getText","insertTextAfter","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            anonymous: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            named: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            asyncArrow: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n        /**\n         * Determines whether a function has a name.\n         * @param {ASTNode} node The function node.\n         * @returns {boolean} Whether the function has a name.\n         */\n        function isNamedFunction(node) {\n            if (node.id) {\n                return true;\n            }\n\n            const parent = node.parent;\n\n            return parent.type === \"MethodDefinition\" ||\n                (parent.type === \"Property\" &&\n                    (\n                        parent.kind === \"get\" ||\n                        parent.kind === \"set\" ||\n                        parent.method\n                    )\n                );\n        }\n\n        /**\n         * Gets the config for a given function\n         * @param {ASTNode} node The function node\n         * @returns {string} \"always\", \"never\", or \"ignore\"\n         */\n        function getConfigForFunction(node) {\n            if (node.type === \"ArrowFunctionExpression\") {\n\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\n                    return overrideConfig.asyncArrow || baseConfig;\n                }\n            } else if (isNamedFunction(node)) {\n                return overrideConfig.named || baseConfig;\n\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n            } else if (!node.generator) {\n                return overrideConfig.anonymous || baseConfig;\n            }\n\n            return \"ignore\";\n        }\n\n        /**\n         * Checks the parens of a function node\n         * @param {ASTNode} node A function node\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            const functionConfig = getConfigForFunction(node);\n\n            if (functionConfig === \"ignore\") {\n                return;\n            }\n\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const leftToken = sourceCode.getTokenBefore(rightToken);\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n            if (hasSpacing && functionConfig === \"never\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Unexpected space before function parentheses.\",\n                    fix(fixer) {\n                        const comments = sourceCode.getCommentsBefore(rightToken);\n\n                        // Don't fix anything if there's a single line comment between the left and the right token\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange(\n                            [leftToken.range[1], rightToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!hasSpacing && functionConfig === \"always\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Missing space before function parentheses.\",\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}