{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = _interopRequireDefault(require('jest-resolve-dependencies'));\n\n  _jestResolveDependencies = function _jestResolveDependencies() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst globsToMatcher = globs => path => _micromatch().default.some((0, _jestUtil().replacePathSepForGlob)(path), globs, {\n  dot: true\n});\n\nconst regexToMatcher = testRegex => path => testRegex.some(testRegex => new RegExp(testRegex).test(path));\n\nconst toTests = (context, tests) => tests.map(path => ({\n  context,\n  duration: undefined,\n  path\n}));\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const config = context.config;\n    this._context = context;\n    const rootPattern = new RegExp(config.roots.map(dir => (0, _jestRegexUtil().escapePathForRegex)(dir + _path().default.sep)).join('|'));\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: globsToMatcher(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(config.testPathIgnorePatterns.join('|'));\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (var _i = 0; _i < testCases.length; _i++) {\n        const _testCases$_i = testCases[_i],\n              isMatch = _testCases$_i.isMatch,\n              stat = _testCases$_i.stat;\n\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(toTests(this._context, this._context.hasteFS.getAllFiles()), testPathPattern);\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = new (_jestResolveDependencies().default)(this._context.resolver, this._context.hasteFS, (0, _jestSnapshot().buildSnapshotResolver)(this._context.config));\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(this._context, dependencyResolver.resolveInverse(allPaths, this.isTestFilePath.bind(this), {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        }))\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(allPaths, this.isTestFilePath.bind(this), {\n      skipNodeResolution: this._context.config.skipNodeResolution\n    });\n    const allPathsAbsolute = Array.from(allPaths).map(p => _path().default.resolve(p));\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies.filter(p => allPathsAbsolute.includes(p)).map(filename => {\n        filename = (0, _jestConfig().replaceRootDirInPath)(this._context.config.rootDir, filename);\n        return _path().default.isAbsolute(filename) ? _path().default.relative(this._context.config.rootDir, filename) : filename;\n      }).forEach(filename => collectCoverageFrom.add(filename));\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(this._context, testModulesMap.map(testModule => testModule.file))\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(this._context, paths.map(p => _path().default.resolve(this._context.config.cwd, p)).filter(this.isTestFilePath.bind(this)))\n    };\n  }\n\n  findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p => _path().default.resolve(this._context.config.cwd, p));\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    const repos = changedFilesInfo.repos,\n          changedFiles = changedFilesInfo.changedFiles; // no SCM (git/hg/...) is found in any of the roots.\n\n    const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);\n    return noSCM ? {\n      noSCM: true,\n      tests: []\n    } : this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  _getTestPaths(globalConfig, changedFiles) {\n    const paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(changedFiles, globalConfig.collectCoverage);\n    } else if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(paths, globalConfig.collectCoverage);\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  getTestPaths(globalConfig, changedFiles, filter) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const searchResult = _this._getTestPaths(globalConfig, changedFiles);\n\n      const filterPath = globalConfig.filter;\n\n      if (filter) {\n        const tests = searchResult.tests;\n        const filterResult = yield filter(tests.map(test => test.path));\n\n        if (!Array.isArray(filterResult.filtered)) {\n          throw new Error(`Filter ${filterPath} did not return a valid test list`);\n        }\n\n        const filteredSet = new Set(filterResult.filtered.map(result => result.test));\n        return _objectSpread({}, searchResult, {\n          tests: tests.filter(test => filteredSet.has(test.path))\n        });\n      }\n\n      return searchResult;\n    })();\n  }\n\n}\n\nexports.default = SearchSource;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@jest/core/build/SearchSource.js"],"names":["Object","defineProperty","exports","value","default","_path","data","_interopRequireDefault","require","_micromatch","_jestResolveDependencies","_jestRegexUtil","_jestConfig","_jestSnapshot","_jestUtil","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","args","apply","err","undefined","configurable","writable","globsToMatcher","globs","path","some","replacePathSepForGlob","dot","regexToMatcher","testRegex","RegExp","test","toTests","context","tests","map","duration","SearchSource","constructor","config","_context","rootPattern","roots","dir","escapePathForRegex","sep","join","_testPathCases","push","isMatch","stat","testMatch","testPathIgnorePatterns","testIgnorePatternsRegex","_filterTestPathsWithStats","allPaths","testPathPattern","stats","total","testCases","Array","from","regex","testPathPatternToRegExp","filterResult","_i","_testCases$_i","_getAllTestPaths","hasteFS","getAllFiles","isTestFilePath","every","testCase","findMatchingTests","findRelatedTests","collectCoverage","dependencyResolver","resolver","buildSnapshotResolver","resolveInverse","bind","skipNodeResolution","testModulesMap","resolveInverseModuleMap","allPathsAbsolute","p","collectCoverageFrom","Set","testModule","dependencies","includes","filename","replaceRootDirInPath","rootDir","isAbsolute","relative","add","file","findTestsByPaths","paths","cwd","findRelatedTestsFromPattern","isArray","resolvedPaths","findTestRelatedToChangedFiles","changedFilesInfo","repos","changedFiles","noSCM","scm","size","_getTestPaths","globalConfig","nonFlagArgs","onlyChanged","Error","runTestsByPath","getTestPaths","_this","searchResult","filterPath","filtered","filteredSet","result","has"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = _interopRequireDefault(require('jest-resolve-dependencies'));\n\n  _jestResolveDependencies = function _jestResolveDependencies() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function _jestConfig() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst globsToMatcher = globs => path =>\n  _micromatch().default.some(\n    (0, _jestUtil().replacePathSepForGlob)(path),\n    globs,\n    {\n      dot: true\n    }\n  );\n\nconst regexToMatcher = testRegex => path =>\n  testRegex.some(testRegex => new RegExp(testRegex).test(path));\n\nconst toTests = (context, tests) =>\n  tests.map(path => ({\n    context,\n    duration: undefined,\n    path\n  }));\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const config = context.config;\n    this._context = context;\n    const rootPattern = new RegExp(\n      config.roots\n        .map(dir =>\n          (0, _jestRegexUtil().escapePathForRegex)(dir + _path().default.sep)\n        )\n        .join('|')\n    );\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: globsToMatcher(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(\n        config.testPathIgnorePatterns.join('|')\n      );\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (var _i = 0; _i < testCases.length; _i++) {\n        const _testCases$_i = testCases[_i],\n          isMatch = _testCases$_i.isMatch,\n          stat = _testCases$_i.stat;\n\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(\n      toTests(this._context, this._context.hasteFS.getAllFiles()),\n      testPathPattern\n    );\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = new (_jestResolveDependencies()).default(\n      this._context.resolver,\n      this._context.hasteFS,\n      (0, _jestSnapshot().buildSnapshotResolver)(this._context.config)\n    );\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(\n          this._context,\n          dependencyResolver.resolveInverse(\n            allPaths,\n            this.isTestFilePath.bind(this),\n            {\n              skipNodeResolution: this._context.config.skipNodeResolution\n            }\n          )\n        )\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(\n      allPaths,\n      this.isTestFilePath.bind(this),\n      {\n        skipNodeResolution: this._context.config.skipNodeResolution\n      }\n    );\n    const allPathsAbsolute = Array.from(allPaths).map(p =>\n      _path().default.resolve(p)\n    );\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies\n        .filter(p => allPathsAbsolute.includes(p))\n        .map(filename => {\n          filename = (0, _jestConfig().replaceRootDirInPath)(\n            this._context.config.rootDir,\n            filename\n          );\n          return _path().default.isAbsolute(filename)\n            ? _path().default.relative(this._context.config.rootDir, filename)\n            : filename;\n        })\n        .forEach(filename => collectCoverageFrom.add(filename));\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(\n        this._context,\n        testModulesMap.map(testModule => testModule.file)\n      )\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(\n        this._context,\n        paths\n          .map(p => _path().default.resolve(this._context.config.cwd, p))\n          .filter(this.isTestFilePath.bind(this))\n      )\n    };\n  }\n\n  findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p =>\n        _path().default.resolve(this._context.config.cwd, p)\n      );\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    const repos = changedFilesInfo.repos,\n      changedFiles = changedFilesInfo.changedFiles; // no SCM (git/hg/...) is found in any of the roots.\n\n    const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);\n    return noSCM\n      ? {\n          noSCM: true,\n          tests: []\n        }\n      : this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  _getTestPaths(globalConfig, changedFiles) {\n    const paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(\n        changedFiles,\n        globalConfig.collectCoverage\n      );\n    } else if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(\n        paths,\n        globalConfig.collectCoverage\n      );\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  getTestPaths(globalConfig, changedFiles, filter) {\n    var _this = this;\n\n    return _asyncToGenerator(function*() {\n      const searchResult = _this._getTestPaths(globalConfig, changedFiles);\n\n      const filterPath = globalConfig.filter;\n\n      if (filter) {\n        const tests = searchResult.tests;\n        const filterResult = yield filter(tests.map(test => test.path));\n\n        if (!Array.isArray(filterResult.filtered)) {\n          throw new Error(\n            `Filter ${filterPath} did not return a valid test list`\n          );\n        }\n\n        const filteredSet = new Set(\n          filterResult.filtered.map(result => result.test)\n        );\n        return _objectSpread({}, searchResult, {\n          tests: tests.filter(test => filteredSet.has(test.path))\n        });\n      }\n\n      return searchResult;\n    })();\n  }\n}\n\nexports.default = SearchSource;\n"]},"metadata":{},"sourceType":"script"}