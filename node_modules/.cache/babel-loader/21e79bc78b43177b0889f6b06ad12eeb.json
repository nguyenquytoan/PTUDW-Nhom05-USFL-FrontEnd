{"ast":null,"code":"import Promise from './promise';\nimport { default as Enumerator } from './enumerator';\nimport { REJECTED } from './-internal';\nexport class MapEnumerator extends Enumerator {\n  constructor(Constructor, entries, mapFn, label) {\n    super(Constructor, entries, true, label, mapFn);\n  }\n\n  _init(Constructor, input, bool, label, mapFn) {\n    let len = input.length || 0;\n    this.length = len;\n    this._remaining = len;\n    this._result = new Array(len);\n    this._mapFn = mapFn;\n\n    this._enumerate(input);\n  }\n\n  _setResultAt(state, i, value, firstPass) {\n    if (firstPass) {\n      try {\n        this._eachEntry(this._mapFn(value, i), i, false);\n      } catch (error) {\n        this._settledAt(REJECTED, i, error, false);\n      }\n    } else {\n      this._remaining--;\n      this._result[i] = value;\n    }\n  }\n\n}\n/**\n `map` is similar to JavaScript's native `map` method. `mapFn` is eagerly called\n  meaning that as soon as any promise resolves its value will be passed to `mapFn`.\n  `map` returns a promise that will become fulfilled with the result of running\n  `mapFn` on the values the promises become fulfilled with.\n\n  For example:\n\n  ```javascript\n  import { map, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  let mapFn = function(item){\n    return item + 1;\n  };\n\n  map(promises, mapFn).then(function(result){\n    // result is [ 2, 3, 4 ]\n  });\n  ```\n\n  If any of the `promises` given to `map` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promise's\n  rejection handler. For example:\n\n  ```javascript\n  import { map, reject, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error('2'));\n  let promise3 = reject(new Error('3'));\n  let promises = [ promise1, promise2, promise3 ];\n\n  let mapFn = function(item){\n    return item + 1;\n  };\n\n  map(promises, mapFn).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(reason) {\n    // reason.message === '2'\n  });\n  ```\n\n  `map` will also wait if a promise is returned from `mapFn`. For example,\n  say you want to get all comments from a set of blog posts, but you need\n  the blog posts first because they contain a url to those comments.\n\n  ```javscript\n  import { map } from 'rsvp';\n\n  let mapFn = function(blogPost){\n    // getComments does some ajax and returns an Promise that is fulfilled\n    // with some comments data\n    return getComments(blogPost.comments_url);\n  };\n\n  // getBlogPosts does some ajax and returns an Promise that is fulfilled\n  // with some blog post data\n  map(getBlogPosts(), mapFn).then(function(comments){\n    // comments is the result of asking the server for the comments\n    // of all blog posts returned from getBlogPosts()\n  });\n  ```\n\n  @method map\n  @public\n  @static\n  @for rsvp\n  @param {Array} promises\n  @param {Function} mapFn function to be called on each fulfilled promise.\n  @param {String} [label] optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled with the result of calling\n  `mapFn` on each fulfilled promise or value when they become fulfilled.\n   The promise will be rejected if any of the given `promises` become rejected.\n*/\n\nexport default function map(promises, mapFn, label) {\n  if (typeof mapFn !== 'function') {\n    return Promise.reject(new TypeError(\"map expects a function as a second argument\"), label);\n  }\n\n  return Promise.resolve(promises, label).then(function (promises) {\n    if (!Array.isArray(promises)) {\n      throw new TypeError(\"map must be called with an array\");\n    }\n\n    return new MapEnumerator(Promise, promises, mapFn, label).promise;\n  });\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/rsvp/lib/rsvp/map.js"],"names":["Promise","default","Enumerator","REJECTED","MapEnumerator","constructor","Constructor","entries","mapFn","label","_init","input","bool","len","length","_remaining","_result","Array","_mapFn","_enumerate","_setResultAt","state","i","value","firstPass","_eachEntry","error","_settledAt","map","promises","reject","TypeError","resolve","then","isArray","promise"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,SACEC,OAAO,IAAIC,UADb,QAEO,cAFP;AAGA,SACEC,QADF,QAEO,aAFP;AAIA,OAAO,MAAMC,aAAN,SAA4BF,UAA5B,CAAuC;AAC5CG,EAAAA,WAAW,CAACC,WAAD,EAAcC,OAAd,EAAuBC,KAAvB,EAA8BC,KAA9B,EAAqC;AAC9C,UAAMH,WAAN,EAAmBC,OAAnB,EAA4B,IAA5B,EAAkCE,KAAlC,EAAyCD,KAAzC;AACD;;AAEDE,EAAAA,KAAK,CAACJ,WAAD,EAAcK,KAAd,EAAqBC,IAArB,EAA2BH,KAA3B,EAAkCD,KAAlC,EAAyC;AAC5C,QAAIK,GAAG,GAAGF,KAAK,CAACG,MAAN,IAAgB,CAA1B;AACA,SAAKA,MAAL,GAAkBD,GAAlB;AACA,SAAKE,UAAL,GAAkBF,GAAlB;AACA,SAAKG,OAAL,GAAe,IAAIC,KAAJ,CAAUJ,GAAV,CAAf;AACA,SAAKK,MAAL,GAAcV,KAAd;;AAEA,SAAKW,UAAL,CAAgBR,KAAhB;AACD;;AAEDS,EAAAA,YAAY,CAACC,KAAD,EAAQC,CAAR,EAAWC,KAAX,EAAkBC,SAAlB,EAA6B;AACvC,QAAIA,SAAJ,EAAe;AACb,UAAI;AACF,aAAKC,UAAL,CAAgB,KAAKP,MAAL,CAAYK,KAAZ,EAAmBD,CAAnB,CAAhB,EAAuCA,CAAvC,EAA0C,KAA1C;AACD,OAFD,CAEE,OAAOI,KAAP,EAAc;AACd,aAAKC,UAAL,CAAgBxB,QAAhB,EAA0BmB,CAA1B,EAA6BI,KAA7B,EAAoC,KAApC;AACD;AACF,KAND,MAMO;AACL,WAAKX,UAAL;AACA,WAAKC,OAAL,CAAaM,CAAb,IAAkBC,KAAlB;AACD;AACF;;AA1B2C;AA8B9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiFA,eAAe,SAASK,GAAT,CAAaC,QAAb,EAAuBrB,KAAvB,EAA8BC,KAA9B,EAAqC;AAClD,MAAI,OAAOD,KAAP,KAAiB,UAArB,EAAiC;AAC/B,WAAOR,OAAO,CAAC8B,MAAR,CAAe,IAAIC,SAAJ,CAAc,6CAAd,CAAf,EAA6EtB,KAA7E,CAAP;AACD;;AAED,SAAOT,OAAO,CAACgC,OAAR,CAAgBH,QAAhB,EAA0BpB,KAA1B,EACJwB,IADI,CACC,UAASJ,QAAT,EAAmB;AACvB,QAAI,CAACZ,KAAK,CAACiB,OAAN,CAAcL,QAAd,CAAL,EAA8B;AAC5B,YAAM,IAAIE,SAAJ,CAAc,kCAAd,CAAN;AACD;;AACD,WAAO,IAAI3B,aAAJ,CAAkBJ,OAAlB,EAA2B6B,QAA3B,EAAqCrB,KAArC,EAA4CC,KAA5C,EAAmD0B,OAA1D;AACD,GANI,CAAP;AAOD","sourcesContent":["import Promise from './promise';\nimport {\n  default as Enumerator\n} from './enumerator';\nimport {\n  REJECTED\n} from './-internal';\n\nexport class MapEnumerator extends Enumerator {\n  constructor(Constructor, entries, mapFn, label) {\n    super(Constructor, entries, true, label, mapFn);\n  }\n\n  _init(Constructor, input, bool, label, mapFn) {\n    let len = input.length || 0;\n    this.length     = len;\n    this._remaining = len;\n    this._result = new Array(len);\n    this._mapFn = mapFn;\n\n    this._enumerate(input);\n  }\n\n  _setResultAt(state, i, value, firstPass) {\n    if (firstPass) {\n      try {\n        this._eachEntry(this._mapFn(value, i), i, false);\n      } catch (error) {\n        this._settledAt(REJECTED, i, error, false);\n      }\n    } else {\n      this._remaining--;\n      this._result[i] = value;\n    }\n  }\n}\n\n\n/**\n `map` is similar to JavaScript's native `map` method. `mapFn` is eagerly called\n  meaning that as soon as any promise resolves its value will be passed to `mapFn`.\n  `map` returns a promise that will become fulfilled with the result of running\n  `mapFn` on the values the promises become fulfilled with.\n\n  For example:\n\n  ```javascript\n  import { map, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  let mapFn = function(item){\n    return item + 1;\n  };\n\n  map(promises, mapFn).then(function(result){\n    // result is [ 2, 3, 4 ]\n  });\n  ```\n\n  If any of the `promises` given to `map` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promise's\n  rejection handler. For example:\n\n  ```javascript\n  import { map, reject, resolve } from 'rsvp';\n\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error('2'));\n  let promise3 = reject(new Error('3'));\n  let promises = [ promise1, promise2, promise3 ];\n\n  let mapFn = function(item){\n    return item + 1;\n  };\n\n  map(promises, mapFn).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(reason) {\n    // reason.message === '2'\n  });\n  ```\n\n  `map` will also wait if a promise is returned from `mapFn`. For example,\n  say you want to get all comments from a set of blog posts, but you need\n  the blog posts first because they contain a url to those comments.\n\n  ```javscript\n  import { map } from 'rsvp';\n\n  let mapFn = function(blogPost){\n    // getComments does some ajax and returns an Promise that is fulfilled\n    // with some comments data\n    return getComments(blogPost.comments_url);\n  };\n\n  // getBlogPosts does some ajax and returns an Promise that is fulfilled\n  // with some blog post data\n  map(getBlogPosts(), mapFn).then(function(comments){\n    // comments is the result of asking the server for the comments\n    // of all blog posts returned from getBlogPosts()\n  });\n  ```\n\n  @method map\n  @public\n  @static\n  @for rsvp\n  @param {Array} promises\n  @param {Function} mapFn function to be called on each fulfilled promise.\n  @param {String} [label] optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled with the result of calling\n  `mapFn` on each fulfilled promise or value when they become fulfilled.\n   The promise will be rejected if any of the given `promises` become rejected.\n*/\nexport default function map(promises, mapFn, label) {\n  if (typeof mapFn !== 'function') {\n    return Promise.reject(new TypeError(\"map expects a function as a second argument\"), label);\n  }\n\n  return Promise.resolve(promises, label)\n    .then(function(promises) {\n      if (!Array.isArray(promises)) {\n        throw new TypeError(\"map must be called with an array\");\n      }\n      return new MapEnumerator(Promise, promises, mapFn, label).promise;\n    });\n}\n"]},"metadata":{},"sourceType":"module"}