{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce camelcase naming convention\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/camelcase\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImports: {\n          type: \"boolean\",\n          default: false\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        },\n        allow: {\n          type: \"array\",\n          items: [{\n            type: \"string\"\n          }],\n          minItems: 0,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let properties = options.properties || \"\";\n    const ignoreDestructuring = options.ignoreDestructuring;\n    const ignoreImports = options.ignoreImports;\n    const allow = options.allow || [];\n\n    if (properties !== \"always\" && properties !== \"never\") {\n      properties = \"always\";\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n\n\n    const reported = [];\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n    /**\n     * Checks if a string contains an underscore and isn't all upper-case\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is underscored\n     * @private\n     */\n\n    function isUnderscored(name) {\n      // if there's an underscore, it might be A_CONSTANT, which is okay\n      return name.includes(\"_\") && name !== name.toUpperCase();\n    }\n    /**\n     * Checks if a string match the ignore list\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is ignored\n     * @private\n     */\n\n\n    function isAllowed(name) {\n      return allow.some(entry => name === entry || name.match(new RegExp(entry, \"u\")));\n    }\n    /**\n     * Checks if a parent of a node is an ObjectPattern.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} if the node is inside an ObjectPattern\n     * @private\n     */\n\n\n    function isInsideObjectPattern(node) {\n      let current = node;\n\n      while (current) {\n        const parent = current.parent;\n\n        if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n          return false;\n        }\n\n        if (current.type === \"ObjectPattern\") {\n          return true;\n        }\n\n        current = parent;\n      }\n\n      return false;\n    }\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node) {\n      if (!reported.includes(node)) {\n        reported.push(node);\n        context.report({\n          node,\n          messageId: \"notCamelCase\",\n          data: {\n            name: node.name\n          }\n        });\n      }\n    }\n\n    return {\n      Identifier(node) {\n        /*\n         * Leading and trailing underscores are commonly used to flag\n         * private/protected identifiers, strip them before checking if underscored\n         */\n        const name = node.name,\n              nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n              effectiveParent = node.parent.type === \"MemberExpression\" ? node.parent.parent : node.parent; // First, we ignore the node if it match the ignore list\n\n        if (isAllowed(name)) {\n          return;\n        } // MemberExpressions get special rules\n\n\n        if (node.parent.type === \"MemberExpression\") {\n          // \"never\" check properties\n          if (properties === \"never\") {\n            return;\n          } // Always report underscored object names\n\n\n          if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n            report(node); // Report AssignmentExpressions only if they are the left side of the assignment\n          } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n            report(node);\n          }\n          /*\n           * Properties have their own rules, and\n           * AssignmentPattern nodes can be treated like Properties:\n           * e.g.: const { no_camelcased = false } = bar;\n           */\n\n        } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n          if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n            if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n              report(node);\n            }\n\n            const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n            if (isUnderscored(name) && node.parent.computed) {\n              report(node);\n            } // prevent checking righthand side of destructured object\n\n\n            if (node.parent.key === node && node.parent.value !== node) {\n              return;\n            }\n\n            const valueIsUnderscored = node.parent.value.name && nameIsUnderscored; // ignore destructuring if the option is set, unless a new identifier is created\n\n            if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          } // \"never\" check properties or always ignore destructuring\n\n\n          if (properties === \"never\" || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          } // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n\n\n          if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n            report(node);\n          } // Check if it's an import specifier\n\n        } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].includes(node.parent.type)) {\n          if (node.parent.type === \"ImportSpecifier\" && ignoreImports) {\n            return;\n          } // Report only if the local imported identifier is underscored\n\n\n          if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {\n            report(node);\n          } // Report anything that is underscored that isn't a CallExpression\n\n        } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/camelcase.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreDestructuring","default","ignoreImports","enum","allow","items","minItems","uniqueItems","additionalProperties","messages","notCamelCase","create","context","options","reported","ALLOWED_PARENT_TYPES","Set","isUnderscored","name","includes","toUpperCase","isAllowed","some","entry","match","RegExp","isInsideObjectPattern","node","current","parent","computed","key","report","push","messageId","data","Identifier","nameIsUnderscored","replace","effectiveParent","object","right","left","property","shorthand","value","assignmentKeyEqualsValue","valueIsUnderscored","has","local"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreImports: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: [\n                            {\n                                type: \"string\"\n                            }\n                        ],\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        let properties = options.properties || \"\";\n        const ignoreDestructuring = options.ignoreDestructuring;\n        const ignoreImports = options.ignoreImports;\n        const allow = options.allow || [];\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = [];\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.includes(\"_\") && name !== name.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.some(\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\n            );\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let current = node;\n\n            while (current) {\n                const parent = current.parent;\n\n                if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n                    return false;\n                }\n\n                if (current.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                current = parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reported.includes(node)) {\n                reported.push(node);\n                context.report({ node, messageId: \"notCamelCase\", data: { name: node.name } });\n            }\n        }\n\n        return {\n\n            Identifier(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them before checking if underscored\n                 */\n                const name = node.name,\n                    nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // First, we ignore the node if it match the ignore list\n                if (isAllowed(name)) {\n                    return;\n                }\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n                        report(node);\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n                        if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n                        if (isUnderscored(name) && node.parent.computed) {\n                            report(node);\n                        }\n\n                        // prevent checking righthand side of destructured object\n                        if (node.parent.key === node && node.parent.value !== node) {\n                            return;\n                        }\n\n                        const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // \"never\" check properties or always ignore destructuring\n                    if (properties === \"never\" || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].includes(node.parent.type)) {\n\n                    if (node.parent.type === \"ImportSpecifier\" && ignoreImports) {\n                        return;\n                    }\n\n                    // Report only if the local imported identifier is underscored\n                    if (\n                        node.parent.local &&\n                        node.parent.local.name === node.name &&\n                        nameIsUnderscored\n                    ) {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}