{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst MiniPass = require('minipass');\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)*$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst SsriOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  error: {\n    default: false\n  },\n  integrity: {},\n  options: {\n    default: []\n  },\n  pickAlgorithm: {\n    default: () => getPrioritizedHash\n  },\n  sep: {\n    default: ' '\n  },\n  single: {\n    default: false\n  },\n  size: {},\n  strict: {\n    default: false\n  }\n});\n\nconst getOptString = options => !options || !options.length ? '' : `?${options.join('?')}`;\n\nconst _onEnd = Symbol('_onEnd');\n\nconst _getOptions = Symbol('_getOptions');\n\nclass IntegrityStream extends MiniPass {\n  constructor(opts) {\n    super();\n    this.size = 0;\n    this.opts = opts; // may be overridden later, but set now for class consistency\n\n    this[_getOptions](); // options used for calculating stream.  can't be changed.\n\n\n    this.algorithms = Array.from(new Set(opts.algorithms.concat(this.algorithm ? [this.algorithm] : [])));\n    this.hashes = this.algorithms.map(crypto.createHash);\n  }\n\n  [_getOptions]() {\n    const opts = this.opts; // For verification\n\n    this.sri = opts.integrity ? parse(opts.integrity, opts) : null;\n    this.expectedSize = opts.size;\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false;\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(opts) : null;\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null;\n    this.optString = getOptString(opts.options);\n  }\n\n  emit(ev, data) {\n    if (ev === 'end') this[_onEnd]();\n    return super.emit(ev, data);\n  }\n\n  write(data) {\n    this.size += data.length;\n    this.hashes.forEach(h => h.update(data));\n    return super.write(data);\n  }\n\n  [_onEnd]() {\n    if (!this.goodSri) {\n      this[_getOptions]();\n    }\n\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`;\n    }).join(' '), this.opts); // Integrity verification mode\n\n    const match = this.goodSri && newSri.match(this.sri, this.opts);\n\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`);\n      err.code = 'EBADSIZE';\n      err.found = this.size;\n      err.expected = this.expectedSize;\n      err.sri = this.sri;\n      this.emit('error', err);\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = this.digests;\n      err.algorithm = this.algorithm;\n      err.sri = this.sri;\n      this.emit('error', err);\n    } else {\n      this.emit('size', this.size);\n      this.emit('integrity', newSri);\n      match && this.emit('verified', match);\n    }\n  }\n\n}\n\nclass Hash {\n  get isHash() {\n    return true;\n  }\n\n  constructor(hash, opts) {\n    opts = SsriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim(); // set default values so that we make V8 happy to\n    // always see a familiar object template.\n\n    this.digest = '';\n    this.algorithm = '';\n    this.options = []; // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?');\n    }\n  }\n\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!( // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) && // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      this.options.every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n\n    const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n    return `${this.algorithm}-${this.digest}${options}`;\n  }\n\n}\n\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n    let sep = opts.sep || ' ';\n\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n\n  concat(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  } // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n\n\n  merge(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = parse(integrity, opts);\n\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity');\n        }\n      } else {\n        this[algo] = other[algo];\n      }\n    }\n  }\n\n  match(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n\n  pickAlgorithm(opts) {\n    opts = SsriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);\n    }\n\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n\n}\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  opts = SsriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = SsriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts);\n  const optString = getOptString(opts.options);\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = getOptString(opts.options);\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = SsriOpts(opts);\n  const istream = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = SsriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = SsriOpts(opts);\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }));\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream(opts) {\n  return new IntegrityStream(SsriOpts(opts));\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = getOptString(opts.options);\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n\n          acc[algo].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/ssri/index.js"],"names":["crypto","require","figgyPudding","MiniPass","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","SsriOpts","algorithms","default","error","integrity","options","pickAlgorithm","getPrioritizedHash","sep","single","size","strict","getOptString","length","join","_onEnd","Symbol","_getOptions","IntegrityStream","constructor","opts","Array","from","Set","concat","algorithm","hashes","map","createHash","sri","parse","expectedSize","goodSri","Object","keys","digests","optString","emit","ev","data","write","forEach","h","update","newSri","i","digest","match","err","Error","code","found","expected","Hash","isHash","hash","source","trim","some","a","rawOpts","slice","split","hexDigest","Buffer","toString","toJSON","x","every","opt","Integrity","isIntegrity","replace","k","prototype","call","filter","other","stringify","merge","algo","find","otherhash","JSON","reduce","acc","module","exports","_parse","fullSri","string","push","obj","fromHex","fromData","fromStream","stream","istream","integrityStream","Promise","resolve","reject","pipe","on","s","checkData","assign","checkStream","checker","create","createIntegrity","chunk","enc","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"mappings":"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","sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst MiniPass = require('minipass')\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)*$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst SsriOpts = figgyPudding({\n  algorithms: { default: ['sha512'] },\n  error: { default: false },\n  integrity: {},\n  options: { default: [] },\n  pickAlgorithm: { default: () => getPrioritizedHash },\n  sep: { default: ' ' },\n  single: { default: false },\n  size: {},\n  strict: { default: false }\n})\n\nconst getOptString = options => !options || !options.length ? ''\n  : `?${options.join('?')}`\n\nconst _onEnd = Symbol('_onEnd')\nconst _getOptions = Symbol('_getOptions')\nclass IntegrityStream extends MiniPass {\n  constructor (opts) {\n    super()\n    this.size = 0\n    this.opts = opts\n\n    // may be overridden later, but set now for class consistency\n    this[_getOptions]()\n\n    // options used for calculating stream.  can't be changed.\n    this.algorithms = Array.from(\n      new Set(opts.algorithms.concat(this.algorithm ? [this.algorithm] : []))\n    )\n    this.hashes = this.algorithms.map(crypto.createHash)\n  }\n\n  [_getOptions] () {\n    const opts = this.opts\n    // For verification\n    this.sri = opts.integrity ? parse(opts.integrity, opts) : null\n    this.expectedSize = opts.size\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(opts) : null\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null\n    this.optString = getOptString(opts.options)\n  }\n\n  emit (ev, data) {\n    if (ev === 'end') this[_onEnd]()\n    return super.emit(ev, data)\n  }\n\n  write (data) {\n    this.size += data.length\n    this.hashes.forEach(h => h.update(data))\n    return super.write(data)\n  }\n\n  [_onEnd] () {\n    if (!this.goodSri) {\n      this[_getOptions]()\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`\n    }).join(' '), this.opts)\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts)\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`)\n      err.code = 'EBADSIZE'\n      err.found = this.size\n      err.expected = this.expectedSize\n      err.sri = this.sri\n      this.emit('error', err)\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = this.digests\n      err.algorithm = this.algorithm\n      err.sri = this.sri\n      this.emit('error', err)\n    } else {\n      this.emit('size', this.size)\n      this.emit('integrity', newSri)\n      match && this.emit('verified', match)\n    }\n  }\n}\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = SsriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = ''\n    this.algorithm = ''\n    this.options = []\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n        ? STRICT_SRI_REGEX\n        : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?')\n    }\n  }\n\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  toString (opts) {\n    opts = SsriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n      ? `?${this.options.join('?')}`\n      : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n\n  toString (opts) {\n    opts = SsriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n\n  concat (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = typeof integrity === 'string'\n      ? integrity\n      : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n\n  hexDigest () {\n    return parse(this, { single: true }).hexDigest()\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = parse(integrity, opts)\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash =>\n          other[algo].find(otherhash =>\n            hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity')\n        }\n      } else {\n        this[algo] = other[algo]\n      }\n    }\n  }\n\n  match (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n\n  pickAlgorithm (opts) {\n    opts = SsriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = SsriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = SsriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts)\n  const optString = getOptString(opts.options)\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n      opts\n    )\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = SsriOpts(opts)\n  const istream = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = SsriOpts(opts)\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({ algorithm, digest })\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = SsriOpts(opts)\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }))\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  return new IntegrityStream(SsriOpts(opts))\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n    ? algo1\n    : algo2\n}\n"]},"metadata":{},"sourceType":"script"}