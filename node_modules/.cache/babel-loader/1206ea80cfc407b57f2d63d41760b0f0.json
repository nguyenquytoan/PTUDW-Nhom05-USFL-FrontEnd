{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar path = require('path'),\n    loaderUtils = require('loader-utils');\n/**\n * Create a value processing function for a given file path.\n *\n * @param {string} filename The current file being processed\n * @param {{absolute:string, keepQuery:boolean, join:function, root:string}} options Options hash\n * @return {function} value processing function\n */\n\n\nfunction valueProcessor(filename, options) {\n  var URL_STATEMENT_REGEX = /(url\\s*\\()\\s*(?:(['\"])((?:(?!\\2).)*)(\\2)|([^'\"](?:(?!\\)).)*[^'\"]))\\s*(\\))/g;\n  var directory = path.dirname(filename);\n  var join = options.join(filename, options);\n  /**\n   * Process the given CSS declaration value.\n   *\n   * @param {string} value A declaration value that may or may not contain a url() statement\n   * @param {string|Iterator.<string>} candidate An absolute path that may be the correct base or an Iterator thereof\n   */\n\n  return function transformValue(value, candidate) {\n    // allow multiple url() values in the declaration\n    //  split by url statements and process the content\n    //  additional capture groups are needed to match quotations correctly\n    //  escaped quotations are not considered\n    return value.split(URL_STATEMENT_REGEX).map(eachSplitOrGroup).join('');\n    /**\n     * Encode the content portion of <code>url()</code> statements.\n     * There are 4 capture groups in the split making every 5th unmatched.\n     *\n     * @param {string} token A single split item\n     * @param {number} i The index of the item in the split\n     * @param {Array} arr The array of split values\n     * @returns {string} Every 3 or 5 items is an encoded url everything else is as is\n     */\n\n    function eachSplitOrGroup(token, i, arr) {\n      // we can get groups as undefined under certain match circumstances\n      var initialised = token || ''; // the content of the url() statement is either in group 3 or group 5\n\n      var mod = i % 7;\n\n      if (mod === 3 || mod === 5) {\n        // detect quoted url and unescape backslashes\n        var before = arr[i - 1],\n            after = arr[i + 1],\n            isQuoted = before === after && (before === '\\'' || before === '\"'),\n            unescaped = isQuoted ? initialised.replace(/\\\\{2}/g, '\\\\') : initialised; // split into uri and query/hash and then find the absolute path to the uri\n\n        var split = unescaped.split(/([?#])/g),\n            uri = split[0],\n            absolute = testIsRelative(uri) && join(uri, candidate) || testIsAbsolute(uri) && join(uri),\n            query = options.keepQuery ? split.slice(1).join('') : ''; // use the absolute path in absolute mode or else relative path (or default to initialised)\n        // #6 - backslashes are not legal in URI\n\n        if (!absolute) {\n          return initialised;\n        } else if (options.absolute) {\n          return absolute.replace(/\\\\/g, '/') + query;\n        } else {\n          return loaderUtils.urlToRequest(path.relative(directory, absolute).replace(/\\\\/g, '/') + query);\n        }\n      } // everything else, including parentheses and quotation (where present) and media statements\n      else {\n          return initialised;\n        }\n    }\n  };\n  /**\n   * The loaderUtils.isUrlRequest() doesn't support windows absolute paths on principle. We do not subscribe to that\n   * dogma so we add path.isAbsolute() check to allow them.\n   *\n   * We also eliminate module relative (~) paths.\n   *\n   * @param {string|undefined} uri A uri string possibly empty or undefined\n   * @return {boolean} True for relative uri\n   */\n\n  function testIsRelative(uri) {\n    return !!uri && loaderUtils.isUrlRequest(uri, false) && !path.isAbsolute(uri) && uri.indexOf('~') !== 0;\n  }\n  /**\n   * The loaderUtils.isUrlRequest() doesn't support windows absolute paths on principle. We do not subscribe to that\n   * dogma so we add path.isAbsolute() check to allow them.\n   *\n   * @param {string|undefined} uri A uri string possibly empty or undefined\n   * @return {boolean} True for absolute uri\n   */\n\n\n  function testIsAbsolute(uri) {\n    return !!uri && typeof options.root === 'string' && loaderUtils.isUrlRequest(uri, options.root) && (/^\\//.test(uri) || path.isAbsolute(uri));\n  }\n}\n\nmodule.exports = valueProcessor;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/resolve-url-loader/lib/value-processor.js"],"names":["path","require","loaderUtils","valueProcessor","filename","options","URL_STATEMENT_REGEX","directory","dirname","join","transformValue","value","candidate","split","map","eachSplitOrGroup","token","i","arr","initialised","mod","before","after","isQuoted","unescaped","replace","uri","absolute","testIsRelative","testIsAbsolute","query","keepQuery","slice","urlToRequest","relative","isUrlRequest","isAbsolute","indexOf","root","test","module","exports"],"mappings":"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","sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar path        = require('path'),\n    loaderUtils = require('loader-utils');\n\n/**\n * Create a value processing function for a given file path.\n *\n * @param {string} filename The current file being processed\n * @param {{absolute:string, keepQuery:boolean, join:function, root:string}} options Options hash\n * @return {function} value processing function\n */\nfunction valueProcessor(filename, options) {\n  var URL_STATEMENT_REGEX = /(url\\s*\\()\\s*(?:(['\"])((?:(?!\\2).)*)(\\2)|([^'\"](?:(?!\\)).)*[^'\"]))\\s*(\\))/g;\n  var directory = path.dirname(filename);\n  var join      = options.join(filename, options);\n\n  /**\n   * Process the given CSS declaration value.\n   *\n   * @param {string} value A declaration value that may or may not contain a url() statement\n   * @param {string|Iterator.<string>} candidate An absolute path that may be the correct base or an Iterator thereof\n   */\n  return function transformValue(value, candidate) {\n\n    // allow multiple url() values in the declaration\n    //  split by url statements and process the content\n    //  additional capture groups are needed to match quotations correctly\n    //  escaped quotations are not considered\n    return value\n      .split(URL_STATEMENT_REGEX)\n      .map(eachSplitOrGroup)\n      .join('');\n\n    /**\n     * Encode the content portion of <code>url()</code> statements.\n     * There are 4 capture groups in the split making every 5th unmatched.\n     *\n     * @param {string} token A single split item\n     * @param {number} i The index of the item in the split\n     * @param {Array} arr The array of split values\n     * @returns {string} Every 3 or 5 items is an encoded url everything else is as is\n     */\n    function eachSplitOrGroup(token, i, arr) {\n\n      // we can get groups as undefined under certain match circumstances\n      var initialised = token || '';\n\n      // the content of the url() statement is either in group 3 or group 5\n      var mod = i % 7;\n      if ((mod === 3) || (mod === 5)) {\n\n        // detect quoted url and unescape backslashes\n        var before    = arr[i - 1],\n            after     = arr[i + 1],\n            isQuoted  = (before === after) && ((before === '\\'') || (before === '\"')),\n            unescaped = isQuoted ? initialised.replace(/\\\\{2}/g, '\\\\') : initialised;\n\n        // split into uri and query/hash and then find the absolute path to the uri\n        var split    = unescaped.split(/([?#])/g),\n            uri      = split[0],\n            absolute = testIsRelative(uri) && join(uri, candidate) || testIsAbsolute(uri) && join(uri),\n            query    = options.keepQuery ? split.slice(1).join('') : '';\n\n        // use the absolute path in absolute mode or else relative path (or default to initialised)\n        // #6 - backslashes are not legal in URI\n        if (!absolute) {\n          return initialised;\n        } else if (options.absolute) {\n          return absolute.replace(/\\\\/g, '/') + query;\n        } else {\n          return loaderUtils.urlToRequest(\n            path.relative(directory, absolute).replace(/\\\\/g, '/') + query\n          );\n        }\n      }\n      // everything else, including parentheses and quotation (where present) and media statements\n      else {\n        return initialised;\n      }\n    }\n  };\n\n  /**\n   * The loaderUtils.isUrlRequest() doesn't support windows absolute paths on principle. We do not subscribe to that\n   * dogma so we add path.isAbsolute() check to allow them.\n   *\n   * We also eliminate module relative (~) paths.\n   *\n   * @param {string|undefined} uri A uri string possibly empty or undefined\n   * @return {boolean} True for relative uri\n   */\n  function testIsRelative(uri) {\n    return !!uri && loaderUtils.isUrlRequest(uri, false) && !path.isAbsolute(uri) && (uri.indexOf('~') !== 0);\n  }\n\n  /**\n   * The loaderUtils.isUrlRequest() doesn't support windows absolute paths on principle. We do not subscribe to that\n   * dogma so we add path.isAbsolute() check to allow them.\n   *\n   * @param {string|undefined} uri A uri string possibly empty or undefined\n   * @return {boolean} True for absolute uri\n   */\n  function testIsAbsolute(uri) {\n    return !!uri && (typeof options.root === 'string') && loaderUtils.isUrlRequest(uri, options.root) &&\n      (/^\\//.test(uri) || path.isAbsolute(uri));\n  }\n}\n\nmodule.exports = valueProcessor;\n"]},"metadata":{},"sourceType":"script"}