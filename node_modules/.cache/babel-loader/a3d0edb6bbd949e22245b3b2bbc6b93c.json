{"ast":null,"code":"/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style for operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-linebreak\"\n    },\n    schema: [{\n      enum: [\"after\", \"before\", \"none\", null]\n    }, {\n      type: \"object\",\n      properties: {\n        overrides: {\n          type: \"object\",\n          properties: {\n            anyOf: {\n              type: \"string\",\n              enum: [\"after\", \"before\", \"none\", \"ignore\"]\n            }\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const usedDefaultGlobal = !context.options[0];\n    const globalStyle = context.options[0] || \"after\";\n    const options = context.options[1] || {};\n    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n    if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n      styleOverrides[\"?\"] = \"before\";\n    }\n\n    if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n      styleOverrides[\":\"] = \"before\";\n    }\n\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets a fixer function to fix rule issues\n     * @param {Token} operatorToken The operator token of an expression\n     * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n     * @returns {Function} A fixer function\n     */\n\n    function getFixer(operatorToken, desiredStyle) {\n      return fixer => {\n        const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n        const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n        let newTextBefore, newTextAfter;\n\n        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n          // If there is a comment before and after the operator, don't do a fix.\n          if (sourceCode.getTokenBefore(operatorToken, {\n            includeComments: true\n          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {\n            includeComments: true\n          }) !== tokenAfter) {\n            return null;\n          }\n          /*\n           * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n           * foo &&\n           *           bar\n           * would get fixed to\n           * foo\n           *        && bar\n           */\n\n\n          newTextBefore = textAfter;\n          newTextAfter = textBefore;\n        } else {\n          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher(); // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n\n          newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n          newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\"); // If there was no change (due to interfering comments), don't output a fix.\n\n          if (newTextBefore === textBefore && newTextAfter === textAfter) {\n            return null;\n          }\n        }\n\n        if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n          // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n          newTextAfter += \" \";\n        }\n\n        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n      };\n    }\n    /**\n     * Checks the operator placement\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode} leftSide The node that comes before the operator in `node`\n     * @private\n     * @returns {void}\n     */\n\n\n    function validateNode(node, leftSide) {\n      /*\n       * When the left part of a binary expression is a single expression wrapped in\n       * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n       * and operatorToken will be the closing parenthesis.\n       * The leftToken should be the last closing parenthesis, and the operatorToken\n       * should be the token right after that.\n       */\n      const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n      const leftToken = sourceCode.getTokenBefore(operatorToken);\n      const rightToken = sourceCode.getTokenAfter(operatorToken);\n      const operator = operatorToken.value;\n      const operatorStyleOverride = styleOverrides[operator];\n      const style = operatorStyleOverride || globalStyle;\n      const fix = getFixer(operatorToken, style); // if single line\n\n      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {// do nothing.\n      } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        // lone operator\n        context.report({\n          node,\n          loc: {\n            line: operatorToken.loc.end.line,\n            column: operatorToken.loc.end.column\n          },\n          message: \"Bad line breaking before and after '{{operator}}'.\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n        context.report({\n          node,\n          loc: {\n            line: operatorToken.loc.end.line,\n            column: operatorToken.loc.end.column\n          },\n          message: \"'{{operator}}' should be placed at the beginning of the line.\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        context.report({\n          node,\n          loc: {\n            line: operatorToken.loc.end.line,\n            column: operatorToken.loc.end.column\n          },\n          message: \"'{{operator}}' should be placed at the end of the line.\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"none\") {\n        context.report({\n          node,\n          loc: {\n            line: operatorToken.loc.end.line,\n            column: operatorToken.loc.end.column\n          },\n          message: \"There should be no line break before or after '{{operator}}'.\",\n          data: {\n            operator\n          },\n          fix\n        });\n      }\n    }\n    /**\n     * Validates a binary expression using `validateNode`\n     * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n     * @returns {void}\n     */\n\n\n    function validateBinaryExpression(node) {\n      validateNode(node, node.left);\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BinaryExpression: validateBinaryExpression,\n      LogicalExpression: validateBinaryExpression,\n      AssignmentExpression: validateBinaryExpression,\n\n      VariableDeclarator(node) {\n        if (node.init) {\n          validateNode(node, node.id);\n        }\n      },\n\n      ConditionalExpression(node) {\n        validateNode(node, node.test);\n        validateNode(node, node.consequent);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/operator-linebreak.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","properties","overrides","anyOf","additionalProperties","fixable","create","context","usedDefaultGlobal","options","globalStyle","styleOverrides","Object","assign","sourceCode","getSourceCode","getFixer","operatorToken","desiredStyle","fixer","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","textBefore","text","slice","range","textAfter","hasLinebreakBefore","isTokenOnSameLine","hasLinebreakAfter","newTextBefore","newTextAfter","includeComments","LINEBREAK_REGEX","createGlobalLinebreakMatcher","trim","replace","includes","value","replaceTextRange","validateNode","node","leftSide","isNotClosingParenToken","leftToken","rightToken","operator","operatorStyleOverride","style","fix","report","loc","line","end","column","message","data","validateBinaryExpression","left","BinaryExpression","LogicalExpression","AssignmentExpression","VariableDeclarator","init","id","ConditionalExpression","test","consequent"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-linebreak\"\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        properties: {\n                            anyOf: {\n                                type: \"string\",\n                                enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                            }\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a fixer function to fix rule issues\n         * @param {Token} operatorToken The operator token of an expression\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n         * @returns {Function} A fixer function\n         */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n\n            /*\n             * When the left part of a binary expression is a single expression wrapped in\n             * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n             * and operatorToken will be the closing parenthesis.\n             * The leftToken should be the last closing parenthesis, and the operatorToken\n             * should be the token right after that.\n             */\n            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operator = operatorToken.value;\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"Bad line breaking before and after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the beginning of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the end of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"There should be no line break before or after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}