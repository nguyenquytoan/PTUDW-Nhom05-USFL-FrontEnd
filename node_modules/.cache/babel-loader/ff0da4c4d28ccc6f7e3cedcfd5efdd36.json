{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"./util\");\n\nconst ts = require(\"typescript\");\n\nvar DeclarationDomain;\n\n(function (DeclarationDomain) {\n  DeclarationDomain[DeclarationDomain[\"Namespace\"] = 1] = \"Namespace\";\n  DeclarationDomain[DeclarationDomain[\"Type\"] = 2] = \"Type\";\n  DeclarationDomain[DeclarationDomain[\"Value\"] = 4] = \"Value\";\n  DeclarationDomain[DeclarationDomain[\"Import\"] = 8] = \"Import\";\n  DeclarationDomain[DeclarationDomain[\"Any\"] = 7] = \"Any\";\n})(DeclarationDomain = exports.DeclarationDomain || (exports.DeclarationDomain = {}));\n\nvar UsageDomain;\n\n(function (UsageDomain) {\n  UsageDomain[UsageDomain[\"Namespace\"] = 1] = \"Namespace\";\n  UsageDomain[UsageDomain[\"Type\"] = 2] = \"Type\";\n  UsageDomain[UsageDomain[\"Value\"] = 4] = \"Value\";\n  UsageDomain[UsageDomain[\"ValueOrNamespace\"] = 5] = \"ValueOrNamespace\";\n  UsageDomain[UsageDomain[\"Any\"] = 7] = \"Any\";\n  UsageDomain[UsageDomain[\"TypeQuery\"] = 8] = \"TypeQuery\";\n})(UsageDomain = exports.UsageDomain || (exports.UsageDomain = {}));\n\nfunction getUsageDomain(node) {\n  const parent = node.parent;\n\n  switch (parent.kind) {\n    case ts.SyntaxKind.TypeReference:\n      return node.originalKeywordKind !== ts.SyntaxKind.ConstKeyword ? 2 : undefined;\n\n    case ts.SyntaxKind.ExpressionWithTypeArguments:\n      return parent.parent.token === ts.SyntaxKind.ImplementsKeyword || parent.parent.parent.kind === ts.SyntaxKind.InterfaceDeclaration ? 2 : 4;\n\n    case ts.SyntaxKind.TypeQuery:\n      return 5 | 8;\n\n    case ts.SyntaxKind.QualifiedName:\n      if (parent.left === node) {\n        if (getEntityNameParent(parent).kind === ts.SyntaxKind.TypeQuery) return 1 | 8;\n        return 1;\n      }\n\n      break;\n\n    case ts.SyntaxKind.ExportSpecifier:\n      if (parent.propertyName === undefined || parent.propertyName === node) return 7;\n      break;\n\n    case ts.SyntaxKind.ExportAssignment:\n      return 7;\n\n    case ts.SyntaxKind.BindingElement:\n      if (parent.initializer === node) return 5;\n      break;\n\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.VariableDeclaration:\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.PropertyAccessExpression:\n    case ts.SyntaxKind.ImportEqualsDeclaration:\n      if (parent.name !== node) return 5;\n      break;\n\n    case ts.SyntaxKind.JsxAttribute:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.NamespaceImport:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ModuleDeclaration:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.LabeledStatement:\n    case ts.SyntaxKind.BreakStatement:\n    case ts.SyntaxKind.ContinueStatement:\n    case ts.SyntaxKind.ImportClause:\n    case ts.SyntaxKind.ImportSpecifier:\n    case ts.SyntaxKind.TypePredicate:\n    case ts.SyntaxKind.MethodSignature:\n    case ts.SyntaxKind.PropertySignature:\n    case ts.SyntaxKind.NamespaceExportDeclaration:\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n    case ts.SyntaxKind.TypeParameter:\n      break;\n\n    default:\n      return 5;\n  }\n}\n\nexports.getUsageDomain = getUsageDomain;\n\nfunction getDeclarationDomain(node) {\n  switch (node.parent.kind) {\n    case ts.SyntaxKind.TypeParameter:\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n      return 2;\n\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n      return 2 | 4;\n\n    case ts.SyntaxKind.EnumDeclaration:\n      return 7;\n\n    case ts.SyntaxKind.NamespaceImport:\n    case ts.SyntaxKind.ImportClause:\n      return 7 | 8;\n\n    case ts.SyntaxKind.ImportEqualsDeclaration:\n    case ts.SyntaxKind.ImportSpecifier:\n      return node.parent.name === node ? 7 | 8 : undefined;\n\n    case ts.SyntaxKind.ModuleDeclaration:\n      return 1;\n\n    case ts.SyntaxKind.Parameter:\n      if (node.parent.parent.kind === ts.SyntaxKind.IndexSignature || node.originalKeywordKind === ts.SyntaxKind.ThisKeyword) return;\n\n    case ts.SyntaxKind.BindingElement:\n    case ts.SyntaxKind.VariableDeclaration:\n      return node.parent.name === node ? 4 : undefined;\n\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.FunctionExpression:\n      return 4;\n  }\n}\n\nexports.getDeclarationDomain = getDeclarationDomain;\n\nfunction collectVariableUsage(sourceFile) {\n  return new UsageWalker().getUsage(sourceFile);\n}\n\nexports.collectVariableUsage = collectVariableUsage;\n\nclass AbstractScope {\n  constructor(_global) {\n    this._global = _global;\n    this._variables = new Map();\n    this._uses = [];\n    this._namespaceScopes = undefined;\n    this._enumScopes = undefined;\n  }\n\n  addVariable(identifier, name, selector, exported, domain) {\n    const variables = this.getDestinationScope(selector).getVariables();\n    const declaration = {\n      domain,\n      exported,\n      declaration: name\n    };\n    const variable = variables.get(identifier);\n\n    if (variable === undefined) {\n      variables.set(identifier, {\n        domain,\n        declarations: [declaration],\n        uses: []\n      });\n    } else {\n      variable.domain |= domain;\n      variable.declarations.push(declaration);\n    }\n  }\n\n  addUse(use) {\n    this._uses.push(use);\n  }\n\n  getVariables() {\n    return this._variables;\n  }\n\n  getFunctionScope() {\n    return this;\n  }\n\n  end(cb) {\n    if (this._namespaceScopes !== undefined) this._namespaceScopes.forEach(value => value.finish(cb));\n    this._namespaceScopes = this._enumScopes = undefined;\n\n    this._applyUses();\n\n    this._variables.forEach(variable => {\n      for (const declaration of variable.declarations) {\n        const result = {\n          declarations: [],\n          domain: declaration.domain,\n          exported: declaration.exported,\n          inGlobalScope: this._global,\n          uses: []\n        };\n\n        for (const other of variable.declarations) if (other.domain & declaration.domain) result.declarations.push(other.declaration);\n\n        for (const use of variable.uses) if (use.domain & declaration.domain) result.uses.push(use);\n\n        cb(result, declaration.declaration, this);\n      }\n    });\n  }\n\n  markExported(_name) {}\n\n  createOrReuseNamespaceScope(name, _exported, ambient, hasExportStatement) {\n    let scope;\n\n    if (this._namespaceScopes === undefined) {\n      this._namespaceScopes = new Map();\n    } else {\n      scope = this._namespaceScopes.get(name);\n    }\n\n    if (scope === undefined) {\n      scope = new NamespaceScope(ambient, hasExportStatement, this);\n\n      this._namespaceScopes.set(name, scope);\n    } else {\n      scope.refresh(ambient, hasExportStatement);\n    }\n\n    return scope;\n  }\n\n  createOrReuseEnumScope(name, _exported) {\n    let scope;\n\n    if (this._enumScopes === undefined) {\n      this._enumScopes = new Map();\n    } else {\n      scope = this._enumScopes.get(name);\n    }\n\n    if (scope === undefined) {\n      scope = new EnumScope(this);\n\n      this._enumScopes.set(name, scope);\n    }\n\n    return scope;\n  }\n\n  _applyUses() {\n    for (const use of this._uses) if (!this._applyUse(use)) this._addUseToParent(use);\n\n    this._uses = [];\n  }\n\n  _applyUse(use, variables = this._variables) {\n    const variable = variables.get(use.location.text);\n    if (variable === undefined || (variable.domain & use.domain) === 0) return false;\n    variable.uses.push(use);\n    return true;\n  }\n\n  _addUseToParent(_use) {}\n\n}\n\nclass RootScope extends AbstractScope {\n  constructor(_exportAll, global) {\n    super(global);\n    this._exportAll = _exportAll;\n    this._exports = undefined;\n    this._innerScope = new NonRootScope(this, 1);\n  }\n\n  addVariable(identifier, name, selector, exported, domain) {\n    if (domain & 8) return super.addVariable(identifier, name, selector, exported, domain);\n    return this._innerScope.addVariable(identifier, name, selector, exported, domain);\n  }\n\n  addUse(use, origin) {\n    if (origin === this._innerScope) return super.addUse(use);\n    return this._innerScope.addUse(use);\n  }\n\n  markExported(id) {\n    if (this._exports === undefined) {\n      this._exports = [id.text];\n    } else {\n      this._exports.push(id.text);\n    }\n  }\n\n  end(cb) {\n    this._innerScope.end((value, key) => {\n      value.exported = value.exported || this._exportAll || this._exports !== undefined && this._exports.includes(key.text);\n      value.inGlobalScope = this._global;\n      return cb(value, key, this);\n    });\n\n    return super.end((value, key, scope) => {\n      value.exported = value.exported || scope === this && this._exports !== undefined && this._exports.includes(key.text);\n      return cb(value, key, scope);\n    });\n  }\n\n  getDestinationScope() {\n    return this;\n  }\n\n}\n\nclass NonRootScope extends AbstractScope {\n  constructor(_parent, _boundary) {\n    super(false);\n    this._parent = _parent;\n    this._boundary = _boundary;\n  }\n\n  _addUseToParent(use) {\n    return this._parent.addUse(use, this);\n  }\n\n  getDestinationScope(selector) {\n    return this._boundary & selector ? this : this._parent.getDestinationScope(selector);\n  }\n\n}\n\nclass EnumScope extends NonRootScope {\n  constructor(parent) {\n    super(parent, 1);\n  }\n\n  end() {\n    this._applyUses();\n  }\n\n}\n\nclass ConditionalTypeScope extends NonRootScope {\n  constructor(parent) {\n    super(parent, 8);\n    this._state = 0;\n  }\n\n  updateState(newState) {\n    this._state = newState;\n  }\n\n  addUse(use) {\n    if (this._state === 2) return void this._uses.push(use);\n    return this._parent.addUse(use, this);\n  }\n\n}\n\nclass FunctionScope extends NonRootScope {\n  constructor(parent) {\n    super(parent, 1);\n  }\n\n  beginBody() {\n    this._applyUses();\n  }\n\n}\n\nclass AbstractNamedExpressionScope extends NonRootScope {\n  constructor(_name, _domain, parent) {\n    super(parent, 1);\n    this._name = _name;\n    this._domain = _domain;\n  }\n\n  end(cb) {\n    this._innerScope.end(cb);\n\n    return cb({\n      declarations: [this._name],\n      domain: this._domain,\n      exported: false,\n      uses: this._uses,\n      inGlobalScope: false\n    }, this._name, this);\n  }\n\n  addUse(use, source) {\n    if (source !== this._innerScope) return this._innerScope.addUse(use);\n\n    if (use.domain & this._domain && use.location.text === this._name.text) {\n      this._uses.push(use);\n    } else {\n      return this._parent.addUse(use, this);\n    }\n  }\n\n  getFunctionScope() {\n    return this._innerScope;\n  }\n\n  getDestinationScope() {\n    return this._innerScope;\n  }\n\n}\n\nclass FunctionExpressionScope extends AbstractNamedExpressionScope {\n  constructor(name, parent) {\n    super(name, 4, parent);\n    this._innerScope = new FunctionScope(this);\n  }\n\n  beginBody() {\n    return this._innerScope.beginBody();\n  }\n\n}\n\nclass ClassExpressionScope extends AbstractNamedExpressionScope {\n  constructor(name, parent) {\n    super(name, 4 | 2, parent);\n    this._innerScope = new NonRootScope(this, 1);\n  }\n\n}\n\nclass BlockScope extends NonRootScope {\n  constructor(_functionScope, parent) {\n    super(parent, 2);\n    this._functionScope = _functionScope;\n  }\n\n  getFunctionScope() {\n    return this._functionScope;\n  }\n\n}\n\nfunction mapDeclaration(declaration) {\n  return {\n    declaration,\n    exported: true,\n    domain: getDeclarationDomain(declaration)\n  };\n}\n\nclass NamespaceScope extends NonRootScope {\n  constructor(_ambient, _hasExport, parent) {\n    super(parent, 1);\n    this._ambient = _ambient;\n    this._hasExport = _hasExport;\n    this._innerScope = new NonRootScope(this, 1);\n    this._exports = undefined;\n  }\n\n  finish(cb) {\n    return super.end(cb);\n  }\n\n  end(cb) {\n    this._innerScope.end((variable, key, scope) => {\n      if (scope !== this._innerScope || !variable.exported && (!this._ambient || this._exports !== undefined && !this._exports.has(key.text))) return cb(variable, key, scope);\n\n      const namespaceVar = this._variables.get(key.text);\n\n      if (namespaceVar === undefined) {\n        this._variables.set(key.text, {\n          declarations: variable.declarations.map(mapDeclaration),\n          domain: variable.domain,\n          uses: [...variable.uses]\n        });\n      } else {\n        outer: for (const declaration of variable.declarations) {\n          for (const existing of namespaceVar.declarations) if (existing.declaration === declaration) continue outer;\n\n          namespaceVar.declarations.push(mapDeclaration(declaration));\n        }\n\n        namespaceVar.domain |= variable.domain;\n\n        for (const use of variable.uses) {\n          if (namespaceVar.uses.includes(use)) continue;\n          namespaceVar.uses.push(use);\n        }\n      }\n    });\n\n    this._applyUses();\n\n    this._innerScope = new NonRootScope(this, 1);\n  }\n\n  createOrReuseNamespaceScope(name, exported, ambient, hasExportStatement) {\n    if (!exported && (!this._ambient || this._hasExport)) return this._innerScope.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);\n    return super.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);\n  }\n\n  createOrReuseEnumScope(name, exported) {\n    if (!exported && (!this._ambient || this._hasExport)) return this._innerScope.createOrReuseEnumScope(name, exported);\n    return super.createOrReuseEnumScope(name, exported);\n  }\n\n  addUse(use, source) {\n    if (source !== this._innerScope) return this._innerScope.addUse(use);\n\n    this._uses.push(use);\n  }\n\n  refresh(ambient, hasExport) {\n    this._ambient = ambient;\n    this._hasExport = hasExport;\n  }\n\n  markExported(name, _as) {\n    if (this._exports === undefined) this._exports = new Set();\n\n    this._exports.add(name.text);\n  }\n\n  getDestinationScope() {\n    return this._innerScope;\n  }\n\n}\n\nfunction getEntityNameParent(name) {\n  let parent = name.parent;\n\n  while (parent.kind === ts.SyntaxKind.QualifiedName) parent = parent.parent;\n\n  return parent;\n}\n\nclass UsageWalker {\n  constructor() {\n    this._result = new Map();\n  }\n\n  getUsage(sourceFile) {\n    const variableCallback = (variable, key) => {\n      this._result.set(key, variable);\n    };\n\n    const isModule = ts.isExternalModule(sourceFile);\n    this._scope = new RootScope(sourceFile.isDeclarationFile && isModule && !containsExportStatement(sourceFile), !isModule);\n\n    const cb = node => {\n      if (util_1.isBlockScopeBoundary(node)) return continueWithScope(node, new BlockScope(this._scope.getFunctionScope(), this._scope), handleBlockScope);\n\n      switch (node.kind) {\n        case ts.SyntaxKind.ClassExpression:\n          return continueWithScope(node, node.name !== undefined ? new ClassExpressionScope(node.name, this._scope) : new NonRootScope(this._scope, 1));\n\n        case ts.SyntaxKind.ClassDeclaration:\n          this._handleDeclaration(node, true, 4 | 2);\n\n          return continueWithScope(node, new NonRootScope(this._scope, 1));\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n          this._handleDeclaration(node, true, 2);\n\n          return continueWithScope(node, new NonRootScope(this._scope, 4));\n\n        case ts.SyntaxKind.EnumDeclaration:\n          this._handleDeclaration(node, true, 7);\n\n          return continueWithScope(node, this._scope.createOrReuseEnumScope(node.name.text, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)));\n\n        case ts.SyntaxKind.ModuleDeclaration:\n          return this._handleModule(node, continueWithScope);\n\n        case ts.SyntaxKind.MappedType:\n          return continueWithScope(node, new NonRootScope(this._scope, 4));\n\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n        case ts.SyntaxKind.MethodSignature:\n        case ts.SyntaxKind.CallSignature:\n        case ts.SyntaxKind.ConstructSignature:\n        case ts.SyntaxKind.ConstructorType:\n        case ts.SyntaxKind.FunctionType:\n          return this._handleFunctionLikeDeclaration(node, cb, variableCallback);\n\n        case ts.SyntaxKind.ConditionalType:\n          return this._handleConditionalType(node, cb, variableCallback);\n\n        case ts.SyntaxKind.VariableDeclarationList:\n          this._handleVariableDeclaration(node);\n\n          break;\n\n        case ts.SyntaxKind.Parameter:\n          if (node.parent.kind !== ts.SyntaxKind.IndexSignature && (node.name.kind !== ts.SyntaxKind.Identifier || node.name.originalKeywordKind !== ts.SyntaxKind.ThisKeyword)) this._handleBindingName(node.name, false, false);\n          break;\n\n        case ts.SyntaxKind.EnumMember:\n          this._scope.addVariable(util_1.getPropertyName(node.name), node.name, 1, true, 4);\n\n          break;\n\n        case ts.SyntaxKind.ImportClause:\n        case ts.SyntaxKind.ImportSpecifier:\n        case ts.SyntaxKind.NamespaceImport:\n        case ts.SyntaxKind.ImportEqualsDeclaration:\n          this._handleDeclaration(node, false, 7 | 8);\n\n          break;\n\n        case ts.SyntaxKind.TypeParameter:\n          this._scope.addVariable(node.name.text, node.name, node.parent.kind === ts.SyntaxKind.InferType ? 8 : 7, false, 2);\n\n          break;\n\n        case ts.SyntaxKind.ExportSpecifier:\n          if (node.propertyName !== undefined) return this._scope.markExported(node.propertyName, node.name);\n          return this._scope.markExported(node.name);\n\n        case ts.SyntaxKind.ExportAssignment:\n          if (node.expression.kind === ts.SyntaxKind.Identifier) return this._scope.markExported(node.expression);\n          break;\n\n        case ts.SyntaxKind.Identifier:\n          const domain = getUsageDomain(node);\n          if (domain !== undefined) this._scope.addUse({\n            domain,\n            location: node\n          });\n          return;\n      }\n\n      return ts.forEachChild(node, cb);\n    };\n\n    const continueWithScope = (node, scope, next = forEachChild) => {\n      const savedScope = this._scope;\n      this._scope = scope;\n      next(node);\n\n      this._scope.end(variableCallback);\n\n      this._scope = savedScope;\n    };\n\n    const handleBlockScope = node => {\n      if (node.kind === ts.SyntaxKind.CatchClause && node.variableDeclaration !== undefined) this._handleBindingName(node.variableDeclaration.name, true, false);\n      return ts.forEachChild(node, cb);\n    };\n\n    ts.forEachChild(sourceFile, cb);\n\n    this._scope.end(variableCallback);\n\n    return this._result;\n\n    function forEachChild(node) {\n      return ts.forEachChild(node, cb);\n    }\n  }\n\n  _handleConditionalType(node, cb, varCb) {\n    const savedScope = this._scope;\n    const scope = this._scope = new ConditionalTypeScope(savedScope);\n    cb(node.checkType);\n    scope.updateState(1);\n    cb(node.extendsType);\n    scope.updateState(2);\n    cb(node.trueType);\n    scope.updateState(3);\n    cb(node.falseType);\n    scope.end(varCb);\n    this._scope = savedScope;\n  }\n\n  _handleFunctionLikeDeclaration(node, cb, varCb) {\n    if (node.decorators !== undefined) node.decorators.forEach(cb);\n    const savedScope = this._scope;\n    if (node.kind === ts.SyntaxKind.FunctionDeclaration) this._handleDeclaration(node, false, 4);\n    const scope = this._scope = node.kind === ts.SyntaxKind.FunctionExpression && node.name !== undefined ? new FunctionExpressionScope(node.name, savedScope) : new FunctionScope(savedScope);\n    if (node.name !== undefined) cb(node.name);\n    if (node.typeParameters !== undefined) node.typeParameters.forEach(cb);\n    node.parameters.forEach(cb);\n    if (node.type !== undefined) cb(node.type);\n\n    if (node.body !== undefined) {\n      scope.beginBody();\n      cb(node.body);\n    }\n\n    scope.end(varCb);\n    this._scope = savedScope;\n  }\n\n  _handleModule(node, next) {\n    if (node.flags & ts.NodeFlags.GlobalAugmentation) return next(node, this._scope.createOrReuseNamespaceScope('-global', false, true, false));\n\n    if (node.name.kind === ts.SyntaxKind.Identifier) {\n      const exported = isNamespaceExported(node);\n\n      this._scope.addVariable(node.name.text, node.name, 1, exported, 1 | 4);\n\n      const ambient = util_1.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword);\n      return next(node, this._scope.createOrReuseNamespaceScope(node.name.text, exported, ambient, ambient && namespaceHasExportStatement(node)));\n    }\n\n    return next(node, this._scope.createOrReuseNamespaceScope(`\"${node.name.text}\"`, false, true, namespaceHasExportStatement(node)));\n  }\n\n  _handleDeclaration(node, blockScoped, domain) {\n    if (node.name !== undefined) this._scope.addVariable(node.name.text, node.name, blockScoped ? 3 : 1, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword), domain);\n  }\n\n  _handleBindingName(name, blockScoped, exported) {\n    if (name.kind === ts.SyntaxKind.Identifier) return this._scope.addVariable(name.text, name, blockScoped ? 3 : 1, exported, 4);\n    util_1.forEachDestructuringIdentifier(name, declaration => {\n      this._scope.addVariable(declaration.name.text, declaration.name, blockScoped ? 3 : 1, exported, 4);\n    });\n  }\n\n  _handleVariableDeclaration(declarationList) {\n    const blockScoped = util_1.isBlockScopedVariableDeclarationList(declarationList);\n    const exported = declarationList.parent.kind === ts.SyntaxKind.VariableStatement && util_1.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword);\n\n    for (const declaration of declarationList.declarations) this._handleBindingName(declaration.name, blockScoped, exported);\n  }\n\n}\n\nfunction isNamespaceExported(node) {\n  return node.parent.kind === ts.SyntaxKind.ModuleDeclaration || util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword);\n}\n\nfunction namespaceHasExportStatement(ns) {\n  if (ns.body === undefined || ns.body.kind !== ts.SyntaxKind.ModuleBlock) return false;\n  return containsExportStatement(ns.body);\n}\n\nfunction containsExportStatement(block) {\n  for (const statement of block.statements) if (statement.kind === ts.SyntaxKind.ExportDeclaration || statement.kind === ts.SyntaxKind.ExportAssignment) return true;\n\n  return false;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/tsutils/util/usage.js"],"names":["Object","defineProperty","exports","value","util_1","require","ts","DeclarationDomain","UsageDomain","getUsageDomain","node","parent","kind","SyntaxKind","TypeReference","originalKeywordKind","ConstKeyword","undefined","ExpressionWithTypeArguments","token","ImplementsKeyword","InterfaceDeclaration","TypeQuery","QualifiedName","left","getEntityNameParent","ExportSpecifier","propertyName","ExportAssignment","BindingElement","initializer","Parameter","EnumMember","PropertyDeclaration","VariableDeclaration","PropertyAssignment","PropertyAccessExpression","ImportEqualsDeclaration","name","JsxAttribute","FunctionDeclaration","FunctionExpression","NamespaceImport","ClassDeclaration","ClassExpression","ModuleDeclaration","MethodDeclaration","EnumDeclaration","GetAccessor","SetAccessor","LabeledStatement","BreakStatement","ContinueStatement","ImportClause","ImportSpecifier","TypePredicate","MethodSignature","PropertySignature","NamespaceExportDeclaration","TypeAliasDeclaration","TypeParameter","getDeclarationDomain","IndexSignature","ThisKeyword","collectVariableUsage","sourceFile","UsageWalker","getUsage","AbstractScope","constructor","_global","_variables","Map","_uses","_namespaceScopes","_enumScopes","addVariable","identifier","selector","exported","domain","variables","getDestinationScope","getVariables","declaration","variable","get","set","declarations","uses","push","addUse","use","getFunctionScope","end","cb","forEach","finish","_applyUses","result","inGlobalScope","other","markExported","_name","createOrReuseNamespaceScope","_exported","ambient","hasExportStatement","scope","NamespaceScope","refresh","createOrReuseEnumScope","EnumScope","_applyUse","_addUseToParent","location","text","_use","RootScope","_exportAll","global","_exports","_innerScope","NonRootScope","origin","id","key","includes","_parent","_boundary","ConditionalTypeScope","_state","updateState","newState","FunctionScope","beginBody","AbstractNamedExpressionScope","_domain","source","FunctionExpressionScope","ClassExpressionScope","BlockScope","_functionScope","mapDeclaration","_ambient","_hasExport","has","namespaceVar","map","outer","existing","hasExport","_as","Set","add","_result","variableCallback","isModule","isExternalModule","_scope","isDeclarationFile","containsExportStatement","isBlockScopeBoundary","continueWithScope","handleBlockScope","_handleDeclaration","hasModifier","modifiers","ExportKeyword","_handleModule","MappedType","ArrowFunction","Constructor","CallSignature","ConstructSignature","ConstructorType","FunctionType","_handleFunctionLikeDeclaration","ConditionalType","_handleConditionalType","VariableDeclarationList","_handleVariableDeclaration","Identifier","_handleBindingName","getPropertyName","InferType","expression","forEachChild","next","savedScope","CatchClause","variableDeclaration","varCb","checkType","extendsType","trueType","falseType","decorators","typeParameters","parameters","type","body","flags","NodeFlags","GlobalAugmentation","isNamespaceExported","DeclareKeyword","namespaceHasExportStatement","blockScoped","forEachDestructuringIdentifier","declarationList","isBlockScopedVariableDeclarationList","VariableStatement","ns","ModuleBlock","block","statement","statements","ExportDeclaration"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nconst ts = require(\"typescript\");\nvar DeclarationDomain;\n(function (DeclarationDomain) {\n    DeclarationDomain[DeclarationDomain[\"Namespace\"] = 1] = \"Namespace\";\n    DeclarationDomain[DeclarationDomain[\"Type\"] = 2] = \"Type\";\n    DeclarationDomain[DeclarationDomain[\"Value\"] = 4] = \"Value\";\n    DeclarationDomain[DeclarationDomain[\"Import\"] = 8] = \"Import\";\n    DeclarationDomain[DeclarationDomain[\"Any\"] = 7] = \"Any\";\n})(DeclarationDomain = exports.DeclarationDomain || (exports.DeclarationDomain = {}));\nvar UsageDomain;\n(function (UsageDomain) {\n    UsageDomain[UsageDomain[\"Namespace\"] = 1] = \"Namespace\";\n    UsageDomain[UsageDomain[\"Type\"] = 2] = \"Type\";\n    UsageDomain[UsageDomain[\"Value\"] = 4] = \"Value\";\n    UsageDomain[UsageDomain[\"ValueOrNamespace\"] = 5] = \"ValueOrNamespace\";\n    UsageDomain[UsageDomain[\"Any\"] = 7] = \"Any\";\n    UsageDomain[UsageDomain[\"TypeQuery\"] = 8] = \"TypeQuery\";\n})(UsageDomain = exports.UsageDomain || (exports.UsageDomain = {}));\nfunction getUsageDomain(node) {\n    const parent = node.parent;\n    switch (parent.kind) {\n        case ts.SyntaxKind.TypeReference:\n            return node.originalKeywordKind !== ts.SyntaxKind.ConstKeyword ? 2 : undefined;\n        case ts.SyntaxKind.ExpressionWithTypeArguments:\n            return parent.parent.token === ts.SyntaxKind.ImplementsKeyword ||\n                parent.parent.parent.kind === ts.SyntaxKind.InterfaceDeclaration\n                ? 2\n                : 4;\n        case ts.SyntaxKind.TypeQuery:\n            return 5 | 8;\n        case ts.SyntaxKind.QualifiedName:\n            if (parent.left === node) {\n                if (getEntityNameParent(parent).kind === ts.SyntaxKind.TypeQuery)\n                    return 1 | 8;\n                return 1;\n            }\n            break;\n        case ts.SyntaxKind.ExportSpecifier:\n            if (parent.propertyName === undefined ||\n                parent.propertyName === node)\n                return 7;\n            break;\n        case ts.SyntaxKind.ExportAssignment:\n            return 7;\n        case ts.SyntaxKind.BindingElement:\n            if (parent.initializer === node)\n                return 5;\n            break;\n        case ts.SyntaxKind.Parameter:\n        case ts.SyntaxKind.EnumMember:\n        case ts.SyntaxKind.PropertyDeclaration:\n        case ts.SyntaxKind.VariableDeclaration:\n        case ts.SyntaxKind.PropertyAssignment:\n        case ts.SyntaxKind.PropertyAccessExpression:\n        case ts.SyntaxKind.ImportEqualsDeclaration:\n            if (parent.name !== node)\n                return 5;\n            break;\n        case ts.SyntaxKind.JsxAttribute:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.NamespaceImport:\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.ClassExpression:\n        case ts.SyntaxKind.ModuleDeclaration:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.EnumDeclaration:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n        case ts.SyntaxKind.LabeledStatement:\n        case ts.SyntaxKind.BreakStatement:\n        case ts.SyntaxKind.ContinueStatement:\n        case ts.SyntaxKind.ImportClause:\n        case ts.SyntaxKind.ImportSpecifier:\n        case ts.SyntaxKind.TypePredicate:\n        case ts.SyntaxKind.MethodSignature:\n        case ts.SyntaxKind.PropertySignature:\n        case ts.SyntaxKind.NamespaceExportDeclaration:\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n        case ts.SyntaxKind.TypeParameter:\n            break;\n        default:\n            return 5;\n    }\n}\nexports.getUsageDomain = getUsageDomain;\nfunction getDeclarationDomain(node) {\n    switch (node.parent.kind) {\n        case ts.SyntaxKind.TypeParameter:\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n            return 2;\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.ClassExpression:\n            return 2 | 4;\n        case ts.SyntaxKind.EnumDeclaration:\n            return 7;\n        case ts.SyntaxKind.NamespaceImport:\n        case ts.SyntaxKind.ImportClause:\n            return 7 | 8;\n        case ts.SyntaxKind.ImportEqualsDeclaration:\n        case ts.SyntaxKind.ImportSpecifier:\n            return node.parent.name === node\n                ? 7 | 8\n                : undefined;\n        case ts.SyntaxKind.ModuleDeclaration:\n            return 1;\n        case ts.SyntaxKind.Parameter:\n            if (node.parent.parent.kind === ts.SyntaxKind.IndexSignature || node.originalKeywordKind === ts.SyntaxKind.ThisKeyword)\n                return;\n        case ts.SyntaxKind.BindingElement:\n        case ts.SyntaxKind.VariableDeclaration:\n            return node.parent.name === node ? 4 : undefined;\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.FunctionExpression:\n            return 4;\n    }\n}\nexports.getDeclarationDomain = getDeclarationDomain;\nfunction collectVariableUsage(sourceFile) {\n    return new UsageWalker().getUsage(sourceFile);\n}\nexports.collectVariableUsage = collectVariableUsage;\nclass AbstractScope {\n    constructor(_global) {\n        this._global = _global;\n        this._variables = new Map();\n        this._uses = [];\n        this._namespaceScopes = undefined;\n        this._enumScopes = undefined;\n    }\n    addVariable(identifier, name, selector, exported, domain) {\n        const variables = this.getDestinationScope(selector).getVariables();\n        const declaration = {\n            domain,\n            exported,\n            declaration: name,\n        };\n        const variable = variables.get(identifier);\n        if (variable === undefined) {\n            variables.set(identifier, {\n                domain,\n                declarations: [declaration],\n                uses: [],\n            });\n        }\n        else {\n            variable.domain |= domain;\n            variable.declarations.push(declaration);\n        }\n    }\n    addUse(use) {\n        this._uses.push(use);\n    }\n    getVariables() {\n        return this._variables;\n    }\n    getFunctionScope() {\n        return this;\n    }\n    end(cb) {\n        if (this._namespaceScopes !== undefined)\n            this._namespaceScopes.forEach((value) => value.finish(cb));\n        this._namespaceScopes = this._enumScopes = undefined;\n        this._applyUses();\n        this._variables.forEach((variable) => {\n            for (const declaration of variable.declarations) {\n                const result = {\n                    declarations: [],\n                    domain: declaration.domain,\n                    exported: declaration.exported,\n                    inGlobalScope: this._global,\n                    uses: [],\n                };\n                for (const other of variable.declarations)\n                    if (other.domain & declaration.domain)\n                        result.declarations.push(other.declaration);\n                for (const use of variable.uses)\n                    if (use.domain & declaration.domain)\n                        result.uses.push(use);\n                cb(result, declaration.declaration, this);\n            }\n        });\n    }\n    markExported(_name) { }\n    createOrReuseNamespaceScope(name, _exported, ambient, hasExportStatement) {\n        let scope;\n        if (this._namespaceScopes === undefined) {\n            this._namespaceScopes = new Map();\n        }\n        else {\n            scope = this._namespaceScopes.get(name);\n        }\n        if (scope === undefined) {\n            scope = new NamespaceScope(ambient, hasExportStatement, this);\n            this._namespaceScopes.set(name, scope);\n        }\n        else {\n            scope.refresh(ambient, hasExportStatement);\n        }\n        return scope;\n    }\n    createOrReuseEnumScope(name, _exported) {\n        let scope;\n        if (this._enumScopes === undefined) {\n            this._enumScopes = new Map();\n        }\n        else {\n            scope = this._enumScopes.get(name);\n        }\n        if (scope === undefined) {\n            scope = new EnumScope(this);\n            this._enumScopes.set(name, scope);\n        }\n        return scope;\n    }\n    _applyUses() {\n        for (const use of this._uses)\n            if (!this._applyUse(use))\n                this._addUseToParent(use);\n        this._uses = [];\n    }\n    _applyUse(use, variables = this._variables) {\n        const variable = variables.get(use.location.text);\n        if (variable === undefined || (variable.domain & use.domain) === 0)\n            return false;\n        variable.uses.push(use);\n        return true;\n    }\n    _addUseToParent(_use) { }\n}\nclass RootScope extends AbstractScope {\n    constructor(_exportAll, global) {\n        super(global);\n        this._exportAll = _exportAll;\n        this._exports = undefined;\n        this._innerScope = new NonRootScope(this, 1);\n    }\n    addVariable(identifier, name, selector, exported, domain) {\n        if (domain & 8)\n            return super.addVariable(identifier, name, selector, exported, domain);\n        return this._innerScope.addVariable(identifier, name, selector, exported, domain);\n    }\n    addUse(use, origin) {\n        if (origin === this._innerScope)\n            return super.addUse(use);\n        return this._innerScope.addUse(use);\n    }\n    markExported(id) {\n        if (this._exports === undefined) {\n            this._exports = [id.text];\n        }\n        else {\n            this._exports.push(id.text);\n        }\n    }\n    end(cb) {\n        this._innerScope.end((value, key) => {\n            value.exported = value.exported || this._exportAll\n                || this._exports !== undefined && this._exports.includes(key.text);\n            value.inGlobalScope = this._global;\n            return cb(value, key, this);\n        });\n        return super.end((value, key, scope) => {\n            value.exported = value.exported || scope === this\n                && this._exports !== undefined && this._exports.includes(key.text);\n            return cb(value, key, scope);\n        });\n    }\n    getDestinationScope() {\n        return this;\n    }\n}\nclass NonRootScope extends AbstractScope {\n    constructor(_parent, _boundary) {\n        super(false);\n        this._parent = _parent;\n        this._boundary = _boundary;\n    }\n    _addUseToParent(use) {\n        return this._parent.addUse(use, this);\n    }\n    getDestinationScope(selector) {\n        return this._boundary & selector\n            ? this\n            : this._parent.getDestinationScope(selector);\n    }\n}\nclass EnumScope extends NonRootScope {\n    constructor(parent) {\n        super(parent, 1);\n    }\n    end() {\n        this._applyUses();\n    }\n}\nclass ConditionalTypeScope extends NonRootScope {\n    constructor(parent) {\n        super(parent, 8);\n        this._state = 0;\n    }\n    updateState(newState) {\n        this._state = newState;\n    }\n    addUse(use) {\n        if (this._state === 2)\n            return void this._uses.push(use);\n        return this._parent.addUse(use, this);\n    }\n}\nclass FunctionScope extends NonRootScope {\n    constructor(parent) {\n        super(parent, 1);\n    }\n    beginBody() {\n        this._applyUses();\n    }\n}\nclass AbstractNamedExpressionScope extends NonRootScope {\n    constructor(_name, _domain, parent) {\n        super(parent, 1);\n        this._name = _name;\n        this._domain = _domain;\n    }\n    end(cb) {\n        this._innerScope.end(cb);\n        return cb({\n            declarations: [this._name],\n            domain: this._domain,\n            exported: false,\n            uses: this._uses,\n            inGlobalScope: false,\n        }, this._name, this);\n    }\n    addUse(use, source) {\n        if (source !== this._innerScope)\n            return this._innerScope.addUse(use);\n        if (use.domain & this._domain && use.location.text === this._name.text) {\n            this._uses.push(use);\n        }\n        else {\n            return this._parent.addUse(use, this);\n        }\n    }\n    getFunctionScope() {\n        return this._innerScope;\n    }\n    getDestinationScope() {\n        return this._innerScope;\n    }\n}\nclass FunctionExpressionScope extends AbstractNamedExpressionScope {\n    constructor(name, parent) {\n        super(name, 4, parent);\n        this._innerScope = new FunctionScope(this);\n    }\n    beginBody() {\n        return this._innerScope.beginBody();\n    }\n}\nclass ClassExpressionScope extends AbstractNamedExpressionScope {\n    constructor(name, parent) {\n        super(name, 4 | 2, parent);\n        this._innerScope = new NonRootScope(this, 1);\n    }\n}\nclass BlockScope extends NonRootScope {\n    constructor(_functionScope, parent) {\n        super(parent, 2);\n        this._functionScope = _functionScope;\n    }\n    getFunctionScope() {\n        return this._functionScope;\n    }\n}\nfunction mapDeclaration(declaration) {\n    return {\n        declaration,\n        exported: true,\n        domain: getDeclarationDomain(declaration),\n    };\n}\nclass NamespaceScope extends NonRootScope {\n    constructor(_ambient, _hasExport, parent) {\n        super(parent, 1);\n        this._ambient = _ambient;\n        this._hasExport = _hasExport;\n        this._innerScope = new NonRootScope(this, 1);\n        this._exports = undefined;\n    }\n    finish(cb) {\n        return super.end(cb);\n    }\n    end(cb) {\n        this._innerScope.end((variable, key, scope) => {\n            if (scope !== this._innerScope ||\n                !variable.exported && (!this._ambient || this._exports !== undefined && !this._exports.has(key.text)))\n                return cb(variable, key, scope);\n            const namespaceVar = this._variables.get(key.text);\n            if (namespaceVar === undefined) {\n                this._variables.set(key.text, {\n                    declarations: variable.declarations.map(mapDeclaration),\n                    domain: variable.domain,\n                    uses: [...variable.uses],\n                });\n            }\n            else {\n                outer: for (const declaration of variable.declarations) {\n                    for (const existing of namespaceVar.declarations)\n                        if (existing.declaration === declaration)\n                            continue outer;\n                    namespaceVar.declarations.push(mapDeclaration(declaration));\n                }\n                namespaceVar.domain |= variable.domain;\n                for (const use of variable.uses) {\n                    if (namespaceVar.uses.includes(use))\n                        continue;\n                    namespaceVar.uses.push(use);\n                }\n            }\n        });\n        this._applyUses();\n        this._innerScope = new NonRootScope(this, 1);\n    }\n    createOrReuseNamespaceScope(name, exported, ambient, hasExportStatement) {\n        if (!exported && (!this._ambient || this._hasExport))\n            return this._innerScope.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);\n        return super.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);\n    }\n    createOrReuseEnumScope(name, exported) {\n        if (!exported && (!this._ambient || this._hasExport))\n            return this._innerScope.createOrReuseEnumScope(name, exported);\n        return super.createOrReuseEnumScope(name, exported);\n    }\n    addUse(use, source) {\n        if (source !== this._innerScope)\n            return this._innerScope.addUse(use);\n        this._uses.push(use);\n    }\n    refresh(ambient, hasExport) {\n        this._ambient = ambient;\n        this._hasExport = hasExport;\n    }\n    markExported(name, _as) {\n        if (this._exports === undefined)\n            this._exports = new Set();\n        this._exports.add(name.text);\n    }\n    getDestinationScope() {\n        return this._innerScope;\n    }\n}\nfunction getEntityNameParent(name) {\n    let parent = name.parent;\n    while (parent.kind === ts.SyntaxKind.QualifiedName)\n        parent = parent.parent;\n    return parent;\n}\nclass UsageWalker {\n    constructor() {\n        this._result = new Map();\n    }\n    getUsage(sourceFile) {\n        const variableCallback = (variable, key) => {\n            this._result.set(key, variable);\n        };\n        const isModule = ts.isExternalModule(sourceFile);\n        this._scope = new RootScope(sourceFile.isDeclarationFile && isModule && !containsExportStatement(sourceFile), !isModule);\n        const cb = (node) => {\n            if (util_1.isBlockScopeBoundary(node))\n                return continueWithScope(node, new BlockScope(this._scope.getFunctionScope(), this._scope), handleBlockScope);\n            switch (node.kind) {\n                case ts.SyntaxKind.ClassExpression:\n                    return continueWithScope(node, node.name !== undefined\n                        ? new ClassExpressionScope(node.name, this._scope)\n                        : new NonRootScope(this._scope, 1));\n                case ts.SyntaxKind.ClassDeclaration:\n                    this._handleDeclaration(node, true, 4 | 2);\n                    return continueWithScope(node, new NonRootScope(this._scope, 1));\n                case ts.SyntaxKind.InterfaceDeclaration:\n                case ts.SyntaxKind.TypeAliasDeclaration:\n                    this._handleDeclaration(node, true, 2);\n                    return continueWithScope(node, new NonRootScope(this._scope, 4));\n                case ts.SyntaxKind.EnumDeclaration:\n                    this._handleDeclaration(node, true, 7);\n                    return continueWithScope(node, this._scope.createOrReuseEnumScope(node.name.text, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)));\n                case ts.SyntaxKind.ModuleDeclaration:\n                    return this._handleModule(node, continueWithScope);\n                case ts.SyntaxKind.MappedType:\n                    return continueWithScope(node, new NonRootScope(this._scope, 4));\n                case ts.SyntaxKind.FunctionExpression:\n                case ts.SyntaxKind.ArrowFunction:\n                case ts.SyntaxKind.Constructor:\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.FunctionDeclaration:\n                case ts.SyntaxKind.GetAccessor:\n                case ts.SyntaxKind.SetAccessor:\n                case ts.SyntaxKind.MethodSignature:\n                case ts.SyntaxKind.CallSignature:\n                case ts.SyntaxKind.ConstructSignature:\n                case ts.SyntaxKind.ConstructorType:\n                case ts.SyntaxKind.FunctionType:\n                    return this._handleFunctionLikeDeclaration(node, cb, variableCallback);\n                case ts.SyntaxKind.ConditionalType:\n                    return this._handleConditionalType(node, cb, variableCallback);\n                case ts.SyntaxKind.VariableDeclarationList:\n                    this._handleVariableDeclaration(node);\n                    break;\n                case ts.SyntaxKind.Parameter:\n                    if (node.parent.kind !== ts.SyntaxKind.IndexSignature &&\n                        (node.name.kind !== ts.SyntaxKind.Identifier ||\n                            node.name.originalKeywordKind !== ts.SyntaxKind.ThisKeyword))\n                        this._handleBindingName(node.name, false, false);\n                    break;\n                case ts.SyntaxKind.EnumMember:\n                    this._scope.addVariable(util_1.getPropertyName(node.name), node.name, 1, true, 4);\n                    break;\n                case ts.SyntaxKind.ImportClause:\n                case ts.SyntaxKind.ImportSpecifier:\n                case ts.SyntaxKind.NamespaceImport:\n                case ts.SyntaxKind.ImportEqualsDeclaration:\n                    this._handleDeclaration(node, false, 7 | 8);\n                    break;\n                case ts.SyntaxKind.TypeParameter:\n                    this._scope.addVariable(node.name.text, node.name, node.parent.kind === ts.SyntaxKind.InferType ? 8 : 7, false, 2);\n                    break;\n                case ts.SyntaxKind.ExportSpecifier:\n                    if (node.propertyName !== undefined)\n                        return this._scope.markExported(node.propertyName, node.name);\n                    return this._scope.markExported(node.name);\n                case ts.SyntaxKind.ExportAssignment:\n                    if (node.expression.kind === ts.SyntaxKind.Identifier)\n                        return this._scope.markExported(node.expression);\n                    break;\n                case ts.SyntaxKind.Identifier:\n                    const domain = getUsageDomain(node);\n                    if (domain !== undefined)\n                        this._scope.addUse({ domain, location: node });\n                    return;\n            }\n            return ts.forEachChild(node, cb);\n        };\n        const continueWithScope = (node, scope, next = forEachChild) => {\n            const savedScope = this._scope;\n            this._scope = scope;\n            next(node);\n            this._scope.end(variableCallback);\n            this._scope = savedScope;\n        };\n        const handleBlockScope = (node) => {\n            if (node.kind === ts.SyntaxKind.CatchClause && node.variableDeclaration !== undefined)\n                this._handleBindingName(node.variableDeclaration.name, true, false);\n            return ts.forEachChild(node, cb);\n        };\n        ts.forEachChild(sourceFile, cb);\n        this._scope.end(variableCallback);\n        return this._result;\n        function forEachChild(node) {\n            return ts.forEachChild(node, cb);\n        }\n    }\n    _handleConditionalType(node, cb, varCb) {\n        const savedScope = this._scope;\n        const scope = this._scope = new ConditionalTypeScope(savedScope);\n        cb(node.checkType);\n        scope.updateState(1);\n        cb(node.extendsType);\n        scope.updateState(2);\n        cb(node.trueType);\n        scope.updateState(3);\n        cb(node.falseType);\n        scope.end(varCb);\n        this._scope = savedScope;\n    }\n    _handleFunctionLikeDeclaration(node, cb, varCb) {\n        if (node.decorators !== undefined)\n            node.decorators.forEach(cb);\n        const savedScope = this._scope;\n        if (node.kind === ts.SyntaxKind.FunctionDeclaration)\n            this._handleDeclaration(node, false, 4);\n        const scope = this._scope = node.kind === ts.SyntaxKind.FunctionExpression && node.name !== undefined\n            ? new FunctionExpressionScope(node.name, savedScope)\n            : new FunctionScope(savedScope);\n        if (node.name !== undefined)\n            cb(node.name);\n        if (node.typeParameters !== undefined)\n            node.typeParameters.forEach(cb);\n        node.parameters.forEach(cb);\n        if (node.type !== undefined)\n            cb(node.type);\n        if (node.body !== undefined) {\n            scope.beginBody();\n            cb(node.body);\n        }\n        scope.end(varCb);\n        this._scope = savedScope;\n    }\n    _handleModule(node, next) {\n        if (node.flags & ts.NodeFlags.GlobalAugmentation)\n            return next(node, this._scope.createOrReuseNamespaceScope('-global', false, true, false));\n        if (node.name.kind === ts.SyntaxKind.Identifier) {\n            const exported = isNamespaceExported(node);\n            this._scope.addVariable(node.name.text, node.name, 1, exported, 1 | 4);\n            const ambient = util_1.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword);\n            return next(node, this._scope.createOrReuseNamespaceScope(node.name.text, exported, ambient, ambient && namespaceHasExportStatement(node)));\n        }\n        return next(node, this._scope.createOrReuseNamespaceScope(`\"${node.name.text}\"`, false, true, namespaceHasExportStatement(node)));\n    }\n    _handleDeclaration(node, blockScoped, domain) {\n        if (node.name !== undefined)\n            this._scope.addVariable(node.name.text, node.name, blockScoped ? 3 : 1, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword), domain);\n    }\n    _handleBindingName(name, blockScoped, exported) {\n        if (name.kind === ts.SyntaxKind.Identifier)\n            return this._scope.addVariable(name.text, name, blockScoped ? 3 : 1, exported, 4);\n        util_1.forEachDestructuringIdentifier(name, (declaration) => {\n            this._scope.addVariable(declaration.name.text, declaration.name, blockScoped ? 3 : 1, exported, 4);\n        });\n    }\n    _handleVariableDeclaration(declarationList) {\n        const blockScoped = util_1.isBlockScopedVariableDeclarationList(declarationList);\n        const exported = declarationList.parent.kind === ts.SyntaxKind.VariableStatement &&\n            util_1.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword);\n        for (const declaration of declarationList.declarations)\n            this._handleBindingName(declaration.name, blockScoped, exported);\n    }\n}\nfunction isNamespaceExported(node) {\n    return node.parent.kind === ts.SyntaxKind.ModuleDeclaration || util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword);\n}\nfunction namespaceHasExportStatement(ns) {\n    if (ns.body === undefined || ns.body.kind !== ts.SyntaxKind.ModuleBlock)\n        return false;\n    return containsExportStatement(ns.body);\n}\nfunction containsExportStatement(block) {\n    for (const statement of block.statements)\n        if (statement.kind === ts.SyntaxKind.ExportDeclaration || statement.kind === ts.SyntaxKind.ExportAssignment)\n            return true;\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}