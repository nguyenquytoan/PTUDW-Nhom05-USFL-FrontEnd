{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst resolveFrom = require('resolve-from');\n\nconst parentModule = require('parent-module');\n\nmodule.exports = moduleId => {\n  if (typeof moduleId !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  const parentPath = parentModule(__filename);\n  const filePath = resolveFrom(path.dirname(parentPath), moduleId);\n  const oldModule = require.cache[filePath]; // Delete itself from module parent\n\n  if (oldModule && oldModule.parent) {\n    let i = oldModule.parent.children.length;\n\n    while (i--) {\n      if (oldModule.parent.children[i].id === filePath) {\n        oldModule.parent.children.splice(i, 1);\n      }\n    }\n  }\n\n  delete require.cache[filePath]; // Delete module from cache\n\n  const parent = require.cache[parentPath]; // If `filePath` and `parentPath` are the same, cache will already be deleted so we won't get a memory leak in next step\n\n  return parent === undefined ? require(filePath) : parent.require(filePath); // In case cache doesn't have parent, fall back to normal require\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/babel-plugin-macros/node_modules/import-fresh/index.js"],"names":["path","require","resolveFrom","parentModule","module","exports","moduleId","TypeError","parentPath","__filename","filePath","dirname","oldModule","cache","parent","i","children","length","id","splice","undefined"],"mappings":"AAAA;;AACA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,eAAD,CAA5B;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,QAAQ,IAAI;AAC5B,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AACjC,UAAM,IAAIC,SAAJ,CAAc,mBAAd,CAAN;AACA;;AAED,QAAMC,UAAU,GAAGL,YAAY,CAACM,UAAD,CAA/B;AAEA,QAAMC,QAAQ,GAAGR,WAAW,CAACF,IAAI,CAACW,OAAL,CAAaH,UAAb,CAAD,EAA2BF,QAA3B,CAA5B;AAEA,QAAMM,SAAS,GAAGX,OAAO,CAACY,KAAR,CAAcH,QAAd,CAAlB,CAT4B,CAU5B;;AACA,MAAIE,SAAS,IAAIA,SAAS,CAACE,MAA3B,EAAmC;AAClC,QAAIC,CAAC,GAAGH,SAAS,CAACE,MAAV,CAAiBE,QAAjB,CAA0BC,MAAlC;;AAEA,WAAOF,CAAC,EAAR,EAAY;AACX,UAAIH,SAAS,CAACE,MAAV,CAAiBE,QAAjB,CAA0BD,CAA1B,EAA6BG,EAA7B,KAAoCR,QAAxC,EAAkD;AACjDE,QAAAA,SAAS,CAACE,MAAV,CAAiBE,QAAjB,CAA0BG,MAA1B,CAAiCJ,CAAjC,EAAoC,CAApC;AACA;AACD;AACD;;AAED,SAAOd,OAAO,CAACY,KAAR,CAAcH,QAAd,CAAP,CArB4B,CAqBI;;AAEhC,QAAMI,MAAM,GAAGb,OAAO,CAACY,KAAR,CAAcL,UAAd,CAAf,CAvB4B,CAuBc;;AAE1C,SAAOM,MAAM,KAAKM,SAAX,GAAuBnB,OAAO,CAACS,QAAD,CAA9B,GAA2CI,MAAM,CAACb,OAAP,CAAeS,QAAf,CAAlD,CAzB4B,CAyBgD;AAC5E,CA1BD","sourcesContent":["'use strict';\nconst path = require('path');\nconst resolveFrom = require('resolve-from');\nconst parentModule = require('parent-module');\n\nmodule.exports = moduleId => {\n\tif (typeof moduleId !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tconst parentPath = parentModule(__filename);\n\n\tconst filePath = resolveFrom(path.dirname(parentPath), moduleId);\n\n\tconst oldModule = require.cache[filePath];\n\t// Delete itself from module parent\n\tif (oldModule && oldModule.parent) {\n\t\tlet i = oldModule.parent.children.length;\n\n\t\twhile (i--) {\n\t\t\tif (oldModule.parent.children[i].id === filePath) {\n\t\t\t\toldModule.parent.children.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete require.cache[filePath]; // Delete module from cache\n\n\tconst parent = require.cache[parentPath]; // If `filePath` and `parentPath` are the same, cache will already be deleted so we won't get a memory leak in next step\n\n\treturn parent === undefined ? require(filePath) : parent.require(filePath); // In case cache doesn't have parent, fall back to normal require\n};\n"]},"metadata":{},"sourceType":"script"}