{"ast":null,"code":"/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the use of variables within the scope they are defined\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/block-scoped-var\"\n    },\n    schema: [],\n    messages: {\n      outOfScope: \"'{{name}}' used outside of binding context.\"\n    }\n  },\n\n  create(context) {\n    let stack = [];\n    /**\n     * Makes a block scope.\n     * @param {ASTNode} node A node of a scope.\n     * @returns {void}\n     */\n\n    function enterScope(node) {\n      stack.push(node.range);\n    }\n    /**\n     * Pops the last block scope.\n     * @returns {void}\n     */\n\n\n    function exitScope() {\n      stack.pop();\n    }\n    /**\n     * Reports a given reference.\n     * @param {eslint-scope.Reference} reference A reference to report.\n     * @returns {void}\n     */\n\n\n    function report(reference) {\n      const identifier = reference.identifier;\n      context.report({\n        node: identifier,\n        messageId: \"outOfScope\",\n        data: {\n          name: identifier.name\n        }\n      });\n    }\n    /**\n     * Finds and reports references which are outside of valid scopes.\n     * @param {ASTNode} node A node to get variables.\n     * @returns {void}\n     */\n\n\n    function checkForVariables(node) {\n      if (node.kind !== \"var\") {\n        return;\n      } // Defines a predicate to check whether or not a given reference is outside of valid scope.\n\n\n      const scopeRange = stack[stack.length - 1];\n      /**\n       * Check if a reference is out of scope\n       * @param {ASTNode} reference node to examine\n       * @returns {boolean} True is its outside the scope\n       * @private\n       */\n\n      function isOutsideOfScope(reference) {\n        const idRange = reference.identifier.range;\n        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n      } // Gets declared variables, and checks its references.\n\n\n      const variables = context.getDeclaredVariables(node);\n\n      for (let i = 0; i < variables.length; ++i) {\n        // Reports.\n        variables[i].references.filter(isOutsideOfScope).forEach(report);\n      }\n    }\n\n    return {\n      Program(node) {\n        stack = [node.range];\n      },\n\n      // Manages scopes.\n      BlockStatement: enterScope,\n      \"BlockStatement:exit\": exitScope,\n      ForStatement: enterScope,\n      \"ForStatement:exit\": exitScope,\n      ForInStatement: enterScope,\n      \"ForInStatement:exit\": exitScope,\n      ForOfStatement: enterScope,\n      \"ForOfStatement:exit\": exitScope,\n      SwitchStatement: enterScope,\n      \"SwitchStatement:exit\": exitScope,\n      CatchClause: enterScope,\n      \"CatchClause:exit\": exitScope,\n      // Finds and reports references which are outside of valid scope.\n      VariableDeclaration: checkForVariables\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/block-scoped-var.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","messages","outOfScope","create","context","stack","enterScope","node","push","range","exitScope","pop","report","reference","identifier","messageId","data","name","checkForVariables","kind","scopeRange","length","isOutsideOfScope","idRange","variables","getDeclaredVariables","i","references","filter","forEach","Program","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","CatchClause","VariableDeclaration"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,gEADX;AAEFC,MAAAA,QAAQ,EAAE,gBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,EAVN;AAYFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,UAAU,EAAE;AADN;AAZR,GADO;;AAkBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,QAAIC,KAAK,GAAG,EAAZ;AAEA;;;;;;AAKA,aAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtBF,MAAAA,KAAK,CAACG,IAAN,CAAWD,IAAI,CAACE,KAAhB;AACH;AAED;;;;;;AAIA,aAASC,SAAT,GAAqB;AACjBL,MAAAA,KAAK,CAACM,GAAN;AACH;AAED;;;;;;;AAKA,aAASC,MAAT,CAAgBC,SAAhB,EAA2B;AACvB,YAAMC,UAAU,GAAGD,SAAS,CAACC,UAA7B;AAEAV,MAAAA,OAAO,CAACQ,MAAR,CAAe;AAAEL,QAAAA,IAAI,EAAEO,UAAR;AAAoBC,QAAAA,SAAS,EAAE,YAA/B;AAA6CC,QAAAA,IAAI,EAAE;AAAEC,UAAAA,IAAI,EAAEH,UAAU,CAACG;AAAnB;AAAnD,OAAf;AACH;AAED;;;;;;;AAKA,aAASC,iBAAT,CAA2BX,IAA3B,EAAiC;AAC7B,UAAIA,IAAI,CAACY,IAAL,KAAc,KAAlB,EAAyB;AACrB;AACH,OAH4B,CAK7B;;;AACA,YAAMC,UAAU,GAAGf,KAAK,CAACA,KAAK,CAACgB,MAAN,GAAe,CAAhB,CAAxB;AAEA;;;;;;;AAMA,eAASC,gBAAT,CAA0BT,SAA1B,EAAqC;AACjC,cAAMU,OAAO,GAAGV,SAAS,CAACC,UAAV,CAAqBL,KAArC;AAEA,eAAOc,OAAO,CAAC,CAAD,CAAP,GAAaH,UAAU,CAAC,CAAD,CAAvB,IAA8BG,OAAO,CAAC,CAAD,CAAP,GAAaH,UAAU,CAAC,CAAD,CAA5D;AACH,OAlB4B,CAoB7B;;;AACA,YAAMI,SAAS,GAAGpB,OAAO,CAACqB,oBAAR,CAA6BlB,IAA7B,CAAlB;;AAEA,WAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACH,MAA9B,EAAsC,EAAEK,CAAxC,EAA2C;AAEvC;AACAF,QAAAA,SAAS,CAACE,CAAD,CAAT,CACKC,UADL,CAEKC,MAFL,CAEYN,gBAFZ,EAGKO,OAHL,CAGajB,MAHb;AAIH;AACJ;;AAED,WAAO;AACHkB,MAAAA,OAAO,CAACvB,IAAD,EAAO;AACVF,QAAAA,KAAK,GAAG,CAACE,IAAI,CAACE,KAAN,CAAR;AACH,OAHE;;AAKH;AACAsB,MAAAA,cAAc,EAAEzB,UANb;AAOH,6BAAuBI,SAPpB;AAQHsB,MAAAA,YAAY,EAAE1B,UARX;AASH,2BAAqBI,SATlB;AAUHuB,MAAAA,cAAc,EAAE3B,UAVb;AAWH,6BAAuBI,SAXpB;AAYHwB,MAAAA,cAAc,EAAE5B,UAZb;AAaH,6BAAuBI,SAbpB;AAcHyB,MAAAA,eAAe,EAAE7B,UAdd;AAeH,8BAAwBI,SAfrB;AAgBH0B,MAAAA,WAAW,EAAE9B,UAhBV;AAiBH,0BAAoBI,SAjBjB;AAmBH;AACA2B,MAAAA,mBAAmB,EAAEnB;AApBlB,KAAP;AAuBH;;AA9GY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/block-scoped-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            outOfScope: \"'{{name}}' used outside of binding context.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const identifier = reference.identifier;\n\n            context.report({ node: identifier, messageId: \"outOfScope\", data: { name: identifier.name } });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}