{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\");\n\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = require(\"./utils/unicode\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\n\n\nfunction* iterateCharacterSequence(nodes) {\n  let seq = [];\n\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node.value);\n        break;\n\n      case \"CharacterClassRange\":\n        seq.push(node.min.value);\n        yield seq;\n        seq = [node.max.value];\n        break;\n\n      case \"CharacterSet\":\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n\n        break;\n      // no default\n    }\n  }\n\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\n\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n  },\n\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));\n  },\n\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));\n  },\n\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));\n  },\n\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);\n  }\n\n};\nconst kinds = Object.keys(hasCharacterSequence); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow characters which are made with multiple code points in character class syntax\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n    },\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\"\n    }\n  },\n\n  create(context) {\n    const parser = new RegExpParser();\n    /**\n     * Verify a given regular expression.\n     * @param {Node} node The node to report.\n     * @param {string} pattern The regular expression pattern to verify.\n     * @param {string} flags The flags of the regular expression.\n     * @returns {void}\n     */\n\n    function verify(node, pattern, flags) {\n      const has = {\n        surrogatePairWithoutUFlag: false,\n        combiningClass: false,\n        variationSelector: false,\n        emojiModifier: false,\n        regionalIndicatorSymbol: false,\n        zwj: false\n      };\n      let patternNode;\n\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch (e) {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n            }\n          }\n        }\n\n      });\n\n      for (const kind of kinds) {\n        if (has[kind]) {\n          context.report({\n            node,\n            messageId: kind\n          });\n        }\n      }\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags);\n      },\n\n      \"Program\"() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        /*\n         * Iterate calls of RegExp.\n         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n         *       `const {RegExp: a} = window; new a()`, etc...\n         */\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = node.arguments;\n          const pattern = getStringIfConstant(patternNode, scope);\n          const flags = getStringIfConstant(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            verify(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-misleading-character-class.js"],"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpParser","visitRegExpAST","isCombiningCharacter","isEmojiModifier","isRegionalIndicatorSymbol","isSurrogatePair","iterateCharacterSequence","nodes","seq","node","type","push","value","min","max","length","hasCharacterSequence","surrogatePairWithoutUFlag","chars","some","c","i","combiningClass","emojiModifier","regionalIndicatorSymbol","zwj","lastIndex","kinds","Object","keys","module","exports","meta","docs","description","category","recommended","url","schema","messages","create","context","parser","verify","pattern","flags","has","variationSelector","patternNode","parsePattern","includes","e","onCharacterClassEnter","ccNode","elements","kind","report","messageId","regex","scope","getScope","tracker","iterateGlobalReferences","RegExp","flagsNode","arguments"],"mappings":"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","sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node.value);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min.value);\n                yield seq;\n                seq = [node.max.value];\n                break;\n\n            case \"CharacterSet\":\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c) &&\n            !isCombiningCharacter(chars[i - 1])\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c) &&\n            !isEmojiModifier(chars[i - 1])\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c) &&\n            isRegionalIndicatorSymbol(chars[i - 1])\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c === 0x200d &&\n            chars[i - 1] !== 0x200d &&\n            chars[i + 1] !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow characters which are made with multiple code points in character class syntax\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\"\n        }\n    },\n    create(context) {\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags) {\n            const has = {\n                surrogatePairWithoutUFlag: false,\n                combiningClass: false,\n                variationSelector: false,\n                emojiModifier: false,\n                regionalIndicatorSymbol: false,\n                zwj: false\n            };\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    flags.includes(\"u\")\n                );\n            } catch (e) {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n                        }\n                    }\n                }\n            });\n\n            for (const kind of kinds) {\n                if (has[kind]) {\n                    context.report({ node, messageId: kind });\n                }\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags);\n            },\n            \"Program\"() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = node.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}