{"ast":null,"code":"'use strict';\n\nconst Root = require('./root');\n\nconst Value = require('./value');\n\nconst AtWord = require('./atword');\n\nconst Colon = require('./colon');\n\nconst Comma = require('./comma');\n\nconst Comment = require('./comment');\n\nconst Func = require('./function');\n\nconst Numbr = require('./number');\n\nconst Operator = require('./operator');\n\nconst Paren = require('./paren');\n\nconst Str = require('./string');\n\nconst Word = require('./word');\n\nconst UnicodeRange = require('./unicode-range');\n\nconst tokenize = require('./tokenize');\n\nconst flatten = require('flatten');\n\nconst indexesOf = require('indexes-of');\n\nconst uniq = require('uniq');\n\nconst ParserError = require('./errors/ParserError');\n\nfunction sortAscending(list) {\n  return list.sort((a, b) => a - b);\n}\n\nmodule.exports = class Parser {\n  constructor(input, options) {\n    const defaults = {\n      loose: false\n    }; // cache needs to be an array for values with more than 1 level of function nesting\n\n    this.cache = [];\n    this.input = input;\n    this.options = Object.assign({}, defaults, options);\n    this.position = 0; // we'll use this to keep track of the paren balance\n\n    this.unbalanced = 0;\n    this.root = new Root();\n    let value = new Value();\n    this.root.append(value);\n    this.current = value;\n    this.tokens = tokenize(input, this.options);\n  }\n\n  parse() {\n    return this.loop();\n  }\n\n  colon() {\n    let token = this.currToken;\n    this.newNode(new Colon({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n    this.position++;\n  }\n\n  comma() {\n    let token = this.currToken;\n    this.newNode(new Comma({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n    this.position++;\n  }\n\n  comment() {\n    let inline = false,\n        value = this.currToken[1].replace(/\\/\\*|\\*\\//g, ''),\n        node;\n\n    if (this.options.loose && value.startsWith(\"//\")) {\n      value = value.substring(2);\n      inline = true;\n    }\n\n    node = new Comment({\n      value: value,\n      inline: inline,\n      source: {\n        start: {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        },\n        end: {\n          line: this.currToken[4],\n          column: this.currToken[5]\n        }\n      },\n      sourceIndex: this.currToken[6]\n    });\n    this.newNode(node);\n    this.position++;\n  }\n\n  error(message, token) {\n    throw new ParserError(message + ` at line: ${token[2]}, column ${token[3]}`);\n  }\n\n  loop() {\n    while (this.position < this.tokens.length) {\n      this.parseTokens();\n    }\n\n    if (!this.current.last && this.spaces) {\n      this.current.raws.before += this.spaces;\n    } else if (this.spaces) {\n      this.current.last.raws.after += this.spaces;\n    }\n\n    this.spaces = '';\n    return this.root;\n  }\n\n  operator() {\n    // if a +|- operator is followed by a non-word character (. is allowed) and\n    // is preceded by a non-word character. (5+5)\n    let char = this.currToken[1],\n        node;\n\n    if (char === '+' || char === '-') {\n      // only inspect if the operator is not the first token, and we're only\n      // within a calc() function: the only spec-valid place for math expressions\n      if (!this.options.loose) {\n        if (this.position > 0) {\n          if (this.current.type === 'func' && this.current.value === 'calc') {\n            // allow operators to be proceeded by spaces and opening parens\n            if (this.prevToken[0] !== 'space' && this.prevToken[0] !== '(') {\n              this.error('Syntax Error', this.currToken);\n            } // valid: calc(1 - +2)\n            // invalid: calc(1 -+2)\n            else if (this.nextToken[0] !== 'space' && this.nextToken[0] !== 'word') {\n                this.error('Syntax Error', this.currToken);\n              } // valid: calc(1 - +2)\n              // valid: calc(-0.5 + 2)\n              // invalid: calc(1 -2)\n              else if (this.nextToken[0] === 'word' && this.current.last.type !== 'operator' && this.current.last.value !== '(') {\n                  this.error('Syntax Error', this.currToken);\n                }\n          } // if we're not in a function and someone has doubled up on operators,\n          // or they're trying to perform a calc outside of a calc\n          // eg. +-4px or 5+ 5, throw an error\n          else if (this.nextToken[0] === 'space' || this.nextToken[0] === 'operator' || this.prevToken[0] === 'operator') {\n              this.error('Syntax Error', this.currToken);\n            }\n        }\n      }\n\n      if (!this.options.loose) {\n        if (this.nextToken[0] === 'word') {\n          return this.word();\n        }\n      } else {\n        if ((!this.current.nodes.length || this.current.last && this.current.last.type === 'operator') && this.nextToken[0] === 'word') {\n          return this.word();\n        }\n      }\n    }\n\n    node = new Operator({\n      value: this.currToken[1],\n      source: {\n        start: {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        },\n        end: {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        }\n      },\n      sourceIndex: this.currToken[4]\n    });\n    this.position++;\n    return this.newNode(node);\n  }\n\n  parseTokens() {\n    switch (this.currToken[0]) {\n      case 'space':\n        this.space();\n        break;\n\n      case 'colon':\n        this.colon();\n        break;\n\n      case 'comma':\n        this.comma();\n        break;\n\n      case 'comment':\n        this.comment();\n        break;\n\n      case '(':\n        this.parenOpen();\n        break;\n\n      case ')':\n        this.parenClose();\n        break;\n\n      case 'atword':\n      case 'word':\n        this.word();\n        break;\n\n      case 'operator':\n        this.operator();\n        break;\n\n      case 'string':\n        this.string();\n        break;\n\n      case 'unicoderange':\n        this.unicodeRange();\n        break;\n\n      default:\n        this.word();\n        break;\n    }\n  }\n\n  parenOpen() {\n    let unbalanced = 1,\n        pos = this.position + 1,\n        token = this.currToken,\n        last; // check for balanced parens\n\n    while (pos < this.tokens.length && unbalanced) {\n      let tkn = this.tokens[pos];\n\n      if (tkn[0] === '(') {\n        unbalanced++;\n      }\n\n      if (tkn[0] === ')') {\n        unbalanced--;\n      }\n\n      pos++;\n    }\n\n    if (unbalanced) {\n      this.error('Expected closing parenthesis', token);\n    } // ok, all parens are balanced. continue on\n\n\n    last = this.current.last;\n\n    if (last && last.type === 'func' && last.unbalanced < 0) {\n      last.unbalanced = 0; // ok we're ready to add parens now\n\n      this.current = last;\n    }\n\n    this.current.unbalanced++;\n    this.newNode(new Paren({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n    this.position++; // url functions get special treatment, and anything between the function\n    // parens get treated as one word, if the contents aren't not a string.\n\n    if (this.current.type === 'func' && this.current.unbalanced && this.current.value === 'url' && this.currToken[0] !== 'string' && this.currToken[0] !== ')' && !this.options.loose) {\n      let nextToken = this.nextToken,\n          value = this.currToken[1],\n          start = {\n        line: this.currToken[2],\n        column: this.currToken[3]\n      };\n\n      while (nextToken && nextToken[0] !== ')' && this.current.unbalanced) {\n        this.position++;\n        value += this.currToken[1];\n        nextToken = this.nextToken;\n      }\n\n      if (this.position !== this.tokens.length - 1) {\n        // skip the following word definition, or it'll be a duplicate\n        this.position++;\n        this.newNode(new Word({\n          value,\n          source: {\n            start,\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[5]\n            }\n          },\n          sourceIndex: this.currToken[6]\n        }));\n      }\n    }\n  }\n\n  parenClose() {\n    let token = this.currToken;\n    this.newNode(new Paren({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n    this.position++;\n\n    if (this.position >= this.tokens.length - 1 && !this.current.unbalanced) {\n      return;\n    }\n\n    this.current.unbalanced--;\n\n    if (this.current.unbalanced < 0) {\n      this.error('Expected opening parenthesis', token);\n    }\n\n    if (!this.current.unbalanced && this.cache.length) {\n      this.current = this.cache.pop();\n    }\n  }\n\n  space() {\n    let token = this.currToken; // Handle space before and after the selector\n\n    if (this.position === this.tokens.length - 1 || this.nextToken[0] === ',' || this.nextToken[0] === ')') {\n      this.current.last.raws.after += token[1];\n      this.position++;\n    } else {\n      this.spaces = token[1];\n      this.position++;\n    }\n  }\n\n  unicodeRange() {\n    let token = this.currToken;\n    this.newNode(new UnicodeRange({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n    this.position++;\n  }\n\n  splitWord() {\n    let nextToken = this.nextToken,\n        word = this.currToken[1],\n        rNumber = /^[\\+\\-]?((\\d+(\\.\\d*)?)|(\\.\\d+))([eE][\\+\\-]?\\d+)?/,\n        // treat css-like groupings differently so they can be inspected,\n    // but don't address them as anything but a word, but allow hex values\n    // to pass through.\n    rNoFollow = /^(?!\\#([a-z0-9]+))[\\#\\{\\}]/gi,\n        hasAt,\n        indices;\n\n    if (!rNoFollow.test(word)) {\n      while (nextToken && nextToken[0] === 'word') {\n        this.position++;\n        let current = this.currToken[1];\n        word += current;\n        nextToken = this.nextToken;\n      }\n    }\n\n    hasAt = indexesOf(word, '@');\n    indices = sortAscending(uniq(flatten([[0], hasAt])));\n    indices.forEach((ind, i) => {\n      let index = indices[i + 1] || word.length,\n          value = word.slice(ind, index),\n          node;\n\n      if (~hasAt.indexOf(ind)) {\n        node = new AtWord({\n          value: value.slice(1),\n          source: {\n            start: {\n              line: this.currToken[2],\n              column: this.currToken[3] + ind\n            },\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[3] + (index - 1)\n            }\n          },\n          sourceIndex: this.currToken[6] + indices[i]\n        });\n      } else if (rNumber.test(this.currToken[1])) {\n        let unit = value.replace(rNumber, '');\n        node = new Numbr({\n          value: value.replace(unit, ''),\n          source: {\n            start: {\n              line: this.currToken[2],\n              column: this.currToken[3] + ind\n            },\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[3] + (index - 1)\n            }\n          },\n          sourceIndex: this.currToken[6] + indices[i],\n          unit\n        });\n      } else {\n        node = new (nextToken && nextToken[0] === '(' ? Func : Word)({\n          value,\n          source: {\n            start: {\n              line: this.currToken[2],\n              column: this.currToken[3] + ind\n            },\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[3] + (index - 1)\n            }\n          },\n          sourceIndex: this.currToken[6] + indices[i]\n        });\n\n        if (node.constructor.name === 'Word') {\n          node.isHex = /^#(.+)/.test(value);\n          node.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(value);\n        } else {\n          this.cache.push(this.current);\n        }\n      }\n\n      this.newNode(node);\n    });\n    this.position++;\n  }\n\n  string() {\n    let token = this.currToken,\n        value = this.currToken[1],\n        rQuote = /^(\\\"|\\')/,\n        quoted = rQuote.test(value),\n        quote = '',\n        node;\n\n    if (quoted) {\n      quote = value.match(rQuote)[0]; // set value to the string within the quotes\n      // quotes are stored in raws\n\n      value = value.slice(1, value.length - 1);\n    }\n\n    node = new Str({\n      value,\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6],\n      quoted\n    });\n    node.raws.quote = quote;\n    this.newNode(node);\n    this.position++;\n  }\n\n  word() {\n    return this.splitWord();\n  }\n\n  newNode(node) {\n    if (this.spaces) {\n      node.raws.before += this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  }\n\n  get currToken() {\n    return this.tokens[this.position];\n  }\n\n  get nextToken() {\n    return this.tokens[this.position + 1];\n  }\n\n  get prevToken() {\n    return this.tokens[this.position - 1];\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-values-parser/lib/parser.js"],"names":["Root","require","Value","AtWord","Colon","Comma","Comment","Func","Numbr","Operator","Paren","Str","Word","UnicodeRange","tokenize","flatten","indexesOf","uniq","ParserError","sortAscending","list","sort","a","b","module","exports","Parser","constructor","input","options","defaults","loose","cache","Object","assign","position","unbalanced","root","value","append","current","tokens","parse","loop","colon","token","currToken","newNode","source","start","line","column","end","sourceIndex","comma","comment","inline","replace","node","startsWith","substring","error","message","length","parseTokens","last","spaces","raws","before","after","operator","char","type","prevToken","nextToken","word","nodes","space","parenOpen","parenClose","string","unicodeRange","pos","tkn","pop","splitWord","rNumber","rNoFollow","hasAt","indices","test","forEach","ind","i","index","slice","indexOf","unit","name","isHex","isColor","push","rQuote","quoted","quote","match"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Root = require('./root');\nconst Value = require('./value');\n\nconst AtWord = require('./atword');\nconst Colon = require('./colon');\nconst Comma = require('./comma');\nconst Comment = require('./comment');\nconst Func = require('./function');\nconst Numbr = require('./number');\nconst Operator = require('./operator');\nconst Paren = require('./paren');\nconst Str = require('./string');\nconst Word = require('./word');\nconst UnicodeRange = require('./unicode-range');\n\nconst tokenize = require('./tokenize');\n\nconst flatten = require('flatten');\nconst indexesOf = require('indexes-of');\nconst uniq = require('uniq');\nconst ParserError = require('./errors/ParserError');\n\nfunction sortAscending (list) {\n  return list.sort((a, b) => a - b);\n}\n\nmodule.exports = class Parser {\n  constructor (input, options) {\n    const defaults = { loose: false };\n\n    // cache needs to be an array for values with more than 1 level of function nesting\n    this.cache = [];\n    this.input = input;\n    this.options = Object.assign({}, defaults, options);\n    this.position = 0;\n    // we'll use this to keep track of the paren balance\n    this.unbalanced = 0;\n    this.root = new Root();\n\n    let value = new Value();\n\n    this.root.append(value);\n\n    this.current = value;\n    this.tokens = tokenize(input, this.options);\n  }\n\n  parse () {\n    return this.loop();\n  }\n\n  colon () {\n    let token = this.currToken;\n\n    this.newNode(new Colon({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n\n    this.position ++;\n  }\n\n  comma () {\n    let token = this.currToken;\n\n    this.newNode(new Comma({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n\n    this.position ++;\n  }\n\n  comment () {\n    let inline = false,\n      value = this.currToken[1].replace(/\\/\\*|\\*\\//g, ''),\n      node;\n\n    if (this.options.loose && value.startsWith(\"//\")) {\n      value = value.substring(2);\n      inline = true;\n    }\n\n    node = new Comment({\n      value: value,\n      inline: inline,\n      source: {\n        start: {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        },\n        end: {\n          line: this.currToken[4],\n          column: this.currToken[5]\n        }\n      },\n      sourceIndex: this.currToken[6]\n    });\n\n    this.newNode(node);\n    this.position++;\n  }\n\n  error (message, token) {\n    throw new ParserError(message + ` at line: ${token[2]}, column ${token[3]}`);\n  }\n\n  loop () {\n    while (this.position < this.tokens.length) {\n      this.parseTokens();\n    }\n\n    if (!this.current.last && this.spaces) {\n      this.current.raws.before += this.spaces;\n    }\n    else if (this.spaces) {\n      this.current.last.raws.after += this.spaces;\n    }\n\n    this.spaces = '';\n\n    return this.root;\n  }\n\n  operator () {\n\n    // if a +|- operator is followed by a non-word character (. is allowed) and\n    // is preceded by a non-word character. (5+5)\n    let char = this.currToken[1],\n      node;\n\n    if (char === '+' || char === '-') {\n      // only inspect if the operator is not the first token, and we're only\n      // within a calc() function: the only spec-valid place for math expressions\n      if (!this.options.loose) {\n        if (this.position > 0) {\n          if (this.current.type === 'func' && this.current.value === 'calc') {\n            // allow operators to be proceeded by spaces and opening parens\n            if (this.prevToken[0] !== 'space' && this.prevToken[0] !== '(') {\n              this.error('Syntax Error', this.currToken);\n            }\n            // valid: calc(1 - +2)\n            // invalid: calc(1 -+2)\n            else if (this.nextToken[0] !== 'space' && this.nextToken[0] !== 'word') {\n              this.error('Syntax Error', this.currToken);\n            }\n            // valid: calc(1 - +2)\n            // valid: calc(-0.5 + 2)\n            // invalid: calc(1 -2)\n            else if (this.nextToken[0] === 'word' && this.current.last.type !== 'operator' &&\n                     this.current.last.value !== '(') {\n              this.error('Syntax Error', this.currToken);\n            }\n          }\n          // if we're not in a function and someone has doubled up on operators,\n          // or they're trying to perform a calc outside of a calc\n          // eg. +-4px or 5+ 5, throw an error\n          else if (this.nextToken[0] === 'space'\n                  || this.nextToken[0] === 'operator'\n                  || this.prevToken[0] === 'operator') {\n            this.error('Syntax Error', this.currToken);\n          }\n        }\n      }\n\n      if (!this.options.loose) {\n        if (this.nextToken[0] === 'word') {\n          return this.word();\n        }\n      }\n      else {\n        if ((!this.current.nodes.length || (this.current.last && this.current.last.type === 'operator')) && this.nextToken[0] === 'word') {\n          return this.word();\n        }\n      }\n    }\n\n    node = new Operator({\n      value: this.currToken[1],\n      source: {\n        start: {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        },\n        end: {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        }\n      },\n      sourceIndex: this.currToken[4]\n    });\n\n    this.position ++;\n\n    return this.newNode(node);\n  }\n\n  parseTokens () {\n    switch (this.currToken[0]) {\n      case 'space':\n        this.space();\n        break;\n      case 'colon':\n        this.colon();\n        break;\n      case 'comma':\n        this.comma();\n        break;\n      case 'comment':\n        this.comment();\n        break;\n      case '(':\n        this.parenOpen();\n        break;\n      case ')':\n        this.parenClose();\n        break;\n      case 'atword':\n      case 'word':\n        this.word();\n        break;\n      case 'operator':\n        this.operator();\n        break;\n      case 'string':\n        this.string();\n        break;\n      case 'unicoderange':\n        this.unicodeRange();\n        break;\n      default:\n        this.word();\n        break;\n    }\n  }\n\n  parenOpen () {\n    let unbalanced = 1,\n      pos = this.position + 1,\n      token = this.currToken,\n      last;\n\n    // check for balanced parens\n    while (pos < this.tokens.length && unbalanced) {\n      let tkn = this.tokens[pos];\n\n      if (tkn[0] === '(') {\n        unbalanced++;\n      }\n      if (tkn[0] === ')') {\n        unbalanced--;\n      }\n      pos ++;\n    }\n\n    if (unbalanced) {\n      this.error('Expected closing parenthesis', token);\n    }\n\n    // ok, all parens are balanced. continue on\n\n    last = this.current.last;\n\n    if (last && last.type === 'func' && last.unbalanced < 0) {\n      last.unbalanced = 0; // ok we're ready to add parens now\n      this.current = last;\n    }\n\n    this.current.unbalanced ++;\n\n    this.newNode(new Paren({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n\n    this.position ++;\n\n    // url functions get special treatment, and anything between the function\n    // parens get treated as one word, if the contents aren't not a string.\n    if (this.current.type === 'func' && this.current.unbalanced &&\n        this.current.value === 'url' && this.currToken[0] !== 'string' &&\n        this.currToken[0] !== ')' && !this.options.loose) {\n\n      let nextToken = this.nextToken,\n        value = this.currToken[1],\n        start = {\n          line: this.currToken[2],\n          column: this.currToken[3]\n        };\n\n      while (nextToken && nextToken[0] !== ')' && this.current.unbalanced) {\n        this.position ++;\n        value += this.currToken[1];\n        nextToken = this.nextToken;\n      }\n\n      if (this.position !== this.tokens.length - 1) {\n        // skip the following word definition, or it'll be a duplicate\n        this.position ++;\n\n        this.newNode(new Word({\n          value,\n          source: {\n            start,\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[5]\n            }\n          },\n          sourceIndex: this.currToken[6]\n        }));\n      }\n    }\n  }\n\n  parenClose () {\n    let token = this.currToken;\n\n    this.newNode(new Paren({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n\n    this.position ++;\n\n    if (this.position >= this.tokens.length - 1 && !this.current.unbalanced) {\n      return;\n    }\n\n    this.current.unbalanced --;\n\n    if (this.current.unbalanced < 0) {\n      this.error('Expected opening parenthesis', token);\n    }\n\n    if (!this.current.unbalanced && this.cache.length) {\n      this.current = this.cache.pop();\n    }\n  }\n\n  space () {\n    let token = this.currToken;\n    // Handle space before and after the selector\n    if (this.position === (this.tokens.length - 1) || this.nextToken[0] === ',' || this.nextToken[0] === ')') {\n      this.current.last.raws.after += token[1];\n      this.position ++;\n    }\n    else {\n      this.spaces = token[1];\n      this.position ++;\n    }\n  }\n\n  unicodeRange () {\n    let token = this.currToken;\n\n    this.newNode(new UnicodeRange({\n      value: token[1],\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6]\n    }));\n\n    this.position ++;\n  }\n\n  splitWord () {\n    let nextToken = this.nextToken,\n      word = this.currToken[1],\n      rNumber = /^[\\+\\-]?((\\d+(\\.\\d*)?)|(\\.\\d+))([eE][\\+\\-]?\\d+)?/,\n\n      // treat css-like groupings differently so they can be inspected,\n      // but don't address them as anything but a word, but allow hex values\n      // to pass through.\n      rNoFollow = /^(?!\\#([a-z0-9]+))[\\#\\{\\}]/gi,\n\n      hasAt, indices;\n\n    if (!rNoFollow.test(word)) {\n      while (nextToken && nextToken[0] === 'word') {\n        this.position ++;\n\n        let current = this.currToken[1];\n        word += current;\n\n        nextToken = this.nextToken;\n      }\n    }\n\n    hasAt = indexesOf(word, '@');\n    indices = sortAscending(uniq(flatten([[0], hasAt])));\n\n    indices.forEach((ind, i) => {\n      let index = indices[i + 1] || word.length,\n        value = word.slice(ind, index),\n        node;\n\n      if (~hasAt.indexOf(ind)) {\n        node = new AtWord({\n          value: value.slice(1),\n          source: {\n            start: {\n              line: this.currToken[2],\n              column: this.currToken[3] + ind\n            },\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[3] + (index - 1)\n            }\n          },\n          sourceIndex: this.currToken[6] + indices[i]\n        });\n      }\n      else if (rNumber.test(this.currToken[1])) {\n        let unit = value.replace(rNumber, '');\n\n        node = new Numbr({\n          value: value.replace(unit, ''),\n          source: {\n            start: {\n              line: this.currToken[2],\n              column: this.currToken[3] + ind\n            },\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[3] + (index - 1)\n            }\n          },\n          sourceIndex: this.currToken[6] + indices[i],\n          unit\n        });\n      }\n      else {\n        node = new (nextToken && nextToken[0] === '(' ? Func : Word)({\n          value,\n          source: {\n            start: {\n              line: this.currToken[2],\n              column: this.currToken[3] + ind\n            },\n            end: {\n              line: this.currToken[4],\n              column: this.currToken[3] + (index - 1)\n            }\n          },\n          sourceIndex: this.currToken[6] + indices[i]\n        });\n\n        if (node.constructor.name === 'Word') {\n          node.isHex = /^#(.+)/.test(value);\n          node.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(value);\n        }\n        else {\n          this.cache.push(this.current);\n        }\n      }\n\n      this.newNode(node);\n\n    });\n\n    this.position ++;\n  }\n\n  string () {\n    let token = this.currToken,\n      value = this.currToken[1],\n      rQuote = /^(\\\"|\\')/,\n      quoted = rQuote.test(value),\n      quote = '',\n      node;\n\n    if (quoted) {\n      quote = value.match(rQuote)[0];\n      // set value to the string within the quotes\n      // quotes are stored in raws\n      value = value.slice(1, value.length - 1);\n    }\n\n    node = new Str({\n      value,\n      source: {\n        start: {\n          line: token[2],\n          column: token[3]\n        },\n        end: {\n          line: token[4],\n          column: token[5]\n        }\n      },\n      sourceIndex: token[6],\n      quoted\n    });\n\n    node.raws.quote = quote;\n\n    this.newNode(node);\n    this.position++;\n  }\n\n  word () {\n    return this.splitWord();\n  }\n\n  newNode (node) {\n    if (this.spaces) {\n      node.raws.before += this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  }\n\n  get currToken () {\n    return this.tokens[this.position];\n  }\n\n  get nextToken () {\n    return this.tokens[this.position + 1];\n  }\n\n  get prevToken () {\n    return this.tokens[this.position - 1];\n  }\n};\n"]},"metadata":{},"sourceType":"script"}