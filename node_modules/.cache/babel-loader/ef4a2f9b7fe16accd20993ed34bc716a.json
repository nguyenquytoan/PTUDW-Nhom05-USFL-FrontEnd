{"ast":null,"code":"/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\n\n\nclass CodePathSegment {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   *   This array includes unreachable segments.\n   * @param {boolean} reachable A flag which shows this is reachable.\n   */\n  constructor(id, allPrevSegments, reachable) {\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n    /**\n     * An array of the next segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.nextSegments = [];\n    /**\n     * An array of the previous segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.prevSegments = allPrevSegments.filter(isReachable);\n    /**\n     * An array of the next segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.allNextSegments = [];\n    /**\n     * An array of the previous segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n\n    this.allPrevSegments = allPrevSegments;\n    /**\n     * A flag which shows this is reachable.\n     * @type {boolean}\n     */\n\n    this.reachable = reachable; // Internal data.\n\n    Object.defineProperty(this, \"internal\", {\n      value: {\n        used: false,\n        loopedPrevSegments: []\n      }\n    });\n    /* istanbul ignore if */\n\n    if (debug.enabled) {\n      this.internal.nodes = [];\n      this.internal.exitNodes = [];\n    }\n  }\n  /**\n   * Checks a given previous segment is coming from the end of a loop.\n   * @param {CodePathSegment} segment A previous segment to check.\n   * @returns {boolean} `true` if the segment is coming from the end of a loop.\n   */\n\n\n  isLoopedPrevSegment(segment) {\n    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n  }\n  /**\n   * Creates the root segment.\n   * @param {string} id An identifier.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newRoot(id) {\n    return new CodePathSegment(id, [], true);\n  }\n  /**\n   * Creates a segment that follows given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newNext(id, allPrevSegments) {\n    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));\n  }\n  /**\n   * Creates an unreachable segment that follows given segments.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newUnreachable(id, allPrevSegments) {\n    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n    /*\n     * In `if (a) return a; foo();` case, the unreachable segment preceded by\n     * the return statement is not used but must not be remove.\n     */\n\n    CodePathSegment.markUsed(segment);\n    return segment;\n  }\n  /**\n   * Creates a segment that follows given segments.\n   * This factory method does not connect with `allPrevSegments`.\n   * But this inherits `reachable` flag.\n   * @param {string} id An identifier.\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n   * @returns {CodePathSegment} The created segment.\n   */\n\n\n  static newDisconnected(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n  }\n  /**\n   * Makes a given segment being used.\n   *\n   * And this function registers the segment into the previous segments as a next.\n   * @param {CodePathSegment} segment A segment to mark.\n   * @returns {void}\n   */\n\n\n  static markUsed(segment) {\n    if (segment.internal.used) {\n      return;\n    }\n\n    segment.internal.used = true;\n    let i;\n\n    if (segment.reachable) {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        const prevSegment = segment.allPrevSegments[i];\n        prevSegment.allNextSegments.push(segment);\n        prevSegment.nextSegments.push(segment);\n      }\n    } else {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        segment.allPrevSegments[i].allNextSegments.push(segment);\n      }\n    }\n  }\n  /**\n   * Marks a previous segment as looped.\n   * @param {CodePathSegment} segment A segment.\n   * @param {CodePathSegment} prevSegment A previous segment to mark.\n   * @returns {void}\n   */\n\n\n  static markPrevSegmentAsLooped(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n  }\n  /**\n   * Replaces unused segments with the previous segments of each unused segment.\n   * @param {CodePathSegment[]} segments An array of segments to replace.\n   * @returns {CodePathSegment[]} The replaced array.\n   */\n\n\n  static flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i]; // Ignores duplicated.\n\n      if (done[segment.id]) {\n        continue;\n      } // Use previous segments if unused.\n\n\n      if (!segment.internal.used) {\n        for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n          const prevSegment = segment.allPrevSegments[j];\n\n          if (!done[prevSegment.id]) {\n            done[prevSegment.id] = true;\n            retv.push(prevSegment);\n          }\n        }\n      } else {\n        done[segment.id] = true;\n        retv.push(segment);\n      }\n    }\n\n    return retv;\n  }\n\n}\n\nmodule.exports = CodePathSegment;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js"],"names":["debug","require","isReachable","segment","reachable","CodePathSegment","constructor","id","allPrevSegments","nextSegments","prevSegments","filter","allNextSegments","Object","defineProperty","value","used","loopedPrevSegments","enabled","internal","nodes","exitNodes","isLoopedPrevSegment","indexOf","newRoot","newNext","flattenUnusedSegments","some","newUnreachable","markUsed","newDisconnected","i","length","prevSegment","push","markPrevSegmentAsLooped","segments","done","create","retv","j","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n            this.internal.exitNodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be remove.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Replaces unused segments with the previous segments of each unused segment.\n     * @param {CodePathSegment[]} segments An array of segments to replace.\n     * @returns {CodePathSegment[]} The replaced array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = Object.create(null);\n        const retv = [];\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done[segment.id]) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done[prevSegment.id]) {\n                        done[prevSegment.id] = true;\n                        retv.push(prevSegment);\n                    }\n                }\n            } else {\n                done[segment.id] = true;\n                retv.push(segment);\n            }\n        }\n\n        return retv;\n    }\n}\n\nmodule.exports = CodePathSegment;\n"]},"metadata":{},"sourceType":"script"}