{"ast":null,"code":"'use strict';\n\nlet call = module.exports = {\n  safe: safeCall,\n  once: callOnce\n};\n/**\n * Calls a function with the given arguments, and ensures that the error-first callback is _always_\n * invoked exactly once, even if the function throws an error.\n *\n * @param {function} fn - The function to invoke\n * @param {...*} args - The arguments to pass to the function. The final argument must be a callback function.\n */\n\nfunction safeCall(fn, args) {\n  // Get the function arguments as an array\n  args = Array.prototype.slice.call(arguments, 1); // Replace the callback function with a wrapper that ensures it will only be called once\n\n  let callback = call.once(args.pop());\n  args.push(callback);\n\n  try {\n    fn.apply(null, args);\n  } catch (err) {\n    callback(err);\n  }\n}\n/**\n * Returns a wrapper function that ensures the given callback function is only called once.\n * Subsequent calls are ignored, unless the first argument is an Error, in which case the\n * error is thrown.\n *\n * @param {function} fn - The function that should only be called once\n * @returns {function}\n */\n\n\nfunction callOnce(fn) {\n  let fulfilled = false;\n  return function onceWrapper(err) {\n    if (!fulfilled) {\n      fulfilled = true;\n      return fn.apply(this, arguments);\n    } else if (err) {\n      // The callback has already been called, but now an error has occurred\n      // (most likely inside the callback function). So re-throw the error,\n      // so it gets handled further up the call stack\n      throw err;\n    }\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@mrmlnc/readdir-enhanced/lib/call.js"],"names":["call","module","exports","safe","safeCall","once","callOnce","fn","args","Array","prototype","slice","arguments","callback","pop","push","apply","err","fulfilled","onceWrapper"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,MAAM,CAACC,OAAP,GAAiB;AAC1BC,EAAAA,IAAI,EAAEC,QADoB;AAE1BC,EAAAA,IAAI,EAAEC;AAFoB,CAA5B;AAKA;;;;;;;;AAOA,SAASF,QAAT,CAAmBG,EAAnB,EAAuBC,IAAvB,EAA6B;AAC3B;AACAA,EAAAA,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBX,IAAtB,CAA2BY,SAA3B,EAAsC,CAAtC,CAAP,CAF2B,CAI3B;;AACA,MAAIC,QAAQ,GAAGb,IAAI,CAACK,IAAL,CAAUG,IAAI,CAACM,GAAL,EAAV,CAAf;AACAN,EAAAA,IAAI,CAACO,IAAL,CAAUF,QAAV;;AAEA,MAAI;AACFN,IAAAA,EAAE,CAACS,KAAH,CAAS,IAAT,EAAeR,IAAf;AACD,GAFD,CAGA,OAAOS,GAAP,EAAY;AACVJ,IAAAA,QAAQ,CAACI,GAAD,CAAR;AACD;AACF;AAED;;;;;;;;;;AAQA,SAASX,QAAT,CAAmBC,EAAnB,EAAuB;AACrB,MAAIW,SAAS,GAAG,KAAhB;AAEA,SAAO,SAASC,WAAT,CAAsBF,GAAtB,EAA2B;AAChC,QAAI,CAACC,SAAL,EAAgB;AACdA,MAAAA,SAAS,GAAG,IAAZ;AACA,aAAOX,EAAE,CAACS,KAAH,CAAS,IAAT,EAAeJ,SAAf,CAAP;AACD,KAHD,MAIK,IAAIK,GAAJ,EAAS;AACZ;AACA;AACA;AACA,YAAMA,GAAN;AACD;AACF,GAXD;AAYD","sourcesContent":["'use strict';\n\nlet call = module.exports = {\n  safe: safeCall,\n  once: callOnce,\n};\n\n/**\n * Calls a function with the given arguments, and ensures that the error-first callback is _always_\n * invoked exactly once, even if the function throws an error.\n *\n * @param {function} fn - The function to invoke\n * @param {...*} args - The arguments to pass to the function. The final argument must be a callback function.\n */\nfunction safeCall (fn, args) {\n  // Get the function arguments as an array\n  args = Array.prototype.slice.call(arguments, 1);\n\n  // Replace the callback function with a wrapper that ensures it will only be called once\n  let callback = call.once(args.pop());\n  args.push(callback);\n\n  try {\n    fn.apply(null, args);\n  }\n  catch (err) {\n    callback(err);\n  }\n}\n\n/**\n * Returns a wrapper function that ensures the given callback function is only called once.\n * Subsequent calls are ignored, unless the first argument is an Error, in which case the\n * error is thrown.\n *\n * @param {function} fn - The function that should only be called once\n * @returns {function}\n */\nfunction callOnce (fn) {\n  let fulfilled = false;\n\n  return function onceWrapper (err) {\n    if (!fulfilled) {\n      fulfilled = true;\n      return fn.apply(this, arguments);\n    }\n    else if (err) {\n      // The callback has already been called, but now an error has occurred\n      // (most likely inside the callback function). So re-throw the error,\n      // so it gets handled further up the call stack\n      throw err;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}