{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n * Constants (parser usage)\n */\n\n\nconst SINGLE_QUOTE = '\\''.charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = {\n  type: C_ESCAPED_SINGLE_QUOTE,\n  value: `\\\\'`\n};\nconst T_ESCAPED_DOUBLE_QUOTE = {\n  type: C_ESCAPED_DOUBLE_QUOTE,\n  value: `\\\\\"`\n};\nconst T_SINGLE_QUOTE = {\n  type: C_SINGLE_QUOTE,\n  value: L_SINGLE_QUOTE\n};\nconst T_DOUBLE_QUOTE = {\n  type: C_DOUBLE_QUOTE,\n  value: L_DOUBLE_QUOTE\n};\nconst T_NEWLINE = {\n  type: C_NEWLINE,\n  value: L_NEWLINE\n};\n\nfunction stringify(ast) {\n  return ast.nodes.reduce((str, {\n    value\n  }) => {\n    // Collapse multiple line strings automatically\n    if (value === L_NEWLINE) {\n      return str;\n    }\n\n    return str + value;\n  }, '');\n}\n\nfunction parse(str) {\n  let code, next, value;\n  let pos = 0;\n  let len = str.length;\n  const ast = {\n    nodes: [],\n    types: {\n      escapedSingleQuote: 0,\n      escapedDoubleQuote: 0,\n      singleQuote: 0,\n      doubleQuote: 0\n    },\n    quotes: false\n  };\n\n  while (pos < len) {\n    code = str.charCodeAt(pos);\n\n    switch (code) {\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = str.charCodeAt(next);\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        ast.nodes.push({\n          type: 'space',\n          value: str.slice(pos, next)\n        });\n        pos = next - 1;\n        break;\n\n      case SINGLE_QUOTE:\n        ast.nodes.push(T_SINGLE_QUOTE);\n        ast.types[C_SINGLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n\n      case DOUBLE_QUOTE:\n        ast.nodes.push(T_DOUBLE_QUOTE);\n        ast.types[C_DOUBLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n\n      case BACKSLASH:\n        next = pos + 1;\n\n        if (str.charCodeAt(next) === SINGLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n          ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === NEWLINE) {\n          ast.nodes.push(T_NEWLINE);\n          pos = next;\n          break;\n        }\n\n      /*\n       * We need to fall through here to handle the token as\n       * a whole word. The missing 'break' is intentional.\n       */\n\n      default:\n        WORD_END.lastIndex = pos + 1;\n        WORD_END.test(str);\n\n        if (WORD_END.lastIndex === 0) {\n          next = len - 1;\n        } else {\n          next = WORD_END.lastIndex - 2;\n        }\n\n        value = str.slice(pos, next + 1);\n        ast.nodes.push({\n          type: C_STRING,\n          value\n        });\n        pos = next;\n    }\n\n    pos++;\n  }\n\n  return ast;\n}\n\nfunction changeWrappingQuotes(node, ast) {\n  const {\n    types\n  } = ast;\n\n  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n    return;\n  }\n\n  if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {\n    node.quote = L_DOUBLE_QUOTE;\n  }\n\n  if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {\n    node.quote = L_SINGLE_QUOTE;\n  }\n\n  ast.nodes = ast.nodes.reduce((newAst, child) => {\n    if (child.type === C_ESCAPED_DOUBLE_QUOTE && node.quote === L_SINGLE_QUOTE) {\n      return [...newAst, T_DOUBLE_QUOTE];\n    }\n\n    if (child.type === C_ESCAPED_SINGLE_QUOTE && node.quote === L_DOUBLE_QUOTE) {\n      return [...newAst, T_SINGLE_QUOTE];\n    }\n\n    return [...newAst, child];\n  }, []);\n}\n\nfunction normalize(value, preferredQuote) {\n  if (!value || !value.length) {\n    return value;\n  }\n\n  return (0, _postcssValueParser2.default)(value).walk(child => {\n    if (child.type !== C_STRING) {\n      return;\n    }\n\n    const ast = parse(child.value);\n\n    if (ast.quotes) {\n      changeWrappingQuotes(child, ast);\n    } else if (preferredQuote === C_SINGLE) {\n      child.quote = L_SINGLE_QUOTE;\n    } else {\n      child.quote = L_DOUBLE_QUOTE;\n    }\n\n    child.value = stringify(ast);\n  }).toString();\n}\n\nconst params = {\n  rule: 'selector',\n  decl: 'value',\n  atrule: 'params'\n};\nexports.default = _postcss2.default.plugin('postcss-normalize-string', opts => {\n  const {\n    preferredQuote\n  } = Object.assign({}, {\n    preferredQuote: 'double'\n  }, opts);\n  return css => {\n    const cache = {};\n    css.walk(node => {\n      const {\n        type\n      } = node;\n\n      if ((0, _has2.default)(params, type)) {\n        const param = params[type];\n        const key = node[param] + '|' + preferredQuote;\n\n        if (cache[key]) {\n          node[param] = cache[key];\n          return;\n        }\n\n        const result = normalize(node[param], preferredQuote);\n        node[param] = result;\n        cache[key] = result;\n      }\n    });\n  };\n});\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-normalize-string/dist/index.js"],"names":["Object","defineProperty","exports","value","_postcss","require","_postcss2","_interopRequireDefault","_postcssValueParser","_postcssValueParser2","_has","_has2","obj","__esModule","default","SINGLE_QUOTE","charCodeAt","DOUBLE_QUOTE","BACKSLASH","NEWLINE","SPACE","FEED","TAB","CR","WORD_END","C_STRING","C_ESCAPED_SINGLE_QUOTE","C_ESCAPED_DOUBLE_QUOTE","C_SINGLE_QUOTE","C_DOUBLE_QUOTE","C_NEWLINE","C_SINGLE","L_SINGLE_QUOTE","L_DOUBLE_QUOTE","L_NEWLINE","T_ESCAPED_SINGLE_QUOTE","type","T_ESCAPED_DOUBLE_QUOTE","T_SINGLE_QUOTE","T_DOUBLE_QUOTE","T_NEWLINE","stringify","ast","nodes","reduce","str","parse","code","next","pos","len","length","types","escapedSingleQuote","escapedDoubleQuote","singleQuote","doubleQuote","quotes","push","slice","lastIndex","test","changeWrappingQuotes","node","quote","newAst","child","normalize","preferredQuote","walk","toString","params","rule","decl","atrule","plugin","opts","assign","css","cache","param","key","result","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Constants (parser usage)\n */\n\nconst SINGLE_QUOTE = '\\''.charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\n\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\\\'` };\nconst T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\\\\"` };\nconst T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };\nconst T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };\nconst T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };\n\nfunction stringify(ast) {\n    return ast.nodes.reduce((str, { value }) => {\n        // Collapse multiple line strings automatically\n        if (value === L_NEWLINE) {\n            return str;\n        }\n\n        return str + value;\n    }, '');\n}\n\nfunction parse(str) {\n    let code, next, value;\n    let pos = 0;\n    let len = str.length;\n\n    const ast = {\n        nodes: [],\n        types: {\n            escapedSingleQuote: 0,\n            escapedDoubleQuote: 0,\n            singleQuote: 0,\n            doubleQuote: 0\n        },\n        quotes: false\n    };\n\n    while (pos < len) {\n        code = str.charCodeAt(pos);\n\n        switch (code) {\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                next = pos;\n\n                do {\n                    next += 1;\n                    code = str.charCodeAt(next);\n                } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n                ast.nodes.push({\n                    type: 'space',\n                    value: str.slice(pos, next)\n                });\n                pos = next - 1;\n                break;\n            case SINGLE_QUOTE:\n                ast.nodes.push(T_SINGLE_QUOTE);\n                ast.types[C_SINGLE_QUOTE]++;\n                ast.quotes = true;\n                break;\n            case DOUBLE_QUOTE:\n                ast.nodes.push(T_DOUBLE_QUOTE);\n                ast.types[C_DOUBLE_QUOTE]++;\n                ast.quotes = true;\n                break;\n            case BACKSLASH:\n                next = pos + 1;\n\n                if (str.charCodeAt(next) === SINGLE_QUOTE) {\n                    ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n                    ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n                    ast.quotes = true;\n                    pos = next;\n                    break;\n                } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n                    ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n                    ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n                    ast.quotes = true;\n                    pos = next;\n                    break;\n                } else if (str.charCodeAt(next) === NEWLINE) {\n                    ast.nodes.push(T_NEWLINE);\n                    pos = next;\n                    break;\n                }\n            /*\n             * We need to fall through here to handle the token as\n             * a whole word. The missing 'break' is intentional.\n             */\n            default:\n                WORD_END.lastIndex = pos + 1;\n                WORD_END.test(str);\n\n                if (WORD_END.lastIndex === 0) {\n                    next = len - 1;\n                } else {\n                    next = WORD_END.lastIndex - 2;\n                }\n\n                value = str.slice(pos, next + 1);\n\n                ast.nodes.push({\n                    type: C_STRING,\n                    value\n                });\n\n                pos = next;\n        }\n        pos++;\n    }\n\n    return ast;\n}\n\nfunction changeWrappingQuotes(node, ast) {\n    const { types } = ast;\n\n    if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n        return;\n    }\n\n    if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {\n        node.quote = L_DOUBLE_QUOTE;\n    }\n\n    if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {\n        node.quote = L_SINGLE_QUOTE;\n    }\n\n    ast.nodes = ast.nodes.reduce((newAst, child) => {\n        if (child.type === C_ESCAPED_DOUBLE_QUOTE && node.quote === L_SINGLE_QUOTE) {\n            return [...newAst, T_DOUBLE_QUOTE];\n        }\n\n        if (child.type === C_ESCAPED_SINGLE_QUOTE && node.quote === L_DOUBLE_QUOTE) {\n            return [...newAst, T_SINGLE_QUOTE];\n        }\n\n        return [...newAst, child];\n    }, []);\n}\n\nfunction normalize(value, preferredQuote) {\n    if (!value || !value.length) {\n        return value;\n    }\n\n    return (0, _postcssValueParser2.default)(value).walk(child => {\n        if (child.type !== C_STRING) {\n            return;\n        }\n\n        const ast = parse(child.value);\n\n        if (ast.quotes) {\n            changeWrappingQuotes(child, ast);\n        } else if (preferredQuote === C_SINGLE) {\n            child.quote = L_SINGLE_QUOTE;\n        } else {\n            child.quote = L_DOUBLE_QUOTE;\n        }\n\n        child.value = stringify(ast);\n    }).toString();\n}\n\nconst params = {\n    rule: 'selector',\n    decl: 'value',\n    atrule: 'params'\n};\n\nexports.default = _postcss2.default.plugin('postcss-normalize-string', opts => {\n    const { preferredQuote } = Object.assign({}, {\n        preferredQuote: 'double'\n    }, opts);\n\n    return css => {\n        const cache = {};\n\n        css.walk(node => {\n            const { type } = node;\n\n            if ((0, _has2.default)(params, type)) {\n                const param = params[type];\n                const key = node[param] + '|' + preferredQuote;\n\n                if (cache[key]) {\n                    node[param] = cache[key];\n\n                    return;\n                }\n\n                const result = normalize(node[param], preferredQuote);\n\n                node[param] = result;\n                cache[key] = result;\n            }\n        });\n    };\n});\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}