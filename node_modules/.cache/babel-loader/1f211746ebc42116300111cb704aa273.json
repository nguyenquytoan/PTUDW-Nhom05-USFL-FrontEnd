{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { Route } from './Route.mjs';\nimport { RegExpRoute } from './RegExpRoute.mjs';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\n\nexport const registerRoute = (capture, handler, method = 'GET') => {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      } // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n\n\n      const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters\n\n      const wildcards = '[*:?+]';\n\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n        logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n      }\n    }\n\n    const matchCallback = ({\n      url\n    }) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n          logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n        }\n      }\n\n      return url.href === captureUrl.href;\n    };\n\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture'\n    });\n  }\n\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n  return route;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-routing/registerRoute.mjs"],"names":["logger","WorkboxError","Route","RegExpRoute","getOrCreateDefaultRouter","registerRoute","capture","handler","method","route","captureUrl","URL","location","process","env","NODE_ENV","startsWith","moduleName","funcName","paramName","valueToCheck","pathname","wildcards","match","RegExp","debug","matchCallback","url","origin","href","defaultRouter"],"mappings":"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","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {Route} from './Route.mjs';\nimport {RegExpRoute} from './RegExpRoute.mjs';\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n\n\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\nexport const registerRoute = (capture, handler, method = 'GET') => {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture',\n        });\n      }\n\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ?\n          captureUrl.pathname : capture;\n\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n        logger.debug(\n            `The '$capture' parameter contains an Express-style wildcard ` +\n          `character (${wildcards}). Strings are now always interpreted as ` +\n          `exact matches; use a RegExp for partial or wildcard matches.`\n        );\n      }\n    }\n\n    const matchCallback = ({url}) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if ((url.pathname === captureUrl.pathname) &&\n            (url.origin !== captureUrl.origin)) {\n          logger.debug(\n              `${capture} only partially matches the cross-origin URL ` +\n              `${url}. This route will only handle cross-origin requests ` +\n              `if they match the entire URL.`);\n        }\n      }\n\n      return url.href === captureUrl.href;\n    };\n\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture',\n    });\n  }\n\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n"]},"metadata":{},"sourceType":"module"}