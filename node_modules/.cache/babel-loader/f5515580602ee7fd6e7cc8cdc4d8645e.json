{"ast":null,"code":"let len = 0;\nlet vertxNext;\nexport default function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n\n  if (len === 2) {\n    // If len is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\nconst browserWindow = typeof window !== 'undefined' ? window : undefined;\nconst browserGlobal = browserWindow || {};\nconst BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nconst isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10\n\nconst isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node\n\nfunction useNextTick() {\n  let nextTick = process.nextTick; // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // setImmediate should be used instead instead\n\n  let version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n\n  if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n    nextTick = setImmediate;\n  }\n\n  return () => nextTick(flush);\n} // vertx\n\n\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  let iterations = 0;\n  let observer = new BrowserMutationObserver(flush);\n  let node = document.createTextNode('');\n  observer.observe(node, {\n    characterData: true\n  });\n  return () => node.data = iterations = ++iterations % 2;\n} // web worker\n\n\nfunction useMessageChannel() {\n  let channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return () => channel.port2.postMessage(0);\n}\n\nfunction useSetTimeout() {\n  return () => setTimeout(flush, 1);\n}\n\nconst queue = new Array(1000);\n\nfunction flush() {\n  for (let i = 0; i < len; i += 2) {\n    let callback = queue[i];\n    let arg = queue[i + 1];\n    callback(arg);\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertex() {\n  try {\n    const vertx = Function('return this')().require('vertx');\n\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nlet scheduleFlush; // Decide what async method to use to triggering processing of queued callbacks:\n\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertex();\n} else {\n  scheduleFlush = useSetTimeout();\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/rsvp/lib/rsvp/asap.js"],"names":["len","vertxNext","asap","callback","arg","queue","scheduleFlush","browserWindow","window","undefined","browserGlobal","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","isNode","self","process","toString","call","isWorker","Uint8ClampedArray","importScripts","MessageChannel","useNextTick","nextTick","version","versions","node","match","Array","isArray","setImmediate","flush","useVertxTimer","useSetTimeout","useMutationObserver","iterations","observer","document","createTextNode","observe","characterData","data","useMessageChannel","channel","port1","onmessage","port2","postMessage","setTimeout","i","attemptVertex","vertx","Function","require","runOnLoop","runOnContext","e"],"mappings":"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","sourcesContent":["let len = 0;\nlet vertxNext;\nexport default function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\n\nconst browserWindow = (typeof window !== 'undefined') ? window : undefined;\nconst browserGlobal = browserWindow || {};\nconst BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nconst isNode = typeof self === 'undefined' &&\n  typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nconst isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n  typeof importScripts !== 'undefined' &&\n  typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  let nextTick = process.nextTick;\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // setImmediate should be used instead instead\n  let version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n  if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n    nextTick = setImmediate;\n  }\n  return () => nextTick(flush);\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function() {\n      vertxNext(flush);\n    };\n  }\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  let iterations = 0;\n  let observer = new BrowserMutationObserver(flush);\n  let node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return () => node.data = (iterations = ++iterations % 2);\n}\n\n// web worker\nfunction useMessageChannel() {\n  let channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return () => channel.port2.postMessage(0);\n}\n\nfunction useSetTimeout() {\n  return () => setTimeout(flush, 1);\n}\n\nconst queue = new Array(1000);\n\nfunction flush() {\n  for (let i = 0; i < len; i+=2) {\n    let callback = queue[i];\n    let arg = queue[i+1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i+1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertex() {\n  try {\n    const vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch(e) {\n    return useSetTimeout();\n  }\n}\n\nlet scheduleFlush;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertex();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n"]},"metadata":{},"sourceType":"module"}