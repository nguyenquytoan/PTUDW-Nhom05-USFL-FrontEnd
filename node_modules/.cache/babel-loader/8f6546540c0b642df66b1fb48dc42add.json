{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxOptionalChaining = _interopRequireDefault(require(\"@babel/plugin-syntax-optional-chaining\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n\n  function isSimpleMemberExpression(expression) {\n    return _core.types.isIdentifier(expression) || _core.types.isSuper(expression) || _core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n  }\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: _pluginSyntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const {\n          parentPath,\n          scope\n        } = path;\n        let isDeleteOperation = false;\n        const optionals = [];\n        let optionalPath = path;\n\n        while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n          const {\n            node\n          } = optionalPath;\n\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = optionalPath.get(\"object\");\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = optionalPath.get(\"callee\");\n          }\n        }\n\n        let replacementPath = path;\n\n        if (parentPath.isUnaryExpression({\n          operator: \"delete\"\n        })) {\n          replacementPath = parentPath;\n          isDeleteOperation = true;\n        }\n\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = _core.types.isCallExpression(node);\n\n          const replaceKey = isCall ? \"callee\" : \"object\";\n          const chain = node[replaceKey];\n          let ref;\n          let check;\n\n          if (loose && isCall && isSimpleMemberExpression(chain)) {\n            check = ref = chain;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n\n            if (ref) {\n              check = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), chain);\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chain;\n            }\n          }\n\n          if (isCall && _core.types.isMemberExpression(chain)) {\n            if (loose && isSimpleMemberExpression(chain)) {\n              node.callee = chain;\n            } else {\n              const {\n                object\n              } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n\n              if (context) {\n                chain.object = _core.types.assignmentExpression(\"=\", context, object);\n              } else if (_core.types.isSuper(object)) {\n                context = _core.types.thisExpression();\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(_core.types.cloneNode(context));\n              node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"call\"));\n            }\n          }\n\n          replacementPath.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"==\", _core.types.cloneNode(check), _core.types.nullLiteral()) : _core.types.logicalExpression(\"||\", _core.types.binaryExpression(\"===\", _core.types.cloneNode(check), _core.types.nullLiteral()), _core.types.binaryExpression(\"===\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? _core.types.booleanLiteral(true) : scope.buildUndefinedNode(), replacementPath.node));\n          replacementPath = replacementPath.get(\"alternate\");\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/babel-preset-react-app/node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxOptionalChaining","_interopRequireDefault","_core","obj","__esModule","_default","declare","api","options","assertVersion","loose","isSimpleMemberExpression","expression","types","isIdentifier","isSuper","isMemberExpression","computed","object","name","inherits","visitor","path","parentPath","scope","isDeleteOperation","optionals","optionalPath","isOptionalMemberExpression","isOptionalCallExpression","node","optional","push","type","get","replacementPath","isUnaryExpression","operator","i","length","isCall","isCallExpression","replaceKey","chain","ref","check","maybeGenerateMemoised","assignmentExpression","cloneNode","callee","context","thisExpression","arguments","unshift","memberExpression","identifier","replaceWith","conditionalExpression","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","booleanLiteral"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxOptionalChaining = _interopRequireDefault(require(\"@babel/plugin-syntax-optional-chaining\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n\n  function isSimpleMemberExpression(expression) {\n    return _core.types.isIdentifier(expression) || _core.types.isSuper(expression) || _core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n  }\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: _pluginSyntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const {\n          parentPath,\n          scope\n        } = path;\n        let isDeleteOperation = false;\n        const optionals = [];\n        let optionalPath = path;\n\n        while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n          const {\n            node\n          } = optionalPath;\n\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = optionalPath.get(\"object\");\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = optionalPath.get(\"callee\");\n          }\n        }\n\n        let replacementPath = path;\n\n        if (parentPath.isUnaryExpression({\n          operator: \"delete\"\n        })) {\n          replacementPath = parentPath;\n          isDeleteOperation = true;\n        }\n\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = _core.types.isCallExpression(node);\n\n          const replaceKey = isCall ? \"callee\" : \"object\";\n          const chain = node[replaceKey];\n          let ref;\n          let check;\n\n          if (loose && isCall && isSimpleMemberExpression(chain)) {\n            check = ref = chain;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n\n            if (ref) {\n              check = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), chain);\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chain;\n            }\n          }\n\n          if (isCall && _core.types.isMemberExpression(chain)) {\n            if (loose && isSimpleMemberExpression(chain)) {\n              node.callee = chain;\n            } else {\n              const {\n                object\n              } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n\n              if (context) {\n                chain.object = _core.types.assignmentExpression(\"=\", context, object);\n              } else if (_core.types.isSuper(object)) {\n                context = _core.types.thisExpression();\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(_core.types.cloneNode(context));\n              node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"call\"));\n            }\n          }\n\n          replacementPath.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"==\", _core.types.cloneNode(check), _core.types.nullLiteral()) : _core.types.logicalExpression(\"||\", _core.types.binaryExpression(\"===\", _core.types.cloneNode(check), _core.types.nullLiteral()), _core.types.binaryExpression(\"===\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? _core.types.booleanLiteral(true) : scope.buildUndefinedNode(), replacementPath.node));\n          replacementPath = replacementPath.get(\"alternate\");\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}