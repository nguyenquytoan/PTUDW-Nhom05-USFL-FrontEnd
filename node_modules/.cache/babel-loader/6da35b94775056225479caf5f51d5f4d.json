{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _utils = require('./utils');\n\nvar _inline_snapshots = require('./inline_snapshots');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile = global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass SnapshotState {\n  // @ts-ignore\n  constructor(snapshotPath, options) {\n    _defineProperty(this, '_counters', void 0);\n\n    _defineProperty(this, '_dirty', void 0);\n\n    _defineProperty(this, '_index', void 0);\n\n    _defineProperty(this, '_updateSnapshot', void 0);\n\n    _defineProperty(this, '_snapshotData', void 0);\n\n    _defineProperty(this, '_initialData', void 0);\n\n    _defineProperty(this, '_snapshotPath', void 0);\n\n    _defineProperty(this, '_inlineSnapshots', void 0);\n\n    _defineProperty(this, '_uncheckedKeys', void 0);\n\n    _defineProperty(this, '_getBabelTraverse', void 0);\n\n    _defineProperty(this, '_getPrettier', void 0);\n\n    _defineProperty(this, 'added', void 0);\n\n    _defineProperty(this, 'expand', void 0);\n\n    _defineProperty(this, 'matched', void 0);\n\n    _defineProperty(this, 'unmatched', void 0);\n\n    _defineProperty(this, 'updated', void 0);\n\n    this._snapshotPath = snapshotPath;\n\n    const _getSnapshotData = (0, _utils.getSnapshotData)(this._snapshotPath, options.updateSnapshot),\n          data = _getSnapshotData.data,\n          dirty = _getSnapshotData.dirty;\n\n    this._initialData = data;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._getBabelTraverse = options.getBabelTraverse;\n    this._getPrettier = options.getPrettier;\n    this._inlineSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = new Map();\n    this._index = 0;\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n  }\n\n  markSnapshotsAsCheckedForTest(testName) {\n    this._uncheckedKeys.forEach(uncheckedKey => {\n      if ((0, _utils.keyToTestName)(uncheckedKey) === testName) {\n        this._uncheckedKeys.delete(uncheckedKey);\n      }\n    });\n  }\n\n  _addSnapshot(key, receivedSerialized, options) {\n    this._dirty = true;\n\n    if (options.isInline) {\n      const error = options.error || new Error();\n      const lines = (0, _jestMessageUtil.getStackTraceLines)(error.stack || '');\n      const frame = (0, _jestMessageUtil.getTopFrame)(lines);\n\n      if (!frame) {\n        throw new Error(\"Jest: Couldn't infer stack frame for inline snapshot.\");\n      }\n\n      this._inlineSnapshots.push({\n        frame,\n        snapshot: receivedSerialized\n      });\n    } else {\n      this._snapshotData[key] = receivedSerialized;\n    }\n  }\n\n  clear() {\n    this._snapshotData = this._initialData;\n    this._inlineSnapshots = [];\n    this._counters = new Map();\n    this._index = 0;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this.updated = 0;\n  }\n\n  save() {\n    const hasExternalSnapshots = Object.keys(this._snapshotData).length;\n    const hasInlineSnapshots = this._inlineSnapshots.length;\n    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;\n    const status = {\n      deleted: false,\n      saved: false\n    };\n\n    if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n      if (hasExternalSnapshots) {\n        (0, _utils.saveSnapshotFile)(this._snapshotData, this._snapshotPath);\n      }\n\n      if (hasInlineSnapshots) {\n        const prettier = this._getPrettier(); // Load lazily\n\n\n        const babelTraverse = this._getBabelTraverse(); // Load lazily\n\n\n        (0, _inline_snapshots.saveInlineSnapshots)(this._inlineSnapshots, prettier, babelTraverse);\n      }\n\n      status.saved = true;\n    } else if (!hasExternalSnapshots && jestExistsFile(this._snapshotPath)) {\n      if (this._updateSnapshot === 'all') {\n        _fs.default.unlinkSync(this._snapshotPath);\n      }\n\n      status.deleted = true;\n    }\n\n    return status;\n  }\n\n  getUncheckedCount() {\n    return this._uncheckedKeys.size || 0;\n  }\n\n  getUncheckedKeys() {\n    return Array.from(this._uncheckedKeys);\n  }\n\n  removeUncheckedKeys() {\n    if (this._updateSnapshot === 'all' && this._uncheckedKeys.size) {\n      this._dirty = true;\n\n      this._uncheckedKeys.forEach(key => delete this._snapshotData[key]);\n\n      this._uncheckedKeys.clear();\n    }\n  }\n\n  match({\n    testName,\n    received,\n    key,\n    inlineSnapshot,\n    error\n  }) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n\n    const count = Number(this._counters.get(testName));\n    const isInline = inlineSnapshot !== undefined;\n\n    if (!key) {\n      key = (0, _utils.testNameToKey)(testName, count);\n    } // Do not mark the snapshot as \"checked\" if the snapshot is inline and\n    // there's an external snapshot. This way the external snapshot can be\n    // removed with `--updateSnapshot`.\n\n\n    if (!(isInline && this._snapshotData[key])) {\n      this._uncheckedKeys.delete(key);\n    }\n\n    const receivedSerialized = (0, _utils.serialize)(received);\n    const expected = isInline ? inlineSnapshot : this._snapshotData[key];\n    const pass = expected === receivedSerialized;\n    const hasSnapshot = isInline ? inlineSnapshot !== '' : this._snapshotData[key] !== undefined;\n\n    const snapshotIsPersisted = isInline || _fs.default.existsSync(this._snapshotPath);\n\n    if (pass && !isInline) {\n      // Executing a snapshot file as JavaScript and writing the strings back\n      // when other snapshots have changed loses the proper escaping for some\n      // characters. Since we check every snapshot in every test, use the newly\n      // generated formatted string.\n      // Note that this is only relevant when a snapshot is added and the dirty\n      // flag is set.\n      this._snapshotData[key] = receivedSerialized;\n    } // These are the conditions on when to write snapshots:\n    //  * There's no snapshot file in a non-CI environment.\n    //  * There is a snapshot file and we decided to update the snapshot.\n    //  * There is a snapshot file, but it doesn't have this snaphsot.\n    // These are the conditions on when not to write snapshots:\n    //  * The update flag is set to 'none'.\n    //  * There's no snapshot file or a file without this snapshot on a CI environment.\n\n\n    if (hasSnapshot && this._updateSnapshot === 'all' || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === 'new' || this._updateSnapshot === 'all')) {\n      if (this._updateSnapshot === 'all') {\n        if (!pass) {\n          if (hasSnapshot) {\n            this.updated++;\n          } else {\n            this.added++;\n          }\n\n          this._addSnapshot(key, receivedSerialized, {\n            error,\n            isInline\n          });\n        } else {\n          this.matched++;\n        }\n      } else {\n        this._addSnapshot(key, receivedSerialized, {\n          error,\n          isInline\n        });\n\n        this.added++;\n      }\n\n      return {\n        actual: '',\n        count,\n        expected: '',\n        key,\n        pass: true\n      };\n    } else {\n      if (!pass) {\n        this.unmatched++;\n        return {\n          actual: (0, _utils.unescape)(receivedSerialized),\n          count,\n          expected: expected ? (0, _utils.unescape)(expected) : null,\n          key,\n          pass: false\n        };\n      } else {\n        this.matched++;\n        return {\n          actual: '',\n          count,\n          expected: '',\n          key,\n          pass: true\n        };\n      }\n    }\n  }\n\n  fail(testName, _received, key) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = (0, _utils.testNameToKey)(testName, count);\n    }\n\n    this._uncheckedKeys.delete(key);\n\n    this.unmatched++;\n    return key;\n  }\n\n}\n\nexports.default = SnapshotState;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-snapshot/build/State.js"],"names":["Object","defineProperty","exports","value","default","_fs","_interopRequireDefault","require","_jestMessageUtil","_utils","_inline_snapshots","obj","__esModule","Symbol","global","jestExistsFile","for","existsSync","_defineProperty","key","enumerable","configurable","writable","SnapshotState","constructor","snapshotPath","options","_snapshotPath","_getSnapshotData","getSnapshotData","updateSnapshot","data","dirty","_initialData","_snapshotData","_dirty","_getBabelTraverse","getBabelTraverse","_getPrettier","getPrettier","_inlineSnapshots","_uncheckedKeys","Set","keys","_counters","Map","_index","expand","added","matched","unmatched","_updateSnapshot","updated","markSnapshotsAsCheckedForTest","testName","forEach","uncheckedKey","keyToTestName","delete","_addSnapshot","receivedSerialized","isInline","error","Error","lines","getStackTraceLines","stack","frame","getTopFrame","push","snapshot","clear","save","hasExternalSnapshots","length","hasInlineSnapshots","isEmpty","status","deleted","saved","size","saveSnapshotFile","prettier","babelTraverse","saveInlineSnapshots","unlinkSync","getUncheckedCount","getUncheckedKeys","Array","from","removeUncheckedKeys","match","received","inlineSnapshot","set","get","count","Number","undefined","testNameToKey","serialize","expected","pass","hasSnapshot","snapshotIsPersisted","actual","unescape","fail","_received"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _utils = require('./utils');\n\nvar _inline_snapshots = require('./inline_snapshots');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile =\n  global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nclass SnapshotState {\n  // @ts-ignore\n  constructor(snapshotPath, options) {\n    _defineProperty(this, '_counters', void 0);\n\n    _defineProperty(this, '_dirty', void 0);\n\n    _defineProperty(this, '_index', void 0);\n\n    _defineProperty(this, '_updateSnapshot', void 0);\n\n    _defineProperty(this, '_snapshotData', void 0);\n\n    _defineProperty(this, '_initialData', void 0);\n\n    _defineProperty(this, '_snapshotPath', void 0);\n\n    _defineProperty(this, '_inlineSnapshots', void 0);\n\n    _defineProperty(this, '_uncheckedKeys', void 0);\n\n    _defineProperty(this, '_getBabelTraverse', void 0);\n\n    _defineProperty(this, '_getPrettier', void 0);\n\n    _defineProperty(this, 'added', void 0);\n\n    _defineProperty(this, 'expand', void 0);\n\n    _defineProperty(this, 'matched', void 0);\n\n    _defineProperty(this, 'unmatched', void 0);\n\n    _defineProperty(this, 'updated', void 0);\n\n    this._snapshotPath = snapshotPath;\n\n    const _getSnapshotData = (0, _utils.getSnapshotData)(\n        this._snapshotPath,\n        options.updateSnapshot\n      ),\n      data = _getSnapshotData.data,\n      dirty = _getSnapshotData.dirty;\n\n    this._initialData = data;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._getBabelTraverse = options.getBabelTraverse;\n    this._getPrettier = options.getPrettier;\n    this._inlineSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = new Map();\n    this._index = 0;\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n  }\n\n  markSnapshotsAsCheckedForTest(testName) {\n    this._uncheckedKeys.forEach(uncheckedKey => {\n      if ((0, _utils.keyToTestName)(uncheckedKey) === testName) {\n        this._uncheckedKeys.delete(uncheckedKey);\n      }\n    });\n  }\n\n  _addSnapshot(key, receivedSerialized, options) {\n    this._dirty = true;\n\n    if (options.isInline) {\n      const error = options.error || new Error();\n      const lines = (0, _jestMessageUtil.getStackTraceLines)(error.stack || '');\n      const frame = (0, _jestMessageUtil.getTopFrame)(lines);\n\n      if (!frame) {\n        throw new Error(\n          \"Jest: Couldn't infer stack frame for inline snapshot.\"\n        );\n      }\n\n      this._inlineSnapshots.push({\n        frame,\n        snapshot: receivedSerialized\n      });\n    } else {\n      this._snapshotData[key] = receivedSerialized;\n    }\n  }\n\n  clear() {\n    this._snapshotData = this._initialData;\n    this._inlineSnapshots = [];\n    this._counters = new Map();\n    this._index = 0;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this.updated = 0;\n  }\n\n  save() {\n    const hasExternalSnapshots = Object.keys(this._snapshotData).length;\n    const hasInlineSnapshots = this._inlineSnapshots.length;\n    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;\n    const status = {\n      deleted: false,\n      saved: false\n    };\n\n    if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n      if (hasExternalSnapshots) {\n        (0, _utils.saveSnapshotFile)(this._snapshotData, this._snapshotPath);\n      }\n\n      if (hasInlineSnapshots) {\n        const prettier = this._getPrettier(); // Load lazily\n\n        const babelTraverse = this._getBabelTraverse(); // Load lazily\n\n        (0, _inline_snapshots.saveInlineSnapshots)(\n          this._inlineSnapshots,\n          prettier,\n          babelTraverse\n        );\n      }\n\n      status.saved = true;\n    } else if (!hasExternalSnapshots && jestExistsFile(this._snapshotPath)) {\n      if (this._updateSnapshot === 'all') {\n        _fs.default.unlinkSync(this._snapshotPath);\n      }\n\n      status.deleted = true;\n    }\n\n    return status;\n  }\n\n  getUncheckedCount() {\n    return this._uncheckedKeys.size || 0;\n  }\n\n  getUncheckedKeys() {\n    return Array.from(this._uncheckedKeys);\n  }\n\n  removeUncheckedKeys() {\n    if (this._updateSnapshot === 'all' && this._uncheckedKeys.size) {\n      this._dirty = true;\n\n      this._uncheckedKeys.forEach(key => delete this._snapshotData[key]);\n\n      this._uncheckedKeys.clear();\n    }\n  }\n\n  match({testName, received, key, inlineSnapshot, error}) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n\n    const count = Number(this._counters.get(testName));\n    const isInline = inlineSnapshot !== undefined;\n\n    if (!key) {\n      key = (0, _utils.testNameToKey)(testName, count);\n    } // Do not mark the snapshot as \"checked\" if the snapshot is inline and\n    // there's an external snapshot. This way the external snapshot can be\n    // removed with `--updateSnapshot`.\n\n    if (!(isInline && this._snapshotData[key])) {\n      this._uncheckedKeys.delete(key);\n    }\n\n    const receivedSerialized = (0, _utils.serialize)(received);\n    const expected = isInline ? inlineSnapshot : this._snapshotData[key];\n    const pass = expected === receivedSerialized;\n    const hasSnapshot = isInline\n      ? inlineSnapshot !== ''\n      : this._snapshotData[key] !== undefined;\n\n    const snapshotIsPersisted =\n      isInline || _fs.default.existsSync(this._snapshotPath);\n\n    if (pass && !isInline) {\n      // Executing a snapshot file as JavaScript and writing the strings back\n      // when other snapshots have changed loses the proper escaping for some\n      // characters. Since we check every snapshot in every test, use the newly\n      // generated formatted string.\n      // Note that this is only relevant when a snapshot is added and the dirty\n      // flag is set.\n      this._snapshotData[key] = receivedSerialized;\n    } // These are the conditions on when to write snapshots:\n    //  * There's no snapshot file in a non-CI environment.\n    //  * There is a snapshot file and we decided to update the snapshot.\n    //  * There is a snapshot file, but it doesn't have this snaphsot.\n    // These are the conditions on when not to write snapshots:\n    //  * The update flag is set to 'none'.\n    //  * There's no snapshot file or a file without this snapshot on a CI environment.\n\n    if (\n      (hasSnapshot && this._updateSnapshot === 'all') ||\n      ((!hasSnapshot || !snapshotIsPersisted) &&\n        (this._updateSnapshot === 'new' || this._updateSnapshot === 'all'))\n    ) {\n      if (this._updateSnapshot === 'all') {\n        if (!pass) {\n          if (hasSnapshot) {\n            this.updated++;\n          } else {\n            this.added++;\n          }\n\n          this._addSnapshot(key, receivedSerialized, {\n            error,\n            isInline\n          });\n        } else {\n          this.matched++;\n        }\n      } else {\n        this._addSnapshot(key, receivedSerialized, {\n          error,\n          isInline\n        });\n\n        this.added++;\n      }\n\n      return {\n        actual: '',\n        count,\n        expected: '',\n        key,\n        pass: true\n      };\n    } else {\n      if (!pass) {\n        this.unmatched++;\n        return {\n          actual: (0, _utils.unescape)(receivedSerialized),\n          count,\n          expected: expected ? (0, _utils.unescape)(expected) : null,\n          key,\n          pass: false\n        };\n      } else {\n        this.matched++;\n        return {\n          actual: '',\n          count,\n          expected: '',\n          key,\n          pass: true\n        };\n      }\n    }\n  }\n\n  fail(testName, _received, key) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = (0, _utils.testNameToKey)(testName, count);\n    }\n\n    this._uncheckedKeys.delete(key);\n\n    this.unmatched++;\n    return key;\n  }\n}\n\nexports.default = SnapshotState;\n"]},"metadata":{},"sourceType":"script"}