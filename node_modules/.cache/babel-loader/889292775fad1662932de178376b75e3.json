{"ast":null,"code":"// Copyright 2014 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\nvar expect = require(\"expect.js\");\n\nvar sourceMappingURL = require(\"../\");\n\nvar comments = {\n  universal: [\"/*# sourceMappingURL=foo.js.map */\"],\n  js: [\"//# sourceMappingURL=foo.js.map\"],\n  block: [\"/*\", \"# sourceMappingURL=foo.js.map\", \"*/\"],\n  mix: [\"/*\", \"//# sourceMappingURL=foo.js.map\", \"*/\"]\n};\nvar nonTrailingComments = {\n  jsLeading: {\n    contents: [\"//# sourceMappingURL=foo.js.map\", \"(function(){})\"],\n    solution: [\"(function(){})\"]\n  },\n  mixEmbedded: {\n    contents: [\"/*! Library Name v1.0.0\", \"//# sourceMappingURL=foo.js.map\", \"*/\", \"(function(){})\"],\n    solution: [\"/*! Library Name v1.0.0\", \"*/\", \"(function(){})\"]\n  }\n};\n\nfunction forEachComment(fn) {\n  forOf(comments, function (name, comment) {\n    var description = \"the '\" + name + \"' syntax with \";\n    fn(comment.join(\"\\n\"), description + \"regular newlines\");\n    fn(comment.join(\"\\r\\n\"), description + \"Windows newlines\");\n  });\n}\n\nfunction forEachNonTrailingComment(fn) {\n  forOf(nonTrailingComments, function (name, comment) {\n    var description = \"the '\" + name + \"' syntax with \";\n    fn({\n      contents: comment.contents.join(\"\\n\"),\n      solution: comment.solution.join(\"\\n\")\n    }, description + \"regular newlines\");\n    fn({\n      contents: comment.contents.join(\"\\r\\n\"),\n      solution: comment.solution.join(\"\\r\\n\")\n    }, description + \"Windows newlines\");\n  });\n}\n\nfunction forOf(obj, fn) {\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      fn(key, obj[key]);\n    }\n  }\n}\n\ndescribe(\"sourceMappingURL\", function () {\n  describe(\".getFrom\", function () {\n    forEachComment(function (comment, description) {\n      it(\"gets the url from \" + description, function () {\n        expect(sourceMappingURL.getFrom(\"code\\n\" + comment)).to.equal(\"foo.js.map\");\n        expect(sourceMappingURL.getFrom(\"code\" + comment)).to.equal(\"foo.js.map\");\n        expect(sourceMappingURL.getFrom(comment)).to.equal(\"foo.js.map\");\n      });\n    });\n    forEachNonTrailingComment(function (comment, description) {\n      it(\"gets the url from \" + description, function () {\n        expect(sourceMappingURL.getFrom(\"code\\n\" + comment.contents)).to.equal(\"foo.js.map\");\n        expect(sourceMappingURL.getFrom(\"code\" + comment.contents)).to.equal(\"foo.js.map\");\n        expect(sourceMappingURL.getFrom(comment.contents)).to.equal(\"foo.js.map\");\n      });\n    });\n    it(\"returns null if no comment\", function () {\n      expect(sourceMappingURL.getFrom(\"code\")).to.equal(null);\n    });\n    it(\"can return an empty string as url\", function () {\n      expect(sourceMappingURL.getFrom(\"/*# sourceMappingURL= */\")).to.equal(\"\");\n    });\n    it(\"is detachable\", function () {\n      var get = sourceMappingURL.getFrom;\n      expect(get(\"/*# sourceMappingURL=foo */\")).to.equal(\"foo\");\n    });\n  });\n  describe(\".existsIn\", function () {\n    forEachComment(function (comment, description) {\n      it(\"returns true for \" + description, function () {\n        expect(sourceMappingURL.existsIn(\"code\\n\" + comment)).to.equal(true);\n        expect(sourceMappingURL.existsIn(\"code\" + comment)).to.equal(true);\n        expect(sourceMappingURL.existsIn(comment)).to.equal(true);\n      });\n    });\n    forEachNonTrailingComment(function (comment, description) {\n      it(\"returns true for \" + description, function () {\n        expect(sourceMappingURL.existsIn(\"code\\n\" + comment.contents)).to.equal(true);\n        expect(sourceMappingURL.existsIn(\"code\" + comment.contents)).to.equal(true);\n        expect(sourceMappingURL.existsIn(comment.contents)).to.equal(true);\n      });\n    });\n    it(\"returns false if no comment\", function () {\n      expect(sourceMappingURL.existsIn(\"code\")).to.equal(false);\n    });\n    it(\"is detachable\", function () {\n      var has = sourceMappingURL.existsIn;\n      expect(has(\"/*# sourceMappingURL=foo */\")).to.equal(true);\n    });\n  });\n  describe(\".removeFrom\", function () {\n    forEachComment(function (comment, description) {\n      it(\"removes the comment for \" + description, function () {\n        expect(sourceMappingURL.removeFrom(\"code\\n\" + comment)).to.equal(\"code\\n\");\n        expect(sourceMappingURL.removeFrom(\"code\" + comment)).to.equal(\"code\");\n        expect(sourceMappingURL.removeFrom(comment)).to.equal(\"\");\n      });\n    });\n    forEachNonTrailingComment(function (comment, description) {\n      it(\"removes the comment for \" + description, function () {\n        expect(sourceMappingURL.removeFrom(\"code\\n\" + comment.contents)).to.equal(\"code\\n\" + comment.solution);\n        expect(sourceMappingURL.removeFrom(\"code\" + comment.contents)).to.equal(\"code\" + comment.solution);\n        expect(sourceMappingURL.removeFrom(comment.contents)).to.equal(comment.solution);\n      });\n    });\n    it(\"does nothing if no comment\", function () {\n      expect(sourceMappingURL.removeFrom(\"code\\n\")).to.equal(\"code\\n\");\n    });\n    it(\"is detachable\", function () {\n      var remove = sourceMappingURL.removeFrom;\n      expect(remove(\"/*# sourceMappingURL=foo */\")).to.equal(\"\");\n    });\n  });\n  describe(\".insertBefore\", function () {\n    forEachComment(function (comment, description) {\n      it(\"inserts a string before the comment for \" + description, function () {\n        expect(sourceMappingURL.insertBefore(\"code\\n\" + comment, \"more code\\n\")).to.equal(\"code\\nmore code\\n\" + comment);\n        expect(sourceMappingURL.insertBefore(\"code\" + comment, \"\\nmore code\")).to.equal(\"code\\nmore code\" + comment);\n        expect(sourceMappingURL.insertBefore(comment, \"some code\")).to.equal(\"some code\" + comment);\n      });\n    });\n    it(\"inserts a string before an embedded comment\", function () {\n      expect(sourceMappingURL.insertBefore(\"/*! Library Name v1.0.0\\n\" + \"//# sourceMappingURL=foo.js.map\\n*/\\n(function(){})\", \"code\\n\")).to.equal(\"/*! Library Name v1.0.0\\ncode\\n\" + \"//# sourceMappingURL=foo.js.map\\n*/\\n(function(){})\");\n    });\n    it(\"inserts a string before a leading comment\", function () {\n      expect(sourceMappingURL.insertBefore(\"//# sourceMappingURL=foo.js.map\\n\" + \"(function(){})\", \"code\\n\")).to.equal(\"code\\n//# sourceMappingURL=foo.js.map\\n\" + \"(function(){})\");\n    });\n    it(\"appends if no comment\", function () {\n      expect(sourceMappingURL.insertBefore(\"code\", \"\\nmore code\")).to.equal(\"code\\nmore code\");\n    });\n    it(\"is detachable\", function () {\n      var insertBefore = sourceMappingURL.insertBefore;\n      expect(insertBefore(\"/*# sourceMappingURL=foo */\", \"bar\")).to.equal(\"bar/*# sourceMappingURL=foo */\");\n    });\n  });\n  describe(\".regex\", function () {\n    it(\"includes ._innerRegex\", function () {\n      expect(sourceMappingURL.regex.source).to.contain(sourceMappingURL._innerRegex.source);\n    });\n\n    var match = function (code) {\n      expect(code).to.match(sourceMappingURL.regex);\n    };\n\n    var noMatch = function (code) {\n      expect(code).not.to.match(sourceMappingURL.regex);\n    };\n\n    forEachComment(function (comment, description) {\n      it(\"matches \" + description, function () {\n        match(\"code\\n\" + comment);\n        match(\"code\" + comment);\n        match(comment);\n      });\n      it(\"matches \" + description + \", with trailing whitespace\", function () {\n        match(comment + \"  \");\n        match(comment + \"\\n\");\n        match(comment + \"\\n\\n\\t\\n    \\t  \");\n      });\n    });\n    it(\"does not match some cases that are easy to mess up\", function () {\n      noMatch(\"/* # sourceMappingURL=foo */\");\n      noMatch(\"// # sourceMappingURL=foo\");\n    });\n    it(\"is liberal regarding inner whitespace\", function () {\n      match(\"/*# sourceMappingURL=foo*/\");\n      match(\"/*# sourceMappingURL=foo    */\");\n      match(\"/*# sourceMappingURL=foo   \\t\\n\" + \"*/\");\n      match(\"/*    \\n\" + \"# sourceMappingURL=foo\\n\" + \"*/\");\n      match(\"/*\\n\" + \"# sourceMappingURL=foo\\n\" + \"     */\");\n      match(\"/*\\n\" + \"# sourceMappingURL=foo\\n\" + \"\\n\" + \"\\t\\n\" + \"*/\");\n    });\n  });\n  describe(\"._innerRegex\", function () {\n    it(\"matches the contents of sourceMappingURL comments\", function () {\n      expect(\"# sourceMappingURL=http://www.example.com/foo/bar.js.map\").to.match(sourceMappingURL._innerRegex);\n    });\n    it(\"captures the url in the first capture group\", function () {\n      expect(sourceMappingURL._innerRegex.exec(\"# sourceMappingURL=foo\")[1]).to.equal(\"foo\");\n    });\n    it(\"supports the legacy syntax\", function () {\n      expect(\"@ sourceMappingURL=http://www.example.com/foo/bar.js.map\").to.match(sourceMappingURL._innerRegex);\n    });\n  });\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/source-map-url/test/source-map-url.js"],"names":["expect","require","sourceMappingURL","comments","universal","js","block","mix","nonTrailingComments","jsLeading","contents","solution","mixEmbedded","forEachComment","fn","forOf","name","comment","description","join","forEachNonTrailingComment","obj","key","Object","prototype","hasOwnProperty","call","describe","it","getFrom","to","equal","get","existsIn","has","removeFrom","remove","insertBefore","regex","source","contain","_innerRegex","match","code","noMatch","not","exec"],"mappings":"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","sourcesContent":["// Copyright 2014 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\n\nvar expect = require(\"expect.js\")\n\nvar sourceMappingURL = require(\"../\")\n\nvar comments = {\n\n  universal: [\n    \"/*# sourceMappingURL=foo.js.map */\"\n  ],\n\n  js: [\n    \"//# sourceMappingURL=foo.js.map\"\n  ],\n\n  block: [\n    \"/*\",\n    \"# sourceMappingURL=foo.js.map\",\n    \"*/\"\n  ],\n\n  mix: [\n    \"/*\",\n    \"//# sourceMappingURL=foo.js.map\",\n    \"*/\"\n  ]\n\n}\n\nvar nonTrailingComments = {\n\n  jsLeading: {\n    contents: [\n      \"//# sourceMappingURL=foo.js.map\",\n      \"(function(){})\"\n    ],\n    solution: [\n      \"(function(){})\"\n    ]\n  },\n\n  mixEmbedded: {\n    contents: [\n      \"/*! Library Name v1.0.0\",\n      \"//# sourceMappingURL=foo.js.map\",\n      \"*/\",\n      \"(function(){})\"\n    ],\n    solution: [\n      \"/*! Library Name v1.0.0\",\n      \"*/\",\n      \"(function(){})\"\n    ]\n  }\n\n}\n\nfunction forEachComment(fn) {\n  forOf(comments, function(name, comment) {\n    var description = \"the '\" + name + \"' syntax with \"\n    fn(comment.join(\"\\n\"),   description + \"regular newlines\")\n    fn(comment.join(\"\\r\\n\"), description + \"Windows newlines\")\n  })\n}\n\nfunction forEachNonTrailingComment(fn) {\n  forOf(nonTrailingComments, function(name, comment) {\n\n    var description = \"the '\" + name + \"' syntax with \"\n\n    fn({\n      contents: comment.contents.join(\"\\n\"),\n      solution: comment.solution.join(\"\\n\")\n    }, description + \"regular newlines\")\n\n    fn({\n      contents: comment.contents.join(\"\\r\\n\"),\n      solution: comment.solution.join(\"\\r\\n\")\n    }, description + \"Windows newlines\")\n  })\n}\n\nfunction forOf(obj, fn) {\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      fn(key, obj[key])\n    }\n  }\n}\n\n\ndescribe(\"sourceMappingURL\", function() {\n\n  describe(\".getFrom\", function() {\n\n    forEachComment(function(comment, description) {\n\n      it(\"gets the url from \" + description, function() {\n        expect(sourceMappingURL.getFrom(\"code\\n\" + comment))\n          .to.equal(\"foo.js.map\")\n\n        expect(sourceMappingURL.getFrom(\"code\" + comment))\n          .to.equal(\"foo.js.map\")\n\n        expect(sourceMappingURL.getFrom(comment))\n          .to.equal(\"foo.js.map\")\n      })\n\n    })\n\n    forEachNonTrailingComment(function(comment, description) {\n\n      it(\"gets the url from \" + description, function() {\n        expect(sourceMappingURL.getFrom(\"code\\n\" + comment.contents))\n          .to.equal(\"foo.js.map\")\n\n        expect(sourceMappingURL.getFrom(\"code\" + comment.contents))\n          .to.equal(\"foo.js.map\")\n\n        expect(sourceMappingURL.getFrom(comment.contents))\n          .to.equal(\"foo.js.map\")\n      })\n\n    })\n\n\n    it(\"returns null if no comment\", function() {\n      expect(sourceMappingURL.getFrom(\"code\"))\n        .to.equal(null)\n    })\n\n\n    it(\"can return an empty string as url\", function() {\n      expect(sourceMappingURL.getFrom(\"/*# sourceMappingURL= */\"))\n        .to.equal(\"\")\n    })\n\n\n    it(\"is detachable\", function() {\n      var get = sourceMappingURL.getFrom\n      expect(get(\"/*# sourceMappingURL=foo */\"))\n        .to.equal(\"foo\")\n    })\n\n  })\n\n\n  describe(\".existsIn\", function() {\n\n    forEachComment(function(comment, description) {\n\n      it(\"returns true for \" + description, function() {\n        expect(sourceMappingURL.existsIn(\"code\\n\" + comment))\n          .to.equal(true)\n\n        expect(sourceMappingURL.existsIn(\"code\" + comment))\n          .to.equal(true)\n\n        expect(sourceMappingURL.existsIn(comment))\n          .to.equal(true)\n      })\n\n    })\n\n    forEachNonTrailingComment(function(comment, description) {\n\n      it(\"returns true for \" + description, function() {\n        expect(sourceMappingURL.existsIn(\"code\\n\" + comment.contents))\n          .to.equal(true)\n\n        expect(sourceMappingURL.existsIn(\"code\" + comment.contents))\n          .to.equal(true)\n\n        expect(sourceMappingURL.existsIn(comment.contents))\n          .to.equal(true)\n      })\n\n    })\n\n\n    it(\"returns false if no comment\", function() {\n      expect(sourceMappingURL.existsIn(\"code\"))\n        .to.equal(false)\n    })\n\n\n    it(\"is detachable\", function() {\n      var has = sourceMappingURL.existsIn\n      expect(has(\"/*# sourceMappingURL=foo */\"))\n        .to.equal(true)\n    })\n\n  })\n\n\n  describe(\".removeFrom\", function() {\n\n    forEachComment(function(comment, description) {\n\n      it(\"removes the comment for \" + description, function() {\n        expect(sourceMappingURL.removeFrom(\"code\\n\" + comment))\n          .to.equal(\"code\\n\")\n\n        expect(sourceMappingURL.removeFrom(\"code\" + comment))\n          .to.equal(\"code\")\n\n        expect(sourceMappingURL.removeFrom(comment))\n          .to.equal(\"\")\n      })\n\n    })\n\n    forEachNonTrailingComment(function(comment, description) {\n\n      it(\"removes the comment for \" + description, function() {\n        expect(sourceMappingURL.removeFrom(\"code\\n\" + comment.contents))\n          .to.equal(\"code\\n\" + comment.solution)\n\n        expect(sourceMappingURL.removeFrom(\"code\" + comment.contents))\n          .to.equal(\"code\" + comment.solution)\n\n        expect(sourceMappingURL.removeFrom(comment.contents))\n          .to.equal(comment.solution)\n      })\n\n    })\n\n\n    it(\"does nothing if no comment\", function() {\n      expect(sourceMappingURL.removeFrom(\"code\\n\"))\n        .to.equal(\"code\\n\")\n    })\n\n\n    it(\"is detachable\", function() {\n      var remove = sourceMappingURL.removeFrom\n      expect(remove(\"/*# sourceMappingURL=foo */\"))\n        .to.equal(\"\")\n    })\n\n  })\n\n\n  describe(\".insertBefore\", function() {\n\n    forEachComment(function(comment, description) {\n\n      it(\"inserts a string before the comment for \" + description, function() {\n        expect(sourceMappingURL.insertBefore(\"code\\n\" + comment, \"more code\\n\"))\n          .to.equal(\"code\\nmore code\\n\" + comment)\n\n        expect(sourceMappingURL.insertBefore(\"code\" + comment, \"\\nmore code\"))\n          .to.equal(\"code\\nmore code\" + comment)\n\n        expect(sourceMappingURL.insertBefore(comment, \"some code\"))\n          .to.equal(\"some code\" + comment)\n      })\n\n    })\n\n\n    it(\"inserts a string before an embedded comment\", function() {\n      expect(sourceMappingURL.insertBefore(\"/*! Library Name v1.0.0\\n\" +\n        \"//# sourceMappingURL=foo.js.map\\n*/\\n(function(){})\", \"code\\n\"))\n        .to.equal(\"/*! Library Name v1.0.0\\ncode\\n\" +\n          \"//# sourceMappingURL=foo.js.map\\n*/\\n(function(){})\")\n    })\n\n\n    it(\"inserts a string before a leading comment\", function() {\n      expect(sourceMappingURL.insertBefore(\"//# sourceMappingURL=foo.js.map\\n\" +\n        \"(function(){})\", \"code\\n\"))\n        .to.equal(\"code\\n//# sourceMappingURL=foo.js.map\\n\" +\n          \"(function(){})\")\n    })\n\n\n    it(\"appends if no comment\", function() {\n      expect(sourceMappingURL.insertBefore(\"code\", \"\\nmore code\"))\n        .to.equal(\"code\\nmore code\")\n    })\n\n\n    it(\"is detachable\", function() {\n      var insertBefore = sourceMappingURL.insertBefore\n      expect(insertBefore(\"/*# sourceMappingURL=foo */\", \"bar\"))\n        .to.equal(\"bar/*# sourceMappingURL=foo */\")\n    })\n\n  })\n\n\n  describe(\".regex\", function() {\n\n    it(\"includes ._innerRegex\", function() {\n      expect(sourceMappingURL.regex.source)\n        .to.contain(sourceMappingURL._innerRegex.source)\n    })\n\n\n    var match = function(code) {\n      expect(code)\n        .to.match(sourceMappingURL.regex)\n    }\n\n    var noMatch = function(code) {\n      expect(code)\n        .not.to.match(sourceMappingURL.regex)\n    }\n\n\n    forEachComment(function(comment, description) {\n\n      it(\"matches \" + description, function() {\n        match(\"code\\n\" + comment)\n        match(\"code\" + comment)\n        match(comment)\n      })\n\n\n      it(\"matches \" + description + \", with trailing whitespace\", function() {\n        match(comment + \"  \")\n        match(comment + \"\\n\")\n        match(comment + \"\\n\\n\\t\\n    \\t  \")\n      })\n\n    })\n\n\n    it(\"does not match some cases that are easy to mess up\", function() {\n      noMatch(\n        \"/* # sourceMappingURL=foo */\"\n      )\n\n      noMatch(\n        \"// # sourceMappingURL=foo\"\n      )\n    })\n\n\n    it(\"is liberal regarding inner whitespace\", function() {\n      match(\n        \"/*# sourceMappingURL=foo*/\"\n      )\n\n      match(\n        \"/*# sourceMappingURL=foo    */\"\n      )\n\n      match(\n        \"/*# sourceMappingURL=foo   \\t\\n\" +\n        \"*/\"\n      )\n\n      match(\n        \"/*    \\n\" +\n        \"# sourceMappingURL=foo\\n\" +\n        \"*/\"\n      )\n\n      match(\n        \"/*\\n\" +\n        \"# sourceMappingURL=foo\\n\" +\n        \"     */\"\n      )\n\n      match(\n        \"/*\\n\" +\n        \"# sourceMappingURL=foo\\n\" +\n        \"\\n\" +\n        \"\\t\\n\" +\n        \"*/\"\n      )\n    })\n\n  })\n\n\n  describe(\"._innerRegex\", function() {\n\n    it(\"matches the contents of sourceMappingURL comments\", function() {\n      expect(\"# sourceMappingURL=http://www.example.com/foo/bar.js.map\")\n        .to.match(sourceMappingURL._innerRegex)\n    })\n\n\n    it(\"captures the url in the first capture group\", function() {\n      expect(sourceMappingURL._innerRegex.exec(\"# sourceMappingURL=foo\")[1])\n        .to.equal(\"foo\")\n    })\n\n\n    it(\"supports the legacy syntax\", function() {\n      expect(\"@ sourceMappingURL=http://www.example.com/foo/bar.js.map\")\n        .to.match(sourceMappingURL._innerRegex)\n    })\n\n  })\n\n})\n"]},"metadata":{},"sourceType":"script"}