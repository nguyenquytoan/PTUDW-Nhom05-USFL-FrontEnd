{"ast":null,"code":"/**\n * @fileoverview Rule to enforce grouped require statements for Node.JS\n * @author Raphael Pigulla\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `require` calls to be mixed with regular variable declarations\",\n      category: \"Node.js and CommonJS\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-requires\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"boolean\"\n      }, {\n        type: \"object\",\n        properties: {\n          grouping: {\n            type: \"boolean\"\n          },\n          allowCall: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let grouping = false,\n        allowCall = false;\n\n    if (typeof options === \"object\") {\n      grouping = options.grouping;\n      allowCall = options.allowCall;\n    } else {\n      grouping = !!options;\n    }\n    /**\n     * Returns the list of built-in modules.\n     * @returns {string[]} An array of built-in Node.js modules.\n     */\n\n\n    function getBuiltinModules() {\n      /*\n       * This list is generated using:\n       * `require(\"repl\")._builtinLibs.concat('repl').sort()`\n       * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\n       */\n      return [\"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\", \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\", \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\", \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\", \"url\", \"util\", \"v8\", \"vm\", \"zlib\"];\n    }\n\n    const BUILTIN_MODULES = getBuiltinModules();\n    const DECL_REQUIRE = \"require\",\n          DECL_UNINITIALIZED = \"uninitialized\",\n          DECL_OTHER = \"other\";\n    const REQ_CORE = \"core\",\n          REQ_FILE = \"file\",\n          REQ_MODULE = \"module\",\n          REQ_COMPUTED = \"computed\";\n    /**\n     * Determines the type of a declaration statement.\n     * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n     * @returns {string} The type of declaration represented by the expression.\n     */\n\n    function getDeclarationType(initExpression) {\n      if (!initExpression) {\n        // \"var x;\"\n        return DECL_UNINITIALIZED;\n      }\n\n      if (initExpression.type === \"CallExpression\" && initExpression.callee.type === \"Identifier\" && initExpression.callee.name === \"require\") {\n        // \"var x = require('util');\"\n        return DECL_REQUIRE;\n      }\n\n      if (allowCall && initExpression.type === \"CallExpression\" && initExpression.callee.type === \"CallExpression\") {\n        // \"var x = require('diagnose')('sub-module');\"\n        return getDeclarationType(initExpression.callee);\n      }\n\n      if (initExpression.type === \"MemberExpression\") {\n        // \"var x = require('glob').Glob;\"\n        return getDeclarationType(initExpression.object);\n      } // \"var x = 42;\"\n\n\n      return DECL_OTHER;\n    }\n    /**\n     * Determines the type of module that is loaded via require.\n     * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n     * @returns {string} The module type.\n     */\n\n\n    function inferModuleType(initExpression) {\n      if (initExpression.type === \"MemberExpression\") {\n        // \"var x = require('glob').Glob;\"\n        return inferModuleType(initExpression.object);\n      }\n\n      if (initExpression.arguments.length === 0) {\n        // \"var x = require();\"\n        return REQ_COMPUTED;\n      }\n\n      const arg = initExpression.arguments[0];\n\n      if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n        // \"var x = require(42);\"\n        return REQ_COMPUTED;\n      }\n\n      if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n        // \"var fs = require('fs');\"\n        return REQ_CORE;\n      }\n\n      if (/^\\.{0,2}\\//u.test(arg.value)) {\n        // \"var utils = require('./utils');\"\n        return REQ_FILE;\n      } // \"var async = require('async');\"\n\n\n      return REQ_MODULE;\n    }\n    /**\n     * Check if the list of variable declarations is mixed, i.e. whether it\n     * contains both require and other declarations.\n     * @param {ASTNode} declarations The list of VariableDeclarators.\n     * @returns {boolean} True if the declarations are mixed, false if not.\n     */\n\n\n    function isMixed(declarations) {\n      const contains = {};\n      declarations.forEach(declaration => {\n        const type = getDeclarationType(declaration.init);\n        contains[type] = true;\n      });\n      return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));\n    }\n    /**\n     * Check if all require declarations in the given list are of the same\n     * type.\n     * @param {ASTNode} declarations The list of VariableDeclarators.\n     * @returns {boolean} True if the declarations are grouped, false if not.\n     */\n\n\n    function isGrouped(declarations) {\n      const found = {};\n      declarations.forEach(declaration => {\n        if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n          found[inferModuleType(declaration.init)] = true;\n        }\n      });\n      return Object.keys(found).length <= 1;\n    }\n\n    return {\n      VariableDeclaration(node) {\n        if (isMixed(node.declarations)) {\n          context.report({\n            node,\n            message: \"Do not mix 'require' and other declarations.\"\n          });\n        } else if (grouping && !isGrouped(node.declarations)) {\n          context.report({\n            node,\n            message: \"Do not mix core, module, file and computed requires.\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-mixed-requires.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","properties","grouping","allowCall","additionalProperties","create","context","options","getBuiltinModules","BUILTIN_MODULES","DECL_REQUIRE","DECL_UNINITIALIZED","DECL_OTHER","REQ_CORE","REQ_FILE","REQ_MODULE","REQ_COMPUTED","getDeclarationType","initExpression","callee","name","object","inferModuleType","arguments","length","arg","value","indexOf","test","isMixed","declarations","contains","forEach","declaration","init","isGrouped","found","Object","keys","VariableDeclaration","node","report","message"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce grouped require statements for Node.JS\n * @author Raphael Pigulla\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `require` calls to be mixed with regular variable declarations\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-requires\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"boolean\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            grouping: {\n                                type: \"boolean\"\n                            },\n                            allowCall: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let grouping = false,\n            allowCall = false;\n\n        if (typeof options === \"object\") {\n            grouping = options.grouping;\n            allowCall = options.allowCall;\n        } else {\n            grouping = !!options;\n        }\n\n        /**\n         * Returns the list of built-in modules.\n         * @returns {string[]} An array of built-in Node.js modules.\n         */\n        function getBuiltinModules() {\n\n            /*\n             * This list is generated using:\n             * `require(\"repl\")._builtinLibs.concat('repl').sort()`\n             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\n             */\n            return [\n                \"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\",\n                \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\",\n                \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\",\n                \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\",\n                \"url\", \"util\", \"v8\", \"vm\", \"zlib\"\n            ];\n        }\n\n        const BUILTIN_MODULES = getBuiltinModules();\n\n        const DECL_REQUIRE = \"require\",\n            DECL_UNINITIALIZED = \"uninitialized\",\n            DECL_OTHER = \"other\";\n\n        const REQ_CORE = \"core\",\n            REQ_FILE = \"file\",\n            REQ_MODULE = \"module\",\n            REQ_COMPUTED = \"computed\";\n\n        /**\n         * Determines the type of a declaration statement.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The type of declaration represented by the expression.\n         */\n        function getDeclarationType(initExpression) {\n            if (!initExpression) {\n\n                // \"var x;\"\n                return DECL_UNINITIALIZED;\n            }\n\n            if (initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"Identifier\" &&\n                initExpression.callee.name === \"require\"\n            ) {\n\n                // \"var x = require('util');\"\n                return DECL_REQUIRE;\n            }\n            if (allowCall &&\n                initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"CallExpression\"\n            ) {\n\n                // \"var x = require('diagnose')('sub-module');\"\n                return getDeclarationType(initExpression.callee);\n            }\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return getDeclarationType(initExpression.object);\n            }\n\n            // \"var x = 42;\"\n            return DECL_OTHER;\n        }\n\n        /**\n         * Determines the type of module that is loaded via require.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The module type.\n         */\n        function inferModuleType(initExpression) {\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return inferModuleType(initExpression.object);\n            }\n            if (initExpression.arguments.length === 0) {\n\n                // \"var x = require();\"\n                return REQ_COMPUTED;\n            }\n\n            const arg = initExpression.arguments[0];\n\n            if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n\n                // \"var x = require(42);\"\n                return REQ_COMPUTED;\n            }\n\n            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n\n                // \"var fs = require('fs');\"\n                return REQ_CORE;\n            }\n            if (/^\\.{0,2}\\//u.test(arg.value)) {\n\n                // \"var utils = require('./utils');\"\n                return REQ_FILE;\n            }\n\n            // \"var async = require('async');\"\n            return REQ_MODULE;\n\n        }\n\n        /**\n         * Check if the list of variable declarations is mixed, i.e. whether it\n         * contains both require and other declarations.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are mixed, false if not.\n         */\n        function isMixed(declarations) {\n            const contains = {};\n\n            declarations.forEach(declaration => {\n                const type = getDeclarationType(declaration.init);\n\n                contains[type] = true;\n            });\n\n            return !!(\n                contains[DECL_REQUIRE] &&\n                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])\n            );\n        }\n\n        /**\n         * Check if all require declarations in the given list are of the same\n         * type.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are grouped, false if not.\n         */\n        function isGrouped(declarations) {\n            const found = {};\n\n            declarations.forEach(declaration => {\n                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n                    found[inferModuleType(declaration.init)] = true;\n                }\n            });\n\n            return Object.keys(found).length <= 1;\n        }\n\n\n        return {\n\n            VariableDeclaration(node) {\n\n                if (isMixed(node.declarations)) {\n                    context.report({ node, message: \"Do not mix 'require' and other declarations.\" });\n                } else if (grouping && !isGrouped(node.declarations)) {\n                    context.report({ node, message: \"Do not mix core, module, file and computed requires.\" });\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}