{"ast":null,"code":"var SyntaxReferenceError = require('./error').SyntaxReferenceError;\n\nvar MatchError = require('./error').MatchError;\n\nvar names = require('../utils/names');\n\nvar generic = require('./generic');\n\nvar parse = require('../definition-syntax/parse');\n\nvar generate = require('../definition-syntax/generate');\n\nvar walk = require('../definition-syntax/walk');\n\nvar prepareTokens = require('./prepare-tokens');\n\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\n\nvar matchAsTree = require('./match').matchAsTree;\n\nvar trace = require('./trace');\n\nvar search = require('./search');\n\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\n\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n  var result = {};\n\n  for (var name in map) {\n    if (map[name].syntax) {\n      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, {\n        compact: compact\n      });\n    }\n  }\n\n  return result;\n}\n\nfunction valueHasVar(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].value.toLowerCase() === 'var(') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction buildMatchResult(match, error, iterations) {\n  return {\n    matched: match,\n    iterations: iterations,\n    error: error,\n    getTrace: trace.getTrace,\n    isType: trace.isType,\n    isProperty: trace.isProperty,\n    isKeyword: trace.isKeyword\n  };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n  var tokens = prepareTokens(value, lexer.syntax);\n  var result;\n\n  if (valueHasVar(tokens)) {\n    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n  }\n\n  if (useCommon) {\n    result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n  }\n\n  if (!useCommon || !result.match) {\n    result = matchAsTree(tokens, syntax.match, lexer);\n\n    if (!result.match) {\n      return buildMatchResult(null, new MatchError(result.reason, syntax.syntax, value, result), result.iterations);\n    }\n  }\n\n  return buildMatchResult(result.match, null, result.iterations);\n}\n\nvar Lexer = function (config, syntax, structure) {\n  this.valueCommonSyntax = cssWideKeywords;\n  this.syntax = syntax;\n  this.generic = false;\n  this.atrules = {};\n  this.properties = {};\n  this.types = {};\n  this.structure = structure || getStructureFromConfig(config);\n\n  if (config) {\n    if (config.types) {\n      for (var name in config.types) {\n        this.addType_(name, config.types[name]);\n      }\n    }\n\n    if (config.generic) {\n      this.generic = true;\n\n      for (var name in generic) {\n        this.addType_(name, generic[name]);\n      }\n    }\n\n    if (config.atrules) {\n      for (var name in config.atrules) {\n        this.addAtrule_(name, config.atrules[name]);\n      }\n    }\n\n    if (config.properties) {\n      for (var name in config.properties) {\n        this.addProperty_(name, config.properties[name]);\n      }\n    }\n  }\n};\n\nLexer.prototype = {\n  structure: {},\n  checkStructure: function (ast) {\n    function collectWarning(node, message) {\n      warns.push({\n        node: node,\n        message: message\n      });\n    }\n\n    var structure = this.structure;\n    var warns = [];\n    this.syntax.walk(ast, function (node) {\n      if (structure.hasOwnProperty(node.type)) {\n        structure[node.type].check(node, collectWarning);\n      } else {\n        collectWarning(node, 'Unknown node type `' + node.type + '`');\n      }\n    });\n    return warns.length ? warns : false;\n  },\n  createDescriptor: function (syntax, type, name) {\n    var ref = {\n      type: type,\n      name: name\n    };\n    var descriptor = {\n      type: type,\n      name: name,\n      syntax: null,\n      match: null\n    };\n\n    if (typeof syntax === 'function') {\n      descriptor.match = buildMatchGraph(syntax, ref);\n    } else {\n      if (typeof syntax === 'string') {\n        // lazy parsing on first access\n        Object.defineProperty(descriptor, 'syntax', {\n          get: function () {\n            Object.defineProperty(descriptor, 'syntax', {\n              value: parse(syntax)\n            });\n            return descriptor.syntax;\n          }\n        });\n      } else {\n        descriptor.syntax = syntax;\n      } // lazy graph build on first access\n\n\n      Object.defineProperty(descriptor, 'match', {\n        get: function () {\n          Object.defineProperty(descriptor, 'match', {\n            value: buildMatchGraph(descriptor.syntax, ref)\n          });\n          return descriptor.match;\n        }\n      });\n    }\n\n    return descriptor;\n  },\n  addAtrule_: function (name, syntax) {\n    this.atrules[name] = {\n      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, name) => {\n        res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);\n        return res;\n      }, {}) : null\n    };\n  },\n  addProperty_: function (name, syntax) {\n    this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n  },\n  addType_: function (name, syntax) {\n    this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n    if (syntax === generic['-ms-legacy-expression']) {\n      this.valueCommonSyntax = cssWideKeywordsWithExpression;\n    }\n  },\n  matchAtrulePrelude: function (atruleName, prelude) {\n    var atrule = names.keyword(atruleName);\n    var atrulePreludeSyntax = atrule.vendor ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename) : this.getAtrulePrelude(atrule.name);\n\n    if (!atrulePreludeSyntax) {\n      if (atrule.basename in this.atrules) {\n        return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));\n      }\n\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule', atruleName));\n    }\n\n    return matchSyntax(this, atrulePreludeSyntax, prelude, true);\n  },\n  matchAtruleDescriptor: function (atruleName, descriptorName, value) {\n    var atrule = names.keyword(atruleName);\n    var descriptor = names.keyword(descriptorName);\n    var atruleEntry = atrule.vendor ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];\n\n    if (!atruleEntry) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule', atruleName));\n    }\n\n    if (!atruleEntry.descriptors) {\n      return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));\n    }\n\n    var atruleDescriptorSyntax = descriptor.vendor ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename] : atruleEntry.descriptors[descriptor.name];\n\n    if (!atruleDescriptorSyntax) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName));\n    }\n\n    return matchSyntax(this, atruleDescriptorSyntax, value, true);\n  },\n  matchDeclaration: function (node) {\n    if (node.type !== 'Declaration') {\n      return buildMatchResult(null, new Error('Not a Declaration node'));\n    }\n\n    return this.matchProperty(node.property, node.value);\n  },\n  matchProperty: function (propertyName, value) {\n    var property = names.property(propertyName); // don't match syntax for a custom property\n\n    if (property.custom) {\n      return buildMatchResult(null, new Error('Lexer matching doesn\\'t applicable for custom properties'));\n    }\n\n    var propertySyntax = property.vendor ? this.getProperty(property.name) || this.getProperty(property.basename) : this.getProperty(property.name);\n\n    if (!propertySyntax) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));\n    }\n\n    return matchSyntax(this, propertySyntax, value, true);\n  },\n  matchType: function (typeName, value) {\n    var typeSyntax = this.getType(typeName);\n\n    if (!typeSyntax) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n    }\n\n    return matchSyntax(this, typeSyntax, value, false);\n  },\n  match: function (syntax, value) {\n    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n      return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n    }\n\n    if (typeof syntax === 'string' || !syntax.match) {\n      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n    }\n\n    return matchSyntax(this, syntax, value, false);\n  },\n  findValueFragments: function (propertyName, value, type, name) {\n    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n  },\n  findDeclarationValueFragments: function (declaration, type, name) {\n    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n  },\n  findAllFragments: function (ast, type, name) {\n    var result = [];\n    this.syntax.walk(ast, {\n      visit: 'Declaration',\n      enter: function (declaration) {\n        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n      }.bind(this)\n    });\n    return result;\n  },\n  getAtrulePrelude: function (atruleName) {\n    return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;\n  },\n  getAtruleDescriptor: function (atruleName, name) {\n    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;\n  },\n  getProperty: function (name) {\n    return this.properties.hasOwnProperty(name) ? this.properties[name] : null;\n  },\n  getType: function (name) {\n    return this.types.hasOwnProperty(name) ? this.types[name] : null;\n  },\n  validate: function () {\n    function validate(syntax, name, broken, descriptor) {\n      if (broken.hasOwnProperty(name)) {\n        return broken[name];\n      }\n\n      broken[name] = false;\n\n      if (descriptor.syntax !== null) {\n        walk(descriptor.syntax, function (node) {\n          if (node.type !== 'Type' && node.type !== 'Property') {\n            return;\n          }\n\n          var map = node.type === 'Type' ? syntax.types : syntax.properties;\n          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n            broken[name] = true;\n          }\n        }, this);\n      }\n    }\n\n    var brokenTypes = {};\n    var brokenProperties = {};\n\n    for (var key in this.types) {\n      validate(this, key, brokenTypes, this.types[key]);\n    }\n\n    for (var key in this.properties) {\n      validate(this, key, brokenProperties, this.properties[key]);\n    }\n\n    brokenTypes = Object.keys(brokenTypes).filter(function (name) {\n      return brokenTypes[name];\n    });\n    brokenProperties = Object.keys(brokenProperties).filter(function (name) {\n      return brokenProperties[name];\n    });\n\n    if (brokenTypes.length || brokenProperties.length) {\n      return {\n        types: brokenTypes,\n        properties: brokenProperties\n      };\n    }\n\n    return null;\n  },\n  dump: function (syntaxAsAst, pretty) {\n    return {\n      generic: this.generic,\n      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)\n    };\n  },\n  toString: function () {\n    return JSON.stringify(this.dump());\n  }\n};\nmodule.exports = Lexer;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/csso/node_modules/css-tree/lib/lexer/Lexer.js"],"names":["SyntaxReferenceError","require","MatchError","names","generic","parse","generate","walk","prepareTokens","buildMatchGraph","matchAsTree","trace","search","getStructureFromConfig","cssWideKeywords","cssWideKeywordsWithExpression","dumpMapSyntax","map","compact","syntaxAsAst","result","name","syntax","valueHasVar","tokens","i","length","value","toLowerCase","buildMatchResult","match","error","iterations","matched","getTrace","isType","isProperty","isKeyword","matchSyntax","lexer","useCommon","Error","valueCommonSyntax","reason","Lexer","config","structure","atrules","properties","types","addType_","addAtrule_","addProperty_","prototype","checkStructure","ast","collectWarning","node","message","warns","push","hasOwnProperty","type","check","createDescriptor","ref","descriptor","Object","defineProperty","get","prelude","descriptors","keys","reduce","res","matchAtrulePrelude","atruleName","atrule","keyword","atrulePreludeSyntax","vendor","getAtrulePrelude","basename","matchAtruleDescriptor","descriptorName","atruleEntry","atruleDescriptorSyntax","matchDeclaration","matchProperty","property","propertyName","custom","propertySyntax","getProperty","matchType","typeName","typeSyntax","getType","findValueFragments","matchFragments","findDeclarationValueFragments","declaration","findAllFragments","visit","enter","apply","bind","getAtruleDescriptor","declarators","validate","broken","brokenMap","brokenTypes","brokenProperties","key","filter","dump","pretty","toString","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["var SyntaxReferenceError = require('./error').SyntaxReferenceError;\nvar MatchError = require('./error').MatchError;\nvar names = require('../utils/names');\nvar generic = require('./generic');\nvar parse = require('../definition-syntax/parse');\nvar generate = require('../definition-syntax/generate');\nvar walk = require('../definition-syntax/walk');\nvar prepareTokens = require('./prepare-tokens');\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\nvar matchAsTree = require('./match').matchAsTree;\nvar trace = require('./trace');\nvar search = require('./search');\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n    var result = {};\n\n    for (var name in map) {\n        if (map[name].syntax) {\n            result[name] = syntaxAsAst\n                ? map[name].syntax\n                : generate(map[name].syntax, { compact: compact });\n        }\n    }\n\n    return result;\n}\n\nfunction valueHasVar(tokens) {\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].value.toLowerCase() === 'var(') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction buildMatchResult(match, error, iterations) {\n    return {\n        matched: match,\n        iterations: iterations,\n        error: error,\n        getTrace: trace.getTrace,\n        isType: trace.isType,\n        isProperty: trace.isProperty,\n        isKeyword: trace.isKeyword\n    };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n    var tokens = prepareTokens(value, lexer.syntax);\n    var result;\n\n    if (valueHasVar(tokens)) {\n        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n    }\n\n    if (useCommon) {\n        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n    }\n\n    if (!useCommon || !result.match) {\n        result = matchAsTree(tokens, syntax.match, lexer);\n        if (!result.match) {\n            return buildMatchResult(\n                null,\n                new MatchError(result.reason, syntax.syntax, value, result),\n                result.iterations\n            );\n        }\n    }\n\n    return buildMatchResult(result.match, null, result.iterations);\n}\n\nvar Lexer = function(config, syntax, structure) {\n    this.valueCommonSyntax = cssWideKeywords;\n    this.syntax = syntax;\n    this.generic = false;\n    this.atrules = {};\n    this.properties = {};\n    this.types = {};\n    this.structure = structure || getStructureFromConfig(config);\n\n    if (config) {\n        if (config.types) {\n            for (var name in config.types) {\n                this.addType_(name, config.types[name]);\n            }\n        }\n\n        if (config.generic) {\n            this.generic = true;\n            for (var name in generic) {\n                this.addType_(name, generic[name]);\n            }\n        }\n\n        if (config.atrules) {\n            for (var name in config.atrules) {\n                this.addAtrule_(name, config.atrules[name]);\n            }\n        }\n\n        if (config.properties) {\n            for (var name in config.properties) {\n                this.addProperty_(name, config.properties[name]);\n            }\n        }\n    }\n};\n\nLexer.prototype = {\n    structure: {},\n    checkStructure: function(ast) {\n        function collectWarning(node, message) {\n            warns.push({\n                node: node,\n                message: message\n            });\n        }\n\n        var structure = this.structure;\n        var warns = [];\n\n        this.syntax.walk(ast, function(node) {\n            if (structure.hasOwnProperty(node.type)) {\n                structure[node.type].check(node, collectWarning);\n            } else {\n                collectWarning(node, 'Unknown node type `' + node.type + '`');\n            }\n        });\n\n        return warns.length ? warns : false;\n    },\n\n    createDescriptor: function(syntax, type, name) {\n        var ref = {\n            type: type,\n            name: name\n        };\n        var descriptor = {\n            type: type,\n            name: name,\n            syntax: null,\n            match: null\n        };\n\n        if (typeof syntax === 'function') {\n            descriptor.match = buildMatchGraph(syntax, ref);\n        } else {\n            if (typeof syntax === 'string') {\n                // lazy parsing on first access\n                Object.defineProperty(descriptor, 'syntax', {\n                    get: function() {\n                        Object.defineProperty(descriptor, 'syntax', {\n                            value: parse(syntax)\n                        });\n\n                        return descriptor.syntax;\n                    }\n                });\n            } else {\n                descriptor.syntax = syntax;\n            }\n\n            // lazy graph build on first access\n            Object.defineProperty(descriptor, 'match', {\n                get: function() {\n                    Object.defineProperty(descriptor, 'match', {\n                        value: buildMatchGraph(descriptor.syntax, ref)\n                    });\n\n                    return descriptor.match;\n                }\n            });\n        }\n\n        return descriptor;\n    },\n    addAtrule_: function(name, syntax) {\n        this.atrules[name] = {\n            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n            descriptors: syntax.descriptors\n                ? Object.keys(syntax.descriptors).reduce((res, name) => {\n                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);\n                    return res;\n                }, {})\n                : null\n        };\n    },\n    addProperty_: function(name, syntax) {\n        this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n    },\n    addType_: function(name, syntax) {\n        this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n        if (syntax === generic['-ms-legacy-expression']) {\n            this.valueCommonSyntax = cssWideKeywordsWithExpression;\n        }\n    },\n\n    matchAtrulePrelude: function(atruleName, prelude) {\n        var atrule = names.keyword(atruleName);\n\n        var atrulePreludeSyntax = atrule.vendor\n            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)\n            : this.getAtrulePrelude(atrule.name);\n\n        if (!atrulePreludeSyntax) {\n            if (atrule.basename in this.atrules) {\n                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));\n            }\n\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule', atruleName));\n        }\n\n        return matchSyntax(this, atrulePreludeSyntax, prelude, true);\n    },\n    matchAtruleDescriptor: function(atruleName, descriptorName, value) {\n        var atrule = names.keyword(atruleName);\n        var descriptor = names.keyword(descriptorName);\n\n        var atruleEntry = atrule.vendor\n            ? this.atrules[atrule.name] || this.atrules[atrule.basename]\n            : this.atrules[atrule.name];\n\n        if (!atruleEntry) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule', atruleName));\n        }\n\n        if (!atruleEntry.descriptors) {\n            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));\n        }\n\n        var atruleDescriptorSyntax = descriptor.vendor\n            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]\n            : atruleEntry.descriptors[descriptor.name];\n\n        if (!atruleDescriptorSyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName));\n        }\n\n        return matchSyntax(this, atruleDescriptorSyntax, value, true);\n    },\n    matchDeclaration: function(node) {\n        if (node.type !== 'Declaration') {\n            return buildMatchResult(null, new Error('Not a Declaration node'));\n        }\n\n        return this.matchProperty(node.property, node.value);\n    },\n    matchProperty: function(propertyName, value) {\n        var property = names.property(propertyName);\n\n        // don't match syntax for a custom property\n        if (property.custom) {\n            return buildMatchResult(null, new Error('Lexer matching doesn\\'t applicable for custom properties'));\n        }\n\n        var propertySyntax = property.vendor\n            ? this.getProperty(property.name) || this.getProperty(property.basename)\n            : this.getProperty(property.name);\n\n        if (!propertySyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));\n        }\n\n        return matchSyntax(this, propertySyntax, value, true);\n    },\n    matchType: function(typeName, value) {\n        var typeSyntax = this.getType(typeName);\n\n        if (!typeSyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n        }\n\n        return matchSyntax(this, typeSyntax, value, false);\n    },\n    match: function(syntax, value) {\n        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n        }\n\n        if (typeof syntax === 'string' || !syntax.match) {\n            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n        }\n\n        return matchSyntax(this, syntax, value, false);\n    },\n\n    findValueFragments: function(propertyName, value, type, name) {\n        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n    },\n    findDeclarationValueFragments: function(declaration, type, name) {\n        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n    },\n    findAllFragments: function(ast, type, name) {\n        var result = [];\n\n        this.syntax.walk(ast, {\n            visit: 'Declaration',\n            enter: function(declaration) {\n                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n            }.bind(this)\n        });\n\n        return result;\n    },\n\n    getAtrulePrelude: function(atruleName) {\n        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;\n    },\n    getAtruleDescriptor: function(atruleName, name) {\n        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators\n            ? this.atrules[atruleName].declarators[name] || null\n            : null;\n    },\n    getProperty: function(name) {\n        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;\n    },\n    getType: function(name) {\n        return this.types.hasOwnProperty(name) ? this.types[name] : null;\n    },\n\n    validate: function() {\n        function validate(syntax, name, broken, descriptor) {\n            if (broken.hasOwnProperty(name)) {\n                return broken[name];\n            }\n\n            broken[name] = false;\n            if (descriptor.syntax !== null) {\n                walk(descriptor.syntax, function(node) {\n                    if (node.type !== 'Type' && node.type !== 'Property') {\n                        return;\n                    }\n\n                    var map = node.type === 'Type' ? syntax.types : syntax.properties;\n                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n                        broken[name] = true;\n                    }\n                }, this);\n            }\n        }\n\n        var brokenTypes = {};\n        var brokenProperties = {};\n\n        for (var key in this.types) {\n            validate(this, key, brokenTypes, this.types[key]);\n        }\n\n        for (var key in this.properties) {\n            validate(this, key, brokenProperties, this.properties[key]);\n        }\n\n        brokenTypes = Object.keys(brokenTypes).filter(function(name) {\n            return brokenTypes[name];\n        });\n        brokenProperties = Object.keys(brokenProperties).filter(function(name) {\n            return brokenProperties[name];\n        });\n\n        if (brokenTypes.length || brokenProperties.length) {\n            return {\n                types: brokenTypes,\n                properties: brokenProperties\n            };\n        }\n\n        return null;\n    },\n    dump: function(syntaxAsAst, pretty) {\n        return {\n            generic: this.generic,\n            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)\n        };\n    },\n    toString: function() {\n        return JSON.stringify(this.dump());\n    }\n};\n\nmodule.exports = Lexer;\n"]},"metadata":{},"sourceType":"script"}