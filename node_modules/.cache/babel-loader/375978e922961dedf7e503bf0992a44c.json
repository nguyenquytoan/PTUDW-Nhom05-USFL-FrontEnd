{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as util from \"./util\"; // this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\n\nexport default function replaceShorthandObjectMethod(path) {\n  const t = util.getTypes();\n\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  } // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n\n\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  } // this function only replaces generators.\n\n\n  if (!path.node.generator) {\n    return path;\n  }\n\n  const parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  });\n  const functionExpression = t.functionExpression(null, // id\n  parameters, // params\n  t.cloneDeep(path.node.body), // body\n  path.node.generator, path.node.async);\n  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), // key\n  functionExpression, //value\n  path.node.computed, // computed\n  false // shorthand\n  )); // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n\n  return path.get(\"value\");\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/regenerator-transform/src/replaceShorthandObjectMethod.js"],"names":["util","replaceShorthandObjectMethod","path","t","getTypes","node","isFunction","Error","isObjectMethod","generator","parameters","params","map","param","cloneDeep","functionExpression","body","async","replaceWithOrRemove","objectProperty","key","computed","get"],"mappings":"AAAA;;;;;;AAOA,OAAO,KAAKA,IAAZ,MAAsB,QAAtB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,4BAAT,CAAsCC,IAAtC,EAA4C;AACzD,QAAMC,CAAC,GAAGH,IAAI,CAACI,QAAL,EAAV;;AAEA,MAAI,CAACF,IAAI,CAACG,IAAN,IAAc,CAACF,CAAC,CAACG,UAAF,CAAaJ,IAAI,CAACG,IAAlB,CAAnB,EAA4C;AAC1C,UAAM,IAAIE,KAAJ,CAAU,6EAAV,CAAN;AACD,GALwD,CAOzD;AACA;;;AACA,MAAI,CAACJ,CAAC,CAACK,cAAF,CAAiBN,IAAI,CAACG,IAAtB,CAAL,EAAkC;AAChC,WAAOH,IAAP;AACD,GAXwD,CAazD;;;AACA,MAAI,CAACA,IAAI,CAACG,IAAL,CAAUI,SAAf,EAA0B;AACxB,WAAOP,IAAP;AACD;;AAED,QAAMQ,UAAU,GAAGR,IAAI,CAACG,IAAL,CAAUM,MAAV,CAAiBC,GAAjB,CAAqB,UAAUC,KAAV,EAAiB;AACvD,WAAOV,CAAC,CAACW,SAAF,CAAYD,KAAZ,CAAP;AACD,GAFkB,CAAnB;AAIA,QAAME,kBAAkB,GAAGZ,CAAC,CAACY,kBAAF,CACzB,IADyB,EACnB;AACNL,EAAAA,UAFyB,EAEb;AACZP,EAAAA,CAAC,CAACW,SAAF,CAAYZ,IAAI,CAACG,IAAL,CAAUW,IAAtB,CAHyB,EAGI;AAC7Bd,EAAAA,IAAI,CAACG,IAAL,CAAUI,SAJe,EAKzBP,IAAI,CAACG,IAAL,CAAUY,KALe,CAA3B;AAQAjB,EAAAA,IAAI,CAACkB,mBAAL,CAAyBhB,IAAzB,EACEC,CAAC,CAACgB,cAAF,CACEhB,CAAC,CAACW,SAAF,CAAYZ,IAAI,CAACG,IAAL,CAAUe,GAAtB,CADF,EAC8B;AAC5BL,EAAAA,kBAFF,EAEsB;AACpBb,EAAAA,IAAI,CAACG,IAAL,CAAUgB,QAHZ,EAGsB;AACpB,OAJF,CAIQ;AAJR,GADF,EA9ByD,CAuCzD;AACA;AACA;AACA;;AACA,SAAOnB,IAAI,CAACoB,GAAL,CAAS,OAAT,CAAP;AACD","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as util from \"./util\";\n\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\nexport default function replaceShorthandObjectMethod(path) {\n  const t = util.getTypes();\n\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  }\n\n  // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  }\n\n  // this function only replaces generators.\n  if (!path.node.generator) {\n    return path;\n  }\n\n  const parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  })\n\n  const functionExpression = t.functionExpression(\n    null, // id\n    parameters, // params\n    t.cloneDeep(path.node.body), // body\n    path.node.generator,\n    path.node.async\n  );\n\n  util.replaceWithOrRemove(path,\n    t.objectProperty(\n      t.cloneDeep(path.node.key), // key\n      functionExpression, //value\n      path.node.computed, // computed\n      false // shorthand\n    )\n  );\n\n  // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n  return path.get(\"value\");\n}\n"]},"metadata":{},"sourceType":"module"}