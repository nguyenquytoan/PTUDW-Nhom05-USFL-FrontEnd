{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeTrimmingDots = exports.formatTestNameByPattern = exports.highlight = exports.getTerminalWidth = exports.trimAndFormatPath = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _slash = _interopRequireDefault(require(\"slash\"));\n\nvar _stripAnsi = _interopRequireDefault(require(\"strip-ansi\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable no-param-reassign */\n\n\nconst TRIMMING_DOTS = '...';\nconst ENTER = '⏎';\n\nconst relativePath = (config, testPath) => {\n  testPath = _path.default.relative(config.cwd || config.rootDir, testPath);\n\n  const dirname = _path.default.dirname(testPath);\n\n  const basename = _path.default.basename(testPath);\n\n  return {\n    basename,\n    dirname\n  };\n};\n\nconst colorize = (str, start, end) => _chalk.default.dim(str.slice(0, start)) + _chalk.default.reset(str.slice(start, end)) + _chalk.default.dim(str.slice(end));\n\nconst trimAndFormatPath = (pad, config, testPath, columns) => {\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);\n  const basename = relative.basename;\n  let dirname = relative.dirname; // length is ok\n\n  if ((dirname + _path.default.sep + basename).length <= maxLength) {\n    return (0, _slash.default)(_chalk.default.dim(dirname + _path.default.sep) + _chalk.default.bold(basename));\n  } // we can fit trimmed dirname and full basename\n\n\n  const basenameLength = basename.length;\n\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = `${TRIMMING_DOTS}${dirname.slice(dirname.length - dirnameLength, dirname.length)}`;\n    return (0, _slash.default)(_chalk.default.dim(dirname + _path.default.sep) + _chalk.default.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return (0, _slash.default)(_chalk.default.dim(`${TRIMMING_DOTS}${_path.default.sep}`) + _chalk.default.bold(basename));\n  } // can't fit dirname, but can fit trimmed basename\n\n\n  return (0, _slash.default)(_chalk.default.bold(`${TRIMMING_DOTS}${basename.slice(-maxLength + 3)}`));\n};\n\nexports.trimAndFormatPath = trimAndFormatPath;\n\nconst getTerminalWidth = (pipe = process.stdout) => pipe.columns;\n\nexports.getTerminalWidth = getTerminalWidth;\n\nconst highlight = (rawPath, filePath, pattern, rootDir) => {\n  const relativePathHead = './';\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return _chalk.default.dim(filePath);\n  }\n\n  rawPath = (0, _stripAnsi.default)(rawPath);\n  filePath = (0, _stripAnsi.default)(filePath);\n  const match = rawPath.match(regexp);\n\n  if (!match) {\n    return _chalk.default.dim(filePath);\n  }\n\n  let offset;\n  let trimLength;\n\n  if (filePath.startsWith(TRIMMING_DOTS)) {\n    offset = rawPath.length - filePath.length;\n    trimLength = TRIMMING_DOTS.length;\n  } else if (filePath.startsWith(relativePathHead)) {\n    offset = rawPath.length - filePath.length;\n    trimLength = relativePathHead.length;\n  } else {\n    offset = rootDir.length + _path.default.sep.length;\n    trimLength = 0;\n  }\n\n  const start = match.index - offset;\n  const end = start + match[0].length;\n  return colorize(filePath, Math.max(start, 0), Math.max(end, trimLength));\n};\n\nexports.highlight = highlight;\n\nconst formatTestNameByPattern = (testName, pattern, width) => {\n  const inlineTestName = testName.replace(/(\\r\\n|\\n|\\r)/gm, ENTER);\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return _chalk.default.dim(inlineTestName);\n  }\n\n  const match = inlineTestName.match(regexp);\n\n  if (!match) {\n    return _chalk.default.dim(inlineTestName);\n  } // $FlowFixMe\n\n\n  const startPatternIndex = Math.max(match.index, 0);\n  const endPatternIndex = startPatternIndex + match[0].length;\n  const testNameFitsInTerminal = inlineTestName.length <= width;\n\n  if (testNameFitsInTerminal) {\n    return colorize(inlineTestName, startPatternIndex, endPatternIndex);\n  }\n\n  const numberOfTruncatedChars = TRIMMING_DOTS.length + inlineTestName.length - width;\n  const end = Math.max(endPatternIndex - numberOfTruncatedChars, 0);\n  const truncatedTestName = inlineTestName.slice(numberOfTruncatedChars);\n  const shouldHighlightDots = startPatternIndex <= numberOfTruncatedChars;\n\n  if (shouldHighlightDots) {\n    return colorize(TRIMMING_DOTS + truncatedTestName, 0, end + TRIMMING_DOTS.length);\n  }\n\n  const start = startPatternIndex - numberOfTruncatedChars;\n  return colorize(TRIMMING_DOTS + truncatedTestName, start + TRIMMING_DOTS.length, end + TRIMMING_DOTS.length);\n};\n\nexports.formatTestNameByPattern = formatTestNameByPattern;\n\nconst removeTrimmingDots = value => {\n  if (value.startsWith(TRIMMING_DOTS)) {\n    return value.slice(TRIMMING_DOTS.length);\n  }\n\n  return value;\n};\n\nexports.removeTrimmingDots = removeTrimmingDots;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-watch-typeahead/build/lib/utils.js"],"names":["Object","defineProperty","exports","value","removeTrimmingDots","formatTestNameByPattern","highlight","getTerminalWidth","trimAndFormatPath","_path","_interopRequireDefault","require","_chalk","_slash","_stripAnsi","obj","__esModule","default","TRIMMING_DOTS","ENTER","relativePath","config","testPath","relative","cwd","rootDir","dirname","basename","colorize","str","start","end","dim","slice","reset","pad","columns","maxLength","sep","length","bold","basenameLength","dirnameLength","pipe","process","stdout","rawPath","filePath","pattern","relativePathHead","regexp","RegExp","e","match","offset","trimLength","startsWith","index","Math","max","testName","width","inlineTestName","replace","startPatternIndex","endPatternIndex","testNameFitsInTerminal","numberOfTruncatedChars","truncatedTestName","shouldHighlightDots"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeTrimmingDots = exports.formatTestNameByPattern = exports.highlight = exports.getTerminalWidth = exports.trimAndFormatPath = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\n\nvar _slash = _interopRequireDefault(require(\"slash\"));\n\nvar _stripAnsi = _interopRequireDefault(require(\"strip-ansi\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable no-param-reassign */\nconst TRIMMING_DOTS = '...';\nconst ENTER = '⏎';\n\nconst relativePath = (config, testPath) => {\n  testPath = _path.default.relative(config.cwd || config.rootDir, testPath);\n\n  const dirname = _path.default.dirname(testPath);\n\n  const basename = _path.default.basename(testPath);\n\n  return {\n    basename,\n    dirname\n  };\n};\n\nconst colorize = (str, start, end) => _chalk.default.dim(str.slice(0, start)) + _chalk.default.reset(str.slice(start, end)) + _chalk.default.dim(str.slice(end));\n\nconst trimAndFormatPath = (pad, config, testPath, columns) => {\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);\n  const basename = relative.basename;\n  let dirname = relative.dirname; // length is ok\n\n  if ((dirname + _path.default.sep + basename).length <= maxLength) {\n    return (0, _slash.default)(_chalk.default.dim(dirname + _path.default.sep) + _chalk.default.bold(basename));\n  } // we can fit trimmed dirname and full basename\n\n\n  const basenameLength = basename.length;\n\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = `${TRIMMING_DOTS}${dirname.slice(dirname.length - dirnameLength, dirname.length)}`;\n    return (0, _slash.default)(_chalk.default.dim(dirname + _path.default.sep) + _chalk.default.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return (0, _slash.default)(_chalk.default.dim(`${TRIMMING_DOTS}${_path.default.sep}`) + _chalk.default.bold(basename));\n  } // can't fit dirname, but can fit trimmed basename\n\n\n  return (0, _slash.default)(_chalk.default.bold(`${TRIMMING_DOTS}${basename.slice(-maxLength + 3)}`));\n};\n\nexports.trimAndFormatPath = trimAndFormatPath;\n\nconst getTerminalWidth = (pipe = process.stdout) => pipe.columns;\n\nexports.getTerminalWidth = getTerminalWidth;\n\nconst highlight = (rawPath, filePath, pattern, rootDir) => {\n  const relativePathHead = './';\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return _chalk.default.dim(filePath);\n  }\n\n  rawPath = (0, _stripAnsi.default)(rawPath);\n  filePath = (0, _stripAnsi.default)(filePath);\n  const match = rawPath.match(regexp);\n\n  if (!match) {\n    return _chalk.default.dim(filePath);\n  }\n\n  let offset;\n  let trimLength;\n\n  if (filePath.startsWith(TRIMMING_DOTS)) {\n    offset = rawPath.length - filePath.length;\n    trimLength = TRIMMING_DOTS.length;\n  } else if (filePath.startsWith(relativePathHead)) {\n    offset = rawPath.length - filePath.length;\n    trimLength = relativePathHead.length;\n  } else {\n    offset = rootDir.length + _path.default.sep.length;\n    trimLength = 0;\n  }\n\n  const start = match.index - offset;\n  const end = start + match[0].length;\n  return colorize(filePath, Math.max(start, 0), Math.max(end, trimLength));\n};\n\nexports.highlight = highlight;\n\nconst formatTestNameByPattern = (testName, pattern, width) => {\n  const inlineTestName = testName.replace(/(\\r\\n|\\n|\\r)/gm, ENTER);\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return _chalk.default.dim(inlineTestName);\n  }\n\n  const match = inlineTestName.match(regexp);\n\n  if (!match) {\n    return _chalk.default.dim(inlineTestName);\n  } // $FlowFixMe\n\n\n  const startPatternIndex = Math.max(match.index, 0);\n  const endPatternIndex = startPatternIndex + match[0].length;\n  const testNameFitsInTerminal = inlineTestName.length <= width;\n\n  if (testNameFitsInTerminal) {\n    return colorize(inlineTestName, startPatternIndex, endPatternIndex);\n  }\n\n  const numberOfTruncatedChars = TRIMMING_DOTS.length + inlineTestName.length - width;\n  const end = Math.max(endPatternIndex - numberOfTruncatedChars, 0);\n  const truncatedTestName = inlineTestName.slice(numberOfTruncatedChars);\n  const shouldHighlightDots = startPatternIndex <= numberOfTruncatedChars;\n\n  if (shouldHighlightDots) {\n    return colorize(TRIMMING_DOTS + truncatedTestName, 0, end + TRIMMING_DOTS.length);\n  }\n\n  const start = startPatternIndex - numberOfTruncatedChars;\n  return colorize(TRIMMING_DOTS + truncatedTestName, start + TRIMMING_DOTS.length, end + TRIMMING_DOTS.length);\n};\n\nexports.formatTestNameByPattern = formatTestNameByPattern;\n\nconst removeTrimmingDots = value => {\n  if (value.startsWith(TRIMMING_DOTS)) {\n    return value.slice(TRIMMING_DOTS.length);\n  }\n\n  return value;\n};\n\nexports.removeTrimmingDots = removeTrimmingDots;"]},"metadata":{},"sourceType":"script"}