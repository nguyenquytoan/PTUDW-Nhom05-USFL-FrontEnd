{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst lodash = require(\"lodash\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n// Schema objects.\n\n\nconst OPTION_VALUE = {\n  oneOf: [{\n    enum: [\"always\", \"never\"]\n  }, {\n    type: \"object\",\n    properties: {\n      multiline: {\n        type: \"boolean\"\n      },\n      minProperties: {\n        type: \"integer\",\n        minimum: 0\n      },\n      consistent: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false,\n    minProperties: 1\n  }]\n};\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\n\nfunction normalizeOptionValue(value) {\n  let multiline = false;\n  let minProperties = Number.POSITIVE_INFINITY;\n  let consistent = false;\n\n  if (value) {\n    if (value === \"always\") {\n      minProperties = 0;\n    } else if (value === \"never\") {\n      minProperties = Number.POSITIVE_INFINITY;\n    } else {\n      multiline = Boolean(value.multiline);\n      minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n      consistent = Boolean(value.consistent);\n    }\n  } else {\n    consistent = true;\n  }\n\n  return {\n    multiline,\n    minProperties,\n    consistent\n  };\n}\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\n\n\nfunction normalizeOptions(options) {\n  const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);\n\n  if (lodash.isPlainObject(options) && lodash.some(options, isNodeSpecificOption)) {\n    return {\n      ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n      ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n    };\n  }\n\n  const value = normalizeOptionValue(options);\n  return {\n    ObjectExpression: value,\n    ObjectPattern: value,\n    ImportDeclaration: value,\n    ExportNamedDeclaration: value\n  };\n}\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\n\n\nfunction areLineBreaksRequired(node, options, first, last) {\n  let objectProperties;\n\n  if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n    objectProperties = node.properties;\n  } else {\n    // is ImportDeclaration or ExportNamedDeclaration\n    objectProperties = node.specifiers.filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n  }\n\n  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks inside braces\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-curly-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [OPTION_VALUE, {\n        type: \"object\",\n        properties: {\n          ObjectExpression: OPTION_VALUE,\n          ObjectPattern: OPTION_VALUE,\n          ImportDeclaration: OPTION_VALUE,\n          ExportDeclaration: OPTION_VALUE\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const normalizedOptions = normalizeOptions(context.options[0]);\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n     * @returns {void}\n     */\n\n    function check(node) {\n      const options = normalizedOptions[node.type];\n\n      if (node.type === \"ImportDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\") || node.type === \"ExportNamedDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\")) {\n        return;\n      }\n\n      const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n      let closeBrace;\n\n      if (node.typeAnnotation) {\n        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n      } else {\n        closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n      }\n\n      let first = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      let last = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n      const hasCommentsFirstToken = astUtils.isCommentToken(first);\n      const hasCommentsLastToken = astUtils.isCommentToken(last);\n      /*\n       * Use tokens or comments to check multiline or not.\n       * But use only tokens to check whether line breaks are needed.\n       * This allows:\n       *     var obj = { // eslint-disable-line foo\n       *         a: 1\n       *     }\n       */\n\n      first = sourceCode.getTokenAfter(openBrace);\n      last = sourceCode.getTokenBefore(closeBrace);\n\n      if (needsLineBreaks) {\n        if (astUtils.isTokenOnSameLine(openBrace, first)) {\n          context.report({\n            message: \"Expected a line break after this opening brace.\",\n            node,\n            loc: openBrace.loc.start,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.insertTextAfter(openBrace, \"\\n\");\n            }\n\n          });\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n          context.report({\n            message: \"Expected a line break before this closing brace.\",\n            node,\n            loc: closeBrace.loc.start,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.insertTextBefore(closeBrace, \"\\n\");\n            }\n\n          });\n        }\n      } else {\n        const consistent = options.consistent;\n        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            message: \"Unexpected line break after this opening brace.\",\n            node,\n            loc: openBrace.loc.start,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.removeRange([openBrace.range[1], first.range[0]]);\n            }\n\n          });\n        }\n\n        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            message: \"Unexpected line break before this closing brace.\",\n            node,\n            loc: closeBrace.loc.start,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.removeRange([last.range[1], closeBrace.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      ObjectExpression: check,\n      ObjectPattern: check,\n      ImportDeclaration: check,\n      ExportNamedDeclaration: check\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/object-curly-newline.js"],"names":["astUtils","require","lodash","OPTION_VALUE","oneOf","enum","type","properties","multiline","minProperties","minimum","consistent","additionalProperties","normalizeOptionValue","value","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","isNodeSpecificOption","overSome","isPlainObject","isString","some","ObjectExpression","ObjectPattern","ImportDeclaration","ExportNamedDeclaration","ExportDeclaration","areLineBreaksRequired","node","first","last","objectProperties","specifiers","filter","s","length","loc","start","line","end","module","exports","meta","docs","description","category","recommended","url","fixable","schema","create","context","sourceCode","getSourceCode","normalizedOptions","check","specifier","openBrace","getFirstToken","token","closeBrace","typeAnnotation","getTokenBefore","getLastToken","getTokenAfter","includeComments","needsLineBreaks","hasCommentsFirstToken","isCommentToken","hasCommentsLastToken","isTokenOnSameLine","report","message","fix","fixer","insertTextAfter","insertTextBefore","hasLineBreakBetweenOpenBraceAndFirst","hasLineBreakBetweenCloseBraceAndLast","removeRange","range"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);\n\n    if (lodash.isPlainObject(options) && lodash.some(options, isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        message: \"Expected a line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        message: \"Expected a line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}