{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.broadcastUpdate = function (exports, assert_mjs, getFriendlyURL_mjs, logger_mjs, Deferred_mjs, WorkboxError_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:broadcast-update:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Given two `Response's`, compares several header values to see if they are\n   * the same or not.\n   *\n   * @param {Response} firstResponse\n   * @param {Response} secondResponse\n   * @param {Array<string>} headersToCheck\n   * @return {boolean}\n   *\n   * @memberof workbox.broadcastUpdate\n   * @private\n   */\n\n\n  const responsesAreSame = (firstResponse, secondResponse, headersToCheck) => {\n    {\n      if (!(firstResponse instanceof Response && secondResponse instanceof Response)) {\n        throw new WorkboxError_mjs.WorkboxError('invalid-responses-are-same-args');\n      }\n    }\n    const atLeastOneHeaderAvailable = headersToCheck.some(header => {\n      return firstResponse.headers.has(header) && secondResponse.headers.has(header);\n    });\n\n    if (!atLeastOneHeaderAvailable) {\n      {\n        logger_mjs.logger.warn(`Unable to determine where the response has been updated ` + `because none of the headers that would be checked are present.`);\n        logger_mjs.logger.debug(`Attempting to compare the following: `, firstResponse, secondResponse, headersToCheck);\n      } // Just return true, indicating the that responses are the same, since we\n      // can't determine otherwise.\n\n      return true;\n    }\n\n    return headersToCheck.every(header => {\n      const headerStateComparison = firstResponse.headers.has(header) === secondResponse.headers.has(header);\n      const headerValueComparison = firstResponse.headers.get(header) === secondResponse.headers.get(header);\n      return headerStateComparison && headerValueComparison;\n    });\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const CACHE_UPDATED_MESSAGE_TYPE = 'CACHE_UPDATED';\n  const CACHE_UPDATED_MESSAGE_META = 'workbox-broadcast-update';\n  const DEFAULT_BROADCAST_CHANNEL_NAME = 'workbox';\n  const DEFAULT_DEFER_NOTIFICATION_TIMEOUT = 10000;\n  const DEFAULT_HEADERS_TO_CHECK = ['content-length', 'etag', 'last-modified'];\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * You would not normally call this method directly; it's called automatically\n   * by an instance of the {@link BroadcastCacheUpdate} class. It's exposed here\n   * for the benefit of developers who would rather not use the full\n   * `BroadcastCacheUpdate` implementation.\n   *\n   * Calling this will dispatch a message on the provided\n   * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel}\n   * to notify interested subscribers about a change to a cached resource.\n   *\n   * The message that's posted has a formation inspired by the\n   * [Flux standard action](https://github.com/acdlite/flux-standard-action#introduction)\n   * format like so:\n   *\n   * ```\n   * {\n   *   type: 'CACHE_UPDATED',\n   *   meta: 'workbox-broadcast-update',\n   *   payload: {\n   *     cacheName: 'the-cache-name',\n   *     updatedURL: 'https://example.com/'\n   *   }\n   * }\n   * ```\n   *\n   * (Usage of [Flux](https://facebook.github.io/flux/) itself is not at\n   * all required.)\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName The name of the cache in which the updated\n   *     `Response` was stored.\n   * @param {string} options.url The URL associated with the updated `Response`.\n   * @param {BroadcastChannel} [options.channel] The `BroadcastChannel` to use.\n   *     If no channel is set or the browser doesn't support the BroadcastChannel\n   *     api, then an attempt will be made to `postMessage` each window client.\n   *\n   * @memberof workbox.broadcastUpdate\n   */\n\n  const broadcastUpdate = async ({\n    channel,\n    cacheName,\n    url\n  }) => {\n    {\n      assert_mjs.assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: '~',\n        funcName: 'broadcastUpdate',\n        paramName: 'cacheName'\n      });\n      assert_mjs.assert.isType(url, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: '~',\n        funcName: 'broadcastUpdate',\n        paramName: 'url'\n      });\n    }\n    const data = {\n      type: CACHE_UPDATED_MESSAGE_TYPE,\n      meta: CACHE_UPDATED_MESSAGE_META,\n      payload: {\n        cacheName: cacheName,\n        updatedURL: url\n      }\n    };\n\n    if (channel) {\n      channel.postMessage(data);\n    } else {\n      const windows = await clients.matchAll({\n        type: 'window'\n      });\n\n      for (const win of windows) {\n        win.postMessage(data);\n      }\n    }\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Uses the [Broadcast Channel API]{@link https://developers.google.com/web/updates/2016/09/broadcastchannel}\n   * to notify interested parties when a cached response has been updated.\n   * In browsers that do not support the Broadcast Channel API, the instance\n   * falls back to sending the update via `postMessage()` to all window clients.\n   *\n   * For efficiency's sake, the underlying response bodies are not compared;\n   * only specific response headers are checked.\n   *\n   * @memberof workbox.broadcastUpdate\n   */\n\n\n  class BroadcastCacheUpdate {\n    /**\n     * Construct a BroadcastCacheUpdate instance with a specific `channelName` to\n     * broadcast messages on\n     *\n     * @param {Object} options\n     * @param {Array<string>}\n     *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n     *     A list of headers that will be used to determine whether the responses\n     *     differ.\n     * @param {string} [options.channelName='workbox'] The name that will be used\n     *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n     *     channel name used by the `workbox-window` package).\n     * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n     *     to wait for a ready message from the window on navigation requests\n     *     before sending the update.\n     */\n    constructor({\n      headersToCheck,\n      channelName,\n      deferNoticationTimeout\n    } = {}) {\n      this._headersToCheck = headersToCheck || DEFAULT_HEADERS_TO_CHECK;\n      this._channelName = channelName || DEFAULT_BROADCAST_CHANNEL_NAME;\n      this._deferNoticationTimeout = deferNoticationTimeout || DEFAULT_DEFER_NOTIFICATION_TIMEOUT;\n      {\n        assert_mjs.assert.isType(this._channelName, 'string', {\n          moduleName: 'workbox-broadcast-update',\n          className: 'BroadcastCacheUpdate',\n          funcName: 'constructor',\n          paramName: 'channelName'\n        });\n        assert_mjs.assert.isArray(this._headersToCheck, {\n          moduleName: 'workbox-broadcast-update',\n          className: 'BroadcastCacheUpdate',\n          funcName: 'constructor',\n          paramName: 'headersToCheck'\n        });\n      }\n\n      this._initWindowReadyDeferreds();\n    }\n    /**\n     * Compare two [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n     * and send a message via the\n     * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel API}\n     * if they differ.\n     *\n     * Neither of the Responses can be {@link http://stackoverflow.com/questions/39109789|opaque}.\n     *\n     * @param {Object} options\n     * @param {Response} options.oldResponse Cached response to compare.\n     * @param {Response} options.newResponse Possibly updated response to compare.\n     * @param {string} options.url The URL of the request.\n     * @param {string} options.cacheName Name of the cache the responses belong\n     *     to. This is included in the broadcast message.\n     * @param {Event} [options.event] event An optional event that triggered\n     *     this possible cache update.\n     * @return {Promise} Resolves once the update is sent.\n     */\n\n\n    notifyIfUpdated({\n      oldResponse,\n      newResponse,\n      url,\n      cacheName,\n      event\n    }) {\n      if (!responsesAreSame(oldResponse, newResponse, this._headersToCheck)) {\n        {\n          logger_mjs.logger.log(`Newer response found (and cached) for:`, url);\n        }\n\n        const sendUpdate = async () => {\n          // In the case of a navigation request, the requesting page will likely\n          // not have loaded its JavaScript in time to recevied the update\n          // notification, so we defer it until ready (or we timeout waiting).\n          if (event && event.request && event.request.mode === 'navigate') {\n            {\n              logger_mjs.logger.debug(`Original request was a navigation request, ` + `waiting for a ready message from the window`, event.request);\n            }\n            await this._windowReadyOrTimeout(event);\n          }\n\n          await this._broadcastUpdate({\n            channel: this._getChannel(),\n            cacheName,\n            url\n          });\n        }; // Send the update and ensure the SW stays alive until it's sent.\n\n\n        const done = sendUpdate();\n\n        if (event) {\n          try {\n            event.waitUntil(done);\n          } catch (error) {\n            {\n              logger_mjs.logger.warn(`Unable to ensure service worker stays alive ` + `when broadcasting cache update for ` + `${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n            }\n          }\n        }\n\n        return done;\n      }\n    }\n    /**\n     * NOTE: this is exposed on the instance primarily so it can be spied on\n     * in tests.\n     *\n     * @param {Object} opts\n     * @private\n     */\n\n\n    async _broadcastUpdate(opts) {\n      await broadcastUpdate(opts);\n    }\n    /**\n     * @return {BroadcastChannel|undefined} The BroadcastChannel instance used for\n     * broadcasting updates, or undefined if the browser doesn't support the\n     * Broadcast Channel API.\n     *\n     * @private\n     */\n\n\n    _getChannel() {\n      if ('BroadcastChannel' in self && !this._channel) {\n        this._channel = new BroadcastChannel(this._channelName);\n      }\n\n      return this._channel;\n    }\n    /**\n     * Waits for a message from the window indicating that it's capable of\n     * receiving broadcasts. By default, this will only wait for the amount of\n     * time specified via the `deferNoticationTimeout` option.\n     *\n     * @param {Event} event The navigation fetch event.\n     * @return {Promise}\n     * @private\n     */\n\n\n    _windowReadyOrTimeout(event) {\n      if (!this._navigationEventsDeferreds.has(event)) {\n        const deferred = new Deferred_mjs.Deferred(); // Set the deferred on the `_navigationEventsDeferreds` map so it will\n        // be resolved when the next ready message event comes.\n\n        this._navigationEventsDeferreds.set(event, deferred); // But don't wait too long for the message since it may never come.\n\n\n        const timeout = setTimeout(() => {\n          {\n            logger_mjs.logger.debug(`Timed out after ${this._deferNoticationTimeout}` + `ms waiting for message from window`);\n          }\n          deferred.resolve();\n        }, this._deferNoticationTimeout); // Ensure the timeout is cleared if the deferred promise is resolved.\n\n        deferred.promise.then(() => clearTimeout(timeout));\n      }\n\n      return this._navigationEventsDeferreds.get(event).promise;\n    }\n    /**\n     * Creates a mapping between navigation fetch events and deferreds, and adds\n     * a listener for message events from the window. When message events arrive,\n     * all deferreds in the mapping are resolved.\n     *\n     * Note: it would be easier if we could only resolve the deferred of\n     * navigation fetch event whose client ID matched the source ID of the\n     * message event, but currently client IDs are not exposed on navigation\n     * fetch events: https://www.chromestatus.com/feature/4846038800138240\n     *\n     * @private\n     */\n\n\n    _initWindowReadyDeferreds() {\n      // A mapping between navigation events and their deferreds.\n      this._navigationEventsDeferreds = new Map(); // The message listener needs to be added in the initial run of the\n      // service worker, but since we don't actually need to be listening for\n      // messages until the cache updates, we only invoke the callback if set.\n\n      self.addEventListener('message', event => {\n        if (event.data.type === 'WINDOW_READY' && event.data.meta === 'workbox-window' && this._navigationEventsDeferreds.size > 0) {\n          {\n            logger_mjs.logger.debug(`Received WINDOW_READY event: `, event);\n          } // Resolve any pending deferreds.\n\n          for (const deferred of this._navigationEventsDeferreds.values()) {\n            deferred.resolve();\n          }\n\n          this._navigationEventsDeferreds.clear();\n        }\n      });\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This plugin will automatically broadcast a message whenever a cached response\n   * is updated.\n   *\n   * @memberof workbox.broadcastUpdate\n   */\n\n\n  class Plugin {\n    /**\n     * Construct a BroadcastCacheUpdate instance with the passed options and\n     * calls its `notifyIfUpdated()` method whenever the plugin's\n     * `cacheDidUpdate` callback is invoked.\n     *\n     * @param {Object} options\n     * @param {Array<string>}\n     *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n     *     A list of headers that will be used to determine whether the responses\n     *     differ.\n     * @param {string} [options.channelName='workbox'] The name that will be used\n     *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n     *     channel name used by the `workbox-window` package).\n     * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n     *     to wait for a ready message from the window on navigation requests\n     *     before sending the update.\n     */\n    constructor(options) {\n      this._broadcastUpdate = new BroadcastCacheUpdate(options);\n    }\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-sw` and `workbox-runtime-caching` handlers when an entry is\n     * added to a cache.\n     *\n     * @private\n     * @param {Object} options The input object to this function.\n     * @param {string} options.cacheName Name of the cache being updated.\n     * @param {Response} [options.oldResponse] The previous cached value, if any.\n     * @param {Response} options.newResponse The new value in the cache.\n     * @param {Request} options.request The request that triggered the udpate.\n     * @param {Request} [options.event] The event that triggered the update.\n     */\n\n\n    cacheDidUpdate({\n      cacheName,\n      oldResponse,\n      newResponse,\n      request,\n      event\n    }) {\n      {\n        assert_mjs.assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-broadcast-update',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'cacheName'\n        });\n        assert_mjs.assert.isInstance(newResponse, Response, {\n          moduleName: 'workbox-broadcast-update',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'newResponse'\n        });\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-broadcast-update',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'request'\n        });\n      }\n\n      if (!oldResponse) {\n        // Without a two responses there is nothing to compare.\n        return;\n      }\n\n      this._broadcastUpdate.notifyIfUpdated({\n        cacheName,\n        oldResponse,\n        newResponse,\n        event,\n        url: request.url\n      });\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.BroadcastCacheUpdate = BroadcastCacheUpdate;\n  exports.Plugin = Plugin;\n  exports.broadcastUpdate = broadcastUpdate;\n  exports.responsesAreSame = responsesAreSame;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../responsesAreSame.mjs","../utils/constants.mjs","../broadcastUpdate.mjs","../BroadcastCacheUpdate.mjs","../Plugin.mjs","../index.mjs"],"names":["self","_","responsesAreSame","firstResponse","secondResponse","WorkboxError","atLeastOneHeaderAvailable","header","logger","headerStateComparison","headerValueComparison","CACHE_UPDATED_MESSAGE_TYPE","CACHE_UPDATED_MESSAGE_META","DEFAULT_BROADCAST_CHANNEL_NAME","DEFAULT_DEFER_NOTIFICATION_TIMEOUT","DEFAULT_HEADERS_TO_CHECK","broadcastUpdate","url","assert","moduleName","className","funcName","paramName","data","type","meta","payload","cacheName","updatedURL","channel","windows","win","constructor","deferNoticationTimeout","headersToCheck","channelName","notifyIfUpdated","event","sendUpdate","done","getFriendlyURL","_getChannel","_windowReadyOrTimeout","deferred","Deferred","timeout","setTimeout","_deferNoticationTimeout","clearTimeout","_initWindowReadyDeferreds","cacheDidUpdate","request"],"mappings":"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","sourcesContent":["try{self['workbox:broadcast-update:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport './_version.mjs';\n\n/**\n * Given two `Response's`, compares several header values to see if they are\n * the same or not.\n *\n * @param {Response} firstResponse\n * @param {Response} secondResponse\n * @param {Array<string>} headersToCheck\n * @return {boolean}\n *\n * @memberof workbox.broadcastUpdate\n * @private\n */\nconst responsesAreSame = (firstResponse, secondResponse, headersToCheck) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!(firstResponse instanceof Response &&\n      secondResponse instanceof Response)) {\n      throw new WorkboxError('invalid-responses-are-same-args');\n    }\n  }\n\n  const atLeastOneHeaderAvailable = headersToCheck.some((header) => {\n    return firstResponse.headers.has(header) &&\n      secondResponse.headers.has(header);\n  });\n\n  if (!atLeastOneHeaderAvailable) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.warn(`Unable to determine where the response has been updated ` +\n        `because none of the headers that would be checked are present.`);\n      logger.debug(`Attempting to compare the following: `,\n          firstResponse, secondResponse, headersToCheck);\n    }\n\n    // Just return true, indicating the that responses are the same, since we\n    // can't determine otherwise.\n    return true;\n  }\n\n  return headersToCheck.every((header) => {\n    const headerStateComparison = firstResponse.headers.has(header) ===\n      secondResponse.headers.has(header);\n    const headerValueComparison = firstResponse.headers.get(header) ===\n      secondResponse.headers.get(header);\n\n    return headerStateComparison && headerValueComparison;\n  });\n};\n\nexport {responsesAreSame};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const CACHE_UPDATED_MESSAGE_TYPE = 'CACHE_UPDATED';\nexport const CACHE_UPDATED_MESSAGE_META = 'workbox-broadcast-update';\nexport const DEFAULT_BROADCAST_CHANNEL_NAME = 'workbox';\nexport const DEFAULT_DEFER_NOTIFICATION_TIMEOUT = 10000;\nexport const DEFAULT_HEADERS_TO_CHECK = [\n  'content-length',\n  'etag',\n  'last-modified',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {CACHE_UPDATED_MESSAGE_TYPE, CACHE_UPDATED_MESSAGE_META}\n  from './utils/constants.mjs';\n\nimport './_version.mjs';\n\n/**\n * You would not normally call this method directly; it's called automatically\n * by an instance of the {@link BroadcastCacheUpdate} class. It's exposed here\n * for the benefit of developers who would rather not use the full\n * `BroadcastCacheUpdate` implementation.\n *\n * Calling this will dispatch a message on the provided\n * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel}\n * to notify interested subscribers about a change to a cached resource.\n *\n * The message that's posted has a formation inspired by the\n * [Flux standard action](https://github.com/acdlite/flux-standard-action#introduction)\n * format like so:\n *\n * ```\n * {\n *   type: 'CACHE_UPDATED',\n *   meta: 'workbox-broadcast-update',\n *   payload: {\n *     cacheName: 'the-cache-name',\n *     updatedURL: 'https://example.com/'\n *   }\n * }\n * ```\n *\n * (Usage of [Flux](https://facebook.github.io/flux/) itself is not at\n * all required.)\n *\n * @param {Object} options\n * @param {string} options.cacheName The name of the cache in which the updated\n *     `Response` was stored.\n * @param {string} options.url The URL associated with the updated `Response`.\n * @param {BroadcastChannel} [options.channel] The `BroadcastChannel` to use.\n *     If no channel is set or the browser doesn't support the BroadcastChannel\n *     api, then an attempt will be made to `postMessage` each window client.\n *\n * @memberof workbox.broadcastUpdate\n */\nconst broadcastUpdate = async ({channel, cacheName, url}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(cacheName, 'string', {\n      moduleName: 'workbox-broadcast-update',\n      className: '~',\n      funcName: 'broadcastUpdate',\n      paramName: 'cacheName',\n    });\n    assert.isType(url, 'string', {\n      moduleName: 'workbox-broadcast-update',\n      className: '~',\n      funcName: 'broadcastUpdate',\n      paramName: 'url',\n    });\n  }\n\n  const data = {\n    type: CACHE_UPDATED_MESSAGE_TYPE,\n    meta: CACHE_UPDATED_MESSAGE_META,\n    payload: {\n      cacheName: cacheName,\n      updatedURL: url,\n    },\n  };\n\n  if (channel) {\n    channel.postMessage(data);\n  } else {\n    const windows = await clients.matchAll({type: 'window'});\n    for (const win of windows) {\n      win.postMessage(data);\n    }\n  }\n};\n\nexport {broadcastUpdate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {responsesAreSame} from './responsesAreSame.mjs';\nimport {broadcastUpdate} from './broadcastUpdate.mjs';\n\nimport {DEFAULT_HEADERS_TO_CHECK, DEFAULT_BROADCAST_CHANNEL_NAME,\n  DEFAULT_DEFER_NOTIFICATION_TIMEOUT} from './utils/constants.mjs';\n\nimport './_version.mjs';\n\n/**\n * Uses the [Broadcast Channel API]{@link https://developers.google.com/web/updates/2016/09/broadcastchannel}\n * to notify interested parties when a cached response has been updated.\n * In browsers that do not support the Broadcast Channel API, the instance\n * falls back to sending the update via `postMessage()` to all window clients.\n *\n * For efficiency's sake, the underlying response bodies are not compared;\n * only specific response headers are checked.\n *\n * @memberof workbox.broadcastUpdate\n */\nclass BroadcastCacheUpdate {\n  /**\n   * Construct a BroadcastCacheUpdate instance with a specific `channelName` to\n   * broadcast messages on\n   *\n   * @param {Object} options\n   * @param {Array<string>}\n   *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n   *     A list of headers that will be used to determine whether the responses\n   *     differ.\n   * @param {string} [options.channelName='workbox'] The name that will be used\n   *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n   *     channel name used by the `workbox-window` package).\n   * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n   *     to wait for a ready message from the window on navigation requests\n   *     before sending the update.\n   */\n  constructor({headersToCheck, channelName, deferNoticationTimeout} = {}) {\n    this._headersToCheck = headersToCheck || DEFAULT_HEADERS_TO_CHECK;\n    this._channelName = channelName || DEFAULT_BROADCAST_CHANNEL_NAME;\n    this._deferNoticationTimeout =\n        deferNoticationTimeout || DEFAULT_DEFER_NOTIFICATION_TIMEOUT;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(this._channelName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'channelName',\n      });\n      assert.isArray(this._headersToCheck, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'headersToCheck',\n      });\n    }\n\n    this._initWindowReadyDeferreds();\n  }\n\n  /**\n   * Compare two [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n   * and send a message via the\n   * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel API}\n   * if they differ.\n   *\n   * Neither of the Responses can be {@link http://stackoverflow.com/questions/39109789|opaque}.\n   *\n   * @param {Object} options\n   * @param {Response} options.oldResponse Cached response to compare.\n   * @param {Response} options.newResponse Possibly updated response to compare.\n   * @param {string} options.url The URL of the request.\n   * @param {string} options.cacheName Name of the cache the responses belong\n   *     to. This is included in the broadcast message.\n   * @param {Event} [options.event] event An optional event that triggered\n   *     this possible cache update.\n   * @return {Promise} Resolves once the update is sent.\n   */\n  notifyIfUpdated({oldResponse, newResponse, url, cacheName, event}) {\n    if (!responsesAreSame(oldResponse, newResponse, this._headersToCheck)) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Newer response found (and cached) for:`, url);\n      }\n\n      const sendUpdate = async () => {\n        // In the case of a navigation request, the requesting page will likely\n        // not have loaded its JavaScript in time to recevied the update\n        // notification, so we defer it until ready (or we timeout waiting).\n        if (event && event.request && event.request.mode === 'navigate') {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Original request was a navigation request, ` +\n                `waiting for a ready message from the window`, event.request);\n          }\n          await this._windowReadyOrTimeout(event);\n        }\n        await this._broadcastUpdate({\n          channel: this._getChannel(),\n          cacheName,\n          url,\n        });\n      };\n\n      // Send the update and ensure the SW stays alive until it's sent.\n      const done = sendUpdate();\n\n      if (event) {\n        try {\n          event.waitUntil(done);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive ` +\n                `when broadcasting cache update for ` +\n                `${getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n      return done;\n    }\n  }\n\n  /**\n   * NOTE: this is exposed on the instance primarily so it can be spied on\n   * in tests.\n   *\n   * @param {Object} opts\n   * @private\n   */\n  async _broadcastUpdate(opts) {\n    await broadcastUpdate(opts);\n  }\n\n  /**\n   * @return {BroadcastChannel|undefined} The BroadcastChannel instance used for\n   * broadcasting updates, or undefined if the browser doesn't support the\n   * Broadcast Channel API.\n   *\n   * @private\n   */\n  _getChannel() {\n    if (('BroadcastChannel' in self) && !this._channel) {\n      this._channel = new BroadcastChannel(this._channelName);\n    }\n    return this._channel;\n  }\n\n  /**\n   * Waits for a message from the window indicating that it's capable of\n   * receiving broadcasts. By default, this will only wait for the amount of\n   * time specified via the `deferNoticationTimeout` option.\n   *\n   * @param {Event} event The navigation fetch event.\n   * @return {Promise}\n   * @private\n   */\n  _windowReadyOrTimeout(event) {\n    if (!this._navigationEventsDeferreds.has(event)) {\n      const deferred = new Deferred();\n\n      // Set the deferred on the `_navigationEventsDeferreds` map so it will\n      // be resolved when the next ready message event comes.\n      this._navigationEventsDeferreds.set(event, deferred);\n\n      // But don't wait too long for the message since it may never come.\n      const timeout = setTimeout(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Timed out after ${this._deferNoticationTimeout}` +\n              `ms waiting for message from window`);\n        }\n        deferred.resolve();\n      }, this._deferNoticationTimeout);\n\n      // Ensure the timeout is cleared if the deferred promise is resolved.\n      deferred.promise.then(() => clearTimeout(timeout));\n    }\n    return this._navigationEventsDeferreds.get(event).promise;\n  }\n\n  /**\n   * Creates a mapping between navigation fetch events and deferreds, and adds\n   * a listener for message events from the window. When message events arrive,\n   * all deferreds in the mapping are resolved.\n   *\n   * Note: it would be easier if we could only resolve the deferred of\n   * navigation fetch event whose client ID matched the source ID of the\n   * message event, but currently client IDs are not exposed on navigation\n   * fetch events: https://www.chromestatus.com/feature/4846038800138240\n   *\n   * @private\n   */\n  _initWindowReadyDeferreds() {\n    // A mapping between navigation events and their deferreds.\n    this._navigationEventsDeferreds = new Map();\n\n    // The message listener needs to be added in the initial run of the\n    // service worker, but since we don't actually need to be listening for\n    // messages until the cache updates, we only invoke the callback if set.\n    self.addEventListener('message', (event) => {\n      if (event.data.type === 'WINDOW_READY' &&\n          event.data.meta === 'workbox-window' &&\n          this._navigationEventsDeferreds.size > 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Received WINDOW_READY event: `, event);\n        }\n        // Resolve any pending deferreds.\n        for (const deferred of this._navigationEventsDeferreds.values()) {\n          deferred.resolve();\n        }\n        this._navigationEventsDeferreds.clear();\n      }\n    });\n  }\n}\n\nexport {BroadcastCacheUpdate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {BroadcastCacheUpdate} from './BroadcastCacheUpdate.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin will automatically broadcast a message whenever a cached response\n * is updated.\n *\n * @memberof workbox.broadcastUpdate\n */\nclass Plugin {\n  /**\n   * Construct a BroadcastCacheUpdate instance with the passed options and\n   * calls its `notifyIfUpdated()` method whenever the plugin's\n   * `cacheDidUpdate` callback is invoked.\n   *\n   * @param {Object} options\n   * @param {Array<string>}\n   *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n   *     A list of headers that will be used to determine whether the responses\n   *     differ.\n   * @param {string} [options.channelName='workbox'] The name that will be used\n   *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n   *     channel name used by the `workbox-window` package).\n   * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n   *     to wait for a ready message from the window on navigation requests\n   *     before sending the update.\n   */\n  constructor(options) {\n    this._broadcastUpdate = new BroadcastCacheUpdate(options);\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox-sw` and `workbox-runtime-caching` handlers when an entry is\n   * added to a cache.\n   *\n   * @private\n   * @param {Object} options The input object to this function.\n   * @param {string} options.cacheName Name of the cache being updated.\n   * @param {Response} [options.oldResponse] The previous cached value, if any.\n   * @param {Response} options.newResponse The new value in the cache.\n   * @param {Request} options.request The request that triggered the udpate.\n   * @param {Request} [options.event] The event that triggered the update.\n   */\n  cacheDidUpdate({cacheName, oldResponse, newResponse, request, event}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(newResponse, Response, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'newResponse',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    if (!oldResponse) {\n      // Without a two responses there is nothing to compare.\n      return;\n    }\n    this._broadcastUpdate.notifyIfUpdated({\n      cacheName,\n      oldResponse,\n      newResponse,\n      event,\n      url: request.url,\n    });\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {BroadcastCacheUpdate} from './BroadcastCacheUpdate.mjs';\nimport {Plugin} from './Plugin.mjs';\nimport {broadcastUpdate} from './broadcastUpdate.mjs';\nimport {responsesAreSame} from './responsesAreSame.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.broadcastUpdate\n */\n\nexport {\n  BroadcastCacheUpdate,\n  Plugin,\n  broadcastUpdate,\n  responsesAreSame,\n};\n"]},"metadata":{},"sourceType":"script"}