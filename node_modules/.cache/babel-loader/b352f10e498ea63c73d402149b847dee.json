{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxTypescript = _interopRequireDefault(require(\"@babel/plugin-syntax-typescript\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _enum = _interopRequireDefault(require(\"./enum\"));\n\nvar _namespace = _interopRequireDefault(require(\"./namespace\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isInType(path) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSQualifiedName\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nconst PARSED_PARAMS = new WeakSet();\nconst GLOBAL_TYPES = new WeakMap();\n\nfunction isGlobalType(path, name) {\n  const program = path.find(path => path.isProgram()).node;\n  if (path.scope.hasOwnBinding(name)) return false;\n  if (GLOBAL_TYPES.get(program).has(name)) return true;\n  console.warn(`The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` + `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` + `never encountered it as a TypeScript type declaration.\\n` + `It will be treated as a JavaScript value.\\n\\n` + `This problem is likely caused by another plugin injecting\\n` + `\"${name}\" without registering it in the scope tracker. If you are the author\\n` + ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`);\n  return false;\n}\n\nfunction registerGlobalType(programScope, name) {\n  GLOBAL_TYPES.get(programScope.path.node).add(name);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, {\n  jsxPragma = \"React\",\n  allowNamespaces = false,\n  allowDeclareFields = false,\n  onlyRemoveTypeImports = false\n}) => {\n  api.assertVersion(7);\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const classMemberVisitors = {\n    field(path) {\n      const {\n        node\n      } = path;\n\n      if (!allowDeclareFields && node.declare) {\n        throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);\n      }\n\n      if (node.definite || node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Definietly assigned fields and fields with the 'declare' modifier cannot` + ` be initialized here, but only in the constructor`);\n        }\n\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (!allowDeclareFields && !node.value && !node.decorators && !_core.types.isClassPrivateProperty(node)) {\n        path.remove();\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n    },\n\n    method({\n      node\n    }) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n    },\n\n    constructor(path, classPath) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      const parameterProperties = [];\n\n      for (const param of path.node.params) {\n        if (param.type === \"TSParameterProperty\" && !PARSED_PARAMS.has(param.parameter)) {\n          PARSED_PARAMS.add(param.parameter);\n          parameterProperties.push(param.parameter);\n        }\n      }\n\n      if (parameterProperties.length) {\n        const assigns = parameterProperties.map(p => {\n          let id;\n\n          if (_core.types.isIdentifier(p)) {\n            id = p;\n          } else if (_core.types.isAssignmentPattern(p) && _core.types.isIdentifier(p.left)) {\n            id = p.left;\n          } else {\n            throw path.buildCodeFrameError(\"Parameter properties can not be destructuring patterns.\");\n          }\n\n          return _core.template.statement.ast`this.${id} = ${id}`;\n        });\n        (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);\n      }\n    }\n\n  };\n  return {\n    name: \"transform-typescript\",\n    inherits: _pluginSyntaxTypescript.default,\n    visitor: {\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program(path, state) {\n        const {\n          file\n        } = state;\n        let fileJsxPragma = null;\n\n        if (!GLOBAL_TYPES.has(path.node)) {\n          GLOBAL_TYPES.set(path.node, new Set());\n        }\n\n        if (file.ast.comments) {\n          for (const comment of file.ast.comments) {\n            const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n            if (jsxMatches) {\n              fileJsxPragma = jsxMatches[1];\n            }\n          }\n        }\n\n        let pragmaImportName = fileJsxPragma || jsxPragma;\n\n        if (pragmaImportName) {\n          [pragmaImportName] = pragmaImportName.split(\".\");\n        }\n\n        for (let stmt of path.get(\"body\")) {\n          if (_core.types.isImportDeclaration(stmt)) {\n            if (stmt.node.importKind === \"type\") {\n              stmt.remove();\n              continue;\n            }\n\n            if (!onlyRemoveTypeImports) {\n              if (stmt.node.specifiers.length === 0) {\n                continue;\n              }\n\n              let allElided = true;\n              const importsToRemove = [];\n\n              for (const specifier of stmt.node.specifiers) {\n                const binding = stmt.scope.getBinding(specifier.local.name);\n\n                if (binding && isImportTypeOnly({\n                  binding,\n                  programPath: path,\n                  jsxPragma: pragmaImportName\n                })) {\n                  importsToRemove.push(binding.path);\n                } else {\n                  allElided = false;\n                }\n              }\n\n              if (allElided) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n            }\n\n            continue;\n          }\n\n          if (stmt.isExportDeclaration()) {\n            stmt = stmt.get(\"declaration\");\n          }\n\n          if (stmt.isVariableDeclaration({\n            declare: true\n          })) {\n            for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n              registerGlobalType(path.scope, name);\n            }\n          } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({\n            declare: true\n          }) || stmt.isTSEnumDeclaration({\n            declare: true\n          }) || stmt.isTSModuleDeclaration({\n            declare: true\n          }) && stmt.get(\"id\").isIdentifier()) {\n            registerGlobalType(path.scope, stmt.node.id.name);\n          }\n        }\n      },\n\n      ExportNamedDeclaration(path) {\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(({\n          local\n        }) => isGlobalType(path, local.name))) {\n          path.remove();\n        }\n      },\n\n      ExportSpecifier(path) {\n        if (!path.parent.source && isGlobalType(path, path.node.local.name)) {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (_core.types.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {\n          path.remove();\n        }\n      },\n\n      TSDeclareFunction(path) {\n        path.remove();\n      },\n\n      TSDeclareMethod(path) {\n        path.remove();\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          path.remove();\n        }\n      },\n\n      VariableDeclarator({\n        node\n      }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n\n        if (node.declare) {\n          path.remove();\n          return;\n        }\n      },\n\n      Class(path) {\n        const {\n          node\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(child, path);\n            } else {\n              classMemberVisitors.method(child, path);\n            }\n          } else if (child.isClassProperty() || child.isClassPrivateProperty()) {\n            classMemberVisitors.field(child, path);\n          }\n        });\n      },\n\n      Function({\n        node\n      }) {\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n        const p0 = node.params[0];\n\n        if (p0 && _core.types.isIdentifier(p0) && p0.name === \"this\") {\n          node.params.shift();\n        }\n\n        node.params = node.params.map(p => {\n          return p.type === \"TSParameterProperty\" ? p.parameter : p;\n        });\n      },\n\n      TSModuleDeclaration(path) {\n        (0, _namespace.default)(path, _core.types, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        (0, _enum.default)(path, _core.types);\n      },\n\n      TSImportEqualsDeclaration(path) {\n        throw path.buildCodeFrameError(\"`import =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using \" + \"`import <moduleName> from '<moduleName>';` alongside \" + \"Typescript's --allowSyntheticDefaultImports option.\");\n      },\n\n      TSExportAssignment(path) {\n        throw path.buildCodeFrameError(\"`export =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using `export <value>;`.\");\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      TSAsExpression(path) {\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTSAsExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      TSNonNullExpression(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      }\n\n    }\n  };\n\n  function visitPattern({\n    node\n  }) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (_core.types.isIdentifier(node) && node.optional) node.optional = null;\n  }\n\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    jsxPragma\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n\n    if (binding.identifier.name !== jsxPragma) {\n      return true;\n    }\n\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      JSXElement() {\n        sourceFileHasJsx = true;\n      },\n\n      JSXFragment() {\n        sourceFileHasJsx = true;\n      }\n\n    });\n    return !sourceFileHasJsx;\n  }\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@babel/plugin-transform-typescript/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxTypescript","_interopRequireDefault","_core","_helperCreateClassFeaturesPlugin","_enum","_namespace","obj","__esModule","isInType","path","parent","type","PARSED_PARAMS","WeakSet","GLOBAL_TYPES","WeakMap","isGlobalType","name","program","find","isProgram","node","scope","hasOwnBinding","get","has","console","warn","registerGlobalType","programScope","add","_default","declare","api","jsxPragma","allowNamespaces","allowDeclareFields","onlyRemoveTypeImports","assertVersion","JSX_ANNOTATION_REGEX","classMemberVisitors","field","buildCodeFrameError","definite","decorators","remove","types","isClassPrivateProperty","accessibility","abstract","readonly","optional","typeAnnotation","method","constructor","classPath","parameterProperties","param","params","parameter","push","length","assigns","map","p","id","isIdentifier","isAssignmentPattern","left","template","statement","ast","injectInitialization","inherits","visitor","Pattern","visitPattern","Identifier","RestElement","Program","state","file","fileJsxPragma","set","Set","comments","comment","jsxMatches","exec","pragmaImportName","split","stmt","isImportDeclaration","importKind","specifiers","allElided","importsToRemove","specifier","binding","getBinding","local","isImportTypeOnly","programPath","importPath","isExportDeclaration","isVariableDeclaration","keys","getBindingIdentifiers","isTSTypeAliasDeclaration","isTSDeclareFunction","isTSInterfaceDeclaration","isClassDeclaration","isTSEnumDeclaration","isTSModuleDeclaration","ExportNamedDeclaration","exportKind","source","every","ExportSpecifier","ExportDefaultDeclaration","declaration","TSDeclareFunction","TSDeclareMethod","VariableDeclaration","VariableDeclarator","TSIndexSignature","ClassDeclaration","Class","typeParameters","superTypeParameters","implements","forEach","child","isClassMethod","isClassPrivateMethod","kind","isClassProperty","Function","returnType","p0","shift","TSModuleDeclaration","TSInterfaceDeclaration","TSTypeAliasDeclaration","TSEnumDeclaration","TSImportEqualsDeclaration","TSExportAssignment","TSTypeAssertion","replaceWith","expression","TSAsExpression","isTSAsExpression","TSNonNullExpression","CallExpression","NewExpression","JSXOpeningElement","TaggedTemplateExpression","referencePaths","identifier","sourceFileHasJsx","traverse","JSXElement","JSXFragment"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxTypescript = _interopRequireDefault(require(\"@babel/plugin-syntax-typescript\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _enum = _interopRequireDefault(require(\"./enum\"));\n\nvar _namespace = _interopRequireDefault(require(\"./namespace\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isInType(path) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSQualifiedName\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nconst PARSED_PARAMS = new WeakSet();\nconst GLOBAL_TYPES = new WeakMap();\n\nfunction isGlobalType(path, name) {\n  const program = path.find(path => path.isProgram()).node;\n  if (path.scope.hasOwnBinding(name)) return false;\n  if (GLOBAL_TYPES.get(program).has(name)) return true;\n  console.warn(`The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` + `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` + `never encountered it as a TypeScript type declaration.\\n` + `It will be treated as a JavaScript value.\\n\\n` + `This problem is likely caused by another plugin injecting\\n` + `\"${name}\" without registering it in the scope tracker. If you are the author\\n` + ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`);\n  return false;\n}\n\nfunction registerGlobalType(programScope, name) {\n  GLOBAL_TYPES.get(programScope.path.node).add(name);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, {\n  jsxPragma = \"React\",\n  allowNamespaces = false,\n  allowDeclareFields = false,\n  onlyRemoveTypeImports = false\n}) => {\n  api.assertVersion(7);\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const classMemberVisitors = {\n    field(path) {\n      const {\n        node\n      } = path;\n\n      if (!allowDeclareFields && node.declare) {\n        throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);\n      }\n\n      if (node.definite || node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Definietly assigned fields and fields with the 'declare' modifier cannot` + ` be initialized here, but only in the constructor`);\n        }\n\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (!allowDeclareFields && !node.value && !node.decorators && !_core.types.isClassPrivateProperty(node)) {\n        path.remove();\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n    },\n\n    method({\n      node\n    }) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n    },\n\n    constructor(path, classPath) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      const parameterProperties = [];\n\n      for (const param of path.node.params) {\n        if (param.type === \"TSParameterProperty\" && !PARSED_PARAMS.has(param.parameter)) {\n          PARSED_PARAMS.add(param.parameter);\n          parameterProperties.push(param.parameter);\n        }\n      }\n\n      if (parameterProperties.length) {\n        const assigns = parameterProperties.map(p => {\n          let id;\n\n          if (_core.types.isIdentifier(p)) {\n            id = p;\n          } else if (_core.types.isAssignmentPattern(p) && _core.types.isIdentifier(p.left)) {\n            id = p.left;\n          } else {\n            throw path.buildCodeFrameError(\"Parameter properties can not be destructuring patterns.\");\n          }\n\n          return _core.template.statement.ast`this.${id} = ${id}`;\n        });\n        (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);\n      }\n    }\n\n  };\n  return {\n    name: \"transform-typescript\",\n    inherits: _pluginSyntaxTypescript.default,\n    visitor: {\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program(path, state) {\n        const {\n          file\n        } = state;\n        let fileJsxPragma = null;\n\n        if (!GLOBAL_TYPES.has(path.node)) {\n          GLOBAL_TYPES.set(path.node, new Set());\n        }\n\n        if (file.ast.comments) {\n          for (const comment of file.ast.comments) {\n            const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n            if (jsxMatches) {\n              fileJsxPragma = jsxMatches[1];\n            }\n          }\n        }\n\n        let pragmaImportName = fileJsxPragma || jsxPragma;\n\n        if (pragmaImportName) {\n          [pragmaImportName] = pragmaImportName.split(\".\");\n        }\n\n        for (let stmt of path.get(\"body\")) {\n          if (_core.types.isImportDeclaration(stmt)) {\n            if (stmt.node.importKind === \"type\") {\n              stmt.remove();\n              continue;\n            }\n\n            if (!onlyRemoveTypeImports) {\n              if (stmt.node.specifiers.length === 0) {\n                continue;\n              }\n\n              let allElided = true;\n              const importsToRemove = [];\n\n              for (const specifier of stmt.node.specifiers) {\n                const binding = stmt.scope.getBinding(specifier.local.name);\n\n                if (binding && isImportTypeOnly({\n                  binding,\n                  programPath: path,\n                  jsxPragma: pragmaImportName\n                })) {\n                  importsToRemove.push(binding.path);\n                } else {\n                  allElided = false;\n                }\n              }\n\n              if (allElided) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n            }\n\n            continue;\n          }\n\n          if (stmt.isExportDeclaration()) {\n            stmt = stmt.get(\"declaration\");\n          }\n\n          if (stmt.isVariableDeclaration({\n            declare: true\n          })) {\n            for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n              registerGlobalType(path.scope, name);\n            }\n          } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({\n            declare: true\n          }) || stmt.isTSEnumDeclaration({\n            declare: true\n          }) || stmt.isTSModuleDeclaration({\n            declare: true\n          }) && stmt.get(\"id\").isIdentifier()) {\n            registerGlobalType(path.scope, stmt.node.id.name);\n          }\n        }\n      },\n\n      ExportNamedDeclaration(path) {\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(({\n          local\n        }) => isGlobalType(path, local.name))) {\n          path.remove();\n        }\n      },\n\n      ExportSpecifier(path) {\n        if (!path.parent.source && isGlobalType(path, path.node.local.name)) {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (_core.types.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {\n          path.remove();\n        }\n      },\n\n      TSDeclareFunction(path) {\n        path.remove();\n      },\n\n      TSDeclareMethod(path) {\n        path.remove();\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          path.remove();\n        }\n      },\n\n      VariableDeclarator({\n        node\n      }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n\n        if (node.declare) {\n          path.remove();\n          return;\n        }\n      },\n\n      Class(path) {\n        const {\n          node\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(child, path);\n            } else {\n              classMemberVisitors.method(child, path);\n            }\n          } else if (child.isClassProperty() || child.isClassPrivateProperty()) {\n            classMemberVisitors.field(child, path);\n          }\n        });\n      },\n\n      Function({\n        node\n      }) {\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n        const p0 = node.params[0];\n\n        if (p0 && _core.types.isIdentifier(p0) && p0.name === \"this\") {\n          node.params.shift();\n        }\n\n        node.params = node.params.map(p => {\n          return p.type === \"TSParameterProperty\" ? p.parameter : p;\n        });\n      },\n\n      TSModuleDeclaration(path) {\n        (0, _namespace.default)(path, _core.types, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        (0, _enum.default)(path, _core.types);\n      },\n\n      TSImportEqualsDeclaration(path) {\n        throw path.buildCodeFrameError(\"`import =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using \" + \"`import <moduleName> from '<moduleName>';` alongside \" + \"Typescript's --allowSyntheticDefaultImports option.\");\n      },\n\n      TSExportAssignment(path) {\n        throw path.buildCodeFrameError(\"`export =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using `export <value>;`.\");\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      TSAsExpression(path) {\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTSAsExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      TSNonNullExpression(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      }\n\n    }\n  };\n\n  function visitPattern({\n    node\n  }) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (_core.types.isIdentifier(node) && node.optional) node.optional = null;\n  }\n\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    jsxPragma\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n\n    if (binding.identifier.name !== jsxPragma) {\n      return true;\n    }\n\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      JSXElement() {\n        sourceFileHasJsx = true;\n      },\n\n      JSXFragment() {\n        sourceFileHasJsx = true;\n      }\n\n    });\n    return !sourceFileHasJsx;\n  }\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}