{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = extract;\nexports.extractLiteral = extractLiteral;\n\nvar _Literal = require('../Literal');\n\nvar _Literal2 = _interopRequireDefault(_Literal);\n\nvar _JSXElement = require('../JSXElement');\n\nvar _JSXElement2 = _interopRequireDefault(_JSXElement);\n\nvar _Identifier = require('./Identifier');\n\nvar _Identifier2 = _interopRequireDefault(_Identifier);\n\nvar _TaggedTemplateExpression = require('./TaggedTemplateExpression');\n\nvar _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);\n\nvar _TemplateLiteral = require('./TemplateLiteral');\n\nvar _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);\n\nvar _FunctionExpression = require('./FunctionExpression');\n\nvar _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);\n\nvar _LogicalExpression = require('./LogicalExpression');\n\nvar _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);\n\nvar _MemberExpression = require('./MemberExpression');\n\nvar _MemberExpression2 = _interopRequireDefault(_MemberExpression);\n\nvar _OptionalCallExpression = require('./OptionalCallExpression');\n\nvar _OptionalCallExpression2 = _interopRequireDefault(_OptionalCallExpression);\n\nvar _OptionalMemberExpression = require('./OptionalMemberExpression');\n\nvar _OptionalMemberExpression2 = _interopRequireDefault(_OptionalMemberExpression);\n\nvar _CallExpression = require('./CallExpression');\n\nvar _CallExpression2 = _interopRequireDefault(_CallExpression);\n\nvar _UnaryExpression = require('./UnaryExpression');\n\nvar _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);\n\nvar _ThisExpression = require('./ThisExpression');\n\nvar _ThisExpression2 = _interopRequireDefault(_ThisExpression);\n\nvar _ConditionalExpression = require('./ConditionalExpression');\n\nvar _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);\n\nvar _BinaryExpression = require('./BinaryExpression');\n\nvar _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);\n\nvar _ObjectExpression = require('./ObjectExpression');\n\nvar _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);\n\nvar _NewExpression = require('./NewExpression');\n\nvar _NewExpression2 = _interopRequireDefault(_NewExpression);\n\nvar _UpdateExpression = require('./UpdateExpression');\n\nvar _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);\n\nvar _ArrayExpression = require('./ArrayExpression');\n\nvar _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);\n\nvar _BindExpression = require('./BindExpression');\n\nvar _BindExpression2 = _interopRequireDefault(_BindExpression);\n\nvar _SpreadElement = require('./SpreadElement');\n\nvar _SpreadElement2 = _interopRequireDefault(_SpreadElement);\n\nvar _TypeCastExpression = require('./TypeCastExpression');\n\nvar _TypeCastExpression2 = _interopRequireDefault(_TypeCastExpression);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Composition map of types to their extractor functions.\n\n\nvar TYPES = {\n  Identifier: _Identifier2.default,\n  Literal: _Literal2.default,\n  JSXElement: _JSXElement2.default,\n  TaggedTemplateExpression: _TaggedTemplateExpression2.default,\n  TemplateLiteral: _TemplateLiteral2.default,\n  ArrowFunctionExpression: _FunctionExpression2.default,\n  FunctionExpression: _FunctionExpression2.default,\n  LogicalExpression: _LogicalExpression2.default,\n  MemberExpression: _MemberExpression2.default,\n  OptionalCallExpression: _OptionalCallExpression2.default,\n  OptionalMemberExpression: _OptionalMemberExpression2.default,\n  CallExpression: _CallExpression2.default,\n  UnaryExpression: _UnaryExpression2.default,\n  ThisExpression: _ThisExpression2.default,\n  ConditionalExpression: _ConditionalExpression2.default,\n  BinaryExpression: _BinaryExpression2.default,\n  ObjectExpression: _ObjectExpression2.default,\n  NewExpression: _NewExpression2.default,\n  UpdateExpression: _UpdateExpression2.default,\n  ArrayExpression: _ArrayExpression2.default,\n  BindExpression: _BindExpression2.default,\n  SpreadElement: _SpreadElement2.default,\n  TypeCastExpression: _TypeCastExpression2.default\n};\n\nvar noop = function noop() {\n  return null;\n};\n\nvar errorMessage = function errorMessage(expression) {\n  return 'The prop value with an expression type of ' + expression + ' could not be resolved. Please file issue to get this fixed immediately.';\n};\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\n\n\nfunction extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  var expression = void 0;\n\n  if (typeof value.expression !== 'boolean' && value.expression) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n\n  var _expression = expression,\n      type = _expression.type;\n\n  while (type === 'TSNonNullExpression' || type === 'TSAsExpression') {\n    var _expression2 = expression;\n    type = _expression2.type;\n\n    if (expression.expression) {\n      var _expression3 = expression;\n      expression = _expression3.expression;\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n} // Composition map of types to their extractor functions to handle literals.\n\n\nvar LITERAL_TYPES = _extends({}, TYPES, {\n  Literal: function Literal(value) {\n    var extractedVal = TYPES.Literal.call(undefined, value);\n    var isNull = extractedVal === null; // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: function Identifier(value) {\n    var isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: function UnaryExpression(value) {\n    var extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: function UpdateExpression(value) {\n    var extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: function ArrayExpression(value) {\n    var extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter(function (val) {\n      return val !== null;\n    });\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop\n});\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\n\n\nfunction extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  var expression = value.expression || value;\n  var type = expression.type;\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsx-ast-utils/lib/values/expressions/index.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","extract","extractLiteral","_Literal","require","_Literal2","_interopRequireDefault","_JSXElement","_JSXElement2","_Identifier","_Identifier2","_TaggedTemplateExpression","_TaggedTemplateExpression2","_TemplateLiteral","_TemplateLiteral2","_FunctionExpression","_FunctionExpression2","_LogicalExpression","_LogicalExpression2","_MemberExpression","_MemberExpression2","_OptionalCallExpression","_OptionalCallExpression2","_OptionalMemberExpression","_OptionalMemberExpression2","_CallExpression","_CallExpression2","_UnaryExpression","_UnaryExpression2","_ThisExpression","_ThisExpression2","_ConditionalExpression","_ConditionalExpression2","_BinaryExpression","_BinaryExpression2","_ObjectExpression","_ObjectExpression2","_NewExpression","_NewExpression2","_UpdateExpression","_UpdateExpression2","_ArrayExpression","_ArrayExpression2","_BindExpression","_BindExpression2","_SpreadElement","_SpreadElement2","_TypeCastExpression","_TypeCastExpression2","obj","__esModule","TYPES","Identifier","Literal","JSXElement","TaggedTemplateExpression","TemplateLiteral","ArrowFunctionExpression","FunctionExpression","LogicalExpression","MemberExpression","OptionalCallExpression","OptionalMemberExpression","CallExpression","UnaryExpression","ThisExpression","ConditionalExpression","BinaryExpression","ObjectExpression","NewExpression","UpdateExpression","ArrayExpression","BindExpression","SpreadElement","TypeCastExpression","noop","errorMessage","expression","_expression","type","_expression2","_expression3","undefined","console","error","LITERAL_TYPES","extractedVal","isNull","isUndefined","filter","val","TSNonNullExpression","TSAsExpression"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = extract;\nexports.extractLiteral = extractLiteral;\n\nvar _Literal = require('../Literal');\n\nvar _Literal2 = _interopRequireDefault(_Literal);\n\nvar _JSXElement = require('../JSXElement');\n\nvar _JSXElement2 = _interopRequireDefault(_JSXElement);\n\nvar _Identifier = require('./Identifier');\n\nvar _Identifier2 = _interopRequireDefault(_Identifier);\n\nvar _TaggedTemplateExpression = require('./TaggedTemplateExpression');\n\nvar _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);\n\nvar _TemplateLiteral = require('./TemplateLiteral');\n\nvar _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);\n\nvar _FunctionExpression = require('./FunctionExpression');\n\nvar _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);\n\nvar _LogicalExpression = require('./LogicalExpression');\n\nvar _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);\n\nvar _MemberExpression = require('./MemberExpression');\n\nvar _MemberExpression2 = _interopRequireDefault(_MemberExpression);\n\nvar _OptionalCallExpression = require('./OptionalCallExpression');\n\nvar _OptionalCallExpression2 = _interopRequireDefault(_OptionalCallExpression);\n\nvar _OptionalMemberExpression = require('./OptionalMemberExpression');\n\nvar _OptionalMemberExpression2 = _interopRequireDefault(_OptionalMemberExpression);\n\nvar _CallExpression = require('./CallExpression');\n\nvar _CallExpression2 = _interopRequireDefault(_CallExpression);\n\nvar _UnaryExpression = require('./UnaryExpression');\n\nvar _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);\n\nvar _ThisExpression = require('./ThisExpression');\n\nvar _ThisExpression2 = _interopRequireDefault(_ThisExpression);\n\nvar _ConditionalExpression = require('./ConditionalExpression');\n\nvar _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);\n\nvar _BinaryExpression = require('./BinaryExpression');\n\nvar _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);\n\nvar _ObjectExpression = require('./ObjectExpression');\n\nvar _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);\n\nvar _NewExpression = require('./NewExpression');\n\nvar _NewExpression2 = _interopRequireDefault(_NewExpression);\n\nvar _UpdateExpression = require('./UpdateExpression');\n\nvar _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);\n\nvar _ArrayExpression = require('./ArrayExpression');\n\nvar _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);\n\nvar _BindExpression = require('./BindExpression');\n\nvar _BindExpression2 = _interopRequireDefault(_BindExpression);\n\nvar _SpreadElement = require('./SpreadElement');\n\nvar _SpreadElement2 = _interopRequireDefault(_SpreadElement);\n\nvar _TypeCastExpression = require('./TypeCastExpression');\n\nvar _TypeCastExpression2 = _interopRequireDefault(_TypeCastExpression);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Composition map of types to their extractor functions.\nvar TYPES = {\n  Identifier: _Identifier2.default,\n  Literal: _Literal2.default,\n  JSXElement: _JSXElement2.default,\n  TaggedTemplateExpression: _TaggedTemplateExpression2.default,\n  TemplateLiteral: _TemplateLiteral2.default,\n  ArrowFunctionExpression: _FunctionExpression2.default,\n  FunctionExpression: _FunctionExpression2.default,\n  LogicalExpression: _LogicalExpression2.default,\n  MemberExpression: _MemberExpression2.default,\n  OptionalCallExpression: _OptionalCallExpression2.default,\n  OptionalMemberExpression: _OptionalMemberExpression2.default,\n  CallExpression: _CallExpression2.default,\n  UnaryExpression: _UnaryExpression2.default,\n  ThisExpression: _ThisExpression2.default,\n  ConditionalExpression: _ConditionalExpression2.default,\n  BinaryExpression: _BinaryExpression2.default,\n  ObjectExpression: _ObjectExpression2.default,\n  NewExpression: _NewExpression2.default,\n  UpdateExpression: _UpdateExpression2.default,\n  ArrayExpression: _ArrayExpression2.default,\n  BindExpression: _BindExpression2.default,\n  SpreadElement: _SpreadElement2.default,\n  TypeCastExpression: _TypeCastExpression2.default\n};\n\nvar noop = function noop() {\n  return null;\n};\n\nvar errorMessage = function errorMessage(expression) {\n  return 'The prop value with an expression type of ' + expression + ' could not be resolved. Please file issue to get this fixed immediately.';\n};\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nfunction extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  var expression = void 0;\n  if (typeof value.expression !== 'boolean' && value.expression) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n  var _expression = expression,\n      type = _expression.type;\n\n\n  while (type === 'TSNonNullExpression' || type === 'TSAsExpression') {\n    var _expression2 = expression;\n    type = _expression2.type;\n\n    if (expression.expression) {\n      var _expression3 = expression;\n      expression = _expression3.expression;\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n}\n\n// Composition map of types to their extractor functions to handle literals.\nvar LITERAL_TYPES = _extends({}, TYPES, {\n  Literal: function Literal(value) {\n    var extractedVal = TYPES.Literal.call(undefined, value);\n    var isNull = extractedVal === null;\n    // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: function Identifier(value) {\n    var isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: function UnaryExpression(value) {\n    var extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: function UpdateExpression(value) {\n    var extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: function ArrayExpression(value) {\n    var extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter(function (val) {\n      return val !== null;\n    });\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop\n});\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nfunction extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  var expression = value.expression || value;\n  var type = expression.type;\n\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}"]},"metadata":{},"sourceType":"script"}