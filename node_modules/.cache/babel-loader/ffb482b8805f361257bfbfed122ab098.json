{"ast":null,"code":"// AST walker module for Mozilla Parser API compatible trees\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  (function c(node, st, override) {\n    var type = override || node.type,\n        found = visitors[type];\n    baseVisitor[type](node, st, c);\n\n    if (found) {\n      found(node, st);\n    }\n  })(node, state, override);\n} // An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\n\n\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  (function c(node, st, override) {\n    var type = override || node.type,\n        found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n\n    if (isNew) {\n      ancestors.push(node);\n    }\n\n    baseVisitor[type](node, st, c);\n\n    if (found) {\n      found(node, st || ancestors, ancestors);\n    }\n\n    if (isNew) {\n      ancestors.pop();\n    }\n  })(node, state);\n} // A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\n\n\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;\n\n  (function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\") {\n    return function (type) {\n      return type === test;\n    };\n  } else if (!test) {\n    return function () {\n      return true;\n    };\n  } else {\n    return test;\n  }\n}\n\nvar Found = function Found(node, state) {\n  this.node = node;\n  this.state = state;\n}; // A full walk triggers the callback on each node\n\n\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  (function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n\n    if (!override) {\n      callback(node, st, type);\n    }\n  })(node, state, override);\n} // An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\n\n\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  var ancestors = [];\n\n  (function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n\n    if (isNew) {\n      ancestors.push(node);\n    }\n\n    baseVisitor[type](node, st, c);\n\n    if (!override) {\n      callback(node, st || ancestors, ancestors, type);\n    }\n\n    if (isNew) {\n      ancestors.pop();\n    }\n  })(node, state);\n} // Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\n\n\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  test = makeTest(test);\n\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n\n      if ((start == null || node.start <= start) && (end == null || node.end >= end)) {\n        baseVisitor[type](node, st, c);\n      }\n\n      if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {\n        throw new Found(node, st);\n      }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n\n    throw e;\n  }\n} // Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\n\n\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n\n      if (node.start > pos || node.end < pos) {\n        return;\n      }\n\n      baseVisitor[type](node, st, c);\n\n      if (test(type, node)) {\n        throw new Found(node, st);\n      }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n\n    throw e;\n  }\n} // Find the outermost matching node after a given position.\n\n\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) {\n        return;\n      }\n\n      var type = override || node.type;\n\n      if (node.start >= pos && test(type, node)) {\n        throw new Found(node, st);\n      }\n\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n\n    throw e;\n  }\n} // Find the outermost matching node before a given position.\n\n\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  var max;\n\n  (function c(node, st, override) {\n    if (node.start > pos) {\n      return;\n    }\n\n    var type = override || node.type;\n\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {\n      max = new Found(node, st);\n    }\n\n    baseVisitor[type](node, st, c);\n  })(node, state);\n\n  return max;\n} // Fallback to an Object.create polyfill for older environments.\n\n\nvar create = Object.create || function (proto) {\n  function Ctor() {}\n\n  Ctor.prototype = proto;\n  return new Ctor();\n}; // Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\n\n\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n\n  for (var type in funcs) {\n    visitor[type] = funcs[type];\n  }\n\n  return visitor;\n}\n\nfunction skipThrough(node, st, c) {\n  c(node, st);\n}\n\nfunction ignore(_node, _st, _c) {} // Node walkers.\n\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var stmt = list[i];\n    c(stmt, st, \"Statement\");\n  }\n};\n\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\n\nbase.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {\n  return c(node.expression, st, \"Expression\");\n};\n\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n\n  if (node.alternate) {\n    c(node.alternate, st, \"Statement\");\n  }\n};\n\nbase.LabeledStatement = function (node, st, c) {\n  return c(node.body, st, \"Statement\");\n};\n\nbase.BreakStatement = base.ContinueStatement = ignore;\n\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n\n  for (var i = 0, list = node.cases; i < list.length; i += 1) {\n    var cs = list[i];\n\n    if (cs.test) {\n      c(cs.test, st, \"Expression\");\n    }\n\n    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1) {\n      var cons = list$1[i$1];\n      c(cons, st, \"Statement\");\n    }\n  }\n};\n\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n\n  for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n    var cons = list[i];\n    c(cons, st, \"Statement\");\n  }\n};\n\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) {\n    c(node.argument, st, \"Expression\");\n  }\n};\n\nbase.ThrowStatement = base.SpreadElement = function (node, st, c) {\n  return c(node.argument, st, \"Expression\");\n};\n\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n\n  if (node.handler) {\n    c(node.handler, st);\n  }\n\n  if (node.finalizer) {\n    c(node.finalizer, st, \"Statement\");\n  }\n};\n\nbase.CatchClause = function (node, st, c) {\n  if (node.param) {\n    c(node.param, st, \"Pattern\");\n  }\n\n  c(node.body, st, \"ScopeBody\");\n};\n\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase.ForStatement = function (node, st, c) {\n  if (node.init) {\n    c(node.init, st, \"ForInit\");\n  }\n\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n\n  if (node.update) {\n    c(node.update, st, \"Expression\");\n  }\n\n  c(node.body, st, \"Statement\");\n};\n\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") {\n    c(node, st);\n  } else {\n    c(node, st, \"Expression\");\n  }\n};\n\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) {\n  return c(node, st, \"Function\");\n};\n\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n    var decl = list[i];\n    c(decl, st);\n  }\n};\n\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n\n  if (node.init) {\n    c(node.init, st, \"Expression\");\n  }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    c(param, st, \"Pattern\");\n  }\n\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n}; // FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\n\n\nbase.ScopeBody = function (node, st, c) {\n  return c(node, st, \"Statement\");\n};\n\nbase.ScopeExpression = function (node, st, c) {\n  return c(node, st, \"Expression\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\") {\n    c(node, st, \"VariablePattern\");\n  } else if (node.type === \"MemberExpression\") {\n    c(node, st, \"MemberPattern\");\n  } else {\n    c(node, st);\n  }\n};\n\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\n\nbase.RestElement = function (node, st, c) {\n  return c(node.argument, st, \"Pattern\");\n};\n\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) {\n      c(elt, st, \"Pattern\");\n    }\n  }\n};\n\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) {\n        c(prop.key, st, \"Expression\");\n      }\n\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\n\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) {\n      c(elt, st, \"Expression\");\n    }\n  }\n};\n\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n    c(prop, st);\n  }\n};\n\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n\nbase.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n    var expr = list[i];\n    c(expr, st, \"Expression\");\n  }\n};\n\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\n\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\n\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\n\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\n\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n\n  if (node.arguments) {\n    for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n      var arg = list[i];\n      c(arg, st, \"Expression\");\n    }\n  }\n};\n\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n\n  if (node.computed) {\n    c(node.property, st, \"Expression\");\n  }\n};\n\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration) {\n    c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n  }\n\n  if (node.source) {\n    c(node.source, st, \"Expression\");\n  }\n};\n\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\n\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n    var spec = list[i];\n    c(spec, st);\n  }\n\n  c(node.source, st, \"Expression\");\n};\n\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\n\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) {\n  return c(node, st, \"Class\");\n};\n\nbase.Class = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n\n  if (node.superClass) {\n    c(node.superClass, st, \"Expression\");\n  }\n\n  c(node.body, st);\n};\n\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var elt = list[i];\n    c(elt, st);\n  }\n};\n\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) {\n    c(node.key, st, \"Expression\");\n  }\n\n  c(node.value, st, \"Expression\");\n};\n\nexport { simple, ancestor, recursive, full, fullAncestor, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsdom/node_modules/acorn/dist/walk.es.js"],"names":["simple","node","visitors","baseVisitor","state","override","base","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","create","Object","proto","Ctor","prototype","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","cases","cs","i$1","list$1","cons","SwitchCase","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","ScopeBody","ScopeExpression","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","TemplateLiteral","expressions","expr","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","ImportDeclaration","specifiers","spec","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","Literal","TaggedTemplateExpression","tag","quasi","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","Property"],"mappings":"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","sourcesContent":["// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = [];(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i = 0, list = node.cases; i < list.length; i += 1) {\n    var cs = list[i];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1)\n      {\n      var cons = list$1[i$1];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"ScopeBody\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n};\n// FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\nbase.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); };\nbase.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); };\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\nexport { simple, ancestor, recursive, full, fullAncestor, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };\n"]},"metadata":{},"sourceType":"module"}