{"ast":null,"code":"/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\n\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow named `function` expressions\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-names\"\n    },\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always\", \"as-needed\", \"never\"]\n        }\n      },\n      items: [{\n        $ref: \"#/definitions/value\"\n      }, {\n        type: \"object\",\n        properties: {\n          generators: {\n            $ref: \"#/definitions/value\"\n          }\n        },\n        additionalProperties: false\n      }]\n    },\n    messages: {\n      unnamed: \"Unexpected unnamed {{name}}.\",\n      named: \"Unexpected named {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Returns the config option for the given node.\n     * @param {ASTNode} node A node to get the config for.\n     * @returns {string} The config option.\n     */\n\n    function getConfigForNode(node) {\n      if (node.generator && context.options.length > 1 && context.options[1].generators) {\n        return context.options[1].generators;\n      }\n\n      return context.options[0] || \"always\";\n    }\n    /**\n     * Determines whether the current FunctionExpression node is a get, set, or\n     * shorthand method in an object literal or a class.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node is a get, set, or shorthand method.\n     */\n\n\n    function isObjectOrClassMethod(node) {\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.method || parent.kind === \"get\" || parent.kind === \"set\");\n    }\n    /**\n     * Determines whether the current FunctionExpression node has a name that would be\n     * inferred from context in a conforming ES6 environment.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} True if the node would have a name assigned automatically.\n     */\n\n\n    function hasInferredName(node) {\n      const parent = node.parent;\n      return isObjectOrClassMethod(node) || parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node || parent.type === \"Property\" && parent.value === node || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node || parent.type === \"ExportDefaultDeclaration\" && parent.declaration === node || parent.type === \"AssignmentPattern\" && parent.right === node;\n    }\n    /**\n     * Reports that an unnamed function should be named\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @returns {void}\n     */\n\n\n    function reportUnexpectedUnnamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"unnamed\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n    /**\n     * Reports that a named function should be unnamed\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @returns {void}\n     */\n\n\n    function reportUnexpectedNamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"named\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n\n    return {\n      \"FunctionExpression:exit\"(node) {\n        // Skip recursive functions.\n        const nameVar = context.getDeclaredVariables(node)[0];\n\n        if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n          return;\n        }\n\n        const hasName = Boolean(node.id && node.id.name);\n        const config = getConfigForNode(node);\n\n        if (config === \"never\") {\n          if (hasName) {\n            reportUnexpectedNamedFunction(node);\n          }\n        } else if (config === \"as-needed\") {\n          if (!hasName && !hasInferredName(node)) {\n            reportUnexpectedUnnamedFunction(node);\n          }\n        } else {\n          if (!hasName && !isObjectOrClassMethod(node)) {\n            reportUnexpectedUnnamedFunction(node);\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/func-names.js"],"names":["astUtils","require","isFunctionName","variable","defs","type","module","exports","meta","docs","description","category","recommended","url","schema","definitions","value","enum","items","$ref","properties","generators","additionalProperties","messages","unnamed","named","create","context","sourceCode","getSourceCode","getConfigForNode","node","generator","options","length","isObjectOrClassMethod","parent","method","kind","hasInferredName","id","init","left","right","declaration","reportUnexpectedUnnamedFunction","report","messageId","loc","getFunctionHeadLoc","data","name","getFunctionNameWithKind","reportUnexpectedNamedFunction","nameVar","getDeclaredVariables","references","hasName","Boolean","config"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-names\"\n        },\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always\",\n                        \"as-needed\",\n                        \"never\"\n                    ]\n                }\n            },\n            items: [\n                {\n                    $ref: \"#/definitions/value\"\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        generators: {\n                            $ref: \"#/definitions/value\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        },\n\n        messages: {\n            unnamed: \"Unexpected unnamed {{name}}.\",\n            named: \"Unexpected named {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the config option for the given node.\n         * @param {ASTNode} node A node to get the config for.\n         * @returns {string} The config option.\n         */\n        function getConfigForNode(node) {\n            if (\n                node.generator &&\n                context.options.length > 1 &&\n                context.options[1].generators\n            ) {\n                return context.options[1].generators;\n            }\n\n            return context.options[0] || \"always\";\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"ExportDefaultDeclaration\" && parent.declaration === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.right === node);\n        }\n\n        /**\n         * Reports that an unnamed function should be named\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedUnnamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"unnamed\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * Reports that a named function should be unnamed\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedNamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"named\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        return {\n            \"FunctionExpression:exit\"(node) {\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                const hasName = Boolean(node.id && node.id.name);\n                const config = getConfigForNode(node);\n\n                if (config === \"never\") {\n                    if (hasName) {\n                        reportUnexpectedNamedFunction(node);\n                    }\n                } else if (config === \"as-needed\") {\n                    if (!hasName && !hasInferredName(node)) {\n                        reportUnexpectedUnnamedFunction(node);\n                    }\n                } else {\n                    if (!hasName && !isObjectOrClassMethod(node)) {\n                        reportUnexpectedUnnamedFunction(node);\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}