{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.expiration = function (exports, DBWrapper_mjs, deleteDatabase_mjs, WorkboxError_mjs, assert_mjs, logger_mjs, cacheNames_mjs, getFriendlyURL_mjs, registerQuotaErrorCallback_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:expiration:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const DB_NAME = 'workbox-expiration';\n  const OBJECT_STORE_NAME = 'cache-entries';\n\n  const normalizeURL = unNormalizedUrl => {\n    const url = new URL(unNormalizedUrl, location);\n    url.hash = '';\n    return url.href;\n  };\n  /**\n   * Returns the timestamp model.\n   *\n   * @private\n   */\n\n\n  class CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n      this._cacheName = cacheName;\n      this._db = new DBWrapper_mjs.DBWrapper(DB_NAME, 1, {\n        onupgradeneeded: event => this._handleUpgrade(event)\n      });\n    }\n    /**\n     * Should perform an upgrade of indexedDB.\n     *\n     * @param {Event} event\n     *\n     * @private\n     */\n\n\n    _handleUpgrade(event) {\n      const db = event.target.result; // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n      // have to use the `id` keyPath here and create our own values (a\n      // concatenation of `url + cacheName`) instead of simply using\n      // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n\n      const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n        keyPath: 'id'\n      }); // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n      // create a single index with the keyPath `['cacheName', 'timestamp']`\n      // instead of doing both these indexes.\n\n      objStore.createIndex('cacheName', 'cacheName', {\n        unique: false\n      });\n      objStore.createIndex('timestamp', 'timestamp', {\n        unique: false\n      }); // Previous versions of `workbox-expiration` used `this._cacheName`\n      // as the IDBDatabase name.\n\n      deleteDatabase_mjs.deleteDatabase(this._cacheName);\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n\n\n    async setTimestamp(url, timestamp) {\n      url = normalizeURL(url);\n      await this._db.put(OBJECT_STORE_NAME, {\n        url,\n        timestamp,\n        cacheName: this._cacheName,\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        id: this._getId(url)\n      });\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number}\n     *\n     * @private\n     */\n\n\n    async getTimestamp(url) {\n      const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n      return entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     *\n     * @private\n     */\n\n\n    async expireEntries(minTimestamp, maxCount) {\n      const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n        const store = txn.objectStore(OBJECT_STORE_NAME);\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n\n        store.index('timestamp').openCursor(null, 'prev').onsuccess = ({\n          target\n        }) => {\n          const cursor = target.result;\n\n          if (cursor) {\n            const result = cursor.value; // TODO(philipwalton): once we can use a multi-key index, we\n            // won't have to check `cacheName` here.\n\n            if (result.cacheName === this._cacheName) {\n              // Delete an entry if it's older than the max age or\n              // if we already have the max number allowed.\n              if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n                // TODO(philipwalton): we should be able to delete the\n                // entry right here, but doing so causes an iteration\n                // bug in Safari stable (fixed in TP). Instead we can\n                // store the keys of the entries to delete, and then\n                // delete the separate transactions.\n                // https://github.com/GoogleChrome/workbox/issues/1978\n                // cursor.delete();\n                // We only need to return the URL, not the whole entry.\n                entriesToDelete.push(cursor.value);\n              } else {\n                entriesNotDeletedCount++;\n              }\n            }\n\n            cursor.continue();\n          } else {\n            done(entriesToDelete);\n          }\n        };\n      }); // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n      // we should be able to remove this loop and do the entry deletion in the\n      // cursor loop above:\n      // https://github.com/GoogleChrome/workbox/issues/1978\n\n      const urlsDeleted = [];\n\n      for (const entry of entriesToDelete) {\n        await this._db.delete(OBJECT_STORE_NAME, entry.id);\n        urlsDeleted.push(entry.url);\n      }\n\n      return urlsDeleted;\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */\n\n\n    _getId(url) {\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      return this._cacheName + '|' + normalizeURL(url);\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * The `CacheExpiration` class allows you define an expiration and / or\n   * limit on the number of responses stored in a\n   * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n   *\n   * @memberof workbox.expiration\n   */\n\n\n  class CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */\n    constructor(cacheName, config = {}) {\n      {\n        assert_mjs.assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'cacheName'\n        });\n\n        if (!(config.maxEntries || config.maxAgeSeconds)) {\n          throw new WorkboxError_mjs.WorkboxError('max-entries-or-age-required', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor'\n          });\n        }\n\n        if (config.maxEntries) {\n          assert_mjs.assert.isType(config.maxEntries, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'config.maxEntries'\n          }); // TODO: Assert is positive\n        }\n\n        if (config.maxAgeSeconds) {\n          assert_mjs.assert.isType(config.maxAgeSeconds, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'config.maxAgeSeconds'\n          }); // TODO: Assert is positive\n        }\n      }\n      this._isRunning = false;\n      this._rerunRequested = false;\n      this._maxEntries = config.maxEntries;\n      this._maxAgeSeconds = config.maxAgeSeconds;\n      this._cacheName = cacheName;\n      this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n\n\n    async expireEntries() {\n      if (this._isRunning) {\n        this._rerunRequested = true;\n        return;\n      }\n\n      this._isRunning = true;\n      const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : undefined;\n      const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n      const cache = await caches.open(this._cacheName);\n\n      for (const url of urlsExpired) {\n        await cache.delete(url);\n      }\n\n      {\n        if (urlsExpired.length > 0) {\n          logger_mjs.logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n          logger_mjs.logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n          urlsExpired.forEach(url => logger_mjs.logger.log(`    ${url}`));\n          logger_mjs.logger.groupEnd();\n        } else {\n          logger_mjs.logger.debug(`Cache expiration ran and found no entries to remove.`);\n        }\n      }\n      this._isRunning = false;\n\n      if (this._rerunRequested) {\n        this._rerunRequested = false;\n        this.expireEntries();\n      }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n\n\n    async updateTimestamp(url) {\n      {\n        assert_mjs.assert.isType(url, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'updateTimestamp',\n          paramName: 'url'\n        });\n      }\n      await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n\n\n    async isURLExpired(url) {\n      {\n        if (!this._maxAgeSeconds) {\n          throw new WorkboxError_mjs.WorkboxError(`expired-test-without-max-age`, {\n            methodName: 'isURLExpired',\n            paramName: 'maxAgeSeconds'\n          });\n        }\n      }\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp < expireOlderThan;\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n\n\n    async delete() {\n      // Make sure we don't attempt another rerun if we're called in the middle of\n      // a cache expiration.\n      this._rerunRequested = false;\n      await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This plugin can be used in the Workbox APIs to regularly enforce a\n   * limit on the age and / or the number of cached requests.\n   *\n   * Whenever a cached request is used or updated, this plugin will look\n   * at the used Cache and remove any old or extra requests.\n   *\n   * When using `maxAgeSeconds`, requests may be used *once* after expiring\n   * because the expiration clean up will not have occurred until *after* the\n   * cached request has been used. If the request has a \"Date\" header, then\n   * a light weight expiration check is performed and the request will not be\n   * used immediately.\n   *\n   * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n   *\n   * @memberof workbox.expiration\n   */\n\n\n  class Plugin {\n    /**\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n      {\n        if (!(config.maxEntries || config.maxAgeSeconds)) {\n          throw new WorkboxError_mjs.WorkboxError('max-entries-or-age-required', {\n            moduleName: 'workbox-expiration',\n            className: 'Plugin',\n            funcName: 'constructor'\n          });\n        }\n\n        if (config.maxEntries) {\n          assert_mjs.assert.isType(config.maxEntries, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'Plugin',\n            funcName: 'constructor',\n            paramName: 'config.maxEntries'\n          });\n        }\n\n        if (config.maxAgeSeconds) {\n          assert_mjs.assert.isType(config.maxAgeSeconds, 'number', {\n            moduleName: 'workbox-expiration',\n            className: 'Plugin',\n            funcName: 'constructor',\n            paramName: 'config.maxAgeSeconds'\n          });\n        }\n      }\n      this._config = config;\n      this._maxAgeSeconds = config.maxAgeSeconds;\n      this._cacheExpirations = new Map();\n\n      if (config.purgeOnQuotaError) {\n        registerQuotaErrorCallback_mjs.registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n      }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n\n\n    _getCacheExpiration(cacheName) {\n      if (cacheName === cacheNames_mjs.cacheNames.getRuntimeName()) {\n        throw new WorkboxError_mjs.WorkboxError('expire-custom-caches-only');\n      }\n\n      let cacheExpiration = this._cacheExpirations.get(cacheName);\n\n      if (!cacheExpiration) {\n        cacheExpiration = new CacheExpiration(cacheName, this._config);\n\n        this._cacheExpirations.set(cacheName, cacheExpiration);\n      }\n\n      return cacheExpiration;\n    }\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox.strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n\n\n    cachedResponseWillBeUsed({\n      event,\n      request,\n      cacheName,\n      cachedResponse\n    }) {\n      if (!cachedResponse) {\n        return null;\n      }\n\n      let isFresh = this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n      // expired, it'll only be used once.\n\n\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n\n      cacheExpiration.expireEntries(); // Update the metadata for the request URL to the current timestamp,\n      // but don't `await` it as we don't want to block the response.\n\n      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n\n      if (event) {\n        try {\n          event.waitUntil(updateTimestampDone);\n        } catch (error) {\n          {\n            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n\n      return isFresh ? cachedResponse : null;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n\n\n    _isResponseDateFresh(cachedResponse) {\n      if (!this._maxAgeSeconds) {\n        // We aren't expiring by age, so return true, it's fresh\n        return true;\n      } // Check if the 'date' header will suffice a quick expiration check.\n      // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n      // discussion.\n\n\n      const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n\n      if (dateHeaderTimestamp === null) {\n        // Unable to parse date, so assume it's fresh.\n        return true;\n      } // If we have a valid headerTime, then our response is fresh iff the\n      // headerTime plus maxAgeSeconds is greater than the current time.\n\n\n      const now = Date.now();\n      return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number}\n     *\n     * @private\n     */\n\n\n    _getDateHeaderTimestamp(cachedResponse) {\n      if (!cachedResponse.headers.has('date')) {\n        return null;\n      }\n\n      const dateHeader = cachedResponse.headers.get('date');\n      const parsedDate = new Date(dateHeader);\n      const headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n      // will return NaN.\n\n      if (isNaN(headerTime)) {\n        return null;\n      }\n\n      return headerTime;\n    }\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox.strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n\n\n    async cacheDidUpdate({\n      cacheName,\n      request\n    }) {\n      {\n        assert_mjs.assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'cacheName'\n        });\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'request'\n        });\n      }\n\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n\n      await cacheExpiration.updateTimestamp(request.url);\n      await cacheExpiration.expireEntries();\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n\n\n    async deleteCacheAndMetadata() {\n      // Do this one at a time instead of all at once via `Promise.all()` to\n      // reduce the chance of inconsistency if a promise rejects.\n      for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n        await caches.delete(cacheName);\n        await cacheExpiration.delete();\n      } // Reset this._cacheExpirations to its initial state.\n\n\n      this._cacheExpirations = new Map();\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.CacheExpiration = CacheExpiration;\n  exports.Plugin = Plugin;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core);","map":{"version":3,"sources":["../_version.mjs","../models/CacheTimestampsModel.mjs","../CacheExpiration.mjs","../Plugin.mjs","../index.mjs"],"names":["self","_","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","constructor","DBWrapper","onupgradeneeded","event","_handleUpgrade","db","objStore","keyPath","unique","deleteDatabase","cacheName","id","entry","entriesToDelete","store","txn","entriesNotDeletedCount","target","cursor","result","minTimestamp","maxCount","done","urlsDeleted","_getId","config","assert","moduleName","className","funcName","paramName","WorkboxError","Date","urlsExpired","cache","caches","logger","length","_cacheName","methodName","timestamp","expireOlderThan","registerQuotaErrorCallback","_getCacheExpiration","cacheNames","cacheExpiration","cachedResponseWillBeUsed","cachedResponse","isFresh","updateTimestampDone","request","getFriendlyURL","_isResponseDateFresh","dateHeaderTimestamp","now","_getDateHeaderTimestamp","dateHeader","parsedDate","headerTime","isNaN"],"mappings":"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","sourcesContent":["try{self['workbox:expiration:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const entriesToDelete = await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesToDelete = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      // TODO(philipwalton): we should be able to delete the\n                      // entry right here, but doing so causes an iteration\n                      // bug in Safari stable (fixed in TP). Instead we can\n                      // store the keys of the entries to delete, and then\n                      // delete the separate transactions.\n                      // https://github.com/GoogleChrome/workbox/issues/1978\n                      // cursor.delete();\n\n                      // We only need to return the URL, not the whole entry.\n                      entriesToDelete.push(cursor.value);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesToDelete);\n                }\n              };\n        });\n\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport {Plugin} from './Plugin.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.expiration\n */\n\nexport {\n  CacheExpiration,\n  Plugin,\n};\n"]},"metadata":{},"sourceType":"script"}