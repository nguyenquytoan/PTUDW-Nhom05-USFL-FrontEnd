{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar path = require('path'),\n    fs = require('fs'),\n    compose = require('compose-function'),\n    Iterator = require('es6-iterator');\n\nvar PACKAGE_NAME = require('../package.json').name;\n\nvar simpleJoin = compose(path.normalize, path.join);\n/**\n * The default join function iterates over possible base paths until a suitable join is found.\n *\n * The first base path is used as fallback for the case where none of the base paths can locate the actual file.\n *\n * @type {function}\n */\n\nexports.defaultJoin = createJoinForPredicate(function predicate(_, uri, base, i, next) {\n  var absolute = simpleJoin(base, uri);\n  return fs.existsSync(absolute) ? absolute : next(i === 0 ? absolute : null);\n}, 'defaultJoin');\n/**\n * Define a join function by a predicate that tests possible base paths from an iterator.\n *\n * The `predicate` is of the form:\n *\n * ```\n * function(filename, uri, base, i, next):string|null\n * ```\n *\n * Given the uri and base it should either return:\n * - an absolute path success\n * - a call to `next(null)` as failure\n * - a call to `next(absolute)` where absolute is placeholder and the iterator continues\n *\n * The value given to `next(...)` is only used if success does not eventually occur.\n *\n * The `file` value is typically unused but useful if you would like to differentiate behaviour.\n *\n * You can write a much simpler function than this if you have specific requirements.\n *\n * @param {function} predicate A function that tests values\n * @param {string} [name] Optional name for the resulting join function\n */\n\nfunction createJoinForPredicate(predicate, name) {\n  /**\n   * A factory for a join function with logging.\n   *\n   * @param {string} filename The current file being processed\n   * @param {{debug:function|boolean,root:string}} options An options hash\n   */\n  function join(filename, options) {\n    var log = createDebugLogger(options.debug);\n    /**\n     * Join function proper.\n     *\n     * For absolute uri only `uri` will be provided. In this case we substitute any `root` given in options.\n     *\n     * @param {string} uri A uri path, relative or absolute\n     * @param {string|Iterator.<string>} [baseOrIteratorOrAbsent] Optional absolute base path or iterator thereof\n     * @return {string} Just the uri where base is empty or the uri appended to the base\n     */\n\n    return function joinProper(uri, baseOrIteratorOrAbsent) {\n      var iterator = typeof baseOrIteratorOrAbsent === 'undefined' && new Iterator([options.root]) || typeof baseOrIteratorOrAbsent === 'string' && new Iterator([baseOrIteratorOrAbsent]) || baseOrIteratorOrAbsent;\n      var result = runIterator([]);\n      log(createJoinMsg, [filename, uri, result, result.isFound]);\n      return typeof result.absolute === 'string' ? result.absolute : uri;\n\n      function runIterator(accumulator) {\n        var nextItem = iterator.next();\n        var base = !nextItem.done && nextItem.value;\n\n        if (typeof base === 'string') {\n          var element = predicate(filename, uri, base, accumulator.length, next);\n\n          if (typeof element === 'string' && path.isAbsolute(element)) {\n            return Object.assign(accumulator.concat(base), {\n              isFound: true,\n              absolute: element\n            });\n          } else if (Array.isArray(element)) {\n            return element;\n          } else {\n            throw new Error('predicate must return an absolute path or the result of calling next()');\n          }\n        } else {\n          return accumulator;\n        }\n\n        function next(fallback) {\n          return runIterator(Object.assign(accumulator.concat(base), typeof fallback === 'string' && {\n            absolute: fallback\n          }));\n        }\n      }\n    };\n  }\n\n  function toString() {\n    return '[Function: ' + name + ']';\n  }\n\n  return Object.assign(join, name && {\n    valueOf: toString,\n    toString: toString\n  });\n}\n\nexports.createJoinForPredicate = createJoinForPredicate;\n/**\n * Format a debug message.\n *\n * @param {string} file The file being processed by webpack\n * @param {string} uri A uri path, relative or absolute\n * @param {Array.<string>} bases Absolute base paths up to and including the found one\n * @param {boolean} isFound Indicates the last base was correct\n * @return {string} Formatted message\n */\n\nfunction createJoinMsg(file, uri, bases, isFound) {\n  return [PACKAGE_NAME + ': ' + pathToString(file) + ': ' + uri].concat(bases.map(pathToString).filter(Boolean)).concat(isFound ? 'FOUND' : 'NOT FOUND').join('\\n  ');\n  /**\n   * If given path is within `process.cwd()` then show relative posix path, otherwise show absolute posix path.\n   *\n   * @param {string} absolute An absolute path\n   * @return {string} A relative or absolute path\n   */\n\n  function pathToString(absolute) {\n    if (!absolute) {\n      return null;\n    } else {\n      var relative = path.relative(process.cwd(), absolute).split(path.sep);\n      return (relative[0] === '..' ? absolute.split(path.sep) : ['.'].concat(relative).filter(Boolean)).join('/');\n    }\n  }\n}\n\nexports.createJoinMsg = createJoinMsg;\n/**\n * A factory for a log function predicated on the given debug parameter.\n *\n * The logging function created accepts a function that formats a message and parameters that the function utilises.\n * Presuming the message function may be expensive we only call it if logging is enabled.\n *\n * The log messages are de-duplicated based on the parameters, so it is assumed they are simple types that stringify\n * well.\n *\n * @param {function|boolean} debug A boolean or debug function\n * @return {function(function, array)} A logging function possibly degenerate\n */\n\nfunction createDebugLogger(debug) {\n  var log = !!debug && (typeof debug === 'function' ? debug : console.log);\n  var cache = {};\n  return log ? actuallyLog : noop;\n\n  function noop() {}\n\n  function actuallyLog(msgFn, params) {\n    var key = JSON.stringify(params);\n\n    if (!cache[key]) {\n      cache[key] = true;\n      log(msgFn.apply(null, params));\n    }\n  }\n}\n\nexports.createDebugLogger = createDebugLogger;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/resolve-url-loader/lib/join-function.js"],"names":["path","require","fs","compose","Iterator","PACKAGE_NAME","name","simpleJoin","normalize","join","exports","defaultJoin","createJoinForPredicate","predicate","_","uri","base","i","next","absolute","existsSync","filename","options","log","createDebugLogger","debug","joinProper","baseOrIteratorOrAbsent","iterator","root","result","runIterator","createJoinMsg","isFound","accumulator","nextItem","done","value","element","length","isAbsolute","Object","assign","concat","Array","isArray","Error","fallback","toString","valueOf","file","bases","pathToString","map","filter","Boolean","relative","process","cwd","split","sep","console","cache","actuallyLog","noop","msgFn","params","key","JSON","stringify","apply"],"mappings":"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","sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar path     = require('path'),\n    fs       = require('fs'),\n    compose  = require('compose-function'),\n    Iterator = require('es6-iterator');\n\nvar PACKAGE_NAME = require('../package.json').name;\n\nvar simpleJoin = compose(path.normalize, path.join);\n\n/**\n * The default join function iterates over possible base paths until a suitable join is found.\n *\n * The first base path is used as fallback for the case where none of the base paths can locate the actual file.\n *\n * @type {function}\n */\nexports.defaultJoin = createJoinForPredicate(\n  function predicate(_, uri, base, i, next) {\n    var absolute = simpleJoin(base, uri);\n    return fs.existsSync(absolute) ? absolute : next((i === 0) ? absolute : null);\n  },\n  'defaultJoin'\n);\n\n/**\n * Define a join function by a predicate that tests possible base paths from an iterator.\n *\n * The `predicate` is of the form:\n *\n * ```\n * function(filename, uri, base, i, next):string|null\n * ```\n *\n * Given the uri and base it should either return:\n * - an absolute path success\n * - a call to `next(null)` as failure\n * - a call to `next(absolute)` where absolute is placeholder and the iterator continues\n *\n * The value given to `next(...)` is only used if success does not eventually occur.\n *\n * The `file` value is typically unused but useful if you would like to differentiate behaviour.\n *\n * You can write a much simpler function than this if you have specific requirements.\n *\n * @param {function} predicate A function that tests values\n * @param {string} [name] Optional name for the resulting join function\n */\nfunction createJoinForPredicate(predicate, name) {\n  /**\n   * A factory for a join function with logging.\n   *\n   * @param {string} filename The current file being processed\n   * @param {{debug:function|boolean,root:string}} options An options hash\n   */\n  function join(filename, options) {\n    var log = createDebugLogger(options.debug);\n\n    /**\n     * Join function proper.\n     *\n     * For absolute uri only `uri` will be provided. In this case we substitute any `root` given in options.\n     *\n     * @param {string} uri A uri path, relative or absolute\n     * @param {string|Iterator.<string>} [baseOrIteratorOrAbsent] Optional absolute base path or iterator thereof\n     * @return {string} Just the uri where base is empty or the uri appended to the base\n     */\n    return function joinProper(uri, baseOrIteratorOrAbsent) {\n      var iterator =\n        (typeof baseOrIteratorOrAbsent === 'undefined') && new Iterator([options.root          ]) ||\n        (typeof baseOrIteratorOrAbsent === 'string'   ) && new Iterator([baseOrIteratorOrAbsent]) ||\n        baseOrIteratorOrAbsent;\n\n      var result = runIterator([]);\n      log(createJoinMsg, [filename, uri, result, result.isFound]);\n\n      return (typeof result.absolute === 'string') ? result.absolute : uri;\n\n      function runIterator(accumulator) {\n        var nextItem = iterator.next();\n        var base     = !nextItem.done && nextItem.value;\n        if (typeof base === 'string') {\n          var element = predicate(filename, uri, base, accumulator.length, next);\n\n          if ((typeof element === 'string') && path.isAbsolute(element)) {\n            return Object.assign(\n              accumulator.concat(base),\n              {isFound: true, absolute: element}\n            );\n          } else if (Array.isArray(element)) {\n            return element;\n          } else {\n            throw new Error('predicate must return an absolute path or the result of calling next()');\n          }\n        } else {\n          return accumulator;\n        }\n\n        function next(fallback) {\n          return runIterator(Object.assign(\n            accumulator.concat(base),\n            (typeof fallback === 'string') && {absolute: fallback}\n          ));\n        }\n      }\n    };\n  }\n\n  function toString() {\n    return '[Function: ' + name + ']';\n  }\n\n  return Object.assign(join, name && {\n    valueOf : toString,\n    toString: toString\n  });\n}\n\nexports.createJoinForPredicate = createJoinForPredicate;\n\n/**\n * Format a debug message.\n *\n * @param {string} file The file being processed by webpack\n * @param {string} uri A uri path, relative or absolute\n * @param {Array.<string>} bases Absolute base paths up to and including the found one\n * @param {boolean} isFound Indicates the last base was correct\n * @return {string} Formatted message\n */\nfunction createJoinMsg(file, uri, bases, isFound) {\n  return [PACKAGE_NAME + ': ' + pathToString(file) + ': ' + uri]\n    .concat(bases.map(pathToString).filter(Boolean))\n    .concat(isFound ? 'FOUND' : 'NOT FOUND')\n    .join('\\n  ');\n\n  /**\n   * If given path is within `process.cwd()` then show relative posix path, otherwise show absolute posix path.\n   *\n   * @param {string} absolute An absolute path\n   * @return {string} A relative or absolute path\n   */\n  function pathToString(absolute) {\n    if (!absolute) {\n      return null;\n    } else {\n      var relative = path.relative(process.cwd(), absolute)\n        .split(path.sep);\n\n      return ((relative[0] === '..') ? absolute.split(path.sep) : ['.'].concat(relative).filter(Boolean))\n        .join('/');\n    }\n  }\n}\n\nexports.createJoinMsg = createJoinMsg;\n\n/**\n * A factory for a log function predicated on the given debug parameter.\n *\n * The logging function created accepts a function that formats a message and parameters that the function utilises.\n * Presuming the message function may be expensive we only call it if logging is enabled.\n *\n * The log messages are de-duplicated based on the parameters, so it is assumed they are simple types that stringify\n * well.\n *\n * @param {function|boolean} debug A boolean or debug function\n * @return {function(function, array)} A logging function possibly degenerate\n */\nfunction createDebugLogger(debug) {\n  var log = !!debug && ((typeof debug === 'function') ? debug : console.log);\n  var cache = {};\n  return log ? actuallyLog : noop;\n\n  function noop() {}\n\n  function actuallyLog(msgFn, params) {\n    var key = JSON.stringify(params);\n    if (!cache[key]) {\n      cache[key] = true;\n      log(msgFn.apply(null, params));\n    }\n  }\n}\n\nexports.createDebugLogger = createDebugLogger;\n"]},"metadata":{},"sourceType":"script"}