{"ast":null,"code":"/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unused expressions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowShortCircuit: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTernary: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTaggedTemplates: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const config = context.options[0] || {},\n          allowShortCircuit = config.allowShortCircuit || false,\n          allowTernary = config.allowTernary || false,\n          allowTaggedTemplates = config.allowTaggedTemplates || false; // eslint-disable-next-line jsdoc/require-description\n\n    /**\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node structurally represents a directive\n     */\n\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    } // eslint-disable-next-line jsdoc/require-description\n\n    /**\n     * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n     * @param {a[]} list the input list\n     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n     */\n\n\n    function takeWhile(predicate, list) {\n      for (let i = 0; i < list.length; ++i) {\n        if (!predicate(list[i])) {\n          return list.slice(0, i);\n        }\n      }\n\n      return list.slice();\n    } // eslint-disable-next-line jsdoc/require-description\n\n    /**\n     * @param {ASTNode} node a Program or BlockStatement node\n     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n     */\n\n\n    function directives(node) {\n      return takeWhile(looksLikeDirective, node.body);\n    } // eslint-disable-next-line jsdoc/require-description\n\n    /**\n     * @param {ASTNode} node any node\n     * @param {ASTNode[]} ancestors the given node's ancestors\n     * @returns {boolean} whether the given node is considered a directive in its current position\n     */\n\n\n    function isDirective(node, ancestors) {\n      const parent = ancestors[ancestors.length - 1],\n            grandparent = ancestors[ancestors.length - 2];\n      return (parent.type === \"Program\" || parent.type === \"BlockStatement\" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;\n    }\n    /**\n     * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node is a valid expression\n     */\n\n\n    function isValidExpression(node) {\n      if (allowTernary) {\n        // Recursive check for ternary and logical expressions\n        if (node.type === \"ConditionalExpression\") {\n          return isValidExpression(node.consequent) && isValidExpression(node.alternate);\n        }\n      }\n\n      if (allowShortCircuit) {\n        if (node.type === \"LogicalExpression\") {\n          return isValidExpression(node.right);\n        }\n      }\n\n      if (allowTaggedTemplates && node.type === \"TaggedTemplateExpression\") {\n        return true;\n      }\n\n      return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/u.test(node.type) || node.type === \"UnaryExpression\" && [\"delete\", \"void\"].indexOf(node.operator) >= 0;\n    }\n\n    return {\n      ExpressionStatement(node) {\n        if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {\n          context.report({\n            node,\n            message: \"Expected an assignment or function call and instead saw an expression.\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-unused-expressions.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","allowShortCircuit","default","allowTernary","allowTaggedTemplates","additionalProperties","create","context","config","options","looksLikeDirective","node","expression","value","takeWhile","predicate","list","i","length","slice","directives","body","isDirective","ancestors","parent","grandparent","test","indexOf","isValidExpression","consequent","alternate","right","operator","ExpressionStatement","getAncestors","report","message"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTernary: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false;\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @param {ASTNode[]} ancestors the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/u.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node is a valid expression\n         */\n        function isValidExpression(node) {\n            if (allowTernary) {\n\n                // Recursive check for ternary and logical expressions\n                if (node.type === \"ConditionalExpression\") {\n                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);\n                }\n            }\n\n            if (allowShortCircuit) {\n                if (node.type === \"LogicalExpression\") {\n                    return isValidExpression(node.right);\n                }\n            }\n\n            if (allowTaggedTemplates && node.type === \"TaggedTemplateExpression\") {\n                return true;\n            }\n\n            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/u.test(node.type) ||\n                (node.type === \"UnaryExpression\" && [\"delete\", \"void\"].indexOf(node.operator) >= 0);\n        }\n\n        return {\n            ExpressionStatement(node) {\n                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, message: \"Expected an assignment or function call and instead saw an expression.\" });\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}