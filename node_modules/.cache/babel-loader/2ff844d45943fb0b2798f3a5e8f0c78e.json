{"ast":null,"code":"/**\n * XmlHttpRequest implementation that uses TLS and flash SocketPool.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./socket');\n\nrequire('./http');\n/* XHR API */\n\n\nvar xhrApi = module.exports = forge.xhr = forge.xhr || {};\n\n(function ($) {\n  // logging category\n  var cat = 'forge.xhr';\n  /*\n  XMLHttpRequest interface definition from:\n  http://www.w3.org/TR/XMLHttpRequest\n  \n  interface XMLHttpRequest {\n    // event handler\n    attribute EventListener onreadystatechange;\n  \n    // state\n    const unsigned short UNSENT = 0;\n    const unsigned short OPENED = 1;\n    const unsigned short HEADERS_RECEIVED = 2;\n    const unsigned short LOADING = 3;\n    const unsigned short DONE = 4;\n    readonly attribute unsigned short readyState;\n  \n    // request\n    void open(in DOMString method, in DOMString url);\n    void open(in DOMString method, in DOMString url, in boolean async);\n    void open(in DOMString method, in DOMString url,\n              in boolean async, in DOMString user);\n    void open(in DOMString method, in DOMString url,\n              in boolean async, in DOMString user, in DOMString password);\n    void setRequestHeader(in DOMString header, in DOMString value);\n    void send();\n    void send(in DOMString data);\n    void send(in Document data);\n    void abort();\n  \n    // response\n    DOMString getAllResponseHeaders();\n    DOMString getResponseHeader(in DOMString header);\n    readonly attribute DOMString responseText;\n    readonly attribute Document responseXML;\n    readonly attribute unsigned short status;\n    readonly attribute DOMString statusText;\n  };\n  */\n  // readyStates\n\n  var UNSENT = 0;\n  var OPENED = 1;\n  var HEADERS_RECEIVED = 2;\n  var LOADING = 3;\n  var DONE = 4; // exceptions\n\n  var INVALID_STATE_ERR = 11;\n  var SYNTAX_ERR = 12;\n  var SECURITY_ERR = 18;\n  var NETWORK_ERR = 19;\n  var ABORT_ERR = 20; // private flash socket pool vars\n\n  var _sp = null;\n  var _policyPort = 0;\n  var _policyUrl = null; // default client (used if no special URL provided when creating an XHR)\n\n  var _client = null; // all clients including the default, key'd by full base url\n  // (multiple cross-domain http clients are permitted so there may be more\n  // than one client in this map)\n  // TODO: provide optional clean up API for non-default clients\n\n  var _clients = {}; // the default maximum number of concurrents connections per client\n\n  var _maxConnections = 10;\n  var net = forge.net;\n  var http = forge.http;\n  /**\n   * Initializes flash XHR support.\n   *\n   * @param options:\n   *   url: the default base URL to connect to if xhr URLs are relative,\n   *     ie: https://myserver.com.\n   *   flashId: the dom ID of the flash SocketPool.\n   *   policyPort: the port that provides the server's flash policy, 0 to use\n   *     the flash default.\n   *   policyUrl: the policy file URL to use instead of a policy port.\n   *   msie: true if browser is internet explorer, false if not.\n   *   connections: the maximum number of concurrent connections.\n   *   caCerts: a list of PEM-formatted certificates to trust.\n   *   cipherSuites: an optional array of cipher suites to use,\n   *     see forge.tls.CipherSuites.\n   *   verify: optional TLS certificate verify callback to use (see forge.tls\n   *     for details).\n   *   getCertificate: an optional callback used to get a client-side\n   *     certificate (see forge.tls for details).\n   *   getPrivateKey: an optional callback used to get a client-side private\n   *     key (see forge.tls for details).\n   *   getSignature: an optional callback used to get a client-side signature\n   *     (see forge.tls for details).\n   *   persistCookies: true to use persistent cookies via flash local storage,\n   *     false to only keep cookies in javascript.\n   *   primeTlsSockets: true to immediately connect TLS sockets on their\n   *     creation so that they will cache TLS sessions for reuse.\n   */\n\n  xhrApi.init = function (options) {\n    forge.log.debug(cat, 'initializing', options); // update default policy port and max connections\n\n    _policyPort = options.policyPort || _policyPort;\n    _policyUrl = options.policyUrl || _policyUrl;\n    _maxConnections = options.connections || _maxConnections; // create the flash socket pool\n\n    _sp = net.createSocketPool({\n      flashId: options.flashId,\n      policyPort: _policyPort,\n      policyUrl: _policyUrl,\n      msie: options.msie || false\n    }); // create default http client\n\n    _client = http.createClient({\n      url: options.url || window.location.protocol + '//' + window.location.host,\n      socketPool: _sp,\n      policyPort: _policyPort,\n      policyUrl: _policyUrl,\n      connections: options.connections || _maxConnections,\n      caCerts: options.caCerts,\n      cipherSuites: options.cipherSuites,\n      persistCookies: options.persistCookies || true,\n      primeTlsSockets: options.primeTlsSockets || false,\n      verify: options.verify,\n      getCertificate: options.getCertificate,\n      getPrivateKey: options.getPrivateKey,\n      getSignature: options.getSignature\n    });\n    _clients[_client.url.full] = _client;\n    forge.log.debug(cat, 'ready');\n  };\n  /**\n   * Called to clean up the clients and socket pool.\n   */\n\n\n  xhrApi.cleanup = function () {\n    // destroy all clients\n    for (var key in _clients) {\n      _clients[key].destroy();\n    }\n\n    _clients = {};\n    _client = null; // destroy socket pool\n\n    _sp.destroy();\n\n    _sp = null;\n  };\n  /**\n   * Sets a cookie.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n\n\n  xhrApi.setCookie = function (cookie) {\n    // default cookie expiration to never\n    cookie.maxAge = cookie.maxAge || -1; // if the cookie's domain is set, use the appropriate client\n\n    if (cookie.domain) {\n      // add the cookies to the applicable domains\n      for (var key in _clients) {\n        var client = _clients[key];\n\n        if (http.withinCookieDomain(client.url, cookie) && client.secure === cookie.secure) {\n          client.setCookie(cookie);\n        }\n      }\n    } else {\n      // use the default domain\n      // FIXME: should a null domain cookie be added to all clients? should\n      // this be an option?\n      _client.setCookie(cookie);\n    }\n  };\n  /**\n   * Gets a cookie.\n   *\n   * @param name the name of the cookie.\n   * @param path an optional path for the cookie (if there are multiple cookies\n   *          with the same name but different paths).\n   * @param domain an optional domain for the cookie (if not using the default\n   *          domain).\n   *\n   * @return the cookie, cookies (if multiple matches), or null if not found.\n   */\n\n\n  xhrApi.getCookie = function (name, path, domain) {\n    var rval = null;\n\n    if (domain) {\n      // get the cookies from the applicable domains\n      for (var key in _clients) {\n        var client = _clients[key];\n\n        if (http.withinCookieDomain(client.url, domain)) {\n          var cookie = client.getCookie(name, path);\n\n          if (cookie !== null) {\n            if (rval === null) {\n              rval = cookie;\n            } else if (!forge.util.isArray(rval)) {\n              rval = [rval, cookie];\n            } else {\n              rval.push(cookie);\n            }\n          }\n        }\n      }\n    } else {\n      // get cookie from default domain\n      rval = _client.getCookie(name, path);\n    }\n\n    return rval;\n  };\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie.\n   * @param path an optional path for the cookie (if there are multiple cookies\n   *          with the same name but different paths).\n   * @param domain an optional domain for the cookie (if not using the default\n   *          domain).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n\n\n  xhrApi.removeCookie = function (name, path, domain) {\n    var rval = false;\n\n    if (domain) {\n      // remove the cookies from the applicable domains\n      for (var key in _clients) {\n        var client = _clients[key];\n\n        if (http.withinCookieDomain(client.url, domain)) {\n          if (client.removeCookie(name, path)) {\n            rval = true;\n          }\n        }\n      }\n    } else {\n      // remove cookie from default domain\n      rval = _client.removeCookie(name, path);\n    }\n\n    return rval;\n  };\n  /**\n   * Creates a new XmlHttpRequest. By default the base URL, flash policy port,\n   * etc, will be used. However, an XHR can be created to point at another\n   * cross-domain URL.\n   *\n   * @param options:\n   *   logWarningOnError: If true and an HTTP error status code is received then\n   *     log a warning, otherwise log a verbose message.\n   *   verbose: If true be very verbose in the output including the response\n   *     event and response body, otherwise only include status, timing, and\n   *     data size.\n   *   logError: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   logWarning: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   logDebug: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   logVerbose: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   url: the default base URL to connect to if xhr URLs are relative,\n   *     eg: https://myserver.com, and note that the following options will be\n   *     ignored if the URL is absent or the same as the default base URL.\n   *   policyPort: the port that provides the server's flash policy, 0 to use\n   *     the flash default.\n   *   policyUrl: the policy file URL to use instead of a policy port.\n   *   connections: the maximum number of concurrent connections.\n   *   caCerts: a list of PEM-formatted certificates to trust.\n   *   cipherSuites: an optional array of cipher suites to use, see\n   *     forge.tls.CipherSuites.\n   *   verify: optional TLS certificate verify callback to use (see forge.tls\n   *     for details).\n   *   getCertificate: an optional callback used to get a client-side\n   *     certificate.\n   *   getPrivateKey: an optional callback used to get a client-side private key.\n   *   getSignature: an optional callback used to get a client-side signature.\n   *   persistCookies: true to use persistent cookies via flash local storage,\n   *     false to only keep cookies in javascript.\n   *   primeTlsSockets: true to immediately connect TLS sockets on their\n   *     creation so that they will cache TLS sessions for reuse.\n   *\n   * @return the XmlHttpRequest.\n   */\n\n\n  xhrApi.create = function (options) {\n    // set option defaults\n    options = $.extend({\n      logWarningOnError: true,\n      verbose: false,\n      logError: function () {},\n      logWarning: function () {},\n      logDebug: function () {},\n      logVerbose: function () {},\n      url: null\n    }, options || {}); // private xhr state\n\n    var _state = {\n      // the http client to use\n      client: null,\n      // request storage\n      request: null,\n      // response storage\n      response: null,\n      // asynchronous, true if doing asynchronous communication\n      asynchronous: true,\n      // sendFlag, true if send has been called\n      sendFlag: false,\n      // errorFlag, true if a network error occurred\n      errorFlag: false\n    }; // private log functions\n\n    var _log = {\n      error: options.logError || forge.log.error,\n      warning: options.logWarning || forge.log.warning,\n      debug: options.logDebug || forge.log.debug,\n      verbose: options.logVerbose || forge.log.verbose\n    }; // create public xhr interface\n\n    var xhr = {\n      // an EventListener\n      onreadystatechange: null,\n      // readonly, the current readyState\n      readyState: UNSENT,\n      // a string with the response entity-body\n      responseText: '',\n      // a Document for response entity-bodies that are XML\n      responseXML: null,\n      // readonly, returns the HTTP status code (i.e. 404)\n      status: 0,\n      // readonly, returns the HTTP status message (i.e. 'Not Found')\n      statusText: ''\n    }; // determine which http client to use\n\n    if (options.url === null) {\n      // use default\n      _state.client = _client;\n    } else {\n      var url = http.parseUrl(options.url);\n\n      if (!url) {\n        var error = new Error('Invalid url.');\n        error.details = {\n          url: options.url\n        };\n      } // find client\n\n\n      if (url.full in _clients) {\n        // client found\n        _state.client = _clients[url.full];\n      } else {\n        // create client\n        _state.client = http.createClient({\n          url: options.url,\n          socketPool: _sp,\n          policyPort: options.policyPort || _policyPort,\n          policyUrl: options.policyUrl || _policyUrl,\n          connections: options.connections || _maxConnections,\n          caCerts: options.caCerts,\n          cipherSuites: options.cipherSuites,\n          persistCookies: options.persistCookies || true,\n          primeTlsSockets: options.primeTlsSockets || false,\n          verify: options.verify,\n          getCertificate: options.getCertificate,\n          getPrivateKey: options.getPrivateKey,\n          getSignature: options.getSignature\n        });\n        _clients[url.full] = _state.client;\n      }\n    }\n    /**\n     * Opens the request. This method will create the HTTP request to send.\n     *\n     * @param method the HTTP method (i.e. 'GET').\n     * @param url the relative url (the HTTP request path).\n     * @param async always true, ignored.\n     * @param user always null, ignored.\n     * @param password always null, ignored.\n     */\n\n\n    xhr.open = function (method, url, async, user, password) {\n      // 1. validate Document if one is associated\n      // TODO: not implemented (not used yet)\n      // 2. validate method token\n      // 3. change method to uppercase if it matches a known\n      // method (here we just require it to be uppercase, and\n      // we do not allow the standard methods)\n      // 4. disallow CONNECT, TRACE, or TRACK with a security error\n      switch (method) {\n        case 'DELETE':\n        case 'GET':\n        case 'HEAD':\n        case 'OPTIONS':\n        case 'PATCH':\n        case 'POST':\n        case 'PUT':\n          // valid method\n          break;\n\n        case 'CONNECT':\n        case 'TRACE':\n        case 'TRACK':\n          throw new Error('CONNECT, TRACE and TRACK methods are disallowed');\n\n        default:\n          throw new Error('Invalid method: ' + method);\n      } // TODO: other validation steps in algorithm are not implemented\n      // 19. set send flag to false\n      // set response body to null\n      // empty list of request headers\n      // set request method to given method\n      // set request URL\n      // set username, password\n      // set asychronous flag\n\n\n      _state.sendFlag = false;\n      xhr.responseText = '';\n      xhr.responseXML = null; // custom: reset status and statusText\n\n      xhr.status = 0;\n      xhr.statusText = ''; // create the HTTP request\n\n      _state.request = http.createRequest({\n        method: method,\n        path: url\n      }); // 20. set state to OPENED\n\n      xhr.readyState = OPENED; // 21. dispatch onreadystatechange\n\n      if (xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n    /**\n     * Adds an HTTP header field to the request.\n     *\n     * @param header the name of the header field.\n     * @param value the value of the header field.\n     */\n\n\n    xhr.setRequestHeader = function (header, value) {\n      // 1. if state is not OPENED or send flag is true, raise exception\n      if (xhr.readyState != OPENED || _state.sendFlag) {\n        throw new Error('XHR not open or sending');\n      } // TODO: other validation steps in spec aren't implemented\n      // set header\n\n\n      _state.request.setField(header, value);\n    };\n    /**\n     * Sends the request and any associated data.\n     *\n     * @param data a string or Document object to send, null to send no data.\n     */\n\n\n    xhr.send = function (data) {\n      // 1. if state is not OPENED or 2. send flag is true, raise\n      // an invalid state exception\n      if (xhr.readyState != OPENED || _state.sendFlag) {\n        throw new Error('XHR not open or sending');\n      } // 3. ignore data if method is GET or HEAD\n\n\n      if (data && _state.request.method !== 'GET' && _state.request.method !== 'HEAD') {\n        // handle non-IE case\n        if (typeof XMLSerializer !== 'undefined') {\n          if (data instanceof Document) {\n            var xs = new XMLSerializer();\n            _state.request.body = xs.serializeToString(data);\n          } else {\n            _state.request.body = data;\n          }\n        } else {\n          // poorly implemented IE case\n          if (typeof data.xml !== 'undefined') {\n            _state.request.body = data.xml;\n          } else {\n            _state.request.body = data;\n          }\n        }\n      } // 4. release storage mutex (not used)\n      // 5. set error flag to false\n\n\n      _state.errorFlag = false; // 6. if asynchronous is true (must be in this implementation)\n      // 6.1 set send flag to true\n\n      _state.sendFlag = true; // 6.2 dispatch onreadystatechange\n\n      if (xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      } // create send options\n\n\n      var options = {};\n      options.request = _state.request;\n\n      options.headerReady = function (e) {\n        // make cookies available for ease of use/iteration\n        xhr.cookies = _state.client.cookies; // TODO: update document.cookie with any cookies where the\n        // script's domain matches\n        // headers received\n\n        xhr.readyState = HEADERS_RECEIVED;\n        xhr.status = e.response.code;\n        xhr.statusText = e.response.message;\n        _state.response = e.response;\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        }\n\n        if (!_state.response.aborted) {\n          // now loading body\n          xhr.readyState = LOADING;\n\n          if (xhr.onreadystatechange) {\n            xhr.onreadystatechange();\n          }\n        }\n      };\n\n      options.bodyReady = function (e) {\n        xhr.readyState = DONE;\n        var ct = e.response.getField('Content-Type'); // Note: this null/undefined check is done outside because IE\n        // dies otherwise on a \"'null' is null\" error\n\n        if (ct) {\n          if (ct.indexOf('text/xml') === 0 || ct.indexOf('application/xml') === 0 || ct.indexOf('+xml') !== -1) {\n            try {\n              var doc = new ActiveXObject('MicrosoftXMLDOM');\n              doc.async = false;\n              doc.loadXML(e.response.body);\n              xhr.responseXML = doc;\n            } catch (ex) {\n              var parser = new DOMParser();\n              xhr.responseXML = parser.parseFromString(ex.body, 'text/xml');\n            }\n          }\n        }\n\n        var length = 0;\n\n        if (e.response.body !== null) {\n          xhr.responseText = e.response.body;\n          length = e.response.body.length;\n        } // build logging output\n\n\n        var req = _state.request;\n        var output = req.method + ' ' + req.path + ' ' + xhr.status + ' ' + xhr.statusText + ' ' + length + 'B ' + (e.request.connectTime + e.request.time + e.response.time) + 'ms';\n        var lFunc;\n\n        if (options.verbose) {\n          lFunc = xhr.status >= 400 && options.logWarningOnError ? _log.warning : _log.verbose;\n          lFunc(cat, output, e, e.response.body ? '\\n' + e.response.body : '\\nNo content');\n        } else {\n          lFunc = xhr.status >= 400 && options.logWarningOnError ? _log.warning : _log.debug;\n          lFunc(cat, output);\n        }\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        }\n      };\n\n      options.error = function (e) {\n        var req = _state.request;\n\n        _log.error(cat, req.method + ' ' + req.path, e); // 1. set response body to null\n\n\n        xhr.responseText = '';\n        xhr.responseXML = null; // 2. set error flag to true (and reset status)\n\n        _state.errorFlag = true;\n        xhr.status = 0;\n        xhr.statusText = ''; // 3. set state to done\n\n        xhr.readyState = DONE; // 4. asyc flag is always true, so dispatch onreadystatechange\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        }\n      }; // 7. send request\n\n\n      _state.client.send(options);\n    };\n    /**\n     * Aborts the request.\n     */\n\n\n    xhr.abort = function () {\n      // 1. abort send\n      // 2. stop network activity\n      _state.request.abort(); // 3. set response to null\n\n\n      xhr.responseText = '';\n      xhr.responseXML = null; // 4. set error flag to true (and reset status)\n\n      _state.errorFlag = true;\n      xhr.status = 0;\n      xhr.statusText = ''; // 5. clear user headers\n\n      _state.request = null;\n      _state.response = null; // 6. if state is DONE or UNSENT, or if OPENED and send flag is false\n\n      if (xhr.readyState === DONE || xhr.readyState === UNSENT || xhr.readyState === OPENED && !_state.sendFlag) {\n        // 7. set ready state to unsent\n        xhr.readyState = UNSENT;\n      } else {\n        // 6.1 set state to DONE\n        xhr.readyState = DONE; // 6.2 set send flag to false\n\n        _state.sendFlag = false; // 6.3 dispatch onreadystatechange\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        } // 7. set state to UNSENT\n\n\n        xhr.readyState = UNSENT;\n      }\n    };\n    /**\n     * Gets all response headers as a string.\n     *\n     * @return the HTTP-encoded response header fields.\n     */\n\n\n    xhr.getAllResponseHeaders = function () {\n      var rval = '';\n\n      if (_state.response !== null) {\n        var fields = _state.response.fields;\n        $.each(fields, function (name, array) {\n          $.each(array, function (i, value) {\n            rval += name + ': ' + value + '\\r\\n';\n          });\n        });\n      }\n\n      return rval;\n    };\n    /**\n     * Gets a single header field value or, if there are multiple\n     * fields with the same name, a comma-separated list of header\n     * values.\n     *\n     * @return the header field value(s) or null.\n     */\n\n\n    xhr.getResponseHeader = function (header) {\n      var rval = null;\n\n      if (_state.response !== null) {\n        if (header in _state.response.fields) {\n          rval = _state.response.fields[header];\n\n          if (forge.util.isArray(rval)) {\n            rval = rval.join();\n          }\n        }\n      }\n\n      return rval;\n    };\n\n    return xhr;\n  };\n})(jQuery);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/node-forge/lib/xhr.js"],"names":["forge","require","xhrApi","module","exports","xhr","$","cat","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","INVALID_STATE_ERR","SYNTAX_ERR","SECURITY_ERR","NETWORK_ERR","ABORT_ERR","_sp","_policyPort","_policyUrl","_client","_clients","_maxConnections","net","http","init","options","log","debug","policyPort","policyUrl","connections","createSocketPool","flashId","msie","createClient","url","window","location","protocol","host","socketPool","caCerts","cipherSuites","persistCookies","primeTlsSockets","verify","getCertificate","getPrivateKey","getSignature","full","cleanup","key","destroy","setCookie","cookie","maxAge","domain","client","withinCookieDomain","secure","getCookie","name","path","rval","util","isArray","push","removeCookie","create","extend","logWarningOnError","verbose","logError","logWarning","logDebug","logVerbose","_state","request","response","asynchronous","sendFlag","errorFlag","_log","error","warning","onreadystatechange","readyState","responseText","responseXML","status","statusText","parseUrl","Error","details","open","method","async","user","password","createRequest","setRequestHeader","header","value","setField","send","data","XMLSerializer","Document","xs","body","serializeToString","xml","headerReady","e","cookies","code","message","aborted","bodyReady","ct","getField","indexOf","doc","ActiveXObject","loadXML","ex","parser","DOMParser","parseFromString","length","req","output","connectTime","time","lFunc","abort","getAllResponseHeaders","fields","each","array","i","getResponseHeader","join","jQuery"],"mappings":"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","sourcesContent":["/**\n * XmlHttpRequest implementation that uses TLS and flash SocketPool.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./socket');\nrequire('./http');\n\n/* XHR API */\nvar xhrApi = module.exports = forge.xhr = forge.xhr || {};\n\n(function($) {\n\n// logging category\nvar cat = 'forge.xhr';\n\n/*\nXMLHttpRequest interface definition from:\nhttp://www.w3.org/TR/XMLHttpRequest\n\ninterface XMLHttpRequest {\n  // event handler\n  attribute EventListener onreadystatechange;\n\n  // state\n  const unsigned short UNSENT = 0;\n  const unsigned short OPENED = 1;\n  const unsigned short HEADERS_RECEIVED = 2;\n  const unsigned short LOADING = 3;\n  const unsigned short DONE = 4;\n  readonly attribute unsigned short readyState;\n\n  // request\n  void open(in DOMString method, in DOMString url);\n  void open(in DOMString method, in DOMString url, in boolean async);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user, in DOMString password);\n  void setRequestHeader(in DOMString header, in DOMString value);\n  void send();\n  void send(in DOMString data);\n  void send(in Document data);\n  void abort();\n\n  // response\n  DOMString getAllResponseHeaders();\n  DOMString getResponseHeader(in DOMString header);\n  readonly attribute DOMString responseText;\n  readonly attribute Document responseXML;\n  readonly attribute unsigned short status;\n  readonly attribute DOMString statusText;\n};\n*/\n\n// readyStates\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\n\n// exceptions\nvar INVALID_STATE_ERR = 11;\nvar SYNTAX_ERR = 12;\nvar SECURITY_ERR = 18;\nvar NETWORK_ERR = 19;\nvar ABORT_ERR = 20;\n\n// private flash socket pool vars\nvar _sp = null;\nvar _policyPort = 0;\nvar _policyUrl = null;\n\n// default client (used if no special URL provided when creating an XHR)\nvar _client = null;\n\n// all clients including the default, key'd by full base url\n// (multiple cross-domain http clients are permitted so there may be more\n// than one client in this map)\n// TODO: provide optional clean up API for non-default clients\nvar _clients = {};\n\n// the default maximum number of concurrents connections per client\nvar _maxConnections = 10;\n\nvar net = forge.net;\nvar http = forge.http;\n\n/**\n * Initializes flash XHR support.\n *\n * @param options:\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     ie: https://myserver.com.\n *   flashId: the dom ID of the flash SocketPool.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   msie: true if browser is internet explorer, false if not.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side private\n *     key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side signature\n *     (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n */\nxhrApi.init = function(options) {\n  forge.log.debug(cat, 'initializing', options);\n\n  // update default policy port and max connections\n  _policyPort = options.policyPort || _policyPort;\n  _policyUrl = options.policyUrl || _policyUrl;\n  _maxConnections = options.connections || _maxConnections;\n\n  // create the flash socket pool\n  _sp = net.createSocketPool({\n    flashId: options.flashId,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    msie: options.msie || false\n  });\n\n  // create default http client\n  _client = http.createClient({\n    url: options.url || (\n      window.location.protocol + '//' + window.location.host),\n    socketPool: _sp,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    connections: options.connections || _maxConnections,\n    caCerts: options.caCerts,\n    cipherSuites: options.cipherSuites,\n    persistCookies: options.persistCookies || true,\n    primeTlsSockets: options.primeTlsSockets || false,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature\n  });\n  _clients[_client.url.full] = _client;\n\n  forge.log.debug(cat, 'ready');\n};\n\n/**\n * Called to clean up the clients and socket pool.\n */\nxhrApi.cleanup = function() {\n  // destroy all clients\n  for(var key in _clients) {\n    _clients[key].destroy();\n  }\n  _clients = {};\n  _client = null;\n\n  // destroy socket pool\n  _sp.destroy();\n  _sp = null;\n};\n\n/**\n * Sets a cookie.\n *\n * @param cookie the cookie with parameters:\n *   name: the name of the cookie.\n *   value: the value of the cookie.\n *   comment: an optional comment string.\n *   maxAge: the age of the cookie in seconds relative to created time.\n *   secure: true if the cookie must be sent over a secure protocol.\n *   httpOnly: true to restrict access to the cookie from javascript\n *     (inaffective since the cookies are stored in javascript).\n *   path: the path for the cookie.\n *   domain: optional domain the cookie belongs to (must start with dot).\n *   version: optional version of the cookie.\n *   created: creation time, in UTC seconds, of the cookie.\n */\nxhrApi.setCookie = function(cookie) {\n  // default cookie expiration to never\n  cookie.maxAge = cookie.maxAge || -1;\n\n  // if the cookie's domain is set, use the appropriate client\n  if(cookie.domain) {\n    // add the cookies to the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, cookie) &&\n        client.secure === cookie.secure) {\n        client.setCookie(cookie);\n      }\n    }\n  } else {\n    // use the default domain\n    // FIXME: should a null domain cookie be added to all clients? should\n    // this be an option?\n    _client.setCookie(cookie);\n  }\n};\n\n/**\n * Gets a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return the cookie, cookies (if multiple matches), or null if not found.\n */\nxhrApi.getCookie = function(name, path, domain) {\n  var rval = null;\n\n  if(domain) {\n    // get the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        var cookie = client.getCookie(name, path);\n        if(cookie !== null) {\n          if(rval === null) {\n            rval = cookie;\n          } else if(!forge.util.isArray(rval)) {\n            rval = [rval, cookie];\n          } else {\n            rval.push(cookie);\n          }\n        }\n      }\n    }\n  } else {\n    // get cookie from default domain\n    rval = _client.getCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Removes a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return true if a cookie was removed, false if not.\n */\nxhrApi.removeCookie = function(name, path, domain) {\n  var rval = false;\n\n  if(domain) {\n    // remove the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        if(client.removeCookie(name, path)) {\n           rval = true;\n        }\n      }\n    }\n  } else {\n    // remove cookie from default domain\n    rval = _client.removeCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a new XmlHttpRequest. By default the base URL, flash policy port,\n * etc, will be used. However, an XHR can be created to point at another\n * cross-domain URL.\n *\n * @param options:\n *   logWarningOnError: If true and an HTTP error status code is received then\n *     log a warning, otherwise log a verbose message.\n *   verbose: If true be very verbose in the output including the response\n *     event and response body, otherwise only include status, timing, and\n *     data size.\n *   logError: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logWarning: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logDebug: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logVerbose: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     eg: https://myserver.com, and note that the following options will be\n *     ignored if the URL is absent or the same as the default base URL.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate.\n *   getPrivateKey: an optional callback used to get a client-side private key.\n *   getSignature: an optional callback used to get a client-side signature.\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n *\n * @return the XmlHttpRequest.\n */\nxhrApi.create = function(options) {\n  // set option defaults\n  options = $.extend({\n    logWarningOnError: true,\n    verbose: false,\n    logError: function() {},\n    logWarning: function() {},\n    logDebug: function() {},\n    logVerbose: function() {},\n    url: null\n  }, options || {});\n\n  // private xhr state\n  var _state = {\n    // the http client to use\n    client: null,\n    // request storage\n    request: null,\n    // response storage\n    response: null,\n    // asynchronous, true if doing asynchronous communication\n    asynchronous: true,\n    // sendFlag, true if send has been called\n    sendFlag: false,\n    // errorFlag, true if a network error occurred\n    errorFlag: false\n  };\n\n  // private log functions\n  var _log = {\n    error: options.logError || forge.log.error,\n    warning: options.logWarning || forge.log.warning,\n    debug: options.logDebug || forge.log.debug,\n    verbose: options.logVerbose || forge.log.verbose\n  };\n\n  // create public xhr interface\n  var xhr = {\n    // an EventListener\n    onreadystatechange: null,\n    // readonly, the current readyState\n    readyState: UNSENT,\n    // a string with the response entity-body\n    responseText: '',\n    // a Document for response entity-bodies that are XML\n    responseXML: null,\n    // readonly, returns the HTTP status code (i.e. 404)\n    status: 0,\n    // readonly, returns the HTTP status message (i.e. 'Not Found')\n    statusText: ''\n  };\n\n  // determine which http client to use\n  if(options.url === null) {\n    // use default\n    _state.client = _client;\n  } else {\n    var url = http.parseUrl(options.url);\n    if(!url) {\n      var error = new Error('Invalid url.');\n      error.details = {\n        url: options.url\n      };\n    }\n\n    // find client\n    if(url.full in _clients) {\n      // client found\n      _state.client = _clients[url.full];\n    } else {\n      // create client\n      _state.client = http.createClient({\n        url: options.url,\n        socketPool: _sp,\n        policyPort: options.policyPort || _policyPort,\n        policyUrl: options.policyUrl || _policyUrl,\n        connections: options.connections || _maxConnections,\n        caCerts: options.caCerts,\n        cipherSuites: options.cipherSuites,\n        persistCookies: options.persistCookies || true,\n        primeTlsSockets: options.primeTlsSockets || false,\n        verify: options.verify,\n        getCertificate: options.getCertificate,\n        getPrivateKey: options.getPrivateKey,\n        getSignature: options.getSignature\n      });\n      _clients[url.full] = _state.client;\n    }\n  }\n\n  /**\n   * Opens the request. This method will create the HTTP request to send.\n   *\n   * @param method the HTTP method (i.e. 'GET').\n   * @param url the relative url (the HTTP request path).\n   * @param async always true, ignored.\n   * @param user always null, ignored.\n   * @param password always null, ignored.\n   */\n  xhr.open = function(method, url, async, user, password) {\n    // 1. validate Document if one is associated\n    // TODO: not implemented (not used yet)\n\n    // 2. validate method token\n    // 3. change method to uppercase if it matches a known\n    // method (here we just require it to be uppercase, and\n    // we do not allow the standard methods)\n    // 4. disallow CONNECT, TRACE, or TRACK with a security error\n    switch(method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'PATCH':\n    case 'POST':\n    case 'PUT':\n      // valid method\n      break;\n    case 'CONNECT':\n    case 'TRACE':\n    case 'TRACK':\n      throw new Error('CONNECT, TRACE and TRACK methods are disallowed');\n    default:\n      throw new Error('Invalid method: ' + method);\n    }\n\n    // TODO: other validation steps in algorithm are not implemented\n\n    // 19. set send flag to false\n    // set response body to null\n    // empty list of request headers\n    // set request method to given method\n    // set request URL\n    // set username, password\n    // set asychronous flag\n    _state.sendFlag = false;\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // custom: reset status and statusText\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // create the HTTP request\n    _state.request = http.createRequest({\n      method: method,\n      path: url\n    });\n\n    // 20. set state to OPENED\n    xhr.readyState = OPENED;\n\n    // 21. dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n       xhr.onreadystatechange();\n    }\n  };\n\n  /**\n   * Adds an HTTP header field to the request.\n   *\n   * @param header the name of the header field.\n   * @param value the value of the header field.\n   */\n  xhr.setRequestHeader = function(header, value) {\n    // 1. if state is not OPENED or send flag is true, raise exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // TODO: other validation steps in spec aren't implemented\n\n    // set header\n    _state.request.setField(header, value);\n  };\n\n  /**\n   * Sends the request and any associated data.\n   *\n   * @param data a string or Document object to send, null to send no data.\n   */\n  xhr.send = function(data) {\n    // 1. if state is not OPENED or 2. send flag is true, raise\n    // an invalid state exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // 3. ignore data if method is GET or HEAD\n    if(data &&\n      _state.request.method !== 'GET' &&\n      _state.request.method !== 'HEAD') {\n      // handle non-IE case\n      if(typeof(XMLSerializer) !== 'undefined') {\n        if(data instanceof Document) {\n          var xs = new XMLSerializer();\n          _state.request.body = xs.serializeToString(data);\n        } else {\n          _state.request.body = data;\n        }\n      } else {\n        // poorly implemented IE case\n        if(typeof(data.xml) !== 'undefined') {\n          _state.request.body = data.xml;\n        } else {\n          _state.request.body = data;\n        }\n      }\n    }\n\n    // 4. release storage mutex (not used)\n\n    // 5. set error flag to false\n    _state.errorFlag = false;\n\n    // 6. if asynchronous is true (must be in this implementation)\n\n    // 6.1 set send flag to true\n    _state.sendFlag = true;\n\n    // 6.2 dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n      xhr.onreadystatechange();\n    }\n\n    // create send options\n    var options = {};\n    options.request = _state.request;\n    options.headerReady = function(e) {\n      // make cookies available for ease of use/iteration\n      xhr.cookies = _state.client.cookies;\n\n      // TODO: update document.cookie with any cookies where the\n      // script's domain matches\n\n      // headers received\n      xhr.readyState = HEADERS_RECEIVED;\n      xhr.status = e.response.code;\n      xhr.statusText = e.response.message;\n      _state.response = e.response;\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n      if(!_state.response.aborted) {\n        // now loading body\n        xhr.readyState = LOADING;\n        if(xhr.onreadystatechange) {\n           xhr.onreadystatechange();\n        }\n      }\n    };\n    options.bodyReady = function(e) {\n      xhr.readyState = DONE;\n      var ct = e.response.getField('Content-Type');\n      // Note: this null/undefined check is done outside because IE\n      // dies otherwise on a \"'null' is null\" error\n      if(ct) {\n        if(ct.indexOf('text/xml') === 0 ||\n          ct.indexOf('application/xml') === 0 ||\n          ct.indexOf('+xml') !== -1) {\n          try {\n            var doc = new ActiveXObject('MicrosoftXMLDOM');\n            doc.async = false;\n            doc.loadXML(e.response.body);\n            xhr.responseXML = doc;\n          } catch(ex) {\n            var parser = new DOMParser();\n            xhr.responseXML = parser.parseFromString(ex.body, 'text/xml');\n          }\n        }\n      }\n\n      var length = 0;\n      if(e.response.body !== null) {\n        xhr.responseText = e.response.body;\n        length = e.response.body.length;\n      }\n      // build logging output\n      var req = _state.request;\n      var output =\n        req.method + ' ' + req.path + ' ' +\n        xhr.status + ' ' + xhr.statusText + ' ' +\n        length + 'B ' +\n        (e.request.connectTime + e.request.time + e.response.time) +\n        'ms';\n      var lFunc;\n      if(options.verbose) {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.verbose;\n        lFunc(cat, output,\n          e, e.response.body ? '\\n' + e.response.body : '\\nNo content');\n      } else {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.debug;\n        lFunc(cat, output);\n      }\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n    options.error = function(e) {\n      var req = _state.request;\n      _log.error(cat, req.method + ' ' + req.path, e);\n\n      // 1. set response body to null\n      xhr.responseText = '';\n      xhr.responseXML = null;\n\n      // 2. set error flag to true (and reset status)\n      _state.errorFlag = true;\n      xhr.status = 0;\n      xhr.statusText = '';\n\n      // 3. set state to done\n      xhr.readyState = DONE;\n\n      // 4. asyc flag is always true, so dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n\n    // 7. send request\n    _state.client.send(options);\n  };\n\n  /**\n   * Aborts the request.\n   */\n  xhr.abort = function() {\n    // 1. abort send\n    // 2. stop network activity\n    _state.request.abort();\n\n    // 3. set response to null\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // 4. set error flag to true (and reset status)\n    _state.errorFlag = true;\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // 5. clear user headers\n    _state.request = null;\n    _state.response = null;\n\n    // 6. if state is DONE or UNSENT, or if OPENED and send flag is false\n    if(xhr.readyState === DONE || xhr.readyState === UNSENT ||\n     (xhr.readyState === OPENED && !_state.sendFlag)) {\n      // 7. set ready state to unsent\n      xhr.readyState = UNSENT;\n    } else {\n      // 6.1 set state to DONE\n      xhr.readyState = DONE;\n\n      // 6.2 set send flag to false\n      _state.sendFlag = false;\n\n      // 6.3 dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n\n      // 7. set state to UNSENT\n      xhr.readyState = UNSENT;\n    }\n  };\n\n  /**\n   * Gets all response headers as a string.\n   *\n   * @return the HTTP-encoded response header fields.\n   */\n  xhr.getAllResponseHeaders = function() {\n    var rval = '';\n    if(_state.response !== null) {\n      var fields = _state.response.fields;\n      $.each(fields, function(name, array) {\n        $.each(array, function(i, value) {\n          rval += name + ': ' + value + '\\r\\n';\n        });\n      });\n    }\n    return rval;\n  };\n\n  /**\n   * Gets a single header field value or, if there are multiple\n   * fields with the same name, a comma-separated list of header\n   * values.\n   *\n   * @return the header field value(s) or null.\n   */\n  xhr.getResponseHeader = function(header) {\n    var rval = null;\n    if(_state.response !== null) {\n      if(header in _state.response.fields) {\n        rval = _state.response.fields[header];\n        if(forge.util.isArray(rval)) {\n          rval = rval.join();\n        }\n      }\n    }\n    return rval;\n  };\n\n  return xhr;\n};\n\n})(jQuery);\n"]},"metadata":{},"sourceType":"script"}