{"ast":null,"code":"'use strict';\n\nconst figgyPudding = require('figgy-pudding');\n\nconst index = require('./lib/entry-index');\n\nconst memo = require('./lib/memoization');\n\nconst write = require('./lib/content/write');\n\nconst Flush = require('minipass-flush');\n\nconst {\n  PassThrough\n} = require('minipass-collect');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst PutOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  integrity: {},\n  memoize: {},\n  metadata: {},\n  pickAlgorithm: {},\n  size: {},\n  tmpPrefix: {},\n  single: {},\n  sep: {},\n  error: {},\n  strict: {}\n});\nmodule.exports = putData;\n\nfunction putData(cache, key, data, opts) {\n  opts = PutOpts(opts);\n  return write(cache, data, opts).then(res => {\n    return index.insert(cache, key, res.integrity, opts.concat({\n      size: res.size\n    })).then(entry => {\n      if (opts.memoize) {\n        memo.put(cache, entry, data, opts);\n      }\n\n      return res.integrity;\n    });\n  });\n}\n\nmodule.exports.stream = putStream;\n\nfunction putStream(cache, key, opts) {\n  opts = PutOpts(opts);\n  let integrity;\n  let size;\n  let memoData;\n  const pipeline = new Pipeline(); // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n\n  if (opts.memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data;\n    });\n    pipeline.push(memoizer);\n  } // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n\n\n  const contentStream = write.stream(cache, opts).on('integrity', int => {\n    integrity = int;\n  }).on('size', s => {\n    size = s;\n  });\n  pipeline.push(contentStream); // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n\n  pipeline.push(new Flush({\n    flush() {\n      return index.insert(cache, key, integrity, opts.concat({\n        size\n      })).then(entry => {\n        if (opts.memoize && memoData) {\n          memo.put(cache, entry, memoData, opts);\n        }\n\n        if (integrity) {\n          pipeline.emit('integrity', integrity);\n        }\n\n        if (size) {\n          pipeline.emit('size', size);\n        }\n      });\n    }\n\n  }));\n  return pipeline;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/cacache/put.js"],"names":["figgyPudding","require","index","memo","write","Flush","PassThrough","Pipeline","PutOpts","algorithms","default","integrity","memoize","metadata","pickAlgorithm","size","tmpPrefix","single","sep","error","strict","module","exports","putData","cache","key","data","opts","then","res","insert","concat","entry","put","stream","putStream","memoData","pipeline","memoizer","on","push","contentStream","int","s","flush","emit"],"mappings":"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","sourcesContent":["'use strict'\n\nconst figgyPudding = require('figgy-pudding')\nconst index = require('./lib/entry-index')\nconst memo = require('./lib/memoization')\nconst write = require('./lib/content/write')\nconst Flush = require('minipass-flush')\nconst { PassThrough } = require('minipass-collect')\nconst Pipeline = require('minipass-pipeline')\n\nconst PutOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  integrity: {},\n  memoize: {},\n  metadata: {},\n  pickAlgorithm: {},\n  size: {},\n  tmpPrefix: {},\n  single: {},\n  sep: {},\n  error: {},\n  strict: {}\n})\n\nmodule.exports = putData\n\nfunction putData (cache, key, data, opts) {\n  opts = PutOpts(opts)\n  return write(cache, data, opts).then((res) => {\n    return index\n      .insert(cache, key, res.integrity, opts.concat({ size: res.size }))\n      .then((entry) => {\n        if (opts.memoize) {\n          memo.put(cache, entry, data, opts)\n        }\n        return res.integrity\n      })\n  })\n}\n\nmodule.exports.stream = putStream\n\nfunction putStream (cache, key, opts) {\n  opts = PutOpts(opts)\n  let integrity\n  let size\n\n  let memoData\n  const pipeline = new Pipeline()\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (opts.memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data\n    })\n    pipeline.push(memoizer)\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  const contentStream = write.stream(cache, opts)\n    .on('integrity', (int) => {\n      integrity = int\n    })\n    .on('size', (s) => {\n      size = s\n    })\n\n  pipeline.push(contentStream)\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    flush () {\n      return index\n        .insert(cache, key, integrity, opts.concat({ size }))\n        .then((entry) => {\n          if (opts.memoize && memoData) {\n            memo.put(cache, entry, memoData, opts)\n          }\n          if (integrity) {\n            pipeline.emit('integrity', integrity)\n          }\n          if (size) {\n            pipeline.emit('size', size)\n          }\n        })\n    }\n  }))\n\n  return pipeline\n}\n"]},"metadata":{},"sourceType":"script"}