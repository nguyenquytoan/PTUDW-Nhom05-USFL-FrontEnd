{"ast":null,"code":"'use strict';\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _snapshot_resolver = require('./snapshot_resolver');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nvar _plugins = require('./plugins');\n\nvar _print = require('./print');\n\nvar utils = _interopRequireWildcard(require('./utils'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile = global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = `.${(0, _jestMatcherUtils.BOLD_WEIGHT)('not')} cannot be used with snapshot matchers`;\nconst HINT_ARG = 'hint';\nconst HINT_COLOR = _jestMatcherUtils.BOLD_WEIGHT;\nconst INLINE_SNAPSHOT_ARG = 'snapshot';\nconst PROPERTY_MATCHERS_ARG = 'properties';\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printName = (concatenatedBlockNames = '', hint = '', count) => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return '`' + (hasNames ? utils.escapeBacktickString(concatenatedBlockNames) : '') + (hasNames && hasHint ? ': ' : '') + (hasHint ? (0, _jestMatcherUtils.BOLD_WEIGHT)(utils.escapeBacktickString(hint)) : '') + ' ' + count + '`';\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substr(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) => hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = '\\\\.' + _snapshot_resolver.EXTENSION + '$';\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        _fs.default.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nconst toMatchSnapshot = function toMatchSnapshot(received, propertyMatchers, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let expectedArgument = '';\n  let secondArgument = '';\n\n  if (typeof propertyMatchers === 'object' && propertyMatchers !== null) {\n    expectedArgument = PROPERTY_MATCHERS_ARG;\n\n    if (typeof hint === 'string' && hint.length !== 0) {\n      secondArgument = HINT_ARG;\n    }\n  } else if (typeof propertyMatchers === 'string' && propertyMatchers.length !== 0) {\n    expectedArgument = HINT_ARG;\n  }\n\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument\n  };\n\n  if (expectedArgument === HINT_ARG) {\n    options.expectedColor = HINT_COLOR;\n  }\n\n  if (secondArgument === HINT_ARG) {\n    options.secondArgumentColor = HINT_COLOR;\n  }\n\n  if (arguments.length === 3 && !propertyMatchers) {\n    throw new Error('Property matchers must be an object.\\n\\nTo provide a snapshot test name without property matchers, use: toMatchSnapshot(\"name\")');\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    expectedArgument,\n    hint,\n    matcherName,\n    options,\n    propertyMatchers,\n    received\n  });\n};\n\nconst toMatchInlineSnapshot = function toMatchInlineSnapshot(received, propertyMatchersOrInlineSnapshot, inlineSnapshot) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let expectedArgument = '';\n  let secondArgument = '';\n\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    expectedArgument = INLINE_SNAPSHOT_ARG;\n  } else if (typeof propertyMatchersOrInlineSnapshot === 'object' && propertyMatchersOrInlineSnapshot !== null) {\n    expectedArgument = PROPERTY_MATCHERS_ARG;\n\n    if (typeof inlineSnapshot === 'string') {\n      secondArgument = INLINE_SNAPSHOT_ARG;\n    }\n  }\n\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument\n  };\n  let propertyMatchers;\n\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    inlineSnapshot = propertyMatchersOrInlineSnapshot;\n  } else {\n    propertyMatchers = propertyMatchersOrInlineSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    expectedArgument,\n    inlineSnapshot: stripAddedIndentation(inlineSnapshot || ''),\n    matcherName,\n    options,\n    propertyMatchers,\n    received\n  });\n};\n\nconst _toMatchSnapshot = ({\n  context,\n  expectedArgument,\n  hint,\n  inlineSnapshot,\n  matcherName,\n  options,\n  propertyMatchers,\n  received\n}) => {\n  context.dontThrow && context.dontThrow();\n  hint = typeof propertyMatchers === 'string' ? propertyMatchers : hint;\n  const currentTestName = context.currentTestName,\n        isNot = context.isNot,\n        snapshotState = context.snapshotState;\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + NOT_SNAPSHOT_MATCHERS);\n  }\n\n  if (!snapshotState) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\nsnapshot state must be initialized');\n  }\n\n  const fullTestName = currentTestName && hint ? `${currentTestName}: ${hint}` : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof propertyMatchers === 'object') {\n    if (propertyMatchers === null) {\n      throw new Error(`Property matchers must be an object.`);\n    }\n\n    const propertyPass = context.equals(received, propertyMatchers, [context.utils.iterableEquality, context.utils.subsetEquality]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const report = () => `Snapshot name: ${printName(currentTestName, hint, count)}\\n` + '\\n' + `Expected properties: ${context.utils.printExpected(propertyMatchers)}\\n` + `Received value:      ${context.utils.printReceived(received)}`;\n\n      return {\n        message: () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + report(),\n        name: matcherName,\n        pass: false,\n        report\n      };\n    } else {\n      received = utils.deepMerge(received, propertyMatchers);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    received,\n    testName: fullTestName\n  });\n  const count = result.count,\n        pass = result.pass;\n  let actual = result.actual,\n      expected = result.expected;\n  let report;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  } else if (!expected) {\n    report = () => `New snapshot was ${(0, _jestMatcherUtils.RECEIVED_COLOR)('not written')}. The update flag ` + `must be explicitly passed to write a new snapshot.\\n\\n` + `This is likely because this test is run in a continuous integration ` + `(CI) environment in which snapshots are not written by default.\\n\\n` + `${(0, _jestMatcherUtils.RECEIVED_COLOR)('Received value')} ` + `${actual}`;\n  } else {\n    expected = (expected || '').trim();\n    actual = (actual || '').trim(); // Assign to local variable because of declaration let expected:\n    // TypeScript thinks it could change before report function is called.\n\n    const printed = (0, _print.printDiffOrStringified)(expected, actual, received, 'Snapshot', 'Received', snapshotState.expand);\n\n    report = () => `Snapshot name: ${printName(currentTestName, hint, count)}\\n\\n` + printed;\n  } // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n\n  return {\n    actual,\n    expected,\n    message: () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + report(),\n    name: matcherName,\n    pass: false,\n    report\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function toThrowErrorMatchingSnapshot(received, hint, // because error TS1016 for hint?: string\nfromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot';\n  const expectedArgument = typeof hint === 'string' && hint.length !== 0 ? HINT_ARG : '';\n  const options = {\n    expectedColor: HINT_COLOR,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: ''\n  };\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    expectedArgument,\n    hint,\n    matcherName,\n    options,\n    received\n  }, fromPromise);\n};\n\nconst toThrowErrorMatchingInlineSnapshot = function toThrowErrorMatchingInlineSnapshot(received, inlineSnapshot, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n  const expectedArgument = typeof inlineSnapshot === 'string' ? INLINE_SNAPSHOT_ARG : '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: ''\n  };\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    expectedArgument,\n    inlineSnapshot: inlineSnapshot || '',\n    matcherName,\n    options,\n    received\n  }, fromPromise);\n};\n\nconst _toThrowErrorMatchingSnapshot = ({\n  context,\n  expectedArgument,\n  inlineSnapshot,\n  matcherName,\n  options,\n  received,\n  hint\n}, fromPromise) => {\n  context.dontThrow && context.dontThrow();\n  const isNot = context.isNot;\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + NOT_SNAPSHOT_MATCHERS);\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    throw new Error((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + DID_NOT_THROW);\n  }\n\n  return _toMatchSnapshot({\n    context,\n    expectedArgument,\n    hint,\n    inlineSnapshot,\n    matcherName,\n    options,\n    received: error.message\n  });\n};\n\nconst JestSnapshot = {\n  EXTENSION: _snapshot_resolver.EXTENSION,\n  SnapshotState: _State.default,\n  addSerializer: _plugins.addSerializer,\n  buildSnapshotResolver: _snapshot_resolver.buildSnapshotResolver,\n  cleanup,\n  getSerializers: _plugins.getSerializers,\n  isSnapshotPath: _snapshot_resolver.isSnapshotPath,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n  utils\n};\n/* eslint-disable-next-line no-redeclare */\n\nmodule.exports = JestSnapshot;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-snapshot/build/index.js"],"names":["_fs","_interopRequireDefault","require","_jestMatcherUtils","_snapshot_resolver","_State","_plugins","_print","utils","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","desc","defineProperty","getOwnPropertyDescriptor","get","set","default","Symbol","global","jestExistsFile","for","existsSync","DID_NOT_THROW","NOT_SNAPSHOT_MATCHERS","BOLD_WEIGHT","HINT_ARG","HINT_COLOR","INLINE_SNAPSHOT_ARG","PROPERTY_MATCHERS_ARG","INDENTATION_REGEX","printName","concatenatedBlockNames","hint","count","hasNames","length","hasHint","escapeBacktickString","stripAddedIndentation","inlineSnapshot","match","indentation","lines","split","trim","i","indexOf","substr","join","fileExists","filePath","hasteFS","exists","cleanup","update","snapshotResolver","testPathIgnorePatterns","pattern","EXTENSION","files","matchFiles","testIgnorePatternsRegex","RegExp","list","filter","snapshotFile","testPath","resolveTestPath","test","unlinkSync","filesRemoved","filesRemovedList","toMatchSnapshot","received","propertyMatchers","matcherName","expectedArgument","secondArgument","options","isNot","promise","expectedColor","secondArgumentColor","arguments","Error","_toMatchSnapshot","context","toMatchInlineSnapshot","propertyMatchersOrInlineSnapshot","dontThrow","currentTestName","snapshotState","matcherHint","undefined","fullTestName","propertyPass","equals","iterableEquality","subsetEquality","fail","matched","exec","Number","report","printExpected","printReceived","message","name","pass","deepMerge","result","error","testName","actual","expected","RECEIVED_COLOR","printed","printDiffOrStringified","expand","toThrowErrorMatchingSnapshot","fromPromise","_toThrowErrorMatchingSnapshot","toThrowErrorMatchingInlineSnapshot","e","JestSnapshot","SnapshotState","addSerializer","buildSnapshotResolver","getSerializers","isSnapshotPath","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _snapshot_resolver = require('./snapshot_resolver');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nvar _plugins = require('./plugins');\n\nvar _print = require('./print');\n\nvar utils = _interopRequireWildcard(require('./utils'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc =\n            Object.defineProperty && Object.getOwnPropertyDescriptor\n              ? Object.getOwnPropertyDescriptor(obj, key)\n              : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestExistsFile =\n  global[Symbol.for('jest-native-exists-file')] || _fs.default.existsSync;\n\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = `.${(0, _jestMatcherUtils.BOLD_WEIGHT)(\n  'not'\n)} cannot be used with snapshot matchers`;\nconst HINT_ARG = 'hint';\nconst HINT_COLOR = _jestMatcherUtils.BOLD_WEIGHT;\nconst INLINE_SNAPSHOT_ARG = 'snapshot';\nconst PROPERTY_MATCHERS_ARG = 'properties';\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printName = (concatenatedBlockNames = '', hint = '', count) => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return (\n    '`' +\n    (hasNames ? utils.escapeBacktickString(concatenatedBlockNames) : '') +\n    (hasNames && hasHint ? ': ' : '') +\n    (hasHint\n      ? (0, _jestMatcherUtils.BOLD_WEIGHT)(utils.escapeBacktickString(hint))\n      : '') +\n    ' ' +\n    count +\n    '`'\n  );\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substr(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) =>\n  hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = '\\\\.' + _snapshot_resolver.EXTENSION + '$';\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        _fs.default.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nconst toMatchSnapshot = function toMatchSnapshot(\n  received,\n  propertyMatchers,\n  hint\n) {\n  const matcherName = 'toMatchSnapshot';\n  let expectedArgument = '';\n  let secondArgument = '';\n\n  if (typeof propertyMatchers === 'object' && propertyMatchers !== null) {\n    expectedArgument = PROPERTY_MATCHERS_ARG;\n\n    if (typeof hint === 'string' && hint.length !== 0) {\n      secondArgument = HINT_ARG;\n    }\n  } else if (\n    typeof propertyMatchers === 'string' &&\n    propertyMatchers.length !== 0\n  ) {\n    expectedArgument = HINT_ARG;\n  }\n\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument\n  };\n\n  if (expectedArgument === HINT_ARG) {\n    options.expectedColor = HINT_COLOR;\n  }\n\n  if (secondArgument === HINT_ARG) {\n    options.secondArgumentColor = HINT_COLOR;\n  }\n\n  if (arguments.length === 3 && !propertyMatchers) {\n    throw new Error(\n      'Property matchers must be an object.\\n\\nTo provide a snapshot test name without property matchers, use: toMatchSnapshot(\"name\")'\n    );\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    expectedArgument,\n    hint,\n    matcherName,\n    options,\n    propertyMatchers,\n    received\n  });\n};\n\nconst toMatchInlineSnapshot = function toMatchInlineSnapshot(\n  received,\n  propertyMatchersOrInlineSnapshot,\n  inlineSnapshot\n) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let expectedArgument = '';\n  let secondArgument = '';\n\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    expectedArgument = INLINE_SNAPSHOT_ARG;\n  } else if (\n    typeof propertyMatchersOrInlineSnapshot === 'object' &&\n    propertyMatchersOrInlineSnapshot !== null\n  ) {\n    expectedArgument = PROPERTY_MATCHERS_ARG;\n\n    if (typeof inlineSnapshot === 'string') {\n      secondArgument = INLINE_SNAPSHOT_ARG;\n    }\n  }\n\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument\n  };\n  let propertyMatchers;\n\n  if (typeof propertyMatchersOrInlineSnapshot === 'string') {\n    inlineSnapshot = propertyMatchersOrInlineSnapshot;\n  } else {\n    propertyMatchers = propertyMatchersOrInlineSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    expectedArgument,\n    inlineSnapshot: stripAddedIndentation(inlineSnapshot || ''),\n    matcherName,\n    options,\n    propertyMatchers,\n    received\n  });\n};\n\nconst _toMatchSnapshot = ({\n  context,\n  expectedArgument,\n  hint,\n  inlineSnapshot,\n  matcherName,\n  options,\n  propertyMatchers,\n  received\n}) => {\n  context.dontThrow && context.dontThrow();\n  hint = typeof propertyMatchers === 'string' ? propertyMatchers : hint;\n  const currentTestName = context.currentTestName,\n    isNot = context.isNot,\n    snapshotState = context.snapshotState;\n\n  if (isNot) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherHint)(\n        matcherName,\n        undefined,\n        expectedArgument,\n        options\n      ) +\n        '\\n\\n' +\n        NOT_SNAPSHOT_MATCHERS\n    );\n  }\n\n  if (!snapshotState) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherHint)(\n        matcherName,\n        undefined,\n        expectedArgument,\n        options\n      ) + '\\n\\nsnapshot state must be initialized'\n    );\n  }\n\n  const fullTestName =\n    currentTestName && hint\n      ? `${currentTestName}: ${hint}`\n      : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof propertyMatchers === 'object') {\n    if (propertyMatchers === null) {\n      throw new Error(`Property matchers must be an object.`);\n    }\n\n    const propertyPass = context.equals(received, propertyMatchers, [\n      context.utils.iterableEquality,\n      context.utils.subsetEquality\n    ]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const report = () =>\n        `Snapshot name: ${printName(currentTestName, hint, count)}\\n` +\n        '\\n' +\n        `Expected properties: ${context.utils.printExpected(\n          propertyMatchers\n        )}\\n` +\n        `Received value:      ${context.utils.printReceived(received)}`;\n\n      return {\n        message: () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          report(),\n        name: matcherName,\n        pass: false,\n        report\n      };\n    } else {\n      received = utils.deepMerge(received, propertyMatchers);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    received,\n    testName: fullTestName\n  });\n  const count = result.count,\n    pass = result.pass;\n  let actual = result.actual,\n    expected = result.expected;\n  let report;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  } else if (!expected) {\n    report = () =>\n      `New snapshot was ${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n        'not written'\n      )}. The update flag ` +\n      `must be explicitly passed to write a new snapshot.\\n\\n` +\n      `This is likely because this test is run in a continuous integration ` +\n      `(CI) environment in which snapshots are not written by default.\\n\\n` +\n      `${(0, _jestMatcherUtils.RECEIVED_COLOR)('Received value')} ` +\n      `${actual}`;\n  } else {\n    expected = (expected || '').trim();\n    actual = (actual || '').trim(); // Assign to local variable because of declaration let expected:\n    // TypeScript thinks it could change before report function is called.\n\n    const printed = (0, _print.printDiffOrStringified)(\n      expected,\n      actual,\n      received,\n      'Snapshot',\n      'Received',\n      snapshotState.expand\n    );\n\n    report = () =>\n      `Snapshot name: ${printName(currentTestName, hint, count)}\\n\\n` + printed;\n  } // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n  return {\n    actual,\n    expected,\n    message: () =>\n      (0, _jestMatcherUtils.matcherHint)(\n        matcherName,\n        undefined,\n        expectedArgument,\n        options\n      ) +\n      '\\n\\n' +\n      report(),\n    name: matcherName,\n    pass: false,\n    report\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function toThrowErrorMatchingSnapshot(\n  received,\n  hint, // because error TS1016 for hint?: string\n  fromPromise\n) {\n  const matcherName = 'toThrowErrorMatchingSnapshot';\n  const expectedArgument =\n    typeof hint === 'string' && hint.length !== 0 ? HINT_ARG : '';\n  const options = {\n    expectedColor: HINT_COLOR,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: ''\n  };\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      expectedArgument,\n      hint,\n      matcherName,\n      options,\n      received\n    },\n    fromPromise\n  );\n};\n\nconst toThrowErrorMatchingInlineSnapshot = function toThrowErrorMatchingInlineSnapshot(\n  received,\n  inlineSnapshot,\n  fromPromise\n) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n  const expectedArgument =\n    typeof inlineSnapshot === 'string' ? INLINE_SNAPSHOT_ARG : '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: ''\n  };\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      expectedArgument,\n      inlineSnapshot: inlineSnapshot || '',\n      matcherName,\n      options,\n      received\n    },\n    fromPromise\n  );\n};\n\nconst _toThrowErrorMatchingSnapshot = (\n  {\n    context,\n    expectedArgument,\n    inlineSnapshot,\n    matcherName,\n    options,\n    received,\n    hint\n  },\n  fromPromise\n) => {\n  context.dontThrow && context.dontThrow();\n  const isNot = context.isNot;\n\n  if (isNot) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherHint)(\n        matcherName,\n        undefined,\n        expectedArgument,\n        options\n      ) +\n        '\\n\\n' +\n        NOT_SNAPSHOT_MATCHERS\n    );\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherHint)(\n        matcherName,\n        undefined,\n        expectedArgument,\n        options\n      ) +\n        '\\n\\n' +\n        DID_NOT_THROW\n    );\n  }\n\n  return _toMatchSnapshot({\n    context,\n    expectedArgument,\n    hint,\n    inlineSnapshot,\n    matcherName,\n    options,\n    received: error.message\n  });\n};\n\nconst JestSnapshot = {\n  EXTENSION: _snapshot_resolver.EXTENSION,\n  SnapshotState: _State.default,\n  addSerializer: _plugins.addSerializer,\n  buildSnapshotResolver: _snapshot_resolver.buildSnapshotResolver,\n  cleanup,\n  getSerializers: _plugins.getSerializers,\n  isSnapshotPath: _snapshot_resolver.isSnapshotPath,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n  utils\n};\n/* eslint-disable-next-line no-redeclare */\n\nmodule.exports = JestSnapshot;\n"]},"metadata":{},"sourceType":"script"}