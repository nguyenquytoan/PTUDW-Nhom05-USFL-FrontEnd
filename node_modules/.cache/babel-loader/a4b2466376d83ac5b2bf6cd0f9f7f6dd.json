{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { NavigationRoute } from './NavigationRoute.mjs';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n/**\n * Registers a route that will return a precached file for a navigation\n * request. This is useful for the\n * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n *\n * When determining the URL of the precached HTML document, you will likely need\n * to call `workbox.precaching.getCacheKeyForURL(originalUrl)`, to account for\n * the fact that Workbox's precaching naming conventions often results in URL\n * cache keys that contain extra revisioning info.\n *\n * This method will generate a\n * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n * and call\n * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute} on a\n * singleton Router instance.\n *\n * @param {string} cachedAssetUrl The cache key to use for the HTML file.\n * @param {Object} [options]\n * @param {string} [options.cacheName] Cache name to store and retrieve\n * requests. Defaults to precache cache name provided by\n * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n * match, the route will not handle the request (even if a whitelist entry\n * matches).\n * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n * match the URL's pathname and search parameter, the route will handle the\n * request (assuming the blacklist doesn't match).\n * @return {workbox.routing.NavigationRoute} Returns the generated\n * Route.\n *\n * @alias workbox.routing.registerNavigationRoute\n */\n\nexport const registerNavigationRoute = (cachedAssetUrl, options = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(cachedAssetUrl, 'string', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerNavigationRoute',\n      paramName: 'cachedAssetUrl'\n    });\n  }\n\n  const cacheName = cacheNames.getPrecacheName(options.cacheName);\n\n  const handler = async () => {\n    try {\n      const response = await caches.match(cachedAssetUrl, {\n        cacheName\n      });\n\n      if (response) {\n        return response;\n      } // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n\n\n      throw new Error(`The cache ${cacheName} did not have an entry for ` + `${cachedAssetUrl}.`);\n    } catch (error) {\n      // If there's either a cache miss, or the caches.match() call threw\n      // an exception, then attempt to fulfill the navigation request with\n      // a response from the network rather than leaving the user with a\n      // failed navigation.\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Unable to respond to navigation request with ` + `cached response. Falling back to network.`, error);\n      } // This might still fail if the browser is offline...\n\n\n      return fetch(cachedAssetUrl);\n    }\n  };\n\n  const route = new NavigationRoute(handler, {\n    whitelist: options.whitelist,\n    blacklist: options.blacklist\n  });\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n  return route;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-routing/registerNavigationRoute.mjs"],"names":["assert","cacheNames","logger","NavigationRoute","getOrCreateDefaultRouter","registerNavigationRoute","cachedAssetUrl","options","process","env","NODE_ENV","isType","moduleName","funcName","paramName","cacheName","getPrecacheName","handler","response","caches","match","Error","error","debug","fetch","route","whitelist","blacklist","defaultRouter","registerRoute"],"mappings":"AAAA;;;;;;;AAQA,SAAQA,MAAR,QAAqB,kCAArB;AACA,SAAQC,UAAR,QAAyB,sCAAzB;AACA,SAAQC,MAAR,QAAqB,kCAArB;AACA,SAAQC,eAAR,QAA8B,uBAA9B;AACA,SAAQC,wBAAR,QAAuC,sCAAvC;AACA,OAAO,gBAAP;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAO,MAAMC,uBAAuB,GAAG,CAACC,cAAD,EAAiBC,OAAO,GAAG,EAA3B,KAAkC;AACvE,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCV,IAAAA,MAAM,CAACW,MAAP,CAAcL,cAAd,EAA8B,QAA9B,EAAwC;AACtCM,MAAAA,UAAU,EAAE,iBAD0B;AAEtCC,MAAAA,QAAQ,EAAE,yBAF4B;AAGtCC,MAAAA,SAAS,EAAE;AAH2B,KAAxC;AAKD;;AAED,QAAMC,SAAS,GAAGd,UAAU,CAACe,eAAX,CAA2BT,OAAO,CAACQ,SAAnC,CAAlB;;AACA,QAAME,OAAO,GAAG,YAAY;AAC1B,QAAI;AACF,YAAMC,QAAQ,GAAG,MAAMC,MAAM,CAACC,KAAP,CAAad,cAAb,EAA6B;AAACS,QAAAA;AAAD,OAA7B,CAAvB;;AAEA,UAAIG,QAAJ,EAAc;AACZ,eAAOA,QAAP;AACD,OALC,CAOF;AACA;;;AACA,YAAM,IAAIG,KAAJ,CAAW,aAAYN,SAAU,6BAAvB,GACX,GAAET,cAAe,GADhB,CAAN;AAED,KAXD,CAWE,OAAOgB,KAAP,EAAc;AACd;AACA;AACA;AACA;AACA,UAAId,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCR,QAAAA,MAAM,CAACqB,KAAP,CAAc,+CAAD,GACR,2CADL,EACiDD,KADjD;AAED,OARa,CAUd;;;AACA,aAAOE,KAAK,CAAClB,cAAD,CAAZ;AACD;AACF,GAzBD;;AA2BA,QAAMmB,KAAK,GAAG,IAAItB,eAAJ,CAAoBc,OAApB,EAA6B;AACzCS,IAAAA,SAAS,EAAEnB,OAAO,CAACmB,SADsB;AAEzCC,IAAAA,SAAS,EAAEpB,OAAO,CAACoB;AAFsB,GAA7B,CAAd;AAKA,QAAMC,aAAa,GAAGxB,wBAAwB,EAA9C;AACAwB,EAAAA,aAAa,CAACC,aAAd,CAA4BJ,KAA5B;AAEA,SAAOA,KAAP;AACD,CA9CM","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {NavigationRoute} from './NavigationRoute.mjs';\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\nimport './_version.mjs';\n\n\n/**\n * Registers a route that will return a precached file for a navigation\n * request. This is useful for the\n * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n *\n * When determining the URL of the precached HTML document, you will likely need\n * to call `workbox.precaching.getCacheKeyForURL(originalUrl)`, to account for\n * the fact that Workbox's precaching naming conventions often results in URL\n * cache keys that contain extra revisioning info.\n *\n * This method will generate a\n * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n * and call\n * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute} on a\n * singleton Router instance.\n *\n * @param {string} cachedAssetUrl The cache key to use for the HTML file.\n * @param {Object} [options]\n * @param {string} [options.cacheName] Cache name to store and retrieve\n * requests. Defaults to precache cache name provided by\n * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n * match, the route will not handle the request (even if a whitelist entry\n * matches).\n * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n * match the URL's pathname and search parameter, the route will handle the\n * request (assuming the blacklist doesn't match).\n * @return {workbox.routing.NavigationRoute} Returns the generated\n * Route.\n *\n * @alias workbox.routing.registerNavigationRoute\n */\nexport const registerNavigationRoute = (cachedAssetUrl, options = {}) => {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(cachedAssetUrl, 'string', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerNavigationRoute',\n      paramName: 'cachedAssetUrl',\n    });\n  }\n\n  const cacheName = cacheNames.getPrecacheName(options.cacheName);\n  const handler = async () => {\n    try {\n      const response = await caches.match(cachedAssetUrl, {cacheName});\n\n      if (response) {\n        return response;\n      }\n\n      // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n      throw new Error(`The cache ${cacheName} did not have an entry for ` +\n          `${cachedAssetUrl}.`);\n    } catch (error) {\n      // If there's either a cache miss, or the caches.match() call threw\n      // an exception, then attempt to fulfill the navigation request with\n      // a response from the network rather than leaving the user with a\n      // failed navigation.\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Unable to respond to navigation request with ` +\n            `cached response. Falling back to network.`, error);\n      }\n\n      // This might still fail if the browser is offline...\n      return fetch(cachedAssetUrl);\n    }\n  };\n\n  const route = new NavigationRoute(handler, {\n    whitelist: options.whitelist,\n    blacklist: options.blacklist,\n  });\n\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n\n  return route;\n};\n"]},"metadata":{},"sourceType":"module"}