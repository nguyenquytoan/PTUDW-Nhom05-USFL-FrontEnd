{"ast":null,"code":"'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n/** Root class of all nodes */\n\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\n\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\n\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\n\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\n\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/yaml/dist/PlainValue-ec8e588e.js"],"names":["Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","defaultTagPrefix","defaultTags","STR","findLineStarts","src","ls","offset","indexOf","push","getSrcInfo","cst","lineStarts","Array","isArray","context","getLinePos","length","i","start","line","col","getLine","end","slice","getPrettyContext","maxWidth","substr","halfWidth","Math","round","errLen","errEnd","min","repeat","err","Range","copy","orig","constructor","isEmpty","setOrigRange","cr","origStart","origEnd","nextOffset","Node","addStringTerminator","str","next","endOfWhiteSpace","atDocumentBoundary","sep","ch0","prev","ch1","ch2","ch3","endOfIdentifier","ch","isVerbatim","notOk","endOfIndent","endOfLine","startOfLine","endOfBlockIndent","indent","lineStart","inEnd","wsEnd","atBlank","endAsBlank","nextNodeIsIndented","indentDiff","indicatorAsIndent","normalizeOffset","foldNewline","inCount","error","fold","type","props","Object","defineProperty","value","writable","range","valueRange","getPropValue","idx","key","skipKey","prop","anchor","comment","comments","join","commentHasRequiredWhitespace","header","hasComment","hasProps","includesTrailingLines","jsonLike","jsonLikeTypes","rangeAsLinePos","undefined","root","rawValue","tag","verbatim","_","handle","suffix","match","valueRangeContainsNewline","parseComment","commentRange","setOrigRanges","forEach","toString","YAMLError","Error","name","source","message","makePretty","nodeType","linePos","ctx","YAMLReferenceError","YAMLSemanticError","YAMLSyntaxError","YAMLWarning","_defineProperty","obj","enumerable","configurable","PlainValue","inFlow","strValue","wsStart","msg","errors","parseBlockValue","valueEnd","parse","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAG;AACXC,EAAAA,MAAM,EAAE,GADG;AAEXC,EAAAA,OAAO,EAAE,GAFE;AAGXC,EAAAA,GAAG,EAAE,GAHM;AAIXC,EAAAA,cAAc,EAAE,GAJL;AAKXC,EAAAA,YAAY,EAAE;AALH,CAAb;AAOA,MAAMC,IAAI,GAAG;AACXC,EAAAA,KAAK,EAAE,OADI;AAEXC,EAAAA,UAAU,EAAE,YAFD;AAGXC,EAAAA,YAAY,EAAE,cAHH;AAIXC,EAAAA,aAAa,EAAE,eAJJ;AAKXR,EAAAA,OAAO,EAAE,SALE;AAMXS,EAAAA,SAAS,EAAE,WANA;AAOXC,EAAAA,QAAQ,EAAE,UAPC;AAQXC,EAAAA,QAAQ,EAAE,UARC;AASXC,EAAAA,QAAQ,EAAE,UATC;AAUXC,EAAAA,GAAG,EAAE,KAVM;AAWXC,EAAAA,OAAO,EAAE,SAXE;AAYXC,EAAAA,SAAS,EAAE,WAZA;AAaXC,EAAAA,KAAK,EAAE,OAbI;AAcXC,EAAAA,YAAY,EAAE,cAdH;AAeXC,EAAAA,YAAY,EAAE,cAfH;AAgBXC,EAAAA,GAAG,EAAE,KAhBM;AAiBXC,EAAAA,QAAQ,EAAE;AAjBC,CAAb;AAmBA,MAAMC,gBAAgB,GAAG,oBAAzB;AACA,MAAMC,WAAW,GAAG;AAClBT,EAAAA,GAAG,EAAE,uBADa;AAElBM,EAAAA,GAAG,EAAE,uBAFa;AAGlBI,EAAAA,GAAG,EAAE;AAHa,CAApB;;AAMA,SAASC,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B,QAAMC,EAAE,GAAG,CAAC,CAAD,CAAX;AACA,MAAIC,MAAM,GAAGF,GAAG,CAACG,OAAJ,CAAY,IAAZ,CAAb;;AAEA,SAAOD,MAAM,KAAK,CAAC,CAAnB,EAAsB;AACpBA,IAAAA,MAAM,IAAI,CAAV;AACAD,IAAAA,EAAE,CAACG,IAAH,CAAQF,MAAR;AACAA,IAAAA,MAAM,GAAGF,GAAG,CAACG,OAAJ,CAAY,IAAZ,EAAkBD,MAAlB,CAAT;AACD;;AAED,SAAOD,EAAP;AACD;;AAED,SAASI,UAAT,CAAoBC,GAApB,EAAyB;AACvB,MAAIC,UAAJ,EAAgBP,GAAhB;;AAEA,MAAI,OAAOM,GAAP,KAAe,QAAnB,EAA6B;AAC3BC,IAAAA,UAAU,GAAGR,cAAc,CAACO,GAAD,CAA3B;AACAN,IAAAA,GAAG,GAAGM,GAAN;AACD,GAHD,MAGO;AACL,QAAIE,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwBA,GAAG,GAAGA,GAAG,CAAC,CAAD,CAAT;;AAExB,QAAIA,GAAG,IAAIA,GAAG,CAACI,OAAf,EAAwB;AACtB,UAAI,CAACJ,GAAG,CAACC,UAAT,EAAqBD,GAAG,CAACC,UAAJ,GAAiBR,cAAc,CAACO,GAAG,CAACI,OAAJ,CAAYV,GAAb,CAA/B;AACrBO,MAAAA,UAAU,GAAGD,GAAG,CAACC,UAAjB;AACAP,MAAAA,GAAG,GAAGM,GAAG,CAACI,OAAJ,CAAYV,GAAlB;AACD;AACF;;AAED,SAAO;AACLO,IAAAA,UADK;AAELP,IAAAA;AAFK,GAAP;AAID;AACD;;;;;;AAMA;;;;;;;;;;;;;;;;AAgBA,SAASW,UAAT,CAAoBT,MAApB,EAA4BI,GAA5B,EAAiC;AAC/B,MAAI,OAAOJ,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,GAAG,CAA3C,EAA8C,OAAO,IAAP;AAC9C,QAAM;AACJK,IAAAA,UADI;AAEJP,IAAAA;AAFI,MAGFK,UAAU,CAACC,GAAD,CAHd;AAIA,MAAI,CAACC,UAAD,IAAe,CAACP,GAAhB,IAAuBE,MAAM,GAAGF,GAAG,CAACY,MAAxC,EAAgD,OAAO,IAAP;;AAEhD,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,UAAU,CAACK,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,UAAMC,KAAK,GAAGP,UAAU,CAACM,CAAD,CAAxB;;AAEA,QAAIX,MAAM,GAAGY,KAAb,EAAoB;AAClB,aAAO;AACLC,QAAAA,IAAI,EAAEF,CADD;AAELG,QAAAA,GAAG,EAAEd,MAAM,GAAGK,UAAU,CAACM,CAAC,GAAG,CAAL,CAAnB,GAA6B;AAF7B,OAAP;AAID;;AAED,QAAIX,MAAM,KAAKY,KAAf,EAAsB,OAAO;AAC3BC,MAAAA,IAAI,EAAEF,CAAC,GAAG,CADiB;AAE3BG,MAAAA,GAAG,EAAE;AAFsB,KAAP;AAIvB;;AAED,QAAMD,IAAI,GAAGR,UAAU,CAACK,MAAxB;AACA,SAAO;AACLG,IAAAA,IADK;AAELC,IAAAA,GAAG,EAAEd,MAAM,GAAGK,UAAU,CAACQ,IAAI,GAAG,CAAR,CAAnB,GAAgC;AAFhC,GAAP;AAID;AACD;;;;;;;;;;;;;;;AAcA,SAASE,OAAT,CAAiBF,IAAjB,EAAuBT,GAAvB,EAA4B;AAC1B,QAAM;AACJC,IAAAA,UADI;AAEJP,IAAAA;AAFI,MAGFK,UAAU,CAACC,GAAD,CAHd;AAIA,MAAI,CAACC,UAAD,IAAe,EAAEQ,IAAI,IAAI,CAAV,CAAf,IAA+BA,IAAI,GAAGR,UAAU,CAACK,MAArD,EAA6D,OAAO,IAAP;AAC7D,QAAME,KAAK,GAAGP,UAAU,CAACQ,IAAI,GAAG,CAAR,CAAxB;AACA,MAAIG,GAAG,GAAGX,UAAU,CAACQ,IAAD,CAApB,CAP0B,CAOE;;AAE5B,SAAOG,GAAG,IAAIA,GAAG,GAAGJ,KAAb,IAAsBd,GAAG,CAACkB,GAAG,GAAG,CAAP,CAAH,KAAiB,IAA9C,EAAoD,EAAEA,GAAF;;AAEpD,SAAOlB,GAAG,CAACmB,KAAJ,CAAUL,KAAV,EAAiBI,GAAjB,CAAP;AACD;AACD;;;;;;;;;;;;;;;;;;AAiBA,SAASE,gBAAT,CAA0B;AACxBN,EAAAA,KADwB;AAExBI,EAAAA;AAFwB,CAA1B,EAGGZ,GAHH,EAGQe,QAAQ,GAAG,EAHnB,EAGuB;AACrB,MAAIrB,GAAG,GAAGiB,OAAO,CAACH,KAAK,CAACC,IAAP,EAAaT,GAAb,CAAjB;AACA,MAAI,CAACN,GAAL,EAAU,OAAO,IAAP;AACV,MAAI;AACFgB,IAAAA;AADE,MAEAF,KAFJ;;AAIA,MAAId,GAAG,CAACY,MAAJ,GAAaS,QAAjB,EAA2B;AACzB,QAAIL,GAAG,IAAIK,QAAQ,GAAG,EAAtB,EAA0B;AACxBrB,MAAAA,GAAG,GAAGA,GAAG,CAACsB,MAAJ,CAAW,CAAX,EAAcD,QAAQ,GAAG,CAAzB,IAA8B,GAApC;AACD,KAFD,MAEO;AACL,YAAME,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWJ,QAAQ,GAAG,CAAtB,CAAlB;AACA,UAAIrB,GAAG,CAACY,MAAJ,GAAaI,GAAG,GAAGO,SAAvB,EAAkCvB,GAAG,GAAGA,GAAG,CAACsB,MAAJ,CAAW,CAAX,EAAcN,GAAG,GAAGO,SAAN,GAAkB,CAAhC,IAAqC,GAA3C;AAClCP,MAAAA,GAAG,IAAIhB,GAAG,CAACY,MAAJ,GAAaS,QAApB;AACArB,MAAAA,GAAG,GAAG,MAAMA,GAAG,CAACsB,MAAJ,CAAW,IAAID,QAAf,CAAZ;AACD;AACF;;AAED,MAAIK,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,EAAb;;AAEA,MAAIT,GAAJ,EAAS;AACP,QAAIA,GAAG,CAACH,IAAJ,KAAaD,KAAK,CAACC,IAAnB,IAA2BC,GAAG,IAAIE,GAAG,CAACF,GAAJ,GAAUF,KAAK,CAACE,GAApB,CAAH,IAA+BK,QAAQ,GAAG,CAAzE,EAA4E;AAC1EK,MAAAA,MAAM,GAAGR,GAAG,CAACF,GAAJ,GAAUF,KAAK,CAACE,GAAzB;AACD,KAFD,MAEO;AACLU,MAAAA,MAAM,GAAGF,IAAI,CAACI,GAAL,CAAS5B,GAAG,CAACY,MAAJ,GAAa,CAAtB,EAAyBS,QAAzB,IAAqCL,GAA9C;AACAW,MAAAA,MAAM,GAAG,GAAT;AACD;AACF;;AAED,QAAMzB,MAAM,GAAGc,GAAG,GAAG,CAAN,GAAU,IAAIa,MAAJ,CAAWb,GAAG,GAAG,CAAjB,CAAV,GAAgC,EAA/C;AACA,QAAMc,GAAG,GAAG,IAAID,MAAJ,CAAWH,MAAX,CAAZ;AACA,SAAQ,GAAE1B,GAAI,KAAIE,MAAO,GAAE4B,GAAI,GAAEH,MAAO,EAAxC;AACD;;AAED,MAAMI,KAAN,CAAY;AACV,SAAOC,IAAP,CAAYC,IAAZ,EAAkB;AAChB,WAAO,IAAIF,KAAJ,CAAUE,IAAI,CAACnB,KAAf,EAAsBmB,IAAI,CAACf,GAA3B,CAAP;AACD;;AAEDgB,EAAAA,WAAW,CAACpB,KAAD,EAAQI,GAAR,EAAa;AACtB,SAAKJ,KAAL,GAAaA,KAAb;AACA,SAAKI,GAAL,GAAWA,GAAG,IAAIJ,KAAlB;AACD;;AAEDqB,EAAAA,OAAO,GAAG;AACR,WAAO,OAAO,KAAKrB,KAAZ,KAAsB,QAAtB,IAAkC,CAAC,KAAKI,GAAxC,IAA+C,KAAKA,GAAL,IAAY,KAAKJ,KAAvE;AACD;AACD;;;;;;;;;;AAUAsB,EAAAA,YAAY,CAACC,EAAD,EAAKnC,MAAL,EAAa;AACvB,UAAM;AACJY,MAAAA,KADI;AAEJI,MAAAA;AAFI,QAGF,IAHJ;;AAKA,QAAImB,EAAE,CAACzB,MAAH,KAAc,CAAd,IAAmBM,GAAG,IAAImB,EAAE,CAAC,CAAD,CAAhC,EAAqC;AACnC,WAAKC,SAAL,GAAiBxB,KAAjB;AACA,WAAKyB,OAAL,GAAerB,GAAf;AACA,aAAOhB,MAAP;AACD;;AAED,QAAIW,CAAC,GAAGX,MAAR;;AAEA,WAAOW,CAAC,GAAGwB,EAAE,CAACzB,MAAd,EAAsB;AACpB,UAAIyB,EAAE,CAACxB,CAAD,CAAF,GAAQC,KAAZ,EAAmB,MAAnB,KAA8B,EAAED,CAAF;AAC/B;;AAED,SAAKyB,SAAL,GAAiBxB,KAAK,GAAGD,CAAzB;AACA,UAAM2B,UAAU,GAAG3B,CAAnB;;AAEA,WAAOA,CAAC,GAAGwB,EAAE,CAACzB,MAAd,EAAsB;AACpB;AACA,UAAIyB,EAAE,CAACxB,CAAD,CAAF,IAASK,GAAb,EAAkB,MAAlB,KAA6B,EAAEL,CAAF;AAC9B;;AAED,SAAK0B,OAAL,GAAerB,GAAG,GAAGL,CAArB;AACA,WAAO2B,UAAP;AACD;;AAnDS;AAuDZ;;;AAEA,MAAMC,IAAN,CAAW;AACT,SAAOC,mBAAP,CAA2B1C,GAA3B,EAAgCE,MAAhC,EAAwCyC,GAAxC,EAA6C;AAC3C,QAAIA,GAAG,CAACA,GAAG,CAAC/B,MAAJ,GAAa,CAAd,CAAH,KAAwB,IAA5B,EAAkC,OAAO+B,GAAP;AAClC,UAAMC,IAAI,GAAGH,IAAI,CAACI,eAAL,CAAqB7C,GAArB,EAA0BE,MAA1B,CAAb;AACA,WAAO0C,IAAI,IAAI5C,GAAG,CAACY,MAAZ,IAAsBZ,GAAG,CAAC4C,IAAD,CAAH,KAAc,IAApC,GAA2CD,GAAG,GAAG,IAAjD,GAAwDA,GAA/D;AACD,GALQ,CAKP;;;AAGF,SAAOG,kBAAP,CAA0B9C,GAA1B,EAA+BE,MAA/B,EAAuC6C,GAAvC,EAA4C;AAC1C,UAAMC,GAAG,GAAGhD,GAAG,CAACE,MAAD,CAAf;AACA,QAAI,CAAC8C,GAAL,EAAU,OAAO,IAAP;AACV,UAAMC,IAAI,GAAGjD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAhB;AACA,QAAI+C,IAAI,IAAIA,IAAI,KAAK,IAArB,EAA2B,OAAO,KAAP;;AAE3B,QAAIF,GAAJ,EAAS;AACP,UAAIC,GAAG,KAAKD,GAAZ,EAAiB,OAAO,KAAP;AAClB,KAFD,MAEO;AACL,UAAIC,GAAG,KAAK3E,IAAI,CAACI,cAAb,IAA+BuE,GAAG,KAAK3E,IAAI,CAACK,YAAhD,EAA8D,OAAO,KAAP;AAC/D;;AAED,UAAMwE,GAAG,GAAGlD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAf;AACA,UAAMiD,GAAG,GAAGnD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAf;AACA,QAAIgD,GAAG,KAAKF,GAAR,IAAeG,GAAG,KAAKH,GAA3B,EAAgC,OAAO,KAAP;AAChC,UAAMI,GAAG,GAAGpD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAf;AACA,WAAO,CAACkD,GAAD,IAAQA,GAAG,KAAK,IAAhB,IAAwBA,GAAG,KAAK,IAAhC,IAAwCA,GAAG,KAAK,GAAvD;AACD;;AAED,SAAOC,eAAP,CAAuBrD,GAAvB,EAA4BE,MAA5B,EAAoC;AAClC,QAAIoD,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAZ;AACA,UAAMqD,UAAU,GAAGD,EAAE,KAAK,GAA1B;AACA,UAAME,KAAK,GAAGD,UAAU,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,GAAlB,CAAH,GAA4B,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,GAAlB,EAAuB,GAAvB,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,GAAtC,CAApD;;AAEA,WAAOD,EAAE,IAAIE,KAAK,CAACrD,OAAN,CAAcmD,EAAd,MAAsB,CAAC,CAApC,EAAuCA,EAAE,GAAGtD,GAAG,CAACE,MAAM,IAAI,CAAX,CAAR;;AAEvC,QAAIqD,UAAU,IAAID,EAAE,KAAK,GAAzB,EAA8BpD,MAAM,IAAI,CAAV;AAC9B,WAAOA,MAAP;AACD;;AAED,SAAOuD,WAAP,CAAmBzD,GAAnB,EAAwBE,MAAxB,EAAgC;AAC9B,QAAIoD,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAZ;;AAEA,WAAOoD,EAAE,KAAK,GAAd,EAAmBA,EAAE,GAAGtD,GAAG,CAACE,MAAM,IAAI,CAAX,CAAR;;AAEnB,WAAOA,MAAP;AACD;;AAED,SAAOwD,SAAP,CAAiB1D,GAAjB,EAAsBE,MAAtB,EAA8B;AAC5B,QAAIoD,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAZ;;AAEA,WAAOoD,EAAE,IAAIA,EAAE,KAAK,IAApB,EAA0BA,EAAE,GAAGtD,GAAG,CAACE,MAAM,IAAI,CAAX,CAAR;;AAE1B,WAAOA,MAAP;AACD;;AAED,SAAO2C,eAAP,CAAuB7C,GAAvB,EAA4BE,MAA5B,EAAoC;AAClC,QAAIoD,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAZ;;AAEA,WAAOoD,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,GAA7B,EAAkCA,EAAE,GAAGtD,GAAG,CAACE,MAAM,IAAI,CAAX,CAAR;;AAElC,WAAOA,MAAP;AACD;;AAED,SAAOyD,WAAP,CAAmB3D,GAAnB,EAAwBE,MAAxB,EAAgC;AAC9B,QAAIoD,EAAE,GAAGtD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAZ;AACA,QAAIoD,EAAE,KAAK,IAAX,EAAiB,OAAOpD,MAAP;;AAEjB,WAAOoD,EAAE,IAAIA,EAAE,KAAK,IAApB,EAA0BA,EAAE,GAAGtD,GAAG,CAACE,MAAM,IAAI,CAAX,CAAR;;AAE1B,WAAOA,MAAM,GAAG,CAAhB;AACD;AACD;;;;;;;;;;;AAWA,SAAO0D,gBAAP,CAAwB5D,GAAxB,EAA6B6D,MAA7B,EAAqCC,SAArC,EAAgD;AAC9C,UAAMC,KAAK,GAAGtB,IAAI,CAACgB,WAAL,CAAiBzD,GAAjB,EAAsB8D,SAAtB,CAAd;;AAEA,QAAIC,KAAK,GAAGD,SAAS,GAAGD,MAAxB,EAAgC;AAC9B,aAAOE,KAAP;AACD,KAFD,MAEO;AACL,YAAMC,KAAK,GAAGvB,IAAI,CAACI,eAAL,CAAqB7C,GAArB,EAA0B+D,KAA1B,CAAd;AACA,YAAMT,EAAE,GAAGtD,GAAG,CAACgE,KAAD,CAAd;AACA,UAAI,CAACV,EAAD,IAAOA,EAAE,KAAK,IAAlB,EAAwB,OAAOU,KAAP;AACzB;;AAED,WAAO,IAAP;AACD;;AAED,SAAOC,OAAP,CAAejE,GAAf,EAAoBE,MAApB,EAA4BgE,UAA5B,EAAwC;AACtC,UAAMZ,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAd;AACA,WAAOoD,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,IAAtB,IAA8BA,EAAE,KAAK,GAArC,IAA4CY,UAAU,IAAI,CAACZ,EAAlE;AACD;;AAED,SAAOa,kBAAP,CAA0Bb,EAA1B,EAA8Bc,UAA9B,EAA0CC,iBAA1C,EAA6D;AAC3D,QAAI,CAACf,EAAD,IAAOc,UAAU,GAAG,CAAxB,EAA2B,OAAO,KAAP;AAC3B,QAAIA,UAAU,GAAG,CAAjB,EAAoB,OAAO,IAAP;AACpB,WAAOC,iBAAiB,IAAIf,EAAE,KAAK,GAAnC;AACD,GAxGQ,CAwGP;;;AAGF,SAAOgB,eAAP,CAAuBtE,GAAvB,EAA4BE,MAA5B,EAAoC;AAClC,UAAMoD,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAd;AACA,WAAO,CAACoD,EAAD,GAAMpD,MAAN,GAAeoD,EAAE,KAAK,IAAP,IAAetD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAH,KAAoB,IAAnC,GAA0CA,MAAM,GAAG,CAAnD,GAAuDuC,IAAI,CAACI,eAAL,CAAqB7C,GAArB,EAA0BE,MAA1B,CAA7E;AACD,GA9GQ,CA8GP;AACF;;;AAGA,SAAOqE,WAAP,CAAmBvE,GAAnB,EAAwBE,MAAxB,EAAgC2D,MAAhC,EAAwC;AACtC,QAAIW,OAAO,GAAG,CAAd;AACA,QAAIC,KAAK,GAAG,KAAZ;AACA,QAAIC,IAAI,GAAG,EAAX;AACA,QAAIpB,EAAE,GAAGtD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAZ;;AAEA,WAAOoD,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,IAArB,IAA6BA,EAAE,KAAK,IAA3C,EAAiD;AAC/C,cAAQA,EAAR;AACE,aAAK,IAAL;AACEkB,UAAAA,OAAO,GAAG,CAAV;AACAtE,UAAAA,MAAM,IAAI,CAAV;AACAwE,UAAAA,IAAI,IAAI,IAAR;AACA;;AAEF,aAAK,IAAL;AACE,cAAIF,OAAO,IAAIX,MAAf,EAAuBY,KAAK,GAAG,IAAR;AACvBvE,UAAAA,MAAM,GAAGuC,IAAI,CAACI,eAAL,CAAqB7C,GAArB,EAA0BE,MAAM,GAAG,CAAnC,IAAwC,CAAjD;AACA;;AAEF,aAAK,GAAL;AACEsE,UAAAA,OAAO,IAAI,CAAX;AACAtE,UAAAA,MAAM,IAAI,CAAV;AACA;AAfJ;;AAkBAoD,MAAAA,EAAE,GAAGtD,GAAG,CAACE,MAAM,GAAG,CAAV,CAAR;AACD;;AAED,QAAI,CAACwE,IAAL,EAAWA,IAAI,GAAG,GAAP;AACX,QAAIpB,EAAE,IAAIkB,OAAO,IAAIX,MAArB,EAA6BY,KAAK,GAAG,IAAR;AAC7B,WAAO;AACLC,MAAAA,IADK;AAELxE,MAAAA,MAFK;AAGLuE,MAAAA;AAHK,KAAP;AAKD;;AAEDvC,EAAAA,WAAW,CAACyC,IAAD,EAAOC,KAAP,EAAclE,OAAd,EAAuB;AAChCmE,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACrCC,MAAAA,KAAK,EAAErE,OAAO,IAAI,IADmB;AAErCsE,MAAAA,QAAQ,EAAE;AAF2B,KAAvC;AAIA,SAAKP,KAAL,GAAa,IAAb;AACA,SAAKQ,KAAL,GAAa,IAAb;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKN,KAAL,GAAaA,KAAK,IAAI,EAAtB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKI,KAAL,GAAa,IAAb;AACD;;AAEDI,EAAAA,YAAY,CAACC,GAAD,EAAMC,GAAN,EAAWC,OAAX,EAAoB;AAC9B,QAAI,CAAC,KAAK5E,OAAV,EAAmB,OAAO,IAAP;AACnB,UAAM;AACJV,MAAAA;AADI,QAEF,KAAKU,OAFT;AAGA,UAAM6E,IAAI,GAAG,KAAKX,KAAL,CAAWQ,GAAX,CAAb;AACA,WAAOG,IAAI,IAAIvF,GAAG,CAACuF,IAAI,CAACzE,KAAN,CAAH,KAAoBuE,GAA5B,GAAkCrF,GAAG,CAACmB,KAAJ,CAAUoE,IAAI,CAACzE,KAAL,IAAcwE,OAAO,GAAG,CAAH,GAAO,CAA5B,CAAV,EAA0CC,IAAI,CAACrE,GAA/C,CAAlC,GAAwF,IAA/F;AACD;;AAED,MAAIsE,MAAJ,GAAa;AACX,SAAK,IAAI3E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK+D,KAAL,CAAWhE,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,YAAM2E,MAAM,GAAG,KAAKL,YAAL,CAAkBtE,CAAlB,EAAqBxC,IAAI,CAACC,MAA1B,EAAkC,IAAlC,CAAf;AACA,UAAIkH,MAAM,IAAI,IAAd,EAAoB,OAAOA,MAAP;AACrB;;AAED,WAAO,IAAP;AACD;;AAED,MAAIC,OAAJ,GAAc;AACZ,UAAMC,QAAQ,GAAG,EAAjB;;AAEA,SAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK+D,KAAL,CAAWhE,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,YAAM4E,OAAO,GAAG,KAAKN,YAAL,CAAkBtE,CAAlB,EAAqBxC,IAAI,CAACE,OAA1B,EAAmC,IAAnC,CAAhB;AACA,UAAIkH,OAAO,IAAI,IAAf,EAAqBC,QAAQ,CAACtF,IAAT,CAAcqF,OAAd;AACtB;;AAED,WAAOC,QAAQ,CAAC9E,MAAT,GAAkB,CAAlB,GAAsB8E,QAAQ,CAACC,IAAT,CAAc,IAAd,CAAtB,GAA4C,IAAnD;AACD;;AAEDC,EAAAA,4BAA4B,CAAC9E,KAAD,EAAQ;AAClC,UAAM;AACJd,MAAAA;AADI,QAEF,KAAKU,OAFT;AAGA,QAAI,KAAKmF,MAAL,IAAe/E,KAAK,KAAK,KAAK+E,MAAL,CAAY3E,GAAzC,EAA8C,OAAO,KAAP;AAC9C,QAAI,CAAC,KAAKgE,UAAV,EAAsB,OAAO,KAAP;AACtB,UAAM;AACJhE,MAAAA;AADI,QAEF,KAAKgE,UAFT;AAGA,WAAOpE,KAAK,KAAKI,GAAV,IAAiBuB,IAAI,CAACwB,OAAL,CAAajE,GAAb,EAAkBkB,GAAG,GAAG,CAAxB,CAAxB;AACD;;AAED,MAAI4E,UAAJ,GAAiB;AACf,QAAI,KAAKpF,OAAT,EAAkB;AAChB,YAAM;AACJV,QAAAA;AADI,UAEF,KAAKU,OAFT;;AAIA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK+D,KAAL,CAAWhE,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,YAAIb,GAAG,CAAC,KAAK4E,KAAL,CAAW/D,CAAX,EAAcC,KAAf,CAAH,KAA6BzC,IAAI,CAACE,OAAtC,EAA+C,OAAO,IAAP;AAChD;AACF;;AAED,WAAO,KAAP;AACD;;AAED,MAAIwH,QAAJ,GAAe;AACb,QAAI,KAAKrF,OAAT,EAAkB;AAChB,YAAM;AACJV,QAAAA;AADI,UAEF,KAAKU,OAFT;;AAIA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK+D,KAAL,CAAWhE,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,YAAIb,GAAG,CAAC,KAAK4E,KAAL,CAAW/D,CAAX,EAAcC,KAAf,CAAH,KAA6BzC,IAAI,CAACE,OAAtC,EAA+C,OAAO,IAAP;AAChD;AACF;;AAED,WAAO,KAAP;AACD;;AAED,MAAIyH,qBAAJ,GAA4B;AAC1B,WAAO,KAAP;AACD;;AAED,MAAIC,QAAJ,GAAe;AACb,UAAMC,aAAa,GAAG,CAACvH,IAAI,CAACO,QAAN,EAAgBP,IAAI,CAACQ,QAArB,EAA+BR,IAAI,CAACa,YAApC,EAAkDb,IAAI,CAACc,YAAvD,CAAtB;AACA,WAAOyG,aAAa,CAAC/F,OAAd,CAAsB,KAAKwE,IAA3B,MAAqC,CAAC,CAA7C;AACD;;AAED,MAAIwB,cAAJ,GAAqB;AACnB,QAAI,CAAC,KAAKlB,KAAN,IAAe,CAAC,KAAKvE,OAAzB,EAAkC,OAAO0F,SAAP;AAClC,UAAMtF,KAAK,GAAGH,UAAU,CAAC,KAAKsE,KAAL,CAAWnE,KAAZ,EAAmB,KAAKJ,OAAL,CAAa2F,IAAhC,CAAxB;AACA,QAAI,CAACvF,KAAL,EAAY,OAAOsF,SAAP;AACZ,UAAMlF,GAAG,GAAGP,UAAU,CAAC,KAAKsE,KAAL,CAAW/D,GAAZ,EAAiB,KAAKR,OAAL,CAAa2F,IAA9B,CAAtB;AACA,WAAO;AACLvF,MAAAA,KADK;AAELI,MAAAA;AAFK,KAAP;AAID;;AAED,MAAIoF,QAAJ,GAAe;AACb,QAAI,CAAC,KAAKpB,UAAN,IAAoB,CAAC,KAAKxE,OAA9B,EAAuC,OAAO,IAAP;AACvC,UAAM;AACJI,MAAAA,KADI;AAEJI,MAAAA;AAFI,QAGF,KAAKgE,UAHT;AAIA,WAAO,KAAKxE,OAAL,CAAaV,GAAb,CAAiBmB,KAAjB,CAAuBL,KAAvB,EAA8BI,GAA9B,CAAP;AACD;;AAED,MAAIqF,GAAJ,GAAU;AACR,SAAK,IAAI1F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK+D,KAAL,CAAWhE,MAA/B,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,YAAM0F,GAAG,GAAG,KAAKpB,YAAL,CAAkBtE,CAAlB,EAAqBxC,IAAI,CAACG,GAA1B,EAA+B,KAA/B,CAAZ;;AAEA,UAAI+H,GAAG,IAAI,IAAX,EAAiB;AACf,YAAIA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAf,EAAoB;AAClB,iBAAO;AACLC,YAAAA,QAAQ,EAAED,GAAG,CAACpF,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd;AADL,WAAP;AAGD,SAJD,MAIO;AACL;AACA,gBAAM,CAACsF,CAAD,EAAIC,MAAJ,EAAYC,MAAZ,IAAsBJ,GAAG,CAACK,KAAJ,CAAU,gBAAV,CAA5B;AACA,iBAAO;AACLF,YAAAA,MADK;AAELC,YAAAA;AAFK,WAAP;AAID;AACF;AACF;;AAED,WAAO,IAAP;AACD;;AAED,MAAIE,yBAAJ,GAAgC;AAC9B,QAAI,CAAC,KAAK3B,UAAN,IAAoB,CAAC,KAAKxE,OAA9B,EAAuC,OAAO,KAAP;AACvC,UAAM;AACJI,MAAAA,KADI;AAEJI,MAAAA;AAFI,QAGF,KAAKgE,UAHT;AAIA,UAAM;AACJlF,MAAAA;AADI,QAEF,KAAKU,OAFT;;AAIA,SAAK,IAAIG,CAAC,GAAGC,KAAb,EAAoBD,CAAC,GAAGK,GAAxB,EAA6B,EAAEL,CAA/B,EAAkC;AAChC,UAAIb,GAAG,CAACa,CAAD,CAAH,KAAW,IAAf,EAAqB,OAAO,IAAP;AACtB;;AAED,WAAO,KAAP;AACD;;AAEDiG,EAAAA,YAAY,CAAChG,KAAD,EAAQ;AAClB,UAAM;AACJd,MAAAA;AADI,QAEF,KAAKU,OAFT;;AAIA,QAAIV,GAAG,CAACc,KAAD,CAAH,KAAezC,IAAI,CAACE,OAAxB,EAAiC;AAC/B,YAAM2C,GAAG,GAAGuB,IAAI,CAACiB,SAAL,CAAe1D,GAAf,EAAoBc,KAAK,GAAG,CAA5B,CAAZ;AACA,YAAMiG,YAAY,GAAG,IAAIhF,KAAJ,CAAUjB,KAAV,EAAiBI,GAAjB,CAArB;AACA,WAAK0D,KAAL,CAAWxE,IAAX,CAAgB2G,YAAhB;AACA,aAAO7F,GAAP;AACD;;AAED,WAAOJ,KAAP;AACD;AACD;;;;;;;;;;AAUAkG,EAAAA,aAAa,CAAC3E,EAAD,EAAKnC,MAAL,EAAa;AACxB,QAAI,KAAK+E,KAAT,EAAgB/E,MAAM,GAAG,KAAK+E,KAAL,CAAW7C,YAAX,CAAwBC,EAAxB,EAA4BnC,MAA5B,CAAT;AAChB,QAAI,KAAKgF,UAAT,EAAqB,KAAKA,UAAL,CAAgB9C,YAAhB,CAA6BC,EAA7B,EAAiCnC,MAAjC;AACrB,SAAK0E,KAAL,CAAWqC,OAAX,CAAmB1B,IAAI,IAAIA,IAAI,CAACnD,YAAL,CAAkBC,EAAlB,EAAsBnC,MAAtB,CAA3B;AACA,WAAOA,MAAP;AACD;;AAEDgH,EAAAA,QAAQ,GAAG;AACT,UAAM;AACJxG,MAAAA,OAAO,EAAE;AACPV,QAAAA;AADO,OADL;AAIJiF,MAAAA,KAJI;AAKJF,MAAAA;AALI,QAMF,IANJ;AAOA,QAAIA,KAAK,IAAI,IAAb,EAAmB,OAAOA,KAAP;AACnB,UAAMpC,GAAG,GAAG3C,GAAG,CAACmB,KAAJ,CAAU8D,KAAK,CAACnE,KAAhB,EAAuBmE,KAAK,CAAC/D,GAA7B,CAAZ;AACA,WAAOuB,IAAI,CAACC,mBAAL,CAAyB1C,GAAzB,EAA8BiF,KAAK,CAAC/D,GAApC,EAAyCyB,GAAzC,CAAP;AACD;;AAxVQ;;AA4VX,MAAMwE,SAAN,SAAwBC,KAAxB,CAA8B;AAC5BlF,EAAAA,WAAW,CAACmF,IAAD,EAAOC,MAAP,EAAeC,OAAf,EAAwB;AACjC,QAAI,CAACA,OAAD,IAAY,EAAED,MAAM,YAAY7E,IAApB,CAAhB,EAA2C,MAAM,IAAI2E,KAAJ,CAAW,6BAA4BC,IAAK,EAA5C,CAAN;AAC3C;AACA,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA,SAAKD,MAAL,GAAcA,MAAd;AACD;;AAEDE,EAAAA,UAAU,GAAG;AACX,QAAI,CAAC,KAAKF,MAAV,EAAkB;AAClB,SAAKG,QAAL,GAAgB,KAAKH,MAAL,CAAY3C,IAA5B;AACA,UAAMrE,GAAG,GAAG,KAAKgH,MAAL,CAAY5G,OAAZ,IAAuB,KAAK4G,MAAL,CAAY5G,OAAZ,CAAoB2F,IAAvD;;AAEA,QAAI,OAAO,KAAKnG,MAAZ,KAAuB,QAA3B,EAAqC;AACnC,WAAK+E,KAAL,GAAa,IAAIlD,KAAJ,CAAU,KAAK7B,MAAf,EAAuB,KAAKA,MAAL,GAAc,CAArC,CAAb;AACA,YAAMY,KAAK,GAAGR,GAAG,IAAIK,UAAU,CAAC,KAAKT,MAAN,EAAcI,GAAd,CAA/B;;AAEA,UAAIQ,KAAJ,EAAW;AACT,cAAMI,GAAG,GAAG;AACVH,UAAAA,IAAI,EAAED,KAAK,CAACC,IADF;AAEVC,UAAAA,GAAG,EAAEF,KAAK,CAACE,GAAN,GAAY;AAFP,SAAZ;AAIA,aAAK0G,OAAL,GAAe;AACb5G,UAAAA,KADa;AAEbI,UAAAA;AAFa,SAAf;AAID;;AAED,aAAO,KAAKhB,MAAZ;AACD,KAhBD,MAgBO;AACL,WAAK+E,KAAL,GAAa,KAAKqC,MAAL,CAAYrC,KAAzB;AACA,WAAKyC,OAAL,GAAe,KAAKJ,MAAL,CAAYnB,cAA3B;AACD;;AAED,QAAI,KAAKuB,OAAT,EAAkB;AAChB,YAAM;AACJ3G,QAAAA,IADI;AAEJC,QAAAA;AAFI,UAGF,KAAK0G,OAAL,CAAa5G,KAHjB;AAIA,WAAKyG,OAAL,IAAiB,YAAWxG,IAAK,YAAWC,GAAI,EAAhD;AACA,YAAM2G,GAAG,GAAGrH,GAAG,IAAIc,gBAAgB,CAAC,KAAKsG,OAAN,EAAepH,GAAf,CAAnC;AACA,UAAIqH,GAAJ,EAAS,KAAKJ,OAAL,IAAiB,QAAOI,GAAI,IAA5B;AACV;;AAED,WAAO,KAAKL,MAAZ;AACD;;AA9C2B;;AAiD9B,MAAMM,kBAAN,SAAiCT,SAAjC,CAA2C;AACzCjF,EAAAA,WAAW,CAACoF,MAAD,EAASC,OAAT,EAAkB;AAC3B,UAAM,oBAAN,EAA4BD,MAA5B,EAAoCC,OAApC;AACD;;AAHwC;;AAM3C,MAAMM,iBAAN,SAAgCV,SAAhC,CAA0C;AACxCjF,EAAAA,WAAW,CAACoF,MAAD,EAASC,OAAT,EAAkB;AAC3B,UAAM,mBAAN,EAA2BD,MAA3B,EAAmCC,OAAnC;AACD;;AAHuC;;AAM1C,MAAMO,eAAN,SAA8BX,SAA9B,CAAwC;AACtCjF,EAAAA,WAAW,CAACoF,MAAD,EAASC,OAAT,EAAkB;AAC3B,UAAM,iBAAN,EAAyBD,MAAzB,EAAiCC,OAAjC;AACD;;AAHqC;;AAMxC,MAAMQ,WAAN,SAA0BZ,SAA1B,CAAoC;AAClCjF,EAAAA,WAAW,CAACoF,MAAD,EAASC,OAAT,EAAkB;AAC3B,UAAM,aAAN,EAAqBD,MAArB,EAA6BC,OAA7B;AACD;;AAHiC;;AAOpC,SAASS,eAAT,CAAyBC,GAAzB,EAA8B5C,GAA9B,EAAmCN,KAAnC,EAA0C;AACxC,MAAIM,GAAG,IAAI4C,GAAX,EAAgB;AACdpD,IAAAA,MAAM,CAACC,cAAP,CAAsBmD,GAAtB,EAA2B5C,GAA3B,EAAgC;AAC9BN,MAAAA,KAAK,EAAEA,KADuB;AAE9BmD,MAAAA,UAAU,EAAE,IAFkB;AAG9BC,MAAAA,YAAY,EAAE,IAHgB;AAI9BnD,MAAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACLiD,IAAAA,GAAG,CAAC5C,GAAD,CAAH,GAAWN,KAAX;AACD;;AAED,SAAOkD,GAAP;AACD;;AAED,MAAMG,UAAN,SAAyB3F,IAAzB,CAA8B;AAC5B,SAAOiB,SAAP,CAAiB1D,GAAjB,EAAsBc,KAAtB,EAA6BuH,MAA7B,EAAqC;AACnC,QAAI/E,EAAE,GAAGtD,GAAG,CAACc,KAAD,CAAZ;AACA,QAAIZ,MAAM,GAAGY,KAAb;;AAEA,WAAOwC,EAAE,IAAIA,EAAE,KAAK,IAApB,EAA0B;AACxB,UAAI+E,MAAM,KAAK/E,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAArB,IAA4BA,EAAE,KAAK,GAAnC,IAA0CA,EAAE,KAAK,GAAjD,IAAwDA,EAAE,KAAK,GAApE,CAAV,EAAoF;AACpF,YAAMV,IAAI,GAAG5C,GAAG,CAACE,MAAM,GAAG,CAAV,CAAhB;AACA,UAAIoD,EAAE,KAAK,GAAP,KAAe,CAACV,IAAD,IAASA,IAAI,KAAK,IAAlB,IAA0BA,IAAI,KAAK,IAAnC,IAA2CA,IAAI,KAAK,GAApD,IAA2DyF,MAAM,IAAIzF,IAAI,KAAK,GAA7F,CAAJ,EAAuG;AACvG,UAAI,CAACU,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,IAAtB,KAA+BV,IAAI,KAAK,GAA5C,EAAiD;AACjD1C,MAAAA,MAAM,IAAI,CAAV;AACAoD,MAAAA,EAAE,GAAGV,IAAL;AACD;;AAED,WAAO1C,MAAP;AACD;;AAED,MAAIoI,QAAJ,GAAe;AACb,QAAI,CAAC,KAAKpD,UAAN,IAAoB,CAAC,KAAKxE,OAA9B,EAAuC,OAAO,IAAP;AACvC,QAAI;AACFI,MAAAA,KADE;AAEFI,MAAAA;AAFE,QAGA,KAAKgE,UAHT;AAIA,UAAM;AACJlF,MAAAA;AADI,QAEF,KAAKU,OAFT;AAGA,QAAI4C,EAAE,GAAGtD,GAAG,CAACkB,GAAG,GAAG,CAAP,CAAZ;;AAEA,WAAOJ,KAAK,GAAGI,GAAR,KAAgBoC,EAAE,KAAK,IAAP,IAAeA,EAAE,KAAK,IAAtB,IAA8BA,EAAE,KAAK,GAArD,CAAP,EAAkEA,EAAE,GAAGtD,GAAG,CAAC,EAAEkB,GAAF,GAAQ,CAAT,CAAR;;AAElE,QAAIyB,GAAG,GAAG,EAAV;;AAEA,SAAK,IAAI9B,CAAC,GAAGC,KAAb,EAAoBD,CAAC,GAAGK,GAAxB,EAA6B,EAAEL,CAA/B,EAAkC;AAChC,YAAMyC,EAAE,GAAGtD,GAAG,CAACa,CAAD,CAAd;;AAEA,UAAIyC,EAAE,KAAK,IAAX,EAAiB;AACf,cAAM;AACJoB,UAAAA,IADI;AAEJxE,UAAAA;AAFI,YAGFuC,IAAI,CAAC8B,WAAL,CAAiBvE,GAAjB,EAAsBa,CAAtB,EAAyB,CAAC,CAA1B,CAHJ;AAIA8B,QAAAA,GAAG,IAAI+B,IAAP;AACA7D,QAAAA,CAAC,GAAGX,MAAJ;AACD,OAPD,MAOO,IAAIoD,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,IAAzB,EAA+B;AACpC;AACA,cAAMiF,OAAO,GAAG1H,CAAhB;AACA,YAAI+B,IAAI,GAAG5C,GAAG,CAACa,CAAC,GAAG,CAAL,CAAd;;AAEA,eAAOA,CAAC,GAAGK,GAAJ,KAAY0B,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAArC,CAAP,EAAmD;AACjD/B,UAAAA,CAAC,IAAI,CAAL;AACA+B,UAAAA,IAAI,GAAG5C,GAAG,CAACa,CAAC,GAAG,CAAL,CAAV;AACD;;AAED,YAAI+B,IAAI,KAAK,IAAb,EAAmBD,GAAG,IAAI9B,CAAC,GAAG0H,OAAJ,GAAcvI,GAAG,CAACmB,KAAJ,CAAUoH,OAAV,EAAmB1H,CAAC,GAAG,CAAvB,CAAd,GAA0CyC,EAAjD;AACpB,OAXM,MAWA;AACLX,QAAAA,GAAG,IAAIW,EAAP;AACD;AACF;;AAED,UAAMN,GAAG,GAAGhD,GAAG,CAACc,KAAD,CAAf;;AAEA,YAAQkC,GAAR;AACE,WAAK,IAAL;AACE;AACE,gBAAMwF,GAAG,GAAG,+CAAZ;AACA,gBAAMC,MAAM,GAAG,CAAC,IAAIZ,iBAAJ,CAAsB,IAAtB,EAA4BW,GAA5B,CAAD,CAAf;AACA,iBAAO;AACLC,YAAAA,MADK;AAEL9F,YAAAA;AAFK,WAAP;AAID;;AAEH,WAAK,GAAL;AACA,WAAK,GAAL;AACE;AACE,gBAAM6F,GAAG,GAAI,oDAAmDxF,GAAI,EAApE;AACA,gBAAMyF,MAAM,GAAG,CAAC,IAAIZ,iBAAJ,CAAsB,IAAtB,EAA4BW,GAA5B,CAAD,CAAf;AACA,iBAAO;AACLC,YAAAA,MADK;AAEL9F,YAAAA;AAFK,WAAP;AAID;;AAEH;AACE,eAAOA,GAAP;AAvBJ;AAyBD;;AAED+F,EAAAA,eAAe,CAAC5H,KAAD,EAAQ;AACrB,UAAM;AACJ+C,MAAAA,MADI;AAEJwE,MAAAA,MAFI;AAGJrI,MAAAA;AAHI,QAIF,KAAKU,OAJT;AAKA,QAAIR,MAAM,GAAGY,KAAb;AACA,QAAI6H,QAAQ,GAAG7H,KAAf;;AAEA,SAAK,IAAIwC,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAjB,EAA2BoD,EAAE,KAAK,IAAlC,EAAwCA,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAhD,EAA0D;AACxD,UAAIuC,IAAI,CAACK,kBAAL,CAAwB9C,GAAxB,EAA6BE,MAAM,GAAG,CAAtC,CAAJ,EAA8C;AAC9C,YAAMgB,GAAG,GAAGuB,IAAI,CAACmB,gBAAL,CAAsB5D,GAAtB,EAA2B6D,MAA3B,EAAmC3D,MAAM,GAAG,CAA5C,CAAZ;AACA,UAAIgB,GAAG,KAAK,IAAR,IAAgBlB,GAAG,CAACkB,GAAD,CAAH,KAAa,GAAjC,EAAsC;;AAEtC,UAAIlB,GAAG,CAACkB,GAAD,CAAH,KAAa,IAAjB,EAAuB;AACrBhB,QAAAA,MAAM,GAAGgB,GAAT;AACD,OAFD,MAEO;AACLyH,QAAAA,QAAQ,GAAGP,UAAU,CAAC1E,SAAX,CAAqB1D,GAArB,EAA0BkB,GAA1B,EAA+BmH,MAA/B,CAAX;AACAnI,QAAAA,MAAM,GAAGyI,QAAT;AACD;AACF;;AAED,QAAI,KAAKzD,UAAL,CAAgB/C,OAAhB,EAAJ,EAA+B,KAAK+C,UAAL,CAAgBpE,KAAhB,GAAwBA,KAAxB;AAC/B,SAAKoE,UAAL,CAAgBhE,GAAhB,GAAsByH,QAAtB;AACA,WAAOA,QAAP;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BAC,EAAAA,KAAK,CAAClI,OAAD,EAAUI,KAAV,EAAiB;AACpB,SAAKJ,OAAL,GAAeA,OAAf;AACA,UAAM;AACJ2H,MAAAA,MADI;AAEJrI,MAAAA;AAFI,QAGFU,OAHJ;AAIA,QAAIR,MAAM,GAAGY,KAAb;AACA,UAAMwC,EAAE,GAAGtD,GAAG,CAACE,MAAD,CAAd;;AAEA,QAAIoD,EAAE,IAAIA,EAAE,KAAK,GAAb,IAAoBA,EAAE,KAAK,IAA/B,EAAqC;AACnCpD,MAAAA,MAAM,GAAGkI,UAAU,CAAC1E,SAAX,CAAqB1D,GAArB,EAA0Bc,KAA1B,EAAiCuH,MAAjC,CAAT;AACD;;AAED,SAAKnD,UAAL,GAAkB,IAAInD,KAAJ,CAAUjB,KAAV,EAAiBZ,MAAjB,CAAlB;AACAA,IAAAA,MAAM,GAAGuC,IAAI,CAACI,eAAL,CAAqB7C,GAArB,EAA0BE,MAA1B,CAAT;AACAA,IAAAA,MAAM,GAAG,KAAK4G,YAAL,CAAkB5G,MAAlB,CAAT;;AAEA,QAAI,CAAC,KAAK4F,UAAN,IAAoB,KAAKZ,UAAL,CAAgB/C,OAAhB,EAAxB,EAAmD;AACjDjC,MAAAA,MAAM,GAAG,KAAKwI,eAAL,CAAqBxI,MAArB,CAAT;AACD;;AAED,WAAOA,MAAP;AACD;;AAlK2B;;AAsK9B2I,OAAO,CAACxK,IAAR,GAAeA,IAAf;AACAwK,OAAO,CAACpG,IAAR,GAAeA,IAAf;AACAoG,OAAO,CAACT,UAAR,GAAqBA,UAArB;AACAS,OAAO,CAAC9G,KAAR,GAAgBA,KAAhB;AACA8G,OAAO,CAAClK,IAAR,GAAeA,IAAf;AACAkK,OAAO,CAAC1B,SAAR,GAAoBA,SAApB;AACA0B,OAAO,CAACjB,kBAAR,GAA6BA,kBAA7B;AACAiB,OAAO,CAAChB,iBAAR,GAA4BA,iBAA5B;AACAgB,OAAO,CAACf,eAAR,GAA0BA,eAA1B;AACAe,OAAO,CAACd,WAAR,GAAsBA,WAAtB;AACAc,OAAO,CAACb,eAAR,GAA0BA,eAA1B;AACAa,OAAO,CAACjJ,gBAAR,GAA2BA,gBAA3B;AACAiJ,OAAO,CAAChJ,WAAR,GAAsBA,WAAtB","sourcesContent":["'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n"]},"metadata":{},"sourceType":"script"}