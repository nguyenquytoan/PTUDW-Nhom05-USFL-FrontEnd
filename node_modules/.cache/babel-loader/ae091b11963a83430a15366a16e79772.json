{"ast":null,"code":"/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  arrays: \"never\",\n  objects: \"never\",\n  imports: \"never\",\n  exports: \"never\",\n  functions: \"never\"\n});\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\n\nfunction isTrailingCommaAllowed(lastItem) {\n  return !(lastItem.type === \"RestElement\" || lastItem.type === \"RestProperty\" || lastItem.type === \"ExperimentalRestProperty\");\n}\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\n\n\nfunction normalizeOptions(optionValue, ecmaVersion) {\n  if (typeof optionValue === \"string\") {\n    return {\n      arrays: optionValue,\n      objects: optionValue,\n      imports: optionValue,\n      exports: optionValue,\n      functions: !ecmaVersion || ecmaVersion < 8 ? \"ignore\" : optionValue\n    };\n  }\n\n  if (typeof optionValue === \"object\" && optionValue !== null) {\n    return {\n      arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n      objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n      imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n      exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n      functions: optionValue.functions || DEFAULT_OPTIONS.functions\n    };\n  }\n\n  return DEFAULT_OPTIONS;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow trailing commas\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-dangle\"\n    },\n    fixable: \"code\",\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always-multiline\", \"always\", \"never\", \"only-multiline\"]\n        },\n        valueWithIgnore: {\n          enum: [\"always-multiline\", \"always\", \"ignore\", \"never\", \"only-multiline\"]\n        }\n      },\n      type: \"array\",\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/value\"\n        }, {\n          type: \"object\",\n          properties: {\n            arrays: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            objects: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            imports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            exports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            functions: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            }\n          },\n          additionalProperties: false\n        }]\n      }]\n    },\n    messages: {\n      unexpected: \"Unexpected trailing comma.\",\n      missing: \"Missing trailing comma.\"\n    }\n  },\n\n  create(context) {\n    const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n    const sourceCode = context.getSourceCode();\n    /**\n     * Gets the last item of the given node.\n     * @param {ASTNode} node The node to get.\n     * @returns {ASTNode|null} The last node or null.\n     */\n\n    function getLastItem(node) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          return lodash.last(node.properties);\n\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          return lodash.last(node.elements);\n\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return lodash.last(node.specifiers);\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n          return lodash.last(node.params);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return lodash.last(node.arguments);\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * Gets the trailing comma token of the given node.\n     * If the trailing comma does not exist, this returns the token which is\n     * the insertion point of the trailing comma token.\n     * @param {ASTNode} node The node to get.\n     * @param {ASTNode} lastItem The last item of the node.\n     * @returns {Token} The trailing comma token or the insertion point.\n     */\n\n\n    function getTrailingToken(node, lastItem) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return sourceCode.getLastToken(node, 1);\n\n        default:\n          {\n            const nextToken = sourceCode.getTokenAfter(lastItem);\n\n            if (astUtils.isCommaToken(nextToken)) {\n              return nextToken;\n            }\n\n            return sourceCode.getLastToken(lastItem);\n          }\n      }\n    }\n    /**\n     * Checks whether or not a given node is multiline.\n     * This rule handles a given node as multiline when the closing parenthesis\n     * and the last element are not on the same line.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is multiline.\n     */\n\n\n    function isMultiline(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem) {\n        return false;\n      }\n\n      const penultimateToken = getTrailingToken(node, lastItem);\n      const lastToken = sourceCode.getTokenAfter(penultimateToken);\n      return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n    }\n    /**\n     * Reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function forbidTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (astUtils.isCommaToken(trailingToken)) {\n        context.report({\n          node: lastItem,\n          loc: trailingToken.loc,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            return fixer.remove(trailingToken);\n          }\n\n        });\n      }\n    }\n    /**\n     * Reports the last element of a given node if it does not have a trailing\n     * comma.\n     *\n     * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n     * comma is disallowed, so report if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function forceTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      if (!isTrailingCommaAllowed(lastItem)) {\n        forbidTrailingComma(node);\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (trailingToken.value !== \",\") {\n        context.report({\n          node: lastItem,\n          loc: {\n            start: trailingToken.loc.end,\n            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n          },\n          messageId: \"missing\",\n\n          fix(fixer) {\n            return fixer.insertTextAfter(trailingToken, \",\");\n          }\n\n        });\n      }\n    }\n    /**\n     * If a given node is multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function forceTrailingCommaIfMultiline(node) {\n      if (isMultiline(node)) {\n        forceTrailingComma(node);\n      } else {\n        forbidTrailingComma(node);\n      }\n    }\n    /**\n     * Only if a given node is not multiline, reports the last element of a given node\n     * when it does not have a trailing comma.\n     * Otherwise, reports a trailing comma if it exists.\n     * @param {ASTNode} node A node to check. Its type is one of\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n     *   ImportDeclaration, and ExportNamedDeclaration.\n     * @returns {void}\n     */\n\n\n    function allowTrailingCommaIfMultiline(node) {\n      if (!isMultiline(node)) {\n        forbidTrailingComma(node);\n      }\n    }\n\n    const predicate = {\n      always: forceTrailingComma,\n      \"always-multiline\": forceTrailingCommaIfMultiline,\n      \"only-multiline\": allowTrailingCommaIfMultiline,\n      never: forbidTrailingComma,\n      ignore: lodash.noop\n    };\n    return {\n      ObjectExpression: predicate[options.objects],\n      ObjectPattern: predicate[options.objects],\n      ArrayExpression: predicate[options.arrays],\n      ArrayPattern: predicate[options.arrays],\n      ImportDeclaration: predicate[options.imports],\n      ExportNamedDeclaration: predicate[options.exports],\n      FunctionDeclaration: predicate[options.functions],\n      FunctionExpression: predicate[options.functions],\n      ArrowFunctionExpression: predicate[options.functions],\n      CallExpression: predicate[options.functions],\n      NewExpression: predicate[options.functions]\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/comma-dangle.js"],"names":["lodash","require","astUtils","DEFAULT_OPTIONS","Object","freeze","arrays","objects","imports","exports","functions","isTrailingCommaAllowed","lastItem","type","normalizeOptions","optionValue","ecmaVersion","module","meta","docs","description","category","recommended","url","fixable","schema","definitions","value","enum","valueWithIgnore","items","oneOf","$ref","properties","additionalProperties","messages","unexpected","missing","create","context","options","parserOptions","sourceCode","getSourceCode","getLastItem","node","last","elements","specifiers","params","arguments","getTrailingToken","getLastToken","nextToken","getTokenAfter","isCommaToken","isMultiline","penultimateToken","lastToken","loc","end","line","forbidTrailingComma","trailingToken","report","messageId","fix","fixer","remove","forceTrailingComma","start","getNextLocation","insertTextAfter","forceTrailingCommaIfMultiline","allowTrailingCommaIfMultiline","predicate","always","never","ignore","noop","ObjectExpression","ObjectPattern","ArrayExpression","ArrayPattern","ImportDeclaration","ExportNamedDeclaration","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","CallExpression","NewExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n            functions: (!ecmaVersion || ecmaVersion < 8) ? \"ignore\" : optionValue\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return lodash.last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return lodash.last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return lodash.last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return lodash.last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return lodash.last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         * @param {ASTNode} node The node to get.\n         * @param {ASTNode} lastItem The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: {\n                        start: trailingToken.loc.end,\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n                    },\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: lodash.noop\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}