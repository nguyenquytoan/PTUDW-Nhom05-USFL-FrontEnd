{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow comma operators\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-sequences\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Parts of the grammar that are required to have parens.\n     */\n\n    const parenthesized = {\n      DoWhileStatement: \"test\",\n      IfStatement: \"test\",\n      SwitchStatement: \"discriminant\",\n      WhileStatement: \"test\",\n      WithStatement: \"object\",\n      ArrowFunctionExpression: \"body\"\n      /*\n       * Omitting CallExpression - commas are parsed as argument separators\n       * Omitting NewExpression - commas are parsed as argument separators\n       * Omitting ForInStatement - parts aren't individually parenthesised\n       * Omitting ForStatement - parts aren't individually parenthesised\n       */\n\n    };\n    /**\n     * Determines whether a node is required by the grammar to be wrapped in\n     * parens, e.g. the test of an if statement.\n     * @param {ASTNode} node The AST node\n     * @returns {boolean} True if parens around node belong to parent node.\n     */\n\n    function requiresExtraParens(node) {\n      return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];\n    }\n    /**\n     * Check if a node is wrapped in parens.\n     * @param {ASTNode} node The AST node\n     * @returns {boolean} True if the node has a paren on each side.\n     */\n\n\n    function isParenthesised(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\n     * Check if a node is wrapped in two levels of parens.\n     * @param {ASTNode} node The AST node\n     * @returns {boolean} True if two parens surround the node on each side.\n     */\n\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n\n    return {\n      SequenceExpression(node) {\n        // Always allow sequences in for statement update\n        if (node.parent.type === \"ForStatement\" && (node === node.parent.init || node === node.parent.update)) {\n          return;\n        } // Wrapping a sequence in extra parens indicates intent\n\n\n        if (requiresExtraParens(node)) {\n          if (isParenthesisedTwice(node)) {\n            return;\n          }\n        } else {\n          if (isParenthesised(node)) {\n            return;\n          }\n        }\n\n        const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);\n        context.report({\n          node,\n          loc: firstCommaToken.loc,\n          message: \"Unexpected use of comma operator.\"\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-sequences.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","create","context","sourceCode","getSourceCode","parenthesized","DoWhileStatement","IfStatement","SwitchStatement","WhileStatement","WithStatement","ArrowFunctionExpression","requiresExtraParens","node","parent","isParenthesised","isParenthesisedTwice","previousToken","getTokenBefore","nextToken","getTokenAfter","isOpeningParenToken","range","isClosingParenToken","SequenceExpression","init","update","firstCommaToken","expressions","isCommaToken","report","loc","message"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow comma operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-sequences\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Parts of the grammar that are required to have parens.\n         */\n        const parenthesized = {\n            DoWhileStatement: \"test\",\n            IfStatement: \"test\",\n            SwitchStatement: \"discriminant\",\n            WhileStatement: \"test\",\n            WithStatement: \"object\",\n            ArrowFunctionExpression: \"body\"\n\n            /*\n             * Omitting CallExpression - commas are parsed as argument separators\n             * Omitting NewExpression - commas are parsed as argument separators\n             * Omitting ForInStatement - parts aren't individually parenthesised\n             * Omitting ForStatement - parts aren't individually parenthesised\n             */\n        };\n\n        /**\n         * Determines whether a node is required by the grammar to be wrapped in\n         * parens, e.g. the test of an if statement.\n         * @param {ASTNode} node The AST node\n         * @returns {boolean} True if parens around node belong to parent node.\n         */\n        function requiresExtraParens(node) {\n            return node.parent && parenthesized[node.parent.type] &&\n                    node === node.parent[parenthesized[node.parent.type]];\n        }\n\n        /**\n         * Check if a node is wrapped in parens.\n         * @param {ASTNode} node The AST node\n         * @returns {boolean} True if the node has a paren on each side.\n         */\n        function isParenthesised(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if a node is wrapped in two levels of parens.\n         * @param {ASTNode} node The AST node\n         * @returns {boolean} True if two parens surround the node on each side.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        return {\n            SequenceExpression(node) {\n\n                // Always allow sequences in for statement update\n                if (node.parent.type === \"ForStatement\" &&\n                        (node === node.parent.init || node === node.parent.update)) {\n                    return;\n                }\n\n                // Wrapping a sequence in extra parens indicates intent\n                if (requiresExtraParens(node)) {\n                    if (isParenthesisedTwice(node)) {\n                        return;\n                    }\n                } else {\n                    if (isParenthesised(node)) {\n                        return;\n                    }\n                }\n\n                const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);\n\n                context.report({ node, loc: firstCommaToken.loc, message: \"Unexpected use of comma operator.\" });\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}