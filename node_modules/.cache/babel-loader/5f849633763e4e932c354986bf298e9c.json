{"ast":null,"code":"/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks between arguments of a function call\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"consistent\"]\n    }],\n    messages: {\n      unexpectedLineBreak: \"There should be no line break here.\",\n      missingLineBreak: \"There should be a line break after this argument.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const checkers = {\n      unexpected: {\n        messageId: \"unexpectedLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n      },\n      missing: {\n        messageId: \"missingLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n      }\n    };\n    /**\n     * Check all arguments for line breaks in the CallExpression\n     * @param {CallExpression} node node to evaluate\n     * @param {{ messageId: string, check: Function }} checker selected checker\n     * @returns {void}\n     * @private\n     */\n\n    function checkArguments(node, checker) {\n      for (let i = 1; i < node.arguments.length; i++) {\n        const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n        const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n        if (checker.check(prevArgToken, currentArgToken)) {\n          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {\n            includeComments: true\n          });\n          const hasLineCommentBefore = tokenBefore.type === \"Line\";\n          context.report({\n            node,\n            loc: {\n              start: tokenBefore.loc.end,\n              end: currentArgToken.loc.start\n            },\n            messageId: checker.messageId,\n            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n          });\n        }\n      }\n    }\n    /**\n     * Check if open space is present in a function name\n     * @param {CallExpression} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n\n\n    function check(node) {\n      if (node.arguments.length < 2) {\n        return;\n      }\n\n      const option = context.options[0] || \"always\";\n\n      if (option === \"never\") {\n        checkArguments(node, checkers.unexpected);\n      } else if (option === \"always\") {\n        checkArguments(node, checkers.missing);\n      } else if (option === \"consistent\") {\n        const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n        const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n        if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n          checkArguments(node, checkers.unexpected);\n        } else {\n          checkArguments(node, checkers.missing);\n        }\n      }\n    }\n\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/function-call-argument-newline.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","checkers","unexpected","messageId","check","prevToken","currentToken","loc","end","line","start","createFix","token","tokenBefore","fixer","replaceTextRange","range","missing","checkArguments","node","checker","i","arguments","length","prevArgToken","getLastToken","currentArgToken","getFirstToken","getTokenBefore","includeComments","hasLineCommentBefore","report","fix","option","options","firstArgToken","secondArgToken","CallExpression","NewExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks between arguments of a function call\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"consistent\"]\n            }\n        ],\n\n        messages: {\n            unexpectedLineBreak: \"There should be no line break here.\",\n            missingLineBreak: \"There should be a line break after this argument.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const checkers = {\n            unexpected: {\n                messageId: \"unexpectedLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n            },\n            missing: {\n                messageId: \"missingLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n            }\n        };\n\n        /**\n         * Check all arguments for line breaks in the CallExpression\n         * @param {CallExpression} node node to evaluate\n         * @param {{ messageId: string, check: Function }} checker selected checker\n         * @returns {void}\n         * @private\n         */\n        function checkArguments(node, checker) {\n            for (let i = 1; i < node.arguments.length; i++) {\n                const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n                if (checker.check(prevArgToken, currentArgToken)) {\n                    const tokenBefore = sourceCode.getTokenBefore(\n                        currentArgToken,\n                        { includeComments: true }\n                    );\n\n                    const hasLineCommentBefore = tokenBefore.type === \"Line\";\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBefore.loc.end,\n                            end: currentArgToken.loc.start\n                        },\n                        messageId: checker.messageId,\n                        fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if open space is present in a function name\n         * @param {CallExpression} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (node.arguments.length < 2) {\n                return;\n            }\n\n            const option = context.options[0] || \"always\";\n\n            if (option === \"never\") {\n                checkArguments(node, checkers.unexpected);\n            } else if (option === \"always\") {\n                checkArguments(node, checkers.missing);\n            } else if (option === \"consistent\") {\n                const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n                if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n                    checkArguments(node, checkers.unexpected);\n                } else {\n                    checkArguments(node, checkers.missing);\n                }\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}