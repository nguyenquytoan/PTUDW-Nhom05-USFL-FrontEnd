{"ast":null,"code":"/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst OPTIONS = {\n  always: \"always\",\n  never: \"never\",\n  methods: \"methods\",\n  properties: \"properties\",\n  consistent: \"consistent\",\n  consistentAsNeeded: \"consistent-as-needed\"\n}; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow method and property shorthand syntax for object literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-shorthand\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\"]\n        }, {\n          type: \"object\",\n          properties: {\n            avoidQuotes: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\"]\n        }, {\n          type: \"object\",\n          properties: {\n            ignoreConstructors: {\n              type: \"boolean\"\n            },\n            avoidQuotes: {\n              type: \"boolean\"\n            },\n            avoidExplicitReturnArrows: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    }\n  },\n\n  create(context) {\n    const APPLY = context.options[0] || OPTIONS.always;\n    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n    const APPLY_NEVER = APPLY === OPTIONS.never;\n    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n    const PARAMS = context.options[1] || {};\n    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n    const AVOID_QUOTES = PARAMS.avoidQuotes;\n    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n    /**\n     * Determines if the first character of the name is a capital letter.\n     * @param {string} name The name of the node to evaluate.\n     * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n     * @private\n     */\n\n    function isConstructor(name) {\n      const match = CTOR_PREFIX_REGEX.exec(name); // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n\n      if (!match) {\n        return false;\n      }\n\n      const firstChar = name.charAt(match.index);\n      return firstChar === firstChar.toUpperCase();\n    }\n    /**\n     * Determines if the property can have a shorthand form.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the property can have a shorthand form\n     * @private\n     *\n     */\n\n\n    function canHaveShorthand(property) {\n      return property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\";\n    }\n    /**\n     * Checks whether a node is a string literal.\n     * @param   {ASTNode} node Any AST node.\n     * @returns {boolean} `true` if it is a string literal.\n     */\n\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\n     * Determines if the property is a shorthand or not.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the property is considered shorthand, false if not.\n     * @private\n     *\n     */\n\n\n    function isShorthand(property) {\n      // property.method is true when `{a(){}}`.\n      return property.shorthand || property.method;\n    }\n    /**\n     * Determines if the property's key and method or value are named equally.\n     * @param {ASTNode} property Property AST node\n     * @returns {boolean} True if the key and value are named equally, false if not.\n     * @private\n     *\n     */\n\n\n    function isRedundant(property) {\n      const value = property.value;\n\n      if (value.type === \"FunctionExpression\") {\n        return !value.id; // Only anonymous should be shorthand method.\n      }\n\n      if (value.type === \"Identifier\") {\n        return astUtils.getStaticPropertyName(property) === value.name;\n      }\n\n      return false;\n    }\n    /**\n     * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n     * @param   {ASTNode} node Property AST node\n     * @param   {boolean} checkRedundancy Whether to check longform redundancy\n     * @returns {void}\n     *\n     */\n\n\n    function checkConsistency(node, checkRedundancy) {\n      // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n      const properties = node.properties.filter(canHaveShorthand); // Do we still have properties left after filtering the getters and setters?\n\n      if (properties.length > 0) {\n        const shorthandProperties = properties.filter(isShorthand);\n        /*\n         * If we do not have an equal number of longform properties as\n         * shorthand properties, we are using the annotations inconsistently\n         */\n\n        if (shorthandProperties.length !== properties.length) {\n          // We have at least 1 shorthand property\n          if (shorthandProperties.length > 0) {\n            context.report({\n              node,\n              message: \"Unexpected mix of shorthand and non-shorthand properties.\"\n            });\n          } else if (checkRedundancy) {\n            /*\n             * If all properties of the object contain a method or value with a name matching it's key,\n             * all the keys are redundant.\n             */\n            const canAlwaysUseShorthand = properties.every(isRedundant);\n\n            if (canAlwaysUseShorthand) {\n              context.report({\n                node,\n                message: \"Expected shorthand for all properties.\"\n              });\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Fixes a FunctionExpression node by making it into a shorthand property.\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n     * @returns {Object} A fix for this node\n     */\n\n\n    function makeFunctionShorthand(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let keyPrefix = \"\"; // key: /* */ () => {}\n\n      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n        return null;\n      }\n\n      if (node.value.async) {\n        keyPrefix += \"async \";\n      }\n\n      if (node.value.generator) {\n        keyPrefix += \"*\";\n      }\n\n      const fixRange = [firstKeyToken.range[0], node.range[1]];\n      const methodPrefix = keyPrefix + keyText;\n\n      if (node.value.type === \"FunctionExpression\") {\n        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n        return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n      const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n      let shouldAddParensAroundParameters = false;\n      let tokenBeforeParams;\n\n      if (node.value.params.length === 0) {\n        tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n      } else {\n        tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n      }\n\n      if (node.value.params.length === 1) {\n        const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n        const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n        shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n      }\n\n      const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];\n      const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n      const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n      const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n      return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);\n    }\n    /**\n     * Fixes a FunctionExpression node by making it into a longform property.\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n     * @returns {Object} A fix for this node\n     */\n\n\n    function makeFunctionLongform(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let functionHeader = \"function\";\n\n      if (node.value.async) {\n        functionHeader = `async ${functionHeader}`;\n      }\n\n      if (node.value.generator) {\n        functionHeader = `${functionHeader}*`;\n      }\n\n      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n    }\n    /*\n     * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n     * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n     * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n     * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n     * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n     * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n     * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n     * because converting it into a method would change the value of one of the lexical identifiers.\n     */\n\n\n    const lexicalScopeStack = [];\n    const arrowsWithLexicalIdentifiers = new WeakSet();\n    const argumentsIdentifiers = new WeakSet();\n    /**\n     * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n     * Also, this marks all `arguments` identifiers so that they can be detected later.\n     * @returns {void}\n     */\n\n    function enterFunction() {\n      lexicalScopeStack.unshift(new Set());\n      context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n      });\n    }\n    /**\n     * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n     * @returns {void}\n     */\n\n\n    function exitFunction() {\n      lexicalScopeStack.shift();\n    }\n    /**\n     * Marks the current function as having a lexical keyword. This implies that all arrow functions\n     * in the current lexical scope contain a reference to this lexical keyword.\n     * @returns {void}\n     */\n\n\n    function reportLexicalIdentifier() {\n      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: enterFunction,\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      \"Program:exit\": exitFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n\n      ArrowFunctionExpression(node) {\n        lexicalScopeStack[0].add(node);\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        lexicalScopeStack[0].delete(node);\n      },\n\n      ThisExpression: reportLexicalIdentifier,\n      Super: reportLexicalIdentifier,\n\n      MetaProperty(node) {\n        if (node.meta.name === \"new\" && node.property.name === \"target\") {\n          reportLexicalIdentifier();\n        }\n      },\n\n      Identifier(node) {\n        if (argumentsIdentifiers.has(node)) {\n          reportLexicalIdentifier();\n        }\n      },\n\n      ObjectExpression(node) {\n        if (APPLY_CONSISTENT) {\n          checkConsistency(node, false);\n        } else if (APPLY_CONSISTENT_AS_NEEDED) {\n          checkConsistency(node, true);\n        }\n      },\n\n      \"Property:exit\"(node) {\n        const isConciseProperty = node.method || node.shorthand; // Ignore destructuring assignment\n\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        } // getters and setters are ignored\n\n\n        if (node.kind === \"get\" || node.kind === \"set\") {\n          return;\n        } // only computed methods can fail the following checks\n\n\n        if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n          return;\n        } //--------------------------------------------------------------\n        // Checks for property/method shorthand.\n\n\n        if (isConciseProperty) {\n          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n            const message = APPLY_NEVER ? \"Expected longform method syntax.\" : \"Expected longform method syntax for string literal keys.\"; // { x() {} } should be written as { x: function() {} }\n\n            context.report({\n              node,\n              message,\n              fix: fixer => makeFunctionLongform(fixer, node)\n            });\n          } else if (APPLY_NEVER) {\n            // { x } should be written as { x: x }\n            context.report({\n              node,\n              message: \"Expected longform property syntax.\",\n              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n            });\n          }\n        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n          if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n            return;\n          }\n\n          if (AVOID_QUOTES && isStringLiteral(node.key)) {\n            return;\n          } // {[x]: function(){}} should be written as {[x]() {}}\n\n\n          if (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\" && node.value.body.type === \"BlockStatement\" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {\n            context.report({\n              node,\n              message: \"Expected method shorthand.\",\n              fix: fixer => makeFunctionShorthand(fixer, node)\n            });\n          }\n        } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n          // {x: x} should be written as {x}\n          context.report({\n            node,\n            message: \"Expected property shorthand.\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n          if (AVOID_QUOTES) {\n            return;\n          } // {\"x\": x} should be written as {x}\n\n\n          context.report({\n            node,\n            message: \"Expected property shorthand.\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/object-shorthand.js"],"names":["OPTIONS","always","never","methods","properties","consistent","consistentAsNeeded","astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","avoidQuotes","additionalProperties","ignoreConstructors","avoidExplicitReturnArrows","create","context","APPLY","options","APPLY_TO_METHODS","APPLY_TO_PROPS","APPLY_NEVER","APPLY_CONSISTENT","APPLY_CONSISTENT_AS_NEEDED","PARAMS","IGNORE_CONSTRUCTORS","AVOID_QUOTES","AVOID_EXPLICIT_RETURN_ARROWS","sourceCode","getSourceCode","CTOR_PREFIX_REGEX","isConstructor","name","match","exec","firstChar","charAt","index","toUpperCase","canHaveShorthand","property","kind","isStringLiteral","node","value","isShorthand","shorthand","method","isRedundant","id","getStaticPropertyName","checkConsistency","checkRedundancy","filter","length","shorthandProperties","report","message","canAlwaysUseShorthand","every","makeFunctionShorthand","fixer","firstKeyToken","computed","getFirstToken","isOpeningBracketToken","key","lastKeyToken","getFirstTokenBetween","isClosingBracketToken","getLastToken","keyText","text","slice","range","keyPrefix","commentsExistBetween","async","generator","fixRange","methodPrefix","functionToken","getTokens","find","token","tokenBeforeParams","getTokenAfter","replaceTextRange","arrowToken","getTokenBefore","body","isArrowToken","fnBody","shouldAddParensAroundParameters","params","isOpeningParenToken","hasParen","isTokenOutsideNode","sliceStart","sliceEnd","oldParamText","newParamText","makeFunctionLongform","getTokensBetween","functionHeader","lexicalScopeStack","arrowsWithLexicalIdentifiers","WeakSet","argumentsIdentifiers","enterFunction","unshift","Set","getScope","variables","variable","forEach","references","map","ref","identifier","add","exitFunction","shift","reportLexicalIdentifier","arrowFunction","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","delete","ThisExpression","Super","MetaProperty","Identifier","has","ObjectExpression","isConciseProperty","parent","fix","insertTextAfter","replaceText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-shorthand\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const match = CTOR_PREFIX_REGEX.exec(name);\n\n            // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n            if (!match) {\n                return false;\n            }\n\n            const firstChar = name.charAt(match.index);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         *\n         */\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n         * Checks whether a node is a string literal.\n         * @param   {ASTNode} node Any AST node.\n         * @returns {boolean} `true` if it is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         *\n         */\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         *\n         */\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         *\n         */\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                /*\n                 * If we do not have an equal number of longform properties as\n                 * shorthand properties, we are using the annotations inconsistently\n                 */\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, message: \"Unexpected mix of shorthand and non-shorthand properties.\" });\n                    } else if (checkRedundancy) {\n\n                        /*\n                         * If all properties of the object contain a method or value with a name matching it's key,\n                         * all the keys are redundant.\n                         */\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, message: \"Expected shorthand for all properties.\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a shorthand property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed\n                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)\n                : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed\n                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)\n                : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            // key: /* */ () => {}\n            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n                return null;\n            }\n\n            if (node.value.async) {\n                keyPrefix += \"async \";\n            }\n            if (node.value.generator) {\n                keyPrefix += \"*\";\n            }\n\n            const fixRange = [firstKeyToken.range[0], node.range[1]];\n            const methodPrefix = keyPrefix + keyText;\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    fixRange,\n                    methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n            const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n\n            let shouldAddParensAroundParameters = false;\n            let tokenBeforeParams;\n\n            if (node.value.params.length === 0) {\n                tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n            } else {\n                tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n            }\n\n            if (node.value.params.length === 1) {\n                const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n                const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n\n                shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n            }\n\n            const sliceStart = shouldAddParensAroundParameters\n                ? node.value.params[0].range[0]\n                : tokenBeforeParams.range[0];\n            const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n\n            const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n            const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n\n            return fixer.replaceTextRange(\n                fixRange,\n                methodPrefix + newParamText + fnBody\n            );\n\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a longform property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.async) {\n                functionHeader = `async ${functionHeader}`;\n            }\n            if (node.value.generator) {\n                functionHeader = `${functionHeader}*`;\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n         * Also, this marks all `arguments` identifiers so that they can be detected later.\n         * @returns {void}\n         */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n         * Marks the current function as having a lexical keyword. This implies that all arrow functions\n         * in the current lexical scope contain a reference to this lexical keyword.\n         * @returns {void}\n         */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const message = APPLY_NEVER ? \"Expected longform method syntax.\" : \"Expected longform method syntax for string literal keys.\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            message,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            message: \"Expected longform property syntax.\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            message: \"Expected method shorthand.\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}