{"ast":null,"code":"'use strict';\n\nvar fs = require('fs'),\n    path = require('path');\n\nvar cache;\n/**\n * Perform <code>path.relative()</code> but try to detect and correct sym-linked node modules.\n * @param {string} from The base path\n * @param {string} to The full path\n */\n\nfunction enhancedRelative(from, to) {\n  // relative path\n  var relative = path.relative(from, to); // trailing is the relative path portion without any '../'\n\n  var trailing = relative.replace(/^\\.{2}[\\\\\\/]/, ''),\n      leading = to.replace(trailing, ''); // within project is what we want\n\n  var isInProject = relative === trailing;\n\n  if (isInProject) {\n    return relative;\n  } // otherwise look at symbolic linked modules\n  else {\n      var splitTrailing = trailing.split(/[\\\\\\/]/); // ensure failures can retry with fresh cache\n\n      for (var i = cache ? 2 : 1, foundPath = false; i > 0 && !foundPath; i--) {\n        // ensure cache\n        cache = cache || indexLinkedModules(from); // take elements from the trailing path and append them the the leading path in an attempt to find a package.json\n\n        for (var j = 0; j < splitTrailing.length && !foundPath; j++) {\n          // find the name of packages in the actual file location\n          //  start at the lowest concrete directory that appears in the relative path\n          var packagePath = path.join.apply(path, [leading].concat(splitTrailing.slice(0, j + 1))),\n              packageJsonPath = path.join(packagePath, 'package.json'),\n              packageName = fs.existsSync(packageJsonPath) && require(packageJsonPath).name; // lookup any package name in the cache\n\n\n          var linkedPackagePath = !!packageName && cache[packageName];\n\n          if (linkedPackagePath) {\n            // the remaining portion of the trailing path, not including the package path\n            var remainingPath = path.join.apply(path, splitTrailing.slice(j + 1)); // validate the remaining path in the linked location\n            //  failure implies we will keep trying nested sym-linked packages\n\n            var linkedFilePath = path.join(linkedPackagePath, remainingPath),\n                isValid = !!linkedFilePath && fs.existsSync(linkedFilePath) && fs.statSync(linkedFilePath).isFile(); // path is found where valid\n\n            foundPath = isValid && linkedFilePath;\n          }\n        } // cache cannot be trusted if a file can't be found\n        //  set the cache to false to trigger its rebuild\n\n\n        cache = !!foundPath && cache;\n      } // the relative path should now be within the project\n\n\n      return foundPath ? path.relative(from, foundPath) : relative;\n    }\n}\n\nmodule.exports = enhancedRelative;\n/**\n * Make a hash of linked modules within the given directory by breadth-first search.\n * @param {string} directory A path to start searching\n * @returns {object} A collection of sym-linked paths within the project keyed by their package name\n */\n\nfunction indexLinkedModules(directory) {\n  var buffer = listSymLinkedModules(directory),\n      hash = {}; // while there are items in the buffer\n\n  while (buffer.length > 0) {\n    var modulePath = buffer.shift(),\n        packageJsonPath = path.join(modulePath, 'package.json'),\n        packageName = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n\n    if (packageName) {\n      // add this path keyed by package name, so long as it doesn't exist at a lower level\n      hash[packageName] = hash[packageName] || modulePath; // detect nested module and push to the buffer (breadth-first)\n\n      buffer.push.apply(buffer, listSymLinkedModules(modulePath));\n    }\n  }\n\n  return hash;\n\n  function listSymLinkedModules(directory) {\n    var modulesPath = path.join(directory, 'node_modules'),\n        hasNodeModules = fs.existsSync(modulesPath) && fs.statSync(modulesPath).isDirectory(),\n        subdirectories = !!hasNodeModules && fs.readdirSync(modulesPath) || [];\n    return subdirectories.map(joinDirectory).filter(testIsSymLink);\n\n    function joinDirectory(subdirectory) {\n      return path.join(modulesPath, subdirectory);\n    }\n\n    function testIsSymLink(directory) {\n      return fs.lstatSync(directory).isSymbolicLink(); // must use lstatSync not statSync\n    }\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/adjust-sourcemap-loader/codec/utility/enhanced-relative.js"],"names":["fs","require","path","cache","enhancedRelative","from","to","relative","trailing","replace","leading","isInProject","splitTrailing","split","i","foundPath","indexLinkedModules","j","length","packagePath","join","apply","concat","slice","packageJsonPath","packageName","existsSync","name","linkedPackagePath","remainingPath","linkedFilePath","isValid","statSync","isFile","module","exports","directory","buffer","listSymLinkedModules","hash","modulePath","shift","push","modulesPath","hasNodeModules","isDirectory","subdirectories","readdirSync","map","joinDirectory","filter","testIsSymLink","subdirectory","lstatSync","isSymbolicLink"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs   = require('fs'),\n    path = require('path');\n\nvar cache;\n\n/**\n * Perform <code>path.relative()</code> but try to detect and correct sym-linked node modules.\n * @param {string} from The base path\n * @param {string} to The full path\n */\nfunction enhancedRelative(from, to) {\n\n  // relative path\n  var relative = path.relative(from, to);\n\n  // trailing is the relative path portion without any '../'\n  var trailing = relative.replace(/^\\.{2}[\\\\\\/]/, ''),\n      leading  = to.replace(trailing, '');\n\n  // within project is what we want\n  var isInProject = (relative === trailing);\n  if (isInProject) {\n    return relative;\n  }\n  // otherwise look at symbolic linked modules\n  else {\n    var splitTrailing = trailing.split(/[\\\\\\/]/);\n\n    // ensure failures can retry with fresh cache\n    for (var i = cache ? 2 : 1, foundPath = false; (i > 0) && !foundPath; i--) {\n\n      // ensure cache\n      cache = cache || indexLinkedModules(from);\n\n      // take elements from the trailing path and append them the the leading path in an attempt to find a package.json\n      for (var j = 0; (j < splitTrailing.length) && !foundPath; j++) {\n\n        // find the name of packages in the actual file location\n        //  start at the lowest concrete directory that appears in the relative path\n        var packagePath     = path.join.apply(path, [leading].concat(splitTrailing.slice(0, j + 1))),\n            packageJsonPath = path.join(packagePath, 'package.json'),\n            packageName     = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n\n        // lookup any package name in the cache\n        var linkedPackagePath = !!packageName && cache[packageName];\n        if (linkedPackagePath) {\n\n          // the remaining portion of the trailing path, not including the package path\n          var remainingPath = path.join.apply(path, splitTrailing.slice(j + 1));\n\n          // validate the remaining path in the linked location\n          //  failure implies we will keep trying nested sym-linked packages\n          var linkedFilePath = path.join(linkedPackagePath, remainingPath),\n              isValid        = !!linkedFilePath && fs.existsSync(linkedFilePath) &&\n                fs.statSync(linkedFilePath).isFile();\n\n          // path is found where valid\n          foundPath = isValid && linkedFilePath;\n        }\n      }\n\n      // cache cannot be trusted if a file can't be found\n      //  set the cache to false to trigger its rebuild\n      cache = !!foundPath && cache;\n    }\n\n    // the relative path should now be within the project\n    return foundPath ? path.relative(from, foundPath) : relative;\n  }\n}\n\nmodule.exports = enhancedRelative;\n\n/**\n * Make a hash of linked modules within the given directory by breadth-first search.\n * @param {string} directory A path to start searching\n * @returns {object} A collection of sym-linked paths within the project keyed by their package name\n */\nfunction indexLinkedModules(directory) {\n  var buffer = listSymLinkedModules(directory),\n      hash   = {};\n\n  // while there are items in the buffer\n  while (buffer.length > 0) {\n    var modulePath      = buffer.shift(),\n        packageJsonPath = path.join(modulePath, 'package.json'),\n        packageName     = fs.existsSync(packageJsonPath) && require(packageJsonPath).name;\n    if (packageName) {\n\n      // add this path keyed by package name, so long as it doesn't exist at a lower level\n      hash[packageName] = hash[packageName] || modulePath;\n\n      // detect nested module and push to the buffer (breadth-first)\n      buffer.push.apply(buffer, listSymLinkedModules(modulePath));\n    }\n  }\n  return hash;\n\n  function listSymLinkedModules(directory) {\n    var modulesPath    = path.join(directory, 'node_modules'),\n        hasNodeModules = fs.existsSync(modulesPath) && fs.statSync(modulesPath).isDirectory(),\n        subdirectories = !!hasNodeModules && fs.readdirSync(modulesPath) || [];\n\n    return subdirectories\n      .map(joinDirectory)\n      .filter(testIsSymLink);\n\n    function joinDirectory(subdirectory) {\n      return path.join(modulesPath, subdirectory);\n    }\n\n    function testIsSymLink(directory) {\n      return fs.lstatSync(directory).isSymbolicLink();  // must use lstatSync not statSync\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}