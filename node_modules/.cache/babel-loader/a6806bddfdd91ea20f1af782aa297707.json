{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _os = _interopRequireDefault(require(\"os\"));\n\nvar _pLimit = _interopRequireDefault(require(\"p-limit\"));\n\nvar _jestWorker = _interopRequireDefault(require(\"jest-worker\"));\n\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\n\nvar _minify = _interopRequireDefault(require(\"./minify\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst workerPath = require.resolve('./worker');\n\nclass TaskRunner {\n  constructor(options = {}) {\n    this.taskGenerator = options.taskGenerator;\n    this.files = options.files;\n    this.cache = options.cache;\n    this.availableNumberOfCores = TaskRunner.getAvailableNumberOfCores(options.parallel);\n  }\n\n  static getAvailableNumberOfCores(parallel) {\n    // In some cases cpus() returns undefined\n    // https://github.com/nodejs/node/issues/19022\n    const cpus = _os.default.cpus() || {\n      length: 1\n    };\n    return parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1);\n  }\n\n  async runTask(task) {\n    if (this.worker) {\n      return this.worker.transform((0, _serializeJavascript.default)(task));\n    }\n\n    return (0, _minify.default)(task);\n  }\n\n  async run() {\n    const {\n      availableNumberOfCores,\n      cache,\n      files,\n      taskGenerator\n    } = this;\n    let concurrency = Infinity;\n\n    if (availableNumberOfCores > 0) {\n      // Do not create unnecessary workers when the number of files is less than the available cores, it saves memory\n      const numWorkers = Math.min(files.length, availableNumberOfCores);\n      concurrency = numWorkers;\n      this.worker = new _jestWorker.default(workerPath, {\n        numWorkers\n      }); // https://github.com/facebook/jest/issues/8872#issuecomment-524822081\n\n      const workerStdout = this.worker.getStdout();\n\n      if (workerStdout) {\n        workerStdout.on('data', chunk => {\n          return process.stdout.write(chunk);\n        });\n      }\n\n      const workerStderr = this.worker.getStderr();\n\n      if (workerStderr) {\n        workerStderr.on('data', chunk => {\n          return process.stderr.write(chunk);\n        });\n      }\n    }\n\n    const limit = (0, _pLimit.default)(concurrency);\n    const scheduledTasks = [];\n\n    for (const file of files) {\n      const enqueue = async task => {\n        let taskResult;\n\n        try {\n          taskResult = await this.runTask(task);\n        } catch (error) {\n          taskResult = {\n            error\n          };\n        }\n\n        if (cache.isEnabled() && !taskResult.error) {\n          taskResult = await cache.store(task, taskResult).then(() => taskResult, () => taskResult);\n        }\n\n        task.callback(taskResult);\n        return taskResult;\n      };\n\n      scheduledTasks.push(limit(() => {\n        const task = taskGenerator(file).next().value;\n\n        if (!task) {\n          // Something went wrong, for example the `cacheKeys` option throw an error\n          return Promise.resolve();\n        }\n\n        if (cache.isEnabled()) {\n          return cache.get(task).then(taskResult => task.callback(taskResult), () => enqueue(task));\n        }\n\n        return enqueue(task);\n      }));\n    }\n\n    return Promise.all(scheduledTasks);\n  }\n\n  async exit() {\n    if (!this.worker) {\n      return Promise.resolve();\n    }\n\n    return this.worker.end();\n  }\n\n}\n\nexports.default = TaskRunner;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/terser-webpack-plugin/dist/TaskRunner.js"],"names":["Object","defineProperty","exports","value","default","_os","_interopRequireDefault","require","_pLimit","_jestWorker","_serializeJavascript","_minify","obj","__esModule","workerPath","resolve","TaskRunner","constructor","options","taskGenerator","files","cache","availableNumberOfCores","getAvailableNumberOfCores","parallel","cpus","length","Math","min","Number","runTask","task","worker","transform","run","concurrency","Infinity","numWorkers","workerStdout","getStdout","on","chunk","process","stdout","write","workerStderr","getStderr","stderr","limit","scheduledTasks","file","enqueue","taskResult","error","isEnabled","store","then","callback","push","next","Promise","get","all","exit","end"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _os = _interopRequireDefault(require(\"os\"));\n\nvar _pLimit = _interopRequireDefault(require(\"p-limit\"));\n\nvar _jestWorker = _interopRequireDefault(require(\"jest-worker\"));\n\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\n\nvar _minify = _interopRequireDefault(require(\"./minify\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst workerPath = require.resolve('./worker');\n\nclass TaskRunner {\n  constructor(options = {}) {\n    this.taskGenerator = options.taskGenerator;\n    this.files = options.files;\n    this.cache = options.cache;\n    this.availableNumberOfCores = TaskRunner.getAvailableNumberOfCores(options.parallel);\n  }\n\n  static getAvailableNumberOfCores(parallel) {\n    // In some cases cpus() returns undefined\n    // https://github.com/nodejs/node/issues/19022\n    const cpus = _os.default.cpus() || {\n      length: 1\n    };\n    return parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1);\n  }\n\n  async runTask(task) {\n    if (this.worker) {\n      return this.worker.transform((0, _serializeJavascript.default)(task));\n    }\n\n    return (0, _minify.default)(task);\n  }\n\n  async run() {\n    const {\n      availableNumberOfCores,\n      cache,\n      files,\n      taskGenerator\n    } = this;\n    let concurrency = Infinity;\n\n    if (availableNumberOfCores > 0) {\n      // Do not create unnecessary workers when the number of files is less than the available cores, it saves memory\n      const numWorkers = Math.min(files.length, availableNumberOfCores);\n      concurrency = numWorkers;\n      this.worker = new _jestWorker.default(workerPath, {\n        numWorkers\n      }); // https://github.com/facebook/jest/issues/8872#issuecomment-524822081\n\n      const workerStdout = this.worker.getStdout();\n\n      if (workerStdout) {\n        workerStdout.on('data', chunk => {\n          return process.stdout.write(chunk);\n        });\n      }\n\n      const workerStderr = this.worker.getStderr();\n\n      if (workerStderr) {\n        workerStderr.on('data', chunk => {\n          return process.stderr.write(chunk);\n        });\n      }\n    }\n\n    const limit = (0, _pLimit.default)(concurrency);\n    const scheduledTasks = [];\n\n    for (const file of files) {\n      const enqueue = async task => {\n        let taskResult;\n\n        try {\n          taskResult = await this.runTask(task);\n        } catch (error) {\n          taskResult = {\n            error\n          };\n        }\n\n        if (cache.isEnabled() && !taskResult.error) {\n          taskResult = await cache.store(task, taskResult).then(() => taskResult, () => taskResult);\n        }\n\n        task.callback(taskResult);\n        return taskResult;\n      };\n\n      scheduledTasks.push(limit(() => {\n        const task = taskGenerator(file).next().value;\n\n        if (!task) {\n          // Something went wrong, for example the `cacheKeys` option throw an error\n          return Promise.resolve();\n        }\n\n        if (cache.isEnabled()) {\n          return cache.get(task).then(taskResult => task.callback(taskResult), () => enqueue(task));\n        }\n\n        return enqueue(task);\n      }));\n    }\n\n    return Promise.all(scheduledTasks);\n  }\n\n  async exit() {\n    if (!this.worker) {\n      return Promise.resolve();\n    }\n\n    return this.worker.end();\n  }\n\n}\n\nexports.default = TaskRunner;"]},"metadata":{},"sourceType":"script"}