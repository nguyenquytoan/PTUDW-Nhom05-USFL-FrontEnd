{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent brace style for all control statements\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/curly\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n        }, {\n          enum: [\"consistent\"]\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      missingCurlyAfter: \"Expected { after '{{name}}'.\",\n      missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n      unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n      unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n    }\n  },\n\n  create(context) {\n    const multiOnly = context.options[0] === \"multi\";\n    const multiLine = context.options[0] === \"multi-line\";\n    const multiOrNest = context.options[0] === \"multi-or-nest\";\n    const consistent = context.options[1] === \"consistent\";\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n     * @private\n     */\n\n    function isCollapsedOneLiner(node) {\n      const before = sourceCode.getTokenBefore(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n    /**\n     * Determines if a given node is a one-liner.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} True if the node is a one-liner.\n     * @private\n     */\n\n\n    function isOneLiner(node) {\n      if (node.type === \"EmptyStatement\") {\n        return true;\n      }\n\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n    /**\n     * Determines if the given node is a lexical declaration (let, const, function, or class)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} True if the node is a lexical declaration\n     * @private\n     */\n\n\n    function isLexicalDeclaration(node) {\n      if (node.type === \"VariableDeclaration\") {\n        return node.kind === \"const\" || node.kind === \"let\";\n      }\n\n      return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n    }\n    /**\n     * Checks if the given token is an `else` token or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if the token is an `else` token.\n     */\n\n\n    function isElseKeywordToken(token) {\n      return token.value === \"else\" && token.type === \"Keyword\";\n    }\n    /**\n     * Gets the `else` keyword token of a given `IfStatement` node.\n     * @param {ASTNode} node A `IfStatement` node to get.\n     * @returns {Token} The `else` keyword token.\n     */\n\n\n    function getElseKeyword(node) {\n      return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);\n    }\n    /**\n     * Checks a given IfStatement node requires braces of the consequent chunk.\n     * This returns `true` when below:\n     *\n     * 1. The given node has the `alternate` node.\n     * 2. There is a `IfStatement` which doesn't have `alternate` node in the\n     *    trailing statement chain of the `consequent` node.\n     * @param {ASTNode} node A IfStatement node to check.\n     * @returns {boolean} `true` if the node requires braces of the consequent chunk.\n     */\n\n\n    function requiresBraceOfConsequent(node) {\n      if (node.alternate && node.consequent.type === \"BlockStatement\") {\n        if (node.consequent.body.length >= 2) {\n          return true;\n        }\n\n        for (let currentNode = node.consequent.body[0]; currentNode; currentNode = astUtils.getTrailingStatement(currentNode)) {\n          if (currentNode.type === \"IfStatement\" && !currentNode.alternate) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n     * @param {Token} closingBracket The } token\n     * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n     */\n\n\n    function needsSemicolon(closingBracket) {\n      const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n      const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n      if (astUtils.isSemicolonToken(tokenBefore)) {\n        // If the last statement already has a semicolon, don't add another one.\n        return false;\n      }\n\n      if (!tokenAfter) {\n        // If there are no statements after this block, there is no need to add a semicolon.\n        return false;\n      }\n\n      if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n        /*\n         * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n         * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n         * a SyntaxError if it was followed by `else`.\n         */\n        return false;\n      }\n\n      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n        // If the next token is on the same line, insert a semicolon.\n        return true;\n      }\n\n      if (/^[([/`+-]/u.test(tokenAfter.value)) {\n        // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n        return true;\n      }\n\n      if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n        // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n        return true;\n      } // Otherwise, do not insert a semicolon.\n\n\n      return false;\n    }\n    /**\n     * Prepares to check the body of a node to see if it's a block statement.\n     * @param {ASTNode} node The node to report if there's a problem.\n     * @param {ASTNode} body The body node to check for blocks.\n     * @param {string} name The name to report if there's a problem.\n     * @param {{ condition: boolean }} opts Options to pass to the report functions\n     * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n     *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n     *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n     *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n     *   the final behavior of \"check\".\n     *   \"check\" will be a function reporting appropriate problems depending on the other\n     *   properties.\n     */\n\n\n    function prepareCheck(node, body, name, opts) {\n      const hasBlock = body.type === \"BlockStatement\";\n      let expected = null;\n\n      if (node.type === \"IfStatement\" && node.consequent === body && requiresBraceOfConsequent(node)) {\n        expected = true;\n      } else if (multiOnly) {\n        if (hasBlock && body.body.length === 1 && !isLexicalDeclaration(body.body[0])) {\n          expected = false;\n        }\n      } else if (multiLine) {\n        if (!isCollapsedOneLiner(body)) {\n          expected = true;\n        }\n      } else if (multiOrNest) {\n        if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {\n          const leadingComments = sourceCode.getCommentsBefore(body.body[0]);\n          const isLexDef = isLexicalDeclaration(body.body[0]);\n\n          if (isLexDef) {\n            expected = true;\n          } else {\n            expected = leadingComments.length > 0;\n          }\n        } else if (!isOneLiner(body)) {\n          expected = true;\n        }\n      } else {\n        expected = true;\n      }\n\n      return {\n        actual: hasBlock,\n        expected,\n\n        check() {\n          if (this.expected !== null && this.expected !== this.actual) {\n            if (this.expected) {\n              context.report({\n                node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                data: {\n                  name\n                },\n                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n              });\n            } else {\n              context.report({\n                node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                data: {\n                  name\n                },\n\n                fix(fixer) {\n                  /*\n                   * `do while` expressions sometimes need a space to be inserted after `do`.\n                   * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                   */\n                  const needsPrecedingSpace = node.type === \"DoWhileStatement\" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, {\n                    skip: 1\n                  }));\n                  const openingBracket = sourceCode.getFirstToken(body);\n                  const closingBracket = sourceCode.getLastToken(body);\n                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                  if (needsSemicolon(closingBracket)) {\n                    /*\n                     * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                     * change the semantics of the code due to ASI), don't perform a fix.\n                     */\n                    return null;\n                  }\n\n                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n                  return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n\n              });\n            }\n          }\n        }\n\n      };\n    }\n    /**\n     * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n     * @param {ASTNode} node The first IfStatement node of the chain.\n     * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n     *   information.\n     */\n\n\n    function prepareIfChecks(node) {\n      const preparedChecks = [];\n\n      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", {\n          condition: true\n        }));\n\n        if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n          break;\n        }\n      }\n\n      if (consistent) {\n        /*\n         * If any node should have or already have braces, make sure they\n         * all have braces.\n         * If all nodes shouldn't have braces, make sure they don't.\n         */\n        const expected = preparedChecks.some(preparedCheck => {\n          if (preparedCheck.expected !== null) {\n            return preparedCheck.expected;\n          }\n\n          return preparedCheck.actual;\n        });\n        preparedChecks.forEach(preparedCheck => {\n          preparedCheck.expected = expected;\n        });\n      }\n\n      return preparedChecks;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      IfStatement(node) {\n        if (node.parent.type !== \"IfStatement\") {\n          prepareIfChecks(node).forEach(preparedCheck => {\n            preparedCheck.check();\n          });\n        }\n      },\n\n      WhileStatement(node) {\n        prepareCheck(node, node.body, \"while\", {\n          condition: true\n        }).check();\n      },\n\n      DoWhileStatement(node) {\n        prepareCheck(node, node.body, \"do\").check();\n      },\n\n      ForStatement(node) {\n        prepareCheck(node, node.body, \"for\", {\n          condition: true\n        }).check();\n      },\n\n      ForInStatement(node) {\n        prepareCheck(node, node.body, \"for-in\").check();\n      },\n\n      ForOfStatement(node) {\n        prepareCheck(node, node.body, \"for-of\").check();\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/curly.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","fixable","messages","missingCurlyAfter","missingCurlyAfterCondition","unexpectedCurlyAfter","unexpectedCurlyAfterCondition","create","context","multiOnly","options","multiLine","multiOrNest","consistent","sourceCode","getSourceCode","isCollapsedOneLiner","node","before","getTokenBefore","last","getLastToken","lastExcludingSemicolon","isSemicolonToken","loc","start","line","end","isOneLiner","first","getFirstToken","isLexicalDeclaration","kind","isElseKeywordToken","token","value","getElseKeyword","alternate","getFirstTokenBetween","consequent","requiresBraceOfConsequent","body","length","currentNode","getTrailingStatement","needsSemicolon","closingBracket","tokenBefore","tokenAfter","getTokenAfter","lastBlockNode","getNodeByRangeIndex","range","parent","test","prepareCheck","name","opts","hasBlock","expected","leadingComments","getCommentsBefore","isLexDef","actual","check","report","messageId","condition","data","fix","fixer","replaceText","getText","needsPrecedingSpace","canTokensBeAdjacent","skip","openingBracket","lastTokenInBlock","resultingBodyText","slice","prepareIfChecks","preparedChecks","push","some","preparedCheck","forEach","IfStatement","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/curly\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            missingCurlyAfter: \"Expected { after '{{name}}'.\",\n            missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n            unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n            unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n        }\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            if (node.type === \"EmptyStatement\") {\n                return true;\n            }\n\n            const first = sourceCode.getFirstToken(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if the given node is a lexical declaration (let, const, function, or class)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lexical declaration\n         * @private\n         */\n        function isLexicalDeclaration(node) {\n            if (node.type === \"VariableDeclaration\") {\n                return node.kind === \"const\" || node.kind === \"let\";\n            }\n\n            return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Gets the `else` keyword token of a given `IfStatement` node.\n         * @param {ASTNode} node A `IfStatement` node to get.\n         * @returns {Token} The `else` keyword token.\n         */\n        function getElseKeyword(node) {\n            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);\n        }\n\n        /**\n         * Checks a given IfStatement node requires braces of the consequent chunk.\n         * This returns `true` when below:\n         *\n         * 1. The given node has the `alternate` node.\n         * 2. There is a `IfStatement` which doesn't have `alternate` node in the\n         *    trailing statement chain of the `consequent` node.\n         * @param {ASTNode} node A IfStatement node to check.\n         * @returns {boolean} `true` if the node requires braces of the consequent chunk.\n         */\n        function requiresBraceOfConsequent(node) {\n            if (node.alternate && node.consequent.type === \"BlockStatement\") {\n                if (node.consequent.body.length >= 2) {\n                    return true;\n                }\n\n                for (\n                    let currentNode = node.consequent.body[0];\n                    currentNode;\n                    currentNode = astUtils.getTrailingStatement(currentNode)\n                ) {\n                    if (currentNode.type === \"IfStatement\" && !currentNode.alternate) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n         * @param {Token} closingBracket The } token\n         * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n         */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                /*\n                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                 * a SyntaxError if it was followed by `else`.\n                 */\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/u.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {{ condition: boolean }} opts Options to pass to the report functions\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, opts) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (node.type === \"IfStatement\" && node.consequent === body && requiresBraceOfConsequent(node)) {\n                expected = true;\n            } else if (multiOnly) {\n                if (hasBlock && body.body.length === 1 && !isLexicalDeclaration(body.body[0])) {\n                    expected = false;\n                }\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n            } else if (multiOrNest) {\n                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {\n                    const leadingComments = sourceCode.getCommentsBefore(body.body[0]);\n                    const isLexDef = isLexicalDeclaration(body.body[0]);\n\n                    if (isLexDef) {\n                        expected = true;\n                    } else {\n                        expected = leadingComments.length > 0;\n                    }\n                } else if (!isOneLiner(body)) {\n                    expected = true;\n                }\n            } else {\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            context.report({\n                                node,\n                                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n                            });\n                        } else {\n                            context.report({\n                                node,\n                                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix(fixer) {\n\n                                    /*\n                                     * `do while` expressions sometimes need a space to be inserted after `do`.\n                                     * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                                     */\n                                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));\n\n                                    const openingBracket = sourceCode.getFirstToken(body);\n                                    const closingBracket = sourceCode.getLastToken(body);\n                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                                    if (needsSemicolon(closingBracket)) {\n\n                                        /*\n                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                                         * change the semantics of the code due to ASI), don't perform a fix.\n                                         */\n                                        return null;\n                                    }\n\n                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                                        sourceCode.getText(lastTokenInBlock) +\n                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                                    return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                                }\n                            });\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));\n                if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n                    break;\n                }\n            }\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", { condition: true }).check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", { condition: true }).check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}