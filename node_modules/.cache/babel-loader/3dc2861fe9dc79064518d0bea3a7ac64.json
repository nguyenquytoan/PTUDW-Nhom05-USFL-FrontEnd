{"ast":null,"code":"/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  findVariable\n} = require(\"eslint-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\n\n\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\n\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n    },\n    schema: [],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\"\n    }\n  },\n\n  create(context) {\n    /**\n     * Determines whether the given identifier node is a reference to a global variable.\n     * @param {ASTNode} node `Identifier` node to check.\n     * @returns {boolean} True if the identifier is a reference to a global variable.\n     */\n    function isGlobalReference(node) {\n      const scope = context.getScope();\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n    /**\n     * Determines whether the given node is a String.raw`` tagged template expression\n     * with a static template literal.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is String.raw`` with a static template.\n     */\n\n\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"MemberExpression\" && node.tag.object.type === \"Identifier\" && node.tag.object.name === \"String\" && isGlobalReference(node.tag.object) && astUtils.getStaticPropertyName(node.tag) === \"raw\" && isStaticTemplateLiteral(node.quasi);\n    }\n    /**\n     * Determines whether the given node is considered to be a static string by the logic of this rule.\n     * @param {ASTNode} node Node to check.\n     * @returns {boolean} True if the node is a static string.\n     */\n\n\n    function isStaticString(node) {\n      return isStringLiteral(node) || isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const args = node.arguments;\n\n          if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n            context.report({\n              node,\n              messageId: \"unexpectedRegExp\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-regex-literals.js"],"names":["astUtils","require","CALL","CONSTRUCT","ReferenceTracker","findVariable","isStringLiteral","node","type","value","isStaticTemplateLiteral","expressions","length","module","exports","meta","docs","description","category","recommended","url","schema","messages","unexpectedRegExp","create","context","isGlobalReference","scope","getScope","variable","defs","isStringRawTaggedStaticTemplateLiteral","tag","object","name","getStaticPropertyName","quasi","isStaticString","Program","tracker","traceMap","RegExp","iterateGlobalReferences","args","arguments","every","report","messageId"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = context.getScope();\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                node.tag.type === \"MemberExpression\" &&\n                node.tag.object.type === \"Identifier\" &&\n                node.tag.object.name === \"String\" &&\n                isGlobalReference(node.tag.object) &&\n                astUtils.getStaticPropertyName(node.tag) === \"raw\" &&\n                isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    const args = node.arguments;\n\n                    if (\n                        (args.length === 1 || args.length === 2) &&\n                        args.every(isStaticString)\n                    ) {\n                        context.report({ node, messageId: \"unexpectedRegExp\" });\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}