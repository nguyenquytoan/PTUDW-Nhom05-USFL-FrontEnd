{"ast":null,"code":"/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst path = require(\"path\");\n\nconst ignore = require(\"ignore\");\n\nconst debug = require(\"debug\")(\"eslint:ignore-pattern\");\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\n\n\nfunction getCommonAncestorPath(sourcePaths) {\n  let result = sourcePaths[0];\n\n  for (let i = 1; i < sourcePaths.length; ++i) {\n    const a = result;\n    const b = sourcePaths[i]; // Set the shorter one (it's the common ancestor if one includes the other).\n\n    result = a.length < b.length ? a : b; // Set the common ancestor.\n\n    for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n      if (a[j] !== b[j]) {\n        result = a.slice(0, lastSepPos);\n        break;\n      }\n\n      if (a[j] === path.sep) {\n        lastSepPos = j;\n      }\n    }\n  }\n\n  return result || path.sep;\n}\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\n\n\nfunction relative(from, to) {\n  const relPath = path.relative(from, to);\n\n  if (path.sep === \"/\") {\n    return relPath;\n  }\n\n  return relPath.split(path.sep).join(\"/\");\n}\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\n\n\nfunction dirSuffix(filePath) {\n  const isDir = filePath.endsWith(path.sep) || process.platform === \"win32\" && filePath.endsWith(\"/\");\n  return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/node_modules/*\", \"/bower_components/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!../\"]); //------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n  /**\n   * The default patterns.\n   * @type {string[]}\n   */\n  static get DefaultPatterns() {\n    return DefaultPatterns;\n  }\n  /**\n   * Create the default predicate function.\n   * @param {string} cwd The current working directory.\n   * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n   * The preficate function.\n   * The first argument is an absolute path that is checked.\n   * The second argument is the flag to not ignore dotfiles.\n   * If the predicate function returned `true`, it means the path should be ignored.\n   */\n\n\n  static createDefaultIgnore(cwd) {\n    return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n  }\n  /**\n   * Create the predicate function from multiple `IgnorePattern` objects.\n   * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n   * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n   * The preficate function.\n   * The first argument is an absolute path that is checked.\n   * The second argument is the flag to not ignore dotfiles.\n   * If the predicate function returned `true`, it means the path should be ignored.\n   */\n\n\n  static createIgnore(ignorePatterns) {\n    debug(\"Create with: %o\", ignorePatterns);\n    const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n    const patterns = [].concat(...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath)));\n    const ig = ignore().add([...DotPatterns, ...patterns]);\n    const dotIg = ignore().add(patterns);\n    debug(\"  processed: %o\", {\n      basePath,\n      patterns\n    });\n    return Object.assign((filePath, dot = false) => {\n      assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n      const relPathRaw = relative(basePath, filePath);\n      const relPath = relPathRaw && relPathRaw + dirSuffix(filePath);\n      const adoptedIg = dot ? dotIg : ig;\n      const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n      debug(\"Check\", {\n        filePath,\n        dot,\n        relativePath: relPath,\n        result\n      });\n      return result;\n    }, {\n      basePath,\n      patterns\n    });\n  }\n  /**\n   * Initialize a new `IgnorePattern` instance.\n   * @param {string[]} patterns The glob patterns that ignore to lint.\n   * @param {string} basePath The base path of `patterns`.\n   */\n\n\n  constructor(patterns, basePath) {\n    assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n    /**\n     * The glob patterns that ignore to lint.\n     * @type {string[]}\n     */\n\n    this.patterns = patterns;\n    /**\n     * The base path of `patterns`.\n     * @type {string}\n     */\n\n    this.basePath = basePath;\n    /**\n     * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n     *\n     * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n     * It's `false` as-is for `ignorePatterns` property in config files.\n     * @type {boolean}\n     */\n\n    this.loose = false;\n  }\n  /**\n   * Get `patterns` as modified for a given base path. It modifies the\n   * absolute paths in the patterns as prepending the difference of two base\n   * paths.\n   * @param {string} newBasePath The base path.\n   * @returns {string[]} Modifired patterns.\n   */\n\n\n  getPatternsRelativeTo(newBasePath) {\n    assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n    const {\n      basePath,\n      loose,\n      patterns\n    } = this;\n\n    if (newBasePath === basePath) {\n      return patterns;\n    }\n\n    const prefix = `/${relative(newBasePath, basePath)}`;\n    return patterns.map(pattern => {\n      const negative = pattern.startsWith(\"!\");\n      const head = negative ? \"!\" : \"\";\n      const body = negative ? pattern.slice(1) : pattern;\n\n      if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n        return `${head}${prefix}${body}`;\n      }\n\n      return loose ? pattern : `${head}${prefix}/**/${body}`;\n    });\n  }\n\n}\n\nmodule.exports = {\n  IgnorePattern\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/cli-engine/config-array/ignore-pattern.js"],"names":["assert","require","path","ignore","debug","getCommonAncestorPath","sourcePaths","result","i","length","a","b","j","lastSepPos","slice","sep","relative","from","to","relPath","split","join","dirSuffix","filePath","isDir","endsWith","process","platform","DefaultPatterns","Object","freeze","DotPatterns","IgnorePattern","createDefaultIgnore","cwd","createIgnore","ignorePatterns","basePath","map","p","patterns","concat","getPatternsRelativeTo","ig","add","dotIg","assign","dot","isAbsolute","relPathRaw","adoptedIg","ignores","relativePath","constructor","loose","newBasePath","prefix","pattern","negative","startsWith","head","body","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst path = require(\"path\");\nconst ignore = require(\"ignore\");\nconst debug = require(\"debug\")(\"eslint:ignore-pattern\");\n\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\nfunction getCommonAncestorPath(sourcePaths) {\n    let result = sourcePaths[0];\n\n    for (let i = 1; i < sourcePaths.length; ++i) {\n        const a = result;\n        const b = sourcePaths[i];\n\n        // Set the shorter one (it's the common ancestor if one includes the other).\n        result = a.length < b.length ? a : b;\n\n        // Set the common ancestor.\n        for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n            if (a[j] !== b[j]) {\n                result = a.slice(0, lastSepPos);\n                break;\n            }\n            if (a[j] === path.sep) {\n                lastSepPos = j;\n            }\n        }\n    }\n\n    return result || path.sep;\n}\n\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\nfunction relative(from, to) {\n    const relPath = path.relative(from, to);\n\n    if (path.sep === \"/\") {\n        return relPath;\n    }\n    return relPath.split(path.sep).join(\"/\");\n}\n\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\nfunction dirSuffix(filePath) {\n    const isDir = (\n        filePath.endsWith(path.sep) ||\n        (process.platform === \"win32\" && filePath.endsWith(\"/\"))\n    );\n\n    return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/node_modules/*\", \"/bower_components/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!../\"]);\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n\n    /**\n     * The default patterns.\n     * @type {string[]}\n     */\n    static get DefaultPatterns() {\n        return DefaultPatterns;\n    }\n\n    /**\n     * Create the default predicate function.\n     * @param {string} cwd The current working directory.\n     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createDefaultIgnore(cwd) {\n        return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n    }\n\n    /**\n     * Create the predicate function from multiple `IgnorePattern` objects.\n     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createIgnore(ignorePatterns) {\n        debug(\"Create with: %o\", ignorePatterns);\n\n        const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n        const patterns = [].concat(\n            ...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath))\n        );\n        const ig = ignore().add([...DotPatterns, ...patterns]);\n        const dotIg = ignore().add(patterns);\n\n        debug(\"  processed: %o\", { basePath, patterns });\n\n        return Object.assign(\n            (filePath, dot = false) => {\n                assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n                const relPathRaw = relative(basePath, filePath);\n                const relPath = relPathRaw && (relPathRaw + dirSuffix(filePath));\n                const adoptedIg = dot ? dotIg : ig;\n                const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n\n                debug(\"Check\", { filePath, dot, relativePath: relPath, result });\n                return result;\n            },\n            { basePath, patterns }\n        );\n    }\n\n    /**\n     * Initialize a new `IgnorePattern` instance.\n     * @param {string[]} patterns The glob patterns that ignore to lint.\n     * @param {string} basePath The base path of `patterns`.\n     */\n    constructor(patterns, basePath) {\n        assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {string[]}\n         */\n        this.patterns = patterns;\n\n        /**\n         * The base path of `patterns`.\n         * @type {string}\n         */\n        this.basePath = basePath;\n\n        /**\n         * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n         *\n         * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n         * It's `false` as-is for `ignorePatterns` property in config files.\n         * @type {boolean}\n         */\n        this.loose = false;\n    }\n\n    /**\n     * Get `patterns` as modified for a given base path. It modifies the\n     * absolute paths in the patterns as prepending the difference of two base\n     * paths.\n     * @param {string} newBasePath The base path.\n     * @returns {string[]} Modifired patterns.\n     */\n    getPatternsRelativeTo(newBasePath) {\n        assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n        const { basePath, loose, patterns } = this;\n\n        if (newBasePath === basePath) {\n            return patterns;\n        }\n        const prefix = `/${relative(newBasePath, basePath)}`;\n\n        return patterns.map(pattern => {\n            const negative = pattern.startsWith(\"!\");\n            const head = negative ? \"!\" : \"\";\n            const body = negative ? pattern.slice(1) : pattern;\n\n            if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n                return `${head}${prefix}${body}`;\n            }\n            return loose ? pattern : `${head}${prefix}/**/${body}`;\n        });\n    }\n}\n\nmodule.exports = { IgnorePattern };\n"]},"metadata":{},"sourceType":"script"}