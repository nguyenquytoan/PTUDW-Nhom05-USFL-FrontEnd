{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { createHeaders } from './utils/createHeaders.mjs';\nimport { concatenateToResponse } from './concatenateToResponse.mjs';\nimport { isSupported } from './isSupported.mjs';\nimport './_version.mjs';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {\n *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n * Each function should return a {@link workbox.streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {workbox.routing.Route~handlerCallback}\n *\n * @memberof workbox.streams\n */\n\nexport function strategy(sourceFunctions, headersInit) {\n  return async ({\n    event,\n    url,\n    params\n  }) => {\n    if (isSupported()) {\n      const {\n        done,\n        response\n      } = concatenateToResponse(sourceFunctions.map(fn => fn({\n        event,\n        url,\n        params\n      })), headersInit);\n      event.waitUntil(done);\n      return response;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n    } // Fallback to waiting for everything to finish, and concatenating the\n    // responses.\n\n\n    const parts = await Promise.all(sourceFunctions.map(sourceFunction => sourceFunction({\n      event,\n      url,\n      params\n    })).map(async responsePromise => {\n      const response = await responsePromise;\n\n      if (response instanceof Response) {\n        return response.blob();\n      } // Otherwise, assume it's something like a string which can be used\n      // as-is when constructing the final composite blob.\n\n\n      return response;\n    }));\n    const headers = createHeaders(headersInit); // Constructing a new Response from a Blob source is well-supported.\n    // So is constructing a new Blob from multiple source Blobs or strings.\n\n    return new Response(new Blob(parts), {\n      headers\n    });\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-streams/strategy.mjs"],"names":["logger","createHeaders","concatenateToResponse","isSupported","strategy","sourceFunctions","headersInit","event","url","params","done","response","map","fn","waitUntil","process","env","NODE_ENV","log","parts","Promise","all","sourceFunction","responsePromise","Response","blob","headers","Blob"],"mappings":"AAAA;;;;;;;AAQA,SAAQA,MAAR,QAAqB,kCAArB;AAEA,SAAQC,aAAR,QAA4B,2BAA5B;AACA,SAAQC,qBAAR,QAAoC,6BAApC;AACA,SAAQC,WAAR,QAA0B,mBAA1B;AAEA,OAAO,gBAAP;AAEA;;;;;;;;;;;;;;;;;;AAiBA,OAAO,SAASC,QAAT,CAAkBC,eAAlB,EAAmCC,WAAnC,EAAgD;AACrD,SAAO,OAAO;AAACC,IAAAA,KAAD;AAAQC,IAAAA,GAAR;AAAaC,IAAAA;AAAb,GAAP,KAAgC;AACrC,QAAIN,WAAW,EAAf,EAAmB;AACjB,YAAM;AAACO,QAAAA,IAAD;AAAOC,QAAAA;AAAP,UAAmBT,qBAAqB,CAACG,eAAe,CAACO,GAAhB,CAC1CC,EAAD,IAAQA,EAAE,CAAC;AAACN,QAAAA,KAAD;AAAQC,QAAAA,GAAR;AAAaC,QAAAA;AAAb,OAAD,CADiC,CAAD,EACPH,WADO,CAA9C;AAEAC,MAAAA,KAAK,CAACO,SAAN,CAAgBJ,IAAhB;AACA,aAAOC,QAAP;AACD;;AAED,QAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCjB,MAAAA,MAAM,CAACkB,GAAP,CAAY,wDAAD,GACR,0DADH;AAED,KAXoC,CAarC;AACA;;;AACA,UAAMC,KAAK,GAAG,MAAMC,OAAO,CAACC,GAAR,CAChBhB,eAAe,CAACO,GAAhB,CACKU,cAAD,IAAoBA,cAAc,CAAC;AAACf,MAAAA,KAAD;AAAQC,MAAAA,GAAR;AAAaC,MAAAA;AAAb,KAAD,CADtC,EAEEG,GAFF,CAEM,MAAOW,eAAP,IAA2B;AAC/B,YAAMZ,QAAQ,GAAG,MAAMY,eAAvB;;AACA,UAAIZ,QAAQ,YAAYa,QAAxB,EAAkC;AAChC,eAAOb,QAAQ,CAACc,IAAT,EAAP;AACD,OAJ8B,CAM/B;AACA;;;AACA,aAAOd,QAAP;AACD,KAXD,CADgB,CAApB;AAeA,UAAMe,OAAO,GAAGzB,aAAa,CAACK,WAAD,CAA7B,CA9BqC,CA+BrC;AACA;;AACA,WAAO,IAAIkB,QAAJ,CAAa,IAAIG,IAAJ,CAASR,KAAT,CAAb,EAA8B;AAACO,MAAAA;AAAD,KAA9B,CAAP;AACD,GAlCD;AAmCD","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenateToResponse} from './concatenateToResponse.mjs';\nimport {isSupported} from './isSupported.mjs';\n\nimport './_version.mjs';\n\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {\n *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n * Each function should return a {@link workbox.streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {workbox.routing.Route~handlerCallback}\n *\n * @memberof workbox.streams\n */\nexport function strategy(sourceFunctions, headersInit) {\n  return async ({event, url, params}) => {\n    if (isSupported()) {\n      const {done, response} = concatenateToResponse(sourceFunctions.map(\n          (fn) => fn({event, url, params})), headersInit);\n      event.waitUntil(done);\n      return response;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`The current browser doesn't support creating response ` +\n        `streams. Falling back to non-streaming response instead.`);\n    }\n\n    // Fallback to waiting for everything to finish, and concatenating the\n    // responses.\n    const parts = await Promise.all(\n        sourceFunctions.map(\n            (sourceFunction) => sourceFunction({event, url, params})\n        ).map(async (responsePromise) => {\n          const response = await responsePromise;\n          if (response instanceof Response) {\n            return response.blob();\n          }\n\n          // Otherwise, assume it's something like a string which can be used\n          // as-is when constructing the final composite blob.\n          return response;\n        })\n    );\n\n    const headers = createHeaders(headersInit);\n    // Constructing a new Response from a Blob source is well-supported.\n    // So is constructing a new Blob from multiple source Blobs or strings.\n    return new Response(new Blob(parts), {headers});\n  };\n}\n"]},"metadata":{},"sourceType":"module"}