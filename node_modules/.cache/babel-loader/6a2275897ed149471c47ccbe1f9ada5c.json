{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.mjs';\nimport { CacheExpiration } from './CacheExpiration.mjs';\nimport './_version.mjs';\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n *\n * @memberof workbox.expiration\n */\n\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor'\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n\n\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n\n    return cacheExpiration;\n  }\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n\n\n  cachedResponseWillBeUsed({\n    event,\n    request,\n    cacheName,\n    cachedResponse\n  }) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n\n    cacheExpiration.expireEntries(); // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n\n\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    } // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n\n\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    } // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n\n\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n  }\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n\n\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n\n\n  async cacheDidUpdate({\n    cacheName,\n    request\n  }) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName'\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request'\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n\n\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    } // Reset this._cacheExpirations to its initial state.\n\n\n    this._cacheExpirations = new Map();\n  }\n\n}\n\nexport { Plugin };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-expiration/Plugin.mjs"],"names":["assert","cacheNames","getFriendlyURL","logger","WorkboxError","registerQuotaErrorCallback","CacheExpiration","Plugin","constructor","config","process","env","NODE_ENV","maxEntries","maxAgeSeconds","moduleName","className","funcName","isType","paramName","_config","_maxAgeSeconds","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","_getCacheExpiration","cacheName","getRuntimeName","cacheExpiration","get","set","cachedResponseWillBeUsed","event","request","cachedResponse","isFresh","_isResponseDateFresh","expireEntries","updateTimestampDone","updateTimestamp","url","waitUntil","error","warn","dateHeaderTimestamp","_getDateHeaderTimestamp","now","Date","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN","cacheDidUpdate","isInstance","Request","caches","delete"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n"]},"metadata":{},"sourceType":"module"}