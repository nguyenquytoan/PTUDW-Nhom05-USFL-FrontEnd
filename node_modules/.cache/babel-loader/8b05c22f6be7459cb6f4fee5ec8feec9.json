{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path = require(\"path\");\n\nvar globParent = require(\"glob-parent\");\n\nvar isGlob = require(\"is-glob\");\n\nvar micromatch = require(\"micromatch\");\n\nvar GLOBSTAR = '**';\n/**\r\n * Return true for static pattern.\r\n */\n\nfunction isStaticPattern(pattern) {\n  return !isDynamicPattern(pattern);\n}\n\nexports.isStaticPattern = isStaticPattern;\n/**\r\n * Return true for pattern that looks like glob.\r\n */\n\nfunction isDynamicPattern(pattern) {\n  return isGlob(pattern, {\n    strict: false\n  });\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n/**\r\n * Convert a windows «path» to a unix-style «path».\r\n */\n\nfunction unixifyPattern(pattern) {\n  return pattern.replace(/\\\\/g, '/');\n}\n\nexports.unixifyPattern = unixifyPattern;\n/**\r\n * Returns negative pattern as positive pattern.\r\n */\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n/**\r\n * Returns positive pattern as negative pattern.\r\n */\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n/**\r\n * Return true if provided pattern is negative pattern.\r\n */\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n/**\r\n * Return true if provided pattern is positive pattern.\r\n */\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n/**\r\n * Extracts negative patterns from array of patterns.\r\n */\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n/**\r\n * Extracts positive patterns from array of patterns.\r\n */\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\r\n * Extract base directory from provided pattern.\r\n */\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern);\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n/**\r\n * Return true if provided pattern has globstar.\r\n */\n\nfunction hasGlobStar(pattern) {\n  return pattern.indexOf(GLOBSTAR) !== -1;\n}\n\nexports.hasGlobStar = hasGlobStar;\n/**\r\n * Return true if provided pattern ends with slash and globstar.\r\n */\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n/**\r\n * Returns «true» when pattern ends with a slash and globstar or the last partial of the pattern is static pattern.\r\n */\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  var basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n/**\r\n * Return naive depth of provided pattern without depth of the base directory.\r\n */\n\nfunction getNaiveDepth(pattern) {\n  var base = getBaseDirectory(pattern);\n  var patternDepth = pattern.split('/').length;\n  var patternBaseDepth = base.split('/').length;\n  /**\r\n   * This is a hack for pattern that has no base directory.\r\n   *\r\n   * This is related to the `*\\something\\*` pattern.\r\n   */\n\n  if (base === '.') {\n    return patternDepth - patternBaseDepth;\n  }\n\n  return patternDepth - patternBaseDepth - 1;\n}\n\nexports.getNaiveDepth = getNaiveDepth;\n/**\r\n * Return max naive depth of provided patterns without depth of the base directory.\r\n */\n\nfunction getMaxNaivePatternsDepth(patterns) {\n  return patterns.reduce(function (max, pattern) {\n    var depth = getNaiveDepth(pattern);\n    return depth > max ? depth : max;\n  }, 0);\n}\n\nexports.getMaxNaivePatternsDepth = getMaxNaivePatternsDepth;\n/**\r\n * Make RegExp for provided pattern.\r\n */\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n/**\r\n * Convert patterns to regexps.\r\n */\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(function (pattern) {\n    return makeRe(pattern, options);\n  });\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n/**\r\n * Returns true if the entry match any of the given RegExp's.\r\n */\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(function (patternRe) {\n    return patternRe.test(entry);\n  });\n}\n\nexports.matchAny = matchAny;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/fast-glob/out/utils/pattern.js"],"names":["Object","defineProperty","exports","value","path","require","globParent","isGlob","micromatch","GLOBSTAR","isStaticPattern","pattern","isDynamicPattern","strict","unixifyPattern","replace","convertToPositivePattern","isNegativePattern","slice","convertToNegativePattern","startsWith","isPositivePattern","getNegativePatterns","patterns","filter","getPositivePatterns","getBaseDirectory","hasGlobStar","indexOf","endsWithSlashGlobStar","endsWith","isAffectDepthOfReadingPattern","basename","getNaiveDepth","base","patternDepth","split","length","patternBaseDepth","getMaxNaivePatternsDepth","reduce","max","depth","makeRe","options","convertPatternsToRe","map","matchAny","entry","patternsRe","some","patternRe","test"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar globParent = require(\"glob-parent\");\r\nvar isGlob = require(\"is-glob\");\r\nvar micromatch = require(\"micromatch\");\r\nvar GLOBSTAR = '**';\r\n/**\r\n * Return true for static pattern.\r\n */\r\nfunction isStaticPattern(pattern) {\r\n    return !isDynamicPattern(pattern);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\n/**\r\n * Return true for pattern that looks like glob.\r\n */\r\nfunction isDynamicPattern(pattern) {\r\n    return isGlob(pattern, { strict: false });\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\n/**\r\n * Convert a windows «path» to a unix-style «path».\r\n */\r\nfunction unixifyPattern(pattern) {\r\n    return pattern.replace(/\\\\/g, '/');\r\n}\r\nexports.unixifyPattern = unixifyPattern;\r\n/**\r\n * Returns negative pattern as positive pattern.\r\n */\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\n/**\r\n * Returns positive pattern as negative pattern.\r\n */\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\n/**\r\n * Return true if provided pattern is negative pattern.\r\n */\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\n/**\r\n * Return true if provided pattern is positive pattern.\r\n */\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\n/**\r\n * Extracts negative patterns from array of patterns.\r\n */\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\n/**\r\n * Extracts positive patterns from array of patterns.\r\n */\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\n/**\r\n * Extract base directory from provided pattern.\r\n */\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern);\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\n/**\r\n * Return true if provided pattern has globstar.\r\n */\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.indexOf(GLOBSTAR) !== -1;\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\n/**\r\n * Return true if provided pattern ends with slash and globstar.\r\n */\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\n/**\r\n * Returns «true» when pattern ends with a slash and globstar or the last partial of the pattern is static pattern.\r\n */\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    var basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\n/**\r\n * Return naive depth of provided pattern without depth of the base directory.\r\n */\r\nfunction getNaiveDepth(pattern) {\r\n    var base = getBaseDirectory(pattern);\r\n    var patternDepth = pattern.split('/').length;\r\n    var patternBaseDepth = base.split('/').length;\r\n    /**\r\n     * This is a hack for pattern that has no base directory.\r\n     *\r\n     * This is related to the `*\\something\\*` pattern.\r\n     */\r\n    if (base === '.') {\r\n        return patternDepth - patternBaseDepth;\r\n    }\r\n    return patternDepth - patternBaseDepth - 1;\r\n}\r\nexports.getNaiveDepth = getNaiveDepth;\r\n/**\r\n * Return max naive depth of provided patterns without depth of the base directory.\r\n */\r\nfunction getMaxNaivePatternsDepth(patterns) {\r\n    return patterns.reduce(function (max, pattern) {\r\n        var depth = getNaiveDepth(pattern);\r\n        return depth > max ? depth : max;\r\n    }, 0);\r\n}\r\nexports.getMaxNaivePatternsDepth = getMaxNaivePatternsDepth;\r\n/**\r\n * Make RegExp for provided pattern.\r\n */\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\n/**\r\n * Convert patterns to regexps.\r\n */\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map(function (pattern) { return makeRe(pattern, options); });\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\n/**\r\n * Returns true if the entry match any of the given RegExp's.\r\n */\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some(function (patternRe) { return patternRe.test(entry); });\r\n}\r\nexports.matchAny = matchAny;\r\n"]},"metadata":{},"sourceType":"script"}