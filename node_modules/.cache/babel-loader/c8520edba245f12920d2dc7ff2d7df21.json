{"ast":null,"code":"'use strict';\n\nvar define = require('define-properties');\n\nvar AdvanceStringIndex = require('es-abstract/2019/AdvanceStringIndex');\n\nvar CreateIterResultObject = require('es-abstract/2019/CreateIterResultObject');\n\nvar Get = require('es-abstract/2019/Get');\n\nvar GetIntrinsic = require('es-abstract/GetIntrinsic');\n\nvar ObjectCreate = require('es-abstract/2019/ObjectCreate');\n\nvar RegExpExec = require('es-abstract/2019/RegExpExec');\n\nvar Set = require('es-abstract/2019/Set');\n\nvar ToLength = require('es-abstract/2019/ToLength');\n\nvar ToString = require('es-abstract/2019/ToString');\n\nvar Type = require('es-abstract/2019/Type');\n\nvar hasSymbols = require('has-symbols')();\n\nvar SLOT = require('internal-slot');\n\nvar undefined;\n\nvar RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {\n  if (Type(S) !== 'String') {\n    throw new TypeError('S must be a string');\n  }\n\n  if (Type(global) !== 'Boolean') {\n    throw new TypeError('global must be a boolean');\n  }\n\n  if (Type(fullUnicode) !== 'Boolean') {\n    throw new TypeError('fullUnicode must be a boolean');\n  }\n\n  SLOT.set(this, '[[IteratingRegExp]]', R);\n  SLOT.set(this, '[[IteratedString]]', S);\n  SLOT.set(this, '[[Global]]', global);\n  SLOT.set(this, '[[Unicode]]', fullUnicode);\n  SLOT.set(this, '[[Done]]', false);\n};\n\nvar IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);\n\nif (IteratorPrototype) {\n  RegExpStringIterator.prototype = ObjectCreate(IteratorPrototype);\n}\n\ndefine(RegExpStringIterator.prototype, {\n  next: function next() {\n    var O = this;\n\n    if (Type(O) !== 'Object') {\n      throw new TypeError('receiver must be an object');\n    }\n\n    if (!(O instanceof RegExpStringIterator) || !SLOT.has(O, '[[IteratingRegExp]]') || !SLOT.has(O, '[[IteratedString]]') || !SLOT.has(O, '[[Global]]') || !SLOT.has(O, '[[Unicode]]') || !SLOT.has(O, '[[Done]]')) {\n      throw new TypeError('\"this\" value must be a RegExpStringIterator instance');\n    }\n\n    if (SLOT.get(O, '[[Done]]')) {\n      return CreateIterResultObject(undefined, true);\n    }\n\n    var R = SLOT.get(O, '[[IteratingRegExp]]');\n    var S = SLOT.get(O, '[[IteratedString]]');\n    var global = SLOT.get(O, '[[Global]]');\n    var fullUnicode = SLOT.get(O, '[[Unicode]]');\n    var match = RegExpExec(R, S);\n\n    if (match === null) {\n      SLOT.set(O, '[[Done]]', true);\n      return CreateIterResultObject(undefined, true);\n    }\n\n    if (global) {\n      var matchStr = ToString(Get(match, '0'));\n\n      if (matchStr === '') {\n        var thisIndex = ToLength(Get(R, 'lastIndex'));\n        var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);\n        Set(R, 'lastIndex', nextIndex, true);\n      }\n\n      return CreateIterResultObject(match, false);\n    }\n\n    SLOT.set(O, '[[Done]]', true);\n    return CreateIterResultObject(match, false);\n  }\n});\n\nif (hasSymbols) {\n  var defineP = Object.defineProperty;\n\n  if (Symbol.toStringTag) {\n    if (defineP) {\n      defineP(RegExpStringIterator.prototype, Symbol.toStringTag, {\n        configurable: true,\n        enumerable: false,\n        value: 'RegExp String Iterator',\n        writable: false\n      });\n    } else {\n      RegExpStringIterator.prototype[Symbol.toStringTag] = 'RegExp String Iterator';\n    }\n  }\n\n  if (!IteratorPrototype && Symbol.iterator) {\n    var func = {};\n\n    func[Symbol.iterator] = RegExpStringIterator.prototype[Symbol.iterator] || function SymbolIterator() {\n      return this;\n    };\n\n    var predicate = {};\n\n    predicate[Symbol.iterator] = function () {\n      return RegExpStringIterator.prototype[Symbol.iterator] !== func[Symbol.iterator];\n    };\n\n    define(RegExpStringIterator.prototype, func, predicate);\n  }\n}\n\nmodule.exports = RegExpStringIterator;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/string.prototype.matchall/helpers/RegExpStringIterator.js"],"names":["define","require","AdvanceStringIndex","CreateIterResultObject","Get","GetIntrinsic","ObjectCreate","RegExpExec","Set","ToLength","ToString","Type","hasSymbols","SLOT","undefined","RegExpStringIterator","R","S","global","fullUnicode","TypeError","set","IteratorPrototype","prototype","next","O","has","get","match","matchStr","thisIndex","nextIndex","defineP","Object","defineProperty","Symbol","toStringTag","configurable","enumerable","value","writable","iterator","func","SymbolIterator","predicate","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar define = require('define-properties');\nvar AdvanceStringIndex = require('es-abstract/2019/AdvanceStringIndex');\nvar CreateIterResultObject = require('es-abstract/2019/CreateIterResultObject');\nvar Get = require('es-abstract/2019/Get');\nvar GetIntrinsic = require('es-abstract/GetIntrinsic');\nvar ObjectCreate = require('es-abstract/2019/ObjectCreate');\nvar RegExpExec = require('es-abstract/2019/RegExpExec');\nvar Set = require('es-abstract/2019/Set');\nvar ToLength = require('es-abstract/2019/ToLength');\nvar ToString = require('es-abstract/2019/ToString');\nvar Type = require('es-abstract/2019/Type');\nvar hasSymbols = require('has-symbols')();\n\nvar SLOT = require('internal-slot');\nvar undefined;\n\nvar RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {\n\tif (Type(S) !== 'String') {\n\t\tthrow new TypeError('S must be a string');\n\t}\n\tif (Type(global) !== 'Boolean') {\n\t\tthrow new TypeError('global must be a boolean');\n\t}\n\tif (Type(fullUnicode) !== 'Boolean') {\n\t\tthrow new TypeError('fullUnicode must be a boolean');\n\t}\n\tSLOT.set(this, '[[IteratingRegExp]]', R);\n\tSLOT.set(this, '[[IteratedString]]', S);\n\tSLOT.set(this, '[[Global]]', global);\n\tSLOT.set(this, '[[Unicode]]', fullUnicode);\n\tSLOT.set(this, '[[Done]]', false);\n};\n\nvar IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);\nif (IteratorPrototype) {\n\tRegExpStringIterator.prototype = ObjectCreate(IteratorPrototype);\n}\n\ndefine(RegExpStringIterator.prototype, {\n\tnext: function next() {\n\t\tvar O = this;\n\t\tif (Type(O) !== 'Object') {\n\t\t\tthrow new TypeError('receiver must be an object');\n\t\t}\n\t\tif (\n\t\t\t!(O instanceof RegExpStringIterator)\n\t\t\t|| !SLOT.has(O, '[[IteratingRegExp]]')\n\t\t\t|| !SLOT.has(O, '[[IteratedString]]')\n\t\t\t|| !SLOT.has(O, '[[Global]]')\n\t\t\t|| !SLOT.has(O, '[[Unicode]]')\n\t\t\t|| !SLOT.has(O, '[[Done]]')\n\t\t) {\n\t\t\tthrow new TypeError('\"this\" value must be a RegExpStringIterator instance');\n\t\t}\n\t\tif (SLOT.get(O, '[[Done]]')) {\n\t\t\treturn CreateIterResultObject(undefined, true);\n\t\t}\n\t\tvar R = SLOT.get(O, '[[IteratingRegExp]]');\n\t\tvar S = SLOT.get(O, '[[IteratedString]]');\n\t\tvar global = SLOT.get(O, '[[Global]]');\n\t\tvar fullUnicode = SLOT.get(O, '[[Unicode]]');\n\t\tvar match = RegExpExec(R, S);\n\t\tif (match === null) {\n\t\t\tSLOT.set(O, '[[Done]]', true);\n\t\t\treturn CreateIterResultObject(undefined, true);\n\t\t}\n\t\tif (global) {\n\t\t\tvar matchStr = ToString(Get(match, '0'));\n\t\t\tif (matchStr === '') {\n\t\t\t\tvar thisIndex = ToLength(Get(R, 'lastIndex'));\n\t\t\t\tvar nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);\n\t\t\t\tSet(R, 'lastIndex', nextIndex, true);\n\t\t\t}\n\t\t\treturn CreateIterResultObject(match, false);\n\t\t}\n\t\tSLOT.set(O, '[[Done]]', true);\n\t\treturn CreateIterResultObject(match, false);\n\t}\n});\nif (hasSymbols) {\n\tvar defineP = Object.defineProperty;\n\tif (Symbol.toStringTag) {\n\t\tif (defineP) {\n\t\t\tdefineP(RegExpStringIterator.prototype, Symbol.toStringTag, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: 'RegExp String Iterator',\n\t\t\t\twritable: false\n\t\t\t});\n\t\t} else {\n\t\t\tRegExpStringIterator.prototype[Symbol.toStringTag] = 'RegExp String Iterator';\n\t\t}\n\t}\n\n\tif (!IteratorPrototype && Symbol.iterator) {\n\t\tvar func = {};\n\t\tfunc[Symbol.iterator] = RegExpStringIterator.prototype[Symbol.iterator] || function SymbolIterator() {\n\t\t\treturn this;\n\t\t};\n\t\tvar predicate = {};\n\t\tpredicate[Symbol.iterator] = function () {\n\t\t\treturn RegExpStringIterator.prototype[Symbol.iterator] !== func[Symbol.iterator];\n\t\t};\n\t\tdefine(RegExpStringIterator.prototype, func, predicate);\n\t}\n}\n\nmodule.exports = RegExpStringIterator;\n"]},"metadata":{},"sourceType":"script"}