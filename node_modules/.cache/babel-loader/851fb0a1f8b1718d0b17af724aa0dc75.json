{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { QueueStore } from './lib/QueueStore.mjs';\nimport { StorableRequest } from './lib/StorableRequest.mjs';\nimport './_version.mjs';\nconst TAG_PREFIX = 'workbox-background-sync';\nconst MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes\n\nconst queueNames = new Set();\n/**\n * A class to manage storing failed requests in IndexedDB and retrying them\n * later. All parts of the storing and replaying process are observable via\n * callbacks.\n *\n * @memberof workbox.backgroundSync\n */\n\nclass Queue {\n  /**\n   * Creates an instance of Queue with the given options\n   *\n   * @param {string} name The unique name for this queue. This name must be\n   *     unique as it's used to register sync events and store requests\n   *     in IndexedDB specific to this instance. An error will be thrown if\n   *     a duplicate name is detected.\n   * @param {Object} [options]\n   * @param {Function} [options.onSync] A function that gets invoked whenever\n   *     the 'sync' event fires. The function is invoked with an object\n   *     containing the `queue` property (referencing this instance), and you\n   *     can use the callback to customize the replay behavior of the queue.\n   *     When not set the `replayRequests()` method is called.\n   *     Note: if the replay fails after a sync event, make sure you throw an\n   *     error, so the browser knows to retry the sync event later.\n   * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n   *     minutes) a request may be retried. After this amount of time has\n   *     passed, the request will be deleted from the queue.\n   */\n  constructor(name, {\n    onSync,\n    maxRetentionTime\n  } = {}) {\n    // Ensure the store name is not already being used\n    if (queueNames.has(name)) {\n      throw new WorkboxError('duplicate-queue-name', {\n        name\n      });\n    } else {\n      queueNames.add(name);\n    }\n\n    this._name = name;\n    this._onSync = onSync || this.replayRequests;\n    this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n    this._queueStore = new QueueStore(this._name);\n\n    this._addSyncListener();\n  }\n  /**\n   * @return {string}\n   */\n\n\n  get name() {\n    return this._name;\n  }\n  /**\n   * Stores the passed request in IndexedDB (with its timestamp and any\n   * metadata) at the end of the queue.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request The request to store in the queue.\n   * @param {Object} [entry.metadata] Any metadata you want associated with the\n   *     stored request. When requests are replayed you'll have access to this\n   *     metadata object in case you need to modify the request beforehand.\n   * @param {number} [entry.timestamp] The timestamp (Epoch time in\n   *     milliseconds) when the request was first added to the queue. This is\n   *     used along with `maxRetentionTime` to remove outdated requests. In\n   *     general you don't need to set this value, as it's automatically set\n   *     for you (defaulting to `Date.now()`), but you can update it if you\n   *     don't want particular requests to expire.\n   */\n\n\n  async pushRequest(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'pushRequest',\n        paramName: 'entry'\n      });\n      assert.isInstance(entry.request, Request, {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'pushRequest',\n        paramName: 'entry.request'\n      });\n    }\n\n    await this._addRequest(entry, 'push');\n  }\n  /**\n   * Stores the passed request in IndexedDB (with its timestamp and any\n   * metadata) at the beginning of the queue.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request The request to store in the queue.\n   * @param {Object} [entry.metadata] Any metadata you want associated with the\n   *     stored request. When requests are replayed you'll have access to this\n   *     metadata object in case you need to modify the request beforehand.\n   * @param {number} [entry.timestamp] The timestamp (Epoch time in\n   *     milliseconds) when the request was first added to the queue. This is\n   *     used along with `maxRetentionTime` to remove outdated requests. In\n   *     general you don't need to set this value, as it's automatically set\n   *     for you (defaulting to `Date.now()`), but you can update it if you\n   *     don't want particular requests to expire.\n   */\n\n\n  async unshiftRequest(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'unshiftRequest',\n        paramName: 'entry'\n      });\n      assert.isInstance(entry.request, Request, {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'unshiftRequest',\n        paramName: 'entry.request'\n      });\n    }\n\n    await this._addRequest(entry, 'unshift');\n  }\n  /**\n   * Removes and returns the last request in the queue (along with its\n   * timestamp and any metadata). The returned object takes the form:\n   * `{request, timestamp, metadata}`.\n   *\n   * @return {Promise<Object>}\n   */\n\n\n  async popRequest() {\n    return this._removeRequest('pop');\n  }\n  /**\n   * Removes and returns the first request in the queue (along with its\n   * timestamp and any metadata). The returned object takes the form:\n   * `{request, timestamp, metadata}`.\n   *\n   * @return {Promise<Object>}\n   */\n\n\n  async shiftRequest() {\n    return this._removeRequest('shift');\n  }\n  /**\n   * Returns all the entries that have not expired (per `maxRetentionTime`).\n   * Any expired entries are removed from the queue.\n   *\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  async getAll() {\n    const allEntries = await this._queueStore.getAll();\n    const now = Date.now();\n    const unexpiredEntries = [];\n\n    for (const entry of allEntries) {\n      // Ignore requests older than maxRetentionTime. Call this function\n      // recursively until an unexpired request is found.\n      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n      if (now - entry.timestamp > maxRetentionTimeInMs) {\n        await this._queueStore.deleteEntry(entry.id);\n      } else {\n        unexpiredEntries.push(convertEntry(entry));\n      }\n    }\n\n    return unexpiredEntries;\n  }\n  /**\n   * Adds the entry to the QueueStore and registers for a sync event.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request\n   * @param {Object} [entry.metadata]\n   * @param {number} [entry.timestamp=Date.now()]\n   * @param {string} operation ('push' or 'unshift')\n   * @private\n   */\n\n\n  async _addRequest({\n    request,\n    metadata,\n    timestamp = Date.now()\n  }, operation) {\n    const storableRequest = await StorableRequest.fromRequest(request.clone());\n    const entry = {\n      requestData: storableRequest.toObject(),\n      timestamp\n    }; // Only include metadata if it's present.\n\n    if (metadata) {\n      entry.metadata = metadata;\n    }\n\n    await this._queueStore[`${operation}Entry`](entry);\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Request for '${getFriendlyURL(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n    } // Don't register for a sync if we're in the middle of a sync. Instead,\n    // we wait until the sync is complete and call register if\n    // `this._requestsAddedDuringSync` is true.\n\n\n    if (this._syncInProgress) {\n      this._requestsAddedDuringSync = true;\n    } else {\n      await this.registerSync();\n    }\n  }\n  /**\n   * Removes and returns the first or last (depending on `operation`) entry\n   * from the QueueStore that's not older than the `maxRetentionTime`.\n   *\n   * @param {string} operation ('pop' or 'shift')\n   * @return {Object|undefined}\n   * @private\n   */\n\n\n  async _removeRequest(operation) {\n    const now = Date.now();\n    const entry = await this._queueStore[`${operation}Entry`]();\n\n    if (entry) {\n      // Ignore requests older than maxRetentionTime. Call this function\n      // recursively until an unexpired request is found.\n      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n      if (now - entry.timestamp > maxRetentionTimeInMs) {\n        return this._removeRequest(operation);\n      }\n\n      return convertEntry(entry);\n    }\n  }\n  /**\n   * Loops through each request in the queue and attempts to re-fetch it.\n   * If any request fails to re-fetch, it's put back in the same position in\n   * the queue (which registers a retry for the next sync event).\n   */\n\n\n  async replayRequests() {\n    let entry;\n\n    while (entry = await this.shiftRequest()) {\n      try {\n        await fetch(entry.request.clone());\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(entry.request.url)}'` + `has been replayed in queue '${this._name}'`);\n        }\n      } catch (error) {\n        await this.unshiftRequest(entry);\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(entry.request.url)}'` + `failed to replay, putting it back in queue '${this._name}'`);\n        }\n\n        throw new WorkboxError('queue-replay-failed', {\n          name: this._name\n        });\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`All requests in queue '${this.name}' have successfully ` + `replayed; the queue is now empty!`);\n    }\n  }\n  /**\n   * Registers a sync event with a tag unique to this instance.\n   */\n\n\n  async registerSync() {\n    if ('sync' in registration) {\n      try {\n        await registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n      } catch (err) {\n        // This means the registration failed for some reason, possibly due to\n        // the user disabling it.\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n        }\n      }\n    }\n  }\n  /**\n   * In sync-supporting browsers, this adds a listener for the sync event.\n   * In non-sync-supporting browsers, this will retry the queue on service\n   * worker startup.\n   *\n   * @private\n   */\n\n\n  _addSyncListener() {\n    if ('sync' in registration) {\n      self.addEventListener('sync', event => {\n        if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.log(`Background sync for tag '${event.tag}'` + `has been received`);\n          }\n\n          const syncComplete = async () => {\n            this._syncInProgress = true;\n            let syncError;\n\n            try {\n              await this._onSync({\n                queue: this\n              });\n            } catch (error) {\n              syncError = error; // Rethrow the error. Note: the logic in the finally clause\n              // will run before this gets rethrown.\n\n              throw syncError;\n            } finally {\n              // New items may have been added to the queue during the sync,\n              // so we need to register for a new sync if that's happened...\n              // Unless there was an error during the sync, in which\n              // case the browser will automatically retry later, as long\n              // as `event.lastChance` is not true.\n              if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                await this.registerSync();\n              }\n\n              this._syncInProgress = false;\n              this._requestsAddedDuringSync = false;\n            }\n          };\n\n          event.waitUntil(syncComplete());\n        }\n      });\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Background sync replaying without background sync event`);\n      } // If the browser doesn't support background sync, retry\n      // every time the service worker starts up as a fallback.\n\n\n      this._onSync({\n        queue: this\n      });\n    }\n  }\n  /**\n   * Returns the set of queue names. This is primarily used to reset the list\n   * of queue names in tests.\n   *\n   * @return {Set}\n   *\n   * @private\n   */\n\n\n  static get _queueNames() {\n    return queueNames;\n  }\n\n}\n/**\n * Converts a QueueStore entry into the format exposed by Queue. This entails\n * converting the request data into a real request and omitting the `id` and\n * `queueName` properties.\n *\n * @param {Object} queueStoreEntry\n * @return {Object}\n * @private\n */\n\n\nconst convertEntry = queueStoreEntry => {\n  const queueEntry = {\n    request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n    timestamp: queueStoreEntry.timestamp\n  };\n\n  if (queueStoreEntry.metadata) {\n    queueEntry.metadata = queueStoreEntry.metadata;\n  }\n\n  return queueEntry;\n};\n\nexport { Queue };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-background-sync/Queue.mjs"],"names":["WorkboxError","logger","assert","getFriendlyURL","QueueStore","StorableRequest","TAG_PREFIX","MAX_RETENTION_TIME","queueNames","Set","Queue","constructor","name","onSync","maxRetentionTime","has","add","_name","_onSync","replayRequests","_maxRetentionTime","_queueStore","_addSyncListener","pushRequest","entry","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","isInstance","request","Request","_addRequest","unshiftRequest","popRequest","_removeRequest","shiftRequest","getAll","allEntries","now","Date","unexpiredEntries","maxRetentionTimeInMs","timestamp","deleteEntry","id","push","convertEntry","metadata","operation","storableRequest","fromRequest","clone","requestData","toObject","log","url","_syncInProgress","_requestsAddedDuringSync","registerSync","fetch","error","registration","sync","register","err","warn","self","addEventListener","event","tag","syncComplete","syncError","queue","lastChance","waitUntil","_queueNames","queueStoreEntry","queueEntry","toRequest"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {QueueStore} from './lib/QueueStore.mjs';\nimport {StorableRequest} from './lib/StorableRequest.mjs';\nimport './_version.mjs';\n\n\nconst TAG_PREFIX = 'workbox-background-sync';\nconst MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes\n\nconst queueNames = new Set();\n\n/**\n * A class to manage storing failed requests in IndexedDB and retrying them\n * later. All parts of the storing and replaying process are observable via\n * callbacks.\n *\n * @memberof workbox.backgroundSync\n */\nclass Queue {\n  /**\n   * Creates an instance of Queue with the given options\n   *\n   * @param {string} name The unique name for this queue. This name must be\n   *     unique as it's used to register sync events and store requests\n   *     in IndexedDB specific to this instance. An error will be thrown if\n   *     a duplicate name is detected.\n   * @param {Object} [options]\n   * @param {Function} [options.onSync] A function that gets invoked whenever\n   *     the 'sync' event fires. The function is invoked with an object\n   *     containing the `queue` property (referencing this instance), and you\n   *     can use the callback to customize the replay behavior of the queue.\n   *     When not set the `replayRequests()` method is called.\n   *     Note: if the replay fails after a sync event, make sure you throw an\n   *     error, so the browser knows to retry the sync event later.\n   * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n   *     minutes) a request may be retried. After this amount of time has\n   *     passed, the request will be deleted from the queue.\n   */\n  constructor(name, {onSync, maxRetentionTime} = {}) {\n    // Ensure the store name is not already being used\n    if (queueNames.has(name)) {\n      throw new WorkboxError('duplicate-queue-name', {name});\n    } else {\n      queueNames.add(name);\n    }\n\n    this._name = name;\n    this._onSync = onSync || this.replayRequests;\n    this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n    this._queueStore = new QueueStore(this._name);\n\n    this._addSyncListener();\n  }\n\n  /**\n   * @return {string}\n   */\n  get name() {\n    return this._name;\n  }\n\n  /**\n   * Stores the passed request in IndexedDB (with its timestamp and any\n   * metadata) at the end of the queue.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request The request to store in the queue.\n   * @param {Object} [entry.metadata] Any metadata you want associated with the\n   *     stored request. When requests are replayed you'll have access to this\n   *     metadata object in case you need to modify the request beforehand.\n   * @param {number} [entry.timestamp] The timestamp (Epoch time in\n   *     milliseconds) when the request was first added to the queue. This is\n   *     used along with `maxRetentionTime` to remove outdated requests. In\n   *     general you don't need to set this value, as it's automatically set\n   *     for you (defaulting to `Date.now()`), but you can update it if you\n   *     don't want particular requests to expire.\n   */\n  async pushRequest(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'pushRequest',\n        paramName: 'entry',\n      });\n      assert.isInstance(entry.request, Request, {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'pushRequest',\n        paramName: 'entry.request',\n      });\n    }\n\n    await this._addRequest(entry, 'push');\n  }\n\n  /**\n   * Stores the passed request in IndexedDB (with its timestamp and any\n   * metadata) at the beginning of the queue.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request The request to store in the queue.\n   * @param {Object} [entry.metadata] Any metadata you want associated with the\n   *     stored request. When requests are replayed you'll have access to this\n   *     metadata object in case you need to modify the request beforehand.\n   * @param {number} [entry.timestamp] The timestamp (Epoch time in\n   *     milliseconds) when the request was first added to the queue. This is\n   *     used along with `maxRetentionTime` to remove outdated requests. In\n   *     general you don't need to set this value, as it's automatically set\n   *     for you (defaulting to `Date.now()`), but you can update it if you\n   *     don't want particular requests to expire.\n   */\n  async unshiftRequest(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'unshiftRequest',\n        paramName: 'entry',\n      });\n      assert.isInstance(entry.request, Request, {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'unshiftRequest',\n        paramName: 'entry.request',\n      });\n    }\n\n    await this._addRequest(entry, 'unshift');\n  }\n\n  /**\n   * Removes and returns the last request in the queue (along with its\n   * timestamp and any metadata). The returned object takes the form:\n   * `{request, timestamp, metadata}`.\n   *\n   * @return {Promise<Object>}\n   */\n  async popRequest() {\n    return this._removeRequest('pop');\n  }\n\n  /**\n   * Removes and returns the first request in the queue (along with its\n   * timestamp and any metadata). The returned object takes the form:\n   * `{request, timestamp, metadata}`.\n   *\n   * @return {Promise<Object>}\n   */\n  async shiftRequest() {\n    return this._removeRequest('shift');\n  }\n\n  /**\n   * Returns all the entries that have not expired (per `maxRetentionTime`).\n   * Any expired entries are removed from the queue.\n   *\n   * @return {Promise<Array<Object>>}\n   */\n  async getAll() {\n    const allEntries = await this._queueStore.getAll();\n    const now = Date.now();\n\n    const unexpiredEntries = [];\n    for (const entry of allEntries) {\n      // Ignore requests older than maxRetentionTime. Call this function\n      // recursively until an unexpired request is found.\n      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n      if (now - entry.timestamp > maxRetentionTimeInMs) {\n        await this._queueStore.deleteEntry(entry.id);\n      } else {\n        unexpiredEntries.push(convertEntry(entry));\n      }\n    }\n\n    return unexpiredEntries;\n  }\n\n\n  /**\n   * Adds the entry to the QueueStore and registers for a sync event.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request\n   * @param {Object} [entry.metadata]\n   * @param {number} [entry.timestamp=Date.now()]\n   * @param {string} operation ('push' or 'unshift')\n   * @private\n   */\n  async _addRequest(\n      {request, metadata, timestamp = Date.now()}, operation) {\n    const storableRequest = await StorableRequest.fromRequest(request.clone());\n    const entry = {\n      requestData: storableRequest.toObject(),\n      timestamp,\n    };\n\n    // Only include metadata if it's present.\n    if (metadata) {\n      entry.metadata = metadata;\n    }\n\n    await this._queueStore[`${operation}Entry`](entry);\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Request for '${getFriendlyURL(request.url)}' has ` +\n          `been added to background sync queue '${this._name}'.`);\n    }\n\n    // Don't register for a sync if we're in the middle of a sync. Instead,\n    // we wait until the sync is complete and call register if\n    // `this._requestsAddedDuringSync` is true.\n    if (this._syncInProgress) {\n      this._requestsAddedDuringSync = true;\n    } else {\n      await this.registerSync();\n    }\n  }\n\n  /**\n   * Removes and returns the first or last (depending on `operation`) entry\n   * from the QueueStore that's not older than the `maxRetentionTime`.\n   *\n   * @param {string} operation ('pop' or 'shift')\n   * @return {Object|undefined}\n   * @private\n   */\n  async _removeRequest(operation) {\n    const now = Date.now();\n    const entry = await this._queueStore[`${operation}Entry`]();\n\n    if (entry) {\n      // Ignore requests older than maxRetentionTime. Call this function\n      // recursively until an unexpired request is found.\n      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n      if (now - entry.timestamp > maxRetentionTimeInMs) {\n        return this._removeRequest(operation);\n      }\n\n      return convertEntry(entry);\n    }\n  }\n\n  /**\n   * Loops through each request in the queue and attempts to re-fetch it.\n   * If any request fails to re-fetch, it's put back in the same position in\n   * the queue (which registers a retry for the next sync event).\n   */\n  async replayRequests() {\n    let entry;\n    while (entry = await this.shiftRequest()) {\n      try {\n        await fetch(entry.request.clone());\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(entry.request.url)}'` +\n             `has been replayed in queue '${this._name}'`);\n        }\n      } catch (error) {\n        await this.unshiftRequest(entry);\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(entry.request.url)}'` +\n             `failed to replay, putting it back in queue '${this._name}'`);\n        }\n        throw new WorkboxError('queue-replay-failed', {name: this._name});\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`All requests in queue '${this.name}' have successfully ` +\n          `replayed; the queue is now empty!`);\n    }\n  }\n\n  /**\n   * Registers a sync event with a tag unique to this instance.\n   */\n  async registerSync() {\n    if ('sync' in registration) {\n      try {\n        await registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n      } catch (err) {\n        // This means the registration failed for some reason, possibly due to\n        // the user disabling it.\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(\n              `Unable to register sync event for '${this._name}'.`, err);\n        }\n      }\n    }\n  }\n\n  /**\n   * In sync-supporting browsers, this adds a listener for the sync event.\n   * In non-sync-supporting browsers, this will retry the queue on service\n   * worker startup.\n   *\n   * @private\n   */\n  _addSyncListener() {\n    if ('sync' in registration) {\n      self.addEventListener('sync', (event) => {\n        if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.log(`Background sync for tag '${event.tag}'` +\n                `has been received`);\n          }\n\n          const syncComplete = async () => {\n            this._syncInProgress = true;\n\n            let syncError;\n            try {\n              await this._onSync({queue: this});\n            } catch (error) {\n              syncError = error;\n\n              // Rethrow the error. Note: the logic in the finally clause\n              // will run before this gets rethrown.\n              throw syncError;\n            } finally {\n              // New items may have been added to the queue during the sync,\n              // so we need to register for a new sync if that's happened...\n              // Unless there was an error during the sync, in which\n              // case the browser will automatically retry later, as long\n              // as `event.lastChance` is not true.\n              if (this._requestsAddedDuringSync &&\n                  !(syncError && !event.lastChance)) {\n                await this.registerSync();\n              }\n\n              this._syncInProgress = false;\n              this._requestsAddedDuringSync = false;\n            }\n          };\n          event.waitUntil(syncComplete());\n        }\n      });\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Background sync replaying without background sync event`);\n      }\n      // If the browser doesn't support background sync, retry\n      // every time the service worker starts up as a fallback.\n      this._onSync({queue: this});\n    }\n  }\n\n  /**\n   * Returns the set of queue names. This is primarily used to reset the list\n   * of queue names in tests.\n   *\n   * @return {Set}\n   *\n   * @private\n   */\n  static get _queueNames() {\n    return queueNames;\n  }\n}\n\n\n/**\n * Converts a QueueStore entry into the format exposed by Queue. This entails\n * converting the request data into a real request and omitting the `id` and\n * `queueName` properties.\n *\n * @param {Object} queueStoreEntry\n * @return {Object}\n * @private\n */\nconst convertEntry = (queueStoreEntry) => {\n  const queueEntry = {\n    request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n    timestamp: queueStoreEntry.timestamp,\n  };\n  if (queueStoreEntry.metadata) {\n    queueEntry.metadata = queueStoreEntry.metadata;\n  }\n  return queueEntry;\n};\n\nexport {Queue};\n"]},"metadata":{},"sourceType":"module"}