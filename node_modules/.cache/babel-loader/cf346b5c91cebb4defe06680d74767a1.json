{"ast":null,"code":"/**\n * @fileoverview disallow unncessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\n\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\n\n\nfunction isConcatOperatorToken(token) {\n  return token.value === \"+\" && token.type === \"Punctuator\";\n}\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\n\n\nfunction getLeft(node) {\n  let left = node.left;\n\n  while (isConcatenation(left)) {\n    left = left.right;\n  }\n\n  return left;\n}\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\n\n\nfunction getRight(node) {\n  let right = node.right;\n\n  while (isConcatenation(right)) {\n    right = right.left;\n  }\n\n  return right;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary concatenation of literals or template literals\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-concat\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      BinaryExpression(node) {\n        // check if not concatenation\n        if (node.operator !== \"+\") {\n          return;\n        } // account for the `foo + \"a\" + \"b\"` case\n\n\n        const left = getLeft(node);\n        const right = getRight(node);\n\n        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {\n          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n          context.report({\n            node,\n            loc: operatorToken.loc.start,\n            message: \"Unexpected string concatenation of literals.\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-useless-concat.js"],"names":["astUtils","require","isConcatenation","node","type","operator","isConcatOperatorToken","token","value","getLeft","left","right","getRight","module","exports","meta","docs","description","category","recommended","url","schema","create","context","sourceCode","getSourceCode","BinaryExpression","isStringLiteral","isTokenOnSameLine","operatorToken","getFirstTokenBetween","report","loc","start","message"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;;;;;;;AAKA,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAC3B,SAAOA,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACE,QAAL,KAAkB,GAA7D;AACH;AAED;;;;;;;AAKA,SAASC,qBAAT,CAA+BC,KAA/B,EAAsC;AAClC,SAAOA,KAAK,CAACC,KAAN,KAAgB,GAAhB,IAAuBD,KAAK,CAACH,IAAN,KAAe,YAA7C;AACH;AAED;;;;;;;AAKA,SAASK,OAAT,CAAiBN,IAAjB,EAAuB;AACnB,MAAIO,IAAI,GAAGP,IAAI,CAACO,IAAhB;;AAEA,SAAOR,eAAe,CAACQ,IAAD,CAAtB,EAA8B;AAC1BA,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAZ;AACH;;AACD,SAAOD,IAAP;AACH;AAED;;;;;;;AAKA,SAASE,QAAT,CAAkBT,IAAlB,EAAwB;AACpB,MAAIQ,KAAK,GAAGR,IAAI,CAACQ,KAAjB;;AAEA,SAAOT,eAAe,CAACS,KAAD,CAAtB,EAA+B;AAC3BA,IAAAA,KAAK,GAAGA,KAAK,CAACD,IAAd;AACH;;AACD,SAAOC,KAAP;AACH,C,CAED;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFX,IAAAA,IAAI,EAAE,YADJ;AAGFY,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,qEADX;AAEFC,MAAAA,QAAQ,EAAE,gBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE;AAVN,GADO;;AAcbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AAEA,WAAO;AACHC,MAAAA,gBAAgB,CAACvB,IAAD,EAAO;AAEnB;AACA,YAAIA,IAAI,CAACE,QAAL,KAAkB,GAAtB,EAA2B;AACvB;AACH,SALkB,CAOnB;;;AACA,cAAMK,IAAI,GAAGD,OAAO,CAACN,IAAD,CAApB;AACA,cAAMQ,KAAK,GAAGC,QAAQ,CAACT,IAAD,CAAtB;;AAEA,YAAIH,QAAQ,CAAC2B,eAAT,CAAyBjB,IAAzB,KACAV,QAAQ,CAAC2B,eAAT,CAAyBhB,KAAzB,CADA,IAEAX,QAAQ,CAAC4B,iBAAT,CAA2BlB,IAA3B,EAAiCC,KAAjC,CAFJ,EAGE;AACE,gBAAMkB,aAAa,GAAGL,UAAU,CAACM,oBAAX,CAAgCpB,IAAhC,EAAsCC,KAAtC,EAA6CL,qBAA7C,CAAtB;AAEAiB,UAAAA,OAAO,CAACQ,MAAR,CAAe;AACX5B,YAAAA,IADW;AAEX6B,YAAAA,GAAG,EAAEH,aAAa,CAACG,GAAd,CAAkBC,KAFZ;AAGXC,YAAAA,OAAO,EAAE;AAHE,WAAf;AAKH;AACJ;;AAxBE,KAAP;AA0BH;;AA3CY,CAAjB","sourcesContent":["/**\n * @fileoverview disallow unncessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-concat\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc.start,\n                        message: \"Unexpected string concatenation of literals.\"\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}