{"ast":null,"code":"/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst debug = require('debug')('istanbuljs');\n\nconst SMC = require('source-map').SourceMapConsumer;\n\nconst pathutils = require('./pathutils');\n\nconst sourceStore = require('./source-store');\n\nconst transformer = require('./transformer');\n/**\n * Tracks source maps for registered files\n */\n\n\nclass MapStore {\n  /**\n   * @param {Object} opts [opts=undefined] options.\n   * @param {Boolean} opts.verbose [opts.verbose=false] verbose mode\n   * @param {String} opts.baseDir [opts.baseDir=null] alternate base directory\n   *  to resolve sourcemap files\n   * @param {String} opts.sourceStore [opts.sourceStore='memory'] - store that tracks\n   *  embedded sources found in source maps, one of 'memory' or 'file'\n   * @param {String} opts.tmpdir [opts.tmpdir=undefined] - temporary directory\n   *   to use for storing files.\n   * @constructor\n   */\n  constructor(opts = {}) {\n    this.baseDir = opts.baseDir || null;\n    this.verbose = opts.verbose || false;\n    this.sourceStore = sourceStore.create(opts.sourceStore, {\n      tmpdir: opts.tmpdir\n    });\n    this.data = Object.create(null);\n  }\n  /**\n   * Registers a source map URL with this store. It makes some input sanity checks\n   * and silently fails on malformed input.\n   * @param transformedFilePath - the file path for which the source map is valid.\n   *  This must *exactly* match the path stashed for the coverage object to be\n   *  useful.\n   * @param sourceMapUrl - the source map URL, **not** a comment\n   */\n\n\n  registerURL(transformedFilePath, sourceMapUrl) {\n    const d = 'data:';\n\n    if (sourceMapUrl.length > d.length && sourceMapUrl.substring(0, d.length) === d) {\n      const b64 = 'base64,';\n      const pos = sourceMapUrl.indexOf(b64);\n\n      if (pos > 0) {\n        this.data[transformedFilePath] = {\n          type: 'encoded',\n          data: sourceMapUrl.substring(pos + b64.length)\n        };\n      } else {\n        debug(`Unable to interpret source map URL: ${sourceMapUrl}`);\n      }\n\n      return;\n    }\n\n    const dir = path.dirname(path.resolve(transformedFilePath));\n    const file = path.resolve(dir, sourceMapUrl);\n    this.data[transformedFilePath] = {\n      type: 'file',\n      data: file\n    };\n  }\n  /**\n   * Registers a source map object with this store. Makes some basic sanity checks\n   * and silently fails on malformed input.\n   * @param transformedFilePath - the file path for which the source map is valid\n   * @param sourceMap - the source map object\n   */\n\n\n  registerMap(transformedFilePath, sourceMap) {\n    if (sourceMap && sourceMap.version) {\n      this.data[transformedFilePath] = {\n        type: 'object',\n        data: sourceMap\n      };\n    } else {\n      debug('Invalid source map object: ' + JSON.stringify(sourceMap, null, 2));\n    }\n  }\n  /**\n   * Transforms the coverage map provided into one that refers to original\n   * sources when valid mappings have been registered with this store.\n   * @param {CoverageMap} coverageMap - the coverage map to transform\n   * @returns {Object} an object with 2 properties. `map` for the transformed\n   * coverage map and `sourceFinder` which is a function to return the source\n   * text for a file.\n   */\n\n\n  transformCoverage(coverageMap) {\n    const sourceFinder = filePath => {\n      const content = this.sourceStore.getSource(filePath);\n\n      if (content !== null) {\n        return content;\n      }\n\n      if (path.isAbsolute(filePath)) {\n        return fs.readFileSync(filePath, 'utf8');\n      }\n\n      return fs.readFileSync(pathutils.asAbsolute(filePath, this.baseDir));\n    };\n\n    coverageMap.files().forEach(file => {\n      const coverage = coverageMap.fileCoverageFor(file);\n\n      if (coverage.data.inputSourceMap && !this.data[file]) {\n        this.registerMap(file, coverage.data.inputSourceMap);\n      }\n    });\n\n    if (Object.keys(this.data).length === 0) {\n      return {\n        map: coverageMap,\n        sourceFinder\n      };\n    }\n\n    const mappedCoverage = transformer.create(filePath => {\n      try {\n        if (!this.data[filePath]) {\n          return null;\n        }\n\n        const d = this.data[filePath];\n        let obj;\n\n        if (d.type === 'file') {\n          obj = JSON.parse(fs.readFileSync(d.data, 'utf8'));\n        } else if (d.type === 'encoded') {\n          obj = JSON.parse(Buffer.from(d.data, 'base64').toString());\n        } else {\n          obj = d.data;\n        }\n\n        const smc = new SMC(obj);\n        smc.sources.forEach(s => {\n          const content = smc.sourceContentFor(s);\n\n          if (content) {\n            const sourceFilePath = pathutils.relativeTo(s, filePath);\n            this.sourceStore.registerSource(sourceFilePath, content);\n          }\n        });\n        return smc;\n      } catch (error) {\n        debug('Error returning source map for ' + filePath);\n        debug(error.stack);\n        return null;\n      }\n    }).transform(coverageMap);\n    return {\n      map: mappedCoverage,\n      sourceFinder\n    };\n  }\n  /**\n   * Disposes temporary resources allocated by this map store\n   */\n\n\n  dispose() {\n    this.sourceStore.dispose();\n  }\n\n}\n\nmodule.exports = {\n  MapStore\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-source-maps/lib/map-store.js"],"names":["path","require","fs","debug","SMC","SourceMapConsumer","pathutils","sourceStore","transformer","MapStore","constructor","opts","baseDir","verbose","create","tmpdir","data","Object","registerURL","transformedFilePath","sourceMapUrl","d","length","substring","b64","pos","indexOf","type","dir","dirname","resolve","file","registerMap","sourceMap","version","JSON","stringify","transformCoverage","coverageMap","sourceFinder","filePath","content","getSource","isAbsolute","readFileSync","asAbsolute","files","forEach","coverage","fileCoverageFor","inputSourceMap","keys","map","mappedCoverage","obj","parse","Buffer","from","toString","smc","sources","s","sourceContentFor","sourceFilePath","relativeTo","registerSource","error","stack","transform","dispose","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\nconst debug = require('debug')('istanbuljs');\nconst SMC = require('source-map').SourceMapConsumer;\nconst pathutils = require('./pathutils');\nconst sourceStore = require('./source-store');\nconst transformer = require('./transformer');\n\n/**\n * Tracks source maps for registered files\n */\nclass MapStore {\n    /**\n     * @param {Object} opts [opts=undefined] options.\n     * @param {Boolean} opts.verbose [opts.verbose=false] verbose mode\n     * @param {String} opts.baseDir [opts.baseDir=null] alternate base directory\n     *  to resolve sourcemap files\n     * @param {String} opts.sourceStore [opts.sourceStore='memory'] - store that tracks\n     *  embedded sources found in source maps, one of 'memory' or 'file'\n     * @param {String} opts.tmpdir [opts.tmpdir=undefined] - temporary directory\n     *   to use for storing files.\n     * @constructor\n     */\n    constructor(opts = {}) {\n        this.baseDir = opts.baseDir || null;\n        this.verbose = opts.verbose || false;\n        this.sourceStore = sourceStore.create(opts.sourceStore, {\n            tmpdir: opts.tmpdir\n        });\n        this.data = Object.create(null);\n    }\n\n    /**\n     * Registers a source map URL with this store. It makes some input sanity checks\n     * and silently fails on malformed input.\n     * @param transformedFilePath - the file path for which the source map is valid.\n     *  This must *exactly* match the path stashed for the coverage object to be\n     *  useful.\n     * @param sourceMapUrl - the source map URL, **not** a comment\n     */\n    registerURL(transformedFilePath, sourceMapUrl) {\n        const d = 'data:';\n\n        if (\n            sourceMapUrl.length > d.length &&\n            sourceMapUrl.substring(0, d.length) === d\n        ) {\n            const b64 = 'base64,';\n            const pos = sourceMapUrl.indexOf(b64);\n            if (pos > 0) {\n                this.data[transformedFilePath] = {\n                    type: 'encoded',\n                    data: sourceMapUrl.substring(pos + b64.length)\n                };\n            } else {\n                debug(`Unable to interpret source map URL: ${sourceMapUrl}`);\n            }\n\n            return;\n        }\n\n        const dir = path.dirname(path.resolve(transformedFilePath));\n        const file = path.resolve(dir, sourceMapUrl);\n        this.data[transformedFilePath] = { type: 'file', data: file };\n    }\n\n    /**\n     * Registers a source map object with this store. Makes some basic sanity checks\n     * and silently fails on malformed input.\n     * @param transformedFilePath - the file path for which the source map is valid\n     * @param sourceMap - the source map object\n     */\n    registerMap(transformedFilePath, sourceMap) {\n        if (sourceMap && sourceMap.version) {\n            this.data[transformedFilePath] = {\n                type: 'object',\n                data: sourceMap\n            };\n        } else {\n            debug(\n                'Invalid source map object: ' +\n                    JSON.stringify(sourceMap, null, 2)\n            );\n        }\n    }\n\n    /**\n     * Transforms the coverage map provided into one that refers to original\n     * sources when valid mappings have been registered with this store.\n     * @param {CoverageMap} coverageMap - the coverage map to transform\n     * @returns {Object} an object with 2 properties. `map` for the transformed\n     * coverage map and `sourceFinder` which is a function to return the source\n     * text for a file.\n     */\n    transformCoverage(coverageMap) {\n        const sourceFinder = filePath => {\n            const content = this.sourceStore.getSource(filePath);\n            if (content !== null) {\n                return content;\n            }\n\n            if (path.isAbsolute(filePath)) {\n                return fs.readFileSync(filePath, 'utf8');\n            }\n\n            return fs.readFileSync(\n                pathutils.asAbsolute(filePath, this.baseDir)\n            );\n        };\n\n        coverageMap.files().forEach(file => {\n            const coverage = coverageMap.fileCoverageFor(file);\n            if (coverage.data.inputSourceMap && !this.data[file]) {\n                this.registerMap(file, coverage.data.inputSourceMap);\n            }\n        });\n\n        if (Object.keys(this.data).length === 0) {\n            return {\n                map: coverageMap,\n                sourceFinder\n            };\n        }\n\n        const mappedCoverage = transformer\n            .create(filePath => {\n                try {\n                    if (!this.data[filePath]) {\n                        return null;\n                    }\n\n                    const d = this.data[filePath];\n                    let obj;\n                    if (d.type === 'file') {\n                        obj = JSON.parse(fs.readFileSync(d.data, 'utf8'));\n                    } else if (d.type === 'encoded') {\n                        obj = JSON.parse(\n                            Buffer.from(d.data, 'base64').toString()\n                        );\n                    } else {\n                        obj = d.data;\n                    }\n\n                    const smc = new SMC(obj);\n                    smc.sources.forEach(s => {\n                        const content = smc.sourceContentFor(s);\n                        if (content) {\n                            const sourceFilePath = pathutils.relativeTo(\n                                s,\n                                filePath\n                            );\n                            this.sourceStore.registerSource(\n                                sourceFilePath,\n                                content\n                            );\n                        }\n                    });\n\n                    return smc;\n                } catch (error) {\n                    debug('Error returning source map for ' + filePath);\n                    debug(error.stack);\n\n                    return null;\n                }\n            })\n            .transform(coverageMap);\n\n        return {\n            map: mappedCoverage,\n            sourceFinder\n        };\n    }\n\n    /**\n     * Disposes temporary resources allocated by this map store\n     */\n    dispose() {\n        this.sourceStore.dispose();\n    }\n}\n\nmodule.exports = { MapStore };\n"]},"metadata":{},"sourceType":"script"}