{"ast":null,"code":"// Generated by LiveScript 1.6.0\n(function () {\n  var VERSION,\n      ref$,\n      id,\n      map,\n      compact,\n      any,\n      groupBy,\n      partition,\n      chars,\n      isItNaN,\n      keys,\n      Obj,\n      camelize,\n      deepIs,\n      closestString,\n      nameToRaw,\n      dasherize,\n      naturalJoin,\n      generateHelp,\n      generateHelpForOption,\n      parsedTypeCheck,\n      parseType,\n      parseLevn,\n      camelizeKeys,\n      parseString,\n      main,\n      toString$ = {}.toString,\n      slice$ = [].slice,\n      arrayFrom$ = Array.from || function (x) {\n    return slice$.call(x);\n  };\n\n  VERSION = '0.8.3';\n  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;\n  deepIs = require('deep-is');\n  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;\n  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;\n  parseLevn = require('levn').parsedTypeParse;\n\n  camelizeKeys = function (obj) {\n    var key,\n        value,\n        resultObj$ = {};\n\n    for (key in obj) {\n      value = obj[key];\n      resultObj$[camelize(key)] = value;\n    }\n\n    return resultObj$;\n  };\n\n  parseString = function (string) {\n    var assignOpt, regex, replaceRegex, result;\n    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';\n    regex = RegExp('(?:' + assignOpt + ')?(?:\\'(?:\\\\\\\\\\'|[^\\'])+\\'|\"(?:\\\\\\\\\"|[^\"])+\")|[^\\'\"\\\\s]+', 'g');\n    replaceRegex = RegExp('^(' + assignOpt + ')?[\\'\"]([\\\\s\\\\S]*)[\\'\"]$');\n    result = map(function (it) {\n      return it.replace(replaceRegex, '$1$2');\n    }, string.match(regex) || []);\n    return result;\n  };\n\n  main = function (libOptions) {\n    var opts, defaults, required, traverse, getOption, parse;\n    opts = {};\n    defaults = {};\n    required = [];\n\n    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {\n      libOptions.stdout = process.stdout;\n    }\n\n    libOptions.positionalAnywhere == null && (libOptions.positionalAnywhere = true);\n    libOptions.typeAliases == null && (libOptions.typeAliases = {});\n    libOptions.defaults == null && (libOptions.defaults = {});\n\n    if (libOptions.concatRepeatedArrays != null) {\n      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;\n    }\n\n    if (libOptions.mergeRepeatedObjects != null) {\n      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;\n    }\n\n    traverse = function (options) {\n      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;\n\n      if (toString$.call(options).slice(8, -1) !== 'Array') {\n        throw new Error('No options defined.');\n      }\n\n      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {\n        option = options[i$];\n\n        if (option.heading == null) {\n          name = option.option;\n\n          if (opts[name] != null) {\n            throw new Error(\"Option '\" + name + \"' already defined.\");\n          }\n\n          for (k in ref$ = libOptions.defaults) {\n            v = ref$[k];\n            option[k] == null && (option[k] = v);\n          }\n\n          if (option.type === 'Boolean') {\n            option.boolean == null && (option.boolean = true);\n          }\n\n          if (option.parsedType == null) {\n            if (!option.type) {\n              throw new Error(\"No type defined for option '\" + name + \"'.\");\n            }\n\n            try {\n              type = (that = libOptions.typeAliases[option.type]) != null ? that : option.type;\n              option.parsedType = parseType(type);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing type '\" + option.type + \"': \" + e.message);\n            }\n          }\n\n          if (option['default']) {\n            try {\n              defaults[name] = parseLevn(option.parsedType, option['default']);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing default value '\" + option['default'] + \"' for type '\" + option.type + \"': \" + e.message);\n            }\n          }\n\n          if (option['enum'] && !option.parsedPossiblities) {\n            parsedPossibilities = [];\n            parsedType = option.parsedType;\n\n            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {\n              possibility = ref$[j$];\n\n              try {\n                parsedPossibilities.push(parseLevn(parsedType, possibility));\n              } catch (e$) {\n                e = e$;\n                throw new Error(\"Option '\" + name + \"': Error parsing enum value '\" + possibility + \"' for type '\" + option.type + \"': \" + e.message);\n              }\n            }\n\n            option.parsedPossibilities = parsedPossibilities;\n          }\n\n          if (that = option.dependsOn) {\n            if (that.length) {\n              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);\n              dependsType = rawDependsType.toLowerCase();\n\n              if (dependsOpts.length) {\n                if (dependsType === 'and' || dependsType === 'or') {\n                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));\n                } else {\n                  throw new Error(\"Option '\" + name + \"': If you have more than one dependency, you must specify either 'and' or 'or'\");\n                }\n              } else {\n                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {\n                  option.dependsOn = null;\n                } else {\n                  option.dependsOn = ['and', rawDependsType];\n                }\n              }\n            } else {\n              option.dependsOn = null;\n            }\n          }\n\n          if (option.required) {\n            required.push(name);\n          }\n\n          opts[name] = option;\n\n          if (option.concatRepeatedArrays != null) {\n            cra = option.concatRepeatedArrays;\n\n            if ('Boolean' === toString$.call(cra).slice(8, -1)) {\n              option.concatRepeatedArrays = [cra, {}];\n            } else if (cra.length === 1) {\n              option.concatRepeatedArrays = [cra[0], {}];\n            } else if (cra.length !== 2) {\n              throw new Error(\"Invalid setting for concatRepeatedArrays\");\n            }\n          }\n\n          if (option.alias || option.aliases) {\n            if (name === 'NUM') {\n              throw new Error(\"-NUM option can't have aliases.\");\n            }\n\n            if (option.alias) {\n              option.aliases == null && (option.aliases = [].concat(option.alias));\n            }\n\n            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {\n              alias = ref$[j$];\n\n              if (opts[alias] != null) {\n                throw new Error(\"Option '\" + alias + \"' already defined.\");\n              }\n\n              opts[alias] = option;\n            }\n\n            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];\n            option.shortNames == null && (option.shortNames = shortNames);\n            option.longNames == null && (option.longNames = longNames);\n          }\n\n          if ((!option.aliases || option.shortNames.length === 0) && option.type === 'Boolean' && option['default'] === 'true') {\n            option.negateName = true;\n          }\n        }\n      }\n\n      function fn$(it) {\n        return it.length === 1;\n      }\n    };\n\n    traverse(libOptions.options);\n\n    getOption = function (name) {\n      var opt, possiblyMeant;\n      opt = opts[name];\n\n      if (opt == null) {\n        possiblyMeant = closestString(keys(opts), name);\n        throw new Error(\"Invalid option '\" + nameToRaw(name) + \"'\" + (possiblyMeant ? \" - perhaps you meant '\" + nameToRaw(possiblyMeant) + \"'?\" : '.'));\n      }\n\n      return opt;\n    };\n\n    parse = function (input, arg$) {\n      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;\n      slice = (arg$ != null ? arg$ : {}).slice;\n      obj = {};\n      positional = [];\n      restPositional = false;\n      overrideRequired = false;\n      prop = null;\n\n      setValue = function (name, value) {\n        var opt, val, cra, e, currentType;\n        opt = getOption(name);\n\n        if (opt.boolean) {\n          val = value;\n        } else {\n          try {\n            cra = opt.concatRepeatedArrays;\n\n            if (cra != null && cra[0] && cra[1].oneValuePerFlag && opt.parsedType.length === 1 && opt.parsedType[0].structure === 'array') {\n              val = [parseLevn(opt.parsedType[0].of, value)];\n            } else {\n              val = parseLevn(opt.parsedType, value);\n            }\n          } catch (e$) {\n            e = e$;\n            throw new Error(\"Invalid value for option '\" + name + \"' - expected type \" + opt.type + \", received value: \" + value + \".\");\n          }\n\n          if (opt['enum'] && !any(function (it) {\n            return deepIs(it, val);\n          }, opt.parsedPossibilities)) {\n            throw new Error(\"Option \" + name + \": '\" + val + \"' not one of \" + naturalJoin(opt['enum']) + \".\");\n          }\n        }\n\n        currentType = toString$.call(obj[name]).slice(8, -1);\n\n        if (obj[name] != null) {\n          if (opt.concatRepeatedArrays != null && opt.concatRepeatedArrays[0] && currentType === 'Array') {\n            obj[name] = obj[name].concat(val);\n          } else if (opt.mergeRepeatedObjects && currentType === 'Object') {\n            import$(obj[name], val);\n          } else {\n            obj[name] = val;\n          }\n        } else {\n          obj[name] = val;\n        }\n\n        if (opt.restPositional) {\n          restPositional = true;\n        }\n\n        if (opt.overrideRequired) {\n          overrideRequired = true;\n        }\n      };\n\n      setDefaults = function () {\n        var name, ref$, value;\n\n        for (name in ref$ = defaults) {\n          value = ref$[name];\n\n          if (obj[name] == null) {\n            obj[name] = value;\n          }\n        }\n      };\n\n      checkRequired = function () {\n        var i$, ref$, len$, name;\n\n        if (overrideRequired) {\n          return;\n        }\n\n        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {\n          name = ref$[i$];\n\n          if (!obj[name]) {\n            throw new Error(\"Option \" + nameToRaw(name) + \" is required.\");\n          }\n        }\n      };\n\n      mutuallyExclusiveError = function (first, second) {\n        throw new Error(\"The options \" + nameToRaw(first) + \" and \" + nameToRaw(second) + \" are mutually exclusive - you cannot use them at the same time.\");\n      };\n\n      checkMutuallyExclusive = function () {\n        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;\n        rules = libOptions.mutuallyExclusive;\n\n        if (!rules) {\n          return;\n        }\n\n        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {\n          rule = rules[i$];\n          present = null;\n\n          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {\n            element = rule[j$];\n\n            if (toString$.call(element).slice(8, -1) === 'Array') {\n              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {\n                opt = element[k$];\n\n                if (opt in obj) {\n                  if (present != null) {\n                    mutuallyExclusiveError(present, opt);\n                  } else {\n                    present = opt;\n                    break;\n                  }\n                }\n              }\n            } else {\n              if (element in obj) {\n                if (present != null) {\n                  mutuallyExclusiveError(present, element);\n                } else {\n                  present = element;\n                }\n              }\n            }\n          }\n        }\n      };\n\n      checkDependency = function (option) {\n        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;\n        dependsOn = option.dependsOn;\n\n        if (!dependsOn || option.dependenciesMet) {\n          return true;\n        }\n\n        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);\n\n        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {\n          targetOptionName = targetOptionNames[i$];\n          targetOption = obj[targetOptionName];\n\n          if (targetOption && checkDependency(targetOption)) {\n            if (type === 'or') {\n              return true;\n            }\n          } else if (type === 'and') {\n            throw new Error(\"The option '\" + option.option + \"' did not have its dependencies met.\");\n          }\n        }\n\n        if (type === 'and') {\n          return true;\n        } else {\n          throw new Error(\"The option '\" + option.option + \"' did not meet any of its dependencies.\");\n        }\n      };\n\n      checkDependencies = function () {\n        var name;\n\n        for (name in obj) {\n          checkDependency(opts[name]);\n        }\n      };\n\n      checkProp = function () {\n        if (prop) {\n          throw new Error(\"Value for '\" + prop + \"' of type '\" + getOption(prop).type + \"' required.\");\n        }\n      };\n\n      switch (toString$.call(input).slice(8, -1)) {\n        case 'String':\n          args = parseString(input.slice(slice != null ? slice : 0));\n          break;\n\n        case 'Array':\n          args = input.slice(slice != null ? slice : 2);\n          break;\n\n        case 'Object':\n          obj = {};\n\n          for (key in input) {\n            value = input[key];\n\n            if (key !== '_') {\n              option = getOption(dasherize(key));\n\n              if (parsedTypeCheck(option.parsedType, value)) {\n                obj[option.option] = value;\n              } else {\n                throw new Error(\"Option '\" + option.option + \"': Invalid type for '\" + value + \"' - expected type '\" + option.type + \"'.\");\n              }\n            }\n          }\n\n          checkMutuallyExclusive();\n          checkDependencies();\n          setDefaults();\n          checkRequired();\n          return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;\n\n        default:\n          throw new Error(\"Invalid argument to 'parse': \" + input + \".\");\n      }\n\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        arg = args[i$];\n\n        if (arg === '--') {\n          restPositional = true;\n        } else if (restPositional) {\n          positional.push(arg);\n        } else {\n          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {\n            result = that;\n            checkProp();\n            short = result[1].length === 1;\n            argName = result[2];\n            usingAssign = result[3] != null;\n            val = result[4];\n\n            if (usingAssign && val == null) {\n              throw new Error(\"No value for '\" + argName + \"' specified.\");\n            }\n\n            if (short) {\n              flags = chars(argName);\n              len = flags.length;\n\n              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {\n                i = j$;\n                flag = flags[j$];\n                opt = getOption(flag);\n                name = opt.option;\n\n                if (restPositional) {\n                  positional.push(flag);\n                } else if (i === len - 1) {\n                  if (usingAssign) {\n                    valPrime = opt.boolean ? parseLevn([{\n                      type: 'Boolean'\n                    }], val) : val;\n                    setValue(name, valPrime);\n                  } else if (opt.boolean) {\n                    setValue(name, true);\n                  } else {\n                    prop = name;\n                  }\n                } else if (opt.boolean) {\n                  setValue(name, true);\n                } else {\n                  throw new Error(\"Can't set argument '\" + flag + \"' when not last flag in a group of short flags.\");\n                }\n              }\n            } else {\n              negated = false;\n\n              if (that = argName.match(/^no-(.+)$/)) {\n                negated = true;\n                noedName = that[1];\n                opt = getOption(noedName);\n              } else {\n                opt = getOption(argName);\n              }\n\n              name = opt.option;\n\n              if (opt.boolean) {\n                valPrime = usingAssign ? parseLevn([{\n                  type: 'Boolean'\n                }], val) : true;\n\n                if (negated) {\n                  setValue(name, !valPrime);\n                } else {\n                  setValue(name, valPrime);\n                }\n              } else {\n                if (negated) {\n                  throw new Error(\"Only use 'no-' prefix for Boolean options, not with '\" + noedName + \"'.\");\n                }\n\n                if (usingAssign) {\n                  setValue(name, val);\n                } else {\n                  prop = name;\n                }\n              }\n            }\n          } else if (that = arg.match(/^-([0-9]+(?:\\.[0-9]+)?)$/)) {\n            opt = opts.NUM;\n\n            if (!opt) {\n              throw new Error('No -NUM option defined.');\n            }\n\n            setValue(opt.option, that[1]);\n          } else {\n            if (prop) {\n              setValue(prop, arg);\n              prop = null;\n            } else {\n              positional.push(arg);\n\n              if (!libOptions.positionalAnywhere) {\n                restPositional = true;\n              }\n            }\n          }\n        }\n      }\n\n      checkProp();\n      checkMutuallyExclusive();\n      checkDependencies();\n      setDefaults();\n      checkRequired();\n      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;\n    };\n\n    return {\n      parse: parse,\n      parseArgv: function (it) {\n        return parse(it, {\n          slice: 2\n        });\n      },\n      generateHelp: generateHelp(libOptions),\n      generateHelpForOption: generateHelpForOption(getOption, libOptions)\n    };\n  };\n\n  main.VERSION = VERSION;\n  module.exports = main;\n\n  function import$(obj, src) {\n    var own = {}.hasOwnProperty;\n\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n\n    return obj;\n  }\n}).call(this);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/optionator/lib/index.js"],"names":["VERSION","ref$","id","map","compact","any","groupBy","partition","chars","isItNaN","keys","Obj","camelize","deepIs","closestString","nameToRaw","dasherize","naturalJoin","generateHelp","generateHelpForOption","parsedTypeCheck","parseType","parseLevn","camelizeKeys","parseString","main","toString$","toString","slice$","slice","arrayFrom$","Array","from","x","call","require","parsedTypeParse","obj","key","value","resultObj$","string","assignOpt","regex","replaceRegex","result","RegExp","it","replace","match","libOptions","opts","defaults","required","traverse","getOption","parse","stdout","process","positionalAnywhere","typeAliases","concatRepeatedArrays","mergeRepeatedObjects","options","i$","len$","option","name","k","v","type","that","e","parsedPossibilities","parsedType","j$","len1$","possibility","rawDependsType","dependsOpts","dependsType","cra","alias","shortNames","longNames","Error","length","heading","boolean","e$","message","parsedPossiblities","push","dependsOn","concat","toLowerCase","aliases","fn$","negateName","opt","possiblyMeant","input","arg$","positional","restPositional","overrideRequired","prop","setValue","setDefaults","checkRequired","mutuallyExclusiveError","checkMutuallyExclusive","checkDependency","checkDependencies","checkProp","args","arg","short","argName","usingAssign","val","flags","len","i","flag","valPrime","negated","noedName","currentType","oneValuePerFlag","structure","of","import$","first","second","rules","rule","present","element","k$","len2$","mutuallyExclusive","targetOptionNames","targetOptionName","targetOption","dependenciesMet","_","NUM","parseArgv","module","exports","src","own","hasOwnProperty"],"mappings":"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","sourcesContent":["// Generated by LiveScript 1.6.0\n(function(){\n  var VERSION, ref$, id, map, compact, any, groupBy, partition, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, naturalJoin, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};\n  VERSION = '0.8.3';\n  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;\n  deepIs = require('deep-is');\n  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;\n  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;\n  parseLevn = require('levn').parsedTypeParse;\n  camelizeKeys = function(obj){\n    var key, value, resultObj$ = {};\n    for (key in obj) {\n      value = obj[key];\n      resultObj$[camelize(key)] = value;\n    }\n    return resultObj$;\n  };\n  parseString = function(string){\n    var assignOpt, regex, replaceRegex, result;\n    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';\n    regex = RegExp('(?:' + assignOpt + ')?(?:\\'(?:\\\\\\\\\\'|[^\\'])+\\'|\"(?:\\\\\\\\\"|[^\"])+\")|[^\\'\"\\\\s]+', 'g');\n    replaceRegex = RegExp('^(' + assignOpt + ')?[\\'\"]([\\\\s\\\\S]*)[\\'\"]$');\n    result = map(function(it){\n      return it.replace(replaceRegex, '$1$2');\n    }, string.match(regex) || []);\n    return result;\n  };\n  main = function(libOptions){\n    var opts, defaults, required, traverse, getOption, parse;\n    opts = {};\n    defaults = {};\n    required = [];\n    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {\n      libOptions.stdout = process.stdout;\n    }\n    libOptions.positionalAnywhere == null && (libOptions.positionalAnywhere = true);\n    libOptions.typeAliases == null && (libOptions.typeAliases = {});\n    libOptions.defaults == null && (libOptions.defaults = {});\n    if (libOptions.concatRepeatedArrays != null) {\n      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;\n    }\n    if (libOptions.mergeRepeatedObjects != null) {\n      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;\n    }\n    traverse = function(options){\n      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;\n      if (toString$.call(options).slice(8, -1) !== 'Array') {\n        throw new Error('No options defined.');\n      }\n      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {\n        option = options[i$];\n        if (option.heading == null) {\n          name = option.option;\n          if (opts[name] != null) {\n            throw new Error(\"Option '\" + name + \"' already defined.\");\n          }\n          for (k in ref$ = libOptions.defaults) {\n            v = ref$[k];\n            option[k] == null && (option[k] = v);\n          }\n          if (option.type === 'Boolean') {\n            option.boolean == null && (option.boolean = true);\n          }\n          if (option.parsedType == null) {\n            if (!option.type) {\n              throw new Error(\"No type defined for option '\" + name + \"'.\");\n            }\n            try {\n              type = (that = libOptions.typeAliases[option.type]) != null\n                ? that\n                : option.type;\n              option.parsedType = parseType(type);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['default']) {\n            try {\n              defaults[name] = parseLevn(option.parsedType, option['default']);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing default value '\" + option['default'] + \"' for type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['enum'] && !option.parsedPossiblities) {\n            parsedPossibilities = [];\n            parsedType = option.parsedType;\n            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {\n              possibility = ref$[j$];\n              try {\n                parsedPossibilities.push(parseLevn(parsedType, possibility));\n              } catch (e$) {\n                e = e$;\n                throw new Error(\"Option '\" + name + \"': Error parsing enum value '\" + possibility + \"' for type '\" + option.type + \"': \" + e.message);\n              }\n            }\n            option.parsedPossibilities = parsedPossibilities;\n          }\n          if (that = option.dependsOn) {\n            if (that.length) {\n              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);\n              dependsType = rawDependsType.toLowerCase();\n              if (dependsOpts.length) {\n                if (dependsType === 'and' || dependsType === 'or') {\n                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));\n                } else {\n                  throw new Error(\"Option '\" + name + \"': If you have more than one dependency, you must specify either 'and' or 'or'\");\n                }\n              } else {\n                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {\n                  option.dependsOn = null;\n                } else {\n                  option.dependsOn = ['and', rawDependsType];\n                }\n              }\n            } else {\n              option.dependsOn = null;\n            }\n          }\n          if (option.required) {\n            required.push(name);\n          }\n          opts[name] = option;\n          if (option.concatRepeatedArrays != null) {\n            cra = option.concatRepeatedArrays;\n            if ('Boolean' === toString$.call(cra).slice(8, -1)) {\n              option.concatRepeatedArrays = [cra, {}];\n            } else if (cra.length === 1) {\n              option.concatRepeatedArrays = [cra[0], {}];\n            } else if (cra.length !== 2) {\n              throw new Error(\"Invalid setting for concatRepeatedArrays\");\n            }\n          }\n          if (option.alias || option.aliases) {\n            if (name === 'NUM') {\n              throw new Error(\"-NUM option can't have aliases.\");\n            }\n            if (option.alias) {\n              option.aliases == null && (option.aliases = [].concat(option.alias));\n            }\n            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {\n              alias = ref$[j$];\n              if (opts[alias] != null) {\n                throw new Error(\"Option '\" + alias + \"' already defined.\");\n              }\n              opts[alias] = option;\n            }\n            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];\n            option.shortNames == null && (option.shortNames = shortNames);\n            option.longNames == null && (option.longNames = longNames);\n          }\n          if ((!option.aliases || option.shortNames.length === 0) && option.type === 'Boolean' && option['default'] === 'true') {\n            option.negateName = true;\n          }\n        }\n      }\n      function fn$(it){\n        return it.length === 1;\n      }\n    };\n    traverse(libOptions.options);\n    getOption = function(name){\n      var opt, possiblyMeant;\n      opt = opts[name];\n      if (opt == null) {\n        possiblyMeant = closestString(keys(opts), name);\n        throw new Error(\"Invalid option '\" + nameToRaw(name) + \"'\" + (possiblyMeant ? \" - perhaps you meant '\" + nameToRaw(possiblyMeant) + \"'?\" : '.'));\n      }\n      return opt;\n    };\n    parse = function(input, arg$){\n      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;\n      slice = (arg$ != null\n        ? arg$\n        : {}).slice;\n      obj = {};\n      positional = [];\n      restPositional = false;\n      overrideRequired = false;\n      prop = null;\n      setValue = function(name, value){\n        var opt, val, cra, e, currentType;\n        opt = getOption(name);\n        if (opt.boolean) {\n          val = value;\n        } else {\n          try {\n            cra = opt.concatRepeatedArrays;\n            if (cra != null && cra[0] && cra[1].oneValuePerFlag && opt.parsedType.length === 1 && opt.parsedType[0].structure === 'array') {\n              val = [parseLevn(opt.parsedType[0].of, value)];\n            } else {\n              val = parseLevn(opt.parsedType, value);\n            }\n          } catch (e$) {\n            e = e$;\n            throw new Error(\"Invalid value for option '\" + name + \"' - expected type \" + opt.type + \", received value: \" + value + \".\");\n          }\n          if (opt['enum'] && !any(function(it){\n            return deepIs(it, val);\n          }, opt.parsedPossibilities)) {\n            throw new Error(\"Option \" + name + \": '\" + val + \"' not one of \" + naturalJoin(opt['enum']) + \".\");\n          }\n        }\n        currentType = toString$.call(obj[name]).slice(8, -1);\n        if (obj[name] != null) {\n          if (opt.concatRepeatedArrays != null && opt.concatRepeatedArrays[0] && currentType === 'Array') {\n            obj[name] = obj[name].concat(val);\n          } else if (opt.mergeRepeatedObjects && currentType === 'Object') {\n            import$(obj[name], val);\n          } else {\n            obj[name] = val;\n          }\n        } else {\n          obj[name] = val;\n        }\n        if (opt.restPositional) {\n          restPositional = true;\n        }\n        if (opt.overrideRequired) {\n          overrideRequired = true;\n        }\n      };\n      setDefaults = function(){\n        var name, ref$, value;\n        for (name in ref$ = defaults) {\n          value = ref$[name];\n          if (obj[name] == null) {\n            obj[name] = value;\n          }\n        }\n      };\n      checkRequired = function(){\n        var i$, ref$, len$, name;\n        if (overrideRequired) {\n          return;\n        }\n        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {\n          name = ref$[i$];\n          if (!obj[name]) {\n            throw new Error(\"Option \" + nameToRaw(name) + \" is required.\");\n          }\n        }\n      };\n      mutuallyExclusiveError = function(first, second){\n        throw new Error(\"The options \" + nameToRaw(first) + \" and \" + nameToRaw(second) + \" are mutually exclusive - you cannot use them at the same time.\");\n      };\n      checkMutuallyExclusive = function(){\n        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;\n        rules = libOptions.mutuallyExclusive;\n        if (!rules) {\n          return;\n        }\n        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {\n          rule = rules[i$];\n          present = null;\n          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {\n            element = rule[j$];\n            if (toString$.call(element).slice(8, -1) === 'Array') {\n              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {\n                opt = element[k$];\n                if (opt in obj) {\n                  if (present != null) {\n                    mutuallyExclusiveError(present, opt);\n                  } else {\n                    present = opt;\n                    break;\n                  }\n                }\n              }\n            } else {\n              if (element in obj) {\n                if (present != null) {\n                  mutuallyExclusiveError(present, element);\n                } else {\n                  present = element;\n                }\n              }\n            }\n          }\n        }\n      };\n      checkDependency = function(option){\n        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;\n        dependsOn = option.dependsOn;\n        if (!dependsOn || option.dependenciesMet) {\n          return true;\n        }\n        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);\n        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {\n          targetOptionName = targetOptionNames[i$];\n          targetOption = obj[targetOptionName];\n          if (targetOption && checkDependency(targetOption)) {\n            if (type === 'or') {\n              return true;\n            }\n          } else if (type === 'and') {\n            throw new Error(\"The option '\" + option.option + \"' did not have its dependencies met.\");\n          }\n        }\n        if (type === 'and') {\n          return true;\n        } else {\n          throw new Error(\"The option '\" + option.option + \"' did not meet any of its dependencies.\");\n        }\n      };\n      checkDependencies = function(){\n        var name;\n        for (name in obj) {\n          checkDependency(opts[name]);\n        }\n      };\n      checkProp = function(){\n        if (prop) {\n          throw new Error(\"Value for '\" + prop + \"' of type '\" + getOption(prop).type + \"' required.\");\n        }\n      };\n      switch (toString$.call(input).slice(8, -1)) {\n      case 'String':\n        args = parseString(input.slice(slice != null ? slice : 0));\n        break;\n      case 'Array':\n        args = input.slice(slice != null ? slice : 2);\n        break;\n      case 'Object':\n        obj = {};\n        for (key in input) {\n          value = input[key];\n          if (key !== '_') {\n            option = getOption(dasherize(key));\n            if (parsedTypeCheck(option.parsedType, value)) {\n              obj[option.option] = value;\n            } else {\n              throw new Error(\"Option '\" + option.option + \"': Invalid type for '\" + value + \"' - expected type '\" + option.type + \"'.\");\n            }\n          }\n        }\n        checkMutuallyExclusive();\n        checkDependencies();\n        setDefaults();\n        checkRequired();\n        return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;\n      default:\n        throw new Error(\"Invalid argument to 'parse': \" + input + \".\");\n      }\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        arg = args[i$];\n        if (arg === '--') {\n          restPositional = true;\n        } else if (restPositional) {\n          positional.push(arg);\n        } else {\n          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {\n            result = that;\n            checkProp();\n            short = result[1].length === 1;\n            argName = result[2];\n            usingAssign = result[3] != null;\n            val = result[4];\n            if (usingAssign && val == null) {\n              throw new Error(\"No value for '\" + argName + \"' specified.\");\n            }\n            if (short) {\n              flags = chars(argName);\n              len = flags.length;\n              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {\n                i = j$;\n                flag = flags[j$];\n                opt = getOption(flag);\n                name = opt.option;\n                if (restPositional) {\n                  positional.push(flag);\n                } else if (i === len - 1) {\n                  if (usingAssign) {\n                    valPrime = opt.boolean ? parseLevn([{\n                      type: 'Boolean'\n                    }], val) : val;\n                    setValue(name, valPrime);\n                  } else if (opt.boolean) {\n                    setValue(name, true);\n                  } else {\n                    prop = name;\n                  }\n                } else if (opt.boolean) {\n                  setValue(name, true);\n                } else {\n                  throw new Error(\"Can't set argument '\" + flag + \"' when not last flag in a group of short flags.\");\n                }\n              }\n            } else {\n              negated = false;\n              if (that = argName.match(/^no-(.+)$/)) {\n                negated = true;\n                noedName = that[1];\n                opt = getOption(noedName);\n              } else {\n                opt = getOption(argName);\n              }\n              name = opt.option;\n              if (opt.boolean) {\n                valPrime = usingAssign ? parseLevn([{\n                  type: 'Boolean'\n                }], val) : true;\n                if (negated) {\n                  setValue(name, !valPrime);\n                } else {\n                  setValue(name, valPrime);\n                }\n              } else {\n                if (negated) {\n                  throw new Error(\"Only use 'no-' prefix for Boolean options, not with '\" + noedName + \"'.\");\n                }\n                if (usingAssign) {\n                  setValue(name, val);\n                } else {\n                  prop = name;\n                }\n              }\n            }\n          } else if (that = arg.match(/^-([0-9]+(?:\\.[0-9]+)?)$/)) {\n            opt = opts.NUM;\n            if (!opt) {\n              throw new Error('No -NUM option defined.');\n            }\n            setValue(opt.option, that[1]);\n          } else {\n            if (prop) {\n              setValue(prop, arg);\n              prop = null;\n            } else {\n              positional.push(arg);\n              if (!libOptions.positionalAnywhere) {\n                restPositional = true;\n              }\n            }\n          }\n        }\n      }\n      checkProp();\n      checkMutuallyExclusive();\n      checkDependencies();\n      setDefaults();\n      checkRequired();\n      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;\n    };\n    return {\n      parse: parse,\n      parseArgv: function(it){\n        return parse(it, {\n          slice: 2\n        });\n      },\n      generateHelp: generateHelp(libOptions),\n      generateHelpForOption: generateHelpForOption(getOption, libOptions)\n    };\n  };\n  main.VERSION = VERSION;\n  module.exports = main;\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}