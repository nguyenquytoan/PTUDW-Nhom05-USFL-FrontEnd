{"ast":null,"code":"/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\n\n\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n  return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\n\n\nfunction splitByLogicalOperator(operator, node) {\n  if (node.type === \"LogicalExpression\" && node.operator === operator) {\n    return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n  }\n\n  return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate conditions in if-else-if chains\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n     * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n     * @param {ASTNode} a First node.\n     * @param {ASTNode} b Second node.\n     * @returns {boolean} `true` if the nodes are considered to be equal.\n     */\n\n    function equal(a, b) {\n      if (a.type !== b.type) {\n        return false;\n      }\n\n      if (a.type === \"LogicalExpression\" && (a.operator === \"||\" || a.operator === \"&&\") && a.operator === b.operator) {\n        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);\n      }\n\n      return astUtils.equalTokens(a, b, sourceCode);\n    }\n\n    const isSubset = isSubsetByComparator.bind(null, equal);\n    return {\n      IfStatement(node) {\n        const test = node.test,\n              conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\" ? [test, ...splitByAnd(test)] : [test];\n        let current = node,\n            listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n        while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n          current = current.parent;\n          const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n          listToCheck = listToCheck.map(orOperands => orOperands.filter(orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))));\n\n          if (listToCheck.some(orOperands => orOperands.length === 0)) {\n            context.report({\n              node: test,\n              messageId: \"unexpected\"\n            });\n            break;\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-dupe-else-if.js"],"names":["astUtils","require","isSubsetByComparator","comparator","arrA","arrB","every","a","some","b","splitByLogicalOperator","operator","node","type","left","right","splitByOr","bind","splitByAnd","module","exports","meta","docs","description","category","recommended","url","schema","messages","unexpected","create","context","sourceCode","getSourceCode","equal","equalTokens","isSubset","IfStatement","test","conditionsToCheck","current","listToCheck","map","c","parent","alternate","currentOrOperands","orOperands","filter","orOperand","currentOrOperand","length","report","messageId"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n    return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\nfunction splitByLogicalOperator(operator, node) {\n    if (node.type === \"LogicalExpression\" && node.operator === operator) {\n        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n    }\n    return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate conditions in if-else-if chains\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n         * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n         * @param {ASTNode} a First node.\n         * @param {ASTNode} b Second node.\n         * @returns {boolean} `true` if the nodes are considered to be equal.\n         */\n        function equal(a, b) {\n            if (a.type !== b.type) {\n                return false;\n            }\n\n            if (\n                a.type === \"LogicalExpression\" &&\n                (a.operator === \"||\" || a.operator === \"&&\") &&\n                a.operator === b.operator\n            ) {\n                return equal(a.left, b.left) && equal(a.right, b.right) ||\n                    equal(a.left, b.right) && equal(a.right, b.left);\n            }\n\n            return astUtils.equalTokens(a, b, sourceCode);\n        }\n\n        const isSubset = isSubsetByComparator.bind(null, equal);\n\n        return {\n            IfStatement(node) {\n                const test = node.test,\n                    conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\"\n                        ? [test, ...splitByAnd(test)]\n                        : [test];\n                let current = node,\n                    listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n                while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n                    current = current.parent;\n\n                    const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n\n                    listToCheck = listToCheck.map(orOperands => orOperands.filter(\n                        orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))\n                    ));\n\n                    if (listToCheck.some(orOperands => orOperands.length === 0)) {\n                        context.report({ node: test, messageId: \"unexpected\" });\n                        break;\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}