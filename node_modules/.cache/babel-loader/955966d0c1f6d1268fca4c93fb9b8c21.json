{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar convertColors = require('@csstools/convert-colors');\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar parser = _interopDefault(require('postcss-values-parser'));\n\nvar index = postcss.plugin('postcss-lab-function', opts => {\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n  return root => {\n    root.walkDecls(decl => {\n      const value = decl.value;\n\n      if (colorAnyRegExp.test(value)) {\n        const ast = parser(value).parse();\n        ast.walkType('func', node => {\n          if (colorRegExp.test(node.value)) {\n            const children = node.nodes.slice(1, -1);\n            const isLab = labRegExp.test(node.value);\n            const isGray = grayRegExp.test(node.value);\n            const isFunctionalLAB = !isGray && matchFunctionalLAB(children);\n            const isFunctionalLCH = !isGray && matchFunctionalLCH(children);\n            const isFunctionalGray = isGray && matchFunctionalGray(children);\n\n            if (isFunctionalLAB || isFunctionalLCH) {\n              node.value = 'rgb';\n              const slashNode = children[3];\n              const alphaNode = children[4];\n\n              if (alphaNode) {\n                if (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n                  alphaNode.unit = '';\n                  alphaNode.value = String(alphaNode.value / 100);\n                }\n\n                if (alphaNode.value === '1') {\n                  slashNode.remove();\n                  alphaNode.remove();\n                } else {\n                  node.value += 'a';\n                }\n              }\n\n              if (slashNode && isSlash(slashNode)) {\n                slashNode.replaceWith(newComma());\n              }\n\n              const converter = isLab ? convertColors.lab2rgb : convertColors.lch2rgb;\n              const rgbValues = converter(...[children[0].value, children[1].value, children[2].value].map(number => parseFloat(number))).map(sourceValue => Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0));\n              children[0].value = String(rgbValues[0]);\n              children[1].value = String(rgbValues[1]);\n              children[2].value = String(rgbValues[2]);\n              node.nodes.splice(3, 0, [newComma()]);\n              node.nodes.splice(2, 0, [newComma()]);\n            } else if (isFunctionalGray) {\n              node.value = 'rgb';\n              const alphaNode = children[2];\n              const rgbValues = convertColors.lab2rgb(...[children[0].value, 0, 0].map(number => parseFloat(number))).map(sourceValue => Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0));\n              node.removeAll().append(newParen('(')).append(newNumber(rgbValues[0])).append(newComma()).append(newNumber(rgbValues[1])).append(newComma()).append(newNumber(rgbValues[2])).append(newParen(')'));\n\n              if (alphaNode) {\n                if (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n                  alphaNode.unit = '';\n                  alphaNode.value = String(alphaNode.value / 100);\n                }\n\n                if (alphaNode.value !== '1') {\n                  node.value += 'a';\n                  node.insertBefore(node.last, newComma()).insertBefore(node.last, alphaNode);\n                }\n              }\n            }\n          }\n        });\n        const newValue = String(ast);\n\n        if (preserve) {\n          decl.cloneBefore({\n            value: newValue\n          });\n        } else {\n          decl.value = newValue;\n        }\n      }\n    });\n  };\n});\nconst colorAnyRegExp = /(^|[^\\w-])(lab|lch|gray)\\(/i;\nconst colorRegExp = /^(lab|lch|gray)$/i;\nconst labRegExp = /^lab$/i;\nconst grayRegExp = /^gray$/i;\nconst alphaUnitMatch = /^%?$/i;\nconst calcFuncMatch = /^calc$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\n\nconst isAlphaValue = node => isCalc(node) || node.type === 'number' && alphaUnitMatch.test(node.unit);\n\nconst isCalc = node => node.type === 'func' && calcFuncMatch.test(node.value);\n\nconst isHue = node => isCalc(node) || node.type === 'number' && hueUnitMatch.test(node.unit);\n\nconst isNumber = node => isCalc(node) || node.type === 'number' && node.unit === '';\n\nconst isPercentage = node => isCalc(node) || node.type === 'number' && node.unit === '%';\n\nconst isSlash = node => node.type === 'operator' && node.value === '/';\n\nconst functionalLABMatch = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];\nconst functionalLCHMatch = [isNumber, isNumber, isHue, isSlash, isAlphaValue];\nconst functionalGrayMatch = [isNumber, isSlash, isAlphaValue];\n\nconst matchFunctionalLAB = children => children.every((child, index) => typeof functionalLABMatch[index] === 'function' && functionalLABMatch[index](child));\n\nconst matchFunctionalLCH = children => children.every((child, index) => typeof functionalLCHMatch[index] === 'function' && functionalLCHMatch[index](child));\n\nconst matchFunctionalGray = children => children.every((child, index) => typeof functionalGrayMatch[index] === 'function' && functionalGrayMatch[index](child));\n\nconst newComma = () => parser.comma({\n  value: ','\n});\n\nconst newNumber = value => parser.number({\n  value\n});\n\nconst newParen = value => parser.paren({\n  value\n});\n\nmodule.exports = index;","map":{"version":3,"sources":["index.js"],"names":["opts","preserve","Object","Boolean","root","decl","value","colorAnyRegExp","ast","parser","node","colorRegExp","children","isLab","labRegExp","isGray","grayRegExp","isFunctionalLAB","matchFunctionalLAB","isFunctionalLCH","matchFunctionalLCH","isFunctionalGray","matchFunctionalGray","slashNode","alphaNode","isPercentage","isCalc","String","isSlash","newComma","converter","lab2rgb","lch2rgb","rgbValues","number","parseFloat","sourceValue","Math","parseInt","newParen","newNumber","newValue","alphaUnitMatch","calcFuncMatch","hueUnitMatch","isAlphaValue","isHue","isNumber","functionalLABMatch","functionalLCHMatch","functionalGrayMatch"],"mappings":"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","sourcesContent":["import { lab2rgb, lch2rgb } from '@csstools/convert-colors';\nimport postcss from 'postcss';\nimport parser from 'postcss-values-parser';\n\nexport default postcss.plugin('postcss-lab-function', opts => {\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n\n\treturn root => {\n\t\troot.walkDecls(decl => {\n\t\t\tconst { value } = decl;\n\n\t\t\tif (colorAnyRegExp.test(value)) {\n\t\t\t\tconst ast = parser(value).parse();\n\n\t\t\t\tast.walkType('func', node => {\n\t\t\t\t\tif (colorRegExp.test(node.value)) {\n\t\t\t\t\t\tconst children = node.nodes.slice(1, -1);\n\t\t\t\t\t\tconst isLab = labRegExp.test(node.value);\n\t\t\t\t\t\tconst isGray = grayRegExp.test(node.value);\n\t\t\t\t\t\tconst isFunctionalLAB = !isGray && matchFunctionalLAB(children);\n\t\t\t\t\t\tconst isFunctionalLCH = !isGray && matchFunctionalLCH(children);\n\t\t\t\t\t\tconst isFunctionalGray = isGray && matchFunctionalGray(children);\n\n\t\t\t\t\t\tif (isFunctionalLAB || isFunctionalLCH) {\n\t\t\t\t\t\t\tnode.value = 'rgb';\n\n\t\t\t\t\t\t\tconst slashNode = children[3];\n\t\t\t\t\t\t\tconst alphaNode = children[4];\n\n\t\t\t\t\t\t\tif (alphaNode) {\n\t\t\t\t\t\t\t\tif (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n\t\t\t\t\t\t\t\t\talphaNode.unit = '';\n\t\t\t\t\t\t\t\t\talphaNode.value = String(alphaNode.value / 100);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (alphaNode.value === '1') {\n\t\t\t\t\t\t\t\t\tslashNode.remove();\n\t\t\t\t\t\t\t\t\talphaNode.remove();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.value += 'a';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (slashNode && isSlash(slashNode)) {\n\t\t\t\t\t\t\t\tslashNode.replaceWith( newComma() );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst converter = isLab ? lab2rgb : lch2rgb;\n\n\t\t\t\t\t\t\tconst rgbValues = converter(\n\t\t\t\t\t\t\t\t...[\n\t\t\t\t\t\t\t\t\tchildren[0].value,\n\t\t\t\t\t\t\t\t\tchildren[1].value,\n\t\t\t\t\t\t\t\t\tchildren[2].value\n\t\t\t\t\t\t\t\t].map(\n\t\t\t\t\t\t\t\t\tnumber => parseFloat(number)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t).map(\n\t\t\t\t\t\t\t\tsourceValue => Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0)\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tchildren[0].value = String(rgbValues[0]);\n\t\t\t\t\t\t\tchildren[1].value = String(rgbValues[1]);\n\t\t\t\t\t\t\tchildren[2].value = String(rgbValues[2]);\n\n\t\t\t\t\t\t\tnode.nodes.splice(3, 0, [ newComma() ]);\n\t\t\t\t\t\t\tnode.nodes.splice(2, 0, [ newComma() ]);\n\t\t\t\t\t\t} else if (isFunctionalGray) {\n\t\t\t\t\t\t\tnode.value = 'rgb';\n\n\t\t\t\t\t\t\tconst alphaNode = children[2];\n\n\t\t\t\t\t\t\tconst rgbValues = lab2rgb(\n\t\t\t\t\t\t\t\t...[\n\t\t\t\t\t\t\t\t\tchildren[0].value,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t].map(\n\t\t\t\t\t\t\t\t\tnumber => parseFloat(number)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t).map(\n\t\t\t\t\t\t\t\tsourceValue => Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tnode.removeAll()\n\t\t\t\t\t\t\t.append(newParen('('))\n\t\t\t\t\t\t\t.append(newNumber(rgbValues[0]))\n\t\t\t\t\t\t\t.append(newComma())\n\t\t\t\t\t\t\t.append(newNumber(rgbValues[1]))\n\t\t\t\t\t\t\t.append(newComma())\n\t\t\t\t\t\t\t.append(newNumber(rgbValues[2]))\n\t\t\t\t\t\t\t.append(newParen(')'));\n\n\t\t\t\t\t\t\tif (alphaNode) {\n\t\t\t\t\t\t\t\tif (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n\t\t\t\t\t\t\t\t\talphaNode.unit = '';\n\t\t\t\t\t\t\t\t\talphaNode.value = String(alphaNode.value / 100);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (alphaNode.value !== '1') {\n\t\t\t\t\t\t\t\t\tnode.value += 'a';\n\n\t\t\t\t\t\t\t\t\tnode\n\t\t\t\t\t\t\t\t\t.insertBefore(node.last, newComma())\n\t\t\t\t\t\t\t\t\t.insertBefore(node.last, alphaNode)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst newValue = String(ast);\n\n\t\t\t\tif (preserve) {\n\t\t\t\t\tdecl.cloneBefore({ value: newValue });\n\t\t\t\t} else {\n\t\t\t\t\tdecl.value = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\nconst colorAnyRegExp = /(^|[^\\w-])(lab|lch|gray)\\(/i;\nconst colorRegExp = /^(lab|lch|gray)$/i;\nconst labRegExp = /^lab$/i;\nconst grayRegExp = /^gray$/i;\nconst alphaUnitMatch = /^%?$/i;\nconst calcFuncMatch = /^calc$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\n\nconst isAlphaValue = node => isCalc(node) || node.type === 'number' && alphaUnitMatch.test(node.unit);\nconst isCalc = node => node.type === 'func' && calcFuncMatch.test(node.value);\nconst isHue = node => isCalc(node) || node.type === 'number' && hueUnitMatch.test(node.unit);\nconst isNumber = node => isCalc(node) || node.type === 'number' && node.unit === '';\nconst isPercentage = node => isCalc(node) || node.type === 'number' && node.unit === '%';\nconst isSlash = node => node.type === 'operator' && node.value === '/';\nconst functionalLABMatch = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];\nconst functionalLCHMatch = [isNumber, isNumber, isHue, isSlash, isAlphaValue];\nconst functionalGrayMatch = [isNumber, isSlash, isAlphaValue];\nconst matchFunctionalLAB = children => children.every(\n\t(child, index) => typeof functionalLABMatch[index] === 'function' && functionalLABMatch[index](child)\n);\nconst matchFunctionalLCH = children => children.every(\n\t(child, index) => typeof functionalLCHMatch[index] === 'function' && functionalLCHMatch[index](child)\n);\nconst matchFunctionalGray = children => children.every(\n\t(child, index) => typeof functionalGrayMatch[index] === 'function' && functionalGrayMatch[index](child)\n);\n\nconst newComma = () => parser.comma({ value: ',' });\nconst newNumber = value => parser.number({ value });\nconst newParen = value => parser.paren({ value });\n"]},"metadata":{},"sourceType":"script"}