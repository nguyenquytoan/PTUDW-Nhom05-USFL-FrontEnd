{"ast":null,"code":"/*\n\tcompiles a selector to an executable function\n*/\nmodule.exports = compile;\n\nvar parse = require(\"css-what\").parse;\n\nvar BaseFuncs = require(\"boolbase\");\n\nvar sortRules = require(\"./sort.js\");\n\nvar procedure = require(\"./procedure.json\");\n\nvar Rules = require(\"./general.js\");\n\nvar Pseudos = require(\"./pseudos.js\");\n\nvar trueFunc = BaseFuncs.trueFunc;\nvar falseFunc = BaseFuncs.falseFunc;\nvar filters = Pseudos.filters;\n\nfunction compile(selector, options, context) {\n  var next = compileUnsafe(selector, options, context);\n  return wrap(next, options);\n}\n\nfunction wrap(next, options) {\n  var adapter = options.adapter;\n  return function base(elem) {\n    return adapter.isTag(elem) && next(elem);\n  };\n}\n\nfunction compileUnsafe(selector, options, context) {\n  var token = parse(selector, options);\n  return compileToken(token, options, context);\n}\n\nfunction includesScopePseudo(t) {\n  return t.type === \"pseudo\" && (t.name === \"scope\" || Array.isArray(t.data) && t.data.some(function (data) {\n    return data.some(includesScopePseudo);\n  }));\n}\n\nvar DESCENDANT_TOKEN = {\n  type: \"descendant\"\n};\nvar FLEXIBLE_DESCENDANT_TOKEN = {\n  type: \"_flexibleDescendant\"\n};\nvar SCOPE_TOKEN = {\n  type: \"pseudo\",\n  name: \"scope\"\n};\nvar PLACEHOLDER_ELEMENT = {}; //CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector\n//http://www.w3.org/TR/selectors4/#absolutizing\n\nfunction absolutize(token, options, context) {\n  var adapter = options.adapter; //TODO better check if context is document\n\n  var hasContext = !!context && !!context.length && context.every(function (e) {\n    return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);\n  });\n  token.forEach(function (t) {\n    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== \"descendant\") {//don't return in else branch\n    } else if (hasContext && !(Array.isArray(t) ? t.some(includesScopePseudo) : includesScopePseudo(t))) {\n      t.unshift(DESCENDANT_TOKEN);\n    } else {\n      return;\n    }\n\n    t.unshift(SCOPE_TOKEN);\n  });\n}\n\nfunction compileToken(token, options, context) {\n  token = token.filter(function (t) {\n    return t.length > 0;\n  });\n  token.forEach(sortRules);\n  var isArrayContext = Array.isArray(context);\n  context = options && options.context || context;\n  if (context && !isArrayContext) context = [context];\n  absolutize(token, options, context);\n  var shouldTestNextSiblings = false;\n  var query = token.map(function (rules) {\n    if (rules[0] && rules[1] && rules[0].name === \"scope\") {\n      var ruleType = rules[1].type;\n\n      if (isArrayContext && ruleType === \"descendant\") {\n        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n      } else if (ruleType === \"adjacent\" || ruleType === \"sibling\") {\n        shouldTestNextSiblings = true;\n      }\n    }\n\n    return compileRules(rules, options, context);\n  }).reduce(reduceRules, falseFunc);\n  query.shouldTestNextSiblings = shouldTestNextSiblings;\n  return query;\n}\n\nfunction isTraversal(t) {\n  return procedure[t.type] < 0;\n}\n\nfunction compileRules(rules, options, context) {\n  return rules.reduce(function (func, rule) {\n    if (func === falseFunc) return func;\n\n    if (!(rule.type in Rules)) {\n      throw new Error(\"Rule type \" + rule.type + \" is not supported by css-select\");\n    }\n\n    return Rules[rule.type](func, rule, options, context);\n  }, options && options.rootFunc || trueFunc);\n}\n\nfunction reduceRules(a, b) {\n  if (b === falseFunc || a === trueFunc) {\n    return a;\n  }\n\n  if (a === falseFunc || b === trueFunc) {\n    return b;\n  }\n\n  return function combine(elem) {\n    return a(elem) || b(elem);\n  };\n}\n\nfunction containsTraversal(t) {\n  return t.some(isTraversal);\n} //:not, :has and :matches have to compile selectors\n//doing this in lib/pseudos.js would lead to circular dependencies,\n//so we add them here\n\n\nfilters.not = function (next, token, options, context) {\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict),\n    adapter: options.adapter\n  };\n\n  if (opts.strict) {\n    if (token.length > 1 || token.some(containsTraversal)) {\n      throw new Error(\"complex selectors in :not aren't allowed in strict mode\");\n    }\n  }\n\n  var func = compileToken(token, opts, context);\n  if (func === falseFunc) return next;\n  if (func === trueFunc) return falseFunc;\n  return function not(elem) {\n    return !func(elem) && next(elem);\n  };\n};\n\nfilters.has = function (next, token, options) {\n  var adapter = options.adapter;\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict),\n    adapter: adapter\n  }; //FIXME: Uses an array as a pointer to the current element (side effects)\n\n  var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;\n  var func = compileToken(token, opts, context);\n  if (func === falseFunc) return falseFunc;\n\n  if (func === trueFunc) {\n    return function hasChild(elem) {\n      return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n    };\n  }\n\n  func = wrap(func, options);\n\n  if (context) {\n    return function has(elem) {\n      return next(elem) && (context[0] = elem, adapter.existsOne(func, adapter.getChildren(elem)));\n    };\n  }\n\n  return function has(elem) {\n    return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));\n  };\n};\n\nfilters.matches = function (next, token, options, context) {\n  var opts = {\n    xmlMode: !!(options && options.xmlMode),\n    strict: !!(options && options.strict),\n    rootFunc: next,\n    adapter: options.adapter\n  };\n  return compileToken(token, opts, context);\n};\n\ncompile.compileToken = compileToken;\ncompile.compileUnsafe = compileUnsafe;\ncompile.Pseudos = Pseudos;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/css-select/lib/compile.js"],"names":["module","exports","compile","parse","require","BaseFuncs","sortRules","procedure","Rules","Pseudos","trueFunc","falseFunc","filters","selector","options","context","next","compileUnsafe","wrap","adapter","base","elem","isTag","token","compileToken","includesScopePseudo","t","type","name","Array","isArray","data","some","DESCENDANT_TOKEN","FLEXIBLE_DESCENDANT_TOKEN","SCOPE_TOKEN","PLACEHOLDER_ELEMENT","absolutize","hasContext","length","every","e","getParent","forEach","isTraversal","unshift","filter","isArrayContext","shouldTestNextSiblings","query","map","rules","ruleType","compileRules","reduce","reduceRules","func","rule","Error","rootFunc","a","b","combine","containsTraversal","not","opts","xmlMode","strict","has","hasChild","getChildren","existsOne","matches"],"mappings":"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","sourcesContent":["/*\n\tcompiles a selector to an executable function\n*/\n\nmodule.exports = compile;\n\nvar parse = require(\"css-what\").parse;\nvar BaseFuncs = require(\"boolbase\");\nvar sortRules = require(\"./sort.js\");\nvar procedure = require(\"./procedure.json\");\nvar Rules = require(\"./general.js\");\nvar Pseudos = require(\"./pseudos.js\");\nvar trueFunc = BaseFuncs.trueFunc;\nvar falseFunc = BaseFuncs.falseFunc;\n\nvar filters = Pseudos.filters;\n\nfunction compile(selector, options, context) {\n    var next = compileUnsafe(selector, options, context);\n    return wrap(next, options);\n}\n\nfunction wrap(next, options) {\n    var adapter = options.adapter;\n\n    return function base(elem) {\n        return adapter.isTag(elem) && next(elem);\n    };\n}\n\nfunction compileUnsafe(selector, options, context) {\n    var token = parse(selector, options);\n    return compileToken(token, options, context);\n}\n\nfunction includesScopePseudo(t) {\n    return (\n        t.type === \"pseudo\" &&\n        (t.name === \"scope\" ||\n            (Array.isArray(t.data) &&\n                t.data.some(function(data) {\n                    return data.some(includesScopePseudo);\n                })))\n    );\n}\n\nvar DESCENDANT_TOKEN = { type: \"descendant\" };\nvar FLEXIBLE_DESCENDANT_TOKEN = { type: \"_flexibleDescendant\" };\nvar SCOPE_TOKEN = { type: \"pseudo\", name: \"scope\" };\nvar PLACEHOLDER_ELEMENT = {};\n\n//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector\n//http://www.w3.org/TR/selectors4/#absolutizing\nfunction absolutize(token, options, context) {\n    var adapter = options.adapter;\n\n    //TODO better check if context is document\n    var hasContext =\n        !!context &&\n        !!context.length &&\n        context.every(function(e) {\n            return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);\n        });\n\n    token.forEach(function(t) {\n        if (t.length > 0 && isTraversal(t[0]) && t[0].type !== \"descendant\") {\n            //don't return in else branch\n        } else if (hasContext && !(Array.isArray(t) ? t.some(includesScopePseudo) : includesScopePseudo(t))) {\n            t.unshift(DESCENDANT_TOKEN);\n        } else {\n            return;\n        }\n\n        t.unshift(SCOPE_TOKEN);\n    });\n}\n\nfunction compileToken(token, options, context) {\n    token = token.filter(function(t) {\n        return t.length > 0;\n    });\n\n    token.forEach(sortRules);\n\n    var isArrayContext = Array.isArray(context);\n\n    context = (options && options.context) || context;\n\n    if (context && !isArrayContext) context = [context];\n\n    absolutize(token, options, context);\n\n    var shouldTestNextSiblings = false;\n\n    var query = token\n        .map(function(rules) {\n            if (rules[0] && rules[1] && rules[0].name === \"scope\") {\n                var ruleType = rules[1].type;\n                if (isArrayContext && ruleType === \"descendant\") {\n                    rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n                } else if (ruleType === \"adjacent\" || ruleType === \"sibling\") {\n                    shouldTestNextSiblings = true;\n                }\n            }\n            return compileRules(rules, options, context);\n        })\n        .reduce(reduceRules, falseFunc);\n\n    query.shouldTestNextSiblings = shouldTestNextSiblings;\n\n    return query;\n}\n\nfunction isTraversal(t) {\n    return procedure[t.type] < 0;\n}\n\nfunction compileRules(rules, options, context) {\n    return rules.reduce(function(func, rule) {\n        if (func === falseFunc) return func;\n\n        if (!(rule.type in Rules)) {\n            throw new Error(\"Rule type \" + rule.type + \" is not supported by css-select\");\n        }\n\n        return Rules[rule.type](func, rule, options, context);\n    }, (options && options.rootFunc) || trueFunc);\n}\n\nfunction reduceRules(a, b) {\n    if (b === falseFunc || a === trueFunc) {\n        return a;\n    }\n    if (a === falseFunc || b === trueFunc) {\n        return b;\n    }\n\n    return function combine(elem) {\n        return a(elem) || b(elem);\n    };\n}\n\nfunction containsTraversal(t) {\n    return t.some(isTraversal);\n}\n\n//:not, :has and :matches have to compile selectors\n//doing this in lib/pseudos.js would lead to circular dependencies,\n//so we add them here\nfilters.not = function(next, token, options, context) {\n    var opts = {\n        xmlMode: !!(options && options.xmlMode),\n        strict: !!(options && options.strict),\n        adapter: options.adapter\n    };\n\n    if (opts.strict) {\n        if (token.length > 1 || token.some(containsTraversal)) {\n            throw new Error(\"complex selectors in :not aren't allowed in strict mode\");\n        }\n    }\n\n    var func = compileToken(token, opts, context);\n\n    if (func === falseFunc) return next;\n    if (func === trueFunc) return falseFunc;\n\n    return function not(elem) {\n        return !func(elem) && next(elem);\n    };\n};\n\nfilters.has = function(next, token, options) {\n    var adapter = options.adapter;\n    var opts = {\n        xmlMode: !!(options && options.xmlMode),\n        strict: !!(options && options.strict),\n        adapter: adapter\n    };\n\n    //FIXME: Uses an array as a pointer to the current element (side effects)\n    var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;\n\n    var func = compileToken(token, opts, context);\n\n    if (func === falseFunc) return falseFunc;\n    if (func === trueFunc) {\n        return function hasChild(elem) {\n            return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n        };\n    }\n\n    func = wrap(func, options);\n\n    if (context) {\n        return function has(elem) {\n            return next(elem) && ((context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem)));\n        };\n    }\n\n    return function has(elem) {\n        return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));\n    };\n};\n\nfilters.matches = function(next, token, options, context) {\n    var opts = {\n        xmlMode: !!(options && options.xmlMode),\n        strict: !!(options && options.strict),\n        rootFunc: next,\n        adapter: options.adapter\n    };\n\n    return compileToken(token, opts, context);\n};\n\ncompile.compileToken = compileToken;\ncompile.compileUnsafe = compileUnsafe;\ncompile.Pseudos = Pseudos;\n"]},"metadata":{},"sourceType":"script"}