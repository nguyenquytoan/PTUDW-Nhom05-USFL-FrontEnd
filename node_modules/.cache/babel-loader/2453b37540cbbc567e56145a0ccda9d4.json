{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst path = require('path');\n\nconst _require = require('workbox-build'),\n      copyWorkboxLibraries = _require.copyWorkboxLibraries,\n      getModuleURL = _require.getModuleURL;\n/**\n * @param {Object} compilation The webpack compilation.\n * @param {Object} config The options passed to the plugin constructor.\n * - config.excludeChunks may be modified by this function if\n *   config.importWorkboxFrom is set to a chunk name.\n * - config.modulePathPrefix may be modified by this function if\n *   config.importWorkboxFrom is set to 'local'.\n * @return {Array<string>|null} A list of URLs to use to import the Workbox\n * runtime code, or null if importWorkboxFrom is 'disabled'.\n * @private\n */\n\n\nfunction getWorkboxSWImport(_x, _x2) {\n  return _getWorkboxSWImport.apply(this, arguments);\n}\n\nfunction _getWorkboxSWImport() {\n  _getWorkboxSWImport = (0, _asyncToGenerator2.default)(function* (compilation, config) {\n    switch (config.importWorkboxFrom) {\n      case 'cdn':\n        {\n          return [getModuleURL('workbox-sw')];\n        }\n\n      case 'local':\n        {\n          // This will create a local copy of the Workbox runtime libraries in\n          // the output directory, independent of the webpack build pipeline.\n          // In general, this should work, but one thing to keep in mind is that\n          // when using the webpack-dev-server, the output will be created on\n          // disk, rather than in the in-memory filesystem. (webpack-dev-server will\n          // still be able to serve the runtime libraries from disk.)\n          const wbDir = yield copyWorkboxLibraries(path.join(compilation.options.output.path, config.importsDirectory)); // We need to set this extra option in the config to ensure that the\n          // workbox library loader knows where to get the local libraries from.\n\n          config.modulePathPrefix = (compilation.options.output.publicPath || '') + path.join(config.importsDirectory, wbDir).split(path.sep).join('/');\n          const workboxSWImport = config.modulePathPrefix + '/workbox-sw.js';\n          return [workboxSWImport];\n        }\n\n      case 'disabled':\n        {\n          return null;\n        }\n\n      default:\n        {\n          // If importWorkboxFrom is anything else, then treat it as the name of\n          // a webpack chunk that corresponds to the custom compilation of the\n          // Workbox code.\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = compilation.chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              const chunk = _step.value; // Make sure that we actually have a chunk with the appropriate name.\n\n              if (chunk.name === config.importWorkboxFrom) {\n                config.excludeChunks.push(chunk.name);\n                return chunk.files.map(file => {\n                  return (compilation.options.output.publicPath || '') + file;\n                });\n              }\n            } // If there's no chunk with the right name, treat it as a fatal error.\n\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          throw Error(`importWorkboxFrom was set to ` + `'${config.importWorkboxFrom}', which is not an existing chunk name.`);\n        }\n    }\n  });\n  return _getWorkboxSWImport.apply(this, arguments);\n}\n\nmodule.exports = getWorkboxSWImport;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-webpack-plugin/build/lib/get-workbox-sw-imports.js"],"names":["_interopRequireDefault","require","_asyncToGenerator2","path","_require","copyWorkboxLibraries","getModuleURL","getWorkboxSWImport","_x","_x2","_getWorkboxSWImport","apply","arguments","default","compilation","config","importWorkboxFrom","wbDir","join","options","output","importsDirectory","modulePathPrefix","publicPath","split","sep","workboxSWImport","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","chunks","Symbol","iterator","_step","next","done","chunk","value","name","excludeChunks","push","files","map","file","err","return","Error","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst path = require('path');\n\nconst _require = require('workbox-build'),\n      copyWorkboxLibraries = _require.copyWorkboxLibraries,\n      getModuleURL = _require.getModuleURL;\n/**\n * @param {Object} compilation The webpack compilation.\n * @param {Object} config The options passed to the plugin constructor.\n * - config.excludeChunks may be modified by this function if\n *   config.importWorkboxFrom is set to a chunk name.\n * - config.modulePathPrefix may be modified by this function if\n *   config.importWorkboxFrom is set to 'local'.\n * @return {Array<string>|null} A list of URLs to use to import the Workbox\n * runtime code, or null if importWorkboxFrom is 'disabled'.\n * @private\n */\n\n\nfunction getWorkboxSWImport(_x, _x2) {\n  return _getWorkboxSWImport.apply(this, arguments);\n}\n\nfunction _getWorkboxSWImport() {\n  _getWorkboxSWImport = (0, _asyncToGenerator2.default)(function* (compilation, config) {\n    switch (config.importWorkboxFrom) {\n      case 'cdn':\n        {\n          return [getModuleURL('workbox-sw')];\n        }\n\n      case 'local':\n        {\n          // This will create a local copy of the Workbox runtime libraries in\n          // the output directory, independent of the webpack build pipeline.\n          // In general, this should work, but one thing to keep in mind is that\n          // when using the webpack-dev-server, the output will be created on\n          // disk, rather than in the in-memory filesystem. (webpack-dev-server will\n          // still be able to serve the runtime libraries from disk.)\n          const wbDir = yield copyWorkboxLibraries(path.join(compilation.options.output.path, config.importsDirectory)); // We need to set this extra option in the config to ensure that the\n          // workbox library loader knows where to get the local libraries from.\n\n          config.modulePathPrefix = (compilation.options.output.publicPath || '') + path.join(config.importsDirectory, wbDir).split(path.sep).join('/');\n          const workboxSWImport = config.modulePathPrefix + '/workbox-sw.js';\n          return [workboxSWImport];\n        }\n\n      case 'disabled':\n        {\n          return null;\n        }\n\n      default:\n        {\n          // If importWorkboxFrom is anything else, then treat it as the name of\n          // a webpack chunk that corresponds to the custom compilation of the\n          // Workbox code.\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = compilation.chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              const chunk = _step.value;\n\n              // Make sure that we actually have a chunk with the appropriate name.\n              if (chunk.name === config.importWorkboxFrom) {\n                config.excludeChunks.push(chunk.name);\n                return chunk.files.map(file => {\n                  return (compilation.options.output.publicPath || '') + file;\n                });\n              }\n            } // If there's no chunk with the right name, treat it as a fatal error.\n\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          throw Error(`importWorkboxFrom was set to ` + `'${config.importWorkboxFrom}', which is not an existing chunk name.`);\n        }\n    }\n  });\n  return _getWorkboxSWImport.apply(this, arguments);\n}\n\nmodule.exports = getWorkboxSWImport;"]},"metadata":{},"sourceType":"script"}