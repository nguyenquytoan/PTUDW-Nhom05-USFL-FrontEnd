{"ast":null,"code":"import Literal from '../Literal';\nimport JSXElement from '../JSXElement';\nimport Identifier from './Identifier';\nimport TaggedTemplateExpression from './TaggedTemplateExpression';\nimport TemplateLiteral from './TemplateLiteral';\nimport FunctionExpression from './FunctionExpression';\nimport LogicalExpression from './LogicalExpression';\nimport MemberExpression from './MemberExpression';\nimport OptionalCallExpression from './OptionalCallExpression';\nimport OptionalMemberExpression from './OptionalMemberExpression';\nimport CallExpression from './CallExpression';\nimport UnaryExpression from './UnaryExpression';\nimport ThisExpression from './ThisExpression';\nimport ConditionalExpression from './ConditionalExpression';\nimport BinaryExpression from './BinaryExpression';\nimport ObjectExpression from './ObjectExpression';\nimport NewExpression from './NewExpression';\nimport UpdateExpression from './UpdateExpression';\nimport ArrayExpression from './ArrayExpression';\nimport BindExpression from './BindExpression';\nimport SpreadElement from './SpreadElement';\nimport TypeCastExpression from './TypeCastExpression'; // Composition map of types to their extractor functions.\n\nconst TYPES = {\n  Identifier,\n  Literal,\n  JSXElement,\n  TaggedTemplateExpression,\n  TemplateLiteral,\n  ArrowFunctionExpression: FunctionExpression,\n  FunctionExpression,\n  LogicalExpression,\n  MemberExpression,\n  OptionalCallExpression,\n  OptionalMemberExpression,\n  CallExpression,\n  UnaryExpression,\n  ThisExpression,\n  ConditionalExpression,\n  BinaryExpression,\n  ObjectExpression,\n  NewExpression,\n  UpdateExpression,\n  ArrayExpression,\n  BindExpression,\n  SpreadElement,\n  TypeCastExpression\n};\n\nconst noop = () => null;\n\nconst errorMessage = expression => `The prop value with an expression type of ${expression} could not be resolved. Please file issue to get this fixed immediately.`;\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\n\n\nexport default function extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  let expression;\n\n  if (typeof value.expression !== 'boolean' && value.expression) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n\n  let {\n    type\n  } = expression;\n\n  while (type === 'TSNonNullExpression' || type === 'TSAsExpression') {\n    ({\n      type\n    } = expression);\n\n    if (expression.expression) {\n      ({\n        expression\n      } = expression);\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n} // Composition map of types to their extractor functions to handle literals.\n\nconst LITERAL_TYPES = { ...TYPES,\n  Literal: value => {\n    const extractedVal = TYPES.Literal.call(undefined, value);\n    const isNull = extractedVal === null; // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: value => {\n    const isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: value => {\n    const extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: value => {\n    const extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: value => {\n    const extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter(val => val !== null);\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop\n};\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\n\nexport function extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  const expression = value.expression || value;\n  const {\n    type\n  } = expression;\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsx-ast-utils/src/values/expressions/index.js"],"names":["Literal","JSXElement","Identifier","TaggedTemplateExpression","TemplateLiteral","FunctionExpression","LogicalExpression","MemberExpression","OptionalCallExpression","OptionalMemberExpression","CallExpression","UnaryExpression","ThisExpression","ConditionalExpression","BinaryExpression","ObjectExpression","NewExpression","UpdateExpression","ArrayExpression","BindExpression","SpreadElement","TypeCastExpression","TYPES","ArrowFunctionExpression","noop","errorMessage","expression","extract","value","type","undefined","console","error","LITERAL_TYPES","extractedVal","call","isNull","isUndefined","filter","val","TSNonNullExpression","TSAsExpression","extractLiteral"],"mappings":"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","sourcesContent":["import Literal from '../Literal';\nimport JSXElement from '../JSXElement';\nimport Identifier from './Identifier';\nimport TaggedTemplateExpression from './TaggedTemplateExpression';\nimport TemplateLiteral from './TemplateLiteral';\nimport FunctionExpression from './FunctionExpression';\nimport LogicalExpression from './LogicalExpression';\nimport MemberExpression from './MemberExpression';\nimport OptionalCallExpression from './OptionalCallExpression';\nimport OptionalMemberExpression from './OptionalMemberExpression';\nimport CallExpression from './CallExpression';\nimport UnaryExpression from './UnaryExpression';\nimport ThisExpression from './ThisExpression';\nimport ConditionalExpression from './ConditionalExpression';\nimport BinaryExpression from './BinaryExpression';\nimport ObjectExpression from './ObjectExpression';\nimport NewExpression from './NewExpression';\nimport UpdateExpression from './UpdateExpression';\nimport ArrayExpression from './ArrayExpression';\nimport BindExpression from './BindExpression';\nimport SpreadElement from './SpreadElement';\nimport TypeCastExpression from './TypeCastExpression';\n\n// Composition map of types to their extractor functions.\nconst TYPES = {\n  Identifier,\n  Literal,\n  JSXElement,\n  TaggedTemplateExpression,\n  TemplateLiteral,\n  ArrowFunctionExpression: FunctionExpression,\n  FunctionExpression,\n  LogicalExpression,\n  MemberExpression,\n  OptionalCallExpression,\n  OptionalMemberExpression,\n  CallExpression,\n  UnaryExpression,\n  ThisExpression,\n  ConditionalExpression,\n  BinaryExpression,\n  ObjectExpression,\n  NewExpression,\n  UpdateExpression,\n  ArrayExpression,\n  BindExpression,\n  SpreadElement,\n  TypeCastExpression,\n};\n\nconst noop = () => null;\n\nconst errorMessage = (expression) => `The prop value with an expression type of ${expression} could not be resolved. Please file issue to get this fixed immediately.`;\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nexport default function extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  let expression;\n  if (\n    typeof value.expression !== 'boolean'\n    && value.expression\n  ) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n  let { type } = expression;\n\n  while (type === 'TSNonNullExpression' || type === 'TSAsExpression') {\n    ({ type } = expression);\n    if (expression.expression) {\n      ({ expression } = expression);\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n}\n\n// Composition map of types to their extractor functions to handle literals.\nconst LITERAL_TYPES = {\n  ...TYPES,\n  Literal: (value) => {\n    const extractedVal = TYPES.Literal.call(undefined, value);\n    const isNull = extractedVal === null;\n    // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: (value) => {\n    const isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: (value) => {\n    const extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: (value) => {\n    const extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: (value) => {\n    const extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter((val) => val !== null);\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop,\n};\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nexport function extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  const expression = value.expression || value;\n  const { type } = expression;\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}\n"]},"metadata":{},"sourceType":"module"}