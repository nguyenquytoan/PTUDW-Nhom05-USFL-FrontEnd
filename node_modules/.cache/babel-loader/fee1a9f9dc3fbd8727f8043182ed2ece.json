{"ast":null,"code":"/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/u;\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * - ArrowFunctionExpression -> `=>` token.\n * @param {ASTNode} node A function node to get.\n * @param {SourceCode} sourceCode A source code to get tokens.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\n\n\nfunction getLocation(node, sourceCode) {\n  if (node.type === \"ArrowFunctionExpression\") {\n    return sourceCode.getTokenBefore(node.body);\n  }\n\n  return node.id || node;\n}\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\n\n\nfunction isTargetMethod(node) {\n  return node.type === \"MemberExpression\" && TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || \"\");\n}\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {boolean} `true` if the node is the callback of an array method.\n */\n\n\nfunction isCallbackOfArrayMethod(node) {\n  let currentNode = node;\n\n  while (currentNode) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      /*\n       * Looks up the destination. e.g.,\n       * foo.every(nativeFoo || function foo() { ... });\n       */\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n        currentNode = parent;\n        break;\n\n      /*\n       * If the upper function is IIFE, checks the destination of the return value.\n       * e.g.\n       *   foo.every((function() {\n       *     // setup...\n       *     return function callback() { ... };\n       *   })());\n       */\n\n      case \"ReturnStatement\":\n        {\n          const func = astUtils.getUpperFunction(parent);\n\n          if (func === null || !astUtils.isCallee(func)) {\n            return false;\n          }\n\n          currentNode = func.parent;\n          break;\n        }\n\n      /*\n       * e.g.\n       *   Array.from([], function() {});\n       *   list.every(function() {});\n       */\n\n      case \"CallExpression\":\n        if (astUtils.isArrayFromMethod(parent.callee)) {\n          return parent.arguments.length >= 2 && parent.arguments[1] === currentNode;\n        }\n\n        if (isTargetMethod(parent.callee)) {\n          return parent.arguments.length >= 1 && parent.arguments[0] === currentNode;\n        }\n\n        return false;\n      // Otherwise this node is not target.\n\n      default:\n        return false;\n    }\n  }\n  /* istanbul ignore next: unreachable */\n\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in callbacks of array methods\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-callback-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedAtEnd: \"Expected to return a value at the end of {{name}}.\",\n      expectedInside: \"Expected to return a value in {{name}}.\",\n      expectedReturnValue: \"{{name}} expected a return value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n    /**\n     * Checks whether or not the last code path segment is reachable.\n     * Then reports this function if the segment is reachable.\n     *\n     * If the last code path segment is reachable, there are paths which are not\n     * returned or thrown.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {\n        context.report({\n          node,\n          loc: getLocation(node, context.getSourceCode()).loc.start,\n          messageId: funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\" && isCallbackOfArrayMethod(node) && !node.async && !node.generator,\n          node\n        };\n      },\n\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true; // if allowImplicit: false, should also check node.argument\n\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expectedReturnValue\",\n              data: {\n                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n              }\n            });\n          }\n        }\n      },\n\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/array-callback-return.js"],"names":["lodash","require","astUtils","TARGET_NODE_TYPE","TARGET_METHODS","isReachable","segment","reachable","getLocation","node","sourceCode","type","getTokenBefore","body","id","isTargetMethod","test","getStaticPropertyName","isCallbackOfArrayMethod","currentNode","parent","func","getUpperFunction","isCallee","isArrayFromMethod","callee","arguments","length","module","exports","meta","docs","description","category","recommended","url","schema","properties","allowImplicit","default","additionalProperties","messages","expectedAtEnd","expectedInside","expectedReturnValue","create","context","options","funcInfo","upper","codePath","hasReturn","shouldCheck","checkLastSegment","currentSegments","some","report","loc","getSourceCode","start","messageId","data","name","getFunctionNameWithKind","onCodePathStart","async","generator","onCodePathEnd","ReturnStatement","argument","upperFirst"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * - ArrowFunctionExpression -> `=>` token.\n * @param {ASTNode} node A function node to get.\n * @param {SourceCode} sourceCode A source code to get tokens.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getLocation(node, sourceCode) {\n    if (node.type === \"ArrowFunctionExpression\") {\n        return sourceCode.getTokenBefore(node.body);\n    }\n    return node.id || node;\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isTargetMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || \"\")\n    );\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {boolean} `true` if the node is the callback of an array method.\n */\nfunction isCallbackOfArrayMethod(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return false;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    );\n                }\n                if (isTargetMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    );\n                }\n                return false;\n\n            // Otherwise this node is not target.\n            default:\n                return false;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-callback-return\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"Expected to return a value at the end of {{name}}.\",\n            expectedInside: \"Expected to return a value in {{name}}.\",\n            expectedReturnValue: \"{{name}} expected a return value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getLocation(node, context.getSourceCode()).loc.start,\n                    messageId: funcInfo.hasReturn\n                        ? \"expectedAtEnd\"\n                        : \"expectedInside\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        TARGET_NODE_TYPE.test(node.type) &&\n                        node.body.type === \"BlockStatement\" &&\n                        isCallbackOfArrayMethod(node) &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expectedReturnValue\",\n                            data: {\n                                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}