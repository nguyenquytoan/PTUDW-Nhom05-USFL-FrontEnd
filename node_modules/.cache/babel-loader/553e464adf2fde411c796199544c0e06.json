{"ast":null,"code":"import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nconst DEFAULT_WEBSOCKET_CONFIG = {\n  url: '',\n  deserializer: e => JSON.parse(e.data),\n  serializer: value => JSON.stringify(value)\n};\nconst WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nexport class WebSocketSubject extends AnonymousSubject {\n  constructor(urlConfigOrSource, destination) {\n    super();\n\n    if (urlConfigOrSource instanceof Observable) {\n      this.destination = destination;\n      this.source = urlConfigOrSource;\n    } else {\n      const config = this._config = Object.assign({}, DEFAULT_WEBSOCKET_CONFIG);\n      this._output = new Subject();\n\n      if (typeof urlConfigOrSource === 'string') {\n        config.url = urlConfigOrSource;\n      } else {\n        for (let key in urlConfigOrSource) {\n          if (urlConfigOrSource.hasOwnProperty(key)) {\n            config[key] = urlConfigOrSource[key];\n          }\n        }\n      }\n\n      if (!config.WebSocketCtor && WebSocket) {\n        config.WebSocketCtor = WebSocket;\n      } else if (!config.WebSocketCtor) {\n        throw new Error('no WebSocket constructor can be found');\n      }\n\n      this.destination = new ReplaySubject();\n    }\n  }\n\n  lift(operator) {\n    const sock = new WebSocketSubject(this._config, this.destination);\n    sock.operator = operator;\n    sock.source = this;\n    return sock;\n  }\n\n  _resetState() {\n    this._socket = null;\n\n    if (!this.source) {\n      this.destination = new ReplaySubject();\n    }\n\n    this._output = new Subject();\n  }\n\n  multiplex(subMsg, unsubMsg, messageFilter) {\n    const self = this;\n    return new Observable(observer => {\n      try {\n        self.next(subMsg());\n      } catch (err) {\n        observer.error(err);\n      }\n\n      const subscription = self.subscribe(x => {\n        try {\n          if (messageFilter(x)) {\n            observer.next(x);\n          }\n        } catch (err) {\n          observer.error(err);\n        }\n      }, err => observer.error(err), () => observer.complete());\n      return () => {\n        try {\n          self.next(unsubMsg());\n        } catch (err) {\n          observer.error(err);\n        }\n\n        subscription.unsubscribe();\n      };\n    });\n  }\n\n  _connectSocket() {\n    const {\n      WebSocketCtor,\n      protocol,\n      url,\n      binaryType\n    } = this._config;\n    const observer = this._output;\n    let socket = null;\n\n    try {\n      socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);\n      this._socket = socket;\n\n      if (binaryType) {\n        this._socket.binaryType = binaryType;\n      }\n    } catch (e) {\n      observer.error(e);\n      return;\n    }\n\n    const subscription = new Subscription(() => {\n      this._socket = null;\n\n      if (socket && socket.readyState === 1) {\n        socket.close();\n      }\n    });\n\n    socket.onopen = e => {\n      const {\n        _socket\n      } = this;\n\n      if (!_socket) {\n        socket.close();\n\n        this._resetState();\n\n        return;\n      }\n\n      const {\n        openObserver\n      } = this._config;\n\n      if (openObserver) {\n        openObserver.next(e);\n      }\n\n      const queue = this.destination;\n      this.destination = Subscriber.create(x => {\n        if (socket.readyState === 1) {\n          try {\n            const {\n              serializer\n            } = this._config;\n            socket.send(serializer(x));\n          } catch (e) {\n            this.destination.error(e);\n          }\n        }\n      }, e => {\n        const {\n          closingObserver\n        } = this._config;\n\n        if (closingObserver) {\n          closingObserver.next(undefined);\n        }\n\n        if (e && e.code) {\n          socket.close(e.code, e.reason);\n        } else {\n          observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n        }\n\n        this._resetState();\n      }, () => {\n        const {\n          closingObserver\n        } = this._config;\n\n        if (closingObserver) {\n          closingObserver.next(undefined);\n        }\n\n        socket.close();\n\n        this._resetState();\n      });\n\n      if (queue && queue instanceof ReplaySubject) {\n        subscription.add(queue.subscribe(this.destination));\n      }\n    };\n\n    socket.onerror = e => {\n      this._resetState();\n\n      observer.error(e);\n    };\n\n    socket.onclose = e => {\n      this._resetState();\n\n      const {\n        closeObserver\n      } = this._config;\n\n      if (closeObserver) {\n        closeObserver.next(e);\n      }\n\n      if (e.wasClean) {\n        observer.complete();\n      } else {\n        observer.error(e);\n      }\n    };\n\n    socket.onmessage = e => {\n      try {\n        const {\n          deserializer\n        } = this._config;\n        observer.next(deserializer(e));\n      } catch (err) {\n        observer.error(err);\n      }\n    };\n  }\n\n  _subscribe(subscriber) {\n    const {\n      source\n    } = this;\n\n    if (source) {\n      return source.subscribe(subscriber);\n    }\n\n    if (!this._socket) {\n      this._connectSocket();\n    }\n\n    this._output.subscribe(subscriber);\n\n    subscriber.add(() => {\n      const {\n        _socket\n      } = this;\n\n      if (this._output.observers.length === 0) {\n        if (_socket && _socket.readyState === 1) {\n          _socket.close();\n        }\n\n        this._resetState();\n      }\n    });\n    return subscriber;\n  }\n\n  unsubscribe() {\n    const {\n      _socket\n    } = this;\n\n    if (_socket && _socket.readyState === 1) {\n      _socket.close();\n    }\n\n    this._resetState();\n\n    super.unsubscribe();\n  }\n\n}","map":{"version":3,"sources":["../../../../src/internal/observable/dom/WebSocketSubject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nconst DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: (e) => JSON.parse(e.data),\n    serializer: (value) => JSON.stringify(value),\n};\nconst WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nexport class WebSocketSubject extends AnonymousSubject {\n    constructor(urlConfigOrSource, destination) {\n        super();\n        if (urlConfigOrSource instanceof Observable) {\n            this.destination = destination;\n            this.source = urlConfigOrSource;\n        }\n        else {\n            const config = this._config = Object.assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (let key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            this.destination = new ReplaySubject();\n        }\n    }\n    lift(operator) {\n        const sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    }\n    _resetState() {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    }\n    multiplex(subMsg, unsubMsg, messageFilter) {\n        const self = this;\n        return new Observable((observer) => {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            const subscription = self.subscribe(x => {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, err => observer.error(err), () => observer.complete());\n            return () => {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    }\n    _connectSocket() {\n        const { WebSocketCtor, protocol, url, binaryType } = this._config;\n        const observer = this._output;\n        let socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        const subscription = new Subscription(() => {\n            this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = (e) => {\n            const { _socket } = this;\n            if (!_socket) {\n                socket.close();\n                this._resetState();\n                return;\n            }\n            const { openObserver } = this._config;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            const queue = this.destination;\n            this.destination = Subscriber.create((x) => {\n                if (socket.readyState === 1) {\n                    try {\n                        const { serializer } = this._config;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        this.destination.error(e);\n                    }\n                }\n            }, (e) => {\n                const { closingObserver } = this._config;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                this._resetState();\n            }, () => {\n                const { closingObserver } = this._config;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(this.destination));\n            }\n        };\n        socket.onerror = (e) => {\n            this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = (e) => {\n            this._resetState();\n            const { closeObserver } = this._config;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = (e) => {\n            try {\n                const { deserializer } = this._config;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    }\n    _subscribe(subscriber) {\n        const { source } = this;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(() => {\n            const { _socket } = this;\n            if (this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                this._resetState();\n            }\n        });\n        return subscriber;\n    }\n    unsubscribe() {\n        const { _socket } = this;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        super.unsubscribe();\n    }\n}\n//# sourceMappingURL=WebSocketSubject.js.map"]},"metadata":{},"sourceType":"module"}