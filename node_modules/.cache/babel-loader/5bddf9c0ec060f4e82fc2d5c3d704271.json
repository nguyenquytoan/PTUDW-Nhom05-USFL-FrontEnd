{"ast":null,"code":"var camelCase = require('camelcase');\n\nvar decamelize = require('decamelize');\n\nvar path = require('path');\n\nvar tokenizeArgString = require('./lib/tokenize-arg-string');\n\nvar util = require('util');\n\nfunction parse(args, opts) {\n  if (!opts) opts = {}; // allow a string argument to be passed in rather\n  // than an argv array.\n\n  args = tokenizeArgString(args); // aliases might have transitive relationships, normalize this.\n\n  var aliases = combineAliases(opts.alias || {});\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'negation-prefix': 'no-',\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false,\n    'combine-arrays': false,\n    'set-placeholder-key': false,\n    'halt-at-non-option': false\n  }, opts.configuration);\n  var defaults = opts.default || {};\n  var configObjects = opts.configObjects || [];\n  var envPrefix = opts.envPrefix;\n  var notFlagsOption = configuration['populate--'];\n  var notFlagsArgv = notFlagsOption ? '--' : '_';\n  var newAliases = {}; // allow a i18n handler to be passed in, default to a fake one (util.format).\n\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments));\n  };\n\n  var error = null;\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {},\n    keys: []\n  };\n  var negative = /^-[0-9]+(\\.[0-9]+)?/;\n  var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n  [].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    var key = opt.key || opt; // assign to flags[bools|strings|numbers]\n\n    const assignment = Object.keys(opt).map(function (key) {\n      return {\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      }[key];\n    }).filter(Boolean).pop(); // assign key to be coerced\n\n    if (assignment) {\n      flags[assignment][key] = true;\n    }\n\n    flags.arrays[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true;\n    flags.keys.push(key);\n  });\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k];\n    flags.keys.push(k);\n  });\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k];\n    flags.keys.push(k);\n  });\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;\n    [].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true;\n    });\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k];\n    });\n  } // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n\n\n  extendAliases(opts.key, aliases, opts.default, flags.arrays); // apply default values to all aliases.\n\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key];\n    });\n  });\n  var argv = {\n    _: []\n  };\n  Object.keys(flags.bools).forEach(function (key) {\n    if (Object.prototype.hasOwnProperty.call(defaults, key)) {\n      setArg(key, defaults[key]);\n      setDefaulted(key);\n    }\n  });\n  var notFlags = [];\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    var broken;\n    var key;\n    var letters;\n    var m;\n    var next;\n    var value; // -- separated by =\n\n    if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/); // nargs format = '--f=monkey washing cat'\n\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatNargs(i, m[1], args); // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatArray(i, m[1], args);\n      } else {\n        setArg(m[1], m[2]);\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1];\n      setArg(key, false); // -- seperated by space.\n    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-.+/)) {\n      key = arg.match(/^--?(.+)/)[1]; // nargs format = '--foo a b c'\n\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args); // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args);\n      } else {\n        next = args[i + 1];\n\n        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n          setArg(key, next);\n          i++;\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next);\n          i++;\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)));\n        }\n      } // dot-notation flag seperated by '='.\n\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n      setArg(m[1], m[2]); // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1];\n      key = arg.match(/^-(.\\..+)/)[1];\n\n      if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n        setArg(key, next);\n        i++;\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)));\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('');\n      broken = false;\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3);\n          key = letters[j]; // nargs format = '-f=monkey washing cat'\n\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value);\n            i = eatNargs(i, key, args); // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value);\n            i = eatArray(i, key, args);\n          } else {\n            setArg(key, value);\n          }\n\n          broken = true;\n          break;\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next);\n          continue;\n        } // current letter is an alphabetic character and next value is a number\n\n\n        if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)));\n        }\n      }\n\n      key = arg.slice(-1)[0];\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args); // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args);\n        } else {\n          next = args[i + 1];\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)));\n          }\n        }\n      }\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1);\n      break;\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i);\n      break;\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg));\n    }\n  } // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n\n\n  applyEnvVars(argv, true); // special case: check env vars that point to config file\n\n  applyEnvVars(argv, false);\n  setConfig(argv);\n  setConfigObjects();\n  applyDefaultsAndAliases(argv, flags.aliases, defaults);\n  applyCoercions(argv);\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv); // for any counts either not in args or without an explicit default, set to 0\n\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n  }); // '--' defaults to undefined.\n\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key);\n  }); // how many arguments should we consume, based\n  // on the nargs option?\n\n  function eatNargs(i, key, args) {\n    var ii;\n    const toEat = checkAllAliases(key, flags.nargs); // nargs will not consume flag arguments, e.g., -abc, --foo,\n    // and terminates when one is observed.\n\n    var available = 0;\n\n    for (ii = i + 1; ii < args.length; ii++) {\n      if (!args[ii].match(/^-[^0-9]/)) available++;else break;\n    }\n\n    if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n    const consumed = Math.min(available, toEat);\n\n    for (ii = i + 1; ii < consumed + i + 1; ii++) {\n      setArg(key, args[ii]);\n    }\n\n    return i + consumed;\n  } // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n\n\n  function eatArray(i, key, args) {\n    var start = i + 1;\n    var argsToSet = [];\n    var multipleArrayFlag = i > 0;\n\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'));\n        }\n\n        multipleArrayFlag = true;\n        break;\n      }\n\n      i = ii;\n      argsToSet.push(args[ii]);\n    }\n\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg);\n      }));\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg);\n      });\n    }\n\n    return i;\n  }\n\n  function setArg(key, val) {\n    unsetDefaulted(key);\n\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      var alias = key.split('.').map(function (prop) {\n        return camelCase(prop);\n      }).join('.');\n      addNewAlias(key, alias);\n    }\n\n    var value = processValue(key, val);\n    var splitKey = key.split('.');\n    setKey(argv, splitKey, value); // handle populating aliases of the full key\n\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.');\n        setKey(argv, x, value);\n      });\n    } // handle populating aliases of the first element of the dot-notation key\n\n\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;\n      (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.'); // expand alias with nested objects in key\n\n        var a = [].concat(splitKey);\n        a.shift(); // nuke the old key.\n\n        x = x.concat(a);\n        setKey(argv, x, value);\n      });\n    } // Set normalize getter and setter when key is in 'normalize' but isn't an array\n\n\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || []);\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v);\n        });\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val;\n        });\n      });\n    }\n  }\n\n  function addNewAlias(key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias];\n      newAliases[alias] = true;\n    }\n\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key);\n    }\n  }\n\n  function processValue(key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true';\n    }\n\n    var value = maybeCoerceNumber(key, val); // increment a count given as arg (either no value or value parsed as boolean)\n\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment;\n    } // Set normalized value when key is in 'normalize' and in 'arrays'\n\n\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize);else value = path.normalize(val);\n    }\n\n    return value;\n  }\n\n  function maybeCoerceNumber(key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(value));\n      if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) value = Number(value);\n    }\n\n    return value;\n  } // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n\n\n  function setConfig(argv) {\n    var configLookup = {}; // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey];\n\n      if (configPath) {\n        try {\n          var config = null;\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath);\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath);\n            } catch (e) {\n              config = e;\n            }\n\n            if (config instanceof Error) {\n              error = config;\n              return;\n            }\n          } else {\n            config = require(resolvedConfigPath);\n          }\n\n          setConfigObject(config);\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n        }\n      }\n    });\n  } // set args from config object.\n  // it recursively checks nested objects.\n\n\n  function setConfigObject(config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key];\n      var fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey);\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || flags.defaulted[fullKey] || flags.arrays[fullKey] && configuration['combine-arrays']) {\n          setArg(fullKey, value);\n        }\n      }\n    });\n  } // set all config objects passed in opts\n\n\n  function setConfigObjects() {\n    if (typeof configObjects === 'undefined') return;\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject);\n    });\n  }\n\n  function applyEnvVars(argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return;\n    var prefix = typeof envPrefix === 'string' ? envPrefix : '';\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length);\n          }\n\n          return camelCase(key);\n        });\n\n        if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar]);\n        }\n      }\n    });\n  }\n\n  function applyCoercions(argv) {\n    var coerce;\n    var applied = {};\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.hasOwnProperty(key)) {\n        // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions);\n\n        if (typeof coerce === 'function') {\n          try {\n            var value = coerce(argv[key]);\n            [].concat(flags.aliases[key] || [], key).forEach(ali => {\n              applied[ali] = argv[ali] = value;\n            });\n          } catch (err) {\n            error = err;\n          }\n        }\n      }\n    });\n  }\n\n  function setPlaceholderKeys(argv) {\n    flags.keys.forEach(key => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return;\n      if (typeof argv[key] === 'undefined') argv[key] = undefined;\n    });\n    return argv;\n  }\n\n  function applyDefaultsAndAliases(obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key]);\n        (aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return;\n          setKey(obj, x.split('.'), defaults[key]);\n        });\n      }\n    });\n  }\n\n  function hasKey(obj, keys) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      o = o[key] || {};\n    });\n    var key = keys[keys.length - 1];\n    if (typeof o !== 'object') return false;else return key in o;\n  }\n\n  function setKey(obj, keys, value) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key, index) {\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {};\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({});\n        } else {\n          o[key] = [o[key], {}];\n        } // we want to update the empty object at the end of the o[key] array, so set o to that object\n\n\n        o = o[key][o[key].length - 1];\n      } else {\n        o = o[key];\n      }\n    });\n    var key = keys[keys.length - 1];\n    var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n    var isValueArray = Array.isArray(value);\n    var duplicate = configuration['duplicate-arguments-array'];\n\n    if (value === increment) {\n      o[key] = increment(o[key]);\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value;\n      } else {\n        o[key] = o[key].concat([value]);\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value];\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [o[key], value];\n    } else {\n      o[key] = value;\n    }\n  } // extend the aliases list with inferred aliases.\n\n\n  function extendAliases() {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return;\n        flags.aliases[key] = [].concat(aliases[key] || []); // For \"--option-name\", also set argv.optionName\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x);\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        }); // For \"--optionName\", also set argv['option-name']\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            var c = decamelize(x, '-');\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        });\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y;\n          }));\n        });\n      });\n    });\n  } // check if a flag is set for any of a key's aliases.\n\n\n  function checkAllAliases(key, flag) {\n    var isSet = false;\n    var toCheck = [].concat(flags.aliases[key] || [], key);\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key];\n    });\n    return isSet;\n  }\n\n  function setDefaulted(key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true;\n    });\n  }\n\n  function unsetDefaulted(key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k];\n    });\n  } // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n\n\n  function defaultForType(type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    };\n    return def[type];\n  } // given a flag, enforce a default type.\n\n\n  function guessType(key, flags) {\n    var type = 'boolean';\n    if (checkAllAliases(key, flags.strings)) type = 'string';else if (checkAllAliases(key, flags.numbers)) type = 'number';else if (checkAllAliases(key, flags.arrays)) type = 'array';\n    return type;\n  }\n\n  function isNumber(x) {\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n  }\n\n  function isUndefined(num) {\n    return num === undefined;\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  };\n} // if any aliases reference each other, we should\n// merge them together.\n\n\nfunction combineAliases(aliases) {\n  var aliasArrays = [];\n  var change = true;\n  var combined = {}; // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  }); // combine arrays until zero changes are\n  // made in an iteration.\n\n  while (change) {\n    change = false;\n\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  } // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    combined[aliasArray.pop()] = aliasArray;\n  });\n  return combined;\n}\n\nfunction assign(defaults, configuration) {\n  var o = {};\n  configuration = configuration || {};\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k];\n  });\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k];\n  });\n  return o;\n} // this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\n\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n\nfunction Parser(args, opts) {\n  var result = parse(args.slice(), opts);\n  return result.argv;\n} // parse arguments and return detailed\n// meta information, aliases, etc.\n\n\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts);\n};\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/webpack-dev-server/node_modules/yargs-parser/index.js"],"names":["camelCase","require","decamelize","path","tokenizeArgString","util","parse","args","opts","aliases","combineAliases","alias","configuration","assign","defaults","default","configObjects","envPrefix","notFlagsOption","notFlagsArgv","newAliases","__","str","format","apply","Array","prototype","slice","call","arguments","error","flags","arrays","bools","strings","numbers","counts","normalize","configs","defaulted","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","array","filter","Boolean","forEach","opt","key","assignment","Object","map","boolean","string","number","pop","push","count","narg","k","coerce","isArray","config","extendAliases","argv","_","hasOwnProperty","setArg","setDefaulted","notFlags","i","length","arg","broken","letters","m","next","value","match","checkAllAliases","splice","eatNargs","eatArray","undefined","test","defaultForType","guessType","split","j","maybeCoerceNumber","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","ii","toEat","available","Error","consumed","Math","min","start","argsToSet","multipleArrayFlag","processValue","val","unsetDefaulted","prop","join","addNewAlias","splitKey","setKey","x","a","shift","__defineSetter__","v","__defineGetter__","isUndefined","increment","shouldCoerceNumber","isNumber","Number","isSafeInteger","floor","configLookup","configKey","configPath","resolvedConfigPath","resolve","process","cwd","e","setConfigObject","ex","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","substring","applied","ali","err","indexOf","obj","o","index","isTypeArray","isValueArray","duplicate","c","y","flag","isSet","toCheck","type","def","num","aliasArrays","change","combined","intersect","aliasArray","self","orig","Parser","result","detailed","module","exports"],"mappings":"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","sourcesContent":["var camelCase = require('camelcase')\nvar decamelize = require('decamelize')\nvar path = require('path')\nvar tokenizeArgString = require('./lib/tokenize-arg-string')\nvar util = require('util')\n\nfunction parse (args, opts) {\n  if (!opts) opts = {}\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {})\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'negation-prefix': 'no-',\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false,\n    'combine-arrays': false,\n    'set-placeholder-key': false,\n    'halt-at-non-option': false\n  }, opts.configuration)\n  var defaults = opts.default || {}\n  var configObjects = opts.configObjects || []\n  var envPrefix = opts.envPrefix\n  var notFlagsOption = configuration['populate--']\n  var notFlagsArgv = notFlagsOption ? '--' : '_'\n  var newAliases = {}\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments))\n  }\n  var error = null\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {},\n    keys: []\n  }\n  var negative = /^-[0-9]+(\\.[0-9]+)?/\n  var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    var key = opt.key || opt\n\n    // assign to flags[bools|strings|numbers]\n    const assignment = Object.keys(opt).map(function (key) {\n      return ({\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      })[key]\n    }).filter(Boolean).pop()\n\n    // assign key to be coerced\n    if (assignment) {\n      flags[assignment][key] = true\n    }\n\n    flags.arrays[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n    flags.keys.push(key)\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n    flags.keys.push(k)\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n    flags.keys.push(k)\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  var argv = { _: [] }\n\n  Object.keys(flags.bools).forEach(function (key) {\n    if (Object.prototype.hasOwnProperty.call(defaults, key)) {\n      setArg(key, defaults[key])\n      setDefaulted(key)\n    }\n  })\n\n  var notFlags = []\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    var broken\n    var key\n    var letters\n    var m\n    var next\n    var value\n\n    // -- separated by =\n    if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatNargs(i, m[1], args)\n      // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2])\n        i = eatArray(i, m[1], args)\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1]\n      setArg(key, false)\n\n    // -- seperated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      // nargs format = '--foo a b c'\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args)\n      // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)))\n        }\n      }\n\n    // dot-notation flag seperated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value)\n            i = eatNargs(i, key, args)\n          // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value)\n            i = eatArray(i, key, args)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args)\n        // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)))\n          }\n        }\n      }\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1)\n      break\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i)\n      break\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg))\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults)\n  applyCoercions(argv)\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args) {\n    var ii\n    const toEat = checkAllAliases(key, flags.nargs)\n\n    // nargs will not consume flag arguments, e.g., -abc, --foo,\n    // and terminates when one is observed.\n    var available = 0\n    for (ii = i + 1; ii < args.length; ii++) {\n      if (!args[ii].match(/^-[^0-9]/)) available++\n      else break\n    }\n\n    if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\n\n    const consumed = Math.min(available, toEat)\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + consumed)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args) {\n    var start = i + 1\n    var argsToSet = []\n    var multipleArrayFlag = i > 0\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'))\n        }\n        multipleArrayFlag = true\n        break\n      }\n      i = ii\n      argsToSet.push(args[ii])\n    }\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg)\n      }))\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg)\n      })\n    }\n\n    return i\n  }\n\n  function setArg (key, val) {\n    unsetDefaulted(key)\n\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      var alias = key.split('.').map(function (prop) {\n        return camelCase(prop)\n      }).join('.')\n      addNewAlias(key, alias)\n    }\n\n    var value = processValue(key, val)\n\n    var splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        setKey(argv, x, value)\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v)\n        })\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val\n        })\n      })\n    }\n  }\n\n  function addNewAlias (key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias]\n      newAliases[alias] = true\n    }\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key)\n    }\n  }\n\n  function processValue (key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    var value = maybeCoerceNumber(key, val)\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  function maybeCoerceNumber (key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\n        Number.isSafeInteger(Math.floor(value))\n      )\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    var configLookup = {}\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          var config = null\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key]\n      var fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey]) || (flags.arrays[fullKey] && configuration['combine-arrays'])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    var prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    var coerce\n    var applied = {}\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.hasOwnProperty(key)) { // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions)\n        if (typeof coerce === 'function') {\n          try {\n            var value = coerce(argv[key])\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n              applied[ali] = argv[ali] = value\n            })\n          } catch (err) {\n            error = err\n          }\n        }\n      }\n    })\n  }\n\n  function setPlaceholderKeys (argv) {\n    flags.keys.forEach((key) => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    var key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key, index) {\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {}\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({})\n        } else {\n          o[key] = [o[key], {}]\n        }\n\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\n        o = o[key][o[key].length - 1]\n      } else {\n        o = o[key]\n      }\n    })\n\n    var key = keys[keys.length - 1]\n\n    var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    var isValueArray = Array.isArray(value)\n    var duplicate = configuration['duplicate-arguments-array']\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [ o[key], value ]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases () {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x)\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        // For \"--optionName\", also set argv['option-name']\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            var c = decamelize(x, '-')\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases (key, flag) {\n    var isSet = false\n    var toCheck = [].concat(flags.aliases[key] || [], key)\n\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key]\n    })\n\n    return isSet\n  }\n\n  function setDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true\n    })\n  }\n\n  function unsetDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k]\n    })\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key, flags) {\n    var type = 'boolean'\n\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n\n    return type\n  }\n\n  function isNumber (x) {\n    if (typeof x === 'number') return true\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  var aliasArrays = []\n  var change = true\n  var combined = {}\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\nfunction assign (defaults, configuration) {\n  var o = {}\n  configuration = configuration || {}\n\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k]\n  })\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k]\n  })\n\n  return o\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  var result = parse(args.slice(), opts)\n\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\nmodule.exports = Parser\n"]},"metadata":{},"sourceType":"script"}