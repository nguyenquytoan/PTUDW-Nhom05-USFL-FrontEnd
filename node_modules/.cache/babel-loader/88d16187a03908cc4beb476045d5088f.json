{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { messageSW } from './messageSW.mjs';\nimport { EventTargetShim } from './utils/EventTargetShim.mjs';\nimport { urlsMatch } from './utils/urlsMatch.mjs';\nimport { WorkboxEvent } from './utils/WorkboxEvent.mjs';\nimport './_version.mjs'; // The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\n\nconst WAITING_TIMEOUT_DURATION = 200; // The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\n\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n *\n * @memberof module:workbox-window\n */\n\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0; // Deferreds we can resolve later.\n\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred(); // Bind event handler callbacks.\n\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n\n\n  async register({\n    immediate = false\n  } = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' + 'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise(res => addEventListener('load', res));\n    } // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n\n\n    this._isUpdate = Boolean(navigator.serviceWorker.controller); // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n    this._registration = await this._registerScript(); // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n\n      this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, {\n        once: true\n      });\n    } // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the prevoius\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n\n\n    const waitingSW = this._registration.waiting;\n\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW; // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true\n        }));\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' + 'before this script was registered...');\n        }\n      });\n    } // If an \"own\" SW is already set, resolve the deferred.\n\n\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' + 'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' + 'currently controlling the page. The browser is now fetching ' + 'the new script now...');\n        }\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' + 'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n\n    navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange, {\n      once: true\n    }); // Add message listeners.\n\n    if ('BroadcastChannel' in self) {\n      this._broadcastChannel = new BroadcastChannel('workbox');\n\n      this._broadcastChannel.addEventListener('message', this._onMessage);\n    }\n\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n    return this._registration;\n  }\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  get active() {\n    return this._activeDeferred.promise;\n  }\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  async getSW() {\n    // If `this._sw` is set, resolve with that as we want `getSW()` to\n    // return the correct (new) service worker if an update is found.\n    return this._sw || this._swDeferred.promise;\n  }\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n\n\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return messageSW(sw, data);\n  }\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matchs.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n\n\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    }\n  }\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n\n\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions); // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n\n      this._registrationTime = performance.now();\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      } // Re-throw the error.\n\n\n      throw error;\n    }\n  }\n  /**\n   * Sends a message to the passed service worker that the window is ready.\n   *\n   * @param {ServiceWorker} sw\n   * @private\n   */\n\n\n  _reportWindowReady(sw) {\n    messageSW(sw, {\n      type: 'WINDOW_READY',\n      meta: 'workbox-window'\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _onUpdateFound() {\n    const installingSW = this._registration.installing; // If the script URL passed to `navigator.serviceWorker.register()` is\n    // different from the current controlling SW's script URL, we know any\n    // successful registration calls will trigger an `updatefound` event.\n    // But if the registered script URL is the same as the current controlling\n    // SW's script URL, we'll only get an `updatefound` event if the file\n    // changed since it was last registered. This can be a problem if the user\n    // opens up the same page in a different tab, and that page registers\n    // a SW that triggers an update. It's a problem because this page has no\n    // good way of knowing whether the `updatefound` event came from the SW\n    // script it registered or from a registration attempt made by a newer\n    // version of the page running in another tab.\n    // To minimize the possibility of a false positive, we use the logic here:\n\n    let updateLikelyTriggeredExternally = // Since we enforce only calling `register()` once, and since we don't\n    // add the `updatefound` event listener until the `register()` call, if\n    // `_updateFoundCount` is > 0 then it means this method has already\n    // been called, thus this SW must be external\n    this._updateFoundCount > 0 || // If the script URL of the installing SW is different from this\n    // instance's script URL, we know it's definitely not from our\n    // registration.\n    !urlsMatch(installingSW.scriptURL, this._scriptURL) || // If all of the above are false, then we use a time-based heuristic:\n    // Any `updatefound` event that occurs long after our registration is\n    // assumed to be external.\n    performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION ? // If any of the above are not true, we assume the update was\n    // triggered by this instance.\n    true : false;\n\n    if (updateLikelyTriggeredExternally) {\n      this._externalSW = installingSW;\n\n      this._registration.removeEventListener('updatefound', this._onUpdateFound);\n    } else {\n      // If the update was not triggered externally we know the installing\n      // SW is the one we registered, so we set it.\n      this._sw = installingSW;\n\n      this._swDeferred.resolve(installingSW); // The `installing` state isn't something we have a dedicated\n      // callback for, but we do log messages for it in development.\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (navigator.serviceWorker.controller) {\n          logger.log('Updated service worker found. Installing now...');\n        } else {\n          logger.log('Service worker is installing...');\n        }\n      }\n    } // Increment the `updatefound` count, so future invocations of this\n    // method can be sure they were triggered externally.\n\n\n    ++this._updateFoundCount; // Add a `statechange` listener regardless of whether this update was\n    // triggered externally, since we have callbacks for both.\n\n    installingSW.addEventListener('statechange', this._onStateChange);\n  }\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n\n\n  _onStateChange(originalEvent) {\n    const sw = originalEvent.target;\n    const {\n      state\n    } = sw;\n    const isExternal = sw === this._externalSW;\n    const eventPrefix = isExternal ? 'external' : '';\n    const eventProps = {\n      sw,\n      originalEvent\n    };\n\n    if (!isExternal && this._isUpdate) {\n      eventProps.isUpdate = true;\n    }\n\n    this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n\n    if (state === 'installed') {\n      // This timeout is used to ignore cases where the service worker calls\n      // `skipWaiting()` in the install event, thus moving it directly in the\n      // activating state. (Since all service workers *must* go through the\n      // waiting phase, the only way to detect `skipWaiting()` called in the\n      // install event is to observe that the time spent in the waiting phase\n      // is very short.)\n      // NOTE: we don't need separate timeouts for the own and external SWs\n      // since they can't go through these phases at the same time.\n      this._waitingTimeout = setTimeout(() => {\n        // Ensure the SW is still waiting (it may now be redundant).\n        if (state === 'installed' && this._registration.waiting === sw) {\n          this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (isExternal) {\n              logger.warn('An external service worker has installed but is ' + 'waiting for this client to close before activating...');\n            } else {\n              logger.warn('The service worker has installed but is waiting ' + 'for existing clients to close before activating...');\n            }\n          }\n        }\n      }, WAITING_TIMEOUT_DURATION);\n    } else if (state === 'activating') {\n      clearTimeout(this._waitingTimeout);\n\n      if (!isExternal) {\n        this._activeDeferred.resolve(sw);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      switch (state) {\n        case 'installed':\n          if (isExternal) {\n            logger.warn('An external service worker has installed. ' + 'You may want to suggest users reload this page.');\n          } else {\n            logger.log('Registered service worker installed.');\n          }\n\n          break;\n\n        case 'activated':\n          if (isExternal) {\n            logger.warn('An external service worker has activated.');\n          } else {\n            logger.log('Registered service worker activated.');\n\n            if (sw !== navigator.serviceWorker.controller) {\n              logger.warn('The registered service worker is active but ' + 'not yet controlling the page. Reload or run ' + '`clients.claim()` in the service worker.');\n            }\n          }\n\n          break;\n\n        case 'redundant':\n          if (sw === this._compatibleControllingSW) {\n            logger.log('Previously controlling service worker now redundant!');\n          } else if (!isExternal) {\n            logger.log('Registered service worker now redundant!');\n          }\n\n          break;\n      }\n    }\n  }\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n\n\n  _onControllerChange(originalEvent) {\n    const sw = this._sw;\n\n    if (sw === navigator.serviceWorker.controller) {\n      this.dispatchEvent(new WorkboxEvent('controlling', {\n        sw,\n        originalEvent\n      }));\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered service worker now controlling this page.');\n      }\n\n      this._controllingDeferred.resolve(sw);\n    }\n  }\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n\n\n  _onMessage(originalEvent) {\n    const {\n      data\n    } = originalEvent;\n    this.dispatchEvent(new WorkboxEvent('message', {\n      data,\n      originalEvent\n    }));\n  }\n\n} // The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` (or a\n * `BroadcastChannel` message with the `workbox` channel name) is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The native `controllerchange` event\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n\nexport { Workbox };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-window/Workbox.mjs"],"names":["Deferred","logger","messageSW","EventTargetShim","urlsMatch","WorkboxEvent","WAITING_TIMEOUT_DURATION","REGISTRATION_TIMEOUT_DURATION","Workbox","constructor","scriptURL","registerOptions","_scriptURL","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_onMessage","bind","_onStateChange","_onUpdateFound","_onControllerChange","register","immediate","process","env","NODE_ENV","_registrationTime","error","document","readyState","Promise","res","addEventListener","_isUpdate","Boolean","navigator","serviceWorker","controller","_compatibleControllingSW","_getControllingSWIfCompatible","_registration","_registerScript","_sw","resolve","_reportWindowReady","once","waitingSW","waiting","then","dispatchEvent","sw","wasWaitingBeforeRegister","warn","log","debug","currentPageIsOutOfScope","scopeURL","URL","scope","baseURI","scopeURLBasePath","href","pathname","location","startsWith","self","_broadcastChannel","BroadcastChannel","active","promise","controlling","getSW","data","reg","performance","now","type","meta","installingSW","installing","updateLikelyTriggeredExternally","_externalSW","removeEventListener","originalEvent","target","state","isExternal","eventPrefix","eventProps","isUpdate","_waitingTimeout","setTimeout","clearTimeout"],"mappings":"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","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {messageSW} from './messageSW.mjs';\nimport {EventTargetShim} from './utils/EventTargetShim.mjs';\nimport {urlsMatch} from './utils/urlsMatch.mjs';\nimport {WorkboxEvent} from './utils/WorkboxEvent.mjs';\nimport './_version.mjs';\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n *\n * @memberof module:workbox-window\n */\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0;\n\n    // Deferreds we can resolve later.\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n\n    // Bind event handler callbacks.\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n  async register({immediate = false} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' +\n            'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise((res) => addEventListener('load', res));\n    }\n\n    // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n    this._isUpdate = Boolean(navigator.serviceWorker.controller);\n\n    // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n\n    this._registration = await this._registerScript();\n\n    // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n      this._compatibleControllingSW.addEventListener(\n          'statechange', this._onStateChange, {once: true});\n    }\n\n    // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the prevoius\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n    const waitingSW = this._registration.waiting;\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW;\n\n      // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true,\n        }));\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' +\n              'before this script was registered...');\n        }\n      });\n    }\n\n    // If an \"own\" SW is already set, resolve the deferred.\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' +\n              'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' +\n              'currently controlling the page. The browser is now fetching ' +\n              'the new script now...');\n        }\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(\n            this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' +\n            'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n    navigator.serviceWorker.addEventListener(\n        'controllerchange', this._onControllerChange, {once: true});\n\n    // Add message listeners.\n    if ('BroadcastChannel' in self) {\n      this._broadcastChannel = new BroadcastChannel('workbox');\n      this._broadcastChannel.addEventListener('message', this._onMessage);\n    }\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n\n    return this._registration;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get active() {\n    return this._activeDeferred.promise;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  async getSW() {\n    // If `this._sw` is set, resolve with that as we want `getSW()` to\n    // return the correct (new) service worker if an update is found.\n    return this._sw || this._swDeferred.promise;\n  }\n\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return messageSW(sw, data);\n  }\n\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matchs.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    }\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(\n          this._scriptURL, this._registerOptions);\n\n      // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n      this._registrationTime = performance.now();\n\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      }\n      // Re-throw the error.\n      throw error;\n    }\n  }\n\n\n  /**\n   * Sends a message to the passed service worker that the window is ready.\n   *\n   * @param {ServiceWorker} sw\n   * @private\n   */\n  _reportWindowReady(sw) {\n    messageSW(sw, {\n      type: 'WINDOW_READY',\n      meta: 'workbox-window',\n    });\n  }\n\n  /**\n   * @private\n   */\n  _onUpdateFound() {\n    const installingSW = this._registration.installing;\n\n    // If the script URL passed to `navigator.serviceWorker.register()` is\n    // different from the current controlling SW's script URL, we know any\n    // successful registration calls will trigger an `updatefound` event.\n    // But if the registered script URL is the same as the current controlling\n    // SW's script URL, we'll only get an `updatefound` event if the file\n    // changed since it was last registered. This can be a problem if the user\n    // opens up the same page in a different tab, and that page registers\n    // a SW that triggers an update. It's a problem because this page has no\n    // good way of knowing whether the `updatefound` event came from the SW\n    // script it registered or from a registration attempt made by a newer\n    // version of the page running in another tab.\n    // To minimize the possibility of a false positive, we use the logic here:\n    let updateLikelyTriggeredExternally =\n        // Since we enforce only calling `register()` once, and since we don't\n        // add the `updatefound` event listener until the `register()` call, if\n        // `_updateFoundCount` is > 0 then it means this method has already\n        // been called, thus this SW must be external\n        this._updateFoundCount > 0 ||\n        // If the script URL of the installing SW is different from this\n        // instance's script URL, we know it's definitely not from our\n        // registration.\n        !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n        // If all of the above are false, then we use a time-based heuristic:\n        // Any `updatefound` event that occurs long after our registration is\n        // assumed to be external.\n        (performance.now() >\n            this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n\n    if (updateLikelyTriggeredExternally) {\n      this._externalSW = installingSW;\n      this._registration.removeEventListener(\n          'updatefound', this._onUpdateFound);\n    } else {\n      // If the update was not triggered externally we know the installing\n      // SW is the one we registered, so we set it.\n      this._sw = installingSW;\n      this._swDeferred.resolve(installingSW);\n\n      // The `installing` state isn't something we have a dedicated\n      // callback for, but we do log messages for it in development.\n      if (process.env.NODE_ENV !== 'production') {\n        if (navigator.serviceWorker.controller) {\n          logger.log('Updated service worker found. Installing now...');\n        } else {\n          logger.log('Service worker is installing...');\n        }\n      }\n    }\n\n    // Increment the `updatefound` count, so future invocations of this\n    // method can be sure they were triggered externally.\n    ++this._updateFoundCount;\n\n    // Add a `statechange` listener regardless of whether this update was\n    // triggered externally, since we have callbacks for both.\n    installingSW.addEventListener('statechange', this._onStateChange);\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onStateChange(originalEvent) {\n    const sw = originalEvent.target;\n    const {state} = sw;\n    const isExternal = sw === this._externalSW;\n    const eventPrefix = isExternal ? 'external' : '';\n\n    const eventProps = {sw, originalEvent};\n    if (!isExternal && this._isUpdate) {\n      eventProps.isUpdate = true;\n    }\n\n    this.dispatchEvent(new WorkboxEvent(\n        eventPrefix + state, eventProps));\n\n    if (state === 'installed') {\n      // This timeout is used to ignore cases where the service worker calls\n      // `skipWaiting()` in the install event, thus moving it directly in the\n      // activating state. (Since all service workers *must* go through the\n      // waiting phase, the only way to detect `skipWaiting()` called in the\n      // install event is to observe that the time spent in the waiting phase\n      // is very short.)\n      // NOTE: we don't need separate timeouts for the own and external SWs\n      // since they can't go through these phases at the same time.\n      this._waitingTimeout = setTimeout(() => {\n        // Ensure the SW is still waiting (it may now be redundant).\n        if (state === 'installed' && this._registration.waiting === sw) {\n          this.dispatchEvent(new WorkboxEvent(\n              eventPrefix + 'waiting', eventProps));\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (isExternal) {\n              logger.warn('An external service worker has installed but is ' +\n                  'waiting for this client to close before activating...');\n            } else {\n              logger.warn('The service worker has installed but is waiting ' +\n                  'for existing clients to close before activating...');\n            }\n          }\n        }\n      }, WAITING_TIMEOUT_DURATION);\n    } else if (state === 'activating') {\n      clearTimeout(this._waitingTimeout);\n      if (!isExternal) {\n        this._activeDeferred.resolve(sw);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      switch (state) {\n        case 'installed':\n          if (isExternal) {\n            logger.warn('An external service worker has installed. ' +\n                'You may want to suggest users reload this page.');\n          } else {\n            logger.log('Registered service worker installed.');\n          }\n          break;\n        case 'activated':\n          if (isExternal) {\n            logger.warn('An external service worker has activated.');\n          } else {\n            logger.log('Registered service worker activated.');\n            if (sw !== navigator.serviceWorker.controller) {\n              logger.warn('The registered service worker is active but ' +\n                  'not yet controlling the page. Reload or run ' +\n                  '`clients.claim()` in the service worker.');\n            }\n          }\n          break;\n        case 'redundant':\n          if (sw === this._compatibleControllingSW) {\n            logger.log('Previously controlling service worker now redundant!');\n          } else if (!isExternal) {\n            logger.log('Registered service worker now redundant!');\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onControllerChange(originalEvent) {\n    const sw = this._sw;\n    if (sw === navigator.serviceWorker.controller) {\n      this.dispatchEvent(new WorkboxEvent('controlling', {sw, originalEvent}));\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered service worker now controlling this page.');\n      }\n      this._controllingDeferred.resolve(sw);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onMessage(originalEvent) {\n    const {data} = originalEvent;\n    this.dispatchEvent(new WorkboxEvent('message', {data, originalEvent}));\n  }\n}\n\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` (or a\n * `BroadcastChannel` message with the `workbox` channel name) is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The native `controllerchange` event\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\nexport {Workbox};\n"]},"metadata":{},"sourceType":"module"}