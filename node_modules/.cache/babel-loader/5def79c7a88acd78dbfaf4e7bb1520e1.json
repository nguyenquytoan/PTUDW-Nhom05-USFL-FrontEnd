{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.backgroundSync = function (exports, WorkboxError_mjs, logger_mjs, assert_mjs, getFriendlyURL_mjs, DBWrapper_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:background-sync:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const DB_VERSION = 3;\n  const DB_NAME = 'workbox-background-sync';\n  const OBJECT_STORE_NAME = 'requests';\n  const INDEXED_PROP = 'queueName';\n  /**\n   * A class to manage storing requests from a Queue in IndexedbDB,\n   * indexed by their queue name for easier access.\n   *\n   * @private\n   */\n\n  class QueueStore {\n    /**\n     * Associates this instance with a Queue instance, so entries added can be\n     * identified by their queue name.\n     *\n     * @param {string} queueName\n     * @private\n     */\n    constructor(queueName) {\n      this._queueName = queueName;\n      this._db = new DBWrapper_mjs.DBWrapper(DB_NAME, DB_VERSION, {\n        onupgradeneeded: this._upgradeDb\n      });\n    }\n    /**\n     * Append an entry last in the queue.\n     *\n     * @param {Object} entry\n     * @param {Object} entry.requestData\n     * @param {number} [entry.timestamp]\n     * @param {Object} [entry.metadata]\n     * @private\n     */\n\n\n    async pushEntry(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'pushEntry',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isType(entry.requestData, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'pushEntry',\n          paramName: 'entry.requestData'\n        });\n      } // Don't specify an ID since one is automatically generated.\n\n      delete entry.id;\n      entry.queueName = this._queueName;\n      await this._db.add(OBJECT_STORE_NAME, entry);\n    }\n    /**\n     * Preppend an entry first in the queue.\n     *\n     * @param {Object} entry\n     * @param {Object} entry.requestData\n     * @param {number} [entry.timestamp]\n     * @param {Object} [entry.metadata]\n     * @private\n     */\n\n\n    async unshiftEntry(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'unshiftEntry',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isType(entry.requestData, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'unshiftEntry',\n          paramName: 'entry.requestData'\n        });\n      }\n      const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n        count: 1\n      });\n\n      if (firstEntry) {\n        // Pick an ID one less than the lowest ID in the object store.\n        entry.id = firstEntry.id - 1;\n      } else {\n        // Otherwise let the auto-incrementor assign the ID.\n        delete entry.id;\n      }\n\n      entry.queueName = this._queueName;\n      await this._db.add(OBJECT_STORE_NAME, entry);\n    }\n    /**\n     * Removes and returns the last entry in the queue matching the `queueName`.\n     *\n     * @return {Promise<Object>}\n     * @private\n     */\n\n\n    async popEntry() {\n      return this._removeEntry({\n        direction: 'prev'\n      });\n    }\n    /**\n     * Removes and returns the first entry in the queue matching the `queueName`.\n     *\n     * @return {Promise<Object>}\n     * @private\n     */\n\n\n    async shiftEntry() {\n      return this._removeEntry({\n        direction: 'next'\n      });\n    }\n    /**\n     * Returns all entries in the store matching the `queueName`.\n     *\n     * @param {Object} options See workbox.backgroundSync.Queue~getAll}\n     * @return {Promise<Array<Object>>}\n     * @private\n     */\n\n\n    async getAll() {\n      return await this._db.getAllMatching(OBJECT_STORE_NAME, {\n        index: INDEXED_PROP,\n        query: IDBKeyRange.only(this._queueName)\n      });\n    }\n    /**\n     * Deletes the entry for the given ID.\n     *\n     * WARNING: this method does not ensure the deleted enry belongs to this\n     * queue (i.e. matches the `queueName`). But this limitation is acceptable\n     * as this class is not publicly exposed. An additional check would make\n     * this method slower than it needs to be.\n     *\n     * @private\n     * @param {number} id\n     */\n\n\n    async deleteEntry(id) {\n      await this._db.delete(OBJECT_STORE_NAME, id);\n    }\n    /**\n     * Removes and returns the first or last entry in the queue (based on the\n     * `direction` argument) matching the `queueName`.\n     *\n     * @return {Promise<Object>}\n     * @private\n     */\n\n\n    async _removeEntry({\n      direction\n    }) {\n      const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n        direction,\n        index: INDEXED_PROP,\n        query: IDBKeyRange.only(this._queueName),\n        count: 1\n      });\n\n      if (entry) {\n        await this.deleteEntry(entry.id);\n        return entry;\n      }\n    }\n    /**\n     * Upgrades the database given an `upgradeneeded` event.\n     *\n     * @param {Event} event\n     * @private\n     */\n\n\n    _upgradeDb(event) {\n      const db = event.target.result;\n\n      if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {\n        if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {\n          db.deleteObjectStore(OBJECT_STORE_NAME);\n        }\n      }\n\n      const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n        autoIncrement: true,\n        keyPath: 'id'\n      });\n      objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {\n        unique: false\n      });\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const serializableProperties = ['method', 'referrer', 'referrerPolicy', 'mode', 'credentials', 'cache', 'redirect', 'integrity', 'keepalive'];\n  /**\n   * A class to make it easier to serialize and de-serialize requests so they\n   * can be stored in IndexedDB.\n   *\n   * @private\n   */\n\n  class StorableRequest {\n    /**\n     * Converts a Request object to a plain object that can be structured\n     * cloned or JSON-stringified.\n     *\n     * @param {Request} request\n     * @return {Promise<StorableRequest>}\n     *\n     * @private\n     */\n    static async fromRequest(request) {\n      const requestData = {\n        url: request.url,\n        headers: {}\n      }; // Set the body if present.\n\n      if (request.method !== 'GET') {\n        // Use ArrayBuffer to support non-text request bodies.\n        // NOTE: we can't use Blobs becuse Safari doesn't support storing\n        // Blobs in IndexedDB in some cases:\n        // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457\n        requestData.body = await request.clone().arrayBuffer();\n      } // Convert the headers from an iterable to an object.\n\n\n      for (const [key, value] of request.headers.entries()) {\n        requestData.headers[key] = value;\n      } // Add all other serializable request properties\n\n\n      for (const prop of serializableProperties) {\n        if (request[prop] !== undefined) {\n          requestData[prop] = request[prop];\n        }\n      }\n\n      return new StorableRequest(requestData);\n    }\n    /**\n     * Accepts an object of request data that can be used to construct a\n     * `Request` but can also be stored in IndexedDB.\n     *\n     * @param {Object} requestData An object of request data that includes the\n     *     `url` plus any relevant properties of\n     *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.\n     * @private\n     */\n\n\n    constructor(requestData) {\n      {\n        assert_mjs.assert.isType(requestData, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'StorableRequest',\n          funcName: 'constructor',\n          paramName: 'requestData'\n        });\n        assert_mjs.assert.isType(requestData.url, 'string', {\n          moduleName: 'workbox-background-sync',\n          className: 'StorableRequest',\n          funcName: 'constructor',\n          paramName: 'requestData.url'\n        });\n      } // If the request's mode is `navigate`, convert it to `same-origin` since\n      // navigation requests can't be constructed via script.\n\n      if (requestData.mode === 'navigate') {\n        requestData.mode = 'same-origin';\n      }\n\n      this._requestData = requestData;\n    }\n    /**\n     * Returns a deep clone of the instances `_requestData` object.\n     *\n     * @return {Object}\n     *\n     * @private\n     */\n\n\n    toObject() {\n      const requestData = Object.assign({}, this._requestData);\n      requestData.headers = Object.assign({}, this._requestData.headers);\n\n      if (requestData.body) {\n        requestData.body = requestData.body.slice(0);\n      }\n\n      return requestData;\n    }\n    /**\n     * Converts this instance to a Request.\n     *\n     * @return {Request}\n     *\n     * @private\n     */\n\n\n    toRequest() {\n      return new Request(this._requestData.url, this._requestData);\n    }\n    /**\n     * Creates and returns a deep clone of the instance.\n     *\n     * @return {StorableRequest}\n     *\n     * @private\n     */\n\n\n    clone() {\n      return new StorableRequest(this.toObject());\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const TAG_PREFIX = 'workbox-background-sync';\n  const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes\n\n  const queueNames = new Set();\n  /**\n   * A class to manage storing failed requests in IndexedDB and retrying them\n   * later. All parts of the storing and replaying process are observable via\n   * callbacks.\n   *\n   * @memberof workbox.backgroundSync\n   */\n\n  class Queue {\n    /**\n     * Creates an instance of Queue with the given options\n     *\n     * @param {string} name The unique name for this queue. This name must be\n     *     unique as it's used to register sync events and store requests\n     *     in IndexedDB specific to this instance. An error will be thrown if\n     *     a duplicate name is detected.\n     * @param {Object} [options]\n     * @param {Function} [options.onSync] A function that gets invoked whenever\n     *     the 'sync' event fires. The function is invoked with an object\n     *     containing the `queue` property (referencing this instance), and you\n     *     can use the callback to customize the replay behavior of the queue.\n     *     When not set the `replayRequests()` method is called.\n     *     Note: if the replay fails after a sync event, make sure you throw an\n     *     error, so the browser knows to retry the sync event later.\n     * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n     *     minutes) a request may be retried. After this amount of time has\n     *     passed, the request will be deleted from the queue.\n     */\n    constructor(name, {\n      onSync,\n      maxRetentionTime\n    } = {}) {\n      // Ensure the store name is not already being used\n      if (queueNames.has(name)) {\n        throw new WorkboxError_mjs.WorkboxError('duplicate-queue-name', {\n          name\n        });\n      } else {\n        queueNames.add(name);\n      }\n\n      this._name = name;\n      this._onSync = onSync || this.replayRequests;\n      this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n      this._queueStore = new QueueStore(this._name);\n\n      this._addSyncListener();\n    }\n    /**\n     * @return {string}\n     */\n\n\n    get name() {\n      return this._name;\n    }\n    /**\n     * Stores the passed request in IndexedDB (with its timestamp and any\n     * metadata) at the end of the queue.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request The request to store in the queue.\n     * @param {Object} [entry.metadata] Any metadata you want associated with the\n     *     stored request. When requests are replayed you'll have access to this\n     *     metadata object in case you need to modify the request beforehand.\n     * @param {number} [entry.timestamp] The timestamp (Epoch time in\n     *     milliseconds) when the request was first added to the queue. This is\n     *     used along with `maxRetentionTime` to remove outdated requests. In\n     *     general you don't need to set this value, as it's automatically set\n     *     for you (defaulting to `Date.now()`), but you can update it if you\n     *     don't want particular requests to expire.\n     */\n\n\n    async pushRequest(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'pushRequest',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isInstance(entry.request, Request, {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'pushRequest',\n          paramName: 'entry.request'\n        });\n      }\n      await this._addRequest(entry, 'push');\n    }\n    /**\n     * Stores the passed request in IndexedDB (with its timestamp and any\n     * metadata) at the beginning of the queue.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request The request to store in the queue.\n     * @param {Object} [entry.metadata] Any metadata you want associated with the\n     *     stored request. When requests are replayed you'll have access to this\n     *     metadata object in case you need to modify the request beforehand.\n     * @param {number} [entry.timestamp] The timestamp (Epoch time in\n     *     milliseconds) when the request was first added to the queue. This is\n     *     used along with `maxRetentionTime` to remove outdated requests. In\n     *     general you don't need to set this value, as it's automatically set\n     *     for you (defaulting to `Date.now()`), but you can update it if you\n     *     don't want particular requests to expire.\n     */\n\n\n    async unshiftRequest(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'unshiftRequest',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isInstance(entry.request, Request, {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'unshiftRequest',\n          paramName: 'entry.request'\n        });\n      }\n      await this._addRequest(entry, 'unshift');\n    }\n    /**\n     * Removes and returns the last request in the queue (along with its\n     * timestamp and any metadata). The returned object takes the form:\n     * `{request, timestamp, metadata}`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async popRequest() {\n      return this._removeRequest('pop');\n    }\n    /**\n     * Removes and returns the first request in the queue (along with its\n     * timestamp and any metadata). The returned object takes the form:\n     * `{request, timestamp, metadata}`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async shiftRequest() {\n      return this._removeRequest('shift');\n    }\n    /**\n     * Returns all the entries that have not expired (per `maxRetentionTime`).\n     * Any expired entries are removed from the queue.\n     *\n     * @return {Promise<Array<Object>>}\n     */\n\n\n    async getAll() {\n      const allEntries = await this._queueStore.getAll();\n      const now = Date.now();\n      const unexpiredEntries = [];\n\n      for (const entry of allEntries) {\n        // Ignore requests older than maxRetentionTime. Call this function\n        // recursively until an unexpired request is found.\n        const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n        if (now - entry.timestamp > maxRetentionTimeInMs) {\n          await this._queueStore.deleteEntry(entry.id);\n        } else {\n          unexpiredEntries.push(convertEntry(entry));\n        }\n      }\n\n      return unexpiredEntries;\n    }\n    /**\n     * Adds the entry to the QueueStore and registers for a sync event.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request\n     * @param {Object} [entry.metadata]\n     * @param {number} [entry.timestamp=Date.now()]\n     * @param {string} operation ('push' or 'unshift')\n     * @private\n     */\n\n\n    async _addRequest({\n      request,\n      metadata,\n      timestamp = Date.now()\n    }, operation) {\n      const storableRequest = await StorableRequest.fromRequest(request.clone());\n      const entry = {\n        requestData: storableRequest.toObject(),\n        timestamp\n      }; // Only include metadata if it's present.\n\n      if (metadata) {\n        entry.metadata = metadata;\n      }\n\n      await this._queueStore[`${operation}Entry`](entry);\n      {\n        logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n      } // Don't register for a sync if we're in the middle of a sync. Instead,\n      // we wait until the sync is complete and call register if\n      // `this._requestsAddedDuringSync` is true.\n\n      if (this._syncInProgress) {\n        this._requestsAddedDuringSync = true;\n      } else {\n        await this.registerSync();\n      }\n    }\n    /**\n     * Removes and returns the first or last (depending on `operation`) entry\n     * from the QueueStore that's not older than the `maxRetentionTime`.\n     *\n     * @param {string} operation ('pop' or 'shift')\n     * @return {Object|undefined}\n     * @private\n     */\n\n\n    async _removeRequest(operation) {\n      const now = Date.now();\n      const entry = await this._queueStore[`${operation}Entry`]();\n\n      if (entry) {\n        // Ignore requests older than maxRetentionTime. Call this function\n        // recursively until an unexpired request is found.\n        const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n        if (now - entry.timestamp > maxRetentionTimeInMs) {\n          return this._removeRequest(operation);\n        }\n\n        return convertEntry(entry);\n      }\n    }\n    /**\n     * Loops through each request in the queue and attempts to re-fetch it.\n     * If any request fails to re-fetch, it's put back in the same position in\n     * the queue (which registers a retry for the next sync event).\n     */\n\n\n    async replayRequests() {\n      let entry;\n\n      while (entry = await this.shiftRequest()) {\n        try {\n          await fetch(entry.request.clone());\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(entry.request.url)}'` + `has been replayed in queue '${this._name}'`);\n          }\n        } catch (error) {\n          await this.unshiftRequest(entry);\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(entry.request.url)}'` + `failed to replay, putting it back in queue '${this._name}'`);\n          }\n          throw new WorkboxError_mjs.WorkboxError('queue-replay-failed', {\n            name: this._name\n          });\n        }\n      }\n\n      {\n        logger_mjs.logger.log(`All requests in queue '${this.name}' have successfully ` + `replayed; the queue is now empty!`);\n      }\n    }\n    /**\n     * Registers a sync event with a tag unique to this instance.\n     */\n\n\n    async registerSync() {\n      if ('sync' in registration) {\n        try {\n          await registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n        } catch (err) {\n          // This means the registration failed for some reason, possibly due to\n          // the user disabling it.\n          {\n            logger_mjs.logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n          }\n        }\n      }\n    }\n    /**\n     * In sync-supporting browsers, this adds a listener for the sync event.\n     * In non-sync-supporting browsers, this will retry the queue on service\n     * worker startup.\n     *\n     * @private\n     */\n\n\n    _addSyncListener() {\n      if ('sync' in registration) {\n        self.addEventListener('sync', event => {\n          if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n            {\n              logger_mjs.logger.log(`Background sync for tag '${event.tag}'` + `has been received`);\n            }\n\n            const syncComplete = async () => {\n              this._syncInProgress = true;\n              let syncError;\n\n              try {\n                await this._onSync({\n                  queue: this\n                });\n              } catch (error) {\n                syncError = error; // Rethrow the error. Note: the logic in the finally clause\n                // will run before this gets rethrown.\n\n                throw syncError;\n              } finally {\n                // New items may have been added to the queue during the sync,\n                // so we need to register for a new sync if that's happened...\n                // Unless there was an error during the sync, in which\n                // case the browser will automatically retry later, as long\n                // as `event.lastChance` is not true.\n                if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                  await this.registerSync();\n                }\n\n                this._syncInProgress = false;\n                this._requestsAddedDuringSync = false;\n              }\n            };\n\n            event.waitUntil(syncComplete());\n          }\n        });\n      } else {\n        {\n          logger_mjs.logger.log(`Background sync replaying without background sync event`);\n        } // If the browser doesn't support background sync, retry\n        // every time the service worker starts up as a fallback.\n\n        this._onSync({\n          queue: this\n        });\n      }\n    }\n    /**\n     * Returns the set of queue names. This is primarily used to reset the list\n     * of queue names in tests.\n     *\n     * @return {Set}\n     *\n     * @private\n     */\n\n\n    static get _queueNames() {\n      return queueNames;\n    }\n\n  }\n  /**\n   * Converts a QueueStore entry into the format exposed by Queue. This entails\n   * converting the request data into a real request and omitting the `id` and\n   * `queueName` properties.\n   *\n   * @param {Object} queueStoreEntry\n   * @return {Object}\n   * @private\n   */\n\n\n  const convertEntry = queueStoreEntry => {\n    const queueEntry = {\n      request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n      timestamp: queueStoreEntry.timestamp\n    };\n\n    if (queueStoreEntry.metadata) {\n      queueEntry.metadata = queueStoreEntry.metadata;\n    }\n\n    return queueEntry;\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * A class implementing the `fetchDidFail` lifecycle callback. This makes it\n   * easier to add failed requests to a background sync Queue.\n   *\n   * @memberof workbox.backgroundSync\n   */\n\n\n  class Plugin {\n    /**\n     * @param {...*} queueArgs Args to forward to the composed Queue instance.\n     *    See the [Queue]{@link workbox.backgroundSync.Queue} documentation for\n     *    parameter details.\n     */\n    constructor(...queueArgs) {\n      this._queue = new Queue(...queueArgs);\n      this.fetchDidFail = this.fetchDidFail.bind(this);\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @private\n     */\n\n\n    async fetchDidFail({\n      request\n    }) {\n      await this._queue.pushRequest({\n        request\n      });\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.Queue = Queue;\n  exports.Plugin = Plugin;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../lib/QueueStore.mjs","../lib/StorableRequest.mjs","../Queue.mjs","../Plugin.mjs","../index.mjs"],"names":["self","_","DB_VERSION","DB_NAME","OBJECT_STORE_NAME","INDEXED_PROP","constructor","DBWrapper","onupgradeneeded","_upgradeDb","assert","moduleName","className","funcName","paramName","entry","count","firstEntry","direction","index","query","IDBKeyRange","db","event","objStore","autoIncrement","keyPath","unique","serializableProperties","requestData","url","request","headers","toObject","Object","toRequest","clone","TAG_PREFIX","MAX_RETENTION_TIME","queueNames","maxRetentionTime","WorkboxError","name","onSync","allEntries","now","Date","unexpiredEntries","maxRetentionTimeInMs","convertEntry","timestamp","storableRequest","StorableRequest","operation","logger","getFriendlyURL","_name","fetch","registration","_addSyncListener","tag","syncComplete","queue","syncError","queueStoreEntry","queueEntry"],"mappings":"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","sourcesContent":["try{self['workbox:background-sync:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport '../_version.mjs';\n\n\nconst DB_VERSION = 3;\nconst DB_NAME = 'workbox-background-sync';\nconst OBJECT_STORE_NAME = 'requests';\nconst INDEXED_PROP = 'queueName';\n\n/**\n * A class to manage storing requests from a Queue in IndexedbDB,\n * indexed by their queue name for easier access.\n *\n * @private\n */\nexport class QueueStore {\n  /**\n   * Associates this instance with a Queue instance, so entries added can be\n   * identified by their queue name.\n   *\n   * @param {string} queueName\n   * @private\n   */\n  constructor(queueName) {\n    this._queueName = queueName;\n    this._db = new DBWrapper(DB_NAME, DB_VERSION, {\n      onupgradeneeded: this._upgradeDb,\n    });\n  }\n\n  /**\n   * Append an entry last in the queue.\n   *\n   * @param {Object} entry\n   * @param {Object} entry.requestData\n   * @param {number} [entry.timestamp]\n   * @param {Object} [entry.metadata]\n   * @private\n   */\n  async pushEntry(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'pushEntry',\n        paramName: 'entry',\n      });\n      assert.isType(entry.requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'pushEntry',\n        paramName: 'entry.requestData',\n      });\n    }\n\n    // Don't specify an ID since one is automatically generated.\n    delete entry.id;\n    entry.queueName = this._queueName;\n\n    await this._db.add(OBJECT_STORE_NAME, entry);\n  }\n\n  /**\n   * Preppend an entry first in the queue.\n   *\n   * @param {Object} entry\n   * @param {Object} entry.requestData\n   * @param {number} [entry.timestamp]\n   * @param {Object} [entry.metadata]\n   * @private\n   */\n  async unshiftEntry(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'unshiftEntry',\n        paramName: 'entry',\n      });\n      assert.isType(entry.requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'unshiftEntry',\n        paramName: 'entry.requestData',\n      });\n    }\n\n    const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      count: 1,\n    });\n\n    if (firstEntry) {\n      // Pick an ID one less than the lowest ID in the object store.\n      entry.id = firstEntry.id - 1;\n    } else {\n      // Otherwise let the auto-incrementor assign the ID.\n      delete entry.id;\n    }\n    entry.queueName = this._queueName;\n\n    await this._db.add(OBJECT_STORE_NAME, entry);\n  }\n\n  /**\n   * Removes and returns the last entry in the queue matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async popEntry() {\n    return this._removeEntry({direction: 'prev'});\n  }\n\n  /**\n   * Removes and returns the first entry in the queue matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async shiftEntry() {\n    return this._removeEntry({direction: 'next'});\n  }\n\n  /**\n   * Returns all entries in the store matching the `queueName`.\n   *\n   * @param {Object} options See workbox.backgroundSync.Queue~getAll}\n   * @return {Promise<Array<Object>>}\n   * @private\n   */\n  async getAll() {\n    return await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      index: INDEXED_PROP,\n      query: IDBKeyRange.only(this._queueName),\n    });\n  }\n\n  /**\n   * Deletes the entry for the given ID.\n   *\n   * WARNING: this method does not ensure the deleted enry belongs to this\n   * queue (i.e. matches the `queueName`). But this limitation is acceptable\n   * as this class is not publicly exposed. An additional check would make\n   * this method slower than it needs to be.\n   *\n   * @private\n   * @param {number} id\n   */\n  async deleteEntry(id) {\n    await this._db.delete(OBJECT_STORE_NAME, id);\n  }\n\n  /**\n   * Removes and returns the first or last entry in the queue (based on the\n   * `direction` argument) matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async _removeEntry({direction}) {\n    const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      direction,\n      index: INDEXED_PROP,\n      query: IDBKeyRange.only(this._queueName),\n      count: 1,\n    });\n\n    if (entry) {\n      await this.deleteEntry(entry.id);\n      return entry;\n    }\n  }\n\n  /**\n   * Upgrades the database given an `upgradeneeded` event.\n   *\n   * @param {Event} event\n   * @private\n   */\n  _upgradeDb(event) {\n    const db = event.target.result;\n\n    if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {\n      if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {\n        db.deleteObjectStore(OBJECT_STORE_NAME);\n      }\n    }\n\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n      autoIncrement: true,\n      keyPath: 'id',\n    });\n    objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {unique: false});\n  }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport '../_version.mjs';\n\n\nconst serializableProperties = [\n  'method',\n  'referrer',\n  'referrerPolicy',\n  'mode',\n  'credentials',\n  'cache',\n  'redirect',\n  'integrity',\n  'keepalive',\n];\n\n\n/**\n * A class to make it easier to serialize and de-serialize requests so they\n * can be stored in IndexedDB.\n *\n * @private\n */\nclass StorableRequest {\n  /**\n   * Converts a Request object to a plain object that can be structured\n   * cloned or JSON-stringified.\n   *\n   * @param {Request} request\n   * @return {Promise<StorableRequest>}\n   *\n   * @private\n   */\n  static async fromRequest(request) {\n    const requestData = {\n      url: request.url,\n      headers: {},\n    };\n\n    // Set the body if present.\n    if (request.method !== 'GET') {\n      // Use ArrayBuffer to support non-text request bodies.\n      // NOTE: we can't use Blobs becuse Safari doesn't support storing\n      // Blobs in IndexedDB in some cases:\n      // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457\n      requestData.body = await request.clone().arrayBuffer();\n    }\n\n    // Convert the headers from an iterable to an object.\n    for (const [key, value] of request.headers.entries()) {\n      requestData.headers[key] = value;\n    }\n\n    // Add all other serializable request properties\n    for (const prop of serializableProperties) {\n      if (request[prop] !== undefined) {\n        requestData[prop] = request[prop];\n      }\n    }\n\n    return new StorableRequest(requestData);\n  }\n\n  /**\n   * Accepts an object of request data that can be used to construct a\n   * `Request` but can also be stored in IndexedDB.\n   *\n   * @param {Object} requestData An object of request data that includes the\n   *     `url` plus any relevant properties of\n   *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.\n   * @private\n   */\n  constructor(requestData) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'StorableRequest',\n        funcName: 'constructor',\n        paramName: 'requestData',\n      });\n      assert.isType(requestData.url, 'string', {\n        moduleName: 'workbox-background-sync',\n        className: 'StorableRequest',\n        funcName: 'constructor',\n        paramName: 'requestData.url',\n      });\n    }\n\n    // If the request's mode is `navigate`, convert it to `same-origin` since\n    // navigation requests can't be constructed via script.\n    if (requestData.mode === 'navigate') {\n      requestData.mode = 'same-origin';\n    }\n\n    this._requestData = requestData;\n  }\n\n  /**\n   * Returns a deep clone of the instances `_requestData` object.\n   *\n   * @return {Object}\n   *\n   * @private\n   */\n  toObject() {\n    const requestData = Object.assign({}, this._requestData);\n    requestData.headers = Object.assign({}, this._requestData.headers);\n    if (requestData.body) {\n      requestData.body = requestData.body.slice(0);\n    }\n\n    return requestData;\n  }\n\n  /**\n   * Converts this instance to a Request.\n   *\n   * @return {Request}\n   *\n   * @private\n   */\n  toRequest() {\n    return new Request(this._requestData.url, this._requestData);\n  }\n\n  /**\n   * Creates and returns a deep clone of the instance.\n   *\n   * @return {StorableRequest}\n   *\n   * @private\n   */\n  clone() {\n    return new StorableRequest(this.toObject());\n  }\n}\n\nexport {StorableRequest};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {QueueStore} from './lib/QueueStore.mjs';\nimport {StorableRequest} from './lib/StorableRequest.mjs';\nimport './_version.mjs';\n\n\nconst TAG_PREFIX = 'workbox-background-sync';\nconst MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes\n\nconst queueNames = new Set();\n\n/**\n * A class to manage storing failed requests in IndexedDB and retrying them\n * later. All parts of the storing and replaying process are observable via\n * callbacks.\n *\n * @memberof workbox.backgroundSync\n */\nclass Queue {\n  /**\n   * Creates an instance of Queue with the given options\n   *\n   * @param {string} name The unique name for this queue. This name must be\n   *     unique as it's used to register sync events and store requests\n   *     in IndexedDB specific to this instance. An error will be thrown if\n   *     a duplicate name is detected.\n   * @param {Object} [options]\n   * @param {Function} [options.onSync] A function that gets invoked whenever\n   *     the 'sync' event fires. The function is invoked with an object\n   *     containing the `queue` property (referencing this instance), and you\n   *     can use the callback to customize the replay behavior of the queue.\n   *     When not set the `replayRequests()` method is called.\n   *     Note: if the replay fails after a sync event, make sure you throw an\n   *     error, so the browser knows to retry the sync event later.\n   * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n   *     minutes) a request may be retried. After this amount of time has\n   *     passed, the request will be deleted from the queue.\n   */\n  constructor(name, {onSync, maxRetentionTime} = {}) {\n    // Ensure the store name is not already being used\n    if (queueNames.has(name)) {\n      throw new WorkboxError('duplicate-queue-name', {name});\n    } else {\n      queueNames.add(name);\n    }\n\n    this._name = name;\n    this._onSync = onSync || this.replayRequests;\n    this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n    this._queueStore = new QueueStore(this._name);\n\n    this._addSyncListener();\n  }\n\n  /**\n   * @return {string}\n   */\n  get name() {\n    return this._name;\n  }\n\n  /**\n   * Stores the passed request in IndexedDB (with its timestamp and any\n   * metadata) at the end of the queue.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request The request to store in the queue.\n   * @param {Object} [entry.metadata] Any metadata you want associated with the\n   *     stored request. When requests are replayed you'll have access to this\n   *     metadata object in case you need to modify the request beforehand.\n   * @param {number} [entry.timestamp] The timestamp (Epoch time in\n   *     milliseconds) when the request was first added to the queue. This is\n   *     used along with `maxRetentionTime` to remove outdated requests. In\n   *     general you don't need to set this value, as it's automatically set\n   *     for you (defaulting to `Date.now()`), but you can update it if you\n   *     don't want particular requests to expire.\n   */\n  async pushRequest(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'pushRequest',\n        paramName: 'entry',\n      });\n      assert.isInstance(entry.request, Request, {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'pushRequest',\n        paramName: 'entry.request',\n      });\n    }\n\n    await this._addRequest(entry, 'push');\n  }\n\n  /**\n   * Stores the passed request in IndexedDB (with its timestamp and any\n   * metadata) at the beginning of the queue.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request The request to store in the queue.\n   * @param {Object} [entry.metadata] Any metadata you want associated with the\n   *     stored request. When requests are replayed you'll have access to this\n   *     metadata object in case you need to modify the request beforehand.\n   * @param {number} [entry.timestamp] The timestamp (Epoch time in\n   *     milliseconds) when the request was first added to the queue. This is\n   *     used along with `maxRetentionTime` to remove outdated requests. In\n   *     general you don't need to set this value, as it's automatically set\n   *     for you (defaulting to `Date.now()`), but you can update it if you\n   *     don't want particular requests to expire.\n   */\n  async unshiftRequest(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'unshiftRequest',\n        paramName: 'entry',\n      });\n      assert.isInstance(entry.request, Request, {\n        moduleName: 'workbox-background-sync',\n        className: 'Queue',\n        funcName: 'unshiftRequest',\n        paramName: 'entry.request',\n      });\n    }\n\n    await this._addRequest(entry, 'unshift');\n  }\n\n  /**\n   * Removes and returns the last request in the queue (along with its\n   * timestamp and any metadata). The returned object takes the form:\n   * `{request, timestamp, metadata}`.\n   *\n   * @return {Promise<Object>}\n   */\n  async popRequest() {\n    return this._removeRequest('pop');\n  }\n\n  /**\n   * Removes and returns the first request in the queue (along with its\n   * timestamp and any metadata). The returned object takes the form:\n   * `{request, timestamp, metadata}`.\n   *\n   * @return {Promise<Object>}\n   */\n  async shiftRequest() {\n    return this._removeRequest('shift');\n  }\n\n  /**\n   * Returns all the entries that have not expired (per `maxRetentionTime`).\n   * Any expired entries are removed from the queue.\n   *\n   * @return {Promise<Array<Object>>}\n   */\n  async getAll() {\n    const allEntries = await this._queueStore.getAll();\n    const now = Date.now();\n\n    const unexpiredEntries = [];\n    for (const entry of allEntries) {\n      // Ignore requests older than maxRetentionTime. Call this function\n      // recursively until an unexpired request is found.\n      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n      if (now - entry.timestamp > maxRetentionTimeInMs) {\n        await this._queueStore.deleteEntry(entry.id);\n      } else {\n        unexpiredEntries.push(convertEntry(entry));\n      }\n    }\n\n    return unexpiredEntries;\n  }\n\n\n  /**\n   * Adds the entry to the QueueStore and registers for a sync event.\n   *\n   * @param {Object} entry\n   * @param {Request} entry.request\n   * @param {Object} [entry.metadata]\n   * @param {number} [entry.timestamp=Date.now()]\n   * @param {string} operation ('push' or 'unshift')\n   * @private\n   */\n  async _addRequest(\n      {request, metadata, timestamp = Date.now()}, operation) {\n    const storableRequest = await StorableRequest.fromRequest(request.clone());\n    const entry = {\n      requestData: storableRequest.toObject(),\n      timestamp,\n    };\n\n    // Only include metadata if it's present.\n    if (metadata) {\n      entry.metadata = metadata;\n    }\n\n    await this._queueStore[`${operation}Entry`](entry);\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`Request for '${getFriendlyURL(request.url)}' has ` +\n          `been added to background sync queue '${this._name}'.`);\n    }\n\n    // Don't register for a sync if we're in the middle of a sync. Instead,\n    // we wait until the sync is complete and call register if\n    // `this._requestsAddedDuringSync` is true.\n    if (this._syncInProgress) {\n      this._requestsAddedDuringSync = true;\n    } else {\n      await this.registerSync();\n    }\n  }\n\n  /**\n   * Removes and returns the first or last (depending on `operation`) entry\n   * from the QueueStore that's not older than the `maxRetentionTime`.\n   *\n   * @param {string} operation ('pop' or 'shift')\n   * @return {Object|undefined}\n   * @private\n   */\n  async _removeRequest(operation) {\n    const now = Date.now();\n    const entry = await this._queueStore[`${operation}Entry`]();\n\n    if (entry) {\n      // Ignore requests older than maxRetentionTime. Call this function\n      // recursively until an unexpired request is found.\n      const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n      if (now - entry.timestamp > maxRetentionTimeInMs) {\n        return this._removeRequest(operation);\n      }\n\n      return convertEntry(entry);\n    }\n  }\n\n  /**\n   * Loops through each request in the queue and attempts to re-fetch it.\n   * If any request fails to re-fetch, it's put back in the same position in\n   * the queue (which registers a retry for the next sync event).\n   */\n  async replayRequests() {\n    let entry;\n    while (entry = await this.shiftRequest()) {\n      try {\n        await fetch(entry.request.clone());\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(entry.request.url)}'` +\n             `has been replayed in queue '${this._name}'`);\n        }\n      } catch (error) {\n        await this.unshiftRequest(entry);\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(entry.request.url)}'` +\n             `failed to replay, putting it back in queue '${this._name}'`);\n        }\n        throw new WorkboxError('queue-replay-failed', {name: this._name});\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`All requests in queue '${this.name}' have successfully ` +\n          `replayed; the queue is now empty!`);\n    }\n  }\n\n  /**\n   * Registers a sync event with a tag unique to this instance.\n   */\n  async registerSync() {\n    if ('sync' in registration) {\n      try {\n        await registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n      } catch (err) {\n        // This means the registration failed for some reason, possibly due to\n        // the user disabling it.\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(\n              `Unable to register sync event for '${this._name}'.`, err);\n        }\n      }\n    }\n  }\n\n  /**\n   * In sync-supporting browsers, this adds a listener for the sync event.\n   * In non-sync-supporting browsers, this will retry the queue on service\n   * worker startup.\n   *\n   * @private\n   */\n  _addSyncListener() {\n    if ('sync' in registration) {\n      self.addEventListener('sync', (event) => {\n        if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.log(`Background sync for tag '${event.tag}'` +\n                `has been received`);\n          }\n\n          const syncComplete = async () => {\n            this._syncInProgress = true;\n\n            let syncError;\n            try {\n              await this._onSync({queue: this});\n            } catch (error) {\n              syncError = error;\n\n              // Rethrow the error. Note: the logic in the finally clause\n              // will run before this gets rethrown.\n              throw syncError;\n            } finally {\n              // New items may have been added to the queue during the sync,\n              // so we need to register for a new sync if that's happened...\n              // Unless there was an error during the sync, in which\n              // case the browser will automatically retry later, as long\n              // as `event.lastChance` is not true.\n              if (this._requestsAddedDuringSync &&\n                  !(syncError && !event.lastChance)) {\n                await this.registerSync();\n              }\n\n              this._syncInProgress = false;\n              this._requestsAddedDuringSync = false;\n            }\n          };\n          event.waitUntil(syncComplete());\n        }\n      });\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Background sync replaying without background sync event`);\n      }\n      // If the browser doesn't support background sync, retry\n      // every time the service worker starts up as a fallback.\n      this._onSync({queue: this});\n    }\n  }\n\n  /**\n   * Returns the set of queue names. This is primarily used to reset the list\n   * of queue names in tests.\n   *\n   * @return {Set}\n   *\n   * @private\n   */\n  static get _queueNames() {\n    return queueNames;\n  }\n}\n\n\n/**\n * Converts a QueueStore entry into the format exposed by Queue. This entails\n * converting the request data into a real request and omitting the `id` and\n * `queueName` properties.\n *\n * @param {Object} queueStoreEntry\n * @return {Object}\n * @private\n */\nconst convertEntry = (queueStoreEntry) => {\n  const queueEntry = {\n    request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n    timestamp: queueStoreEntry.timestamp,\n  };\n  if (queueStoreEntry.metadata) {\n    queueEntry.metadata = queueStoreEntry.metadata;\n  }\n  return queueEntry;\n};\n\nexport {Queue};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Queue} from './Queue.mjs';\nimport './_version.mjs';\n\n/**\n * A class implementing the `fetchDidFail` lifecycle callback. This makes it\n * easier to add failed requests to a background sync Queue.\n *\n * @memberof workbox.backgroundSync\n */\nclass Plugin {\n  /**\n   * @param {...*} queueArgs Args to forward to the composed Queue instance.\n   *    See the [Queue]{@link workbox.backgroundSync.Queue} documentation for\n   *    parameter details.\n   */\n  constructor(...queueArgs) {\n    this._queue = new Queue(...queueArgs);\n    this.fetchDidFail = this.fetchDidFail.bind(this);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @private\n   */\n  async fetchDidFail({request}) {\n    await this._queue.pushRequest({request});\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Queue} from './Queue.mjs';\nimport {Plugin} from './Plugin.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.backgroundSync\n */\n\nexport {\n  Queue,\n  Plugin,\n};\n"]},"metadata":{},"sourceType":"script"}