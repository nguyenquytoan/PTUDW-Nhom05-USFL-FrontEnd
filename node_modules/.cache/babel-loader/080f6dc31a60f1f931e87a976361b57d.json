{"ast":null,"code":"// @ts-check\n// Import types\n\n/** @typedef {import(\"./typings\").HtmlTagObject} HtmlTagObject */\n\n/** @typedef {import(\"./typings\").Options} HtmlWebpackOptions */\n\n/** @typedef {import(\"./typings\").ProcessedOptions} ProcessedHtmlWebpackOptions */\n\n/** @typedef {import(\"./typings\").TemplateParameter} TemplateParameter */\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n'use strict'; // use Polyfill for util.promisify in node versions < v8\n\nconst promisify = require('util.promisify');\n\nconst vm = require('vm');\n\nconst fs = require('fs');\n\nconst _ = require('lodash');\n\nconst path = require('path');\n\nconst loaderUtils = require('loader-utils');\n\nconst {\n  createHtmlTagObject,\n  htmlTagObjectToString\n} = require('./lib/html-tags');\n\nconst childCompiler = require('./lib/compiler.js');\n\nconst prettyError = require('./lib/errors.js');\n\nconst chunkSorter = require('./lib/chunksorter.js');\n\nconst getHtmlWebpackPluginHooks = require('./lib/hooks.js').getHtmlWebpackPluginHooks;\n\nconst fsStatAsync = promisify(fs.stat);\nconst fsReadFileAsync = promisify(fs.readFile);\n\nclass HtmlWebpackPlugin {\n  /**\n   * @param {HtmlWebpackOptions} [options]\n   */\n  constructor(options) {\n    /** @type {HtmlWebpackOptions} */\n    const userOptions = options || {}; // Default options\n\n    /** @type {ProcessedHtmlWebpackOptions} */\n\n    const defaultOptions = {\n      template: 'auto',\n      templateContent: false,\n      templateParameters: templateParametersGenerator,\n      filename: 'index.html',\n      hash: false,\n      inject: true,\n      compile: true,\n      favicon: false,\n      minify: 'auto',\n      cache: true,\n      showErrors: true,\n      chunks: 'all',\n      excludeChunks: [],\n      chunksSortMode: 'auto',\n      meta: {},\n      base: false,\n      title: 'Webpack App',\n      xhtml: false\n    };\n    /** @type {ProcessedHtmlWebpackOptions} */\n\n    this.options = Object.assign(defaultOptions, userOptions); // Default metaOptions if no template is provided\n\n    if (!userOptions.template && this.options.templateContent === false && this.options.meta) {\n      const defaultMeta = {\n        // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag\n        viewport: 'width=device-width, initial-scale=1'\n      };\n      this.options.meta = Object.assign({}, this.options.meta, defaultMeta, userOptions.meta);\n    } // Instance variables to keep caching information\n    // for multiple builds\n\n\n    this.childCompilerHash = undefined;\n    /**\n     * @type {string | undefined}\n     */\n\n    this.childCompilationOutputName = undefined;\n    this.assetJson = undefined;\n    this.hash = undefined;\n    this.version = HtmlWebpackPlugin.version;\n  }\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n\n\n  apply(compiler) {\n    const self = this;\n    let isCompilationCached = false;\n    /** @type Promise<string> */\n\n    let compilationPromise;\n    this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); // convert absolute filename into relative so that webpack can\n    // generate it at correct location\n\n    const filename = this.options.filename;\n\n    if (path.resolve(filename) === path.normalize(filename)) {\n      this.options.filename = path.relative(compiler.options.output.path, filename);\n    } // `contenthash` is introduced in webpack v4.3\n    // which conflicts with the plugin's existing `contenthash` method,\n    // hence it is renamed to `templatehash` to avoid conflicts\n\n\n    this.options.filename = this.options.filename.replace(/\\[(?:(\\w+):)?contenthash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, match => {\n      return match.replace('contenthash', 'templatehash');\n    }); // Check if webpack is running in production mode\n    // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14\n\n    const isProductionLikeMode = compiler.options.mode === 'production' || !compiler.options.mode;\n    const minify = this.options.minify;\n\n    if (minify === true || minify === 'auto' && isProductionLikeMode) {\n      /** @type { import('html-minifier').Options } */\n      this.options.minify = {\n        // https://github.com/kangax/html-minifier#options-quick-reference\n        collapseWhitespace: true,\n        removeComments: true,\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true,\n        useShortDoctype: true\n      };\n    } // Clear the cache once a new HtmlWebpackPlugin is added\n\n\n    childCompiler.clearCache(compiler); // Register all HtmlWebpackPlugins instances at the child compiler\n\n    compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', compilation => {\n      // Clear the cache if the child compiler is outdated\n      if (childCompiler.hasOutDatedTemplateCache(compilation)) {\n        childCompiler.clearCache(compiler);\n      } // Add this instances template to the child compiler\n\n\n      childCompiler.addTemplateToCompiler(compiler, this.options.template); // Add file dependencies of child compiler to parent compiler\n      // to keep them watched even if we get the result from the cache\n\n      compilation.hooks.additionalChunkAssets.tap('HtmlWebpackPlugin', () => {\n        const childCompilerDependencies = childCompiler.getFileDependencies(compiler);\n        childCompilerDependencies.forEach(fileDependency => {\n          compilation.compilationDependencies.add(fileDependency);\n        });\n      });\n    });\n    compiler.hooks.make.tapAsync('HtmlWebpackPlugin', (compilation, callback) => {\n      // Compile the template (queued)\n      compilationPromise = childCompiler.compileTemplate(self.options.template, self.options.filename, compilation).catch(err => {\n        compilation.errors.push(prettyError(err, compiler.context).toString());\n        return {\n          content: self.options.showErrors ? prettyError(err, compiler.context).toJsonHtml() : 'ERROR',\n          outputName: self.options.filename,\n          hash: ''\n        };\n      }).then(compilationResult => {\n        // If the compilation change didnt change the cache is valid\n        isCompilationCached = Boolean(compilationResult.hash) && self.childCompilerHash === compilationResult.hash;\n        self.childCompilerHash = compilationResult.hash;\n        self.childCompilationOutputName = compilationResult.outputName;\n        callback();\n        return compilationResult.content;\n      });\n    });\n    compiler.hooks.emit.tapAsync('HtmlWebpackPlugin',\n    /**\n     * Hook into the webpack emit phase\n     * @param {WebpackCompilation} compilation\n     * @param {() => void} callback\n    */\n    (compilation, callback) => {\n      // Get all entry point names for this html file\n      const entryNames = Array.from(compilation.entrypoints.keys());\n      const filteredEntryNames = self.filterChunks(entryNames, self.options.chunks, self.options.excludeChunks);\n      const sortedEntryNames = self.sortEntryChunks(filteredEntryNames, this.options.chunksSortMode, compilation);\n      const childCompilationOutputName = self.childCompilationOutputName;\n\n      if (childCompilationOutputName === undefined) {\n        throw new Error('Did not receive child compilation result');\n      } // Turn the entry point names into file paths\n\n\n      const assets = self.htmlWebpackPluginAssets(compilation, childCompilationOutputName, sortedEntryNames); // If this is a hot update compilation, move on!\n      // This solves a problem where an `index.html` file is generated for hot-update js files\n      // It only happens in Webpack 2, where hot updates are emitted separately before the full bundle\n\n      if (self.isHotUpdateCompilation(assets)) {\n        return callback();\n      } // If the template and the assets did not change we don't have to emit the html\n\n\n      const assetJson = JSON.stringify(self.getAssetFiles(assets));\n\n      if (isCompilationCached && self.options.cache && assetJson === self.assetJson) {\n        return callback();\n      } else {\n        self.assetJson = assetJson;\n      } // The html-webpack plugin uses a object representation for the html-tags which will be injected\n      // to allow altering them more easily\n      // Just before they are converted a third-party-plugin author might change the order and content\n\n\n      const assetsPromise = this.getFaviconPublicPath(this.options.favicon, compilation, assets.publicPath).then(faviconPath => {\n        assets.favicon = faviconPath;\n        return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({\n          assets: assets,\n          outputName: childCompilationOutputName,\n          plugin: self\n        });\n      }); // Turn the js and css paths into grouped HtmlTagObjects\n\n      const assetTagGroupsPromise = assetsPromise // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped\n      .then(({\n        assets\n      }) => getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({\n        assetTags: {\n          scripts: self.generatedScriptTags(assets.js),\n          styles: self.generateStyleTags(assets.css),\n          meta: [...self.generateBaseTag(self.options.base), ...self.generatedMetaTags(self.options.meta), ...self.generateFaviconTags(assets.favicon)]\n        },\n        outputName: childCompilationOutputName,\n        plugin: self\n      })).then(({\n        assetTags\n      }) => {\n        // Inject scripts to body unless it set explictly to head\n        const scriptTarget = self.options.inject === 'head' ? 'head' : 'body'; // Group assets to `head` and `body` tag arrays\n\n        const assetGroups = this.generateAssetGroups(assetTags, scriptTarget); // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped\n\n        return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({\n          headTags: assetGroups.headTags,\n          bodyTags: assetGroups.bodyTags,\n          outputName: childCompilationOutputName,\n          plugin: self\n        });\n      }); // Turn the compiled tempalte into a nodejs function or into a nodejs string\n\n      const templateEvaluationPromise = compilationPromise.then(compiledTemplate => {\n        // Allow to use a custom function / string instead\n        if (self.options.templateContent !== false) {\n          return self.options.templateContent;\n        } // Once everything is compiled evaluate the html factory\n        // and replace it with its content\n\n\n        return self.evaluateCompilationResult(compilation, compiledTemplate);\n      });\n      const templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise]) // Execute the template\n      .then(([assetsHookResult, assetTags, compilationResult]) => typeof compilationResult !== 'function' ? compilationResult : self.executeTemplate(compilationResult, assetsHookResult.assets, {\n        headTags: assetTags.headTags,\n        bodyTags: assetTags.bodyTags\n      }, compilation));\n      const injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise]) // Allow plugins to change the html before assets are injected\n      .then(([assetTags, html]) => {\n        const pluginArgs = {\n          html,\n          headTags: assetTags.headTags,\n          bodyTags: assetTags.bodyTags,\n          plugin: self,\n          outputName: childCompilationOutputName\n        };\n        return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);\n      }).then(({\n        html,\n        headTags,\n        bodyTags\n      }) => {\n        return self.postProcessHtml(html, assets, {\n          headTags,\n          bodyTags\n        });\n      });\n      const emitHtmlPromise = injectedHtmlPromise // Allow plugins to change the html after assets are injected\n      .then(html => {\n        const pluginArgs = {\n          html,\n          plugin: self,\n          outputName: childCompilationOutputName\n        };\n        return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs).then(result => result.html);\n      }).catch(err => {\n        // In case anything went wrong the promise is resolved\n        // with the error message and an error is logged\n        compilation.errors.push(prettyError(err, compiler.context).toString()); // Prevent caching\n\n        self.hash = null;\n        return self.options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';\n      }).then(html => {\n        // Allow to use [templatehash] as placeholder for the html-webpack-plugin name\n        // See also https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/\n        // From https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/8de6558e33487e7606e7cd7cb2adc2cccafef272/src/index.js#L212-L214\n        const finalOutputName = childCompilationOutputName.replace(/\\[(?:(\\w+):)?templatehash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, (_, hashType, digestType, maxLength) => {\n          return loaderUtils.getHashDigest(Buffer.from(html, 'utf8'), hashType, digestType, parseInt(maxLength, 10));\n        }); // Add the evaluated html code to the webpack assets\n\n        compilation.assets[finalOutputName] = {\n          source: () => html,\n          size: () => html.length\n        };\n        return finalOutputName;\n      }).then(finalOutputName => getHtmlWebpackPluginHooks(compilation).afterEmit.promise({\n        outputName: finalOutputName,\n        plugin: self\n      }).catch(err => {\n        console.error(err);\n        return null;\n      }).then(() => null)); // Once all files are added to the webpack compilation\n      // let the webpack compiler continue\n\n      emitHtmlPromise.then(() => {\n        callback();\n      });\n    });\n  }\n  /**\n   * Evaluates the child compilation result\n   * @param {WebpackCompilation} compilation\n   * @param {string} source\n   * @returns {Promise<string | (() => string | Promise<string>)>}\n   */\n\n\n  evaluateCompilationResult(compilation, source) {\n    if (!source) {\n      return Promise.reject(new Error('The child compilation didn\\'t provide a result'));\n    } // The LibraryTemplatePlugin stores the template result in a local variable.\n    // To extract the result during the evaluation this part has to be removed.\n\n\n    source = source.replace('var HTML_WEBPACK_PLUGIN_RESULT =', '');\n    const template = this.options.template.replace(/^.+!/, '').replace(/\\?.+$/, '');\n    const vmContext = vm.createContext(_.extend({\n      HTML_WEBPACK_PLUGIN: true,\n      require: require\n    }, global));\n    const vmScript = new vm.Script(source, {\n      filename: template\n    }); // Evaluate code and cast to string\n\n    let newSource;\n\n    try {\n      newSource = vmScript.runInContext(vmContext);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {\n      newSource = newSource.default;\n    }\n\n    return typeof newSource === 'string' || typeof newSource === 'function' ? Promise.resolve(newSource) : Promise.reject(new Error('The loader \"' + this.options.template + '\" didn\\'t return html.'));\n  }\n  /**\n   * Generate the template parameters for the template function\n   * @param {WebpackCompilation} compilation\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @returns {Promise<{[key: any]: any}>}\n   */\n\n\n  getTemplateParameters(compilation, assets, assetTags) {\n    const templateParameters = this.options.templateParameters;\n\n    if (templateParameters === false) {\n      return Promise.resolve({});\n    }\n\n    if (typeof templateParameters === 'function') {\n      const preparedAssetTags = {\n        headTags: this.prepareAssetTagGroupForRendering(assetTags.headTags),\n        bodyTags: this.prepareAssetTagGroupForRendering(assetTags.bodyTags)\n      };\n      return Promise.resolve().then(() => templateParameters(compilation, assets, preparedAssetTags, this.options));\n    }\n\n    if (typeof templateParameters === 'object') {\n      return Promise.resolve(templateParameters);\n    }\n\n    throw new Error('templateParameters has to be either a function or an object');\n  }\n  /**\n   * This function renders the actual html by executing the template function\n   *\n   * @param {(templateParameters) => string | Promise<string>} templateFunction\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns Promise<string>\n   */\n\n\n  executeTemplate(templateFunction, assets, assetTags, compilation) {\n    // Template processing\n    const templateParamsPromise = this.getTemplateParameters(compilation, assets, assetTags);\n    return templateParamsPromise.then(templateParams => {\n      try {\n        // If html is a promise return the promise\n        // If html is a string turn it into a promise\n        return templateFunction(templateParams);\n      } catch (e) {\n        compilation.errors.push(new Error('Template execution failed: ' + e));\n        return Promise.reject(e);\n      }\n    });\n  }\n  /**\n   * Html Post processing\n   *\n   * @param {any} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  postProcessHtml(html, assets, assetTags) {\n    if (typeof html !== 'string') {\n      return Promise.reject(new Error('Expected html to be a string but got ' + JSON.stringify(html)));\n    }\n\n    const htmlAfterInjection = this.options.inject ? this.injectAssetsIntoHtml(html, assets, assetTags) : html;\n    const htmlAfterMinification = typeof this.options.minify === 'object' ? require('html-minifier-terser').minify(htmlAfterInjection, this.options.minify) : htmlAfterInjection;\n    return Promise.resolve(htmlAfterMinification);\n  }\n  /*\n   * Pushes the content of the given filename to the compilation assets\n   * @param {string} filename\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns {string} file basename\n   */\n\n\n  addFileToAssets(filename, compilation) {\n    filename = path.resolve(compilation.compiler.context, filename);\n    return Promise.all([fsStatAsync(filename), fsReadFileAsync(filename)]).then(([size, source]) => {\n      return {\n        size,\n        source\n      };\n    }).catch(() => Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename))).then(results => {\n      const basename = path.basename(filename);\n      compilation.fileDependencies.add(filename);\n      compilation.assets[basename] = {\n        source: () => results.source,\n        size: () => results.size.size\n      };\n      return basename;\n    });\n  }\n  /**\n   * Helper to sort chunks\n   * @param {string[]} entryNames\n   * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode\n   * @param {WebpackCompilation} compilation\n   */\n\n\n  sortEntryChunks(entryNames, sortMode, compilation) {\n    // Custom function\n    if (typeof sortMode === 'function') {\n      return entryNames.sort(sortMode);\n    } // Check if the given sort mode is a valid chunkSorter sort mode\n\n\n    if (typeof chunkSorter[sortMode] !== 'undefined') {\n      return chunkSorter[sortMode](entryNames, compilation, this.options);\n    }\n\n    throw new Error('\"' + sortMode + '\" is not a valid chunk sort mode');\n  }\n  /**\n   * Return all chunks from the compilation result which match the exclude and include filters\n   * @param {any} chunks\n   * @param {string[]|'all'} includedChunks\n   * @param {string[]} excludedChunks\n   */\n\n\n  filterChunks(chunks, includedChunks, excludedChunks) {\n    return chunks.filter(chunkName => {\n      // Skip if the chunks should be filtered and the given chunk was not added explicity\n      if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {\n        return false;\n      } // Skip if the chunks should be filtered and the given chunk was excluded explicity\n\n\n      if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {\n        return false;\n      } // Add otherwise\n\n\n      return true;\n    });\n  }\n  /**\n   * Check if the given asset object consists only of hot-update.js files\n   *\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   */\n\n\n  isHotUpdateCompilation(assets) {\n    return assets.js.length && assets.js.every(assetPath => /\\.hot-update\\.js$/.test(assetPath));\n  }\n  /**\n   * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation\n   * for all given entry names\n   * @param {WebpackCompilation} compilation\n   * @param {string[]} entryNames\n   * @returns {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }}\n   */\n\n\n  htmlWebpackPluginAssets(compilation, childCompilationOutputName, entryNames) {\n    const compilationHash = compilation.hash;\n    /**\n     * @type {string} the configured public path to the asset root\n     * if a path publicPath is set in the current webpack config use it otherwise\n     * fallback to a realtive path\n     */\n\n    const webpackPublicPath = compilation.mainTemplate.getPublicPath({\n      hash: compilationHash\n    });\n    const isPublicPathDefined = webpackPublicPath.trim() !== '';\n    let publicPath = isPublicPathDefined // If a hard coded public path exists use it\n    ? webpackPublicPath // If no public path was set get a relative url path\n    : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path).split(path.sep).join('/');\n\n    if (publicPath.length && publicPath.substr(-1, 1) !== '/') {\n      publicPath += '/';\n    }\n    /**\n     * @type {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }}\n     */\n\n\n    const assets = {\n      // The public path\n      publicPath: publicPath,\n      // Will contain all js and mjs files\n      js: [],\n      // Will contain all css files\n      css: [],\n      // Will contain the html5 appcache manifest files if it exists\n      manifest: Object.keys(compilation.assets).find(assetFile => path.extname(assetFile) === '.appcache'),\n      // Favicon\n      favicon: undefined\n    }; // Append a hash for cache busting\n\n    if (this.options.hash && assets.manifest) {\n      assets.manifest = this.appendHash(assets.manifest, compilationHash);\n    } // Extract paths to .js, .mjs and .css files from the current compilation\n\n\n    const entryPointPublicPathMap = {};\n    const extensionRegexp = /\\.(css|js|mjs)(\\?|$)/;\n\n    for (let i = 0; i < entryNames.length; i++) {\n      const entryName = entryNames[i];\n      const entryPointFiles = compilation.entrypoints.get(entryName).getFiles(); // Prepend the publicPath and append the hash depending on the\n      // webpack.output.publicPath and hashOptions\n      // E.g. bundle.js -> /bundle.js?hash\n\n      const entryPointPublicPaths = entryPointFiles.map(chunkFile => {\n        const entryPointPublicPath = publicPath + this.urlencodePath(chunkFile);\n        return this.options.hash ? this.appendHash(entryPointPublicPath, compilationHash) : entryPointPublicPath;\n      });\n      entryPointPublicPaths.forEach(entryPointPublicPath => {\n        const extMatch = extensionRegexp.exec(entryPointPublicPath); // Skip if the public path is not a .css, .mjs or .js file\n\n        if (!extMatch) {\n          return;\n        } // Skip if this file is already known\n        // (e.g. because of common chunk optimizations)\n\n\n        if (entryPointPublicPathMap[entryPointPublicPath]) {\n          return;\n        }\n\n        entryPointPublicPathMap[entryPointPublicPath] = true; // ext will contain .js or .css, because .mjs recognizes as .js\n\n        const ext = extMatch[1] === 'mjs' ? 'js' : extMatch[1];\n        assets[ext].push(entryPointPublicPath);\n      });\n    }\n\n    return assets;\n  }\n  /**\n   * Converts a favicon file from disk to a webpack ressource\n   * and returns the url to the ressource\n   *\n   * @param {string|false} faviconFilePath\n   * @param {WebpackCompilation} compilation\n   * @param {string} publicPath\n   * @returns {Promise<string|undefined>}\n   */\n\n\n  getFaviconPublicPath(faviconFilePath, compilation, publicPath) {\n    if (!faviconFilePath) {\n      return Promise.resolve(undefined);\n    }\n\n    return this.addFileToAssets(faviconFilePath, compilation).then(faviconName => {\n      const faviconPath = publicPath + faviconName;\n\n      if (this.options.hash) {\n        return this.appendHash(faviconPath, compilation.hash);\n      }\n\n      return faviconPath;\n    });\n  }\n  /**\n   * Generate meta tags\n   * @returns {HtmlTagObject[]}\n   */\n\n\n  getMetaTags() {\n    const metaOptions = this.options.meta;\n\n    if (metaOptions === false) {\n      return [];\n    } // Make tags self-closing in case of xhtml\n    // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n    // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n    const metaTagAttributeObjects = Object.keys(metaOptions).map(metaName => {\n      const metaTagContent = metaOptions[metaName];\n      return typeof metaTagContent === 'string' ? {\n        name: metaName,\n        content: metaTagContent\n      } : metaTagContent;\n    }).filter(attribute => attribute !== false); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n    // the html-webpack-plugin tag structure\n\n    return metaTagAttributeObjects.map(metaTagAttributes => {\n      if (metaTagAttributes === false) {\n        throw new Error('Invalid meta tag');\n      }\n\n      return {\n        tagName: 'meta',\n        voidTag: true,\n        attributes: metaTagAttributes\n      };\n    });\n  }\n  /**\n   * Generate all tags script for the given file paths\n   * @param {Array<string>} jsAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  generatedScriptTags(jsAssets) {\n    return jsAssets.map(scriptAsset => ({\n      tagName: 'script',\n      voidTag: false,\n      attributes: {\n        src: scriptAsset\n      }\n    }));\n  }\n  /**\n   * Generate all style tags for the given file paths\n   * @param {Array<string>} cssAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  generateStyleTags(cssAssets) {\n    return cssAssets.map(styleAsset => ({\n      tagName: 'link',\n      voidTag: true,\n      attributes: {\n        href: styleAsset,\n        rel: 'stylesheet'\n      }\n    }));\n  }\n  /**\n   * Generate an optional base tag\n   * @param { false\n            | string\n            | {[attributeName: string]: string} // attributes e.g. { href:\"http://example.com/page.html\" target:\"_blank\" }\n            } baseOption\n  * @returns {Array<HtmlTagObject>}\n  */\n\n\n  generateBaseTag(baseOption) {\n    if (baseOption === false) {\n      return [];\n    } else {\n      return [{\n        tagName: 'base',\n        voidTag: true,\n        attributes: typeof baseOption === 'string' ? {\n          href: baseOption\n        } : baseOption\n      }];\n    }\n  }\n  /**\n   * Generate all meta tags for the given meta configuration\n   * @param {false | {\n            [name: string]:\n              false // disabled\n              | string // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`\n              | {[attributeName: string]: string|boolean} // custom properties e.g. { name:\"viewport\" content:\"width=500, initial-scale=1\" }\n        }} metaOptions\n  * @returns {Array<HtmlTagObject>}\n  */\n\n\n  generatedMetaTags(metaOptions) {\n    if (metaOptions === false) {\n      return [];\n    } // Make tags self-closing in case of xhtml\n    // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n    // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n    const metaTagAttributeObjects = Object.keys(metaOptions).map(metaName => {\n      const metaTagContent = metaOptions[metaName];\n      return typeof metaTagContent === 'string' ? {\n        name: metaName,\n        content: metaTagContent\n      } : metaTagContent;\n    }).filter(attribute => attribute !== false); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n    // the html-webpack-plugin tag structure\n\n    return metaTagAttributeObjects.map(metaTagAttributes => {\n      if (metaTagAttributes === false) {\n        throw new Error('Invalid meta tag');\n      }\n\n      return {\n        tagName: 'meta',\n        voidTag: true,\n        attributes: metaTagAttributes\n      };\n    });\n  }\n  /**\n   * Generate a favicon tag for the given file path\n   * @param {string| undefined} faviconPath\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  generateFaviconTags(faviconPath) {\n    if (!faviconPath) {\n      return [];\n    }\n\n    return [{\n      tagName: 'link',\n      voidTag: true,\n      attributes: {\n        rel: 'shortcut icon',\n        href: faviconPath\n      }\n    }];\n  }\n  /**\n   * Group assets to head and bottom tags\n   *\n   * @param {{\n      scripts: Array<HtmlTagObject>;\n      styles: Array<HtmlTagObject>;\n      meta: Array<HtmlTagObject>;\n    }} assetTags\n  * @param {\"body\" | \"head\"} scriptTarget\n  * @returns {{\n      headTags: Array<HtmlTagObject>;\n      bodyTags: Array<HtmlTagObject>;\n    }}\n  */\n\n\n  generateAssetGroups(assetTags, scriptTarget) {\n    /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */\n    const result = {\n      headTags: [...assetTags.meta, ...assetTags.styles],\n      bodyTags: []\n    }; // Add script tags to head or body depending on\n    // the htmlPluginOptions\n\n    if (scriptTarget === 'body') {\n      result.bodyTags.push(...assetTags.scripts);\n    } else {\n      result.headTags.push(...assetTags.scripts);\n    }\n\n    return result;\n  }\n  /**\n   * Add toString methods for easier rendering\n   * inside the template\n   *\n   * @param {Array<HtmlTagObject>} assetTagGroup\n   * @returns {Array<HtmlTagObject>}\n   */\n\n\n  prepareAssetTagGroupForRendering(assetTagGroup) {\n    const xhtml = this.options.xhtml;\n    const preparedTags = assetTagGroup.map(assetTag => {\n      const copiedAssetTag = Object.assign({}, assetTag);\n\n      copiedAssetTag.toString = function () {\n        return htmlTagObjectToString(this, xhtml);\n      };\n\n      return copiedAssetTag;\n    });\n\n    preparedTags.toString = function () {\n      return this.join('');\n    };\n\n    return preparedTags;\n  }\n  /**\n   * Injects the assets into the given html string\n   *\n   * @param {string} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {string}\n   */\n\n\n  injectAssetsIntoHtml(html, assets, assetTags) {\n    const htmlRegExp = /(<html[^>]*>)/i;\n    const headRegExp = /(<\\/head\\s*>)/i;\n    const bodyRegExp = /(<\\/body\\s*>)/i;\n    const body = assetTags.bodyTags.map(assetTagObject => htmlTagObjectToString(assetTagObject, this.options.xhtml));\n    const head = assetTags.headTags.map(assetTagObject => htmlTagObjectToString(assetTagObject, this.options.xhtml));\n\n    if (body.length) {\n      if (bodyRegExp.test(html)) {\n        // Append assets to body element\n        html = html.replace(bodyRegExp, match => body.join('') + match);\n      } else {\n        // Append scripts to the end of the file if no <body> element exists:\n        html += body.join('');\n      }\n    }\n\n    if (head.length) {\n      // Create a head tag if none exists\n      if (!headRegExp.test(html)) {\n        if (!htmlRegExp.test(html)) {\n          html = '<head></head>' + html;\n        } else {\n          html = html.replace(htmlRegExp, match => match + '<head></head>');\n        }\n      } // Append assets to head element\n\n\n      html = html.replace(headRegExp, match => head.join('') + match);\n    } // Inject manifest into the opening html tag\n\n\n    if (assets.manifest) {\n      html = html.replace(/(<html[^>]*)(>)/i, (match, start, end) => {\n        // Append the manifest only if no manifest was specified\n        if (/\\smanifest\\s*=/.test(match)) {\n          return match;\n        }\n\n        return start + ' manifest=\"' + assets.manifest + '\"' + end;\n      });\n    }\n\n    return html;\n  }\n  /**\n   * Appends a cache busting hash to the query string of the url\n   * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175\n   * @param {string} url\n   * @param {string} hash\n   */\n\n\n  appendHash(url, hash) {\n    if (!url) {\n      return url;\n    }\n\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;\n  }\n  /**\n   * Encode each path component using `encodeURIComponent` as files can contain characters\n   * which needs special encoding in URLs like `+ `.\n   *\n   * @param {string} filePath\n   */\n\n\n  urlencodePath(filePath) {\n    return filePath.split('/').map(encodeURIComponent).join('/');\n  }\n  /**\n   * Helper to return the absolute template path with a fallback loader\n   * @param {string} template\n   * The path to the template e.g. './index.html'\n   * @param {string} context\n   * The webpack base resolution path for relative paths e.g. process.cwd()\n   */\n\n\n  getFullTemplatePath(template, context) {\n    if (template === 'auto') {\n      template = path.resolve(context, 'src/index.ejs');\n\n      if (!fs.existsSync(template)) {\n        template = path.join(__dirname, 'default_index.ejs');\n      }\n    } // If the template doesn't use a loader use the lodash template loader\n\n\n    if (template.indexOf('!') === -1) {\n      template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);\n    } // Resolve template path\n\n\n    return template.replace(/([!])([^/\\\\][^!?]+|[^/\\\\!?])($|\\?[^!?\\n]+$)/, (match, prefix, filepath, postfix) => prefix + path.resolve(filepath) + postfix);\n  }\n  /**\n   * Helper to return a sorted unique array of all asset files out of the\n   * asset object\n   */\n\n\n  getAssetFiles(assets) {\n    const files = _.uniq(Object.keys(assets).filter(assetType => assetType !== 'chunks' && assets[assetType]).reduce((files, assetType) => files.concat(assets[assetType]), []));\n\n    files.sort();\n    return files;\n  }\n\n}\n/**\n * The default for options.templateParameter\n * Generate the template parameters\n *\n * Generate the template parameters for the template function\n * @param {WebpackCompilation} compilation\n * @param {{\n   publicPath: string,\n   js: Array<string>,\n   css: Array<string>,\n   manifest?: string,\n   favicon?: string\n }} assets\n * @param {{\n     headTags: HtmlTagObject[],\n     bodyTags: HtmlTagObject[]\n   }} assetTags\n * @param {ProcessedHtmlWebpackOptions} options\n * @returns {TemplateParameter}\n */\n\n\nfunction templateParametersGenerator(compilation, assets, assetTags, options) {\n  return {\n    compilation: compilation,\n    webpackConfig: compilation.options,\n    htmlWebpackPlugin: {\n      tags: assetTags,\n      files: assets,\n      options: options\n    }\n  };\n} // Statics:\n\n/**\n * The major version number of this plugin\n */\n\n\nHtmlWebpackPlugin.version = 4;\n/**\n * A static helper to get the hooks for this plugin\n *\n * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });\n */\n\nHtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;\nHtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;\nmodule.exports = HtmlWebpackPlugin;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/html-webpack-plugin/index.js"],"names":["promisify","require","vm","fs","_","path","loaderUtils","createHtmlTagObject","htmlTagObjectToString","childCompiler","prettyError","chunkSorter","getHtmlWebpackPluginHooks","fsStatAsync","stat","fsReadFileAsync","readFile","HtmlWebpackPlugin","constructor","options","userOptions","defaultOptions","template","templateContent","templateParameters","templateParametersGenerator","filename","hash","inject","compile","favicon","minify","cache","showErrors","chunks","excludeChunks","chunksSortMode","meta","base","title","xhtml","Object","assign","defaultMeta","viewport","childCompilerHash","undefined","childCompilationOutputName","assetJson","version","apply","compiler","self","isCompilationCached","compilationPromise","getFullTemplatePath","context","resolve","normalize","relative","output","replace","match","isProductionLikeMode","mode","collapseWhitespace","removeComments","removeRedundantAttributes","removeScriptTypeAttributes","removeStyleLinkTypeAttributes","useShortDoctype","clearCache","hooks","thisCompilation","tap","compilation","hasOutDatedTemplateCache","addTemplateToCompiler","additionalChunkAssets","childCompilerDependencies","getFileDependencies","forEach","fileDependency","compilationDependencies","add","make","tapAsync","callback","compileTemplate","catch","err","errors","push","toString","content","toJsonHtml","outputName","then","compilationResult","Boolean","emit","entryNames","Array","from","entrypoints","keys","filteredEntryNames","filterChunks","sortedEntryNames","sortEntryChunks","Error","assets","htmlWebpackPluginAssets","isHotUpdateCompilation","JSON","stringify","getAssetFiles","assetsPromise","getFaviconPublicPath","publicPath","faviconPath","beforeAssetTagGeneration","promise","plugin","assetTagGroupsPromise","alterAssetTags","assetTags","scripts","generatedScriptTags","js","styles","generateStyleTags","css","generateBaseTag","generatedMetaTags","generateFaviconTags","scriptTarget","assetGroups","generateAssetGroups","alterAssetTagGroups","headTags","bodyTags","templateEvaluationPromise","compiledTemplate","evaluateCompilationResult","templateExectutionPromise","Promise","all","assetsHookResult","executeTemplate","injectedHtmlPromise","html","pluginArgs","afterTemplateExecution","postProcessHtml","emitHtmlPromise","beforeEmit","result","toHtml","finalOutputName","hashType","digestType","maxLength","getHashDigest","Buffer","parseInt","source","size","length","afterEmit","console","error","reject","vmContext","createContext","extend","HTML_WEBPACK_PLUGIN","global","vmScript","Script","newSource","runInContext","e","__esModule","default","getTemplateParameters","preparedAssetTags","prepareAssetTagGroupForRendering","templateFunction","templateParamsPromise","templateParams","htmlAfterInjection","injectAssetsIntoHtml","htmlAfterMinification","addFileToAssets","results","basename","fileDependencies","sortMode","sort","includedChunks","excludedChunks","filter","chunkName","isArray","indexOf","every","assetPath","test","compilationHash","webpackPublicPath","mainTemplate","getPublicPath","isPublicPathDefined","trim","dirname","split","sep","join","substr","manifest","find","assetFile","extname","appendHash","entryPointPublicPathMap","extensionRegexp","i","entryName","entryPointFiles","get","getFiles","entryPointPublicPaths","map","chunkFile","entryPointPublicPath","urlencodePath","extMatch","exec","ext","faviconFilePath","faviconName","getMetaTags","metaOptions","metaTagAttributeObjects","metaName","metaTagContent","name","attribute","metaTagAttributes","tagName","voidTag","attributes","jsAssets","scriptAsset","src","cssAssets","styleAsset","href","rel","baseOption","assetTagGroup","preparedTags","assetTag","copiedAssetTag","htmlRegExp","headRegExp","bodyRegExp","body","assetTagObject","head","start","end","url","filePath","encodeURIComponent","existsSync","__dirname","prefix","filepath","postfix","files","uniq","assetType","reduce","concat","webpackConfig","htmlWebpackPlugin","tags","getHooks","module","exports"],"mappings":"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","sourcesContent":["// @ts-check\n// Import types\n/** @typedef {import(\"./typings\").HtmlTagObject} HtmlTagObject */\n/** @typedef {import(\"./typings\").Options} HtmlWebpackOptions */\n/** @typedef {import(\"./typings\").ProcessedOptions} ProcessedHtmlWebpackOptions */\n/** @typedef {import(\"./typings\").TemplateParameter} TemplateParameter */\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n'use strict';\n\n// use Polyfill for util.promisify in node versions < v8\nconst promisify = require('util.promisify');\n\nconst vm = require('vm');\nconst fs = require('fs');\nconst _ = require('lodash');\nconst path = require('path');\nconst loaderUtils = require('loader-utils');\n\nconst { createHtmlTagObject, htmlTagObjectToString } = require('./lib/html-tags');\n\nconst childCompiler = require('./lib/compiler.js');\nconst prettyError = require('./lib/errors.js');\nconst chunkSorter = require('./lib/chunksorter.js');\nconst getHtmlWebpackPluginHooks = require('./lib/hooks.js').getHtmlWebpackPluginHooks;\n\nconst fsStatAsync = promisify(fs.stat);\nconst fsReadFileAsync = promisify(fs.readFile);\n\nclass HtmlWebpackPlugin {\n  /**\n   * @param {HtmlWebpackOptions} [options]\n   */\n  constructor (options) {\n    /** @type {HtmlWebpackOptions} */\n    const userOptions = options || {};\n\n    // Default options\n    /** @type {ProcessedHtmlWebpackOptions} */\n    const defaultOptions = {\n      template: 'auto',\n      templateContent: false,\n      templateParameters: templateParametersGenerator,\n      filename: 'index.html',\n      hash: false,\n      inject: true,\n      compile: true,\n      favicon: false,\n      minify: 'auto',\n      cache: true,\n      showErrors: true,\n      chunks: 'all',\n      excludeChunks: [],\n      chunksSortMode: 'auto',\n      meta: {},\n      base: false,\n      title: 'Webpack App',\n      xhtml: false\n    };\n\n    /** @type {ProcessedHtmlWebpackOptions} */\n    this.options = Object.assign(defaultOptions, userOptions);\n\n    // Default metaOptions if no template is provided\n    if (!userOptions.template && this.options.templateContent === false && this.options.meta) {\n      const defaultMeta = {\n        // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag\n        viewport: 'width=device-width, initial-scale=1'\n      };\n      this.options.meta = Object.assign({}, this.options.meta, defaultMeta, userOptions.meta);\n    }\n\n    // Instance variables to keep caching information\n    // for multiple builds\n    this.childCompilerHash = undefined;\n    /**\n     * @type {string | undefined}\n     */\n    this.childCompilationOutputName = undefined;\n    this.assetJson = undefined;\n    this.hash = undefined;\n    this.version = HtmlWebpackPlugin.version;\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n  apply (compiler) {\n    const self = this;\n    let isCompilationCached = false;\n    /** @type Promise<string> */\n    let compilationPromise;\n\n    this.options.template = this.getFullTemplatePath(this.options.template, compiler.context);\n\n    // convert absolute filename into relative so that webpack can\n    // generate it at correct location\n    const filename = this.options.filename;\n    if (path.resolve(filename) === path.normalize(filename)) {\n      this.options.filename = path.relative(compiler.options.output.path, filename);\n    }\n\n    // `contenthash` is introduced in webpack v4.3\n    // which conflicts with the plugin's existing `contenthash` method,\n    // hence it is renamed to `templatehash` to avoid conflicts\n    this.options.filename = this.options.filename.replace(/\\[(?:(\\w+):)?contenthash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, (match) => {\n      return match.replace('contenthash', 'templatehash');\n    });\n\n    // Check if webpack is running in production mode\n    // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14\n    const isProductionLikeMode = compiler.options.mode === 'production' || !compiler.options.mode;\n\n    const minify = this.options.minify;\n    if (minify === true || (minify === 'auto' && isProductionLikeMode)) {\n      /** @type { import('html-minifier').Options } */\n      this.options.minify = {\n        // https://github.com/kangax/html-minifier#options-quick-reference\n        collapseWhitespace: true,\n        removeComments: true,\n        removeRedundantAttributes: true,\n        removeScriptTypeAttributes: true,\n        removeStyleLinkTypeAttributes: true,\n        useShortDoctype: true\n      };\n    }\n\n    // Clear the cache once a new HtmlWebpackPlugin is added\n    childCompiler.clearCache(compiler);\n\n    // Register all HtmlWebpackPlugins instances at the child compiler\n    compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', (compilation) => {\n      // Clear the cache if the child compiler is outdated\n      if (childCompiler.hasOutDatedTemplateCache(compilation)) {\n        childCompiler.clearCache(compiler);\n      }\n      // Add this instances template to the child compiler\n      childCompiler.addTemplateToCompiler(compiler, this.options.template);\n      // Add file dependencies of child compiler to parent compiler\n      // to keep them watched even if we get the result from the cache\n      compilation.hooks.additionalChunkAssets.tap('HtmlWebpackPlugin', () => {\n        const childCompilerDependencies = childCompiler.getFileDependencies(compiler);\n        childCompilerDependencies.forEach(fileDependency => {\n          compilation.compilationDependencies.add(fileDependency);\n        });\n      });\n    });\n\n    compiler.hooks.make.tapAsync('HtmlWebpackPlugin', (compilation, callback) => {\n      // Compile the template (queued)\n      compilationPromise = childCompiler.compileTemplate(self.options.template, self.options.filename, compilation)\n        .catch(err => {\n          compilation.errors.push(prettyError(err, compiler.context).toString());\n          return {\n            content: self.options.showErrors ? prettyError(err, compiler.context).toJsonHtml() : 'ERROR',\n            outputName: self.options.filename,\n            hash: ''\n          };\n        })\n        .then(compilationResult => {\n          // If the compilation change didnt change the cache is valid\n          isCompilationCached = Boolean(compilationResult.hash) && self.childCompilerHash === compilationResult.hash;\n          self.childCompilerHash = compilationResult.hash;\n          self.childCompilationOutputName = compilationResult.outputName;\n          callback();\n          return compilationResult.content;\n        });\n    });\n\n    compiler.hooks.emit.tapAsync('HtmlWebpackPlugin',\n      /**\n       * Hook into the webpack emit phase\n       * @param {WebpackCompilation} compilation\n       * @param {() => void} callback\n      */\n      (compilation, callback) => {\n        // Get all entry point names for this html file\n        const entryNames = Array.from(compilation.entrypoints.keys());\n        const filteredEntryNames = self.filterChunks(entryNames, self.options.chunks, self.options.excludeChunks);\n        const sortedEntryNames = self.sortEntryChunks(filteredEntryNames, this.options.chunksSortMode, compilation);\n        const childCompilationOutputName = self.childCompilationOutputName;\n\n        if (childCompilationOutputName === undefined) {\n          throw new Error('Did not receive child compilation result');\n        }\n\n        // Turn the entry point names into file paths\n        const assets = self.htmlWebpackPluginAssets(compilation, childCompilationOutputName, sortedEntryNames);\n\n        // If this is a hot update compilation, move on!\n        // This solves a problem where an `index.html` file is generated for hot-update js files\n        // It only happens in Webpack 2, where hot updates are emitted separately before the full bundle\n        if (self.isHotUpdateCompilation(assets)) {\n          return callback();\n        }\n\n        // If the template and the assets did not change we don't have to emit the html\n        const assetJson = JSON.stringify(self.getAssetFiles(assets));\n        if (isCompilationCached && self.options.cache && assetJson === self.assetJson) {\n          return callback();\n        } else {\n          self.assetJson = assetJson;\n        }\n\n        // The html-webpack plugin uses a object representation for the html-tags which will be injected\n        // to allow altering them more easily\n        // Just before they are converted a third-party-plugin author might change the order and content\n        const assetsPromise = this.getFaviconPublicPath(this.options.favicon, compilation, assets.publicPath)\n          .then((faviconPath) => {\n            assets.favicon = faviconPath;\n            return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({\n              assets: assets,\n              outputName: childCompilationOutputName,\n              plugin: self\n            });\n          });\n\n        // Turn the js and css paths into grouped HtmlTagObjects\n        const assetTagGroupsPromise = assetsPromise\n          // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped\n          .then(({ assets }) => getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({\n            assetTags: {\n              scripts: self.generatedScriptTags(assets.js),\n              styles: self.generateStyleTags(assets.css),\n              meta: [\n                ...self.generateBaseTag(self.options.base),\n                ...self.generatedMetaTags(self.options.meta),\n                ...self.generateFaviconTags(assets.favicon)\n              ]\n            },\n            outputName: childCompilationOutputName,\n            plugin: self\n          }))\n          .then(({ assetTags }) => {\n            // Inject scripts to body unless it set explictly to head\n            const scriptTarget = self.options.inject === 'head' ? 'head' : 'body';\n            // Group assets to `head` and `body` tag arrays\n            const assetGroups = this.generateAssetGroups(assetTags, scriptTarget);\n            // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped\n            return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({\n              headTags: assetGroups.headTags,\n              bodyTags: assetGroups.bodyTags,\n              outputName: childCompilationOutputName,\n              plugin: self\n            });\n          });\n\n        // Turn the compiled tempalte into a nodejs function or into a nodejs string\n        const templateEvaluationPromise = compilationPromise\n          .then(compiledTemplate => {\n            // Allow to use a custom function / string instead\n            if (self.options.templateContent !== false) {\n              return self.options.templateContent;\n            }\n            // Once everything is compiled evaluate the html factory\n            // and replace it with its content\n            return self.evaluateCompilationResult(compilation, compiledTemplate);\n          });\n\n        const templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise])\n          // Execute the template\n          .then(([assetsHookResult, assetTags, compilationResult]) => typeof compilationResult !== 'function'\n            ? compilationResult\n            : self.executeTemplate(compilationResult, assetsHookResult.assets, { headTags: assetTags.headTags, bodyTags: assetTags.bodyTags }, compilation));\n\n        const injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise])\n          // Allow plugins to change the html before assets are injected\n          .then(([assetTags, html]) => {\n            const pluginArgs = { html, headTags: assetTags.headTags, bodyTags: assetTags.bodyTags, plugin: self, outputName: childCompilationOutputName };\n            return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);\n          })\n          .then(({ html, headTags, bodyTags }) => {\n            return self.postProcessHtml(html, assets, { headTags, bodyTags });\n          });\n\n        const emitHtmlPromise = injectedHtmlPromise\n          // Allow plugins to change the html after assets are injected\n          .then((html) => {\n            const pluginArgs = { html, plugin: self, outputName: childCompilationOutputName };\n            return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs)\n              .then(result => result.html);\n          })\n          .catch(err => {\n            // In case anything went wrong the promise is resolved\n            // with the error message and an error is logged\n            compilation.errors.push(prettyError(err, compiler.context).toString());\n            // Prevent caching\n            self.hash = null;\n            return self.options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';\n          })\n          .then(html => {\n            // Allow to use [templatehash] as placeholder for the html-webpack-plugin name\n            // See also https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/\n            // From https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/8de6558e33487e7606e7cd7cb2adc2cccafef272/src/index.js#L212-L214\n            const finalOutputName = childCompilationOutputName.replace(/\\[(?:(\\w+):)?templatehash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, (_, hashType, digestType, maxLength) => {\n              return loaderUtils.getHashDigest(Buffer.from(html, 'utf8'), hashType, digestType, parseInt(maxLength, 10));\n            });\n              // Add the evaluated html code to the webpack assets\n            compilation.assets[finalOutputName] = {\n              source: () => html,\n              size: () => html.length\n            };\n            return finalOutputName;\n          })\n          .then((finalOutputName) => getHtmlWebpackPluginHooks(compilation).afterEmit.promise({\n            outputName: finalOutputName,\n            plugin: self\n          }).catch(err => {\n            console.error(err);\n            return null;\n          }).then(() => null));\n\n        // Once all files are added to the webpack compilation\n        // let the webpack compiler continue\n        emitHtmlPromise.then(() => {\n          callback();\n        });\n      });\n  }\n\n  /**\n   * Evaluates the child compilation result\n   * @param {WebpackCompilation} compilation\n   * @param {string} source\n   * @returns {Promise<string | (() => string | Promise<string>)>}\n   */\n  evaluateCompilationResult (compilation, source) {\n    if (!source) {\n      return Promise.reject(new Error('The child compilation didn\\'t provide a result'));\n    }\n    // The LibraryTemplatePlugin stores the template result in a local variable.\n    // To extract the result during the evaluation this part has to be removed.\n    source = source.replace('var HTML_WEBPACK_PLUGIN_RESULT =', '');\n    const template = this.options.template.replace(/^.+!/, '').replace(/\\?.+$/, '');\n    const vmContext = vm.createContext(_.extend({ HTML_WEBPACK_PLUGIN: true, require: require }, global));\n    const vmScript = new vm.Script(source, { filename: template });\n    // Evaluate code and cast to string\n    let newSource;\n    try {\n      newSource = vmScript.runInContext(vmContext);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {\n      newSource = newSource.default;\n    }\n    return typeof newSource === 'string' || typeof newSource === 'function'\n      ? Promise.resolve(newSource)\n      : Promise.reject(new Error('The loader \"' + this.options.template + '\" didn\\'t return html.'));\n  }\n\n  /**\n   * Generate the template parameters for the template function\n   * @param {WebpackCompilation} compilation\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @returns {Promise<{[key: any]: any}>}\n   */\n  getTemplateParameters (compilation, assets, assetTags) {\n    const templateParameters = this.options.templateParameters;\n    if (templateParameters === false) {\n      return Promise.resolve({});\n    }\n    if (typeof templateParameters === 'function') {\n      const preparedAssetTags = {\n        headTags: this.prepareAssetTagGroupForRendering(assetTags.headTags),\n        bodyTags: this.prepareAssetTagGroupForRendering(assetTags.bodyTags)\n      };\n      return Promise\n        .resolve()\n        .then(() => templateParameters(compilation, assets, preparedAssetTags, this.options));\n    }\n    if (typeof templateParameters === 'object') {\n      return Promise.resolve(templateParameters);\n    }\n    throw new Error('templateParameters has to be either a function or an object');\n  }\n\n  /**\n   * This function renders the actual html by executing the template function\n   *\n   * @param {(templateParameters) => string | Promise<string>} templateFunction\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns Promise<string>\n   */\n  executeTemplate (templateFunction, assets, assetTags, compilation) {\n    // Template processing\n    const templateParamsPromise = this.getTemplateParameters(compilation, assets, assetTags);\n    return templateParamsPromise.then((templateParams) => {\n      try {\n        // If html is a promise return the promise\n        // If html is a string turn it into a promise\n        return templateFunction(templateParams);\n      } catch (e) {\n        compilation.errors.push(new Error('Template execution failed: ' + e));\n        return Promise.reject(e);\n      }\n    });\n  }\n\n  /**\n   * Html Post processing\n   *\n   * @param {any} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {Promise<string>}\n   */\n  postProcessHtml (html, assets, assetTags) {\n    if (typeof html !== 'string') {\n      return Promise.reject(new Error('Expected html to be a string but got ' + JSON.stringify(html)));\n    }\n    const htmlAfterInjection = this.options.inject\n      ? this.injectAssetsIntoHtml(html, assets, assetTags)\n      : html;\n    const htmlAfterMinification = typeof this.options.minify === 'object'\n      ? require('html-minifier-terser').minify(htmlAfterInjection, this.options.minify)\n      : htmlAfterInjection;\n    return Promise.resolve(htmlAfterMinification);\n  }\n\n  /*\n   * Pushes the content of the given filename to the compilation assets\n   * @param {string} filename\n   * @param {WebpackCompilation} compilation\n   *\n   * @returns {string} file basename\n   */\n  addFileToAssets (filename, compilation) {\n    filename = path.resolve(compilation.compiler.context, filename);\n    return Promise.all([\n      fsStatAsync(filename),\n      fsReadFileAsync(filename)\n    ])\n      .then(([size, source]) => {\n        return {\n          size,\n          source\n        };\n      })\n      .catch(() => Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename)))\n      .then(results => {\n        const basename = path.basename(filename);\n        compilation.fileDependencies.add(filename);\n        compilation.assets[basename] = {\n          source: () => results.source,\n          size: () => results.size.size\n        };\n        return basename;\n      });\n  }\n\n  /**\n   * Helper to sort chunks\n   * @param {string[]} entryNames\n   * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode\n   * @param {WebpackCompilation} compilation\n   */\n  sortEntryChunks (entryNames, sortMode, compilation) {\n    // Custom function\n    if (typeof sortMode === 'function') {\n      return entryNames.sort(sortMode);\n    }\n    // Check if the given sort mode is a valid chunkSorter sort mode\n    if (typeof chunkSorter[sortMode] !== 'undefined') {\n      return chunkSorter[sortMode](entryNames, compilation, this.options);\n    }\n    throw new Error('\"' + sortMode + '\" is not a valid chunk sort mode');\n  }\n\n  /**\n   * Return all chunks from the compilation result which match the exclude and include filters\n   * @param {any} chunks\n   * @param {string[]|'all'} includedChunks\n   * @param {string[]} excludedChunks\n   */\n  filterChunks (chunks, includedChunks, excludedChunks) {\n    return chunks.filter(chunkName => {\n      // Skip if the chunks should be filtered and the given chunk was not added explicity\n      if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {\n        return false;\n      }\n      // Skip if the chunks should be filtered and the given chunk was excluded explicity\n      if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {\n        return false;\n      }\n      // Add otherwise\n      return true;\n    });\n  }\n\n  /**\n   * Check if the given asset object consists only of hot-update.js files\n   *\n   * @param {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }} assets\n   */\n  isHotUpdateCompilation (assets) {\n    return assets.js.length && assets.js.every((assetPath) => /\\.hot-update\\.js$/.test(assetPath));\n  }\n\n  /**\n   * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation\n   * for all given entry names\n   * @param {WebpackCompilation} compilation\n   * @param {string[]} entryNames\n   * @returns {{\n      publicPath: string,\n      js: Array<string>,\n      css: Array<string>,\n      manifest?: string,\n      favicon?: string\n    }}\n   */\n  htmlWebpackPluginAssets (compilation, childCompilationOutputName, entryNames) {\n    const compilationHash = compilation.hash;\n\n    /**\n     * @type {string} the configured public path to the asset root\n     * if a path publicPath is set in the current webpack config use it otherwise\n     * fallback to a realtive path\n     */\n    const webpackPublicPath = compilation.mainTemplate.getPublicPath({ hash: compilationHash });\n    const isPublicPathDefined = webpackPublicPath.trim() !== '';\n    let publicPath = isPublicPathDefined\n      // If a hard coded public path exists use it\n      ? webpackPublicPath\n      // If no public path was set get a relative url path\n      : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path)\n        .split(path.sep).join('/');\n\n    if (publicPath.length && publicPath.substr(-1, 1) !== '/') {\n      publicPath += '/';\n    }\n\n    /**\n     * @type {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }}\n     */\n    const assets = {\n      // The public path\n      publicPath: publicPath,\n      // Will contain all js and mjs files\n      js: [],\n      // Will contain all css files\n      css: [],\n      // Will contain the html5 appcache manifest files if it exists\n      manifest: Object.keys(compilation.assets).find(assetFile => path.extname(assetFile) === '.appcache'),\n      // Favicon\n      favicon: undefined\n    };\n\n    // Append a hash for cache busting\n    if (this.options.hash && assets.manifest) {\n      assets.manifest = this.appendHash(assets.manifest, compilationHash);\n    }\n\n    // Extract paths to .js, .mjs and .css files from the current compilation\n    const entryPointPublicPathMap = {};\n    const extensionRegexp = /\\.(css|js|mjs)(\\?|$)/;\n    for (let i = 0; i < entryNames.length; i++) {\n      const entryName = entryNames[i];\n      const entryPointFiles = compilation.entrypoints.get(entryName).getFiles();\n      // Prepend the publicPath and append the hash depending on the\n      // webpack.output.publicPath and hashOptions\n      // E.g. bundle.js -> /bundle.js?hash\n      const entryPointPublicPaths = entryPointFiles\n        .map(chunkFile => {\n          const entryPointPublicPath = publicPath + this.urlencodePath(chunkFile);\n          return this.options.hash\n            ? this.appendHash(entryPointPublicPath, compilationHash)\n            : entryPointPublicPath;\n        });\n\n      entryPointPublicPaths.forEach((entryPointPublicPath) => {\n        const extMatch = extensionRegexp.exec(entryPointPublicPath);\n        // Skip if the public path is not a .css, .mjs or .js file\n        if (!extMatch) {\n          return;\n        }\n        // Skip if this file is already known\n        // (e.g. because of common chunk optimizations)\n        if (entryPointPublicPathMap[entryPointPublicPath]) {\n          return;\n        }\n        entryPointPublicPathMap[entryPointPublicPath] = true;\n        // ext will contain .js or .css, because .mjs recognizes as .js\n        const ext = extMatch[1] === 'mjs' ? 'js' : extMatch[1];\n        assets[ext].push(entryPointPublicPath);\n      });\n    }\n    return assets;\n  }\n\n  /**\n   * Converts a favicon file from disk to a webpack ressource\n   * and returns the url to the ressource\n   *\n   * @param {string|false} faviconFilePath\n   * @param {WebpackCompilation} compilation\n   * @param {string} publicPath\n   * @returns {Promise<string|undefined>}\n   */\n  getFaviconPublicPath (faviconFilePath, compilation, publicPath) {\n    if (!faviconFilePath) {\n      return Promise.resolve(undefined);\n    }\n    return this.addFileToAssets(faviconFilePath, compilation)\n      .then((faviconName) => {\n        const faviconPath = publicPath + faviconName;\n        if (this.options.hash) {\n          return this.appendHash(faviconPath, compilation.hash);\n        }\n        return faviconPath;\n      });\n  }\n\n  /**\n   * Generate meta tags\n   * @returns {HtmlTagObject[]}\n   */\n  getMetaTags () {\n    const metaOptions = this.options.meta;\n    if (metaOptions === false) {\n      return [];\n    }\n    // Make tags self-closing in case of xhtml\n    // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n    // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n    const metaTagAttributeObjects = Object.keys(metaOptions)\n      .map((metaName) => {\n        const metaTagContent = metaOptions[metaName];\n        return (typeof metaTagContent === 'string') ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      })\n      .filter((attribute) => attribute !== false);\n    // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n    // the html-webpack-plugin tag structure\n    return metaTagAttributeObjects.map((metaTagAttributes) => {\n      if (metaTagAttributes === false) {\n        throw new Error('Invalid meta tag');\n      }\n      return {\n        tagName: 'meta',\n        voidTag: true,\n        attributes: metaTagAttributes\n      };\n    });\n  }\n\n  /**\n   * Generate all tags script for the given file paths\n   * @param {Array<string>} jsAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n  generatedScriptTags (jsAssets) {\n    return jsAssets.map(scriptAsset => ({\n      tagName: 'script',\n      voidTag: false,\n      attributes: {\n        src: scriptAsset\n      }\n    }));\n  }\n\n  /**\n   * Generate all style tags for the given file paths\n   * @param {Array<string>} cssAssets\n   * @returns {Array<HtmlTagObject>}\n   */\n  generateStyleTags (cssAssets) {\n    return cssAssets.map(styleAsset => ({\n      tagName: 'link',\n      voidTag: true,\n      attributes: {\n        href: styleAsset,\n        rel: 'stylesheet'\n      }\n    }));\n  }\n\n  /**\n   * Generate an optional base tag\n   * @param { false\n            | string\n            | {[attributeName: string]: string} // attributes e.g. { href:\"http://example.com/page.html\" target:\"_blank\" }\n            } baseOption\n  * @returns {Array<HtmlTagObject>}\n  */\n  generateBaseTag (baseOption) {\n    if (baseOption === false) {\n      return [];\n    } else {\n      return [{\n        tagName: 'base',\n        voidTag: true,\n        attributes: (typeof baseOption === 'string') ? {\n          href: baseOption\n        } : baseOption\n      }];\n    }\n  }\n\n  /**\n   * Generate all meta tags for the given meta configuration\n   * @param {false | {\n            [name: string]:\n              false // disabled\n              | string // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`\n              | {[attributeName: string]: string|boolean} // custom properties e.g. { name:\"viewport\" content:\"width=500, initial-scale=1\" }\n        }} metaOptions\n  * @returns {Array<HtmlTagObject>}\n  */\n  generatedMetaTags (metaOptions) {\n    if (metaOptions === false) {\n      return [];\n    }\n    // Make tags self-closing in case of xhtml\n    // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n    // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n    const metaTagAttributeObjects = Object.keys(metaOptions)\n      .map((metaName) => {\n        const metaTagContent = metaOptions[metaName];\n        return (typeof metaTagContent === 'string') ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      })\n      .filter((attribute) => attribute !== false);\n      // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n      // the html-webpack-plugin tag structure\n    return metaTagAttributeObjects.map((metaTagAttributes) => {\n      if (metaTagAttributes === false) {\n        throw new Error('Invalid meta tag');\n      }\n      return {\n        tagName: 'meta',\n        voidTag: true,\n        attributes: metaTagAttributes\n      };\n    });\n  }\n\n  /**\n   * Generate a favicon tag for the given file path\n   * @param {string| undefined} faviconPath\n   * @returns {Array<HtmlTagObject>}\n   */\n  generateFaviconTags (faviconPath) {\n    if (!faviconPath) {\n      return [];\n    }\n    return [{\n      tagName: 'link',\n      voidTag: true,\n      attributes: {\n        rel: 'shortcut icon',\n        href: faviconPath\n      }\n    }];\n  }\n\n  /**\n   * Group assets to head and bottom tags\n   *\n   * @param {{\n      scripts: Array<HtmlTagObject>;\n      styles: Array<HtmlTagObject>;\n      meta: Array<HtmlTagObject>;\n    }} assetTags\n  * @param {\"body\" | \"head\"} scriptTarget\n  * @returns {{\n      headTags: Array<HtmlTagObject>;\n      bodyTags: Array<HtmlTagObject>;\n    }}\n  */\n  generateAssetGroups (assetTags, scriptTarget) {\n    /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */\n    const result = {\n      headTags: [\n        ...assetTags.meta,\n        ...assetTags.styles\n      ],\n      bodyTags: []\n    };\n    // Add script tags to head or body depending on\n    // the htmlPluginOptions\n    if (scriptTarget === 'body') {\n      result.bodyTags.push(...assetTags.scripts);\n    } else {\n      result.headTags.push(...assetTags.scripts);\n    }\n    return result;\n  }\n\n  /**\n   * Add toString methods for easier rendering\n   * inside the template\n   *\n   * @param {Array<HtmlTagObject>} assetTagGroup\n   * @returns {Array<HtmlTagObject>}\n   */\n  prepareAssetTagGroupForRendering (assetTagGroup) {\n    const xhtml = this.options.xhtml;\n    const preparedTags = assetTagGroup.map((assetTag) => {\n      const copiedAssetTag = Object.assign({}, assetTag);\n      copiedAssetTag.toString = function () {\n        return htmlTagObjectToString(this, xhtml);\n      };\n      return copiedAssetTag;\n    });\n    preparedTags.toString = function () {\n      return this.join('');\n    };\n    return preparedTags;\n  }\n\n  /**\n   * Injects the assets into the given html string\n   *\n   * @param {string} html\n   * The input html\n   * @param {any} assets\n   * @param {{\n       headTags: HtmlTagObject[],\n       bodyTags: HtmlTagObject[]\n     }} assetTags\n   * The asset tags to inject\n   *\n   * @returns {string}\n   */\n  injectAssetsIntoHtml (html, assets, assetTags) {\n    const htmlRegExp = /(<html[^>]*>)/i;\n    const headRegExp = /(<\\/head\\s*>)/i;\n    const bodyRegExp = /(<\\/body\\s*>)/i;\n    const body = assetTags.bodyTags.map((assetTagObject) => htmlTagObjectToString(assetTagObject, this.options.xhtml));\n    const head = assetTags.headTags.map((assetTagObject) => htmlTagObjectToString(assetTagObject, this.options.xhtml));\n\n    if (body.length) {\n      if (bodyRegExp.test(html)) {\n        // Append assets to body element\n        html = html.replace(bodyRegExp, match => body.join('') + match);\n      } else {\n        // Append scripts to the end of the file if no <body> element exists:\n        html += body.join('');\n      }\n    }\n\n    if (head.length) {\n      // Create a head tag if none exists\n      if (!headRegExp.test(html)) {\n        if (!htmlRegExp.test(html)) {\n          html = '<head></head>' + html;\n        } else {\n          html = html.replace(htmlRegExp, match => match + '<head></head>');\n        }\n      }\n\n      // Append assets to head element\n      html = html.replace(headRegExp, match => head.join('') + match);\n    }\n\n    // Inject manifest into the opening html tag\n    if (assets.manifest) {\n      html = html.replace(/(<html[^>]*)(>)/i, (match, start, end) => {\n        // Append the manifest only if no manifest was specified\n        if (/\\smanifest\\s*=/.test(match)) {\n          return match;\n        }\n        return start + ' manifest=\"' + assets.manifest + '\"' + end;\n      });\n    }\n    return html;\n  }\n\n  /**\n   * Appends a cache busting hash to the query string of the url\n   * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175\n   * @param {string} url\n   * @param {string} hash\n   */\n  appendHash (url, hash) {\n    if (!url) {\n      return url;\n    }\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;\n  }\n\n  /**\n   * Encode each path component using `encodeURIComponent` as files can contain characters\n   * which needs special encoding in URLs like `+ `.\n   *\n   * @param {string} filePath\n   */\n  urlencodePath (filePath) {\n    return filePath.split('/').map(encodeURIComponent).join('/');\n  }\n\n  /**\n   * Helper to return the absolute template path with a fallback loader\n   * @param {string} template\n   * The path to the template e.g. './index.html'\n   * @param {string} context\n   * The webpack base resolution path for relative paths e.g. process.cwd()\n   */\n  getFullTemplatePath (template, context) {\n    if (template === 'auto') {\n      template = path.resolve(context, 'src/index.ejs');\n      if (!fs.existsSync(template)) {\n        template = path.join(__dirname, 'default_index.ejs');\n      }\n    }\n    // If the template doesn't use a loader use the lodash template loader\n    if (template.indexOf('!') === -1) {\n      template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);\n    }\n    // Resolve template path\n    return template.replace(\n      /([!])([^/\\\\][^!?]+|[^/\\\\!?])($|\\?[^!?\\n]+$)/,\n      (match, prefix, filepath, postfix) => prefix + path.resolve(filepath) + postfix);\n  }\n\n  /**\n   * Helper to return a sorted unique array of all asset files out of the\n   * asset object\n   */\n  getAssetFiles (assets) {\n    const files = _.uniq(Object.keys(assets).filter(assetType => assetType !== 'chunks' && assets[assetType]).reduce((files, assetType) => files.concat(assets[assetType]), []));\n    files.sort();\n    return files;\n  }\n}\n\n/**\n * The default for options.templateParameter\n * Generate the template parameters\n *\n * Generate the template parameters for the template function\n * @param {WebpackCompilation} compilation\n * @param {{\n   publicPath: string,\n   js: Array<string>,\n   css: Array<string>,\n   manifest?: string,\n   favicon?: string\n }} assets\n * @param {{\n     headTags: HtmlTagObject[],\n     bodyTags: HtmlTagObject[]\n   }} assetTags\n * @param {ProcessedHtmlWebpackOptions} options\n * @returns {TemplateParameter}\n */\nfunction templateParametersGenerator (compilation, assets, assetTags, options) {\n  return {\n    compilation: compilation,\n    webpackConfig: compilation.options,\n    htmlWebpackPlugin: {\n      tags: assetTags,\n      files: assets,\n      options: options\n    }\n  };\n}\n\n// Statics:\n/**\n * The major version number of this plugin\n */\nHtmlWebpackPlugin.version = 4;\n\n/**\n * A static helper to get the hooks for this plugin\n *\n * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });\n */\nHtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;\nHtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;\n\nmodule.exports = HtmlWebpackPlugin;\n"]},"metadata":{},"sourceType":"script"}