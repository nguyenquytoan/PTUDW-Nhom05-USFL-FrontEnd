{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ts = require(\"typescript\");\n\nconst node_1 = require(\"../typeguard/node\");\n\nconst _3_2_1 = require(\"../typeguard/3.2\");\n\nconst type_1 = require(\"./type\");\n\nfunction getChildOfKind(node, kind, sourceFile) {\n  for (const child of node.getChildren(sourceFile)) if (child.kind === kind) return child;\n}\n\nexports.getChildOfKind = getChildOfKind;\n\nfunction isTokenKind(kind) {\n  return kind >= ts.SyntaxKind.FirstToken && kind <= ts.SyntaxKind.LastToken;\n}\n\nexports.isTokenKind = isTokenKind;\n\nfunction isNodeKind(kind) {\n  return kind >= ts.SyntaxKind.FirstNode;\n}\n\nexports.isNodeKind = isNodeKind;\n\nfunction isAssignmentKind(kind) {\n  return kind >= ts.SyntaxKind.FirstAssignment && kind <= ts.SyntaxKind.LastAssignment;\n}\n\nexports.isAssignmentKind = isAssignmentKind;\n\nfunction isTypeNodeKind(kind) {\n  return kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode;\n}\n\nexports.isTypeNodeKind = isTypeNodeKind;\n\nfunction isJsDocKind(kind) {\n  return kind >= ts.SyntaxKind.FirstJSDocNode && kind <= ts.SyntaxKind.LastJSDocNode;\n}\n\nexports.isJsDocKind = isJsDocKind;\n\nfunction isKeywordKind(kind) {\n  return kind >= ts.SyntaxKind.FirstKeyword && kind <= ts.SyntaxKind.LastKeyword;\n}\n\nexports.isKeywordKind = isKeywordKind;\n\nfunction isThisParameter(parameter) {\n  return parameter.name.kind === ts.SyntaxKind.Identifier && parameter.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword;\n}\n\nexports.isThisParameter = isThisParameter;\n\nfunction getModifier(node, kind) {\n  if (node.modifiers !== undefined) for (const modifier of node.modifiers) if (modifier.kind === kind) return modifier;\n}\n\nexports.getModifier = getModifier;\n\nfunction hasModifier(modifiers, ...kinds) {\n  if (modifiers === undefined) return false;\n\n  for (const modifier of modifiers) if (kinds.includes(modifier.kind)) return true;\n\n  return false;\n}\n\nexports.hasModifier = hasModifier;\n\nfunction isParameterProperty(node) {\n  return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword, ts.SyntaxKind.ReadonlyKeyword);\n}\n\nexports.isParameterProperty = isParameterProperty;\n\nfunction hasAccessModifier(node) {\n  return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword);\n}\n\nexports.hasAccessModifier = hasAccessModifier;\n\nfunction isFlagSet(obj, flag) {\n  return (obj.flags & flag) !== 0;\n}\n\nexports.isNodeFlagSet = isFlagSet;\nexports.isTypeFlagSet = isFlagSet;\nexports.isSymbolFlagSet = isFlagSet;\n\nfunction isObjectFlagSet(objectType, flag) {\n  return (objectType.objectFlags & flag) !== 0;\n}\n\nexports.isObjectFlagSet = isObjectFlagSet;\n\nfunction isModifierFlagSet(node, flag) {\n  return (ts.getCombinedModifierFlags(node) & flag) !== 0;\n}\n\nexports.isModifierFlagSet = isModifierFlagSet;\n\nfunction getPreviousStatement(statement) {\n  const parent = statement.parent;\n\n  if (node_1.isBlockLike(parent)) {\n    const index = parent.statements.indexOf(statement);\n    if (index > 0) return parent.statements[index - 1];\n  }\n}\n\nexports.getPreviousStatement = getPreviousStatement;\n\nfunction getNextStatement(statement) {\n  const parent = statement.parent;\n\n  if (node_1.isBlockLike(parent)) {\n    const index = parent.statements.indexOf(statement);\n    if (index < parent.statements.length) return parent.statements[index + 1];\n  }\n}\n\nexports.getNextStatement = getNextStatement;\n\nfunction getPreviousToken(node, sourceFile) {\n  let parent = node.parent;\n\n  while (parent !== undefined && parent.pos === node.pos) parent = parent.parent;\n\n  if (parent === undefined) return;\n\n  outer: while (true) {\n    const children = parent.getChildren(sourceFile);\n\n    for (let i = children.length - 1; i >= 0; --i) {\n      const child = children[i];\n\n      if (child.pos < node.pos && child.kind !== ts.SyntaxKind.JSDocComment) {\n        if (isTokenKind(child.kind)) return child;\n        parent = child;\n        continue outer;\n      }\n    }\n\n    return;\n  }\n}\n\nexports.getPreviousToken = getPreviousToken;\n\nfunction getNextToken(node, sourceFile = node.getSourceFile()) {\n  if (node.kind === ts.SyntaxKind.SourceFile || node.kind === ts.SyntaxKind.EndOfFileToken) return;\n  const end = node.end;\n  node = node.parent;\n\n  while (node.end === end) {\n    if (node.parent === undefined) return node.endOfFileToken;\n    node = node.parent;\n  }\n\n  return getTokenAtPositionWorker(node, end, sourceFile, false);\n}\n\nexports.getNextToken = getNextToken;\n\nfunction getTokenAtPosition(parent, pos, sourceFile, allowJsDoc) {\n  if (pos < parent.pos || pos >= parent.end) return;\n  if (isTokenKind(parent.kind)) return parent;\n  if (sourceFile === undefined) sourceFile = parent.getSourceFile();\n  return getTokenAtPositionWorker(parent, pos, sourceFile, allowJsDoc === true);\n}\n\nexports.getTokenAtPosition = getTokenAtPosition;\n\nfunction getTokenAtPositionWorker(node, pos, sourceFile, allowJsDoc) {\n  outer: while (true) {\n    for (const child of node.getChildren(sourceFile)) {\n      if (child.end > pos && (allowJsDoc || child.kind !== ts.SyntaxKind.JSDocComment)) {\n        if (isTokenKind(child.kind)) return child;\n        node = child;\n        continue outer;\n      }\n    }\n\n    return;\n  }\n}\n\nfunction getCommentAtPosition(sourceFile, pos, parent = sourceFile) {\n  const token = getTokenAtPosition(parent, pos, sourceFile);\n  if (token === undefined || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || '').length) return;\n  const startPos = token.pos === 0 ? (ts.getShebang(sourceFile.text) || '').length : token.pos;\n  return startPos !== 0 && ts.forEachTrailingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos) || ts.forEachLeadingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos);\n}\n\nexports.getCommentAtPosition = getCommentAtPosition;\n\nfunction commentAtPositionCallback(pos, end, kind, _nl, at) {\n  return at >= pos && at < end ? {\n    pos,\n    end,\n    kind\n  } : undefined;\n}\n\nfunction isPositionInComment(sourceFile, pos, parent) {\n  return getCommentAtPosition(sourceFile, pos, parent) !== undefined;\n}\n\nexports.isPositionInComment = isPositionInComment;\n\nfunction commentText(sourceText, comment) {\n  return sourceText.substring(comment.pos + 2, comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? comment.end : comment.end - 2);\n}\n\nexports.commentText = commentText;\n\nfunction getWrappedNodeAtPosition(wrap, pos) {\n  if (wrap.node.pos > pos || wrap.node.end <= pos) return;\n\n  outer: while (true) {\n    for (const child of wrap.children) {\n      if (child.node.pos > pos) return wrap;\n\n      if (child.node.end > pos) {\n        wrap = child;\n        continue outer;\n      }\n    }\n\n    return wrap;\n  }\n}\n\nexports.getWrappedNodeAtPosition = getWrappedNodeAtPosition;\n\nfunction getPropertyName(propertyName) {\n  if (propertyName.kind === ts.SyntaxKind.ComputedPropertyName) {\n    if (!node_1.isLiteralExpression(propertyName.expression)) return;\n    if (_3_2_1.isBigIntLiteral(propertyName.expression)) return propertyName.expression.text.slice(0, -1);\n    return propertyName.expression.text;\n  }\n\n  return propertyName.text;\n}\n\nexports.getPropertyName = getPropertyName;\n\nfunction forEachDestructuringIdentifier(pattern, fn) {\n  for (const element of pattern.elements) {\n    if (element.kind !== ts.SyntaxKind.BindingElement) continue;\n    let result;\n\n    if (element.name.kind === ts.SyntaxKind.Identifier) {\n      result = fn(element);\n    } else {\n      result = forEachDestructuringIdentifier(element.name, fn);\n    }\n\n    if (result) return result;\n  }\n}\n\nexports.forEachDestructuringIdentifier = forEachDestructuringIdentifier;\n\nfunction forEachDeclaredVariable(declarationList, cb) {\n  for (const declaration of declarationList.declarations) {\n    let result;\n\n    if (declaration.name.kind === ts.SyntaxKind.Identifier) {\n      result = cb(declaration);\n    } else {\n      result = forEachDestructuringIdentifier(declaration.name, cb);\n    }\n\n    if (result) return result;\n  }\n}\n\nexports.forEachDeclaredVariable = forEachDeclaredVariable;\nvar VariableDeclarationKind;\n\n(function (VariableDeclarationKind) {\n  VariableDeclarationKind[VariableDeclarationKind[\"Var\"] = 0] = \"Var\";\n  VariableDeclarationKind[VariableDeclarationKind[\"Let\"] = 1] = \"Let\";\n  VariableDeclarationKind[VariableDeclarationKind[\"Const\"] = 2] = \"Const\";\n})(VariableDeclarationKind = exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));\n\nfunction getVariableDeclarationKind(declarationList) {\n  if (declarationList.flags & ts.NodeFlags.Let) return 1;\n  if (declarationList.flags & ts.NodeFlags.Const) return 2;\n  return 0;\n}\n\nexports.getVariableDeclarationKind = getVariableDeclarationKind;\n\nfunction isBlockScopedVariableDeclarationList(declarationList) {\n  return (declarationList.flags & ts.NodeFlags.BlockScoped) !== 0;\n}\n\nexports.isBlockScopedVariableDeclarationList = isBlockScopedVariableDeclarationList;\n\nfunction isBlockScopedVariableDeclaration(declaration) {\n  const parent = declaration.parent;\n  return parent.kind === ts.SyntaxKind.CatchClause || isBlockScopedVariableDeclarationList(parent);\n}\n\nexports.isBlockScopedVariableDeclaration = isBlockScopedVariableDeclaration;\n\nfunction isBlockScopedDeclarationStatement(statement) {\n  switch (statement.kind) {\n    case ts.SyntaxKind.VariableStatement:\n      return isBlockScopedVariableDeclarationList(statement.declarationList);\n\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.isBlockScopedDeclarationStatement = isBlockScopedDeclarationStatement;\n\nfunction isInSingleStatementContext(statement) {\n  switch (statement.parent.kind) {\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.ForInStatement:\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.WhileStatement:\n    case ts.SyntaxKind.DoStatement:\n    case ts.SyntaxKind.IfStatement:\n    case ts.SyntaxKind.WithStatement:\n    case ts.SyntaxKind.LabeledStatement:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.isInSingleStatementContext = isInSingleStatementContext;\nvar ScopeBoundary;\n\n(function (ScopeBoundary) {\n  ScopeBoundary[ScopeBoundary[\"None\"] = 0] = \"None\";\n  ScopeBoundary[ScopeBoundary[\"Function\"] = 1] = \"Function\";\n  ScopeBoundary[ScopeBoundary[\"Block\"] = 2] = \"Block\";\n  ScopeBoundary[ScopeBoundary[\"Type\"] = 4] = \"Type\";\n  ScopeBoundary[ScopeBoundary[\"ConditionalType\"] = 8] = \"ConditionalType\";\n})(ScopeBoundary = exports.ScopeBoundary || (exports.ScopeBoundary = {}));\n\nvar ScopeBoundarySelector;\n\n(function (ScopeBoundarySelector) {\n  ScopeBoundarySelector[ScopeBoundarySelector[\"Function\"] = 1] = \"Function\";\n  ScopeBoundarySelector[ScopeBoundarySelector[\"Block\"] = 3] = \"Block\";\n  ScopeBoundarySelector[ScopeBoundarySelector[\"Type\"] = 7] = \"Type\";\n  ScopeBoundarySelector[ScopeBoundarySelector[\"InferType\"] = 8] = \"InferType\";\n})(ScopeBoundarySelector = exports.ScopeBoundarySelector || (exports.ScopeBoundarySelector = {}));\n\nfunction isScopeBoundary(node) {\n  return isFunctionScopeBoundary(node) || isBlockScopeBoundary(node) || isTypeScopeBoundary(node);\n}\n\nexports.isScopeBoundary = isScopeBoundary;\n\nfunction isTypeScopeBoundary(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n    case ts.SyntaxKind.MappedType:\n      return 4;\n\n    case ts.SyntaxKind.ConditionalType:\n      return 8;\n\n    default:\n      return 0;\n  }\n}\n\nexports.isTypeScopeBoundary = isTypeScopeBoundary;\n\nfunction isFunctionScopeBoundary(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.Constructor:\n    case ts.SyntaxKind.ModuleDeclaration:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.MethodSignature:\n    case ts.SyntaxKind.CallSignature:\n    case ts.SyntaxKind.ConstructSignature:\n    case ts.SyntaxKind.ConstructorType:\n    case ts.SyntaxKind.FunctionType:\n      return 1;\n\n    case ts.SyntaxKind.SourceFile:\n      return ts.isExternalModule(node) ? 1 : 0;\n\n    default:\n      return 0;\n  }\n}\n\nexports.isFunctionScopeBoundary = isFunctionScopeBoundary;\n\nfunction isBlockScopeBoundary(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.Block:\n      const parent = node.parent;\n      return parent.kind !== ts.SyntaxKind.CatchClause && (parent.kind === ts.SyntaxKind.SourceFile || !isFunctionScopeBoundary(parent)) ? 2 : 0;\n\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.ForInStatement:\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.CaseBlock:\n    case ts.SyntaxKind.CatchClause:\n    case ts.SyntaxKind.WithStatement:\n      return 2;\n\n    default:\n      return 0;\n  }\n}\n\nexports.isBlockScopeBoundary = isBlockScopeBoundary;\n\nfunction hasOwnThisReference(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.FunctionExpression:\n      return true;\n\n    case ts.SyntaxKind.FunctionDeclaration:\n      return node.body !== undefined;\n\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n      return node.parent.kind === ts.SyntaxKind.ObjectLiteralExpression;\n\n    default:\n      return false;\n  }\n}\n\nexports.hasOwnThisReference = hasOwnThisReference;\n\nfunction isFunctionWithBody(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.Constructor:\n      return node.body !== undefined;\n\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.ArrowFunction:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.isFunctionWithBody = isFunctionWithBody;\n\nfunction forEachToken(node, cb, sourceFile = node.getSourceFile()) {\n  return function iterate(child) {\n    if (isTokenKind(child.kind)) return cb(child);\n    if (child.kind !== ts.SyntaxKind.JSDocComment) return child.getChildren(sourceFile).forEach(iterate);\n  }(node);\n}\n\nexports.forEachToken = forEachToken;\n\nfunction forEachTokenWithTrivia(node, cb, sourceFile = node.getSourceFile()) {\n  const fullText = sourceFile.text;\n  const scanner = ts.createScanner(sourceFile.languageVersion, false, sourceFile.languageVariant, fullText);\n  return forEachToken(node, token => {\n    const tokenStart = token.kind === ts.SyntaxKind.JsxText || token.pos === token.end ? token.pos : token.getStart(sourceFile);\n\n    if (tokenStart !== token.pos) {\n      scanner.setTextPos(token.pos);\n      let kind = scanner.scan();\n      let pos = scanner.getTokenPos();\n\n      while (pos < tokenStart) {\n        const textPos = scanner.getTextPos();\n        cb(fullText, kind, {\n          pos,\n          end: textPos\n        }, token.parent);\n        if (textPos === tokenStart) break;\n        kind = scanner.scan();\n        pos = scanner.getTokenPos();\n      }\n    }\n\n    return cb(fullText, token.kind, {\n      end: token.end,\n      pos: tokenStart\n    }, token.parent);\n  }, sourceFile);\n}\n\nexports.forEachTokenWithTrivia = forEachTokenWithTrivia;\n\nfunction forEachComment(node, cb, sourceFile = node.getSourceFile()) {\n  const fullText = sourceFile.text;\n  const notJsx = sourceFile.languageVariant !== ts.LanguageVariant.JSX;\n  return forEachToken(node, token => {\n    if (token.pos === token.end) return;\n    if (token.kind !== ts.SyntaxKind.JsxText) ts.forEachLeadingCommentRange(fullText, token.pos === 0 ? (ts.getShebang(fullText) || '').length : token.pos, commentCallback);\n    if (notJsx || canHaveTrailingTrivia(token)) return ts.forEachTrailingCommentRange(fullText, token.end, commentCallback);\n  }, sourceFile);\n\n  function commentCallback(pos, end, kind) {\n    cb(fullText, {\n      pos,\n      end,\n      kind\n    });\n  }\n}\n\nexports.forEachComment = forEachComment;\n\nfunction canHaveTrailingTrivia(token) {\n  switch (token.kind) {\n    case ts.SyntaxKind.CloseBraceToken:\n      return token.parent.kind !== ts.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);\n\n    case ts.SyntaxKind.GreaterThanToken:\n      switch (token.parent.kind) {\n        case ts.SyntaxKind.JsxOpeningElement:\n          return token.end !== token.parent.end;\n\n        case ts.SyntaxKind.JsxOpeningFragment:\n          return false;\n\n        case ts.SyntaxKind.JsxSelfClosingElement:\n          return token.end !== token.parent.end || !isJsxElementOrFragment(token.parent.parent);\n\n        case ts.SyntaxKind.JsxClosingElement:\n        case ts.SyntaxKind.JsxClosingFragment:\n          return !isJsxElementOrFragment(token.parent.parent.parent);\n      }\n\n  }\n\n  return true;\n}\n\nfunction isJsxElementOrFragment(node) {\n  return node.kind === ts.SyntaxKind.JsxElement || node.kind === ts.SyntaxKind.JsxFragment;\n}\n\nfunction getLineRanges(sourceFile) {\n  const lineStarts = sourceFile.getLineStarts();\n  const result = [];\n  const length = lineStarts.length;\n  const sourceText = sourceFile.text;\n  let pos = 0;\n\n  for (let i = 1; i < length; ++i) {\n    const end = lineStarts[i];\n    let lineEnd = end;\n\n    for (; lineEnd > pos; --lineEnd) if (!ts.isLineBreak(sourceText.charCodeAt(lineEnd - 1))) break;\n\n    result.push({\n      pos,\n      end,\n      contentLength: lineEnd - pos\n    });\n    pos = end;\n  }\n\n  result.push({\n    pos,\n    end: sourceFile.end,\n    contentLength: sourceFile.end - pos\n  });\n  return result;\n}\n\nexports.getLineRanges = getLineRanges;\n\nfunction getLineBreakStyle(sourceFile) {\n  const lineStarts = sourceFile.getLineStarts();\n  return lineStarts.length === 1 || lineStarts[1] < 2 || sourceFile.text[lineStarts[1] - 2] !== '\\r' ? '\\n' : '\\r\\n';\n}\n\nexports.getLineBreakStyle = getLineBreakStyle;\nlet cachedScanner;\n\nfunction scanToken(text, languageVersion) {\n  if (cachedScanner === undefined) {\n    cachedScanner = ts.createScanner(languageVersion, false, undefined, text);\n  } else {\n    cachedScanner.setScriptTarget(languageVersion);\n    cachedScanner.setText(text);\n  }\n\n  cachedScanner.scan();\n  return cachedScanner;\n}\n\nfunction isValidIdentifier(text, languageVersion = ts.ScriptTarget.Latest) {\n  const scan = scanToken(text, languageVersion);\n  return scan.isIdentifier() && scan.getTextPos() === text.length && scan.getTokenPos() === 0;\n}\n\nexports.isValidIdentifier = isValidIdentifier;\n\nfunction charSize(ch) {\n  return ch >= 0x10000 ? 2 : 1;\n}\n\nfunction isValidPropertyAccess(text, languageVersion = ts.ScriptTarget.Latest) {\n  if (text.length === 0) return false;\n  let ch = text.codePointAt(0);\n  if (!ts.isIdentifierStart(ch, languageVersion)) return false;\n\n  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n    ch = text.codePointAt(i);\n    if (!ts.isIdentifierPart(ch, languageVersion)) return false;\n  }\n\n  return true;\n}\n\nexports.isValidPropertyAccess = isValidPropertyAccess;\n\nfunction isValidPropertyName(text, languageVersion = ts.ScriptTarget.Latest) {\n  if (isValidPropertyAccess(text, languageVersion)) return true;\n  const scan = scanToken(text, languageVersion);\n  return scan.getTextPos() === text.length && scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTokenValue() === text;\n}\n\nexports.isValidPropertyName = isValidPropertyName;\n\nfunction isValidNumericLiteral(text, languageVersion = ts.ScriptTarget.Latest) {\n  const scan = scanToken(text, languageVersion);\n  return scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTextPos() === text.length && scan.getTokenPos() === 0;\n}\n\nexports.isValidNumericLiteral = isValidNumericLiteral;\n\nfunction isValidJsxIdentifier(text, languageVersion = ts.ScriptTarget.Latest) {\n  if (text.length === 0) return false;\n  let ch = text.codePointAt(0);\n  if (!ts.isIdentifierStart(ch, languageVersion)) return false;\n\n  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n    ch = text.codePointAt(i);\n    if (!ts.isIdentifierPart(ch, languageVersion) && ch !== 45) return false;\n  }\n\n  return true;\n}\n\nexports.isValidJsxIdentifier = isValidJsxIdentifier;\n\nfunction isNumericPropertyName(name) {\n  return String(+name) === name;\n}\n\nexports.isNumericPropertyName = isNumericPropertyName;\n\nfunction isSameLine(sourceFile, pos1, pos2) {\n  return ts.getLineAndCharacterOfPosition(sourceFile, pos1).line === ts.getLineAndCharacterOfPosition(sourceFile, pos2).line;\n}\n\nexports.isSameLine = isSameLine;\nvar SideEffectOptions;\n\n(function (SideEffectOptions) {\n  SideEffectOptions[SideEffectOptions[\"None\"] = 0] = \"None\";\n  SideEffectOptions[SideEffectOptions[\"TaggedTemplate\"] = 1] = \"TaggedTemplate\";\n  SideEffectOptions[SideEffectOptions[\"Constructor\"] = 2] = \"Constructor\";\n  SideEffectOptions[SideEffectOptions[\"JsxElement\"] = 4] = \"JsxElement\";\n})(SideEffectOptions = exports.SideEffectOptions || (exports.SideEffectOptions = {}));\n\nfunction hasSideEffects(node, options) {\n  switch (node.kind) {\n    case ts.SyntaxKind.CallExpression:\n    case ts.SyntaxKind.PostfixUnaryExpression:\n    case ts.SyntaxKind.AwaitExpression:\n    case ts.SyntaxKind.YieldExpression:\n    case ts.SyntaxKind.DeleteExpression:\n      return true;\n\n    case ts.SyntaxKind.TypeAssertionExpression:\n    case ts.SyntaxKind.AsExpression:\n    case ts.SyntaxKind.ParenthesizedExpression:\n    case ts.SyntaxKind.NonNullExpression:\n    case ts.SyntaxKind.VoidExpression:\n    case ts.SyntaxKind.TypeOfExpression:\n    case ts.SyntaxKind.PropertyAccessExpression:\n    case ts.SyntaxKind.SpreadElement:\n    case ts.SyntaxKind.PartiallyEmittedExpression:\n      return hasSideEffects(node.expression, options);\n\n    case ts.SyntaxKind.BinaryExpression:\n      return isAssignmentKind(node.operatorToken.kind) || hasSideEffects(node.left, options) || hasSideEffects(node.right, options);\n\n    case ts.SyntaxKind.PrefixUnaryExpression:\n      switch (node.operator) {\n        case ts.SyntaxKind.PlusPlusToken:\n        case ts.SyntaxKind.MinusMinusToken:\n          return true;\n\n        default:\n          return hasSideEffects(node.operand, options);\n      }\n\n    case ts.SyntaxKind.ElementAccessExpression:\n      return hasSideEffects(node.expression, options) || node.argumentExpression !== undefined && hasSideEffects(node.argumentExpression, options);\n\n    case ts.SyntaxKind.ConditionalExpression:\n      return hasSideEffects(node.condition, options) || hasSideEffects(node.whenTrue, options) || hasSideEffects(node.whenFalse, options);\n\n    case ts.SyntaxKind.NewExpression:\n      if (options & 2 || hasSideEffects(node.expression, options)) return true;\n      if (node.arguments !== undefined) for (const child of node.arguments) if (hasSideEffects(child, options)) return true;\n      return false;\n\n    case ts.SyntaxKind.TaggedTemplateExpression:\n      if (options & 1 || hasSideEffects(node.tag, options)) return true;\n      if (node.template.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) return false;\n      node = node.template;\n\n    case ts.SyntaxKind.TemplateExpression:\n      for (const child of node.templateSpans) if (hasSideEffects(child.expression, options)) return true;\n\n      return false;\n\n    case ts.SyntaxKind.ClassExpression:\n      return classExpressionHasSideEffects(node, options);\n\n    case ts.SyntaxKind.ArrayLiteralExpression:\n      for (const child of node.elements) if (hasSideEffects(child, options)) return true;\n\n      return false;\n\n    case ts.SyntaxKind.ObjectLiteralExpression:\n      for (const child of node.properties) {\n        if (child.name !== undefined && child.name.kind === ts.SyntaxKind.ComputedPropertyName && hasSideEffects(child.name.expression, options)) return true;\n\n        switch (child.kind) {\n          case ts.SyntaxKind.PropertyAssignment:\n            if (hasSideEffects(child.initializer, options)) return true;\n            break;\n\n          case ts.SyntaxKind.SpreadAssignment:\n            if (hasSideEffects(child.expression, options)) return true;\n        }\n      }\n\n      return false;\n\n    case ts.SyntaxKind.JsxExpression:\n      return node.expression !== undefined && hasSideEffects(node.expression, options);\n\n    case ts.SyntaxKind.JsxElement:\n    case ts.SyntaxKind.JsxFragment:\n      for (const child of node.children) if (child.kind !== ts.SyntaxKind.JsxText && hasSideEffects(child, options)) return true;\n\n      if (node.kind === ts.SyntaxKind.JsxFragment) return false;\n      node = node.openingElement;\n\n    case ts.SyntaxKind.JsxSelfClosingElement:\n    case ts.SyntaxKind.JsxOpeningElement:\n      if (options & 4) return true;\n\n      for (const child of node.attributes.properties) {\n        if (child.kind === ts.SyntaxKind.JsxSpreadAttribute) {\n          if (hasSideEffects(child.expression, options)) return true;\n        } else if (child.initializer !== undefined && hasSideEffects(child.initializer, options)) {\n          return true;\n        }\n      }\n\n      return false;\n\n    case ts.SyntaxKind.CommaListExpression:\n      for (const child of node.elements) if (hasSideEffects(child, options)) return true;\n\n      return false;\n\n    default:\n      return false;\n  }\n}\n\nexports.hasSideEffects = hasSideEffects;\n\nfunction classExpressionHasSideEffects(node, options) {\n  if (node.heritageClauses !== undefined && node.heritageClauses[0].token === ts.SyntaxKind.ExtendsKeyword) for (const base of node.heritageClauses[0].types) if (hasSideEffects(base.expression, options)) return true;\n\n  for (const child of node.members) if (child.name !== undefined && child.name.kind === ts.SyntaxKind.ComputedPropertyName && hasSideEffects(child.name.expression, options) || node_1.isPropertyDeclaration(child) && child.initializer !== undefined && hasSideEffects(child.initializer, options)) return true;\n\n  return false;\n}\n\nfunction getDeclarationOfBindingElement(node) {\n  let parent = node.parent.parent;\n\n  while (parent.kind === ts.SyntaxKind.BindingElement) parent = parent.parent.parent;\n\n  return parent;\n}\n\nexports.getDeclarationOfBindingElement = getDeclarationOfBindingElement;\n\nfunction isExpressionValueUsed(node) {\n  while (true) {\n    const parent = node.parent;\n\n    switch (parent.kind) {\n      case ts.SyntaxKind.CallExpression:\n      case ts.SyntaxKind.NewExpression:\n      case ts.SyntaxKind.ElementAccessExpression:\n      case ts.SyntaxKind.WhileStatement:\n      case ts.SyntaxKind.DoStatement:\n      case ts.SyntaxKind.WithStatement:\n      case ts.SyntaxKind.ThrowStatement:\n      case ts.SyntaxKind.ReturnStatement:\n      case ts.SyntaxKind.JsxExpression:\n      case ts.SyntaxKind.JsxSpreadAttribute:\n      case ts.SyntaxKind.JsxElement:\n      case ts.SyntaxKind.JsxFragment:\n      case ts.SyntaxKind.JsxSelfClosingElement:\n      case ts.SyntaxKind.ComputedPropertyName:\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.ExportSpecifier:\n      case ts.SyntaxKind.ExportAssignment:\n      case ts.SyntaxKind.ImportDeclaration:\n      case ts.SyntaxKind.ExternalModuleReference:\n      case ts.SyntaxKind.Decorator:\n      case ts.SyntaxKind.TaggedTemplateExpression:\n      case ts.SyntaxKind.TemplateSpan:\n      case ts.SyntaxKind.ExpressionWithTypeArguments:\n      case ts.SyntaxKind.TypeOfExpression:\n      case ts.SyntaxKind.AwaitExpression:\n      case ts.SyntaxKind.YieldExpression:\n      case ts.SyntaxKind.LiteralType:\n      case ts.SyntaxKind.JsxAttributes:\n      case ts.SyntaxKind.JsxOpeningElement:\n      case ts.SyntaxKind.JsxClosingElement:\n      case ts.SyntaxKind.IfStatement:\n      case ts.SyntaxKind.CaseClause:\n      case ts.SyntaxKind.SwitchStatement:\n        return true;\n\n      case ts.SyntaxKind.PropertyAccessExpression:\n        return parent.expression === node;\n\n      case ts.SyntaxKind.QualifiedName:\n        return parent.left === node;\n\n      case ts.SyntaxKind.ShorthandPropertyAssignment:\n        return parent.objectAssignmentInitializer === node || !isInDestructuringAssignment(parent);\n\n      case ts.SyntaxKind.PropertyAssignment:\n        return parent.initializer === node && !isInDestructuringAssignment(parent);\n\n      case ts.SyntaxKind.SpreadAssignment:\n      case ts.SyntaxKind.SpreadElement:\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        return !isInDestructuringAssignment(parent);\n\n      case ts.SyntaxKind.ParenthesizedExpression:\n      case ts.SyntaxKind.AsExpression:\n      case ts.SyntaxKind.TypeAssertionExpression:\n      case ts.SyntaxKind.PostfixUnaryExpression:\n      case ts.SyntaxKind.PrefixUnaryExpression:\n      case ts.SyntaxKind.NonNullExpression:\n        node = parent;\n        break;\n\n      case ts.SyntaxKind.ForStatement:\n        return parent.condition === node;\n\n      case ts.SyntaxKind.ForInStatement:\n      case ts.SyntaxKind.ForOfStatement:\n        return parent.expression === node;\n\n      case ts.SyntaxKind.ConditionalExpression:\n        if (parent.condition === node) return true;\n        node = parent;\n        break;\n\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.BindingElement:\n      case ts.SyntaxKind.VariableDeclaration:\n      case ts.SyntaxKind.Parameter:\n      case ts.SyntaxKind.EnumMember:\n        return parent.initializer === node;\n\n      case ts.SyntaxKind.ImportEqualsDeclaration:\n        return parent.moduleReference === node;\n\n      case ts.SyntaxKind.CommaListExpression:\n        if (parent.elements[parent.elements.length - 1] !== node) return false;\n        node = parent;\n        break;\n\n      case ts.SyntaxKind.BinaryExpression:\n        if (parent.right === node) {\n          if (parent.operatorToken.kind === ts.SyntaxKind.CommaToken) {\n            node = parent;\n            break;\n          }\n\n          return true;\n        }\n\n        switch (parent.operatorToken.kind) {\n          case ts.SyntaxKind.CommaToken:\n          case ts.SyntaxKind.EqualsToken:\n            return false;\n\n          case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          case ts.SyntaxKind.EqualsEqualsToken:\n          case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          case ts.SyntaxKind.ExclamationEqualsToken:\n          case ts.SyntaxKind.InstanceOfKeyword:\n          case ts.SyntaxKind.PlusToken:\n          case ts.SyntaxKind.MinusToken:\n          case ts.SyntaxKind.AsteriskToken:\n          case ts.SyntaxKind.SlashToken:\n          case ts.SyntaxKind.PercentToken:\n          case ts.SyntaxKind.AsteriskAsteriskToken:\n          case ts.SyntaxKind.GreaterThanToken:\n          case ts.SyntaxKind.GreaterThanGreaterThanToken:\n          case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n          case ts.SyntaxKind.GreaterThanEqualsToken:\n          case ts.SyntaxKind.LessThanToken:\n          case ts.SyntaxKind.LessThanLessThanToken:\n          case ts.SyntaxKind.LessThanEqualsToken:\n          case ts.SyntaxKind.AmpersandToken:\n          case ts.SyntaxKind.BarToken:\n          case ts.SyntaxKind.CaretToken:\n          case ts.SyntaxKind.BarBarToken:\n          case ts.SyntaxKind.AmpersandAmpersandToken:\n          case ts.SyntaxKind.InKeyword:\n            return true;\n\n          default:\n            node = parent;\n        }\n\n        break;\n\n      default:\n        return false;\n    }\n  }\n}\n\nexports.isExpressionValueUsed = isExpressionValueUsed;\n\nfunction isInDestructuringAssignment(node) {\n  switch (node.kind) {\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n      if (node.objectAssignmentInitializer !== undefined) return true;\n\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.SpreadAssignment:\n      node = node.parent;\n      break;\n\n    case ts.SyntaxKind.SpreadElement:\n      if (node.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression) return false;\n      node = node.parent;\n  }\n\n  while (true) {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.BinaryExpression:\n        return node.parent.left === node && node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n\n      case ts.SyntaxKind.ForOfStatement:\n        return node.parent.initializer === node;\n\n      case ts.SyntaxKind.ArrayLiteralExpression:\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        node = node.parent;\n        break;\n\n      case ts.SyntaxKind.SpreadAssignment:\n      case ts.SyntaxKind.PropertyAssignment:\n        node = node.parent.parent;\n        break;\n\n      case ts.SyntaxKind.SpreadElement:\n        if (node.parent.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression) return false;\n        node = node.parent.parent;\n        break;\n\n      default:\n        return false;\n    }\n  }\n}\n\nvar AccessKind;\n\n(function (AccessKind) {\n  AccessKind[AccessKind[\"None\"] = 0] = \"None\";\n  AccessKind[AccessKind[\"Read\"] = 1] = \"Read\";\n  AccessKind[AccessKind[\"Write\"] = 2] = \"Write\";\n  AccessKind[AccessKind[\"Delete\"] = 4] = \"Delete\";\n  AccessKind[AccessKind[\"ReadWrite\"] = 3] = \"ReadWrite\";\n  AccessKind[AccessKind[\"Modification\"] = 6] = \"Modification\";\n})(AccessKind = exports.AccessKind || (exports.AccessKind = {}));\n\nfunction getAccessKind(node) {\n  const parent = node.parent;\n\n  switch (parent.kind) {\n    case ts.SyntaxKind.DeleteExpression:\n      return 4;\n\n    case ts.SyntaxKind.PostfixUnaryExpression:\n      return 3;\n\n    case ts.SyntaxKind.PrefixUnaryExpression:\n      return parent.operator === ts.SyntaxKind.PlusPlusToken || parent.operator === ts.SyntaxKind.MinusMinusToken ? 3 : 1;\n\n    case ts.SyntaxKind.BinaryExpression:\n      return parent.right === node ? 1 : !isAssignmentKind(parent.operatorToken.kind) ? 1 : parent.operatorToken.kind === ts.SyntaxKind.EqualsToken ? 2 : 3;\n\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n      return parent.objectAssignmentInitializer === node ? 1 : isInDestructuringAssignment(parent) ? 2 : 1;\n\n    case ts.SyntaxKind.PropertyAssignment:\n      return parent.name === node ? 0 : isInDestructuringAssignment(parent) ? 2 : 1;\n\n    case ts.SyntaxKind.ArrayLiteralExpression:\n    case ts.SyntaxKind.SpreadElement:\n    case ts.SyntaxKind.SpreadAssignment:\n      return isInDestructuringAssignment(parent) ? 2 : 1;\n\n    case ts.SyntaxKind.ParenthesizedExpression:\n    case ts.SyntaxKind.NonNullExpression:\n    case ts.SyntaxKind.TypeAssertionExpression:\n    case ts.SyntaxKind.AsExpression:\n      return getAccessKind(parent);\n\n    case ts.SyntaxKind.ForOfStatement:\n    case ts.SyntaxKind.ForInStatement:\n      return parent.initializer === node ? 2 : 1;\n\n    case ts.SyntaxKind.ExpressionWithTypeArguments:\n      return parent.parent.token === ts.SyntaxKind.ExtendsKeyword && parent.parent.parent.kind !== ts.SyntaxKind.InterfaceDeclaration ? 1 : 0;\n\n    case ts.SyntaxKind.ComputedPropertyName:\n    case ts.SyntaxKind.ExpressionStatement:\n    case ts.SyntaxKind.TypeOfExpression:\n    case ts.SyntaxKind.ElementAccessExpression:\n    case ts.SyntaxKind.ForStatement:\n    case ts.SyntaxKind.IfStatement:\n    case ts.SyntaxKind.DoStatement:\n    case ts.SyntaxKind.WhileStatement:\n    case ts.SyntaxKind.SwitchStatement:\n    case ts.SyntaxKind.WithStatement:\n    case ts.SyntaxKind.ThrowStatement:\n    case ts.SyntaxKind.CallExpression:\n    case ts.SyntaxKind.NewExpression:\n    case ts.SyntaxKind.TaggedTemplateExpression:\n    case ts.SyntaxKind.JsxExpression:\n    case ts.SyntaxKind.Decorator:\n    case ts.SyntaxKind.TemplateSpan:\n    case ts.SyntaxKind.JsxOpeningElement:\n    case ts.SyntaxKind.JsxSelfClosingElement:\n    case ts.SyntaxKind.JsxSpreadAttribute:\n    case ts.SyntaxKind.VoidExpression:\n    case ts.SyntaxKind.ReturnStatement:\n    case ts.SyntaxKind.AwaitExpression:\n    case ts.SyntaxKind.YieldExpression:\n    case ts.SyntaxKind.ConditionalExpression:\n    case ts.SyntaxKind.CaseClause:\n    case ts.SyntaxKind.JsxElement:\n      return 1;\n\n    case ts.SyntaxKind.ArrowFunction:\n      return parent.body === node ? 1 : 2;\n\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.VariableDeclaration:\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.BindingElement:\n    case ts.SyntaxKind.JsxAttribute:\n      return parent.initializer === node ? 1 : 0;\n\n    case ts.SyntaxKind.PropertyAccessExpression:\n      return parent.expression === node ? 1 : 0;\n\n    case ts.SyntaxKind.ExportAssignment:\n      return parent.isExportEquals ? 1 : 0;\n  }\n\n  return 0;\n}\n\nexports.getAccessKind = getAccessKind;\n\nfunction isReassignmentTarget(node) {\n  return (getAccessKind(node) & 2) !== 0;\n}\n\nexports.isReassignmentTarget = isReassignmentTarget;\n\nfunction canHaveJsDoc(node) {\n  const kind = node.kind;\n\n  switch (kind) {\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.CallSignature:\n    case ts.SyntaxKind.ConstructSignature:\n    case ts.SyntaxKind.MethodSignature:\n    case ts.SyntaxKind.PropertySignature:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.ParenthesizedExpression:\n    case ts.SyntaxKind.SpreadAssignment:\n    case ts.SyntaxKind.ShorthandPropertyAssignment:\n    case ts.SyntaxKind.PropertyAssignment:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.LabeledStatement:\n    case ts.SyntaxKind.ExpressionStatement:\n    case ts.SyntaxKind.VariableStatement:\n    case ts.SyntaxKind.Constructor:\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.PropertyDeclaration:\n    case ts.SyntaxKind.GetAccessor:\n    case ts.SyntaxKind.SetAccessor:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.InterfaceDeclaration:\n    case ts.SyntaxKind.TypeAliasDeclaration:\n    case ts.SyntaxKind.EnumMember:\n    case ts.SyntaxKind.EnumDeclaration:\n    case ts.SyntaxKind.ModuleDeclaration:\n    case ts.SyntaxKind.ImportEqualsDeclaration:\n    case ts.SyntaxKind.IndexSignature:\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.ConstructorType:\n    case ts.SyntaxKind.JSDocFunctionType:\n    case ts.SyntaxKind.EndOfFileToken:\n    case ts.SyntaxKind.ExportDeclaration:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.canHaveJsDoc = canHaveJsDoc;\n\nfunction getJsDoc(node, sourceFile) {\n  if (node.kind === ts.SyntaxKind.EndOfFileToken) return parseJsDocWorker(node, sourceFile || node.parent);\n  const result = [];\n\n  for (const child of node.getChildren(sourceFile)) {\n    if (!node_1.isJsDoc(child)) break;\n    result.push(child);\n  }\n\n  return result;\n}\n\nexports.getJsDoc = getJsDoc;\n\nfunction parseJsDocOfNode(node, considerTrailingComments, sourceFile = node.getSourceFile()) {\n  if (canHaveJsDoc(node) && node.kind !== ts.SyntaxKind.EndOfFileToken) {\n    const result = getJsDoc(node, sourceFile);\n    if (result.length !== 0 || !considerTrailingComments) return result;\n  }\n\n  return parseJsDocWorker(node, sourceFile, considerTrailingComments);\n}\n\nexports.parseJsDocOfNode = parseJsDocOfNode;\n\nfunction parseJsDocWorker(node, sourceFile, considerTrailingComments) {\n  const nodeStart = node.getStart(sourceFile);\n  const start = ts[considerTrailingComments && isSameLine(sourceFile, node.pos, nodeStart) ? 'forEachTrailingCommentRange' : 'forEachLeadingCommentRange'](sourceFile.text, node.pos, (pos, _end, kind) => kind === ts.SyntaxKind.MultiLineCommentTrivia && sourceFile.text[pos + 2] === '*' ? {\n    pos\n  } : undefined);\n  if (start === undefined) return [];\n  const startPos = start.pos;\n  const text = sourceFile.text.slice(startPos, nodeStart);\n  const newSourceFile = ts.createSourceFile('jsdoc.ts', `${text}var a;`, sourceFile.languageVersion);\n  const result = getJsDoc(newSourceFile.statements[0], newSourceFile);\n\n  for (const doc of result) updateNode(doc, node);\n\n  return result;\n\n  function updateNode(n, parent) {\n    n.pos += startPos;\n    n.end += startPos;\n    n.parent = parent;\n    return ts.forEachChild(n, child => updateNode(child, n), children => {\n      children.pos += startPos;\n      children.end += startPos;\n\n      for (const child of children) updateNode(child, n);\n    });\n  }\n}\n\nvar ImportKind;\n\n(function (ImportKind) {\n  ImportKind[ImportKind[\"ImportDeclaration\"] = 1] = \"ImportDeclaration\";\n  ImportKind[ImportKind[\"ImportEquals\"] = 2] = \"ImportEquals\";\n  ImportKind[ImportKind[\"ExportFrom\"] = 4] = \"ExportFrom\";\n  ImportKind[ImportKind[\"DynamicImport\"] = 8] = \"DynamicImport\";\n  ImportKind[ImportKind[\"Require\"] = 16] = \"Require\";\n  ImportKind[ImportKind[\"ImportType\"] = 32] = \"ImportType\";\n  ImportKind[ImportKind[\"All\"] = 63] = \"All\";\n  ImportKind[ImportKind[\"AllImports\"] = 59] = \"AllImports\";\n  ImportKind[ImportKind[\"AllStaticImports\"] = 3] = \"AllStaticImports\";\n  ImportKind[ImportKind[\"AllImportExpressions\"] = 24] = \"AllImportExpressions\";\n  ImportKind[ImportKind[\"AllRequireLike\"] = 18] = \"AllRequireLike\";\n  ImportKind[ImportKind[\"AllNestedImports\"] = 56] = \"AllNestedImports\";\n  ImportKind[ImportKind[\"AllTopLevelImports\"] = 7] = \"AllTopLevelImports\";\n})(ImportKind = exports.ImportKind || (exports.ImportKind = {}));\n\nfunction findImports(sourceFile, kinds) {\n  const result = [];\n\n  for (const node of findImportLikeNodes(sourceFile, kinds)) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ImportDeclaration:\n        addIfTextualLiteral(node.moduleSpecifier);\n        break;\n\n      case ts.SyntaxKind.ImportEqualsDeclaration:\n        addIfTextualLiteral(node.moduleReference.expression);\n        break;\n\n      case ts.SyntaxKind.ExportDeclaration:\n        addIfTextualLiteral(node.moduleSpecifier);\n        break;\n\n      case ts.SyntaxKind.CallExpression:\n        addIfTextualLiteral(node.arguments[0]);\n        break;\n\n      case ts.SyntaxKind.ImportType:\n        if (node_1.isLiteralTypeNode(node.argument)) addIfTextualLiteral(node.argument.literal);\n        break;\n\n      default:\n        throw new Error('unexpected node');\n    }\n  }\n\n  return result;\n\n  function addIfTextualLiteral(node) {\n    if (node_1.isTextualLiteral(node)) result.push(node);\n  }\n}\n\nexports.findImports = findImports;\n\nfunction findImportLikeNodes(sourceFile, kinds) {\n  return new ImportFinder(sourceFile, kinds).find();\n}\n\nexports.findImportLikeNodes = findImportLikeNodes;\n\nclass ImportFinder {\n  constructor(_sourceFile, _options) {\n    this._sourceFile = _sourceFile;\n    this._options = _options;\n    this._result = [];\n  }\n\n  find() {\n    if (this._sourceFile.isDeclarationFile) this._options &= ~24;\n    if (this._options & 7) this._findImports(this._sourceFile.statements);\n    if (this._options & 56) this._findNestedImports();\n    return this._result;\n  }\n\n  _findImports(statements) {\n    for (const statement of statements) {\n      if (node_1.isImportDeclaration(statement)) {\n        if (this._options & 1) this._result.push(statement);\n      } else if (node_1.isImportEqualsDeclaration(statement)) {\n        if (this._options & 2 && statement.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) this._result.push(statement);\n      } else if (node_1.isExportDeclaration(statement)) {\n        if (statement.moduleSpecifier !== undefined && this._options & 4) this._result.push(statement);\n      } else if (node_1.isModuleDeclaration(statement)) {\n        this._findImportsInModule(statement);\n      }\n    }\n  }\n\n  _findImportsInModule(declaration) {\n    if (declaration.body === undefined) return;\n    if (declaration.body.kind === ts.SyntaxKind.ModuleDeclaration) return this._findImportsInModule(declaration.body);\n\n    this._findImports(declaration.body.statements);\n  }\n\n  _findNestedImports() {\n    let re;\n\n    if ((this._options & 56) === 16) {\n      re = /\\brequire\\s*[</(]/g;\n    } else if (this._options & 16) {\n      re = /\\b(?:import|require)\\s*[</(]/g;\n    } else {\n      re = /\\bimport\\s*[</(]/g;\n    }\n\n    const isJavaScriptFile = (this._sourceFile.flags & ts.NodeFlags.JavaScriptFile) !== 0;\n\n    for (let match = re.exec(this._sourceFile.text); match !== null; match = re.exec(this._sourceFile.text)) {\n      const token = getTokenAtPositionWorker(this._sourceFile, match.index, this._sourceFile, match[0][0] === 'i' && isJavaScriptFile);\n\n      if (token.kind === ts.SyntaxKind.ImportKeyword) {\n        if (token.end - 'import'.length !== match.index) continue;\n\n        switch (token.parent.kind) {\n          case ts.SyntaxKind.ImportType:\n            this._result.push(token.parent);\n\n            break;\n\n          case ts.SyntaxKind.CallExpression:\n            if (token.parent.arguments.length === 1) this._result.push(token.parent);\n        }\n      } else if (token.kind === ts.SyntaxKind.Identifier && token.end - 'require'.length === match.index && token.parent.kind === ts.SyntaxKind.CallExpression && token.parent.expression === token && token.parent.arguments.length === 1) {\n        this._result.push(token.parent);\n      }\n    }\n  }\n\n}\n\nfunction isStatementInAmbientContext(node) {\n  while (node.flags & ts.NodeFlags.NestedNamespace) node = node.parent;\n\n  return hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword) || isAmbientModuleBlock(node.parent);\n}\n\nexports.isStatementInAmbientContext = isStatementInAmbientContext;\n\nfunction isAmbientModuleBlock(node) {\n  while (node.kind === ts.SyntaxKind.ModuleBlock) {\n    do node = node.parent; while (node.flags & ts.NodeFlags.NestedNamespace);\n\n    if (hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword)) return true;\n    node = node.parent;\n  }\n\n  return false;\n}\n\nexports.isAmbientModuleBlock = isAmbientModuleBlock;\n\nfunction getIIFE(func) {\n  let node = func.parent;\n\n  while (node.kind === ts.SyntaxKind.ParenthesizedExpression) node = node.parent;\n\n  return node_1.isCallExpression(node) && func.end <= node.expression.end ? node : undefined;\n}\n\nexports.getIIFE = getIIFE;\n\nfunction isStrictCompilerOptionEnabled(options, option) {\n  return (options.strict ? options[option] !== false : options[option] === true) && (option !== 'strictPropertyInitialization' || isStrictCompilerOptionEnabled(options, 'strictNullChecks'));\n}\n\nexports.isStrictCompilerOptionEnabled = isStrictCompilerOptionEnabled;\n\nfunction isCompilerOptionEnabled(options, option) {\n  switch (option) {\n    case 'stripInternal':\n      return options.stripInternal === true && isCompilerOptionEnabled(options, 'declaration');\n\n    case 'declaration':\n      return options.declaration || isCompilerOptionEnabled(options, 'composite');\n\n    case 'incremental':\n      return options.incremental === undefined ? isCompilerOptionEnabled(options, 'composite') : options.incremental;\n\n    case 'skipDefaultLibCheck':\n      return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, 'skipLibCheck');\n\n    case 'suppressImplicitAnyIndexErrors':\n      return options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, 'noImplicitAny');\n\n    case 'allowSyntheticDefaultImports':\n      return options.allowSyntheticDefaultImports !== undefined ? options.allowSyntheticDefaultImports : isCompilerOptionEnabled(options, 'esModuleInterop') || options.module === ts.ModuleKind.System;\n\n    case 'noImplicitAny':\n    case 'noImplicitThis':\n    case 'strictNullChecks':\n    case 'strictFunctionTypes':\n    case 'strictPropertyInitialization':\n    case 'alwaysStrict':\n    case 'strictBindCallApply':\n      return isStrictCompilerOptionEnabled(options, option);\n  }\n\n  return options[option] === true;\n}\n\nexports.isCompilerOptionEnabled = isCompilerOptionEnabled;\n\nfunction isAmbientModule(node) {\n  return node.name.kind === ts.SyntaxKind.StringLiteral || (node.flags & ts.NodeFlags.GlobalAugmentation) !== 0;\n}\n\nexports.isAmbientModule = isAmbientModule;\n\nfunction getCheckJsDirective(source) {\n  let directive;\n  ts.forEachLeadingCommentRange(source, (ts.getShebang(source) || '').length, (pos, end, kind) => {\n    if (kind === ts.SyntaxKind.SingleLineCommentTrivia) {\n      const text = source.slice(pos, end);\n      const match = /^\\/{2,3}\\s*@ts-(no)?check(?:\\s|$)/i.exec(text);\n      if (match !== null) directive = {\n        pos,\n        end,\n        enabled: match[1] === undefined\n      };\n    }\n  });\n  return directive;\n}\n\nexports.getCheckJsDirective = getCheckJsDirective;\n\nfunction isConstAssertion(node) {\n  return node_1.isTypeReferenceNode(node.type) && node.type.typeName.kind === ts.SyntaxKind.Identifier && node.type.typeName.escapedText === 'const';\n}\n\nexports.isConstAssertion = isConstAssertion;\n\nfunction isInConstContext(node) {\n  let current = node;\n\n  while (true) {\n    const parent = current.parent;\n\n    outer: switch (parent.kind) {\n      case ts.SyntaxKind.TypeAssertionExpression:\n      case ts.SyntaxKind.AsExpression:\n        return isConstAssertion(parent);\n\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        if (current.kind !== ts.SyntaxKind.NumericLiteral) return false;\n\n        switch (parent.operator) {\n          case ts.SyntaxKind.PlusToken:\n          case ts.SyntaxKind.MinusToken:\n            current = parent;\n            break outer;\n\n          default:\n            return false;\n        }\n\n      case ts.SyntaxKind.PropertyAssignment:\n        if (parent.initializer !== current) return false;\n        current = parent.parent;\n        break;\n\n      case ts.SyntaxKind.ShorthandPropertyAssignment:\n        current = parent.parent;\n        break;\n\n      case ts.SyntaxKind.ParenthesizedExpression:\n      case ts.SyntaxKind.ArrayLiteralExpression:\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        current = parent;\n        break;\n\n      default:\n        return false;\n    }\n  }\n}\n\nexports.isInConstContext = isInConstContext;\n\nfunction isReadonlyAssignmentDeclaration(node, checker) {\n  if (!isBindableObjectDefinePropertyCall(node)) return false;\n  const descriptorType = checker.getTypeAtLocation(node.arguments[2]);\n  if (descriptorType.getProperty('value') === undefined) return descriptorType.getProperty('set') === undefined;\n  const writableProp = descriptorType.getProperty('writable');\n  if (writableProp === undefined) return false;\n  const writableType = writableProp.valueDeclaration !== undefined && node_1.isPropertyAssignment(writableProp.valueDeclaration) ? checker.getTypeAtLocation(writableProp.valueDeclaration.initializer) : checker.getTypeOfSymbolAtLocation(writableProp, node.arguments[2]);\n  return type_1.isBooleanLiteralType(writableType, false);\n}\n\nexports.isReadonlyAssignmentDeclaration = isReadonlyAssignmentDeclaration;\n\nfunction isBindableObjectDefinePropertyCall(node) {\n  return node.arguments.length === 3 && node_1.isEntityNameExpression(node.arguments[0]) && node_1.isNumericOrStringLikeLiteral(node.arguments[1]) && node_1.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === 'defineProperty' && node_1.isIdentifier(node.expression.expression) && node.expression.expression.escapedText === 'Object';\n}\n\nexports.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;\n\nfunction isWellKnownSymbolLiterally(node) {\n  return ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression) && node.expression.escapedText === 'Symbol';\n}\n\nexports.isWellKnownSymbolLiterally = isWellKnownSymbolLiterally;\n\nfunction getPropertyNameOfWellKnownSymbol(node) {\n  return {\n    displayName: `[Symbol.${node.name.text}]`,\n    symbolName: '__@' + node.name.text\n  };\n}\n\nexports.getPropertyNameOfWellKnownSymbol = getPropertyNameOfWellKnownSymbol;\n\nfunction getLateBoundPropertyNames(node, checker) {\n  const result = {\n    known: true,\n    names: []\n  };\n  node = unwrapParentheses(node);\n\n  if (isWellKnownSymbolLiterally(node)) {\n    result.names.push(getPropertyNameOfWellKnownSymbol(node));\n  } else {\n    const type = checker.getTypeAtLocation(node);\n\n    for (const key of type_1.unionTypeParts(checker.getBaseConstraintOfType(type) || type)) {\n      const propertyName = type_1.getPropertyNameFromType(key);\n\n      if (propertyName) {\n        result.names.push(propertyName);\n      } else {\n        result.known = false;\n      }\n    }\n  }\n\n  return result;\n}\n\nexports.getLateBoundPropertyNames = getLateBoundPropertyNames;\n\nfunction getLateBoundPropertyNamesOfPropertyName(node, checker) {\n  const staticName = getPropertyName(node);\n  return staticName !== undefined ? {\n    known: true,\n    names: [{\n      displayName: staticName,\n      symbolName: ts.escapeLeadingUnderscores(staticName)\n    }]\n  } : getLateBoundPropertyNames(node.expression, checker);\n}\n\nexports.getLateBoundPropertyNamesOfPropertyName = getLateBoundPropertyNamesOfPropertyName;\n\nfunction getSingleLateBoundPropertyNameOfPropertyName(node, checker) {\n  const staticName = getPropertyName(node);\n  if (staticName !== undefined) return {\n    displayName: staticName,\n    symbolName: ts.escapeLeadingUnderscores(staticName)\n  };\n  const {\n    expression\n  } = node;\n  return isWellKnownSymbolLiterally(expression) ? getPropertyNameOfWellKnownSymbol(expression) : type_1.getPropertyNameFromType(checker.getTypeAtLocation(expression));\n}\n\nexports.getSingleLateBoundPropertyNameOfPropertyName = getSingleLateBoundPropertyNameOfPropertyName;\n\nfunction unwrapParentheses(node) {\n  while (node.kind === ts.SyntaxKind.ParenthesizedExpression) node = node.expression;\n\n  return node;\n}\n\nexports.unwrapParentheses = unwrapParentheses;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/tsutils/util/util.js"],"names":["Object","defineProperty","exports","value","ts","require","node_1","_3_2_1","type_1","getChildOfKind","node","kind","sourceFile","child","getChildren","isTokenKind","SyntaxKind","FirstToken","LastToken","isNodeKind","FirstNode","isAssignmentKind","FirstAssignment","LastAssignment","isTypeNodeKind","FirstTypeNode","LastTypeNode","isJsDocKind","FirstJSDocNode","LastJSDocNode","isKeywordKind","FirstKeyword","LastKeyword","isThisParameter","parameter","name","Identifier","originalKeywordKind","ThisKeyword","getModifier","modifiers","undefined","modifier","hasModifier","kinds","includes","isParameterProperty","PublicKeyword","ProtectedKeyword","PrivateKeyword","ReadonlyKeyword","hasAccessModifier","isFlagSet","obj","flag","flags","isNodeFlagSet","isTypeFlagSet","isSymbolFlagSet","isObjectFlagSet","objectType","objectFlags","isModifierFlagSet","getCombinedModifierFlags","getPreviousStatement","statement","parent","isBlockLike","index","statements","indexOf","getNextStatement","length","getPreviousToken","pos","outer","children","i","JSDocComment","getNextToken","getSourceFile","SourceFile","EndOfFileToken","end","endOfFileToken","getTokenAtPositionWorker","getTokenAtPosition","allowJsDoc","getCommentAtPosition","token","JsxText","tokenToString","startPos","getShebang","text","forEachTrailingCommentRange","commentAtPositionCallback","forEachLeadingCommentRange","_nl","at","isPositionInComment","commentText","sourceText","comment","substring","SingleLineCommentTrivia","getWrappedNodeAtPosition","wrap","getPropertyName","propertyName","ComputedPropertyName","isLiteralExpression","expression","isBigIntLiteral","slice","forEachDestructuringIdentifier","pattern","fn","element","elements","BindingElement","result","forEachDeclaredVariable","declarationList","cb","declaration","declarations","VariableDeclarationKind","getVariableDeclarationKind","NodeFlags","Let","Const","isBlockScopedVariableDeclarationList","BlockScoped","isBlockScopedVariableDeclaration","CatchClause","isBlockScopedDeclarationStatement","VariableStatement","ClassDeclaration","EnumDeclaration","InterfaceDeclaration","TypeAliasDeclaration","isInSingleStatementContext","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoStatement","IfStatement","WithStatement","LabeledStatement","ScopeBoundary","ScopeBoundarySelector","isScopeBoundary","isFunctionScopeBoundary","isBlockScopeBoundary","isTypeScopeBoundary","MappedType","ConditionalType","FunctionExpression","ArrowFunction","Constructor","ModuleDeclaration","ClassExpression","MethodDeclaration","FunctionDeclaration","GetAccessor","SetAccessor","MethodSignature","CallSignature","ConstructSignature","ConstructorType","FunctionType","isExternalModule","Block","CaseBlock","hasOwnThisReference","body","ObjectLiteralExpression","isFunctionWithBody","forEachToken","iterate","forEach","forEachTokenWithTrivia","fullText","scanner","createScanner","languageVersion","languageVariant","tokenStart","getStart","setTextPos","scan","getTokenPos","textPos","getTextPos","forEachComment","notJsx","LanguageVariant","JSX","commentCallback","canHaveTrailingTrivia","CloseBraceToken","JsxExpression","isJsxElementOrFragment","GreaterThanToken","JsxOpeningElement","JsxOpeningFragment","JsxSelfClosingElement","JsxClosingElement","JsxClosingFragment","JsxElement","JsxFragment","getLineRanges","lineStarts","getLineStarts","lineEnd","isLineBreak","charCodeAt","push","contentLength","getLineBreakStyle","cachedScanner","scanToken","setScriptTarget","setText","isValidIdentifier","ScriptTarget","Latest","isIdentifier","charSize","ch","isValidPropertyAccess","codePointAt","isIdentifierStart","isIdentifierPart","isValidPropertyName","getToken","NumericLiteral","getTokenValue","isValidNumericLiteral","isValidJsxIdentifier","isNumericPropertyName","String","isSameLine","pos1","pos2","getLineAndCharacterOfPosition","line","SideEffectOptions","hasSideEffects","options","CallExpression","PostfixUnaryExpression","AwaitExpression","YieldExpression","DeleteExpression","TypeAssertionExpression","AsExpression","ParenthesizedExpression","NonNullExpression","VoidExpression","TypeOfExpression","PropertyAccessExpression","SpreadElement","PartiallyEmittedExpression","BinaryExpression","operatorToken","left","right","PrefixUnaryExpression","operator","PlusPlusToken","MinusMinusToken","operand","ElementAccessExpression","argumentExpression","ConditionalExpression","condition","whenTrue","whenFalse","NewExpression","arguments","TaggedTemplateExpression","tag","template","NoSubstitutionTemplateLiteral","TemplateExpression","templateSpans","classExpressionHasSideEffects","ArrayLiteralExpression","properties","PropertyAssignment","initializer","SpreadAssignment","openingElement","attributes","JsxSpreadAttribute","CommaListExpression","heritageClauses","ExtendsKeyword","base","types","members","isPropertyDeclaration","getDeclarationOfBindingElement","isExpressionValueUsed","ThrowStatement","ReturnStatement","ExportSpecifier","ExportAssignment","ImportDeclaration","ExternalModuleReference","Decorator","TemplateSpan","ExpressionWithTypeArguments","LiteralType","JsxAttributes","CaseClause","SwitchStatement","QualifiedName","ShorthandPropertyAssignment","objectAssignmentInitializer","isInDestructuringAssignment","PropertyDeclaration","VariableDeclaration","Parameter","EnumMember","ImportEqualsDeclaration","moduleReference","CommaToken","EqualsToken","EqualsEqualsEqualsToken","EqualsEqualsToken","ExclamationEqualsEqualsToken","ExclamationEqualsToken","InstanceOfKeyword","PlusToken","MinusToken","AsteriskToken","SlashToken","PercentToken","AsteriskAsteriskToken","GreaterThanGreaterThanToken","GreaterThanGreaterThanGreaterThanToken","GreaterThanEqualsToken","LessThanToken","LessThanLessThanToken","LessThanEqualsToken","AmpersandToken","BarToken","CaretToken","BarBarToken","AmpersandAmpersandToken","InKeyword","AccessKind","getAccessKind","ExpressionStatement","JsxAttribute","isExportEquals","isReassignmentTarget","canHaveJsDoc","PropertySignature","IndexSignature","JSDocFunctionType","ExportDeclaration","getJsDoc","parseJsDocWorker","isJsDoc","parseJsDocOfNode","considerTrailingComments","nodeStart","start","_end","MultiLineCommentTrivia","newSourceFile","createSourceFile","doc","updateNode","n","forEachChild","ImportKind","findImports","findImportLikeNodes","addIfTextualLiteral","moduleSpecifier","ImportType","isLiteralTypeNode","argument","literal","Error","isTextualLiteral","ImportFinder","find","constructor","_sourceFile","_options","_result","isDeclarationFile","_findImports","_findNestedImports","isImportDeclaration","isImportEqualsDeclaration","isExportDeclaration","isModuleDeclaration","_findImportsInModule","re","isJavaScriptFile","JavaScriptFile","match","exec","ImportKeyword","isStatementInAmbientContext","NestedNamespace","DeclareKeyword","isAmbientModuleBlock","ModuleBlock","getIIFE","func","isCallExpression","isStrictCompilerOptionEnabled","option","strict","isCompilerOptionEnabled","stripInternal","incremental","skipDefaultLibCheck","suppressImplicitAnyIndexErrors","allowSyntheticDefaultImports","module","ModuleKind","System","isAmbientModule","StringLiteral","GlobalAugmentation","getCheckJsDirective","source","directive","enabled","isConstAssertion","isTypeReferenceNode","type","typeName","escapedText","isInConstContext","current","isReadonlyAssignmentDeclaration","checker","isBindableObjectDefinePropertyCall","descriptorType","getTypeAtLocation","getProperty","writableProp","writableType","valueDeclaration","isPropertyAssignment","getTypeOfSymbolAtLocation","isBooleanLiteralType","isEntityNameExpression","isNumericOrStringLikeLiteral","isPropertyAccessExpression","isWellKnownSymbolLiterally","getPropertyNameOfWellKnownSymbol","displayName","symbolName","getLateBoundPropertyNames","known","names","unwrapParentheses","key","unionTypeParts","getBaseConstraintOfType","getPropertyNameFromType","getLateBoundPropertyNamesOfPropertyName","staticName","escapeLeadingUnderscores","getSingleLateBoundPropertyNameOfPropertyName"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ts = require(\"typescript\");\nconst node_1 = require(\"../typeguard/node\");\nconst _3_2_1 = require(\"../typeguard/3.2\");\nconst type_1 = require(\"./type\");\nfunction getChildOfKind(node, kind, sourceFile) {\n    for (const child of node.getChildren(sourceFile))\n        if (child.kind === kind)\n            return child;\n}\nexports.getChildOfKind = getChildOfKind;\nfunction isTokenKind(kind) {\n    return kind >= ts.SyntaxKind.FirstToken && kind <= ts.SyntaxKind.LastToken;\n}\nexports.isTokenKind = isTokenKind;\nfunction isNodeKind(kind) {\n    return kind >= ts.SyntaxKind.FirstNode;\n}\nexports.isNodeKind = isNodeKind;\nfunction isAssignmentKind(kind) {\n    return kind >= ts.SyntaxKind.FirstAssignment && kind <= ts.SyntaxKind.LastAssignment;\n}\nexports.isAssignmentKind = isAssignmentKind;\nfunction isTypeNodeKind(kind) {\n    return kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode;\n}\nexports.isTypeNodeKind = isTypeNodeKind;\nfunction isJsDocKind(kind) {\n    return kind >= ts.SyntaxKind.FirstJSDocNode && kind <= ts.SyntaxKind.LastJSDocNode;\n}\nexports.isJsDocKind = isJsDocKind;\nfunction isKeywordKind(kind) {\n    return kind >= ts.SyntaxKind.FirstKeyword && kind <= ts.SyntaxKind.LastKeyword;\n}\nexports.isKeywordKind = isKeywordKind;\nfunction isThisParameter(parameter) {\n    return parameter.name.kind === ts.SyntaxKind.Identifier && parameter.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword;\n}\nexports.isThisParameter = isThisParameter;\nfunction getModifier(node, kind) {\n    if (node.modifiers !== undefined)\n        for (const modifier of node.modifiers)\n            if (modifier.kind === kind)\n                return modifier;\n}\nexports.getModifier = getModifier;\nfunction hasModifier(modifiers, ...kinds) {\n    if (modifiers === undefined)\n        return false;\n    for (const modifier of modifiers)\n        if (kinds.includes(modifier.kind))\n            return true;\n    return false;\n}\nexports.hasModifier = hasModifier;\nfunction isParameterProperty(node) {\n    return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword, ts.SyntaxKind.ReadonlyKeyword);\n}\nexports.isParameterProperty = isParameterProperty;\nfunction hasAccessModifier(node) {\n    return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword);\n}\nexports.hasAccessModifier = hasAccessModifier;\nfunction isFlagSet(obj, flag) {\n    return (obj.flags & flag) !== 0;\n}\nexports.isNodeFlagSet = isFlagSet;\nexports.isTypeFlagSet = isFlagSet;\nexports.isSymbolFlagSet = isFlagSet;\nfunction isObjectFlagSet(objectType, flag) {\n    return (objectType.objectFlags & flag) !== 0;\n}\nexports.isObjectFlagSet = isObjectFlagSet;\nfunction isModifierFlagSet(node, flag) {\n    return (ts.getCombinedModifierFlags(node) & flag) !== 0;\n}\nexports.isModifierFlagSet = isModifierFlagSet;\nfunction getPreviousStatement(statement) {\n    const parent = statement.parent;\n    if (node_1.isBlockLike(parent)) {\n        const index = parent.statements.indexOf(statement);\n        if (index > 0)\n            return parent.statements[index - 1];\n    }\n}\nexports.getPreviousStatement = getPreviousStatement;\nfunction getNextStatement(statement) {\n    const parent = statement.parent;\n    if (node_1.isBlockLike(parent)) {\n        const index = parent.statements.indexOf(statement);\n        if (index < parent.statements.length)\n            return parent.statements[index + 1];\n    }\n}\nexports.getNextStatement = getNextStatement;\nfunction getPreviousToken(node, sourceFile) {\n    let parent = node.parent;\n    while (parent !== undefined && parent.pos === node.pos)\n        parent = parent.parent;\n    if (parent === undefined)\n        return;\n    outer: while (true) {\n        const children = parent.getChildren(sourceFile);\n        for (let i = children.length - 1; i >= 0; --i) {\n            const child = children[i];\n            if (child.pos < node.pos && child.kind !== ts.SyntaxKind.JSDocComment) {\n                if (isTokenKind(child.kind))\n                    return child;\n                parent = child;\n                continue outer;\n            }\n        }\n        return;\n    }\n}\nexports.getPreviousToken = getPreviousToken;\nfunction getNextToken(node, sourceFile = node.getSourceFile()) {\n    if (node.kind === ts.SyntaxKind.SourceFile || node.kind === ts.SyntaxKind.EndOfFileToken)\n        return;\n    const end = node.end;\n    node = node.parent;\n    while (node.end === end) {\n        if (node.parent === undefined)\n            return node.endOfFileToken;\n        node = node.parent;\n    }\n    return getTokenAtPositionWorker(node, end, sourceFile, false);\n}\nexports.getNextToken = getNextToken;\nfunction getTokenAtPosition(parent, pos, sourceFile, allowJsDoc) {\n    if (pos < parent.pos || pos >= parent.end)\n        return;\n    if (isTokenKind(parent.kind))\n        return parent;\n    if (sourceFile === undefined)\n        sourceFile = parent.getSourceFile();\n    return getTokenAtPositionWorker(parent, pos, sourceFile, allowJsDoc === true);\n}\nexports.getTokenAtPosition = getTokenAtPosition;\nfunction getTokenAtPositionWorker(node, pos, sourceFile, allowJsDoc) {\n    outer: while (true) {\n        for (const child of node.getChildren(sourceFile)) {\n            if (child.end > pos && (allowJsDoc || child.kind !== ts.SyntaxKind.JSDocComment)) {\n                if (isTokenKind(child.kind))\n                    return child;\n                node = child;\n                continue outer;\n            }\n        }\n        return;\n    }\n}\nfunction getCommentAtPosition(sourceFile, pos, parent = sourceFile) {\n    const token = getTokenAtPosition(parent, pos, sourceFile);\n    if (token === undefined || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || '').length)\n        return;\n    const startPos = token.pos === 0\n        ? (ts.getShebang(sourceFile.text) || '').length\n        : token.pos;\n    return startPos !== 0 && ts.forEachTrailingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos) ||\n        ts.forEachLeadingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos);\n}\nexports.getCommentAtPosition = getCommentAtPosition;\nfunction commentAtPositionCallback(pos, end, kind, _nl, at) {\n    return at >= pos && at < end ? { pos, end, kind } : undefined;\n}\nfunction isPositionInComment(sourceFile, pos, parent) {\n    return getCommentAtPosition(sourceFile, pos, parent) !== undefined;\n}\nexports.isPositionInComment = isPositionInComment;\nfunction commentText(sourceText, comment) {\n    return sourceText.substring(comment.pos + 2, comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? comment.end : comment.end - 2);\n}\nexports.commentText = commentText;\nfunction getWrappedNodeAtPosition(wrap, pos) {\n    if (wrap.node.pos > pos || wrap.node.end <= pos)\n        return;\n    outer: while (true) {\n        for (const child of wrap.children) {\n            if (child.node.pos > pos)\n                return wrap;\n            if (child.node.end > pos) {\n                wrap = child;\n                continue outer;\n            }\n        }\n        return wrap;\n    }\n}\nexports.getWrappedNodeAtPosition = getWrappedNodeAtPosition;\nfunction getPropertyName(propertyName) {\n    if (propertyName.kind === ts.SyntaxKind.ComputedPropertyName) {\n        if (!node_1.isLiteralExpression(propertyName.expression))\n            return;\n        if (_3_2_1.isBigIntLiteral(propertyName.expression))\n            return propertyName.expression.text.slice(0, -1);\n        return propertyName.expression.text;\n    }\n    return propertyName.text;\n}\nexports.getPropertyName = getPropertyName;\nfunction forEachDestructuringIdentifier(pattern, fn) {\n    for (const element of pattern.elements) {\n        if (element.kind !== ts.SyntaxKind.BindingElement)\n            continue;\n        let result;\n        if (element.name.kind === ts.SyntaxKind.Identifier) {\n            result = fn(element);\n        }\n        else {\n            result = forEachDestructuringIdentifier(element.name, fn);\n        }\n        if (result)\n            return result;\n    }\n}\nexports.forEachDestructuringIdentifier = forEachDestructuringIdentifier;\nfunction forEachDeclaredVariable(declarationList, cb) {\n    for (const declaration of declarationList.declarations) {\n        let result;\n        if (declaration.name.kind === ts.SyntaxKind.Identifier) {\n            result = cb(declaration);\n        }\n        else {\n            result = forEachDestructuringIdentifier(declaration.name, cb);\n        }\n        if (result)\n            return result;\n    }\n}\nexports.forEachDeclaredVariable = forEachDeclaredVariable;\nvar VariableDeclarationKind;\n(function (VariableDeclarationKind) {\n    VariableDeclarationKind[VariableDeclarationKind[\"Var\"] = 0] = \"Var\";\n    VariableDeclarationKind[VariableDeclarationKind[\"Let\"] = 1] = \"Let\";\n    VariableDeclarationKind[VariableDeclarationKind[\"Const\"] = 2] = \"Const\";\n})(VariableDeclarationKind = exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));\nfunction getVariableDeclarationKind(declarationList) {\n    if (declarationList.flags & ts.NodeFlags.Let)\n        return 1;\n    if (declarationList.flags & ts.NodeFlags.Const)\n        return 2;\n    return 0;\n}\nexports.getVariableDeclarationKind = getVariableDeclarationKind;\nfunction isBlockScopedVariableDeclarationList(declarationList) {\n    return (declarationList.flags & ts.NodeFlags.BlockScoped) !== 0;\n}\nexports.isBlockScopedVariableDeclarationList = isBlockScopedVariableDeclarationList;\nfunction isBlockScopedVariableDeclaration(declaration) {\n    const parent = declaration.parent;\n    return parent.kind === ts.SyntaxKind.CatchClause ||\n        isBlockScopedVariableDeclarationList(parent);\n}\nexports.isBlockScopedVariableDeclaration = isBlockScopedVariableDeclaration;\nfunction isBlockScopedDeclarationStatement(statement) {\n    switch (statement.kind) {\n        case ts.SyntaxKind.VariableStatement:\n            return isBlockScopedVariableDeclarationList(statement.declarationList);\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.EnumDeclaration:\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isBlockScopedDeclarationStatement = isBlockScopedDeclarationStatement;\nfunction isInSingleStatementContext(statement) {\n    switch (statement.parent.kind) {\n        case ts.SyntaxKind.ForStatement:\n        case ts.SyntaxKind.ForInStatement:\n        case ts.SyntaxKind.ForOfStatement:\n        case ts.SyntaxKind.WhileStatement:\n        case ts.SyntaxKind.DoStatement:\n        case ts.SyntaxKind.IfStatement:\n        case ts.SyntaxKind.WithStatement:\n        case ts.SyntaxKind.LabeledStatement:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isInSingleStatementContext = isInSingleStatementContext;\nvar ScopeBoundary;\n(function (ScopeBoundary) {\n    ScopeBoundary[ScopeBoundary[\"None\"] = 0] = \"None\";\n    ScopeBoundary[ScopeBoundary[\"Function\"] = 1] = \"Function\";\n    ScopeBoundary[ScopeBoundary[\"Block\"] = 2] = \"Block\";\n    ScopeBoundary[ScopeBoundary[\"Type\"] = 4] = \"Type\";\n    ScopeBoundary[ScopeBoundary[\"ConditionalType\"] = 8] = \"ConditionalType\";\n})(ScopeBoundary = exports.ScopeBoundary || (exports.ScopeBoundary = {}));\nvar ScopeBoundarySelector;\n(function (ScopeBoundarySelector) {\n    ScopeBoundarySelector[ScopeBoundarySelector[\"Function\"] = 1] = \"Function\";\n    ScopeBoundarySelector[ScopeBoundarySelector[\"Block\"] = 3] = \"Block\";\n    ScopeBoundarySelector[ScopeBoundarySelector[\"Type\"] = 7] = \"Type\";\n    ScopeBoundarySelector[ScopeBoundarySelector[\"InferType\"] = 8] = \"InferType\";\n})(ScopeBoundarySelector = exports.ScopeBoundarySelector || (exports.ScopeBoundarySelector = {}));\nfunction isScopeBoundary(node) {\n    return isFunctionScopeBoundary(node) || isBlockScopeBoundary(node) || isTypeScopeBoundary(node);\n}\nexports.isScopeBoundary = isScopeBoundary;\nfunction isTypeScopeBoundary(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n        case ts.SyntaxKind.MappedType:\n            return 4;\n        case ts.SyntaxKind.ConditionalType:\n            return 8;\n        default:\n            return 0;\n    }\n}\nexports.isTypeScopeBoundary = isTypeScopeBoundary;\nfunction isFunctionScopeBoundary(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.ModuleDeclaration:\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.ClassExpression:\n        case ts.SyntaxKind.EnumDeclaration:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n        case ts.SyntaxKind.MethodSignature:\n        case ts.SyntaxKind.CallSignature:\n        case ts.SyntaxKind.ConstructSignature:\n        case ts.SyntaxKind.ConstructorType:\n        case ts.SyntaxKind.FunctionType:\n            return 1;\n        case ts.SyntaxKind.SourceFile:\n            return ts.isExternalModule(node) ? 1 : 0;\n        default:\n            return 0;\n    }\n}\nexports.isFunctionScopeBoundary = isFunctionScopeBoundary;\nfunction isBlockScopeBoundary(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.Block:\n            const parent = node.parent;\n            return parent.kind !== ts.SyntaxKind.CatchClause &&\n                (parent.kind === ts.SyntaxKind.SourceFile ||\n                    !isFunctionScopeBoundary(parent))\n                ? 2\n                : 0;\n        case ts.SyntaxKind.ForStatement:\n        case ts.SyntaxKind.ForInStatement:\n        case ts.SyntaxKind.ForOfStatement:\n        case ts.SyntaxKind.CaseBlock:\n        case ts.SyntaxKind.CatchClause:\n        case ts.SyntaxKind.WithStatement:\n            return 2;\n        default:\n            return 0;\n    }\n}\nexports.isBlockScopeBoundary = isBlockScopeBoundary;\nfunction hasOwnThisReference(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.ClassExpression:\n        case ts.SyntaxKind.FunctionExpression:\n            return true;\n        case ts.SyntaxKind.FunctionDeclaration:\n            return node.body !== undefined;\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n            return node.parent.kind === ts.SyntaxKind.ObjectLiteralExpression;\n        default:\n            return false;\n    }\n}\nexports.hasOwnThisReference = hasOwnThisReference;\nfunction isFunctionWithBody(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.Constructor:\n            return node.body !== undefined;\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.ArrowFunction:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isFunctionWithBody = isFunctionWithBody;\nfunction forEachToken(node, cb, sourceFile = node.getSourceFile()) {\n    return (function iterate(child) {\n        if (isTokenKind(child.kind))\n            return cb(child);\n        if (child.kind !== ts.SyntaxKind.JSDocComment)\n            return child.getChildren(sourceFile).forEach(iterate);\n    })(node);\n}\nexports.forEachToken = forEachToken;\nfunction forEachTokenWithTrivia(node, cb, sourceFile = node.getSourceFile()) {\n    const fullText = sourceFile.text;\n    const scanner = ts.createScanner(sourceFile.languageVersion, false, sourceFile.languageVariant, fullText);\n    return forEachToken(node, (token) => {\n        const tokenStart = token.kind === ts.SyntaxKind.JsxText || token.pos === token.end ? token.pos : token.getStart(sourceFile);\n        if (tokenStart !== token.pos) {\n            scanner.setTextPos(token.pos);\n            let kind = scanner.scan();\n            let pos = scanner.getTokenPos();\n            while (pos < tokenStart) {\n                const textPos = scanner.getTextPos();\n                cb(fullText, kind, { pos, end: textPos }, token.parent);\n                if (textPos === tokenStart)\n                    break;\n                kind = scanner.scan();\n                pos = scanner.getTokenPos();\n            }\n        }\n        return cb(fullText, token.kind, { end: token.end, pos: tokenStart }, token.parent);\n    }, sourceFile);\n}\nexports.forEachTokenWithTrivia = forEachTokenWithTrivia;\nfunction forEachComment(node, cb, sourceFile = node.getSourceFile()) {\n    const fullText = sourceFile.text;\n    const notJsx = sourceFile.languageVariant !== ts.LanguageVariant.JSX;\n    return forEachToken(node, (token) => {\n        if (token.pos === token.end)\n            return;\n        if (token.kind !== ts.SyntaxKind.JsxText)\n            ts.forEachLeadingCommentRange(fullText, token.pos === 0 ? (ts.getShebang(fullText) || '').length : token.pos, commentCallback);\n        if (notJsx || canHaveTrailingTrivia(token))\n            return ts.forEachTrailingCommentRange(fullText, token.end, commentCallback);\n    }, sourceFile);\n    function commentCallback(pos, end, kind) {\n        cb(fullText, { pos, end, kind });\n    }\n}\nexports.forEachComment = forEachComment;\nfunction canHaveTrailingTrivia(token) {\n    switch (token.kind) {\n        case ts.SyntaxKind.CloseBraceToken:\n            return token.parent.kind !== ts.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);\n        case ts.SyntaxKind.GreaterThanToken:\n            switch (token.parent.kind) {\n                case ts.SyntaxKind.JsxOpeningElement:\n                    return token.end !== token.parent.end;\n                case ts.SyntaxKind.JsxOpeningFragment:\n                    return false;\n                case ts.SyntaxKind.JsxSelfClosingElement:\n                    return token.end !== token.parent.end ||\n                        !isJsxElementOrFragment(token.parent.parent);\n                case ts.SyntaxKind.JsxClosingElement:\n                case ts.SyntaxKind.JsxClosingFragment:\n                    return !isJsxElementOrFragment(token.parent.parent.parent);\n            }\n    }\n    return true;\n}\nfunction isJsxElementOrFragment(node) {\n    return node.kind === ts.SyntaxKind.JsxElement || node.kind === ts.SyntaxKind.JsxFragment;\n}\nfunction getLineRanges(sourceFile) {\n    const lineStarts = sourceFile.getLineStarts();\n    const result = [];\n    const length = lineStarts.length;\n    const sourceText = sourceFile.text;\n    let pos = 0;\n    for (let i = 1; i < length; ++i) {\n        const end = lineStarts[i];\n        let lineEnd = end;\n        for (; lineEnd > pos; --lineEnd)\n            if (!ts.isLineBreak(sourceText.charCodeAt(lineEnd - 1)))\n                break;\n        result.push({\n            pos,\n            end,\n            contentLength: lineEnd - pos,\n        });\n        pos = end;\n    }\n    result.push({\n        pos,\n        end: sourceFile.end,\n        contentLength: sourceFile.end - pos,\n    });\n    return result;\n}\nexports.getLineRanges = getLineRanges;\nfunction getLineBreakStyle(sourceFile) {\n    const lineStarts = sourceFile.getLineStarts();\n    return lineStarts.length === 1 || lineStarts[1] < 2 || sourceFile.text[lineStarts[1] - 2] !== '\\r'\n        ? '\\n'\n        : '\\r\\n';\n}\nexports.getLineBreakStyle = getLineBreakStyle;\nlet cachedScanner;\nfunction scanToken(text, languageVersion) {\n    if (cachedScanner === undefined) {\n        cachedScanner = ts.createScanner(languageVersion, false, undefined, text);\n    }\n    else {\n        cachedScanner.setScriptTarget(languageVersion);\n        cachedScanner.setText(text);\n    }\n    cachedScanner.scan();\n    return cachedScanner;\n}\nfunction isValidIdentifier(text, languageVersion = ts.ScriptTarget.Latest) {\n    const scan = scanToken(text, languageVersion);\n    return scan.isIdentifier() && scan.getTextPos() === text.length && scan.getTokenPos() === 0;\n}\nexports.isValidIdentifier = isValidIdentifier;\nfunction charSize(ch) {\n    return ch >= 0x10000 ? 2 : 1;\n}\nfunction isValidPropertyAccess(text, languageVersion = ts.ScriptTarget.Latest) {\n    if (text.length === 0)\n        return false;\n    let ch = text.codePointAt(0);\n    if (!ts.isIdentifierStart(ch, languageVersion))\n        return false;\n    for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n        ch = text.codePointAt(i);\n        if (!ts.isIdentifierPart(ch, languageVersion))\n            return false;\n    }\n    return true;\n}\nexports.isValidPropertyAccess = isValidPropertyAccess;\nfunction isValidPropertyName(text, languageVersion = ts.ScriptTarget.Latest) {\n    if (isValidPropertyAccess(text, languageVersion))\n        return true;\n    const scan = scanToken(text, languageVersion);\n    return scan.getTextPos() === text.length &&\n        scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTokenValue() === text;\n}\nexports.isValidPropertyName = isValidPropertyName;\nfunction isValidNumericLiteral(text, languageVersion = ts.ScriptTarget.Latest) {\n    const scan = scanToken(text, languageVersion);\n    return scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTextPos() === text.length && scan.getTokenPos() === 0;\n}\nexports.isValidNumericLiteral = isValidNumericLiteral;\nfunction isValidJsxIdentifier(text, languageVersion = ts.ScriptTarget.Latest) {\n    if (text.length === 0)\n        return false;\n    let ch = text.codePointAt(0);\n    if (!ts.isIdentifierStart(ch, languageVersion))\n        return false;\n    for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n        ch = text.codePointAt(i);\n        if (!ts.isIdentifierPart(ch, languageVersion) && ch !== 45)\n            return false;\n    }\n    return true;\n}\nexports.isValidJsxIdentifier = isValidJsxIdentifier;\nfunction isNumericPropertyName(name) {\n    return String(+name) === name;\n}\nexports.isNumericPropertyName = isNumericPropertyName;\nfunction isSameLine(sourceFile, pos1, pos2) {\n    return ts.getLineAndCharacterOfPosition(sourceFile, pos1).line === ts.getLineAndCharacterOfPosition(sourceFile, pos2).line;\n}\nexports.isSameLine = isSameLine;\nvar SideEffectOptions;\n(function (SideEffectOptions) {\n    SideEffectOptions[SideEffectOptions[\"None\"] = 0] = \"None\";\n    SideEffectOptions[SideEffectOptions[\"TaggedTemplate\"] = 1] = \"TaggedTemplate\";\n    SideEffectOptions[SideEffectOptions[\"Constructor\"] = 2] = \"Constructor\";\n    SideEffectOptions[SideEffectOptions[\"JsxElement\"] = 4] = \"JsxElement\";\n})(SideEffectOptions = exports.SideEffectOptions || (exports.SideEffectOptions = {}));\nfunction hasSideEffects(node, options) {\n    switch (node.kind) {\n        case ts.SyntaxKind.CallExpression:\n        case ts.SyntaxKind.PostfixUnaryExpression:\n        case ts.SyntaxKind.AwaitExpression:\n        case ts.SyntaxKind.YieldExpression:\n        case ts.SyntaxKind.DeleteExpression:\n            return true;\n        case ts.SyntaxKind.TypeAssertionExpression:\n        case ts.SyntaxKind.AsExpression:\n        case ts.SyntaxKind.ParenthesizedExpression:\n        case ts.SyntaxKind.NonNullExpression:\n        case ts.SyntaxKind.VoidExpression:\n        case ts.SyntaxKind.TypeOfExpression:\n        case ts.SyntaxKind.PropertyAccessExpression:\n        case ts.SyntaxKind.SpreadElement:\n        case ts.SyntaxKind.PartiallyEmittedExpression:\n            return hasSideEffects(node.expression, options);\n        case ts.SyntaxKind.BinaryExpression:\n            return isAssignmentKind(node.operatorToken.kind) ||\n                hasSideEffects(node.left, options) ||\n                hasSideEffects(node.right, options);\n        case ts.SyntaxKind.PrefixUnaryExpression:\n            switch (node.operator) {\n                case ts.SyntaxKind.PlusPlusToken:\n                case ts.SyntaxKind.MinusMinusToken:\n                    return true;\n                default:\n                    return hasSideEffects(node.operand, options);\n            }\n        case ts.SyntaxKind.ElementAccessExpression:\n            return hasSideEffects(node.expression, options) ||\n                node.argumentExpression !== undefined &&\n                    hasSideEffects(node.argumentExpression, options);\n        case ts.SyntaxKind.ConditionalExpression:\n            return hasSideEffects(node.condition, options) ||\n                hasSideEffects(node.whenTrue, options) ||\n                hasSideEffects(node.whenFalse, options);\n        case ts.SyntaxKind.NewExpression:\n            if (options & 2 || hasSideEffects(node.expression, options))\n                return true;\n            if (node.arguments !== undefined)\n                for (const child of node.arguments)\n                    if (hasSideEffects(child, options))\n                        return true;\n            return false;\n        case ts.SyntaxKind.TaggedTemplateExpression:\n            if (options & 1 || hasSideEffects(node.tag, options))\n                return true;\n            if (node.template.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral)\n                return false;\n            node = node.template;\n        case ts.SyntaxKind.TemplateExpression:\n            for (const child of node.templateSpans)\n                if (hasSideEffects(child.expression, options))\n                    return true;\n            return false;\n        case ts.SyntaxKind.ClassExpression:\n            return classExpressionHasSideEffects(node, options);\n        case ts.SyntaxKind.ArrayLiteralExpression:\n            for (const child of node.elements)\n                if (hasSideEffects(child, options))\n                    return true;\n            return false;\n        case ts.SyntaxKind.ObjectLiteralExpression:\n            for (const child of node.properties) {\n                if (child.name !== undefined && child.name.kind === ts.SyntaxKind.ComputedPropertyName &&\n                    hasSideEffects(child.name.expression, options))\n                    return true;\n                switch (child.kind) {\n                    case ts.SyntaxKind.PropertyAssignment:\n                        if (hasSideEffects(child.initializer, options))\n                            return true;\n                        break;\n                    case ts.SyntaxKind.SpreadAssignment:\n                        if (hasSideEffects(child.expression, options))\n                            return true;\n                }\n            }\n            return false;\n        case ts.SyntaxKind.JsxExpression:\n            return node.expression !== undefined && hasSideEffects(node.expression, options);\n        case ts.SyntaxKind.JsxElement:\n        case ts.SyntaxKind.JsxFragment:\n            for (const child of node.children)\n                if (child.kind !== ts.SyntaxKind.JsxText && hasSideEffects(child, options))\n                    return true;\n            if (node.kind === ts.SyntaxKind.JsxFragment)\n                return false;\n            node = node.openingElement;\n        case ts.SyntaxKind.JsxSelfClosingElement:\n        case ts.SyntaxKind.JsxOpeningElement:\n            if (options & 4)\n                return true;\n            for (const child of node.attributes.properties) {\n                if (child.kind === ts.SyntaxKind.JsxSpreadAttribute) {\n                    if (hasSideEffects(child.expression, options))\n                        return true;\n                }\n                else if (child.initializer !== undefined && hasSideEffects(child.initializer, options)) {\n                    return true;\n                }\n            }\n            return false;\n        case ts.SyntaxKind.CommaListExpression:\n            for (const child of node.elements)\n                if (hasSideEffects(child, options))\n                    return true;\n            return false;\n        default:\n            return false;\n    }\n}\nexports.hasSideEffects = hasSideEffects;\nfunction classExpressionHasSideEffects(node, options) {\n    if (node.heritageClauses !== undefined && node.heritageClauses[0].token === ts.SyntaxKind.ExtendsKeyword)\n        for (const base of node.heritageClauses[0].types)\n            if (hasSideEffects(base.expression, options))\n                return true;\n    for (const child of node.members)\n        if (child.name !== undefined && child.name.kind === ts.SyntaxKind.ComputedPropertyName &&\n            hasSideEffects(child.name.expression, options) ||\n            node_1.isPropertyDeclaration(child) && child.initializer !== undefined &&\n                hasSideEffects(child.initializer, options))\n            return true;\n    return false;\n}\nfunction getDeclarationOfBindingElement(node) {\n    let parent = node.parent.parent;\n    while (parent.kind === ts.SyntaxKind.BindingElement)\n        parent = parent.parent.parent;\n    return parent;\n}\nexports.getDeclarationOfBindingElement = getDeclarationOfBindingElement;\nfunction isExpressionValueUsed(node) {\n    while (true) {\n        const parent = node.parent;\n        switch (parent.kind) {\n            case ts.SyntaxKind.CallExpression:\n            case ts.SyntaxKind.NewExpression:\n            case ts.SyntaxKind.ElementAccessExpression:\n            case ts.SyntaxKind.WhileStatement:\n            case ts.SyntaxKind.DoStatement:\n            case ts.SyntaxKind.WithStatement:\n            case ts.SyntaxKind.ThrowStatement:\n            case ts.SyntaxKind.ReturnStatement:\n            case ts.SyntaxKind.JsxExpression:\n            case ts.SyntaxKind.JsxSpreadAttribute:\n            case ts.SyntaxKind.JsxElement:\n            case ts.SyntaxKind.JsxFragment:\n            case ts.SyntaxKind.JsxSelfClosingElement:\n            case ts.SyntaxKind.ComputedPropertyName:\n            case ts.SyntaxKind.ArrowFunction:\n            case ts.SyntaxKind.ExportSpecifier:\n            case ts.SyntaxKind.ExportAssignment:\n            case ts.SyntaxKind.ImportDeclaration:\n            case ts.SyntaxKind.ExternalModuleReference:\n            case ts.SyntaxKind.Decorator:\n            case ts.SyntaxKind.TaggedTemplateExpression:\n            case ts.SyntaxKind.TemplateSpan:\n            case ts.SyntaxKind.ExpressionWithTypeArguments:\n            case ts.SyntaxKind.TypeOfExpression:\n            case ts.SyntaxKind.AwaitExpression:\n            case ts.SyntaxKind.YieldExpression:\n            case ts.SyntaxKind.LiteralType:\n            case ts.SyntaxKind.JsxAttributes:\n            case ts.SyntaxKind.JsxOpeningElement:\n            case ts.SyntaxKind.JsxClosingElement:\n            case ts.SyntaxKind.IfStatement:\n            case ts.SyntaxKind.CaseClause:\n            case ts.SyntaxKind.SwitchStatement:\n                return true;\n            case ts.SyntaxKind.PropertyAccessExpression:\n                return parent.expression === node;\n            case ts.SyntaxKind.QualifiedName:\n                return parent.left === node;\n            case ts.SyntaxKind.ShorthandPropertyAssignment:\n                return parent.objectAssignmentInitializer === node ||\n                    !isInDestructuringAssignment(parent);\n            case ts.SyntaxKind.PropertyAssignment:\n                return parent.initializer === node && !isInDestructuringAssignment(parent);\n            case ts.SyntaxKind.SpreadAssignment:\n            case ts.SyntaxKind.SpreadElement:\n            case ts.SyntaxKind.ArrayLiteralExpression:\n                return !isInDestructuringAssignment(parent);\n            case ts.SyntaxKind.ParenthesizedExpression:\n            case ts.SyntaxKind.AsExpression:\n            case ts.SyntaxKind.TypeAssertionExpression:\n            case ts.SyntaxKind.PostfixUnaryExpression:\n            case ts.SyntaxKind.PrefixUnaryExpression:\n            case ts.SyntaxKind.NonNullExpression:\n                node = parent;\n                break;\n            case ts.SyntaxKind.ForStatement:\n                return parent.condition === node;\n            case ts.SyntaxKind.ForInStatement:\n            case ts.SyntaxKind.ForOfStatement:\n                return parent.expression === node;\n            case ts.SyntaxKind.ConditionalExpression:\n                if (parent.condition === node)\n                    return true;\n                node = parent;\n                break;\n            case ts.SyntaxKind.PropertyDeclaration:\n            case ts.SyntaxKind.BindingElement:\n            case ts.SyntaxKind.VariableDeclaration:\n            case ts.SyntaxKind.Parameter:\n            case ts.SyntaxKind.EnumMember:\n                return parent.initializer === node;\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n                return parent.moduleReference === node;\n            case ts.SyntaxKind.CommaListExpression:\n                if (parent.elements[parent.elements.length - 1] !== node)\n                    return false;\n                node = parent;\n                break;\n            case ts.SyntaxKind.BinaryExpression:\n                if (parent.right === node) {\n                    if (parent.operatorToken.kind === ts.SyntaxKind.CommaToken) {\n                        node = parent;\n                        break;\n                    }\n                    return true;\n                }\n                switch (parent.operatorToken.kind) {\n                    case ts.SyntaxKind.CommaToken:\n                    case ts.SyntaxKind.EqualsToken:\n                        return false;\n                    case ts.SyntaxKind.EqualsEqualsEqualsToken:\n                    case ts.SyntaxKind.EqualsEqualsToken:\n                    case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n                    case ts.SyntaxKind.ExclamationEqualsToken:\n                    case ts.SyntaxKind.InstanceOfKeyword:\n                    case ts.SyntaxKind.PlusToken:\n                    case ts.SyntaxKind.MinusToken:\n                    case ts.SyntaxKind.AsteriskToken:\n                    case ts.SyntaxKind.SlashToken:\n                    case ts.SyntaxKind.PercentToken:\n                    case ts.SyntaxKind.AsteriskAsteriskToken:\n                    case ts.SyntaxKind.GreaterThanToken:\n                    case ts.SyntaxKind.GreaterThanGreaterThanToken:\n                    case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n                    case ts.SyntaxKind.GreaterThanEqualsToken:\n                    case ts.SyntaxKind.LessThanToken:\n                    case ts.SyntaxKind.LessThanLessThanToken:\n                    case ts.SyntaxKind.LessThanEqualsToken:\n                    case ts.SyntaxKind.AmpersandToken:\n                    case ts.SyntaxKind.BarToken:\n                    case ts.SyntaxKind.CaretToken:\n                    case ts.SyntaxKind.BarBarToken:\n                    case ts.SyntaxKind.AmpersandAmpersandToken:\n                    case ts.SyntaxKind.InKeyword:\n                        return true;\n                    default:\n                        node = parent;\n                }\n                break;\n            default:\n                return false;\n        }\n    }\n}\nexports.isExpressionValueUsed = isExpressionValueUsed;\nfunction isInDestructuringAssignment(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ShorthandPropertyAssignment:\n            if (node.objectAssignmentInitializer !== undefined)\n                return true;\n        case ts.SyntaxKind.PropertyAssignment:\n        case ts.SyntaxKind.SpreadAssignment:\n            node = node.parent;\n            break;\n        case ts.SyntaxKind.SpreadElement:\n            if (node.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression)\n                return false;\n            node = node.parent;\n    }\n    while (true) {\n        switch (node.parent.kind) {\n            case ts.SyntaxKind.BinaryExpression:\n                return node.parent.left === node &&\n                    node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n            case ts.SyntaxKind.ForOfStatement:\n                return node.parent.initializer === node;\n            case ts.SyntaxKind.ArrayLiteralExpression:\n            case ts.SyntaxKind.ObjectLiteralExpression:\n                node = node.parent;\n                break;\n            case ts.SyntaxKind.SpreadAssignment:\n            case ts.SyntaxKind.PropertyAssignment:\n                node = node.parent.parent;\n                break;\n            case ts.SyntaxKind.SpreadElement:\n                if (node.parent.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression)\n                    return false;\n                node = node.parent.parent;\n                break;\n            default:\n                return false;\n        }\n    }\n}\nvar AccessKind;\n(function (AccessKind) {\n    AccessKind[AccessKind[\"None\"] = 0] = \"None\";\n    AccessKind[AccessKind[\"Read\"] = 1] = \"Read\";\n    AccessKind[AccessKind[\"Write\"] = 2] = \"Write\";\n    AccessKind[AccessKind[\"Delete\"] = 4] = \"Delete\";\n    AccessKind[AccessKind[\"ReadWrite\"] = 3] = \"ReadWrite\";\n    AccessKind[AccessKind[\"Modification\"] = 6] = \"Modification\";\n})(AccessKind = exports.AccessKind || (exports.AccessKind = {}));\nfunction getAccessKind(node) {\n    const parent = node.parent;\n    switch (parent.kind) {\n        case ts.SyntaxKind.DeleteExpression:\n            return 4;\n        case ts.SyntaxKind.PostfixUnaryExpression:\n            return 3;\n        case ts.SyntaxKind.PrefixUnaryExpression:\n            return parent.operator === ts.SyntaxKind.PlusPlusToken ||\n                parent.operator === ts.SyntaxKind.MinusMinusToken\n                ? 3\n                : 1;\n        case ts.SyntaxKind.BinaryExpression:\n            return parent.right === node\n                ? 1\n                : !isAssignmentKind(parent.operatorToken.kind)\n                    ? 1\n                    : parent.operatorToken.kind === ts.SyntaxKind.EqualsToken\n                        ? 2\n                        : 3;\n        case ts.SyntaxKind.ShorthandPropertyAssignment:\n            return parent.objectAssignmentInitializer === node\n                ? 1\n                : isInDestructuringAssignment(parent)\n                    ? 2\n                    : 1;\n        case ts.SyntaxKind.PropertyAssignment:\n            return parent.name === node\n                ? 0\n                : isInDestructuringAssignment(parent)\n                    ? 2\n                    : 1;\n        case ts.SyntaxKind.ArrayLiteralExpression:\n        case ts.SyntaxKind.SpreadElement:\n        case ts.SyntaxKind.SpreadAssignment:\n            return isInDestructuringAssignment(parent)\n                ? 2\n                : 1;\n        case ts.SyntaxKind.ParenthesizedExpression:\n        case ts.SyntaxKind.NonNullExpression:\n        case ts.SyntaxKind.TypeAssertionExpression:\n        case ts.SyntaxKind.AsExpression:\n            return getAccessKind(parent);\n        case ts.SyntaxKind.ForOfStatement:\n        case ts.SyntaxKind.ForInStatement:\n            return parent.initializer === node\n                ? 2\n                : 1;\n        case ts.SyntaxKind.ExpressionWithTypeArguments:\n            return parent.parent.token === ts.SyntaxKind.ExtendsKeyword &&\n                parent.parent.parent.kind !== ts.SyntaxKind.InterfaceDeclaration\n                ? 1\n                : 0;\n        case ts.SyntaxKind.ComputedPropertyName:\n        case ts.SyntaxKind.ExpressionStatement:\n        case ts.SyntaxKind.TypeOfExpression:\n        case ts.SyntaxKind.ElementAccessExpression:\n        case ts.SyntaxKind.ForStatement:\n        case ts.SyntaxKind.IfStatement:\n        case ts.SyntaxKind.DoStatement:\n        case ts.SyntaxKind.WhileStatement:\n        case ts.SyntaxKind.SwitchStatement:\n        case ts.SyntaxKind.WithStatement:\n        case ts.SyntaxKind.ThrowStatement:\n        case ts.SyntaxKind.CallExpression:\n        case ts.SyntaxKind.NewExpression:\n        case ts.SyntaxKind.TaggedTemplateExpression:\n        case ts.SyntaxKind.JsxExpression:\n        case ts.SyntaxKind.Decorator:\n        case ts.SyntaxKind.TemplateSpan:\n        case ts.SyntaxKind.JsxOpeningElement:\n        case ts.SyntaxKind.JsxSelfClosingElement:\n        case ts.SyntaxKind.JsxSpreadAttribute:\n        case ts.SyntaxKind.VoidExpression:\n        case ts.SyntaxKind.ReturnStatement:\n        case ts.SyntaxKind.AwaitExpression:\n        case ts.SyntaxKind.YieldExpression:\n        case ts.SyntaxKind.ConditionalExpression:\n        case ts.SyntaxKind.CaseClause:\n        case ts.SyntaxKind.JsxElement:\n            return 1;\n        case ts.SyntaxKind.ArrowFunction:\n            return parent.body === node\n                ? 1\n                : 2;\n        case ts.SyntaxKind.PropertyDeclaration:\n        case ts.SyntaxKind.VariableDeclaration:\n        case ts.SyntaxKind.Parameter:\n        case ts.SyntaxKind.EnumMember:\n        case ts.SyntaxKind.BindingElement:\n        case ts.SyntaxKind.JsxAttribute:\n            return parent.initializer === node\n                ? 1\n                : 0;\n        case ts.SyntaxKind.PropertyAccessExpression:\n            return parent.expression === node\n                ? 1\n                : 0;\n        case ts.SyntaxKind.ExportAssignment:\n            return parent.isExportEquals\n                ? 1\n                : 0;\n    }\n    return 0;\n}\nexports.getAccessKind = getAccessKind;\nfunction isReassignmentTarget(node) {\n    return (getAccessKind(node) & 2) !== 0;\n}\nexports.isReassignmentTarget = isReassignmentTarget;\nfunction canHaveJsDoc(node) {\n    const kind = node.kind;\n    switch (kind) {\n        case ts.SyntaxKind.Parameter:\n        case ts.SyntaxKind.CallSignature:\n        case ts.SyntaxKind.ConstructSignature:\n        case ts.SyntaxKind.MethodSignature:\n        case ts.SyntaxKind.PropertySignature:\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.ParenthesizedExpression:\n        case ts.SyntaxKind.SpreadAssignment:\n        case ts.SyntaxKind.ShorthandPropertyAssignment:\n        case ts.SyntaxKind.PropertyAssignment:\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.LabeledStatement:\n        case ts.SyntaxKind.ExpressionStatement:\n        case ts.SyntaxKind.VariableStatement:\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.PropertyDeclaration:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.ClassExpression:\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.TypeAliasDeclaration:\n        case ts.SyntaxKind.EnumMember:\n        case ts.SyntaxKind.EnumDeclaration:\n        case ts.SyntaxKind.ModuleDeclaration:\n        case ts.SyntaxKind.ImportEqualsDeclaration:\n        case ts.SyntaxKind.IndexSignature:\n        case ts.SyntaxKind.FunctionType:\n        case ts.SyntaxKind.ConstructorType:\n        case ts.SyntaxKind.JSDocFunctionType:\n        case ts.SyntaxKind.EndOfFileToken:\n        case ts.SyntaxKind.ExportDeclaration:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.canHaveJsDoc = canHaveJsDoc;\nfunction getJsDoc(node, sourceFile) {\n    if (node.kind === ts.SyntaxKind.EndOfFileToken)\n        return parseJsDocWorker(node, sourceFile || node.parent);\n    const result = [];\n    for (const child of node.getChildren(sourceFile)) {\n        if (!node_1.isJsDoc(child))\n            break;\n        result.push(child);\n    }\n    return result;\n}\nexports.getJsDoc = getJsDoc;\nfunction parseJsDocOfNode(node, considerTrailingComments, sourceFile = node.getSourceFile()) {\n    if (canHaveJsDoc(node) && node.kind !== ts.SyntaxKind.EndOfFileToken) {\n        const result = getJsDoc(node, sourceFile);\n        if (result.length !== 0 || !considerTrailingComments)\n            return result;\n    }\n    return parseJsDocWorker(node, sourceFile, considerTrailingComments);\n}\nexports.parseJsDocOfNode = parseJsDocOfNode;\nfunction parseJsDocWorker(node, sourceFile, considerTrailingComments) {\n    const nodeStart = node.getStart(sourceFile);\n    const start = ts[considerTrailingComments && isSameLine(sourceFile, node.pos, nodeStart)\n        ? 'forEachTrailingCommentRange'\n        : 'forEachLeadingCommentRange'](sourceFile.text, node.pos, (pos, _end, kind) => kind === ts.SyntaxKind.MultiLineCommentTrivia && sourceFile.text[pos + 2] === '*' ? { pos } : undefined);\n    if (start === undefined)\n        return [];\n    const startPos = start.pos;\n    const text = sourceFile.text.slice(startPos, nodeStart);\n    const newSourceFile = ts.createSourceFile('jsdoc.ts', `${text}var a;`, sourceFile.languageVersion);\n    const result = getJsDoc(newSourceFile.statements[0], newSourceFile);\n    for (const doc of result)\n        updateNode(doc, node);\n    return result;\n    function updateNode(n, parent) {\n        n.pos += startPos;\n        n.end += startPos;\n        n.parent = parent;\n        return ts.forEachChild(n, (child) => updateNode(child, n), (children) => {\n            children.pos += startPos;\n            children.end += startPos;\n            for (const child of children)\n                updateNode(child, n);\n        });\n    }\n}\nvar ImportKind;\n(function (ImportKind) {\n    ImportKind[ImportKind[\"ImportDeclaration\"] = 1] = \"ImportDeclaration\";\n    ImportKind[ImportKind[\"ImportEquals\"] = 2] = \"ImportEquals\";\n    ImportKind[ImportKind[\"ExportFrom\"] = 4] = \"ExportFrom\";\n    ImportKind[ImportKind[\"DynamicImport\"] = 8] = \"DynamicImport\";\n    ImportKind[ImportKind[\"Require\"] = 16] = \"Require\";\n    ImportKind[ImportKind[\"ImportType\"] = 32] = \"ImportType\";\n    ImportKind[ImportKind[\"All\"] = 63] = \"All\";\n    ImportKind[ImportKind[\"AllImports\"] = 59] = \"AllImports\";\n    ImportKind[ImportKind[\"AllStaticImports\"] = 3] = \"AllStaticImports\";\n    ImportKind[ImportKind[\"AllImportExpressions\"] = 24] = \"AllImportExpressions\";\n    ImportKind[ImportKind[\"AllRequireLike\"] = 18] = \"AllRequireLike\";\n    ImportKind[ImportKind[\"AllNestedImports\"] = 56] = \"AllNestedImports\";\n    ImportKind[ImportKind[\"AllTopLevelImports\"] = 7] = \"AllTopLevelImports\";\n})(ImportKind = exports.ImportKind || (exports.ImportKind = {}));\nfunction findImports(sourceFile, kinds) {\n    const result = [];\n    for (const node of findImportLikeNodes(sourceFile, kinds)) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ImportDeclaration:\n                addIfTextualLiteral(node.moduleSpecifier);\n                break;\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n                addIfTextualLiteral(node.moduleReference.expression);\n                break;\n            case ts.SyntaxKind.ExportDeclaration:\n                addIfTextualLiteral(node.moduleSpecifier);\n                break;\n            case ts.SyntaxKind.CallExpression:\n                addIfTextualLiteral(node.arguments[0]);\n                break;\n            case ts.SyntaxKind.ImportType:\n                if (node_1.isLiteralTypeNode(node.argument))\n                    addIfTextualLiteral(node.argument.literal);\n                break;\n            default:\n                throw new Error('unexpected node');\n        }\n    }\n    return result;\n    function addIfTextualLiteral(node) {\n        if (node_1.isTextualLiteral(node))\n            result.push(node);\n    }\n}\nexports.findImports = findImports;\nfunction findImportLikeNodes(sourceFile, kinds) {\n    return new ImportFinder(sourceFile, kinds).find();\n}\nexports.findImportLikeNodes = findImportLikeNodes;\nclass ImportFinder {\n    constructor(_sourceFile, _options) {\n        this._sourceFile = _sourceFile;\n        this._options = _options;\n        this._result = [];\n    }\n    find() {\n        if (this._sourceFile.isDeclarationFile)\n            this._options &= ~24;\n        if (this._options & 7)\n            this._findImports(this._sourceFile.statements);\n        if (this._options & 56)\n            this._findNestedImports();\n        return this._result;\n    }\n    _findImports(statements) {\n        for (const statement of statements) {\n            if (node_1.isImportDeclaration(statement)) {\n                if (this._options & 1)\n                    this._result.push(statement);\n            }\n            else if (node_1.isImportEqualsDeclaration(statement)) {\n                if (this._options & 2 &&\n                    statement.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference)\n                    this._result.push(statement);\n            }\n            else if (node_1.isExportDeclaration(statement)) {\n                if (statement.moduleSpecifier !== undefined && this._options & 4)\n                    this._result.push(statement);\n            }\n            else if (node_1.isModuleDeclaration(statement)) {\n                this._findImportsInModule(statement);\n            }\n        }\n    }\n    _findImportsInModule(declaration) {\n        if (declaration.body === undefined)\n            return;\n        if (declaration.body.kind === ts.SyntaxKind.ModuleDeclaration)\n            return this._findImportsInModule(declaration.body);\n        this._findImports(declaration.body.statements);\n    }\n    _findNestedImports() {\n        let re;\n        if ((this._options & 56) === 16) {\n            re = /\\brequire\\s*[</(]/g;\n        }\n        else if (this._options & 16) {\n            re = /\\b(?:import|require)\\s*[</(]/g;\n        }\n        else {\n            re = /\\bimport\\s*[</(]/g;\n        }\n        const isJavaScriptFile = (this._sourceFile.flags & ts.NodeFlags.JavaScriptFile) !== 0;\n        for (let match = re.exec(this._sourceFile.text); match !== null; match = re.exec(this._sourceFile.text)) {\n            const token = getTokenAtPositionWorker(this._sourceFile, match.index, this._sourceFile, match[0][0] === 'i' && isJavaScriptFile);\n            if (token.kind === ts.SyntaxKind.ImportKeyword) {\n                if (token.end - 'import'.length !== match.index)\n                    continue;\n                switch (token.parent.kind) {\n                    case ts.SyntaxKind.ImportType:\n                        this._result.push(token.parent);\n                        break;\n                    case ts.SyntaxKind.CallExpression:\n                        if (token.parent.arguments.length === 1)\n                            this._result.push(token.parent);\n                }\n            }\n            else if (token.kind === ts.SyntaxKind.Identifier &&\n                token.end - 'require'.length === match.index &&\n                token.parent.kind === ts.SyntaxKind.CallExpression &&\n                token.parent.expression === token &&\n                token.parent.arguments.length === 1) {\n                this._result.push(token.parent);\n            }\n        }\n    }\n}\nfunction isStatementInAmbientContext(node) {\n    while (node.flags & ts.NodeFlags.NestedNamespace)\n        node = node.parent;\n    return hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword) || isAmbientModuleBlock(node.parent);\n}\nexports.isStatementInAmbientContext = isStatementInAmbientContext;\nfunction isAmbientModuleBlock(node) {\n    while (node.kind === ts.SyntaxKind.ModuleBlock) {\n        do\n            node = node.parent;\n        while (node.flags & ts.NodeFlags.NestedNamespace);\n        if (hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword))\n            return true;\n        node = node.parent;\n    }\n    return false;\n}\nexports.isAmbientModuleBlock = isAmbientModuleBlock;\nfunction getIIFE(func) {\n    let node = func.parent;\n    while (node.kind === ts.SyntaxKind.ParenthesizedExpression)\n        node = node.parent;\n    return node_1.isCallExpression(node) && func.end <= node.expression.end ? node : undefined;\n}\nexports.getIIFE = getIIFE;\nfunction isStrictCompilerOptionEnabled(options, option) {\n    return (options.strict ? options[option] !== false : options[option] === true) &&\n        (option !== 'strictPropertyInitialization' || isStrictCompilerOptionEnabled(options, 'strictNullChecks'));\n}\nexports.isStrictCompilerOptionEnabled = isStrictCompilerOptionEnabled;\nfunction isCompilerOptionEnabled(options, option) {\n    switch (option) {\n        case 'stripInternal':\n            return options.stripInternal === true && isCompilerOptionEnabled(options, 'declaration');\n        case 'declaration':\n            return options.declaration || isCompilerOptionEnabled(options, 'composite');\n        case 'incremental':\n            return options.incremental === undefined ? isCompilerOptionEnabled(options, 'composite') : options.incremental;\n        case 'skipDefaultLibCheck':\n            return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, 'skipLibCheck');\n        case 'suppressImplicitAnyIndexErrors':\n            return options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, 'noImplicitAny');\n        case 'allowSyntheticDefaultImports':\n            return options.allowSyntheticDefaultImports !== undefined\n                ? options.allowSyntheticDefaultImports\n                : isCompilerOptionEnabled(options, 'esModuleInterop') || options.module === ts.ModuleKind.System;\n        case 'noImplicitAny':\n        case 'noImplicitThis':\n        case 'strictNullChecks':\n        case 'strictFunctionTypes':\n        case 'strictPropertyInitialization':\n        case 'alwaysStrict':\n        case 'strictBindCallApply':\n            return isStrictCompilerOptionEnabled(options, option);\n    }\n    return options[option] === true;\n}\nexports.isCompilerOptionEnabled = isCompilerOptionEnabled;\nfunction isAmbientModule(node) {\n    return node.name.kind === ts.SyntaxKind.StringLiteral || (node.flags & ts.NodeFlags.GlobalAugmentation) !== 0;\n}\nexports.isAmbientModule = isAmbientModule;\nfunction getCheckJsDirective(source) {\n    let directive;\n    ts.forEachLeadingCommentRange(source, (ts.getShebang(source) || '').length, (pos, end, kind) => {\n        if (kind === ts.SyntaxKind.SingleLineCommentTrivia) {\n            const text = source.slice(pos, end);\n            const match = /^\\/{2,3}\\s*@ts-(no)?check(?:\\s|$)/i.exec(text);\n            if (match !== null)\n                directive = { pos, end, enabled: match[1] === undefined };\n        }\n    });\n    return directive;\n}\nexports.getCheckJsDirective = getCheckJsDirective;\nfunction isConstAssertion(node) {\n    return node_1.isTypeReferenceNode(node.type) &&\n        node.type.typeName.kind === ts.SyntaxKind.Identifier &&\n        node.type.typeName.escapedText === 'const';\n}\nexports.isConstAssertion = isConstAssertion;\nfunction isInConstContext(node) {\n    let current = node;\n    while (true) {\n        const parent = current.parent;\n        outer: switch (parent.kind) {\n            case ts.SyntaxKind.TypeAssertionExpression:\n            case ts.SyntaxKind.AsExpression:\n                return isConstAssertion(parent);\n            case ts.SyntaxKind.PrefixUnaryExpression:\n                if (current.kind !== ts.SyntaxKind.NumericLiteral)\n                    return false;\n                switch (parent.operator) {\n                    case ts.SyntaxKind.PlusToken:\n                    case ts.SyntaxKind.MinusToken:\n                        current = parent;\n                        break outer;\n                    default:\n                        return false;\n                }\n            case ts.SyntaxKind.PropertyAssignment:\n                if (parent.initializer !== current)\n                    return false;\n                current = parent.parent;\n                break;\n            case ts.SyntaxKind.ShorthandPropertyAssignment:\n                current = parent.parent;\n                break;\n            case ts.SyntaxKind.ParenthesizedExpression:\n            case ts.SyntaxKind.ArrayLiteralExpression:\n            case ts.SyntaxKind.ObjectLiteralExpression:\n                current = parent;\n                break;\n            default:\n                return false;\n        }\n    }\n}\nexports.isInConstContext = isInConstContext;\nfunction isReadonlyAssignmentDeclaration(node, checker) {\n    if (!isBindableObjectDefinePropertyCall(node))\n        return false;\n    const descriptorType = checker.getTypeAtLocation(node.arguments[2]);\n    if (descriptorType.getProperty('value') === undefined)\n        return descriptorType.getProperty('set') === undefined;\n    const writableProp = descriptorType.getProperty('writable');\n    if (writableProp === undefined)\n        return false;\n    const writableType = writableProp.valueDeclaration !== undefined && node_1.isPropertyAssignment(writableProp.valueDeclaration)\n        ? checker.getTypeAtLocation(writableProp.valueDeclaration.initializer)\n        : checker.getTypeOfSymbolAtLocation(writableProp, node.arguments[2]);\n    return type_1.isBooleanLiteralType(writableType, false);\n}\nexports.isReadonlyAssignmentDeclaration = isReadonlyAssignmentDeclaration;\nfunction isBindableObjectDefinePropertyCall(node) {\n    return node.arguments.length === 3 &&\n        node_1.isEntityNameExpression(node.arguments[0]) &&\n        node_1.isNumericOrStringLikeLiteral(node.arguments[1]) &&\n        node_1.isPropertyAccessExpression(node.expression) &&\n        node.expression.name.escapedText === 'defineProperty' &&\n        node_1.isIdentifier(node.expression.expression) &&\n        node.expression.expression.escapedText === 'Object';\n}\nexports.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;\nfunction isWellKnownSymbolLiterally(node) {\n    return ts.isPropertyAccessExpression(node) &&\n        ts.isIdentifier(node.expression) &&\n        node.expression.escapedText === 'Symbol';\n}\nexports.isWellKnownSymbolLiterally = isWellKnownSymbolLiterally;\nfunction getPropertyNameOfWellKnownSymbol(node) {\n    return {\n        displayName: `[Symbol.${node.name.text}]`,\n        symbolName: ('__@' + node.name.text),\n    };\n}\nexports.getPropertyNameOfWellKnownSymbol = getPropertyNameOfWellKnownSymbol;\nfunction getLateBoundPropertyNames(node, checker) {\n    const result = {\n        known: true,\n        names: [],\n    };\n    node = unwrapParentheses(node);\n    if (isWellKnownSymbolLiterally(node)) {\n        result.names.push(getPropertyNameOfWellKnownSymbol(node));\n    }\n    else {\n        const type = checker.getTypeAtLocation(node);\n        for (const key of type_1.unionTypeParts(checker.getBaseConstraintOfType(type) || type)) {\n            const propertyName = type_1.getPropertyNameFromType(key);\n            if (propertyName) {\n                result.names.push(propertyName);\n            }\n            else {\n                result.known = false;\n            }\n        }\n    }\n    return result;\n}\nexports.getLateBoundPropertyNames = getLateBoundPropertyNames;\nfunction getLateBoundPropertyNamesOfPropertyName(node, checker) {\n    const staticName = getPropertyName(node);\n    return staticName !== undefined\n        ? { known: true, names: [{ displayName: staticName, symbolName: ts.escapeLeadingUnderscores(staticName) }] }\n        : getLateBoundPropertyNames(node.expression, checker);\n}\nexports.getLateBoundPropertyNamesOfPropertyName = getLateBoundPropertyNamesOfPropertyName;\nfunction getSingleLateBoundPropertyNameOfPropertyName(node, checker) {\n    const staticName = getPropertyName(node);\n    if (staticName !== undefined)\n        return { displayName: staticName, symbolName: ts.escapeLeadingUnderscores(staticName) };\n    const { expression } = node;\n    return isWellKnownSymbolLiterally(expression)\n        ? getPropertyNameOfWellKnownSymbol(expression)\n        : type_1.getPropertyNameFromType(checker.getTypeAtLocation(expression));\n}\nexports.getSingleLateBoundPropertyNameOfPropertyName = getSingleLateBoundPropertyNameOfPropertyName;\nfunction unwrapParentheses(node) {\n    while (node.kind === ts.SyntaxKind.ParenthesizedExpression)\n        node = node.expression;\n    return node;\n}\nexports.unwrapParentheses = unwrapParentheses;\n"]},"metadata":{},"sourceType":"script"}