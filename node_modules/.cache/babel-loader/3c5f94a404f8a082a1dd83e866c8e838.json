{"ast":null,"code":"/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst {\n  findVariable,\n  getPropertyName\n} = require(\"eslint-utils\");\n\nconst MutationMethods = {\n  Object: new Set([\"assign\", \"defineProperties\", \"defineProperty\", \"freeze\", \"setPrototypeOf\"]),\n  Reflect: new Set([\"defineProperty\", \"deleteProperty\", \"set\", \"setPrototypeOf\"])\n};\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\n\nfunction isAssignmentLeft(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"AssignmentExpression\" && parent.left === node || // Destructuring assignments\n  parent.type === \"ArrayPattern\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"RestElement\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\n\n\nfunction isOperandOfMutationUnaryOperator(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"UpdateExpression\" && parent.argument === node || parent.type === \"UnaryExpression\" && parent.operator === \"delete\" && parent.argument === node;\n}\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\n\n\nfunction isIterationVariable(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"ForInStatement\" && parent.left === node || parent.type === \"ForOfStatement\" && parent.left === node;\n}\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is the iteration variable.\n */\n\n\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n  const {\n    parent\n  } = node;\n\n  if (parent.type === \"CallExpression\" && parent.arguments[0] === node && parent.callee.type === \"MemberExpression\" && parent.callee.object.type === \"Identifier\") {\n    const {\n      callee\n    } = parent;\n    const {\n      object\n    } = callee;\n\n    if (Object.keys(MutationMethods).includes(object.name)) {\n      const variable = findVariable(scope, object);\n      return variable !== null && variable.scope.type === \"global\" && MutationMethods[object.name].has(getPropertyName(callee, scope));\n    }\n  }\n\n  return false;\n}\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\n\n\nfunction isMemberWrite(id, scope) {\n  const {\n    parent\n  } = id;\n  return parent.type === \"MemberExpression\" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);\n}\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\n\n\nfunction getWriteNode(id) {\n  let node = id.parent;\n\n  while (node && node.type !== \"AssignmentExpression\" && node.type !== \"UpdateExpression\" && node.type !== \"UnaryExpression\" && node.type !== \"CallExpression\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\") {\n    node = node.parent;\n  }\n\n  return node || id;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assigning to imported bindings\",\n      category: \"Possible Errors\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-import-assign\"\n    },\n    schema: [],\n    messages: {\n      readonly: \"'{{name}}' is read-only.\",\n      readonlyMember: \"The members of '{{name}}' are read-only.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ImportDeclaration(node) {\n        const scope = context.getScope();\n\n        for (const variable of context.getDeclaredVariables(node)) {\n          const shouldCheckMembers = variable.defs.some(d => d.node.type === \"ImportNamespaceSpecifier\");\n          let prevIdNode = null;\n\n          for (const reference of variable.references) {\n            const idNode = reference.identifier;\n            /*\n             * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n             * references for the same identifier. This should skip\n             * the one of the two in order to prevent redundant reports.\n             */\n\n            if (idNode === prevIdNode) {\n              continue;\n            }\n\n            prevIdNode = idNode;\n\n            if (reference.isWrite()) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonly\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonlyMember\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-import-assign.js"],"names":["findVariable","getPropertyName","require","MutationMethods","Object","Set","Reflect","isAssignmentLeft","node","parent","type","left","value","isOperandOfMutationUnaryOperator","argument","operator","isIterationVariable","isArgumentOfWellKnownMutationFunction","scope","arguments","callee","object","keys","includes","name","variable","has","isMemberWrite","id","getWriteNode","module","exports","meta","docs","description","category","recommended","url","schema","messages","readonly","readonlyMember","create","context","ImportDeclaration","getScope","getDeclaredVariables","shouldCheckMembers","defs","some","d","prevIdNode","reference","references","idNode","identifier","isWrite","report","messageId","data"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst { findVariable, getPropertyName } = require(\"eslint-utils\");\n\nconst MutationMethods = {\n    Object: new Set([\n        \"assign\", \"defineProperties\", \"defineProperty\", \"freeze\",\n        \"setPrototypeOf\"\n    ]),\n    Reflect: new Set([\n        \"defineProperty\", \"deleteProperty\", \"set\", \"setPrototypeOf\"\n    ])\n};\n\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\nfunction isAssignmentLeft(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // Destructuring assignments\n        parent.type === \"ArrayPattern\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\nfunction isOperandOfMutationUnaryOperator(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"UpdateExpression\" &&\n            parent.argument === node\n        ) ||\n        (\n            parent.type === \"UnaryExpression\" &&\n            parent.operator === \"delete\" &&\n            parent.argument === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isIterationVariable(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"ForInStatement\" &&\n            parent.left === node\n        ) ||\n        (\n            parent.type === \"ForOfStatement\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n    const { parent } = node;\n\n    if (\n        parent.type === \"CallExpression\" &&\n        parent.arguments[0] === node &&\n        parent.callee.type === \"MemberExpression\" &&\n        parent.callee.object.type === \"Identifier\"\n    ) {\n        const { callee } = parent;\n        const { object } = callee;\n\n        if (Object.keys(MutationMethods).includes(object.name)) {\n            const variable = findVariable(scope, object);\n\n            return (\n                variable !== null &&\n                variable.scope.type === \"global\" &&\n                MutationMethods[object.name].has(getPropertyName(callee, scope))\n            );\n        }\n    }\n\n    return false;\n}\n\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\nfunction isMemberWrite(id, scope) {\n    const { parent } = id;\n\n    return (\n        (\n            parent.type === \"MemberExpression\" &&\n            parent.object === id &&\n            (\n                isAssignmentLeft(parent) ||\n                isOperandOfMutationUnaryOperator(parent) ||\n                isIterationVariable(parent)\n            )\n        ) ||\n        isArgumentOfWellKnownMutationFunction(id, scope)\n    );\n}\n\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\nfunction getWriteNode(id) {\n    let node = id.parent;\n\n    while (\n        node &&\n        node.type !== \"AssignmentExpression\" &&\n        node.type !== \"UpdateExpression\" &&\n        node.type !== \"UnaryExpression\" &&\n        node.type !== \"CallExpression\" &&\n        node.type !== \"ForInStatement\" &&\n        node.type !== \"ForOfStatement\"\n    ) {\n        node = node.parent;\n    }\n\n    return node || id;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assigning to imported bindings\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-import-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            readonly: \"'{{name}}' is read-only.\",\n            readonlyMember: \"The members of '{{name}}' are read-only.\"\n        }\n    },\n\n    create(context) {\n        return {\n            ImportDeclaration(node) {\n                const scope = context.getScope();\n\n                for (const variable of context.getDeclaredVariables(node)) {\n                    const shouldCheckMembers = variable.defs.some(\n                        d => d.node.type === \"ImportNamespaceSpecifier\"\n                    );\n                    let prevIdNode = null;\n\n                    for (const reference of variable.references) {\n                        const idNode = reference.identifier;\n\n                        /*\n                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n                         * references for the same identifier. This should skip\n                         * the one of the two in order to prevent redundant reports.\n                         */\n                        if (idNode === prevIdNode) {\n                            continue;\n                        }\n                        prevIdNode = idNode;\n\n                        if (reference.isWrite()) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonly\",\n                                data: { name: idNode.name }\n                            });\n                        } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonlyMember\",\n                                data: { name: idNode.name }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}