{"ast":null,"code":"import Promise from './promise';\nimport { default as Enumerator, setSettledResult } from './enumerator';\nimport PromiseHash from './promise-hash';\n\nclass HashSettled extends PromiseHash {\n  constructor(Constructor, object, label) {\n    super(Constructor, object, false, label);\n  }\n\n}\n\nHashSettled.prototype._setResultAt = setSettledResult;\n/**\n  `hashSettled` is similar to `allSettled`, but takes an object\n  instead of an array for its `promises` argument.\n\n  Unlike `all` or `hash`, which implement a fail-fast method,\n  but like `allSettled`, `hashSettled` waits until all the\n  constituent promises have returned and then shows you all the results\n  with their states and values/reasons. This is useful if you want to\n  handle multiple promises' failure states together as a set.\n\n  Returns a promise that is fulfilled when all the given promises have been\n  settled, or rejected if the passed parameters are invalid.\n\n  The returned promise is fulfilled with a hash that has the same key names as\n  the `promises` object argument. If any of the values in the object are not\n  promises, they will be copied over to the fulfilled object and marked with state\n  'fulfilled'.\n\n  Example:\n\n  ```javascript\n  import { hashSettled, resolve } from 'rsvp';\n\n  let promises = {\n    myPromise: resolve(1),\n    yourPromise: resolve(2),\n    theirPromise: resolve(3),\n    notAPromise: 4\n  };\n\n  hashSettled(promises).then(function(hash){\n    // hash here is an object that looks like:\n    // {\n    //   myPromise: { state: 'fulfilled', value: 1 },\n    //   yourPromise: { state: 'fulfilled', value: 2 },\n    //   theirPromise: { state: 'fulfilled', value: 3 },\n    //   notAPromise: { state: 'fulfilled', value: 4 }\n    // }\n  });\n  ```\n\n  If any of the `promises` given to `hash` are rejected, the state will\n  be set to 'rejected' and the reason for rejection provided.\n\n  Example:\n\n  ```javascript\n  import { hashSettled, reject, resolve } from 'rsvp';\n\n  let promises = {\n    myPromise: resolve(1),\n    rejectedPromise: reject(new Error('rejection')),\n    anotherRejectedPromise: reject(new Error('more rejection')),\n  };\n\n  hashSettled(promises).then(function(hash){\n    // hash here is an object that looks like:\n    // {\n    //   myPromise:              { state: 'fulfilled', value: 1 },\n    //   rejectedPromise:        { state: 'rejected', reason: Error },\n    //   anotherRejectedPromise: { state: 'rejected', reason: Error },\n    // }\n    // Note that for rejectedPromise, reason.message == 'rejection',\n    // and for anotherRejectedPromise, reason.message == 'more rejection'.\n  });\n  ```\n\n  An important note: `hashSettled` is intended for plain JavaScript objects that\n  are just a set of keys and values. `hashSettled` will NOT preserve prototype\n  chains.\n\n  Example:\n\n  ```javascript\n  import Promise, { hashSettled, resolve } from 'rsvp';\n\n  function MyConstructor(){\n    this.example = resolve('Example');\n  }\n\n  MyConstructor.prototype = {\n    protoProperty: Promise.resolve('Proto Property')\n  };\n\n  let myObject = new MyConstructor();\n\n  hashSettled(myObject).then(function(hash){\n    // protoProperty will not be present, instead you will just have an\n    // object that looks like:\n    // {\n    //   example: { state: 'fulfilled', value: 'Example' }\n    // }\n    //\n    // hash.hasOwnProperty('protoProperty'); // false\n    // 'undefined' === typeof hash.protoProperty\n  });\n  ```\n\n  @method hashSettled\n  @public\n  @for rsvp\n  @param {Object} object\n  @param {String} [label] optional string that describes the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when when all properties of `promises`\n  have been settled.\n  @static\n*/\n\nexport default function hashSettled(object, label) {\n  return Promise.resolve(object, label).then(function (object) {\n    if (object === null || typeof object !== 'object') {\n      throw new TypeError(\"hashSettled must be called with an object\");\n    }\n\n    return new HashSettled(Promise, object, false, label).promise;\n  });\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/rsvp/lib/rsvp/hash-settled.js"],"names":["Promise","default","Enumerator","setSettledResult","PromiseHash","HashSettled","constructor","Constructor","object","label","prototype","_setResultAt","hashSettled","resolve","then","TypeError","promise"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,SACEC,OAAO,IAAIC,UADb,EAEEC,gBAFF,QAGO,cAHP;AAIA,OAAOC,WAAP,MAAwB,gBAAxB;;AAEA,MAAMC,WAAN,SAA0BD,WAA1B,CAAsC;AACpCE,EAAAA,WAAW,CAACC,WAAD,EAAcC,MAAd,EAAsBC,KAAtB,EAA6B;AACtC,UAAMF,WAAN,EAAmBC,MAAnB,EAA2B,KAA3B,EAAkCC,KAAlC;AACD;;AAHmC;;AAMtCJ,WAAW,CAACK,SAAZ,CAAsBC,YAAtB,GAAqCR,gBAArC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6GA,eAAe,SAASS,WAAT,CAAqBJ,MAArB,EAA6BC,KAA7B,EAAoC;AACjD,SAAOT,OAAO,CAACa,OAAR,CAAgBL,MAAhB,EAAwBC,KAAxB,EACJK,IADI,CACC,UAASN,MAAT,EAAiB;AACrB,QAAIA,MAAM,KAAK,IAAX,IAAmB,OAAOA,MAAP,KAAkB,QAAzC,EAAmD;AACjD,YAAM,IAAIO,SAAJ,CAAc,2CAAd,CAAN;AACD;;AAED,WAAO,IAAIV,WAAJ,CAAgBL,OAAhB,EAAyBQ,MAAzB,EAAiC,KAAjC,EAAwCC,KAAxC,EAA+CO,OAAtD;AACD,GAPI,CAAP;AAQD","sourcesContent":["import Promise from './promise';\nimport {\n  default as Enumerator,\n  setSettledResult\n} from './enumerator';\nimport PromiseHash from './promise-hash';\n\nclass HashSettled extends PromiseHash {\n  constructor(Constructor, object, label) {\n    super(Constructor, object, false, label);\n  }\n}\n\nHashSettled.prototype._setResultAt = setSettledResult;\n\n/**\n  `hashSettled` is similar to `allSettled`, but takes an object\n  instead of an array for its `promises` argument.\n\n  Unlike `all` or `hash`, which implement a fail-fast method,\n  but like `allSettled`, `hashSettled` waits until all the\n  constituent promises have returned and then shows you all the results\n  with their states and values/reasons. This is useful if you want to\n  handle multiple promises' failure states together as a set.\n\n  Returns a promise that is fulfilled when all the given promises have been\n  settled, or rejected if the passed parameters are invalid.\n\n  The returned promise is fulfilled with a hash that has the same key names as\n  the `promises` object argument. If any of the values in the object are not\n  promises, they will be copied over to the fulfilled object and marked with state\n  'fulfilled'.\n\n  Example:\n\n  ```javascript\n  import { hashSettled, resolve } from 'rsvp';\n\n  let promises = {\n    myPromise: resolve(1),\n    yourPromise: resolve(2),\n    theirPromise: resolve(3),\n    notAPromise: 4\n  };\n\n  hashSettled(promises).then(function(hash){\n    // hash here is an object that looks like:\n    // {\n    //   myPromise: { state: 'fulfilled', value: 1 },\n    //   yourPromise: { state: 'fulfilled', value: 2 },\n    //   theirPromise: { state: 'fulfilled', value: 3 },\n    //   notAPromise: { state: 'fulfilled', value: 4 }\n    // }\n  });\n  ```\n\n  If any of the `promises` given to `hash` are rejected, the state will\n  be set to 'rejected' and the reason for rejection provided.\n\n  Example:\n\n  ```javascript\n  import { hashSettled, reject, resolve } from 'rsvp';\n\n  let promises = {\n    myPromise: resolve(1),\n    rejectedPromise: reject(new Error('rejection')),\n    anotherRejectedPromise: reject(new Error('more rejection')),\n  };\n\n  hashSettled(promises).then(function(hash){\n    // hash here is an object that looks like:\n    // {\n    //   myPromise:              { state: 'fulfilled', value: 1 },\n    //   rejectedPromise:        { state: 'rejected', reason: Error },\n    //   anotherRejectedPromise: { state: 'rejected', reason: Error },\n    // }\n    // Note that for rejectedPromise, reason.message == 'rejection',\n    // and for anotherRejectedPromise, reason.message == 'more rejection'.\n  });\n  ```\n\n  An important note: `hashSettled` is intended for plain JavaScript objects that\n  are just a set of keys and values. `hashSettled` will NOT preserve prototype\n  chains.\n\n  Example:\n\n  ```javascript\n  import Promise, { hashSettled, resolve } from 'rsvp';\n\n  function MyConstructor(){\n    this.example = resolve('Example');\n  }\n\n  MyConstructor.prototype = {\n    protoProperty: Promise.resolve('Proto Property')\n  };\n\n  let myObject = new MyConstructor();\n\n  hashSettled(myObject).then(function(hash){\n    // protoProperty will not be present, instead you will just have an\n    // object that looks like:\n    // {\n    //   example: { state: 'fulfilled', value: 'Example' }\n    // }\n    //\n    // hash.hasOwnProperty('protoProperty'); // false\n    // 'undefined' === typeof hash.protoProperty\n  });\n  ```\n\n  @method hashSettled\n  @public\n  @for rsvp\n  @param {Object} object\n  @param {String} [label] optional string that describes the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when when all properties of `promises`\n  have been settled.\n  @static\n*/\n\nexport default function hashSettled(object, label) {\n  return Promise.resolve(object, label)\n    .then(function(object) {\n      if (object === null || typeof object !== 'object') {\n        throw new TypeError(\"hashSettled must be called with an object\");\n      }\n\n      return new HashSettled(Promise, object, false, label).promise;\n    });\n}\n"]},"metadata":{},"sourceType":"module"}