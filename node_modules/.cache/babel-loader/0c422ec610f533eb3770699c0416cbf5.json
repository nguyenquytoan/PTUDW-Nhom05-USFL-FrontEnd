{"ast":null,"code":"/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines per file\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          max: {\n            type: \"integer\",\n            minimum: 0\n          },\n          skipComments: {\n            type: \"boolean\"\n          },\n          skipBlankLines: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      exceed: \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const option = context.options[0];\n    let max = 300;\n\n    if (typeof option === \"object\" && Object.prototype.hasOwnProperty.call(option, \"max\")) {\n      max = option.max;\n    } else if (typeof option === \"number\") {\n      max = option;\n    }\n\n    const skipComments = option && option.skipComments;\n    const skipBlankLines = option && option.skipBlankLines;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Returns whether or not a token is a comment node type\n     * @param {Token} token The token to check\n     * @returns {boolean} True if the token is a comment node\n     */\n\n    function isCommentNodeType(token) {\n      return token && (token.type === \"Block\" || token.type === \"Line\");\n    }\n    /**\n     * Returns the line numbers of a comment that don't have any code on the same line\n     * @param {Node} comment The comment node to check\n     * @returns {number[]} The line numbers\n     */\n\n\n    function getLinesWithoutCode(comment) {\n      let start = comment.loc.start.line;\n      let end = comment.loc.end.line;\n      let token;\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenBefore(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(token, comment)) {\n        start += 1;\n      }\n\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenAfter(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(comment, token)) {\n        end -= 1;\n      }\n\n      if (start <= end) {\n        return lodash.range(start, end + 1);\n      }\n\n      return [];\n    }\n\n    return {\n      \"Program:exit\"() {\n        let lines = sourceCode.lines.map((text, i) => ({\n          lineNumber: i + 1,\n          text\n        }));\n\n        if (skipBlankLines) {\n          lines = lines.filter(l => l.text.trim() !== \"\");\n        }\n\n        if (skipComments) {\n          const comments = sourceCode.getAllComments();\n          const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));\n          lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));\n        }\n\n        if (lines.length > max) {\n          context.report({\n            loc: {\n              line: 1,\n              column: 0\n            },\n            messageId: \"exceed\",\n            data: {\n              max,\n              actual: lines.length\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/max-lines.js"],"names":["lodash","require","astUtils","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","minimum","properties","max","skipComments","skipBlankLines","additionalProperties","messages","exceed","create","context","option","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","isCommentNodeType","token","getLinesWithoutCode","comment","start","loc","line","end","getTokenBefore","includeComments","isTokenOnSameLine","getTokenAfter","range","lines","map","text","i","lineNumber","filter","l","trim","comments","getAllComments","commentLines","flatten","includes","length","report","column","messageId","data","actual"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEAE,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,4CADX;AAEFC,MAAAA,QAAQ,EAAE,kBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,KAAK,EAAE,CACH;AACIP,QAAAA,IAAI,EAAE,SADV;AAEIQ,QAAAA,OAAO,EAAE;AAFb,OADG,EAKH;AACIR,QAAAA,IAAI,EAAE,QADV;AAEIS,QAAAA,UAAU,EAAE;AACRC,UAAAA,GAAG,EAAE;AACDV,YAAAA,IAAI,EAAE,SADL;AAEDQ,YAAAA,OAAO,EAAE;AAFR,WADG;AAKRG,UAAAA,YAAY,EAAE;AACVX,YAAAA,IAAI,EAAE;AADI,WALN;AAQRY,UAAAA,cAAc,EAAE;AACZZ,YAAAA,IAAI,EAAE;AADM;AARR,SAFhB;AAcIa,QAAAA,oBAAoB,EAAE;AAd1B,OALG;AADX,KADI,CAVN;AAoCFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,MAAM,EAAE;AADF;AApCR,GADO;;AA0CbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,MAAM,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAf;AACA,QAAIT,GAAG,GAAG,GAAV;;AAEA,QAAI,OAAOQ,MAAP,KAAkB,QAAlB,IAA8BE,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,MAArC,EAA6C,KAA7C,CAAlC,EAAuF;AACnFR,MAAAA,GAAG,GAAGQ,MAAM,CAACR,GAAb;AACH,KAFD,MAEO,IAAI,OAAOQ,MAAP,KAAkB,QAAtB,EAAgC;AACnCR,MAAAA,GAAG,GAAGQ,MAAN;AACH;;AAED,UAAMP,YAAY,GAAGO,MAAM,IAAIA,MAAM,CAACP,YAAtC;AACA,UAAMC,cAAc,GAAGM,MAAM,IAAIA,MAAM,CAACN,cAAxC;AAEA,UAAMY,UAAU,GAAGP,OAAO,CAACQ,aAAR,EAAnB;AAEA;;;;;;AAKA,aAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAC9B,aAAOA,KAAK,KAAKA,KAAK,CAAC3B,IAAN,KAAe,OAAf,IAA0B2B,KAAK,CAAC3B,IAAN,KAAe,MAA9C,CAAZ;AACH;AAED;;;;;;;AAKA,aAAS4B,mBAAT,CAA6BC,OAA7B,EAAsC;AAClC,UAAIC,KAAK,GAAGD,OAAO,CAACE,GAAR,CAAYD,KAAZ,CAAkBE,IAA9B;AACA,UAAIC,GAAG,GAAGJ,OAAO,CAACE,GAAR,CAAYE,GAAZ,CAAgBD,IAA1B;AAEA,UAAIL,KAAJ;AAEAA,MAAAA,KAAK,GAAGE,OAAR;;AACA,SAAG;AACCF,QAAAA,KAAK,GAAGH,UAAU,CAACU,cAAX,CAA0BP,KAA1B,EAAiC;AAAEQ,UAAAA,eAAe,EAAE;AAAnB,SAAjC,CAAR;AACH,OAFD,QAEST,iBAAiB,CAACC,KAAD,CAF1B;;AAIA,UAAIA,KAAK,IAAI/B,QAAQ,CAACwC,iBAAT,CAA2BT,KAA3B,EAAkCE,OAAlC,CAAb,EAAyD;AACrDC,QAAAA,KAAK,IAAI,CAAT;AACH;;AAEDH,MAAAA,KAAK,GAAGE,OAAR;;AACA,SAAG;AACCF,QAAAA,KAAK,GAAGH,UAAU,CAACa,aAAX,CAAyBV,KAAzB,EAAgC;AAAEQ,UAAAA,eAAe,EAAE;AAAnB,SAAhC,CAAR;AACH,OAFD,QAEST,iBAAiB,CAACC,KAAD,CAF1B;;AAIA,UAAIA,KAAK,IAAI/B,QAAQ,CAACwC,iBAAT,CAA2BP,OAA3B,EAAoCF,KAApC,CAAb,EAAyD;AACrDM,QAAAA,GAAG,IAAI,CAAP;AACH;;AAED,UAAIH,KAAK,IAAIG,GAAb,EAAkB;AACd,eAAOvC,MAAM,CAAC4C,KAAP,CAAaR,KAAb,EAAoBG,GAAG,GAAG,CAA1B,CAAP;AACH;;AACD,aAAO,EAAP;AACH;;AAED,WAAO;AACH,uBAAiB;AACb,YAAIM,KAAK,GAAGf,UAAU,CAACe,KAAX,CAAiBC,GAAjB,CAAqB,CAACC,IAAD,EAAOC,CAAP,MAAc;AAAEC,UAAAA,UAAU,EAAED,CAAC,GAAG,CAAlB;AAAqBD,UAAAA;AAArB,SAAd,CAArB,CAAZ;;AAEA,YAAI7B,cAAJ,EAAoB;AAChB2B,UAAAA,KAAK,GAAGA,KAAK,CAACK,MAAN,CAAaC,CAAC,IAAIA,CAAC,CAACJ,IAAF,CAAOK,IAAP,OAAkB,EAApC,CAAR;AACH;;AAED,YAAInC,YAAJ,EAAkB;AACd,gBAAMoC,QAAQ,GAAGvB,UAAU,CAACwB,cAAX,EAAjB;AAEA,gBAAMC,YAAY,GAAGvD,MAAM,CAACwD,OAAP,CAAeH,QAAQ,CAACP,GAAT,CAAaX,OAAO,IAAID,mBAAmB,CAACC,OAAD,CAA3C,CAAf,CAArB;AAEAU,UAAAA,KAAK,GAAGA,KAAK,CAACK,MAAN,CAAaC,CAAC,IAAI,CAACnD,MAAM,CAACyD,QAAP,CAAgBF,YAAhB,EAA8BJ,CAAC,CAACF,UAAhC,CAAnB,CAAR;AACH;;AAED,YAAIJ,KAAK,CAACa,MAAN,GAAe1C,GAAnB,EAAwB;AACpBO,UAAAA,OAAO,CAACoC,MAAR,CAAe;AACXtB,YAAAA,GAAG,EAAE;AAAEC,cAAAA,IAAI,EAAE,CAAR;AAAWsB,cAAAA,MAAM,EAAE;AAAnB,aADM;AAEXC,YAAAA,SAAS,EAAE,QAFA;AAGXC,YAAAA,IAAI,EAAE;AACF9C,cAAAA,GADE;AAEF+C,cAAAA,MAAM,EAAElB,KAAK,CAACa;AAFZ;AAHK,WAAf;AAQH;AACJ;;AA1BE,KAAP;AA4BH;;AAjIY,CAAjB","sourcesContent":["/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of lines per file\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed: \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (typeof option === \"object\" && Object.prototype.hasOwnProperty.call(option, \"max\")) {\n            max = option.max;\n        } else if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {number[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return lodash.range(start, end + 1);\n            }\n            return [];\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({ lineNumber: i + 1, text }));\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));\n\n                    lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));\n                }\n\n                if (lines.length > max) {\n                    context.report({\n                        loc: { line: 1, column: 0 },\n                        messageId: \"exceed\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}