{"ast":null,"code":"'use strict';\n\nconst {\n  randomBytes\n} = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n\nconst {\n  isValidStatusCode\n} = require('./validation');\n\nconst {\n  mask: applyMask,\n  toBuffer\n} = require('./buffer-util');\n/**\n * HyBi Sender implementation.\n */\n\n\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n\n\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n    const mask = randomBytes(4);\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  close(code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  doClose(data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(buf, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      }), cb);\n    }\n  }\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n\n\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n\n\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n\n      this._socket.write(list[0]);\n\n      this._socket.write(list[1], cb);\n\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n\n}\n\nmodule.exports = Sender;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-environment-jsdom-fourteen/node_modules/ws/lib/sender.js"],"names":["randomBytes","require","PerMessageDeflate","EMPTY_BUFFER","isValidStatusCode","mask","applyMask","toBuffer","Sender","constructor","socket","extensions","_extensions","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","frame","data","options","merge","readOnly","offset","payloadLength","length","target","Buffer","allocUnsafe","fin","opcode","rsv1","writeUInt16BE","writeUInt32BE","close","code","cb","buf","undefined","TypeError","byteLength","write","enqueue","doClose","sendFrame","ping","doPing","pong","doPong","send","perMessageDeflate","extensionName","binary","compress","_threshold","opts","dispatch","_","dequeue","params","shift","apply","slice","push","list","cork","uncork","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { randomBytes } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    const mask = randomBytes(4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n"]},"metadata":{},"sourceType":"script"}