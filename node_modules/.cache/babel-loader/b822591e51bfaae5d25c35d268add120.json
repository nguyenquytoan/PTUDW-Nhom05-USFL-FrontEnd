{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tapable_1 = require(\"tapable\");\n\nconst compilerHookMap = new WeakMap();\nexports.legacyHookMap = {\n  serviceBeforeStart: 'fork-ts-checker-service-before-start',\n  cancel: 'fork-ts-checker-cancel',\n  serviceStartError: 'fork-ts-checker-service-start-error',\n  waiting: 'fork-ts-checker-waiting',\n  serviceStart: 'fork-ts-checker-service-start',\n  receive: 'fork-ts-checker-receive',\n  serviceOutOfMemory: 'fork-ts-checker-service-out-of-memory',\n  emit: 'fork-ts-checker-emit',\n  done: 'fork-ts-checker-done'\n};\n\nfunction createForkTsCheckerWebpackPluginHooks() {\n  return {\n    serviceBeforeStart: new tapable_1.AsyncSeriesHook([]),\n    cancel: new tapable_1.SyncHook(['cancellationToken']),\n    serviceStartError: new tapable_1.SyncHook(['error']),\n    waiting: new tapable_1.SyncHook(['hasTsLint']),\n    serviceStart: new tapable_1.SyncHook(['tsconfigPath', 'tslintPath', 'watchPaths', 'workersNumber', 'memoryLimit']),\n    receive: new tapable_1.SyncHook(['diagnostics', 'lints']),\n    serviceOutOfMemory: new tapable_1.SyncHook([]),\n    emit: new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed']),\n    done: new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed'])\n  };\n}\n\nfunction getForkTsCheckerWebpackPluginHooks(compiler) {\n  let hooks = compilerHookMap.get(compiler);\n\n  if (hooks === undefined) {\n    hooks = createForkTsCheckerWebpackPluginHooks();\n    compilerHookMap.set(compiler, hooks);\n  }\n\n  return hooks;\n}\n\nexports.getForkTsCheckerWebpackPluginHooks = getForkTsCheckerWebpackPluginHooks;","map":{"version":3,"sources":["../src/hooks.ts"],"names":[],"mappings":";;;;;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAkBA,MAAM,eAAe,GAAG,IAAI,OAAJ,EAAxB;AAEa,OAAA,CAAA,aAAA,GAA4C;AACvD,EAAA,kBAAkB,EAAE,sCADmC;AAEvD,EAAA,MAAM,EAAE,wBAF+C;AAGvD,EAAA,iBAAiB,EAAE,qCAHoC;AAIvD,EAAA,OAAO,EAAE,yBAJ8C;AAKvD,EAAA,YAAY,EAAE,+BALyC;AAMvD,EAAA,OAAO,EAAE,yBAN8C;AAOvD,EAAA,kBAAkB,EAAE,uCAPmC;AAQvD,EAAA,IAAI,EAAE,sBARiD;AASvD,EAAA,IAAI,EAAE;AATiD,CAA5C;;AAYb,SAAS,qCAAT,GAA8C;AAC5C,SAAO;AACL,IAAA,kBAAkB,EAAE,IAAI,SAAA,CAAA,eAAJ,CAAoB,EAApB,CADf;AAEL,IAAA,MAAM,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CAAC,mBAAD,CAAb,CAFH;AAGL,IAAA,iBAAiB,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CAAC,OAAD,CAAb,CAHd;AAIL,IAAA,OAAO,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CAAC,WAAD,CAAb,CAJJ;AAKL,IAAA,YAAY,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CACzB,cADyB,EAEzB,YAFyB,EAGzB,YAHyB,EAIzB,eAJyB,EAKzB,aALyB,CAAb,CALT;AAYL,IAAA,OAAO,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CAAC,aAAD,EAAgB,OAAhB,CAAb,CAZJ;AAaL,IAAA,kBAAkB,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,EAAb,CAbf;AAcL,IAAA,IAAI,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CAAC,aAAD,EAAgB,OAAhB,EAAyB,SAAzB,CAAb,CAdD;AAeL,IAAA,IAAI,EAAE,IAAI,SAAA,CAAA,QAAJ,CAAa,CAAC,aAAD,EAAgB,OAAhB,EAAyB,SAAzB,CAAb;AAfD,GAAP;AAiBD;;AAED,SAAgB,kCAAhB,CAAmD,QAAnD,EAA6E;AAC3E,MAAI,KAAK,GAAG,eAAe,CAAC,GAAhB,CAAoB,QAApB,CAAZ;;AACA,MAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,IAAA,KAAK,GAAG,qCAAqC,EAA7C;AACA,IAAA,eAAe,CAAC,GAAhB,CAAoB,QAApB,EAA8B,KAA9B;AACD;;AACD,SAAO,KAAP;AACD;;AAPD,OAAA,CAAA,kCAAA,GAAA,kCAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tapable_1 = require(\"tapable\");\nconst compilerHookMap = new WeakMap();\nexports.legacyHookMap = {\n    serviceBeforeStart: 'fork-ts-checker-service-before-start',\n    cancel: 'fork-ts-checker-cancel',\n    serviceStartError: 'fork-ts-checker-service-start-error',\n    waiting: 'fork-ts-checker-waiting',\n    serviceStart: 'fork-ts-checker-service-start',\n    receive: 'fork-ts-checker-receive',\n    serviceOutOfMemory: 'fork-ts-checker-service-out-of-memory',\n    emit: 'fork-ts-checker-emit',\n    done: 'fork-ts-checker-done'\n};\nfunction createForkTsCheckerWebpackPluginHooks() {\n    return {\n        serviceBeforeStart: new tapable_1.AsyncSeriesHook([]),\n        cancel: new tapable_1.SyncHook(['cancellationToken']),\n        serviceStartError: new tapable_1.SyncHook(['error']),\n        waiting: new tapable_1.SyncHook(['hasTsLint']),\n        serviceStart: new tapable_1.SyncHook([\n            'tsconfigPath',\n            'tslintPath',\n            'watchPaths',\n            'workersNumber',\n            'memoryLimit'\n        ]),\n        receive: new tapable_1.SyncHook(['diagnostics', 'lints']),\n        serviceOutOfMemory: new tapable_1.SyncHook([]),\n        emit: new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed']),\n        done: new tapable_1.SyncHook(['diagnostics', 'lints', 'elapsed'])\n    };\n}\nfunction getForkTsCheckerWebpackPluginHooks(compiler) {\n    let hooks = compilerHookMap.get(compiler);\n    if (hooks === undefined) {\n        hooks = createForkTsCheckerWebpackPluginHooks();\n        compilerHookMap.set(compiler, hooks);\n    }\n    return hooks;\n}\nexports.getForkTsCheckerWebpackPluginHooks = getForkTsCheckerWebpackPluginHooks;\n//# sourceMappingURL=hooks.js.map"]},"metadata":{},"sourceType":"script"}