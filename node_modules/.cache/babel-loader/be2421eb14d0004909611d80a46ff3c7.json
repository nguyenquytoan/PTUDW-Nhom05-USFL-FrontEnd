{"ast":null,"code":"\"use strict\";\n\nconst {\n  isS,\n  isChar,\n  isNameStartChar,\n  isNameChar,\n  S_LIST,\n  NAME_RE\n} = require(\"xmlchars/xml/1.0/ed5\");\n\nconst {\n  isNCNameStartChar,\n  isNCNameChar,\n  NC_NAME_RE\n} = require(\"xmlchars/xmlns/1.0/ed3\");\n\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nconst XML_ENTITIES = {\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n};\nconst S_INITIAL = \"sInitial\"; // initial state\n\nconst S_BEGIN_WHITESPACE = \"sBeginWhitespace\"; // leading whitespace\n\nconst S_DOCTYPE = \"sDoctype\"; // <!DOCTYPE\n\nconst S_DOCTYPE_QUOTE = \"sDoctypeQuote\"; // <!DOCTYPE \"//blah\n\nconst S_DTD = \"sDTD\"; // <!DOCTYPE \"//blah\" [ ...\n\nconst S_DTD_QUOTED = \"sDTDQuoted\"; // <!DOCTYPE \"//blah\" [ \"foo\n\nconst S_DTD_OPEN_WAKA = \"sDTDOpenWaka\";\nconst S_DTD_OPEN_WAKA_BANG = \"sDTDOpenWakaBang\";\nconst S_DTD_COMMENT = \"sDTDComment\"; // <!--\n\nconst S_DTD_COMMENT_ENDING = \"sDTDCommentEnding\"; // <!-- blah -\n\nconst S_DTD_COMMENT_ENDED = \"sDTDCommentEnded\"; // <!-- blah --\n\nconst S_DTD_PI = \"sDTDPI\"; // <?\n\nconst S_DTD_PI_ENDING = \"sDTDPIEnding\"; // <?hi \"there\" ?\n\nconst S_TEXT = \"sText\"; // general stuff\n\nconst S_ENTITY = \"sEntity\"; // &amp and such\n\nconst S_OPEN_WAKA = \"sOpenWaka\"; // <\n\nconst S_OPEN_WAKA_BANG = \"sOpenWakaBang\"; // <!...\n\nconst S_COMMENT = \"sComment\"; // <!--\n\nconst S_COMMENT_ENDING = \"sCommentEnding\"; // <!-- blah -\n\nconst S_COMMENT_ENDED = \"sCommentEnded\"; // <!-- blah --\n\nconst S_CDATA = \"sCData\"; // <![CDATA[ something\n\nconst S_CDATA_ENDING = \"sCDataEnding\"; // ]\n\nconst S_CDATA_ENDING_2 = \"sCDataEnding2\"; // ]]\n\nconst S_PI_FIRST_CHAR = \"sPIFirstChar\"; // <?hi, first char\n\nconst S_PI_REST = \"sPIRest\"; // <?hi, rest of the name\n\nconst S_PI_BODY = \"sPIBody\"; // <?hi there\n\nconst S_PI_ENDING = \"sPIEnding\"; // <?hi \"there\" ?\n\nconst S_OPEN_TAG = \"sOpenTag\"; // <strong\n\nconst S_OPEN_TAG_SLASH = \"sOpenTagSlash\"; // <strong /\n\nconst S_ATTRIB = \"sAttrib\"; // <a\n\nconst S_ATTRIB_NAME = \"sAttribName\"; // <a foo\n\nconst S_ATTRIB_NAME_SAW_WHITE = \"sAttribNameSawWhite\"; // <a foo _\n\nconst S_ATTRIB_VALUE = \"sAttribValue\"; // <a foo=\n\nconst S_ATTRIB_VALUE_QUOTED = \"sAttribValueQuoted\"; // <a foo=\"bar\n\nconst S_ATTRIB_VALUE_CLOSED = \"sAttribValueClosed\"; // <a foo=\"bar\"\n\nconst S_ATTRIB_VALUE_UNQUOTED = \"sAttribValueUnquoted\"; // <a foo=bar\n\nconst S_CLOSE_TAG = \"sCloseTag\"; // </a\n\nconst S_CLOSE_TAG_SAW_WHITE = \"sCloseTagSawWhite\"; // </a   >\n// These states are internal to sPIBody\n\nconst S_XML_DECL_NAME_START = 1; // <?xml\n\nconst S_XML_DECL_NAME = 2; // <?xml foo\n\nconst S_XML_DECL_EQ = 3; // <?xml foo=\n\nconst S_XML_DECL_VALUE_START = 4; // <?xml foo=\n\nconst S_XML_DECL_VALUE = 5; // <?xml foo=\"bar\"\n\n/**\n * The list of supported events.\n */\n\nexports.EVENTS = [\"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\n\nfunction isQuote(c) {\n  return c === DQUOTE || c === SQUOTE;\n}\n\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n      }\n\n      break;\n\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n      }\n\n      break;\n\n    default:\n  }\n\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n      break;\n\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n\n        case \"\":\n          parser.fail(`the default namespace may not be set to ${uri}.`);\n          break;\n\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n\n      break;\n\n    default:\n  }\n}\n\nfunction nsMappingCheck(parser, mapping) {\n  for (const local of Object.keys(mapping)) {\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n\nfunction isNCName(name) {\n  return NC_NAME_RE.test(name);\n}\n\nfunction isName(name) {\n  return NAME_RE.test(name);\n}\n\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * Data structure for an XML tag.\n *\n * @typedef {object} SaxesTag\n *\n * @property {string} name The tag's name. This is the combination of prefix and\n * global name. For instance ``<a:b>`` would have ``\"a:b\"`` for ``name``.\n *\n * @property {string} prefix The tag's prefix. For instance ``<a:b>`` would have\n * ``\"a\"`` for ``prefix``. Undefined if we do not track namespaces.\n *\n * @property {string} local The tag's local name. For instance ``<a:b>`` would\n * have ``\"b\"`` for ``local``. Undefined if we do not track namespaces.\n *\n * @property {string} uri The namespace URI of this tag. Undefined if we do not\n * track namespaces.\n *\n * @property {Object.<string, SaxesAttribute> | Object.<string, string>}\n * attributes A map of attribute name to attributes. If namespaces are tracked,\n * the values in the map are {@link SaxesAttribute SaxesAttribute}\n * objects. Otherwise, they are strings.\n *\n * @property {Object.<string, string>} ns The namespace bindings in effect.\n *\n * @property {boolean} isSelfClosing Whether the tag is\n * self-closing (e.g. ``<foo/>``).\n *\n */\n\n/**\n * Data structure for an XML attribute\n *\n * @typedef {object} SaxesAttribute\n *\n * @property {string} name The attribute's name. This is the combination of\n * prefix and local name. For instance ``a:b=\"c\"`` would have ``a:b`` for name.\n *\n * @property {string} prefix The attribute's prefix. For instance ``a:b=\"c\"``\n * would have ``\"a\"`` for ``prefix``.\n *\n * @property {string} local The attribute's local name. For instance ``a:b=\"c\"``\n * would have ``\"b\"`` for ``local``.\n *\n * @property {string} uri The namespace URI of this attribute.\n *\n * @property {string} value The attribute's value.\n */\n\n/**\n * @typedef XMLDecl\n *\n * @property {string} [version] The version specified by the XML declaration.\n *\n * @property {string} [encoding] The encoding specified by the XML declaration.\n *\n * @property {string} [standalone] The value of the standalone parameter\n * specified by the XML declaration.\n */\n\n/**\n * @callback ResolvePrefix\n *\n * @param {string} prefix The prefix to check.\n *\n * @returns {string|undefined} The URI corresponding to the prefix, if any.\n */\n\n/**\n * @typedef SaxesOptions\n *\n * @property {boolean} [xmlns] Whether to track namespaces. Unset means\n * ``false``.\n *\n * @property {boolean} [fragment] Whether to accept XML fragments. Unset means\n * ``false``.\n *\n * @property {boolean} [additionalNamespaces] A plain object whose key, value\n * pairs define namespaces known before parsing the XML file. It is not legal\n * to pass bindings for the namespaces ``\"xml\"`` or ``\"xmlns\"``.\n *\n * @property {ResolvePrefix} [resolvePrefix] A function that will be used if the\n * parser cannot resolve a namespace prefix on its own.\n *\n * @property {boolean} [position] Whether to track positions. Unset means\n * ``true``.\n *\n * @property {string} [fileName] A file name to use for error reporting. Leaving\n * this unset will report a file name of \"undefined\". \"File name\" is a loose\n * concept. You could use a URL to some resource, or any descriptive name you\n * like.\n */\n\nclass SaxesParser {\n  /**\n   * @param {SaxesOptions} opt The parser options.\n   */\n  constructor(opt) {\n    this._init(opt);\n  }\n  /**\n   * Reset the parser state.\n   *\n   * @private\n   */\n\n\n  _init(opt) {\n    this.comment = \"\";\n    this.openWakaBang = \"\";\n    this.text = \"\";\n    this.name = \"\";\n    this.doctype = \"\";\n    this.piTarget = \"\";\n    this.piBody = \"\";\n    this.entity = \"\";\n    this.cdata = \"\";\n    this.xmlDeclName = \"\";\n    this.xmlDeclValue = \"\";\n    /**\n     * The options passed to the constructor of this parser.\n     *\n     * @type {SaxesOptions}\n     */\n\n    this.opt = opt || {};\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     *\n     * @type {boolean}\n     */\n\n    this.closed = false;\n    /**\n     * The XML declaration for this document.\n     *\n     * @type {XMLDecl}\n     */\n\n    this.xmlDecl = {\n      version: undefined,\n      encoding: undefined,\n      standalone: undefined\n    };\n    this.q = null;\n    this.tags = [];\n    this.tag = null;\n    this.chunk = \"\";\n    this.chunkPosition = 0;\n    this.i = 0;\n    this.trailingCR = false;\n    this.forbiddenState = FORBIDDEN_START;\n    /**\n     * A map of entity name to expansion.\n     *\n     * @type {Object.<string, string>}\n     */\n\n    this.ENTITIES = Object.create(XML_ENTITIES);\n    this.attribList = []; // The logic is organized so as to minimize the need to check\n    // this.opt.fragment while parsing.\n\n    const fragmentOpt = this.fragmentOpt = !!this.opt.fragment;\n    this.state = fragmentOpt ? S_TEXT : S_INITIAL; // We want these to be all true if we are dealing with a fragment.\n\n    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt; // An XML declaration is intially possible only when parsing whole\n    // documents.\n\n    this.xmlDeclPossible = !fragmentOpt;\n    this.piIsXMLDecl = false;\n    this.xmlDeclState = S_XML_DECL_NAME_START;\n    this.xmlDeclExpects = [\"version\"];\n    this.requiredSeparator = false;\n    this.entityReturnState = undefined;\n    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName;\n      this.processAttribs = this.processAttribsNS;\n      this.pushAttrib = this.pushAttribNS;\n      this.ns = Object.assign({\n        __proto__: null\n      }, rootNS);\n      const additional = this.opt.additionalNamespaces;\n\n      if (additional) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    } else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName;\n      this.processAttribs = this.processAttribsPlain;\n      this.pushAttrib = this.pushAttribPlain;\n    }\n\n    this.trackPosition = this.opt.position !== false;\n    /** The line number the parser is  currently looking at. */\n\n    this.line = 1;\n    /** The column the parser is currently looking at. */\n\n    this.column = 0;\n    this.fileName = this.opt.fileName;\n    this.onready();\n  }\n  /** The stream position the parser is currently looking at. */\n\n\n  get position() {\n    return this.chunkPosition + this.i;\n  }\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Event handler for text data. The default implementation is a no-op.\n   *\n   * @param {string} text The text data encountered by the parser.\n   *\n   */\n\n\n  ontext() {}\n  /**\n   * Event handler for processing instructions. The default implementation is a\n   * no-op.\n   *\n   * @param {{target: string, body: string}} data The target and body of\n   * the processing instruction.\n   */\n\n\n  onprocessinginstruction() {}\n  /**\n   * Event handler for doctype. The default implementation is a no-op.\n   *\n   * @param {string} doctype The doctype contents.\n   */\n\n\n  ondoctype() {}\n  /**\n   * Event handler for comments. The default implementation is a no-op.\n   *\n   * @param {string} comment The comment contents.\n   */\n\n\n  oncomment() {}\n  /**\n   * Event handler for the start of an open tag. This is called as soon as we\n   * have a tag name. The default implementation is a no-op.\n   *\n   * @param {SaxesTag} tag The tag.\n   */\n\n\n  onopentagstart() {}\n  /**\n   * Event handler for an open tag. This is called when the open tag is\n   * complete. (We've encountered the \">\" that ends the open tag.) The default\n   * implementation is a no-op.\n   *\n   * @param {SaxesTag} tag The tag.\n   */\n\n\n  onopentag() {}\n  /**\n   * Event handler for a close tag. Note that for self-closing tags, this is\n   * called right after ``onopentag``. The default implementation is a no-op.\n   *\n   * @param {SaxesTag} tag The tag.\n   */\n\n\n  onclosetag() {}\n  /**\n   * Event handler for a CDATA section. This is called when ending the\n   * CDATA section. The default implementation is a no-op.\n   *\n   * @param {string} cdata The contents of the CDATA section.\n   */\n\n\n  oncdata() {}\n  /**\n   * Event handler for the stream end. This is called when the stream has been\n   * closed with ``close`` or by passing ``null`` to ``write``. The default\n   * implementation is a no-op.\n   */\n\n\n  onend() {}\n  /**\n   * Event handler indicating parser readiness . This is called when the parser\n   * is ready to parse a new document.  The default implementation is a no-op.\n   */\n\n\n  onready() {}\n  /**\n   * Event handler indicating an error. The default implementation throws the\n   * error. Override with a no-op handler if you don't want this.\n   *\n   * @param {Error} err The error that occurred.\n   */\n\n\n  onerror(err) {\n    throw new Error(err);\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * Report a parsing error. This method is made public so that client code may\n   * check for issues that are outside the scope of this project and can report\n   * errors.\n   *\n   * @param {Error} er The error to report.\n   *\n   * @returns this\n   */\n\n\n  fail(er) {\n    const message = this.trackPosition ? `${this.fileName}:${this.line}:${this.column}: ${er}` : er;\n    this.onerror(new Error(message));\n    return this;\n  }\n  /**\n   * Write a XML data to the parser.\n   *\n   * @param {string} chunk The XML data to write.\n   *\n   * @returns this\n   */\n\n\n  write(chunk) {\n    if (this.closed) {\n      return this.fail(\"cannot write after close; assign an onready handler.\");\n    }\n\n    let end = false;\n\n    if (chunk === null) {\n      end = true;\n      chunk = \"\";\n    }\n\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    } // We checked if performing a pre-decomposition of the string into an array\n    // of single complete characters (``Array.from(chunk)``) would be faster\n    // than the current repeated calls to ``codePointAt``. As of August 2018, it\n    // isn't. (There may be Node-specific code that would perform faster than\n    // ``Array.from`` but don't want to be dependent on Node.)\n\n\n    let limit = chunk.length;\n\n    if (this.trailingCR) {\n      // The previous chunk had a trailing cr. We need to handle it now.\n      chunk = `\\r${chunk}`;\n    }\n\n    if (!end && chunk[limit - 1] === CR) {\n      // The chunk ends with a trailing CR. We cannot know how to handle it\n      // until we get the next chunk or the end of the stream. So save it for\n      // later.\n      limit--;\n      this.trailingCR = true;\n    }\n\n    this.limit = limit;\n    this.chunk = chunk;\n    this.i = 0;\n\n    while (this.i < limit) {\n      this[this.state]();\n    }\n\n    this.chunkPosition += limit;\n    return end ? this.end() : this;\n  }\n  /**\n   * Close the current stream. Perform final well-formedness checks and reset\n   * the parser tstate.\n   *\n   * @returns this\n   */\n\n\n  close() {\n    return this.write(null);\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * @private\n   *\n   * @returns {number} The character read.\n   */\n\n\n  getCode() {\n    const {\n      chunk,\n      i\n    } = this; // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n    let code = chunk.charCodeAt(i);\n    let skip = 1;\n\n    switch (code) {\n      case CR:\n        // We may get NaN if we read past the end of the chunk, which is\n        // fine.\n        if (chunk.charCodeAt(i + 1) === NL) {\n          // A \\r\\n sequence is converted to \\n so we have to skip over the next\n          // character. We already know it has a size of 1 so ++ is fine here.\n          skip++;\n        } // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n        // ahead.\n        // In either case, \\r becomes \\n.\n\n\n        code = NL;\n\n      /* yes, fall through */\n\n      case NL:\n        this.line++;\n        this.column = 0;\n        break;\n\n      default:\n        this.column++;\n\n        if (code >= 0xD800 && code <= 0xDBFF) {\n          code = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n          this.column++;\n          skip++;\n        }\n\n        if (!isChar(code)) {\n          this.fail(\"disallowed character.\");\n        }\n\n    }\n\n    this.i += skip;\n    return code;\n  }\n  /**\n   * @callback CharacterTest\n   *\n   * @private\n   *\n   * @param {string} c The character to test.\n   *\n   * @returns {boolean} ``true`` if the method should continue capturing text,\n   * ``false`` otherwise.\n   */\n\n  /**\n   * Capture characters into a buffer until encountering one of a set of\n   * characters.\n   *\n   * @private\n   *\n   * @param {number[]} chars An array of codepoints. Encountering a character in\n   * the array ends the capture.\n   *\n   * @param {string} buffer The name of the buffer to save into.\n   *\n   * @return {number|undefined} The character code that made the capture end, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n\n\n  captureTo(chars, buffer) {\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this;\n\n    while (this.i < limit) {\n      const c = this.getCode();\n\n      if (chars.includes(c)) {\n        // This is faster than adding codepoints one by one.\n        this[buffer] += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n        return c;\n      }\n    } // This is faster than adding codepoints one by one.\n\n\n    this[buffer] += chunk.substring(start);\n    return undefined;\n  }\n  /**\n   * Capture characters into a buffer until encountering a character.\n   *\n   * @private\n   *\n   * @param {number} char The codepoint that ends the capture.\n   *\n   * @param {string} buffer The name of the buffer to save into.\n   *\n   * @return {boolean} ``true`` if we ran into the character. Otherwise, we ran\n   * into the end of the current chunk.\n   */\n\n\n  captureToChar(char, buffer) {\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this;\n\n    while (this.i < limit) {\n      const c = this.getCode();\n\n      if (c === char) {\n        // This is faster than adding codepoints one by one.\n        this[buffer] += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n        return true;\n      }\n    } // This is faster than adding codepoints one by one.\n\n\n    this[buffer] += chunk.substring(start);\n    return false;\n  }\n  /**\n   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n   * this parser.\n   *\n   * @private\n   *\n   * @return {number|undefined} The character code that made the test fail, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n\n\n  captureNameChars() {\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this;\n\n    while (this.i < limit) {\n      const c = this.getCode();\n\n      if (!isNameChar(c)) {\n        // This is faster than adding codepoints one by one.\n        this.name += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n        return c;\n      }\n    } // This is faster than adding codepoints one by one.\n\n\n    this.name += chunk.substring(start);\n    return undefined;\n  }\n  /**\n   * Capture characters into a buffer while ``this.nameCheck`` run on the\n   * character read returns true.\n   *\n   * @private\n   *\n   * @param {string} buffer The name of the buffer to save into.\n   *\n   * @return {number|undefined} The character code that made the test fail, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n\n\n  captureWhileNameCheck(buffer) {\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this;\n\n    while (this.i < limit) {\n      const c = this.getCode();\n\n      if (!this.nameCheck(c)) {\n        // This is faster than adding codepoints one by one.\n        this[buffer] += chunk.substring(start, this.i - (c <= 0xFFFF ? 1 : 2));\n        return c;\n      }\n    } // This is faster than adding codepoints one by one.\n\n\n    this[buffer] += chunk.substring(start);\n    return undefined;\n  }\n  /**\n   * Skip white spaces.\n   *\n   * @private\n   *\n   * @return {string|undefined} The character that ended the skip, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n\n\n  skipSpaces() {\n    const {\n      limit\n    } = this;\n\n    while (this.i < limit) {\n      const c = this.getCode();\n\n      if (!isS(c)) {\n        return c;\n      }\n    }\n\n    return undefined;\n  } // STATE HANDLERS\n\n  /** @private */\n\n\n  sInitial() {\n    // We are essentially peeking at the first character of the chunk. Since\n    // S_INITIAL can be in effect only when we start working on the first chunk,\n    // the index at which we must look is necessarily 0. Note also that the\n    // following tests do not depend on decoding surrogates.\n    const c = this.chunk.charCodeAt(0); // If the initial character is 0xFEFF, ignore it.\n\n    if (c === 0xFEFF) {\n      this.i++;\n      this.column++;\n    } else if (isS(c)) {\n      this.i++;\n      this.column++; // An XML declaration cannot appear after initial spaces.\n\n      this.xmlDeclPossible = false;\n    }\n\n    this.state = S_BEGIN_WHITESPACE;\n  }\n  /** @private */\n\n\n  sBeginWhitespace() {\n    const c = this.skipSpaces();\n\n    if (c === LESS) {\n      this.state = S_OPEN_WAKA;\n    } else if (c) {\n      // have to process this as a text node.\n      // weird, but happens.\n      if (!this.reportedTextBeforeRoot) {\n        this.fail(\"text data outside of root node.\");\n        this.reportedTextBeforeRoot = true;\n      }\n\n      this.text = String.fromCodePoint(c);\n      this.state = S_TEXT;\n      this.xmlDeclPossible = false;\n    }\n  }\n  /** @private */\n\n\n  sText() {\n    //\n    // We did try a version of saxes where the S_TEXT state was split in two\n    // states: one for text inside the root element, and one for text\n    // outside. This was avoiding having to test this.tags.length to decide what\n    // implementation to actually use.\n    //\n    // Peformance testing on gigabyte-size files did not show any advantage to\n    // using the two states solution instead of the current one. Conversely, it\n    // made the code a bit more complicated elsewhere. For instance, a comment\n    // can appear before the root element so when a comment ended it was\n    // necessary to determine whether to return to the S_TEXT state or to the\n    // new text-outside-root state.\n    //\n    if (this.tags.length !== 0) {\n      this.handleTextInRoot();\n    } else {\n      this.handleTextOutsideRoot();\n    }\n  }\n  /** @private */\n\n\n  handleTextInRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n    //\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this;\n    let {\n      forbiddenState\n    } = this;\n    let c; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    scanLoop: while (this.i < limit) {\n      const code = this.getCode();\n\n      switch (code) {\n        case LESS:\n          this.state = S_OPEN_WAKA;\n          c = code;\n          forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n          break scanLoop;\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n          c = code;\n          forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n          break scanLoop;\n\n        case CLOSE_BRACKET:\n          switch (forbiddenState) {\n            case FORBIDDEN_START:\n              forbiddenState = FORBIDDEN_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET:\n              forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET_BRACKET:\n              break;\n\n            default:\n              throw new Error(\"impossible state\");\n          }\n\n          break;\n\n        case GREATER:\n          if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n            this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n          }\n\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        default:\n          forbiddenState = FORBIDDEN_START;\n      }\n    }\n\n    this.forbiddenState = forbiddenState; // This is faster than adding codepoints one by one.\n\n    this.text += chunk.substring(start, c === undefined ? undefined : this.i - (c <= 0xFFFF ? 1 : 2));\n  }\n  /** @private */\n\n\n  handleTextOutsideRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of non-space characters in the text since these are errors when appearing\n    // outside the document root element.\n    //\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this;\n    let nonSpace = false;\n    let c; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    outRootLoop: while (this.i < limit) {\n      const code = this.getCode();\n\n      switch (code) {\n        case LESS:\n          this.state = S_OPEN_WAKA;\n          c = code; // eslint-disable-next-line no-labels\n\n          break outRootLoop;\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n          c = code;\n          nonSpace = true; // eslint-disable-next-line no-labels\n\n          break outRootLoop;\n\n        default:\n          if (!isS(code)) {\n            nonSpace = true;\n          }\n\n      }\n    } // This is faster than adding codepoints one by one.\n\n\n    this.text += chunk.substring(start, c === undefined ? undefined : this.i - (c <= 0xFFFF ? 1 : 2));\n\n    if (!nonSpace) {\n      return;\n    } // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n    // to avoid reporting errors for every single character that is out of\n    // place.\n\n\n    if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextBeforeRoot = true;\n    }\n\n    if (this.closedRoot && !this.reportedTextAfterRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextAfterRoot = true;\n    }\n  }\n  /** @private */\n\n\n  sOpenWaka() {\n    const c = this.getCode(); // either a /, ?, !, or text is coming next.\n\n    if (isNameStartChar(c)) {\n      this.state = S_OPEN_TAG;\n      this.name = String.fromCodePoint(c);\n      this.xmlDeclPossible = false;\n    } else {\n      switch (c) {\n        case FORWARD_SLASH:\n          this.state = S_CLOSE_TAG;\n          this.xmlDeclPossible = false;\n          break;\n\n        case BANG:\n          this.state = S_OPEN_WAKA_BANG;\n          this.openWakaBang = \"\";\n          this.xmlDeclPossible = false;\n          break;\n\n        case QUESTION:\n          this.state = S_PI_FIRST_CHAR;\n          break;\n\n        default:\n          this.fail(\"disallowed character in tag name.\");\n          this.state = S_TEXT;\n          this.xmlDeclPossible = false;\n      }\n    }\n  }\n  /** @private */\n\n\n  sOpenWakaBang() {\n    this.openWakaBang += String.fromCodePoint(this.getCode());\n\n    switch (this.openWakaBang) {\n      case \"[CDATA[\":\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextAfterRoot = true;\n        }\n\n        this.state = S_CDATA;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"--\":\n        this.state = S_COMMENT;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"DOCTYPE\":\n        this.state = S_DOCTYPE;\n\n        if (this.doctype || this.sawRoot) {\n          this.fail(\"inappropriately located doctype declaration.\");\n        }\n\n        this.openWakaBang = \"\";\n        break;\n\n      default:\n        // 7 happens to be the maximum length of the string that can possibly\n        // match one of the cases above.\n        if (this.openWakaBang.length >= 7) {\n          this.fail(\"incorrect syntax.\");\n        }\n\n    }\n  }\n  /** @private */\n\n\n  sDoctype() {\n    const c = this.captureTo(DOCTYPE_TERMINATOR, \"doctype\");\n\n    if (c === GREATER) {\n      this.state = S_TEXT;\n\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n\n      this.ondoctype(this.doctype);\n      this.doctype = true; // just remember that we saw it.\n    } else if (c) {\n      this.doctype += String.fromCodePoint(c);\n\n      if (c === OPEN_BRACKET) {\n        this.state = S_DTD;\n      } else if (isQuote(c)) {\n        this.state = S_DOCTYPE_QUOTE;\n        this.q = c;\n      }\n    }\n  }\n  /** @private */\n\n\n  sDoctypeQuote() {\n    const {\n      q\n    } = this;\n\n    if (this.captureToChar(q, \"doctype\")) {\n      this.doctype += String.fromCodePoint(q);\n      this.q = null;\n      this.state = S_DOCTYPE;\n    }\n  }\n  /** @private */\n\n\n  sDTD() {\n    const c = this.captureTo(DTD_TERMINATOR, \"doctype\");\n\n    if (!c) {\n      return;\n    }\n\n    this.doctype += String.fromCodePoint(c);\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_DOCTYPE;\n    } else if (c === LESS) {\n      this.state = S_DTD_OPEN_WAKA;\n    } else if (isQuote(c)) {\n      this.state = S_DTD_QUOTED;\n      this.q = c;\n    }\n  }\n  /** @private */\n\n\n  sDTDQuoted() {\n    const {\n      q\n    } = this;\n\n    if (this.captureToChar(q, \"doctype\")) {\n      this.doctype += String.fromCodePoint(q);\n      this.state = S_DTD;\n      this.q = null;\n    }\n  }\n  /** @private */\n\n\n  sDTDOpenWaka() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n\n    switch (c) {\n      case BANG:\n        this.state = S_DTD_OPEN_WAKA_BANG;\n        this.openWakaBang = \"\";\n        break;\n\n      case QUESTION:\n        this.state = S_DTD_PI;\n        break;\n\n      default:\n        this.state = S_DTD;\n    }\n  }\n  /** @private */\n\n\n  sDTDOpenWakaBang() {\n    const char = String.fromCodePoint(this.getCode());\n    const owb = this.openWakaBang += char;\n    this.doctype += char;\n\n    if (owb !== \"-\") {\n      this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n      this.openWakaBang = \"\";\n    }\n  }\n  /** @private */\n\n\n  sDTDComment() {\n    if (this.captureToChar(MINUS, \"doctype\")) {\n      this.doctype += \"-\";\n      this.state = S_DTD_COMMENT_ENDING;\n    }\n  }\n  /** @private */\n\n\n  sDTDCommentEnding() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n    this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n  }\n  /** @private */\n\n\n  sDTDCommentEnded() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    } else {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.state = S_DTD_COMMENT;\n    }\n  }\n  /** @private */\n\n\n  sDTDPI() {\n    if (this.captureToChar(QUESTION, \"doctype\")) {\n      this.doctype += \"?\";\n      this.state = S_DTD_PI_ENDING;\n    }\n  }\n  /** @private */\n\n\n  sDTDPIEnding() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n  }\n  /** @private */\n\n\n  sComment() {\n    if (this.captureToChar(MINUS, \"comment\")) {\n      this.state = S_COMMENT_ENDING;\n    }\n  }\n  /** @private */\n\n\n  sCommentEnding() {\n    const c = this.getCode();\n\n    if (c === MINUS) {\n      this.state = S_COMMENT_ENDED;\n\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n\n      this.oncomment(this.comment);\n      this.comment = \"\";\n    } else {\n      this.comment += `-${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n  }\n  /** @private */\n\n\n  sCommentEnded() {\n    const c = this.getCode();\n\n    if (c !== GREATER) {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.comment += `--${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    } else {\n      this.state = S_TEXT;\n    }\n  }\n  /** @private */\n\n\n  sCData() {\n    if (this.captureToChar(CLOSE_BRACKET, \"cdata\")) {\n      this.state = S_CDATA_ENDING;\n    }\n  }\n  /** @private */\n\n\n  sCDataEnding() {\n    const c = this.getCode();\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_CDATA_ENDING_2;\n    } else {\n      this.cdata += `]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n  /** @private */\n\n\n  sCDataEnding2() {\n    const c = this.getCode();\n\n    switch (c) {\n      case GREATER:\n        if (this.text.length !== 0) {\n          this.closeText();\n        }\n\n        this.oncdata(this.cdata);\n        this.cdata = \"\";\n        this.state = S_TEXT;\n        break;\n\n      case CLOSE_BRACKET:\n        this.cdata += \"]\";\n        break;\n\n      default:\n        this.cdata += `]]${String.fromCodePoint(c)}`;\n        this.state = S_CDATA;\n    }\n  }\n  /** @private */\n\n\n  sPIFirstChar() {\n    const c = this.getCode();\n\n    if (this.nameStartCheck(c)) {\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    } else if (c === QUESTION || isS(c)) {\n      this.fail(\"processing instruction without a target.\");\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    } else {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n  }\n  /** @private */\n\n\n  sPIRest() {\n    const c = this.captureWhileNameCheck(\"piTarget\");\n\n    if (c === QUESTION || isS(c)) {\n      this.piIsXMLDecl = this.piTarget === \"xml\";\n\n      if (this.piIsXMLDecl && !this.xmlDeclPossible) {\n        this.fail(\"an XML declaration must be at the start of the document.\");\n      }\n\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    } else if (c) {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n    }\n  }\n  /** @private */\n\n\n  sPIBody() {\n    let c;\n\n    if (this.piIsXMLDecl) {\n      switch (this.xmlDeclState) {\n        case S_XML_DECL_NAME_START:\n          {\n            c = this.getCode();\n\n            if (isS(c)) {\n              c = this.skipSpaces();\n            } else if (this.requiredSeparator && c !== QUESTION) {\n              this.fail(\"whitespace required.\");\n            }\n\n            this.requiredSeparator = false; // The question mark character is not valid inside any of the XML\n            // declaration name/value pairs.\n\n            if (c === QUESTION) {\n              this.state = S_PI_ENDING;\n              return;\n            }\n\n            if (c) {\n              this.xmlDeclState = S_XML_DECL_NAME;\n              this.xmlDeclName = String.fromCodePoint(c);\n            }\n\n            break;\n          }\n\n        case S_XML_DECL_NAME:\n          c = this.captureTo(XML_DECL_NAME_TERMINATOR, \"xmlDeclName\"); // The question mark character is not valid inside any of the XML\n          // declaration name/value pairs.\n\n          if (c === QUESTION) {\n            this.state = S_PI_ENDING;\n            return;\n          }\n\n          if (isS(c) || c === EQUAL) {\n            if (!this.xmlDeclExpects.includes(this.xmlDeclName)) {\n              switch (this.xmlDeclName.length) {\n                case 0:\n                  this.fail(\"did not expect any more name/value pairs.\");\n                  break;\n\n                case 1:\n                  this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                  break;\n\n                default:\n                  this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n              }\n            }\n\n            this.xmlDeclState = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n          }\n\n          break;\n\n        case S_XML_DECL_EQ:\n          c = this.getCode(); // The question mark character is not valid inside any of the XML\n          // declaration name/value pairs.\n\n          if (c === QUESTION) {\n            this.state = S_PI_ENDING;\n            return;\n          }\n\n          if (!isS(c)) {\n            if (c !== EQUAL) {\n              this.fail(\"value required.\");\n            }\n\n            this.xmlDeclState = S_XML_DECL_VALUE_START;\n          }\n\n          break;\n\n        case S_XML_DECL_VALUE_START:\n          c = this.getCode(); // The question mark character is not valid inside any of the XML\n          // declaration name/value pairs.\n\n          if (c === QUESTION) {\n            this.state = S_PI_ENDING;\n            return;\n          }\n\n          if (!isS(c)) {\n            if (!isQuote(c)) {\n              this.fail(\"value must be quoted.\");\n              this.q = SPACE;\n            } else {\n              this.q = c;\n            }\n\n            this.xmlDeclState = S_XML_DECL_VALUE;\n          }\n\n          break;\n\n        case S_XML_DECL_VALUE:\n          c = this.captureTo([this.q, QUESTION], \"xmlDeclValue\"); // The question mark character is not valid inside any of the XML\n          // declaration name/value pairs.\n\n          if (c === QUESTION) {\n            this.state = S_PI_ENDING;\n            return;\n          }\n\n          if (c) {\n            switch (this.xmlDeclName) {\n              case \"version\":\n                if (!/^1\\.[0-9]+$/.test(this.xmlDeclValue)) {\n                  this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                this.xmlDecl.version = this.xmlDeclValue;\n                break;\n\n              case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(this.xmlDeclValue)) {\n                  this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = this.xmlDeclValue;\n                break;\n\n              case \"standalone\":\n                if (this.xmlDeclValue !== \"yes\" && this.xmlDeclValue !== \"no\") {\n                  this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = this.xmlDeclValue;\n                break;\n\n              default: // We don't need to raise an error here since we've already\n              // raised one when checking what name was expected.\n\n            }\n\n            this.xmlDeclName = this.xmlDeclValue = \"\";\n            this.xmlDeclState = S_XML_DECL_NAME_START;\n            this.requiredSeparator = true;\n          }\n\n          break;\n\n        default:\n          throw new Error(this, `Unknown XML declaration state: ${this.xmlDeclState}`);\n      }\n    } else if (this.piBody.length === 0) {\n      c = this.getCode();\n\n      if (c === QUESTION) {\n        this.state = S_PI_ENDING;\n      } else if (!isS(c)) {\n        this.piBody = String.fromCodePoint(c);\n      }\n    } // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    else if (this.captureToChar(QUESTION, \"piBody\")) {\n        this.state = S_PI_ENDING;\n      }\n  }\n  /** @private */\n\n\n  sPIEnding() {\n    const c = this.getCode();\n\n    if (this.piIsXMLDecl) {\n      if (c === GREATER) {\n        if (this.piTarget !== \"xml\") {\n          this.fail(\"processing instructions are not allowed before root.\");\n        } else if (this.xmlDeclState !== S_XML_DECL_NAME_START) {\n          this.fail(\"XML declaration is incomplete.\");\n        } else if (this.xmlDeclExpects.includes(\"version\")) {\n          this.fail(\"XML declaration must contain a version.\");\n        }\n\n        this.xmlDeclName = this.xmlDeclValue = \"\";\n        this.requiredSeparator = false;\n        this.piTarget = this.piBody = \"\";\n        this.state = S_TEXT;\n      } else {\n        // We got here because the previous character was a ?, but the\n        // question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n      }\n    } else if (c === GREATER) {\n      if (this.piTarget.trim().toLowerCase() === \"xml\") {\n        this.fail(\"the XML declaration must appear at the start of the document.\");\n      }\n\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n\n      this.onprocessinginstruction({\n        target: this.piTarget,\n        body: this.piBody\n      });\n      this.piTarget = this.piBody = \"\";\n      this.state = S_TEXT;\n    } else if (c === QUESTION) {\n      // We ran into ?? as part of a processing instruction. We initially\n      // took the first ? as a sign that the PI was ending, but it is\n      // not. So we have to add it to the body but we take the new ? as a\n      // sign that the PI is ending.\n      this.piBody += \"?\";\n    } else {\n      this.piBody += `?${String.fromCodePoint(c)}`;\n      this.state = S_PI_BODY;\n    }\n\n    this.xmlDeclPossible = false;\n  }\n  /** @private */\n\n\n  sOpenTag() {\n    const c = this.captureNameChars();\n\n    if (!c) {\n      return;\n    }\n\n    const tag = this.tag = {\n      name: this.name,\n      attributes: Object.create(null)\n    };\n\n    if (this.xmlnsOpt) {\n      tag.ns = Object.create(null);\n    }\n\n    if (this.text.length !== 0) {\n      this.closeText();\n    }\n\n    this.onopentagstart(tag);\n    this.sawRoot = true;\n\n    if (!this.fragmentOpt && this.closedRoot) {\n      this.fail(\"documents may contain only one root.\");\n    }\n\n    switch (c) {\n      case GREATER:\n        this.openTag();\n        break;\n\n      case FORWARD_SLASH:\n        this.state = S_OPEN_TAG_SLASH;\n        break;\n\n      default:\n        if (!isS(c)) {\n          this.fail(\"disallowed character in tag name.\");\n        }\n\n        this.state = S_ATTRIB;\n    }\n  }\n  /** @private */\n\n\n  sOpenTagSlash() {\n    const c = this.getCode();\n\n    if (c === GREATER) {\n      this.openSelfClosingTag();\n    } else {\n      this.fail(\"forward-slash in opening tag not followed by >.\");\n      this.state = S_ATTRIB;\n    }\n  }\n  /** @private */\n\n\n  sAttrib() {\n    const c = this.skipSpaces();\n\n    if (!c) {\n      return;\n    }\n\n    if (isNameStartChar(c)) {\n      this.name = String.fromCodePoint(c);\n      this.state = S_ATTRIB_NAME;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n  /** @private */\n\n\n  pushAttribNS(name, value) {\n    const {\n      prefix,\n      local\n    } = this.qname(name);\n    this.attribList.push({\n      name,\n      prefix,\n      local,\n      value,\n      uri: undefined\n    });\n\n    if (prefix === \"xmlns\") {\n      const trimmed = value.trim();\n      this.tag.ns[local] = trimmed;\n      nsPairCheck(this, local, trimmed);\n    } else if (name === \"xmlns\") {\n      const trimmed = value.trim();\n      this.tag.ns[\"\"] = trimmed;\n      nsPairCheck(this, \"\", trimmed);\n    }\n  }\n  /** @private */\n\n\n  pushAttribPlain(name, value) {\n    this.attribList.push({\n      name,\n      value\n    });\n  }\n  /** @private */\n\n\n  sAttribName() {\n    const c = this.captureNameChars();\n\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    } else if (isS(c)) {\n      this.state = S_ATTRIB_NAME_SAW_WHITE;\n    } else if (c === GREATER) {\n      this.fail(\"attribute without value.\");\n      this.pushAttrib(this.name, this.name);\n      this.name = this.text = \"\";\n      this.openTag();\n    } else if (c) {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n  /** @private */\n\n\n  sAttribNameSawWhite() {\n    const c = this.skipSpaces();\n\n    if (!c) {\n      return;\n    }\n\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    } else {\n      this.fail(\"attribute without value.\");\n      this.tag.attributes[this.name] = \"\";\n      this.text = \"\";\n      this.name = \"\";\n\n      if (c === GREATER) {\n        this.openTag();\n      } else if (isNameStartChar(c)) {\n        this.name = String.fromCodePoint(c);\n        this.state = S_ATTRIB_NAME;\n      } else {\n        this.fail(\"disallowed character in attribute name.\");\n        this.state = S_ATTRIB;\n      }\n    }\n  }\n  /** @private */\n\n\n  sAttribValue() {\n    const c = this.getCode();\n\n    if (isQuote(c)) {\n      this.q = c;\n      this.state = S_ATTRIB_VALUE_QUOTED;\n    } else if (!isS(c)) {\n      this.fail(\"unquoted attribute value.\");\n      this.state = S_ATTRIB_VALUE_UNQUOTED;\n      this.text = String.fromCodePoint(c);\n    }\n  }\n  /** @private */\n\n\n  sAttribValueQuoted() {\n    // We deliberately do not use captureTo here. The specialized code we use\n    // here is faster than using captureTo.\n    const {\n      q\n    } = this;\n    const {\n      chunk,\n      limit,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      if (this.i >= limit) {\n        // This is faster than adding codepoints one by one.\n        this.text += chunk.substring(start);\n        return;\n      }\n\n      const code = this.getCode();\n\n      if (code === q || code === AMP || code === LESS) {\n        // This is faster than adding codepoints one by one.\n        const slice = chunk.substring(start, this.i - (code <= 0xFFFF ? 1 : 2));\n\n        switch (code) {\n          case q:\n            this.pushAttrib(this.name, this.text + slice);\n            this.name = this.text = \"\";\n            this.q = null;\n            this.state = S_ATTRIB_VALUE_CLOSED;\n            return;\n\n          case AMP:\n            this.text += slice;\n            this.state = S_ENTITY;\n            this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n            return;\n\n          default:\n            this.text += slice;\n            this.fail(\"disallowed character.\");\n            return;\n        }\n      }\n    }\n  }\n  /** @private */\n\n\n  sAttribValueClosed() {\n    const c = this.getCode();\n\n    if (isS(c)) {\n      this.state = S_ATTRIB;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else if (isNameStartChar(c)) {\n      this.fail(\"no whitespace between attributes.\");\n      this.name = String.fromCodePoint(c);\n      this.state = S_ATTRIB_NAME;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n  /** @private */\n\n\n  sAttribValueUnquoted() {\n    const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR, \"text\");\n\n    if (c === AMP) {\n      this.state = S_ENTITY;\n      this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n    } else if (c === LESS) {\n      this.fail(\"disallowed character.\");\n    } else if (c) {\n      if (this.text.includes(\"]]>\")) {\n        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n      }\n\n      this.pushAttrib(this.name, this.text);\n      this.name = this.text = \"\";\n\n      if (c === GREATER) {\n        this.openTag();\n      } else {\n        this.state = S_ATTRIB;\n      }\n    }\n  }\n  /** @private */\n\n\n  sCloseTag() {\n    const c = this.captureNameChars();\n\n    if (c === GREATER) {\n      this.closeTag();\n    } else if (isS(c)) {\n      this.state = S_CLOSE_TAG_SAW_WHITE;\n    } else if (c) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n  /** @private */\n\n\n  sCloseTagSawWhite() {\n    const c = this.skipSpaces();\n\n    if (c === GREATER) {\n      this.closeTag();\n    } else if (c) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n  /** @private */\n\n\n  sEntity() {\n    if (this.captureToChar(SEMICOLON, \"entity\")) {\n      this.state = this.entityReturnState;\n\n      if (this.entity === \"\") {\n        this.fail(\"empty entity name.\");\n        this.text += \"&;\";\n        return;\n      }\n\n      this.text += this.parseEntity(this.entity);\n      this.entity = \"\";\n    }\n  } // END OF STATE HANDLERS\n\n  /**\n   * End parsing. This performs final well-formedness checks and resets the\n   * parser to a clean state.\n   *\n   * @private\n   *\n   * @returns this\n   */\n\n\n  end() {\n    if (!this.sawRoot) {\n      this.fail(\"document must contain a root element.\");\n    }\n\n    const {\n      tags\n    } = this;\n\n    while (tags.length > 0) {\n      const tag = tags.pop();\n      this.fail(`unclosed tag: ${tag.name}`);\n    }\n\n    if (this.state !== S_INITIAL && this.state !== S_TEXT) {\n      this.fail(\"unexpected end.\");\n    }\n\n    if (this.text.length !== 0) {\n      this.closeText();\n    }\n\n    this.closed = true;\n    this.onend();\n\n    this._init(this.opt);\n\n    return this;\n  }\n  /**\n   * If there's text to emit ``ontext``, emit it.\n   *\n   * @private\n   */\n\n\n  closeText() {\n    this.ontext(this.text);\n    this.text = \"\";\n  }\n  /**\n   * Resolve a namespace prefix.\n   *\n   * @param {string} prefix The prefix to resolve.\n   *\n   * @returns {string|undefined} The namespace URI or ``undefined`` if the\n   * prefix is not defined.\n   */\n\n\n  resolve(prefix) {\n    let uri = this.tag.ns[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    const {\n      tags\n    } = this;\n\n    for (let index = tags.length - 1; index >= 0; index--) {\n      uri = tags[index].ns[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n    }\n\n    uri = this.ns[prefix];\n\n    if (uri) {\n      return uri;\n    }\n\n    const {\n      resolvePrefix\n    } = this.opt;\n    return resolvePrefix ? resolvePrefix(prefix) : undefined;\n  }\n  /**\n   * Parse a qname into its prefix and local name parts.\n   *\n   * @private\n   *\n   * @param {string} name The name to parse\n   *\n   * @returns {{prefix: string, local: string}}\n   */\n\n\n  qname(name) {\n    const colon = name.indexOf(\":\");\n\n    if (colon === -1) {\n      return {\n        prefix: \"\",\n        local: name\n      };\n    }\n\n    const local = name.substring(colon + 1);\n    const prefix = name.substring(0, colon);\n\n    if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n      this.fail(`malformed name: ${name}.`);\n    }\n\n    return {\n      prefix,\n      local\n    };\n  }\n  /** @private */\n\n\n  processAttribsNS() {\n    const {\n      tag,\n      attribList\n    } = this;\n    const {\n      name: tagName,\n      attributes\n    } = tag;\n    {\n      // add namespace info to tag\n      const {\n        prefix,\n        local\n      } = this.qname(tagName);\n      tag.prefix = prefix;\n      tag.local = local;\n      const uri = tag.uri = this.resolve(prefix) || \"\";\n\n      if (prefix) {\n        if (prefix === \"xmlns\") {\n          this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n        }\n\n        if (!uri) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          tag.uri = prefix;\n        }\n      }\n    }\n\n    if (attribList.length === 0) {\n      return;\n    }\n\n    const seen = new Set(); // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n    for (const attr of attribList) {\n      const {\n        name,\n        prefix,\n        local\n      } = attr;\n      let uri;\n      let eqname;\n\n      if (prefix === \"\") {\n        uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n        eqname = name;\n      } else {\n        uri = this.resolve(prefix); // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (!uri) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          uri = prefix;\n        }\n\n        eqname = `{${uri}}${local}`;\n      }\n\n      if (seen.has(eqname)) {\n        this.fail(`duplicate attribute: ${eqname}.`);\n      }\n\n      seen.add(eqname);\n      attr.uri = uri;\n      attributes[name] = attr;\n    }\n\n    this.attribList = [];\n  }\n  /** @private */\n\n\n  processAttribsPlain() {\n    const {\n      attribList,\n      tag: {\n        attributes\n      }\n    } = this;\n\n    for (const {\n      name,\n      value\n    } of attribList) {\n      if (attributes[name]) {\n        this.fail(`duplicate attribute: ${name}.`);\n      }\n\n      attributes[name] = value;\n    }\n\n    this.attribList = [];\n  }\n  /**\n   * Handle a complete open tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag``.\n   *\n   * @private\n   */\n\n\n  openTag() {\n    this.processAttribs();\n    const {\n      tag,\n      tags\n    } = this;\n    tag.isSelfClosing = false; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n\n    this.onopentag(tag);\n    tags.push(tag);\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete self-closing tag. This parser code calls this once it has\n   * seen the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag`` and ``onclosetag``.\n   *\n   * @private\n   */\n\n\n  openSelfClosingTag() {\n    this.processAttribs();\n    const {\n      tag,\n      tags\n    } = this;\n    tag.isSelfClosing = true; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n\n    this.onopentag(tag);\n    this.onclosetag(tag);\n    const top = this.tag = tags[tags.length - 1];\n\n    if (!top) {\n      this.closedRoot = true;\n    }\n\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete close tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onclosetag``.\n   *\n   * @private\n   */\n\n\n  closeTag() {\n    const {\n      tags,\n      name\n    } = this; // Our state after this will be S_TEXT, no matter what, and we can clear\n    // tagName now.\n\n    this.state = S_TEXT;\n    this.name = \"\";\n\n    if (!name) {\n      this.fail(\"weird empty close tag.\");\n      this.text += \"</>\";\n      return;\n    }\n\n    let l = tags.length;\n\n    while (l-- > 0) {\n      const tag = this.tag = tags.pop();\n\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n\n      this.onclosetag(tag);\n\n      if (tag.name === name) {\n        break;\n      }\n\n      this.fail(\"unexpected close tag.\");\n    }\n\n    if (l === 0) {\n      this.closedRoot = true;\n    } else if (l < 0) {\n      this.fail(`unmatched closing tag: ${name}.`);\n      this.text += `</${name}>`;\n    }\n  }\n  /**\n   * Resolves an entity. Makes any necessary well-formedness checks.\n   *\n   * @private\n   *\n   * @param {string} entity The entity to resolve.\n   *\n   * @returns {string} The parsed entity.\n   */\n\n\n  parseEntity(entity) {\n    if (entity[0] !== \"#\") {\n      const defined = this.ENTITIES[entity];\n\n      if (defined) {\n        return defined;\n      }\n\n      this.fail(this.isName(entity) ? \"undefined entity.\" : \"disallowed character in entity name.\");\n      return `&${entity};`;\n    }\n\n    let num = NaN;\n\n    if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n      num = parseInt(entity.slice(2), 16);\n    } else if (/^#[0-9]+$/.test(entity)) {\n      num = parseInt(entity.slice(1), 10);\n    } // The character reference is required to match the CHAR production.\n\n\n    if (!isChar(num)) {\n      this.fail(\"malformed character entity.\");\n      return `&${entity};`;\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n}\n\nexports.SaxesParser = SaxesParser;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/saxes/lib/saxes.js"],"names":["isS","isChar","isNameStartChar","isNameChar","S_LIST","NAME_RE","require","isNCNameStartChar","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","S_INITIAL","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","exports","EVENTS","NL","CR","SPACE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","isQuote","c","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","parser","prefix","uri","fail","nsMappingCheck","mapping","local","Object","keys","isNCName","name","test","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","SaxesParser","constructor","opt","_init","comment","openWakaBang","text","doctype","piTarget","piBody","entity","cdata","xmlDeclName","xmlDeclValue","closed","xmlDecl","version","undefined","encoding","standalone","q","tags","tag","chunk","chunkPosition","i","trailingCR","forbiddenState","ENTITIES","create","attribList","fragmentOpt","fragment","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","piIsXMLDecl","xmlDeclState","xmlDeclExpects","requiredSeparator","entityReturnState","xmlnsOpt","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","assign","additional","additionalNamespaces","processAttribsPlain","pushAttribPlain","trackPosition","position","line","column","fileName","onready","ontext","onprocessinginstruction","ondoctype","oncomment","onopentagstart","onopentag","onclosetag","oncdata","onend","onerror","err","Error","er","message","write","end","toString","limit","length","close","getCode","code","charCodeAt","skip","captureTo","chars","buffer","start","includes","substring","captureToChar","char","captureNameChars","captureWhileNameCheck","skipSpaces","sInitial","sBeginWhitespace","String","fromCodePoint","sText","handleTextInRoot","handleTextOutsideRoot","scanLoop","nonSpace","outRootLoop","sOpenWaka","sOpenWakaBang","sDoctype","closeText","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","owb","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","join","sPIEnding","trim","toLowerCase","target","body","sOpenTag","attributes","openTag","sOpenTagSlash","openSelfClosingTag","sAttrib","value","qname","push","trimmed","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","slice","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","closeTag","sCloseTagSawWhite","sEntity","parseEntity","pop","resolve","index","resolvePrefix","colon","indexOf","tagName","JSON","stringify","seen","Set","attr","eqname","has","add","isSelfClosing","top","l","defined","num","NaN","parseInt"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { isS, isChar, isNameStartChar, isNameChar, S_LIST, NAME_RE } =\n      require(\"xmlchars/xml/1.0/ed5\");\nconst { isNCNameStartChar, isNCNameChar, NC_NAME_RE } = require(\"xmlchars/xmlns/1.0/ed3\");\n\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n\nconst rootNS = {\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE,\n};\n\nconst XML_ENTITIES = {\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\",\n};\n\nconst S_INITIAL = \"sInitial\"; // initial state\nconst S_BEGIN_WHITESPACE = \"sBeginWhitespace\"; // leading whitespace\nconst S_DOCTYPE = \"sDoctype\"; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = \"sDoctypeQuote\"; // <!DOCTYPE \"//blah\nconst S_DTD = \"sDTD\"; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = \"sDTDQuoted\"; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = \"sDTDOpenWaka\";\nconst S_DTD_OPEN_WAKA_BANG = \"sDTDOpenWakaBang\";\nconst S_DTD_COMMENT = \"sDTDComment\"; // <!--\nconst S_DTD_COMMENT_ENDING = \"sDTDCommentEnding\"; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = \"sDTDCommentEnded\"; // <!-- blah --\nconst S_DTD_PI = \"sDTDPI\"; // <?\nconst S_DTD_PI_ENDING = \"sDTDPIEnding\"; // <?hi \"there\" ?\nconst S_TEXT = \"sText\"; // general stuff\nconst S_ENTITY = \"sEntity\"; // &amp and such\nconst S_OPEN_WAKA = \"sOpenWaka\"; // <\nconst S_OPEN_WAKA_BANG = \"sOpenWakaBang\"; // <!...\nconst S_COMMENT = \"sComment\"; // <!--\nconst S_COMMENT_ENDING = \"sCommentEnding\"; // <!-- blah -\nconst S_COMMENT_ENDED = \"sCommentEnded\"; // <!-- blah --\nconst S_CDATA = \"sCData\"; // <![CDATA[ something\nconst S_CDATA_ENDING = \"sCDataEnding\"; // ]\nconst S_CDATA_ENDING_2 = \"sCDataEnding2\"; // ]]\nconst S_PI_FIRST_CHAR = \"sPIFirstChar\"; // <?hi, first char\nconst S_PI_REST = \"sPIRest\"; // <?hi, rest of the name\nconst S_PI_BODY = \"sPIBody\"; // <?hi there\nconst S_PI_ENDING = \"sPIEnding\"; // <?hi \"there\" ?\nconst S_OPEN_TAG = \"sOpenTag\"; // <strong\nconst S_OPEN_TAG_SLASH = \"sOpenTagSlash\"; // <strong /\nconst S_ATTRIB = \"sAttrib\"; // <a\nconst S_ATTRIB_NAME = \"sAttribName\"; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = \"sAttribNameSawWhite\"; // <a foo _\nconst S_ATTRIB_VALUE = \"sAttribValue\"; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = \"sAttribValueQuoted\"; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = \"sAttribValueClosed\"; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = \"sAttribValueUnquoted\"; // <a foo=bar\nconst S_CLOSE_TAG = \"sCloseTag\"; // </a\nconst S_CLOSE_TAG_SAW_WHITE = \"sCloseTagSawWhite\"; // </a   >\n\n// These states are internal to sPIBody\nconst S_XML_DECL_NAME_START = 1; // <?xml\nconst S_XML_DECL_NAME = 2; // <?xml foo\nconst S_XML_DECL_EQ = 3; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 4; // <?xml foo=\nconst S_XML_DECL_VALUE = 5; // <?xml foo=\"bar\"\n\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n  \"text\",\n  \"processinginstruction\",\n  \"doctype\",\n  \"comment\",\n  \"opentagstart\",\n  \"opentag\",\n  \"closetag\",\n  \"cdata\",\n  \"error\",\n  \"end\",\n  \"ready\",\n];\n\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\n\nfunction isQuote(c) {\n  return c === DQUOTE || c === SQUOTE;\n}\n\nconst QUOTES = [DQUOTE, SQUOTE];\n\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n  case \"xml\":\n    if (uri !== XML_NAMESPACE) {\n      parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n    }\n    break;\n  case \"xmlns\":\n    if (uri !== XMLNS_NAMESPACE) {\n      parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n    }\n    break;\n  default:\n  }\n\n  switch (uri) {\n  case XMLNS_NAMESPACE:\n    parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n    break;\n  case XML_NAMESPACE:\n    switch (prefix) {\n    case \"xml\":\n      // Assinging the XML namespace to \"xml\" is fine.\n      break;\n    case \"\":\n      parser.fail(`the default namespace may not be set to ${uri}.`);\n      break;\n    default:\n      parser.fail(\"may not assign the xml namespace to another prefix.\");\n    }\n    break;\n  default:\n  }\n}\n\n\nfunction nsMappingCheck(parser, mapping) {\n  for (const local of Object.keys(mapping)) {\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n\nfunction isNCName(name) {\n  return NC_NAME_RE.test(name);\n}\n\nfunction isName(name) {\n  return NAME_RE.test(name);\n}\n\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n\n/**\n * Data structure for an XML tag.\n *\n * @typedef {object} SaxesTag\n *\n * @property {string} name The tag's name. This is the combination of prefix and\n * global name. For instance ``<a:b>`` would have ``\"a:b\"`` for ``name``.\n *\n * @property {string} prefix The tag's prefix. For instance ``<a:b>`` would have\n * ``\"a\"`` for ``prefix``. Undefined if we do not track namespaces.\n *\n * @property {string} local The tag's local name. For instance ``<a:b>`` would\n * have ``\"b\"`` for ``local``. Undefined if we do not track namespaces.\n *\n * @property {string} uri The namespace URI of this tag. Undefined if we do not\n * track namespaces.\n *\n * @property {Object.<string, SaxesAttribute> | Object.<string, string>}\n * attributes A map of attribute name to attributes. If namespaces are tracked,\n * the values in the map are {@link SaxesAttribute SaxesAttribute}\n * objects. Otherwise, they are strings.\n *\n * @property {Object.<string, string>} ns The namespace bindings in effect.\n *\n * @property {boolean} isSelfClosing Whether the tag is\n * self-closing (e.g. ``<foo/>``).\n *\n */\n\n/**\n * Data structure for an XML attribute\n *\n * @typedef {object} SaxesAttribute\n *\n * @property {string} name The attribute's name. This is the combination of\n * prefix and local name. For instance ``a:b=\"c\"`` would have ``a:b`` for name.\n *\n * @property {string} prefix The attribute's prefix. For instance ``a:b=\"c\"``\n * would have ``\"a\"`` for ``prefix``.\n *\n * @property {string} local The attribute's local name. For instance ``a:b=\"c\"``\n * would have ``\"b\"`` for ``local``.\n *\n * @property {string} uri The namespace URI of this attribute.\n *\n * @property {string} value The attribute's value.\n */\n\n/**\n * @typedef XMLDecl\n *\n * @property {string} [version] The version specified by the XML declaration.\n *\n * @property {string} [encoding] The encoding specified by the XML declaration.\n *\n * @property {string} [standalone] The value of the standalone parameter\n * specified by the XML declaration.\n */\n\n/**\n * @callback ResolvePrefix\n *\n * @param {string} prefix The prefix to check.\n *\n * @returns {string|undefined} The URI corresponding to the prefix, if any.\n */\n\n/**\n * @typedef SaxesOptions\n *\n * @property {boolean} [xmlns] Whether to track namespaces. Unset means\n * ``false``.\n *\n * @property {boolean} [fragment] Whether to accept XML fragments. Unset means\n * ``false``.\n *\n * @property {boolean} [additionalNamespaces] A plain object whose key, value\n * pairs define namespaces known before parsing the XML file. It is not legal\n * to pass bindings for the namespaces ``\"xml\"`` or ``\"xmlns\"``.\n *\n * @property {ResolvePrefix} [resolvePrefix] A function that will be used if the\n * parser cannot resolve a namespace prefix on its own.\n *\n * @property {boolean} [position] Whether to track positions. Unset means\n * ``true``.\n *\n * @property {string} [fileName] A file name to use for error reporting. Leaving\n * this unset will report a file name of \"undefined\". \"File name\" is a loose\n * concept. You could use a URL to some resource, or any descriptive name you\n * like.\n */\n\nclass SaxesParser {\n  /**\n   * @param {SaxesOptions} opt The parser options.\n   */\n  constructor(opt) {\n    this._init(opt);\n  }\n\n  /**\n   * Reset the parser state.\n   *\n   * @private\n   */\n  _init(opt) {\n    this.comment = \"\";\n    this.openWakaBang = \"\";\n    this.text = \"\";\n    this.name = \"\";\n    this.doctype = \"\";\n    this.piTarget = \"\";\n    this.piBody = \"\";\n    this.entity = \"\";\n    this.cdata = \"\";\n    this.xmlDeclName = \"\";\n    this.xmlDeclValue = \"\";\n\n    /**\n     * The options passed to the constructor of this parser.\n     *\n     * @type {SaxesOptions}\n     */\n    this.opt = opt || {};\n\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     *\n     * @type {boolean}\n     */\n    this.closed = false;\n\n    /**\n     * The XML declaration for this document.\n     *\n     * @type {XMLDecl}\n     */\n    this.xmlDecl = {\n      version: undefined,\n      encoding: undefined,\n      standalone: undefined,\n    };\n\n    this.q = null;\n    this.tags = [];\n    this.tag = null;\n    this.chunk = \"\";\n    this.chunkPosition = 0;\n    this.i = 0;\n    this.trailingCR = false;\n    this.forbiddenState = FORBIDDEN_START;\n    /**\n     * A map of entity name to expansion.\n     *\n     * @type {Object.<string, string>}\n     */\n    this.ENTITIES = Object.create(XML_ENTITIES);\n    this.attribList = [];\n\n    // The logic is organized so as to minimize the need to check\n    // this.opt.fragment while parsing.\n\n    const fragmentOpt = this.fragmentOpt = !!this.opt.fragment;\n    this.state = fragmentOpt ? S_TEXT : S_INITIAL;\n    // We want these to be all true if we are dealing with a fragment.\n    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n      this.sawRoot = fragmentOpt;\n    // An XML declaration is intially possible only when parsing whole\n    // documents.\n    this.xmlDeclPossible = !fragmentOpt;\n\n    this.piIsXMLDecl = false;\n    this.xmlDeclState = S_XML_DECL_NAME_START;\n    this.xmlDeclExpects = [\"version\"];\n    this.requiredSeparator = false;\n    this.entityReturnState = undefined;\n    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName;\n      this.processAttribs = this.processAttribsNS;\n      this.pushAttrib = this.pushAttribNS;\n\n      this.ns = Object.assign({ __proto__: null }, rootNS);\n      const additional = this.opt.additionalNamespaces;\n      if (additional) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    }\n    else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName;\n      this.processAttribs = this.processAttribsPlain;\n      this.pushAttrib = this.pushAttribPlain;\n    }\n\n    this.trackPosition = this.opt.position !== false;\n    /** The line number the parser is  currently looking at. */\n    this.line = 1;\n\n    /** The column the parser is currently looking at. */\n    this.column = 0;\n\n    this.fileName = this.opt.fileName;\n    this.onready();\n  }\n\n  /** The stream position the parser is currently looking at. */\n  get position() {\n    return this.chunkPosition + this.i;\n  }\n\n  /* eslint-disable class-methods-use-this */\n  /**\n   * Event handler for text data. The default implementation is a no-op.\n   *\n   * @param {string} text The text data encountered by the parser.\n   *\n   */\n  ontext() {}\n\n  /**\n   * Event handler for processing instructions. The default implementation is a\n   * no-op.\n   *\n   * @param {{target: string, body: string}} data The target and body of\n   * the processing instruction.\n   */\n  onprocessinginstruction() {}\n\n  /**\n   * Event handler for doctype. The default implementation is a no-op.\n   *\n   * @param {string} doctype The doctype contents.\n   */\n  ondoctype() {}\n\n  /**\n   * Event handler for comments. The default implementation is a no-op.\n   *\n   * @param {string} comment The comment contents.\n   */\n  oncomment() {}\n\n  /**\n   * Event handler for the start of an open tag. This is called as soon as we\n   * have a tag name. The default implementation is a no-op.\n   *\n   * @param {SaxesTag} tag The tag.\n   */\n  onopentagstart() {}\n\n  /**\n   * Event handler for an open tag. This is called when the open tag is\n   * complete. (We've encountered the \">\" that ends the open tag.) The default\n   * implementation is a no-op.\n   *\n   * @param {SaxesTag} tag The tag.\n   */\n  onopentag() {}\n\n  /**\n   * Event handler for a close tag. Note that for self-closing tags, this is\n   * called right after ``onopentag``. The default implementation is a no-op.\n   *\n   * @param {SaxesTag} tag The tag.\n   */\n  onclosetag() {}\n\n  /**\n   * Event handler for a CDATA section. This is called when ending the\n   * CDATA section. The default implementation is a no-op.\n   *\n   * @param {string} cdata The contents of the CDATA section.\n   */\n  oncdata() {}\n\n  /**\n   * Event handler for the stream end. This is called when the stream has been\n   * closed with ``close`` or by passing ``null`` to ``write``. The default\n   * implementation is a no-op.\n   */\n  onend() {}\n\n  /**\n   * Event handler indicating parser readiness . This is called when the parser\n   * is ready to parse a new document.  The default implementation is a no-op.\n   */\n  onready() {}\n\n  /**\n   * Event handler indicating an error. The default implementation throws the\n   * error. Override with a no-op handler if you don't want this.\n   *\n   * @param {Error} err The error that occurred.\n   */\n  onerror(err) {\n    throw new Error(err);\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * Report a parsing error. This method is made public so that client code may\n   * check for issues that are outside the scope of this project and can report\n   * errors.\n   *\n   * @param {Error} er The error to report.\n   *\n   * @returns this\n   */\n  fail(er) {\n    const message = (this.trackPosition) ?\n          `${this.fileName}:${this.line}:${this.column}: ${er}` : er;\n\n    this.onerror(new Error(message));\n    return this;\n  }\n\n  /**\n   * Write a XML data to the parser.\n   *\n   * @param {string} chunk The XML data to write.\n   *\n   * @returns this\n   */\n  write(chunk) {\n    if (this.closed) {\n      return this.fail(\"cannot write after close; assign an onready handler.\");\n    }\n\n    let end = false;\n    if (chunk === null) {\n      end = true;\n      chunk = \"\";\n    }\n\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n\n    // We checked if performing a pre-decomposition of the string into an array\n    // of single complete characters (``Array.from(chunk)``) would be faster\n    // than the current repeated calls to ``codePointAt``. As of August 2018, it\n    // isn't. (There may be Node-specific code that would perform faster than\n    // ``Array.from`` but don't want to be dependent on Node.)\n\n    let limit = chunk.length;\n\n    if (this.trailingCR) {\n      // The previous chunk had a trailing cr. We need to handle it now.\n      chunk = `\\r${chunk}`;\n    }\n\n    if (!end && chunk[limit - 1] === CR) {\n      // The chunk ends with a trailing CR. We cannot know how to handle it\n      // until we get the next chunk or the end of the stream. So save it for\n      // later.\n      limit--;\n      this.trailingCR = true;\n    }\n    this.limit = limit;\n\n    this.chunk = chunk;\n    this.i = 0;\n    while (this.i < limit) {\n      this[this.state]();\n    }\n    this.chunkPosition += limit;\n\n    return end ? this.end() : this;\n  }\n\n  /**\n   * Close the current stream. Perform final well-formedness checks and reset\n   * the parser tstate.\n   *\n   * @returns this\n   */\n  close() {\n    return this.write(null);\n  }\n\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * @private\n   *\n   * @returns {number} The character read.\n   */\n  getCode() {\n    const { chunk, i } = this;\n    // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n    let code = chunk.charCodeAt(i);\n\n    let skip = 1;\n    switch (code) {\n    case CR:\n      // We may get NaN if we read past the end of the chunk, which is\n      // fine.\n      if (chunk.charCodeAt(i + 1) === NL) {\n        // A \\r\\n sequence is converted to \\n so we have to skip over the next\n        // character. We already know it has a size of 1 so ++ is fine here.\n        skip++;\n      }\n      // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n      // ahead.\n\n      // In either case, \\r becomes \\n.\n      code = NL;\n      /* yes, fall through */\n    case NL:\n      this.line++;\n      this.column = 0;\n      break;\n    default:\n      this.column++;\n      if (code >= 0xD800 && code <= 0xDBFF) {\n        code = 0x10000 + ((code - 0xD800) * 0x400) +\n          (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.column++;\n        skip++;\n      }\n\n      if (!isChar(code)) {\n        this.fail(\"disallowed character.\");\n      }\n    }\n\n    this.i += skip;\n\n    return code;\n  }\n\n  /**\n   * @callback CharacterTest\n   *\n   * @private\n   *\n   * @param {string} c The character to test.\n   *\n   * @returns {boolean} ``true`` if the method should continue capturing text,\n   * ``false`` otherwise.\n   */\n\n  /**\n   * Capture characters into a buffer until encountering one of a set of\n   * characters.\n   *\n   * @private\n   *\n   * @param {number[]} chars An array of codepoints. Encountering a character in\n   * the array ends the capture.\n   *\n   * @param {string} buffer The name of the buffer to save into.\n   *\n   * @return {number|undefined} The character code that made the capture end, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n  captureTo(chars, buffer) {\n    const { chunk, limit, i: start } = this;\n    while (this.i < limit) {\n      const c = this.getCode();\n      if (chars.includes(c)) {\n        // This is faster than adding codepoints one by one.\n        this[buffer] += chunk.substring(start,\n                                        this.i - (c <= 0xFFFF ? 1 : 2));\n        return c;\n      }\n    }\n\n    // This is faster than adding codepoints one by one.\n    this[buffer] += chunk.substring(start);\n    return undefined;\n  }\n\n  /**\n   * Capture characters into a buffer until encountering a character.\n   *\n   * @private\n   *\n   * @param {number} char The codepoint that ends the capture.\n   *\n   * @param {string} buffer The name of the buffer to save into.\n   *\n   * @return {boolean} ``true`` if we ran into the character. Otherwise, we ran\n   * into the end of the current chunk.\n   */\n  captureToChar(char, buffer) {\n    const { chunk, limit, i: start } = this;\n    while (this.i < limit) {\n      const c = this.getCode();\n      if (c === char) {\n        // This is faster than adding codepoints one by one.\n        this[buffer] += chunk.substring(start,\n                                        this.i - (c <= 0xFFFF ? 1 : 2));\n        return true;\n      }\n    }\n\n    // This is faster than adding codepoints one by one.\n    this[buffer] += chunk.substring(start);\n    return false;\n  }\n\n  /**\n   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n   * this parser.\n   *\n   * @private\n   *\n   * @return {number|undefined} The character code that made the test fail, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n  captureNameChars() {\n    const { chunk, limit, i: start } = this;\n    while (this.i < limit) {\n      const c = this.getCode();\n      if (!isNameChar(c)) {\n        // This is faster than adding codepoints one by one.\n        this.name += chunk.substring(start,\n                                     this.i - (c <= 0xFFFF ? 1 : 2));\n        return c;\n      }\n    }\n\n    // This is faster than adding codepoints one by one.\n    this.name += chunk.substring(start);\n    return undefined;\n  }\n\n  /**\n   * Capture characters into a buffer while ``this.nameCheck`` run on the\n   * character read returns true.\n   *\n   * @private\n   *\n   * @param {string} buffer The name of the buffer to save into.\n   *\n   * @return {number|undefined} The character code that made the test fail, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n  captureWhileNameCheck(buffer) {\n    const { chunk, limit, i: start } = this;\n    while (this.i < limit) {\n      const c = this.getCode();\n      if (!this.nameCheck(c)) {\n        // This is faster than adding codepoints one by one.\n        this[buffer] += chunk.substring(start,\n                                        this.i - (c <= 0xFFFF ? 1 : 2));\n        return c;\n      }\n    }\n\n    // This is faster than adding codepoints one by one.\n    this[buffer] += chunk.substring(start);\n    return undefined;\n  }\n\n  /**\n   * Skip white spaces.\n   *\n   * @private\n   *\n   * @return {string|undefined} The character that ended the skip, or\n   * ``undefined`` if we hit the end of the chunk.\n   */\n  skipSpaces() {\n    const { limit } = this;\n    while (this.i < limit) {\n      const c = this.getCode();\n      if (!isS(c)) {\n        return c;\n      }\n    }\n\n    return undefined;\n  }\n\n  // STATE HANDLERS\n\n  /** @private */\n  sInitial() {\n    // We are essentially peeking at the first character of the chunk. Since\n    // S_INITIAL can be in effect only when we start working on the first chunk,\n    // the index at which we must look is necessarily 0. Note also that the\n    // following tests do not depend on decoding surrogates.\n    const c = this.chunk.charCodeAt(0);\n    // If the initial character is 0xFEFF, ignore it.\n    if (c === 0xFEFF) {\n      this.i++;\n      this.column++;\n    }\n    else if (isS(c)) {\n      this.i++;\n      this.column++;\n      // An XML declaration cannot appear after initial spaces.\n      this.xmlDeclPossible = false;\n    }\n\n    this.state = S_BEGIN_WHITESPACE;\n  }\n\n  /** @private */\n  sBeginWhitespace() {\n    const c = this.skipSpaces();\n    if (c === LESS) {\n      this.state = S_OPEN_WAKA;\n    }\n    else if (c) {\n      // have to process this as a text node.\n      // weird, but happens.\n      if (!this.reportedTextBeforeRoot) {\n        this.fail(\"text data outside of root node.\");\n        this.reportedTextBeforeRoot = true;\n      }\n      this.text = String.fromCodePoint(c);\n      this.state = S_TEXT;\n      this.xmlDeclPossible = false;\n    }\n  }\n\n  /** @private */\n  sText() {\n    //\n    // We did try a version of saxes where the S_TEXT state was split in two\n    // states: one for text inside the root element, and one for text\n    // outside. This was avoiding having to test this.tags.length to decide what\n    // implementation to actually use.\n    //\n    // Peformance testing on gigabyte-size files did not show any advantage to\n    // using the two states solution instead of the current one. Conversely, it\n    // made the code a bit more complicated elsewhere. For instance, a comment\n    // can appear before the root element so when a comment ended it was\n    // necessary to determine whether to return to the S_TEXT state or to the\n    // new text-outside-root state.\n    //\n    if (this.tags.length !== 0) {\n      this.handleTextInRoot();\n    }\n    else {\n      this.handleTextOutsideRoot();\n    }\n  }\n\n  /** @private */\n  handleTextInRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n    //\n    const { chunk, limit, i: start } = this;\n    let { forbiddenState } = this;\n    let c;\n    // eslint-disable-next-line no-labels, no-restricted-syntax\n    scanLoop:\n    while (this.i < limit) {\n      const code = this.getCode();\n      switch (code) {\n      case LESS:\n        this.state = S_OPEN_WAKA;\n        c = code;\n        forbiddenState = FORBIDDEN_START;\n        // eslint-disable-next-line no-labels\n        break scanLoop;\n      case AMP:\n        this.state = S_ENTITY;\n        this.entityReturnState = S_TEXT;\n        c = code;\n        forbiddenState = FORBIDDEN_START;\n        // eslint-disable-next-line no-labels\n        break scanLoop;\n      case CLOSE_BRACKET:\n        switch (forbiddenState) {\n        case FORBIDDEN_START:\n          forbiddenState = FORBIDDEN_BRACKET;\n          break;\n        case FORBIDDEN_BRACKET:\n          forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n          break;\n        case FORBIDDEN_BRACKET_BRACKET:\n          break;\n        default:\n          throw new Error(\"impossible state\");\n        }\n        break;\n      case GREATER:\n        if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n          this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n        }\n        forbiddenState = FORBIDDEN_START;\n        break;\n      default:\n        forbiddenState = FORBIDDEN_START;\n      }\n    }\n    this.forbiddenState = forbiddenState;\n\n    // This is faster than adding codepoints one by one.\n    this.text += chunk.substring(start,\n                                 c === undefined ? undefined :\n                                 (this.i - (c <= 0xFFFF ? 1 : 2)));\n  }\n\n  /** @private */\n  handleTextOutsideRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of non-space characters in the text since these are errors when appearing\n    // outside the document root element.\n    //\n    const { chunk, limit, i: start } = this;\n    let nonSpace = false;\n    let c;\n    // eslint-disable-next-line no-labels, no-restricted-syntax\n    outRootLoop:\n    while (this.i < limit) {\n      const code = this.getCode();\n      switch (code) {\n      case LESS:\n        this.state = S_OPEN_WAKA;\n        c = code;\n        // eslint-disable-next-line no-labels\n        break outRootLoop;\n      case AMP:\n        this.state = S_ENTITY;\n        this.entityReturnState = S_TEXT;\n        c = code;\n        nonSpace = true;\n        // eslint-disable-next-line no-labels\n        break outRootLoop;\n      default:\n        if (!isS(code)) {\n          nonSpace = true;\n        }\n      }\n    }\n\n    // This is faster than adding codepoints one by one.\n    this.text += chunk.substring(start,\n                                 c === undefined ? undefined :\n                                 (this.i - (c <= 0xFFFF ? 1 : 2)));\n\n    if (!nonSpace) {\n      return;\n    }\n\n    // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n    // to avoid reporting errors for every single character that is out of\n    // place.\n    if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextBeforeRoot = true;\n    }\n\n    if (this.closedRoot && !this.reportedTextAfterRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextAfterRoot = true;\n    }\n  }\n\n  /** @private */\n  sOpenWaka() {\n    const c = this.getCode();\n    // either a /, ?, !, or text is coming next.\n    if (isNameStartChar(c)) {\n      this.state = S_OPEN_TAG;\n      this.name = String.fromCodePoint(c);\n      this.xmlDeclPossible = false;\n    }\n    else {\n      switch (c) {\n      case FORWARD_SLASH:\n        this.state = S_CLOSE_TAG;\n        this.xmlDeclPossible = false;\n        break;\n      case BANG:\n        this.state = S_OPEN_WAKA_BANG;\n        this.openWakaBang = \"\";\n        this.xmlDeclPossible = false;\n        break;\n      case QUESTION:\n        this.state = S_PI_FIRST_CHAR;\n        break;\n      default:\n        this.fail(\"disallowed character in tag name.\");\n        this.state = S_TEXT;\n        this.xmlDeclPossible = false;\n      }\n    }\n  }\n\n  /** @private */\n  sOpenWakaBang() {\n    this.openWakaBang += String.fromCodePoint(this.getCode());\n    switch (this.openWakaBang) {\n    case \"[CDATA[\":\n      if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n        this.fail(\"text data outside of root node.\");\n        this.reportedTextBeforeRoot = true;\n      }\n\n      if (this.closedRoot && !this.reportedTextAfterRoot) {\n        this.fail(\"text data outside of root node.\");\n        this.reportedTextAfterRoot = true;\n      }\n      this.state = S_CDATA;\n      this.openWakaBang = \"\";\n      break;\n    case \"--\":\n      this.state = S_COMMENT;\n      this.openWakaBang = \"\";\n      break;\n    case \"DOCTYPE\":\n      this.state = S_DOCTYPE;\n      if (this.doctype || this.sawRoot) {\n        this.fail(\"inappropriately located doctype declaration.\");\n      }\n      this.openWakaBang = \"\";\n      break;\n    default:\n      // 7 happens to be the maximum length of the string that can possibly\n      // match one of the cases above.\n      if (this.openWakaBang.length >= 7) {\n        this.fail(\"incorrect syntax.\");\n      }\n    }\n  }\n\n  /** @private */\n  sDoctype() {\n    const c = this.captureTo(DOCTYPE_TERMINATOR, \"doctype\");\n    if (c === GREATER) {\n      this.state = S_TEXT;\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n      this.ondoctype(this.doctype);\n      this.doctype = true; // just remember that we saw it.\n    }\n    else if (c) {\n      this.doctype += String.fromCodePoint(c);\n      if (c === OPEN_BRACKET) {\n        this.state = S_DTD;\n      }\n      else if (isQuote(c)) {\n        this.state = S_DOCTYPE_QUOTE;\n        this.q = c;\n      }\n    }\n  }\n\n  /** @private */\n  sDoctypeQuote() {\n    const { q } = this;\n    if (this.captureToChar(q, \"doctype\")) {\n      this.doctype += String.fromCodePoint(q);\n      this.q = null;\n      this.state = S_DOCTYPE;\n    }\n  }\n\n  /** @private */\n  sDTD() {\n    const c = this.captureTo(DTD_TERMINATOR, \"doctype\");\n    if (!c) {\n      return;\n    }\n\n    this.doctype += String.fromCodePoint(c);\n    if (c === CLOSE_BRACKET) {\n      this.state = S_DOCTYPE;\n    }\n    else if (c === LESS) {\n      this.state = S_DTD_OPEN_WAKA;\n    }\n    else if (isQuote(c)) {\n      this.state = S_DTD_QUOTED;\n      this.q = c;\n    }\n  }\n\n  /** @private */\n  sDTDQuoted() {\n    const { q } = this;\n    if (this.captureToChar(q, \"doctype\")) {\n      this.doctype += String.fromCodePoint(q);\n      this.state = S_DTD;\n      this.q = null;\n    }\n  }\n\n  /** @private */\n  sDTDOpenWaka() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n    switch (c) {\n    case BANG:\n      this.state = S_DTD_OPEN_WAKA_BANG;\n      this.openWakaBang = \"\";\n      break;\n    case QUESTION:\n      this.state = S_DTD_PI;\n      break;\n    default:\n      this.state = S_DTD;\n    }\n  }\n\n  /** @private */\n  sDTDOpenWakaBang() {\n    const char = String.fromCodePoint(this.getCode());\n    const owb = this.openWakaBang += char;\n    this.doctype += char;\n    if (owb !== \"-\") {\n      this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n      this.openWakaBang = \"\";\n    }\n  }\n\n  /** @private */\n  sDTDComment() {\n    if (this.captureToChar(MINUS, \"doctype\")) {\n      this.doctype += \"-\";\n      this.state = S_DTD_COMMENT_ENDING;\n    }\n  }\n\n  /** @private */\n  sDTDCommentEnding() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n    this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n  }\n\n  /** @private */\n  sDTDCommentEnded() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n    else {\n      this.fail(\"malformed comment.\");\n      // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n      this.state = S_DTD_COMMENT;\n    }\n  }\n\n  /** @private */\n  sDTDPI() {\n    if (this.captureToChar(QUESTION, \"doctype\")) {\n      this.doctype += \"?\";\n      this.state = S_DTD_PI_ENDING;\n    }\n  }\n\n  /** @private */\n  sDTDPIEnding() {\n    const c = this.getCode();\n    this.doctype += String.fromCodePoint(c);\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n  }\n\n  /** @private */\n  sComment() {\n    if (this.captureToChar(MINUS, \"comment\")) {\n      this.state = S_COMMENT_ENDING;\n    }\n  }\n\n  /** @private */\n  sCommentEnding() {\n    const c = this.getCode();\n    if (c === MINUS) {\n      this.state = S_COMMENT_ENDED;\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n      this.oncomment(this.comment);\n      this.comment = \"\";\n    }\n    else {\n      this.comment += `-${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n  }\n\n  /** @private */\n  sCommentEnded() {\n    const c = this.getCode();\n    if (c !== GREATER) {\n      this.fail(\"malformed comment.\");\n      // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n      this.comment += `--${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n    else {\n      this.state = S_TEXT;\n    }\n  }\n\n  /** @private */\n  sCData() {\n    if (this.captureToChar(CLOSE_BRACKET, \"cdata\")) {\n      this.state = S_CDATA_ENDING;\n    }\n  }\n\n  /** @private */\n  sCDataEnding() {\n    const c = this.getCode();\n    if (c === CLOSE_BRACKET) {\n      this.state = S_CDATA_ENDING_2;\n    }\n    else {\n      this.cdata += `]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n\n  /** @private */\n  sCDataEnding2() {\n    const c = this.getCode();\n    switch (c) {\n    case GREATER:\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n      this.oncdata(this.cdata);\n      this.cdata = \"\";\n      this.state = S_TEXT;\n      break;\n    case CLOSE_BRACKET:\n      this.cdata += \"]\";\n      break;\n    default:\n      this.cdata += `]]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n\n  /** @private */\n  sPIFirstChar() {\n    const c = this.getCode();\n    if (this.nameStartCheck(c)) {\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n    else if (c === QUESTION || isS(c)) {\n      this.fail(\"processing instruction without a target.\");\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    }\n    else {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n  }\n\n  /** @private */\n  sPIRest() {\n    const c = this.captureWhileNameCheck(\"piTarget\");\n    if ((c === QUESTION || isS(c))) {\n      this.piIsXMLDecl = this.piTarget === \"xml\";\n      if (this.piIsXMLDecl && !this.xmlDeclPossible) {\n        this.fail(\"an XML declaration must be at the start of the document.\");\n      }\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    }\n    else if (c) {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n    }\n  }\n\n  /** @private */\n  sPIBody() {\n    let c;\n    if (this.piIsXMLDecl) {\n      switch (this.xmlDeclState) {\n      case S_XML_DECL_NAME_START: {\n        c = this.getCode();\n        if (isS(c)) {\n          c = this.skipSpaces();\n        }\n        else if (this.requiredSeparator && c !== QUESTION) {\n          this.fail(\"whitespace required.\");\n        }\n        this.requiredSeparator = false;\n\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n          return;\n        }\n\n        if (c) {\n          this.xmlDeclState = S_XML_DECL_NAME;\n          this.xmlDeclName = String.fromCodePoint(c);\n        }\n        break;\n      }\n      case S_XML_DECL_NAME:\n        c = this.captureTo(XML_DECL_NAME_TERMINATOR, \"xmlDeclName\");\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n          return;\n        }\n        if (isS(c) || c === EQUAL) {\n          if (!this.xmlDeclExpects.includes(this.xmlDeclName)) {\n            switch (this.xmlDeclName.length) {\n            case 0:\n              this.fail(\"did not expect any more name/value pairs.\");\n              break;\n            case 1:\n              this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n              break;\n            default:\n              this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n          }\n\n          this.xmlDeclState = (c === EQUAL) ? S_XML_DECL_VALUE_START :\n            S_XML_DECL_EQ;\n        }\n        break;\n      case S_XML_DECL_EQ:\n        c = this.getCode();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n          return;\n        }\n\n        if (!isS(c)) {\n          if (c !== EQUAL) {\n            this.fail(\"value required.\");\n          }\n          this.xmlDeclState = S_XML_DECL_VALUE_START;\n        }\n        break;\n      case S_XML_DECL_VALUE_START:\n        c = this.getCode();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n          return;\n        }\n\n        if (!isS(c)) {\n          if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n          }\n          else {\n            this.q = c;\n          }\n          this.xmlDeclState = S_XML_DECL_VALUE;\n        }\n        break;\n      case S_XML_DECL_VALUE:\n        c = this.captureTo([this.q, QUESTION], \"xmlDeclValue\");\n\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n          this.state = S_PI_ENDING;\n          return;\n        }\n\n        if (c) {\n          switch (this.xmlDeclName) {\n          case \"version\":\n            if (!/^1\\.[0-9]+$/.test(this.xmlDeclValue)) {\n              this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n            }\n            this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n            this.xmlDecl.version = this.xmlDeclValue;\n            break;\n          case \"encoding\":\n            if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(this.xmlDeclValue)) {\n              this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n            }\n            this.xmlDeclExpects = [\"standalone\"];\n            this.xmlDecl.encoding = this.xmlDeclValue;\n            break;\n          case \"standalone\":\n            if (this.xmlDeclValue !== \"yes\" && this.xmlDeclValue !== \"no\") {\n              this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n            }\n            this.xmlDeclExpects = [];\n            this.xmlDecl.standalone = this.xmlDeclValue;\n            break;\n          default:\n            // We don't need to raise an error here since we've already\n            // raised one when checking what name was expected.\n          }\n          this.xmlDeclName = this.xmlDeclValue = \"\";\n          this.xmlDeclState = S_XML_DECL_NAME_START;\n          this.requiredSeparator = true;\n        }\n        break;\n      default:\n        throw new Error(this,\n                        `Unknown XML declaration state: ${this.xmlDeclState}`);\n      }\n    }\n    else if (this.piBody.length === 0) {\n      c = this.getCode();\n      if (c === QUESTION) {\n        this.state = S_PI_ENDING;\n      }\n      else if (!isS(c)) {\n        this.piBody = String.fromCodePoint(c);\n      }\n    }\n    // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    else if (this.captureToChar(QUESTION, \"piBody\")) {\n      this.state = S_PI_ENDING;\n    }\n  }\n\n  /** @private */\n  sPIEnding() {\n    const c = this.getCode();\n    if (this.piIsXMLDecl) {\n      if (c === GREATER) {\n        if (this.piTarget !== \"xml\") {\n          this.fail(\"processing instructions are not allowed before root.\");\n        }\n        else if (this.xmlDeclState !== S_XML_DECL_NAME_START) {\n          this.fail(\"XML declaration is incomplete.\");\n        }\n        else if (this.xmlDeclExpects.includes(\"version\")) {\n          this.fail(\"XML declaration must contain a version.\");\n        }\n        this.xmlDeclName = this.xmlDeclValue = \"\";\n        this.requiredSeparator = false;\n        this.piTarget = this.piBody = \"\";\n        this.state = S_TEXT;\n      }\n      else {\n        // We got here because the previous character was a ?, but the\n        // question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        this.fail(\n          \"The character ? is disallowed anywhere in XML declarations.\");\n      }\n    }\n    else if (c === GREATER) {\n      if (this.piTarget.trim().toLowerCase() === \"xml\") {\n        this.fail(\"the XML declaration must appear at the start of the document.\");\n      }\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n      this.onprocessinginstruction({\n        target: this.piTarget,\n        body: this.piBody,\n      });\n      this.piTarget = this.piBody = \"\";\n      this.state = S_TEXT;\n    }\n    else if (c === QUESTION) {\n      // We ran into ?? as part of a processing instruction. We initially\n      // took the first ? as a sign that the PI was ending, but it is\n      // not. So we have to add it to the body but we take the new ? as a\n      // sign that the PI is ending.\n      this.piBody += \"?\";\n    }\n    else {\n      this.piBody += `?${String.fromCodePoint(c)}`;\n      this.state = S_PI_BODY;\n    }\n    this.xmlDeclPossible = false;\n  }\n\n  /** @private */\n  sOpenTag() {\n    const c = this.captureNameChars();\n    if (!c) {\n      return;\n    }\n\n    const tag = this.tag = {\n      name: this.name,\n      attributes: Object.create(null),\n    };\n\n    if (this.xmlnsOpt) {\n      tag.ns = Object.create(null);\n    }\n\n    if (this.text.length !== 0) {\n      this.closeText();\n    }\n    this.onopentagstart(tag);\n    this.sawRoot = true;\n    if (!this.fragmentOpt && this.closedRoot) {\n      this.fail(\"documents may contain only one root.\");\n    }\n\n    switch (c) {\n    case GREATER:\n      this.openTag();\n      break;\n    case FORWARD_SLASH:\n      this.state = S_OPEN_TAG_SLASH;\n      break;\n    default:\n      if (!isS(c)) {\n        this.fail(\"disallowed character in tag name.\");\n      }\n      this.state = S_ATTRIB;\n    }\n  }\n\n  /** @private */\n  sOpenTagSlash() {\n    const c = this.getCode();\n    if (c === GREATER) {\n      this.openSelfClosingTag();\n    }\n    else {\n      this.fail(\"forward-slash in opening tag not followed by >.\");\n      this.state = S_ATTRIB;\n    }\n  }\n\n  /** @private */\n  sAttrib() {\n    const c = this.skipSpaces();\n    if (!c) {\n      return;\n    }\n    if (isNameStartChar(c)) {\n      this.name = String.fromCodePoint(c);\n      this.state = S_ATTRIB_NAME;\n    }\n    else if (c === GREATER) {\n      this.openTag();\n    }\n    else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    }\n    else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  /** @private */\n  pushAttribNS(name, value) {\n    const { prefix, local } = this.qname(name);\n    this.attribList.push({ name, prefix, local, value, uri: undefined });\n    if (prefix === \"xmlns\") {\n      const trimmed = value.trim();\n      this.tag.ns[local] = trimmed;\n      nsPairCheck(this, local, trimmed);\n    }\n    else if (name === \"xmlns\") {\n      const trimmed = value.trim();\n      this.tag.ns[\"\"] = trimmed;\n      nsPairCheck(this, \"\", trimmed);\n    }\n  }\n\n  /** @private */\n  pushAttribPlain(name, value) {\n    this.attribList.push({ name, value });\n  }\n\n  /** @private */\n  sAttribName() {\n    const c = this.captureNameChars();\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    }\n    else if (isS(c)) {\n      this.state = S_ATTRIB_NAME_SAW_WHITE;\n    }\n    else if (c === GREATER) {\n      this.fail(\"attribute without value.\");\n      this.pushAttrib(this.name, this.name);\n      this.name = this.text = \"\";\n      this.openTag();\n    }\n    else if (c) {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  /** @private */\n  sAttribNameSawWhite() {\n    const c = this.skipSpaces();\n    if (!c) {\n      return;\n    }\n\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    }\n    else {\n      this.fail(\"attribute without value.\");\n      this.tag.attributes[this.name] = \"\";\n      this.text = \"\";\n      this.name = \"\";\n      if (c === GREATER) {\n        this.openTag();\n      }\n      else if (isNameStartChar(c)) {\n        this.name = String.fromCodePoint(c);\n        this.state = S_ATTRIB_NAME;\n      }\n      else {\n        this.fail(\"disallowed character in attribute name.\");\n        this.state = S_ATTRIB;\n      }\n    }\n  }\n\n  /** @private */\n  sAttribValue() {\n    const c = this.getCode();\n    if (isQuote(c)) {\n      this.q = c;\n      this.state = S_ATTRIB_VALUE_QUOTED;\n    }\n    else if (!isS(c)) {\n      this.fail(\"unquoted attribute value.\");\n      this.state = S_ATTRIB_VALUE_UNQUOTED;\n      this.text = String.fromCodePoint(c);\n    }\n  }\n\n  /** @private */\n  sAttribValueQuoted() {\n    // We deliberately do not use captureTo here. The specialized code we use\n    // here is faster than using captureTo.\n    const { q } = this;\n    const { chunk, limit, i: start } = this;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (this.i >= limit) {\n        // This is faster than adding codepoints one by one.\n        this.text += chunk.substring(start);\n        return;\n      }\n      const code = this.getCode();\n      if (code === q || code === AMP || code === LESS) {\n        // This is faster than adding codepoints one by one.\n        const slice = chunk.substring(start,\n                                      this.i - (code <= 0xFFFF ? 1 : 2));\n        switch (code) {\n        case q:\n          this.pushAttrib(this.name, this.text + slice);\n          this.name = this.text = \"\";\n          this.q = null;\n          this.state = S_ATTRIB_VALUE_CLOSED;\n          return;\n        case AMP:\n          this.text += slice;\n          this.state = S_ENTITY;\n          this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n          return;\n        default:\n          this.text += slice;\n          this.fail(\"disallowed character.\");\n          return;\n        }\n      }\n    }\n  }\n\n  /** @private */\n  sAttribValueClosed() {\n    const c = this.getCode();\n    if (isS(c)) {\n      this.state = S_ATTRIB;\n    }\n    else if (c === GREATER) {\n      this.openTag();\n    }\n    else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    }\n    else if (isNameStartChar(c)) {\n      this.fail(\"no whitespace between attributes.\");\n      this.name = String.fromCodePoint(c);\n      this.state = S_ATTRIB_NAME;\n    }\n    else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  /** @private */\n  sAttribValueUnquoted() {\n    const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR, \"text\");\n    if (c === AMP) {\n      this.state = S_ENTITY;\n      this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n    }\n    else if (c === LESS) {\n      this.fail(\"disallowed character.\");\n    }\n    else if (c) {\n      if (this.text.includes(\"]]>\")) {\n        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n      }\n      this.pushAttrib(this.name, this.text);\n      this.name = this.text = \"\";\n      if (c === GREATER) {\n        this.openTag();\n      }\n      else {\n        this.state = S_ATTRIB;\n      }\n    }\n  }\n\n  /** @private */\n  sCloseTag() {\n    const c = this.captureNameChars();\n    if (c === GREATER) {\n      this.closeTag();\n    }\n    else if (isS(c)) {\n      this.state = S_CLOSE_TAG_SAW_WHITE;\n    }\n    else if (c) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n\n  /** @private */\n  sCloseTagSawWhite() {\n    const c = this.skipSpaces();\n    if (c === GREATER) {\n      this.closeTag();\n    }\n    else if (c) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n\n  /** @private */\n  sEntity() {\n    if (this.captureToChar(SEMICOLON, \"entity\")) {\n      this.state = this.entityReturnState;\n      if (this.entity === \"\") {\n        this.fail(\"empty entity name.\");\n        this.text += \"&;\";\n        return;\n      }\n      this.text += this.parseEntity(this.entity);\n      this.entity = \"\";\n    }\n  }\n\n  // END OF STATE HANDLERS\n\n  /**\n   * End parsing. This performs final well-formedness checks and resets the\n   * parser to a clean state.\n   *\n   * @private\n   *\n   * @returns this\n   */\n  end() {\n    if (!this.sawRoot) {\n      this.fail(\"document must contain a root element.\");\n    }\n    const { tags } = this;\n    while (tags.length > 0) {\n      const tag = tags.pop();\n      this.fail(`unclosed tag: ${tag.name}`);\n    }\n    if ((this.state !== S_INITIAL) &&\n        (this.state !== S_TEXT)) {\n      this.fail(\"unexpected end.\");\n    }\n    if (this.text.length !== 0) {\n      this.closeText();\n    }\n    this.closed = true;\n    this.onend();\n    this._init(this.opt);\n    return this;\n  }\n\n  /**\n   * If there's text to emit ``ontext``, emit it.\n   *\n   * @private\n   */\n  closeText() {\n    this.ontext(this.text);\n    this.text = \"\";\n  }\n\n  /**\n   * Resolve a namespace prefix.\n   *\n   * @param {string} prefix The prefix to resolve.\n   *\n   * @returns {string|undefined} The namespace URI or ``undefined`` if the\n   * prefix is not defined.\n   */\n  resolve(prefix) {\n    let uri = this.tag.ns[prefix];\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    const { tags } = this;\n    for (let index = tags.length - 1; index >= 0; index--) {\n      uri = tags[index].ns[prefix];\n      if (uri !== undefined) {\n        return uri;\n      }\n    }\n\n    uri = this.ns[prefix];\n    if (uri) {\n      return uri;\n    }\n\n    const { resolvePrefix } = this.opt;\n    return resolvePrefix ? resolvePrefix(prefix) : undefined;\n  }\n\n  /**\n   * Parse a qname into its prefix and local name parts.\n   *\n   * @private\n   *\n   * @param {string} name The name to parse\n   *\n   * @returns {{prefix: string, local: string}}\n   */\n  qname(name) {\n    const colon = name.indexOf(\":\");\n    if (colon === -1) {\n      return { prefix: \"\", local: name };\n    }\n\n    const local = name.substring(colon + 1);\n    const prefix = name.substring(0, colon);\n    if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n      this.fail(`malformed name: ${name}.`);\n    }\n\n    return { prefix, local };\n  }\n\n  /** @private */\n  processAttribsNS() {\n    const { tag, attribList } = this;\n    const { name: tagName, attributes } = tag;\n\n    {\n      // add namespace info to tag\n      const { prefix, local } = this.qname(tagName);\n      tag.prefix = prefix;\n      tag.local = local;\n      const uri = tag.uri = this.resolve(prefix) || \"\";\n\n      if (prefix) {\n        if (prefix === \"xmlns\") {\n          this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n        }\n\n        if (!uri) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          tag.uri = prefix;\n        }\n      }\n    }\n\n    if (attribList.length === 0) {\n      return;\n    }\n\n    const seen = new Set();\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (const attr of attribList) {\n      const { name, prefix, local } = attr;\n      let uri;\n      let eqname;\n      if (prefix === \"\") {\n        uri = (name === \"xmlns\") ? XMLNS_NAMESPACE : \"\";\n        eqname = name;\n      }\n      else {\n        uri = this.resolve(prefix);\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (!uri) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          uri = prefix;\n        }\n        eqname = `{${uri}}${local}`;\n      }\n\n      if (seen.has(eqname)) {\n        this.fail(`duplicate attribute: ${eqname}.`);\n      }\n      seen.add(eqname);\n\n      attr.uri = uri;\n      attributes[name] = attr;\n    }\n\n    this.attribList = [];\n  }\n\n  /** @private */\n  processAttribsPlain() {\n    const { attribList, tag: { attributes } } = this;\n    for (const { name, value } of attribList) {\n      if (attributes[name]) {\n        this.fail(`duplicate attribute: ${name}.`);\n      }\n      attributes[name] = value;\n    }\n\n    this.attribList = [];\n  }\n\n  /**\n   * Handle a complete open tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag``.\n   *\n   * @private\n   */\n  openTag() {\n    this.processAttribs();\n\n    const { tag, tags } = this;\n    tag.isSelfClosing = false;\n\n    // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    this.onopentag(tag);\n    tags.push(tag);\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n\n  /**\n   * Handle a complete self-closing tag. This parser code calls this once it has\n   * seen the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag`` and ``onclosetag``.\n   *\n   * @private\n   */\n  openSelfClosingTag() {\n    this.processAttribs();\n\n    const { tag, tags } = this;\n    tag.isSelfClosing = true;\n\n    // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    this.onopentag(tag);\n    this.onclosetag(tag);\n    const top = this.tag = tags[tags.length - 1];\n    if (!top) {\n      this.closedRoot = true;\n    }\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n\n  /**\n   * Handle a complete close tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onclosetag``.\n   *\n   * @private\n   */\n  closeTag() {\n    const { tags, name } = this;\n\n    // Our state after this will be S_TEXT, no matter what, and we can clear\n    // tagName now.\n    this.state = S_TEXT;\n    this.name = \"\";\n\n    if (!name) {\n      this.fail(\"weird empty close tag.\");\n      this.text += \"</>\";\n      return;\n    }\n\n    let l = tags.length;\n    while (l-- > 0) {\n      const tag = this.tag = tags.pop();\n      if (this.text.length !== 0) {\n        this.closeText();\n      }\n      this.onclosetag(tag);\n      if (tag.name === name) {\n        break;\n      }\n      this.fail(\"unexpected close tag.\");\n    }\n\n    if (l === 0) {\n      this.closedRoot = true;\n    }\n    else if (l < 0) {\n      this.fail(`unmatched closing tag: ${name}.`);\n      this.text += `</${name}>`;\n    }\n  }\n\n  /**\n   * Resolves an entity. Makes any necessary well-formedness checks.\n   *\n   * @private\n   *\n   * @param {string} entity The entity to resolve.\n   *\n   * @returns {string} The parsed entity.\n   */\n  parseEntity(entity) {\n    if (entity[0] !== \"#\") {\n      const defined = this.ENTITIES[entity];\n      if (defined) {\n        return defined;\n      }\n\n      this.fail(this.isName(entity) ? \"undefined entity.\" :\n               \"disallowed character in entity name.\");\n      return `&${entity};`;\n    }\n\n    let num = NaN;\n    if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n      num = parseInt(entity.slice(2), 16);\n    }\n    else if (/^#[0-9]+$/.test(entity)) {\n      num = parseInt(entity.slice(1), 10);\n    }\n\n    // The character reference is required to match the CHAR production.\n    if (!isChar(num)) {\n      this.fail(\"malformed character entity.\");\n      return `&${entity};`;\n    }\n\n    return String.fromCodePoint(num);\n  }\n}\n\nexports.SaxesParser = SaxesParser;\n"]},"metadata":{},"sourceType":"script"}