{"ast":null,"code":"/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require the use of `===` and `!==`\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eqeqeq\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            null: {\n              enum: [\"always\", \"never\", \"ignore\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"smart\", \"allow-null\"]\n        }],\n        additionalItems: false\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || \"always\";\n    const options = context.options[1] || {};\n    const sourceCode = context.getSourceCode();\n    const nullOption = config === \"always\" ? options.null || \"always\" : \"ignore\";\n    const enforceRuleForNull = nullOption === \"always\";\n    const enforceInverseRuleForNull = nullOption === \"never\";\n    /**\n     * Checks if an expression is a typeof expression\n     * @param  {ASTNode} node The node to check\n     * @returns {boolean} if the node is a typeof expression\n     */\n\n    function isTypeOf(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n    /**\n     * Checks if either operand of a binary expression is a typeof operation\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if one of the operands is typeof\n     * @private\n     */\n\n\n    function isTypeOfBinary(node) {\n      return isTypeOf(node.left) || isTypeOf(node.right);\n    }\n    /**\n     * Checks if operands are literals of the same type (via typeof)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are of same type\n     * @private\n     */\n\n\n    function areLiteralsAndSameType(node) {\n      return node.left.type === \"Literal\" && node.right.type === \"Literal\" && typeof node.left.value === typeof node.right.value;\n    }\n    /**\n     * Checks if one of the operands is a literal null\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are null\n     * @private\n     */\n\n\n    function isNullCheck(node) {\n      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n    }\n    /**\n     * Reports a message for this rule.\n     * @param {ASTNode} node The binary expression node that was checked\n     * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node, expectedOperator) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      context.report({\n        node,\n        loc: operatorToken.loc,\n        messageId: \"unexpected\",\n        data: {\n          expectedOperator,\n          actualOperator: node.operator\n        },\n\n        fix(fixer) {\n          // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n            return fixer.replaceText(operatorToken, expectedOperator);\n          }\n\n          return null;\n        }\n\n      });\n    }\n\n    return {\n      BinaryExpression(node) {\n        const isNull = isNullCheck(node);\n\n        if (node.operator !== \"==\" && node.operator !== \"!=\") {\n          if (enforceInverseRuleForNull && isNull) {\n            report(node, node.operator.slice(0, -1));\n          }\n\n          return;\n        }\n\n        if (config === \"smart\" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {\n          return;\n        }\n\n        if (!enforceRuleForNull && isNull) {\n          return;\n        }\n\n        report(node, `${node.operator}=`);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/eqeqeq.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","properties","null","additionalProperties","additionalItems","fixable","messages","unexpected","create","context","config","options","sourceCode","getSourceCode","nullOption","enforceRuleForNull","enforceInverseRuleForNull","isTypeOf","node","operator","isTypeOfBinary","left","right","areLiteralsAndSameType","value","isNullCheck","isNullLiteral","report","expectedOperator","operatorToken","getFirstTokenBetween","token","loc","messageId","data","actualOperator","fix","fixer","replaceText","BinaryExpression","isNull","slice"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eqeqeq\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n\n            context.report({\n                node,\n                loc: operatorToken.loc,\n                messageId: \"unexpected\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}