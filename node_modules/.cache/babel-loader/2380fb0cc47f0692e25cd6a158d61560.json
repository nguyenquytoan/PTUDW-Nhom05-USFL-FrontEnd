{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('acorn')) : typeof define === 'function' && define.amd ? define(['exports', 'acorn'], factory) : (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.loose = {}), global.acorn));\n})(this, function (exports, acorn) {\n  'use strict';\n\n  function noop() {}\n\n  var LooseParser = function LooseParser(input, options) {\n    if (options === void 0) options = {};\n    this.toks = this.constructor.BaseParser.tokenizer(input, options);\n    this.options = this.toks.options;\n    this.input = this.toks.input;\n    this.tok = this.last = {\n      type: acorn.tokTypes.eof,\n      start: 0,\n      end: 0\n    };\n    this.tok.validateRegExpFlags = noop;\n    this.tok.validateRegExpPattern = noop;\n\n    if (this.options.locations) {\n      var here = this.toks.curPosition();\n      this.tok.loc = new acorn.SourceLocation(this.toks, here, here);\n    }\n\n    this.ahead = []; // Tokens ahead\n\n    this.context = []; // Indentation contexted\n\n    this.curIndent = 0;\n    this.curLineStart = 0;\n    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    this.inAsync = false;\n    this.inFunction = false;\n  };\n\n  LooseParser.prototype.startNode = function startNode() {\n    return new acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);\n  };\n\n  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {\n    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;\n  };\n\n  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {\n    if (this.options.locations) {\n      return new acorn.Node(this.toks, pos[0], pos[1]);\n    } else {\n      return new acorn.Node(this.toks, pos);\n    }\n  };\n\n  LooseParser.prototype.finishNode = function finishNode(node, type) {\n    node.type = type;\n    node.end = this.last.end;\n\n    if (this.options.locations) {\n      node.loc.end = this.last.loc.end;\n    }\n\n    if (this.options.ranges) {\n      node.range[1] = this.last.end;\n    }\n\n    return node;\n  };\n\n  LooseParser.prototype.dummyNode = function dummyNode(type) {\n    var dummy = this.startNode();\n    dummy.type = type;\n    dummy.end = dummy.start;\n\n    if (this.options.locations) {\n      dummy.loc.end = dummy.loc.start;\n    }\n\n    if (this.options.ranges) {\n      dummy.range[1] = dummy.start;\n    }\n\n    this.last = {\n      type: acorn.tokTypes.name,\n      start: dummy.start,\n      end: dummy.start,\n      loc: dummy.loc\n    };\n    return dummy;\n  };\n\n  LooseParser.prototype.dummyIdent = function dummyIdent() {\n    var dummy = this.dummyNode(\"Identifier\");\n    dummy.name = \"✖\";\n    return dummy;\n  };\n\n  LooseParser.prototype.dummyString = function dummyString() {\n    var dummy = this.dummyNode(\"Literal\");\n    dummy.value = dummy.raw = \"✖\";\n    return dummy;\n  };\n\n  LooseParser.prototype.eat = function eat(type) {\n    if (this.tok.type === type) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  LooseParser.prototype.isContextual = function isContextual(name) {\n    return this.tok.type === acorn.tokTypes.name && this.tok.value === name;\n  };\n\n  LooseParser.prototype.eatContextual = function eatContextual(name) {\n    return this.tok.value === name && this.eat(acorn.tokTypes.name);\n  };\n\n  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {\n    return this.tok.type === acorn.tokTypes.eof || this.tok.type === acorn.tokTypes.braceR || acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start));\n  };\n\n  LooseParser.prototype.semicolon = function semicolon() {\n    return this.eat(acorn.tokTypes.semi);\n  };\n\n  LooseParser.prototype.expect = function expect(type) {\n    if (this.eat(type)) {\n      return true;\n    }\n\n    for (var i = 1; i <= 2; i++) {\n      if (this.lookAhead(i).type === type) {\n        for (var j = 0; j < i; j++) {\n          this.next();\n        }\n\n        return true;\n      }\n    }\n  };\n\n  LooseParser.prototype.pushCx = function pushCx() {\n    this.context.push(this.curIndent);\n  };\n\n  LooseParser.prototype.popCx = function popCx() {\n    this.curIndent = this.context.pop();\n  };\n\n  LooseParser.prototype.lineEnd = function lineEnd(pos) {\n    while (pos < this.input.length && !acorn.isNewLine(this.input.charCodeAt(pos))) {\n      ++pos;\n    }\n\n    return pos;\n  };\n\n  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {\n    for (var count = 0;; ++pos) {\n      var ch = this.input.charCodeAt(pos);\n\n      if (ch === 32) {\n        ++count;\n      } else if (ch === 9) {\n        count += this.options.tabSize;\n      } else {\n        return count;\n      }\n    }\n  };\n\n  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {\n    if (this.tok.type === closeTok || this.tok.type === acorn.tokTypes.eof) {\n      return true;\n    }\n\n    return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);\n  };\n\n  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {\n    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n      var ch = this.input.charCodeAt(p);\n\n      if (ch !== 9 && ch !== 32) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  LooseParser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  LooseParser.prototype.parse = function parse() {\n    this.next();\n    return this.parseTopLevel();\n  };\n\n  LooseParser.extend = function extend() {\n    var plugins = [],\n        len = arguments.length;\n\n    while (len--) plugins[len] = arguments[len];\n\n    var cls = this;\n\n    for (var i = 0; i < plugins.length; i++) {\n      cls = plugins[i](cls);\n    }\n\n    return cls;\n  };\n\n  LooseParser.parse = function parse(input, options) {\n    return new this(input, options).parse();\n  }; // Allows plugins to extend the base parser / tokenizer used\n\n\n  LooseParser.BaseParser = acorn.Parser;\n  var lp = LooseParser.prototype;\n\n  function isSpace(ch) {\n    return ch < 14 && ch > 8 || ch === 32 || ch === 160 || acorn.isNewLine(ch);\n  }\n\n  lp.next = function () {\n    this.last = this.tok;\n\n    if (this.ahead.length) {\n      this.tok = this.ahead.shift();\n    } else {\n      this.tok = this.readToken();\n    }\n\n    if (this.tok.start >= this.nextLineStart) {\n      while (this.tok.start >= this.nextLineStart) {\n        this.curLineStart = this.nextLineStart;\n        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n      }\n\n      this.curIndent = this.indentationAfter(this.curLineStart);\n    }\n  };\n\n  lp.readToken = function () {\n    for (;;) {\n      try {\n        this.toks.next();\n\n        if (this.toks.type === acorn.tokTypes.dot && this.input.substr(this.toks.end, 1) === \".\" && this.options.ecmaVersion >= 6) {\n          this.toks.end++;\n          this.toks.type = acorn.tokTypes.ellipsis;\n        }\n\n        return new acorn.Token(this.toks);\n      } catch (e) {\n        if (!(e instanceof SyntaxError)) {\n          throw e;\n        } // Try to skip some text, based on the error message, and then continue\n\n\n        var msg = e.message,\n            pos = e.raisedAt,\n            replace = true;\n\n        if (/unterminated/i.test(msg)) {\n          pos = this.lineEnd(e.pos + 1);\n\n          if (/string/.test(msg)) {\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.string,\n              value: this.input.slice(e.pos + 1, pos)\n            };\n          } else if (/regular expr/i.test(msg)) {\n            var re = this.input.slice(e.pos, pos);\n\n            try {\n              re = new RegExp(re);\n            } catch (e) {\n              /* ignore compilation error due to new syntax */\n            }\n\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.regexp,\n              value: re\n            };\n          } else if (/template/.test(msg)) {\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.template,\n              value: this.input.slice(e.pos, pos)\n            };\n          } else {\n            replace = false;\n          }\n        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n          while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) {\n            ++pos;\n          }\n        } else if (/character escape|expected hexadecimal/i.test(msg)) {\n          while (pos < this.input.length) {\n            var ch = this.input.charCodeAt(pos++);\n\n            if (ch === 34 || ch === 39 || acorn.isNewLine(ch)) {\n              break;\n            }\n          }\n        } else if (/unexpected character/i.test(msg)) {\n          pos++;\n          replace = false;\n        } else if (/regular expression/i.test(msg)) {\n          replace = true;\n        } else {\n          throw e;\n        }\n\n        this.resetTo(pos);\n\n        if (replace === true) {\n          replace = {\n            start: pos,\n            end: pos,\n            type: acorn.tokTypes.name,\n            value: \"✖\"\n          };\n        }\n\n        if (replace) {\n          if (this.options.locations) {\n            replace.loc = new acorn.SourceLocation(this.toks, acorn.getLineInfo(this.input, replace.start), acorn.getLineInfo(this.input, replace.end));\n          }\n\n          return replace;\n        }\n      }\n    }\n  };\n\n  lp.resetTo = function (pos) {\n    this.toks.pos = pos;\n    var ch = this.input.charAt(pos - 1);\n    this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n    if (this.options.locations) {\n      this.toks.curLine = 1;\n      this.toks.lineStart = acorn.lineBreakG.lastIndex = 0;\n      var match;\n\n      while ((match = acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n        ++this.toks.curLine;\n        this.toks.lineStart = match.index + match[0].length;\n      }\n    }\n  };\n\n  lp.lookAhead = function (n) {\n    while (n > this.ahead.length) {\n      this.ahead.push(this.readToken());\n    }\n\n    return this.ahead[n - 1];\n  };\n\n  function isDummy(node) {\n    return node.name === \"✖\";\n  }\n\n  var lp$1 = LooseParser.prototype;\n\n  lp$1.parseTopLevel = function () {\n    var node = this.startNodeAt(this.options.locations ? [0, acorn.getLineInfo(this.input, 0)] : 0);\n    node.body = [];\n\n    while (this.tok.type !== acorn.tokTypes.eof) {\n      node.body.push(this.parseStatement());\n    }\n\n    this.toks.adaptDirectivePrologue(node.body);\n    this.last = this.tok;\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\");\n  };\n\n  lp$1.parseStatement = function () {\n    var starttype = this.tok.type,\n        node = this.startNode(),\n        kind;\n\n    if (this.toks.isLet()) {\n      starttype = acorn.tokTypes._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case acorn.tokTypes._break:\n      case acorn.tokTypes._continue:\n        this.next();\n        var isBreak = starttype === acorn.tokTypes._break;\n\n        if (this.semicolon() || this.canInsertSemicolon()) {\n          node.label = null;\n        } else {\n          node.label = this.tok.type === acorn.tokTypes.name ? this.parseIdent() : null;\n          this.semicolon();\n        }\n\n        return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n      case acorn.tokTypes._debugger:\n        this.next();\n        this.semicolon();\n        return this.finishNode(node, \"DebuggerStatement\");\n\n      case acorn.tokTypes._do:\n        this.next();\n        node.body = this.parseStatement();\n        node.test = this.eat(acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n        this.semicolon();\n        return this.finishNode(node, \"DoWhileStatement\");\n\n      case acorn.tokTypes._for:\n        this.next(); // `for` keyword\n\n        var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n        this.pushCx();\n        this.expect(acorn.tokTypes.parenL);\n\n        if (this.tok.type === acorn.tokTypes.semi) {\n          return this.parseFor(node, null);\n        }\n\n        var isLet = this.toks.isLet();\n\n        if (isLet || this.tok.type === acorn.tokTypes._var || this.tok.type === acorn.tokTypes._const) {\n          var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n\n          if (init$1.declarations.length === 1 && (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\"))) {\n            if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n              node.await = isAwait;\n            }\n\n            return this.parseForIn(node, init$1);\n          }\n\n          return this.parseFor(node, init$1);\n        }\n\n        var init = this.parseExpression(true);\n\n        if (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\")) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n            node.await = isAwait;\n          }\n\n          return this.parseForIn(node, this.toAssignable(init));\n        }\n\n        return this.parseFor(node, init);\n\n      case acorn.tokTypes._function:\n        this.next();\n        return this.parseFunction(node, true);\n\n      case acorn.tokTypes._if:\n        this.next();\n        node.test = this.parseParenExpression();\n        node.consequent = this.parseStatement();\n        node.alternate = this.eat(acorn.tokTypes._else) ? this.parseStatement() : null;\n        return this.finishNode(node, \"IfStatement\");\n\n      case acorn.tokTypes._return:\n        this.next();\n\n        if (this.eat(acorn.tokTypes.semi) || this.canInsertSemicolon()) {\n          node.argument = null;\n        } else {\n          node.argument = this.parseExpression();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ReturnStatement\");\n\n      case acorn.tokTypes._switch:\n        var blockIndent = this.curIndent,\n            line = this.curLineStart;\n        this.next();\n        node.discriminant = this.parseParenExpression();\n        node.cases = [];\n        this.pushCx();\n        this.expect(acorn.tokTypes.braceL);\n        var cur;\n\n        while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {\n          if (this.tok.type === acorn.tokTypes._case || this.tok.type === acorn.tokTypes._default) {\n            var isCase = this.tok.type === acorn.tokTypes._case;\n\n            if (cur) {\n              this.finishNode(cur, \"SwitchCase\");\n            }\n\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            this.next();\n\n            if (isCase) {\n              cur.test = this.parseExpression();\n            } else {\n              cur.test = null;\n            }\n\n            this.expect(acorn.tokTypes.colon);\n          } else {\n            if (!cur) {\n              node.cases.push(cur = this.startNode());\n              cur.consequent = [];\n              cur.test = null;\n            }\n\n            cur.consequent.push(this.parseStatement());\n          }\n        }\n\n        if (cur) {\n          this.finishNode(cur, \"SwitchCase\");\n        }\n\n        this.popCx();\n        this.eat(acorn.tokTypes.braceR);\n        return this.finishNode(node, \"SwitchStatement\");\n\n      case acorn.tokTypes._throw:\n        this.next();\n        node.argument = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ThrowStatement\");\n\n      case acorn.tokTypes._try:\n        this.next();\n        node.block = this.parseBlock();\n        node.handler = null;\n\n        if (this.tok.type === acorn.tokTypes._catch) {\n          var clause = this.startNode();\n          this.next();\n\n          if (this.eat(acorn.tokTypes.parenL)) {\n            clause.param = this.toAssignable(this.parseExprAtom(), true);\n            this.expect(acorn.tokTypes.parenR);\n          } else {\n            clause.param = null;\n          }\n\n          clause.body = this.parseBlock();\n          node.handler = this.finishNode(clause, \"CatchClause\");\n        }\n\n        node.finalizer = this.eat(acorn.tokTypes._finally) ? this.parseBlock() : null;\n\n        if (!node.handler && !node.finalizer) {\n          return node.block;\n        }\n\n        return this.finishNode(node, \"TryStatement\");\n\n      case acorn.tokTypes._var:\n      case acorn.tokTypes._const:\n        return this.parseVar(node, false, kind || this.tok.value);\n\n      case acorn.tokTypes._while:\n        this.next();\n        node.test = this.parseParenExpression();\n        node.body = this.parseStatement();\n        return this.finishNode(node, \"WhileStatement\");\n\n      case acorn.tokTypes._with:\n        this.next();\n        node.object = this.parseParenExpression();\n        node.body = this.parseStatement();\n        return this.finishNode(node, \"WithStatement\");\n\n      case acorn.tokTypes.braceL:\n        return this.parseBlock();\n\n      case acorn.tokTypes.semi:\n        this.next();\n        return this.finishNode(node, \"EmptyStatement\");\n\n      case acorn.tokTypes._class:\n        return this.parseClass(true);\n\n      case acorn.tokTypes._import:\n        if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === acorn.tokTypes.parenL) {\n          node.expression = this.parseExpression();\n          this.semicolon();\n          return this.finishNode(node, \"ExpressionStatement\");\n        }\n\n        return this.parseImport();\n\n      case acorn.tokTypes._export:\n        return this.parseExport();\n\n      default:\n        if (this.toks.isAsyncFunction()) {\n          this.next();\n          this.next();\n          return this.parseFunction(node, true, true);\n        }\n\n        var expr = this.parseExpression();\n\n        if (isDummy(expr)) {\n          this.next();\n\n          if (this.tok.type === acorn.tokTypes.eof) {\n            return this.finishNode(node, \"EmptyStatement\");\n          }\n\n          return this.parseStatement();\n        } else if (starttype === acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(acorn.tokTypes.colon)) {\n          node.body = this.parseStatement();\n          node.label = expr;\n          return this.finishNode(node, \"LabeledStatement\");\n        } else {\n          node.expression = expr;\n          this.semicolon();\n          return this.finishNode(node, \"ExpressionStatement\");\n        }\n\n    }\n  };\n\n  lp$1.parseBlock = function () {\n    var node = this.startNode();\n    this.pushCx();\n    this.expect(acorn.tokTypes.braceL);\n    var blockIndent = this.curIndent,\n        line = this.curLineStart;\n    node.body = [];\n\n    while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {\n      node.body.push(this.parseStatement());\n    }\n\n    this.popCx();\n    this.eat(acorn.tokTypes.braceR);\n    return this.finishNode(node, \"BlockStatement\");\n  };\n\n  lp$1.parseFor = function (node, init) {\n    node.init = init;\n    node.test = node.update = null;\n\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.semi) {\n      node.test = this.parseExpression();\n    }\n\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.parenR) {\n      node.update = this.parseExpression();\n    }\n\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"ForStatement\");\n  };\n\n  lp$1.parseForIn = function (node, init) {\n    var type = this.tok.type === acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, type);\n  };\n\n  lp$1.parseVar = function (node, noIn, kind) {\n    node.kind = kind;\n    this.next();\n    node.declarations = [];\n\n    do {\n      var decl = this.startNode();\n      decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n      decl.init = this.eat(acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    } while (this.eat(acorn.tokTypes.comma));\n\n    if (!node.declarations.length) {\n      var decl$1 = this.startNode();\n      decl$1.id = this.dummyIdent();\n      node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n    }\n\n    if (!noIn) {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"VariableDeclaration\");\n  };\n\n  lp$1.parseClass = function (isStatement) {\n    var node = this.startNode();\n    this.next();\n\n    if (this.tok.type === acorn.tokTypes.name) {\n      node.id = this.parseIdent();\n    } else if (isStatement === true) {\n      node.id = this.dummyIdent();\n    } else {\n      node.id = null;\n    }\n\n    node.superClass = this.eat(acorn.tokTypes._extends) ? this.parseExpression() : null;\n    node.body = this.startNode();\n    node.body.body = [];\n    this.pushCx();\n    var indent = this.curIndent + 1,\n        line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n\n    if (this.curIndent + 1 < indent) {\n      indent = this.curIndent;\n      line = this.curLineStart;\n    }\n\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      if (this.semicolon()) {\n        continue;\n      }\n\n      var method = this.startNode(),\n          isGenerator = void 0,\n          isAsync = void 0;\n\n      if (this.options.ecmaVersion >= 6) {\n        method.static = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n\n      this.parsePropertyName(method);\n\n      if (isDummy(method.key)) {\n        if (isDummy(this.parseMaybeAssign())) {\n          this.next();\n        }\n\n        this.eat(acorn.tokTypes.comma);\n        continue;\n      }\n\n      if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" && this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL) {\n        method.static = true;\n        isGenerator = this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        method.static = false;\n      }\n\n      if (!method.computed && method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== acorn.tokTypes.parenL && !this.canInsertSemicolon()) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        isAsync = false;\n      }\n\n      if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" && !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") && this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL) {\n        method.kind = method.key.name;\n        this.parsePropertyName(method);\n        method.value = this.parseMethod(false);\n      } else {\n        if (!method.computed && !method.static && !isGenerator && !isAsync && (method.key.type === \"Identifier\" && method.key.name === \"constructor\" || method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n\n        method.value = this.parseMethod(isGenerator, isAsync);\n      }\n\n      node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n    }\n\n    this.popCx();\n\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n\n      if (this.options.locations) {\n        this.last.loc.end = this.tok.loc.start;\n      }\n    }\n\n    this.semicolon();\n    this.finishNode(node.body, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  };\n\n  lp$1.parseFunction = function (node, isStatement, isAsync) {\n    var oldInAsync = this.inAsync,\n        oldInFunction = this.inFunction;\n    this.initFunction(node);\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = this.eat(acorn.tokTypes.star);\n    }\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n\n    if (this.tok.type === acorn.tokTypes.name) {\n      node.id = this.parseIdent();\n    } else if (isStatement === true) {\n      node.id = this.dummyIdent();\n    }\n\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  };\n\n  lp$1.parseExport = function () {\n    var node = this.startNode();\n    this.next();\n\n    if (this.eat(acorn.tokTypes.star)) {\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    if (this.eat(acorn.tokTypes._default)) {\n      // export default (function foo() {}) // This is FunctionExpression.\n      var isAsync;\n\n      if (this.tok.type === acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n\n        if (isAsync) {\n          this.next();\n        }\n\n        node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n      } else if (this.tok.type === acorn.tokTypes._class) {\n        node.declaration = this.parseClass(\"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n      node.declaration = this.parseStatement();\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifierList();\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n  };\n\n  lp$1.parseImport = function () {\n    var node = this.startNode();\n    this.next();\n\n    if (this.tok.type === acorn.tokTypes.string) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      var elt;\n\n      if (this.tok.type === acorn.tokTypes.name && this.tok.value !== \"from\") {\n        elt = this.startNode();\n        elt.local = this.parseIdent();\n        this.finishNode(elt, \"ImportDefaultSpecifier\");\n        this.eat(acorn.tokTypes.comma);\n      }\n\n      node.specifiers = this.parseImportSpecifiers();\n      node.source = this.eatContextual(\"from\") && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n\n      if (elt) {\n        node.specifiers.unshift(elt);\n      }\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  };\n\n  lp$1.parseImportSpecifiers = function () {\n    var elts = [];\n\n    if (this.tok.type === acorn.tokTypes.star) {\n      var elt = this.startNode();\n      this.next();\n      elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n      elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n    } else {\n      var indent = this.curIndent,\n          line = this.curLineStart,\n          continuedLine = this.nextLineStart;\n      this.pushCx();\n      this.eat(acorn.tokTypes.braceL);\n\n      if (this.curLineStart > continuedLine) {\n        continuedLine = this.curLineStart;\n      }\n\n      while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n        var elt$1 = this.startNode();\n\n        if (this.eat(acorn.tokTypes.star)) {\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n          this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n        } else {\n          if (this.isContextual(\"from\")) {\n            break;\n          }\n\n          elt$1.imported = this.parseIdent();\n\n          if (isDummy(elt$1.imported)) {\n            break;\n          }\n\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n          this.finishNode(elt$1, \"ImportSpecifier\");\n        }\n\n        elts.push(elt$1);\n        this.eat(acorn.tokTypes.comma);\n      }\n\n      this.eat(acorn.tokTypes.braceR);\n      this.popCx();\n    }\n\n    return elts;\n  };\n\n  lp$1.parseExportSpecifierList = function () {\n    var elts = [];\n    var indent = this.curIndent,\n        line = this.curLineStart,\n        continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(acorn.tokTypes.braceL);\n\n    if (this.curLineStart > continuedLine) {\n      continuedLine = this.curLineStart;\n    }\n\n    while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      if (this.isContextual(\"from\")) {\n        break;\n      }\n\n      var elt = this.startNode();\n      elt.local = this.parseIdent();\n\n      if (isDummy(elt.local)) {\n        break;\n      }\n\n      elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n      this.finishNode(elt, \"ExportSpecifier\");\n      elts.push(elt);\n      this.eat(acorn.tokTypes.comma);\n    }\n\n    this.eat(acorn.tokTypes.braceR);\n    this.popCx();\n    return elts;\n  };\n\n  var lp$2 = LooseParser.prototype;\n\n  lp$2.checkLVal = function (expr) {\n    if (!expr) {\n      return expr;\n    }\n\n    switch (expr.type) {\n      case \"Identifier\":\n      case \"MemberExpression\":\n        return expr;\n\n      case \"ParenthesizedExpression\":\n        expr.expression = this.checkLVal(expr.expression);\n        return expr;\n\n      default:\n        return this.dummyIdent();\n    }\n  };\n\n  lp$2.parseExpression = function (noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseMaybeAssign(noIn);\n\n    if (this.tok.type === acorn.tokTypes.comma) {\n      var node = this.startNodeAt(start);\n      node.expressions = [expr];\n\n      while (this.eat(acorn.tokTypes.comma)) {\n        node.expressions.push(this.parseMaybeAssign(noIn));\n      }\n\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  };\n\n  lp$2.parseParenExpression = function () {\n    this.pushCx();\n    this.expect(acorn.tokTypes.parenL);\n    var val = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    return val;\n  };\n\n  lp$2.parseMaybeAssign = function (noIn) {\n    if (this.toks.isContextual(\"yield\")) {\n      var node = this.startNode();\n      this.next();\n\n      if (this.semicolon() || this.canInsertSemicolon() || this.tok.type !== acorn.tokTypes.star && !this.tok.type.startsExpr) {\n        node.delegate = false;\n        node.argument = null;\n      } else {\n        node.delegate = this.eat(acorn.tokTypes.star);\n        node.argument = this.parseMaybeAssign();\n      }\n\n      return this.finishNode(node, \"YieldExpression\");\n    }\n\n    var start = this.storeCurrentPos();\n    var left = this.parseMaybeConditional(noIn);\n\n    if (this.tok.type.isAssign) {\n      var node$1 = this.startNodeAt(start);\n      node$1.operator = this.tok.value;\n      node$1.left = this.tok.type === acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n      this.next();\n      node$1.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node$1, \"AssignmentExpression\");\n    }\n\n    return left;\n  };\n\n  lp$2.parseMaybeConditional = function (noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseExprOps(noIn);\n\n    if (this.eat(acorn.tokTypes.question)) {\n      var node = this.startNodeAt(start);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      node.alternate = this.expect(acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  };\n\n  lp$2.parseExprOps = function (noIn) {\n    var start = this.storeCurrentPos();\n    var indent = this.curIndent,\n        line = this.curLineStart;\n    return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);\n  };\n\n  lp$2.parseExprOp = function (left, start, minPrec, noIn, indent, line) {\n    if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n      return left;\n    }\n\n    var prec = this.tok.type.binop;\n\n    if (prec != null && (!noIn || this.tok.type !== acorn.tokTypes._in)) {\n      if (prec > minPrec) {\n        var node = this.startNodeAt(start);\n        node.left = left;\n        node.operator = this.tok.value;\n        this.next();\n\n        if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n          node.right = this.dummyIdent();\n        } else {\n          var rightStart = this.storeCurrentPos();\n          node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n        }\n\n        this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(node, start, minPrec, noIn, indent, line);\n      }\n    }\n\n    return left;\n  };\n\n  lp$2.parseMaybeUnary = function (sawUnary) {\n    var start = this.storeCurrentPos(),\n        expr;\n\n    if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.tok.type.prefix) {\n      var node = this.startNode(),\n          update = this.tok.type === acorn.tokTypes.incDec;\n\n      if (!update) {\n        sawUnary = true;\n      }\n\n      node.operator = this.tok.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(true);\n\n      if (update) {\n        node.argument = this.checkLVal(node.argument);\n      }\n\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (this.tok.type === acorn.tokTypes.ellipsis) {\n      var node$1 = this.startNode();\n      this.next();\n      node$1.argument = this.parseMaybeUnary(sawUnary);\n      expr = this.finishNode(node$1, \"SpreadElement\");\n    } else {\n      expr = this.parseExprSubscripts();\n\n      while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n        var node$2 = this.startNodeAt(start);\n        node$2.operator = this.tok.value;\n        node$2.prefix = false;\n        node$2.argument = this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$2, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(acorn.tokTypes.starstar)) {\n      var node$3 = this.startNodeAt(start);\n      node$3.operator = \"**\";\n      node$3.left = expr;\n      node$3.right = this.parseMaybeUnary(false);\n      return this.finishNode(node$3, \"BinaryExpression\");\n    }\n\n    return expr;\n  };\n\n  lp$2.parseExprSubscripts = function () {\n    var start = this.storeCurrentPos();\n    return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);\n  };\n\n  lp$2.parseSubscripts = function (base, start, noCalls, startIndent, line) {\n    for (;;) {\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        if (this.tok.type === acorn.tokTypes.dot && this.curIndent === startIndent) {\n          --startIndent;\n        } else {\n          return base;\n        }\n      }\n\n      var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n      if (this.eat(acorn.tokTypes.dot)) {\n        var node = this.startNodeAt(start);\n        node.object = base;\n\n        if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n          node.property = this.dummyIdent();\n        } else {\n          node.property = this.parsePropertyAccessor() || this.dummyIdent();\n        }\n\n        node.computed = false;\n        base = this.finishNode(node, \"MemberExpression\");\n      } else if (this.tok.type === acorn.tokTypes.bracketL) {\n        this.pushCx();\n        this.next();\n        var node$1 = this.startNodeAt(start);\n        node$1.object = base;\n        node$1.property = this.parseExpression();\n        node$1.computed = true;\n        this.popCx();\n        this.expect(acorn.tokTypes.bracketR);\n        base = this.finishNode(node$1, \"MemberExpression\");\n      } else if (!noCalls && this.tok.type === acorn.tokTypes.parenL) {\n        var exprList = this.parseExprList(acorn.tokTypes.parenR);\n\n        if (maybeAsyncArrow && this.eat(acorn.tokTypes.arrow)) {\n          return this.parseArrowExpression(this.startNodeAt(start), exprList, true);\n        }\n\n        var node$2 = this.startNodeAt(start);\n        node$2.callee = base;\n        node$2.arguments = exprList;\n        base = this.finishNode(node$2, \"CallExpression\");\n      } else if (this.tok.type === acorn.tokTypes.backQuote) {\n        var node$3 = this.startNodeAt(start);\n        node$3.tag = base;\n        node$3.quasi = this.parseTemplate();\n        base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n      } else {\n        return base;\n      }\n    }\n  };\n\n  lp$2.parseExprAtom = function () {\n    var node;\n\n    switch (this.tok.type) {\n      case acorn.tokTypes._this:\n      case acorn.tokTypes._super:\n        var type = this.tok.type === acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, type);\n\n      case acorn.tokTypes.name:\n        var start = this.storeCurrentPos();\n        var id = this.parseIdent();\n        var isAsync = false;\n\n        if (id.name === \"async\" && !this.canInsertSemicolon()) {\n          if (this.eat(acorn.tokTypes._function)) {\n            return this.parseFunction(this.startNodeAt(start), false, true);\n          }\n\n          if (this.tok.type === acorn.tokTypes.name) {\n            id = this.parseIdent();\n            isAsync = true;\n          }\n        }\n\n        return this.eat(acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id;\n\n      case acorn.tokTypes.regexp:\n        node = this.startNode();\n        var val = this.tok.value;\n        node.regex = {\n          pattern: val.pattern,\n          flags: val.flags\n        };\n        node.value = val.value;\n        node.raw = this.input.slice(this.tok.start, this.tok.end);\n        this.next();\n        return this.finishNode(node, \"Literal\");\n\n      case acorn.tokTypes.num:\n      case acorn.tokTypes.string:\n        node = this.startNode();\n        node.value = this.tok.value;\n        node.raw = this.input.slice(this.tok.start, this.tok.end);\n\n        if (this.tok.type === acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) {\n          node.bigint = node.raw.slice(0, -1);\n        }\n\n        this.next();\n        return this.finishNode(node, \"Literal\");\n\n      case acorn.tokTypes._null:\n      case acorn.tokTypes._true:\n      case acorn.tokTypes._false:\n        node = this.startNode();\n        node.value = this.tok.type === acorn.tokTypes._null ? null : this.tok.type === acorn.tokTypes._true;\n        node.raw = this.tok.type.keyword;\n        this.next();\n        return this.finishNode(node, \"Literal\");\n\n      case acorn.tokTypes.parenL:\n        var parenStart = this.storeCurrentPos();\n        this.next();\n        var inner = this.parseExpression();\n        this.expect(acorn.tokTypes.parenR);\n\n        if (this.eat(acorn.tokTypes.arrow)) {\n          // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n          var params = inner.expressions || [inner];\n\n          if (params.length && isDummy(params[params.length - 1])) {\n            params.pop();\n          }\n\n          return this.parseArrowExpression(this.startNodeAt(parenStart), params);\n        }\n\n        if (this.options.preserveParens) {\n          var par = this.startNodeAt(parenStart);\n          par.expression = inner;\n          inner = this.finishNode(par, \"ParenthesizedExpression\");\n        }\n\n        return inner;\n\n      case acorn.tokTypes.bracketL:\n        node = this.startNode();\n        node.elements = this.parseExprList(acorn.tokTypes.bracketR, true);\n        return this.finishNode(node, \"ArrayExpression\");\n\n      case acorn.tokTypes.braceL:\n        return this.parseObj();\n\n      case acorn.tokTypes._class:\n        return this.parseClass(false);\n\n      case acorn.tokTypes._function:\n        node = this.startNode();\n        this.next();\n        return this.parseFunction(node, false);\n\n      case acorn.tokTypes._new:\n        return this.parseNew();\n\n      case acorn.tokTypes.backQuote:\n        return this.parseTemplate();\n\n      case acorn.tokTypes._import:\n        if (this.options.ecmaVersion > 10) {\n          return this.parseDynamicImport();\n        } else {\n          return this.dummyIdent();\n        }\n\n      default:\n        return this.dummyIdent();\n    }\n  };\n\n  lp$2.parseDynamicImport = function () {\n    var node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"Import\");\n  };\n\n  lp$2.parseNew = function () {\n    var node = this.startNode(),\n        startIndent = this.curIndent,\n        line = this.curLineStart;\n    var meta = this.parseIdent(true);\n\n    if (this.options.ecmaVersion >= 6 && this.eat(acorn.tokTypes.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      return this.finishNode(node, \"MetaProperty\");\n    }\n\n    var start = this.storeCurrentPos();\n    node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n\n    if (this.tok.type === acorn.tokTypes.parenL) {\n      node.arguments = this.parseExprList(acorn.tokTypes.parenR);\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  };\n\n  lp$2.parseTemplateElement = function () {\n    var elem = this.startNode(); // The loose parser accepts invalid unicode escapes even in untagged templates.\n\n    if (this.tok.type === acorn.tokTypes.invalidTemplate) {\n      elem.value = {\n        raw: this.tok.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.tok.value\n      };\n    }\n\n    this.next();\n    elem.tail = this.tok.type === acorn.tokTypes.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n  };\n\n  lp$2.parseTemplate = function () {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.next();\n      node.expressions.push(this.parseExpression());\n\n      if (this.expect(acorn.tokTypes.braceR)) {\n        curElt = this.parseTemplateElement();\n      } else {\n        curElt = this.startNode();\n        curElt.value = {\n          cooked: \"\",\n          raw: \"\"\n        };\n        curElt.tail = true;\n        this.finishNode(curElt, \"TemplateElement\");\n      }\n\n      node.quasis.push(curElt);\n    }\n\n    this.expect(acorn.tokTypes.backQuote);\n    return this.finishNode(node, \"TemplateLiteral\");\n  };\n\n  lp$2.parseObj = function () {\n    var node = this.startNode();\n    node.properties = [];\n    this.pushCx();\n    var indent = this.curIndent + 1,\n        line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n\n    if (this.curIndent + 1 < indent) {\n      indent = this.curIndent;\n      line = this.curLineStart;\n    }\n\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      var prop = this.startNode(),\n          isGenerator = void 0,\n          isAsync = void 0,\n          start = void 0;\n\n      if (this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.ellipsis)) {\n        prop.argument = this.parseMaybeAssign();\n        node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n        this.eat(acorn.tokTypes.comma);\n        continue;\n      }\n\n      if (this.options.ecmaVersion >= 6) {\n        start = this.storeCurrentPos();\n        prop.method = false;\n        prop.shorthand = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n\n      this.parsePropertyName(prop);\n\n      if (this.toks.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(prop);\n      } else {\n        isAsync = false;\n      }\n\n      if (isDummy(prop.key)) {\n        if (isDummy(this.parseMaybeAssign())) {\n          this.next();\n        }\n\n        this.eat(acorn.tokTypes.comma);\n        continue;\n      }\n\n      if (this.eat(acorn.tokTypes.colon)) {\n        prop.kind = \"init\";\n        prop.value = this.parseMaybeAssign();\n      } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn.tokTypes.parenL || this.tok.type === acorn.tokTypes.braceL)) {\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n      } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" && !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.tok.type !== acorn.tokTypes.comma && this.tok.type !== acorn.tokTypes.braceR && this.tok.type !== acorn.tokTypes.eq) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n      } else {\n        prop.kind = \"init\";\n\n        if (this.options.ecmaVersion >= 6) {\n          if (this.eat(acorn.tokTypes.eq)) {\n            var assign = this.startNodeAt(start);\n            assign.operator = \"=\";\n            assign.left = prop.key;\n            assign.right = this.parseMaybeAssign();\n            prop.value = this.finishNode(assign, \"AssignmentExpression\");\n          } else {\n            prop.value = prop.key;\n          }\n        } else {\n          prop.value = this.dummyIdent();\n        }\n\n        prop.shorthand = true;\n      }\n\n      node.properties.push(this.finishNode(prop, \"Property\"));\n      this.eat(acorn.tokTypes.comma);\n    }\n\n    this.popCx();\n\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n\n      if (this.options.locations) {\n        this.last.loc.end = this.tok.loc.start;\n      }\n    }\n\n    return this.finishNode(node, \"ObjectExpression\");\n  };\n\n  lp$2.parsePropertyName = function (prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(acorn.tokTypes.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseExpression();\n        this.expect(acorn.tokTypes.bracketR);\n        return;\n      } else {\n        prop.computed = false;\n      }\n    }\n\n    var key = this.tok.type === acorn.tokTypes.num || this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.parseIdent();\n    prop.key = key || this.dummyIdent();\n  };\n\n  lp$2.parsePropertyAccessor = function () {\n    if (this.tok.type === acorn.tokTypes.name || this.tok.type.keyword) {\n      return this.parseIdent();\n    }\n  };\n\n  lp$2.parseIdent = function () {\n    var name = this.tok.type === acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n\n    if (!name) {\n      return this.dummyIdent();\n    }\n\n    var node = this.startNode();\n    this.next();\n    node.name = name;\n    return this.finishNode(node, \"Identifier\");\n  };\n\n  lp$2.initFunction = function (node) {\n    node.id = null;\n    node.params = [];\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = false;\n    }\n  }; // Convert existing expression atom to assignable pattern\n  // if possible.\n\n\n  lp$2.toAssignable = function (node, binding) {\n    if (!node || node.type === \"Identifier\" || node.type === \"MemberExpression\" && !binding) ;else if (node.type === \"ParenthesizedExpression\") {\n      this.toAssignable(node.expression, binding);\n    } else if (this.options.ecmaVersion < 6) {\n      return this.dummyIdent();\n    } else if (node.type === \"ObjectExpression\") {\n      node.type = \"ObjectPattern\";\n\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        this.toAssignable(prop, binding);\n      }\n    } else if (node.type === \"ArrayExpression\") {\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, binding);\n    } else if (node.type === \"Property\") {\n      this.toAssignable(node.value, binding);\n    } else if (node.type === \"SpreadElement\") {\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, binding);\n    } else if (node.type === \"AssignmentExpression\") {\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n    } else {\n      return this.dummyIdent();\n    }\n    return node;\n  };\n\n  lp$2.toAssignableList = function (exprList, binding) {\n    for (var i = 0, list = exprList; i < list.length; i += 1) {\n      var expr = list[i];\n      this.toAssignable(expr, binding);\n    }\n\n    return exprList;\n  };\n\n  lp$2.parseFunctionParams = function (params) {\n    params = this.parseExprList(acorn.tokTypes.parenR);\n    return this.toAssignableList(params, true);\n  };\n\n  lp$2.parseMethod = function (isGenerator, isAsync) {\n    var node = this.startNode(),\n        oldInAsync = this.inAsync,\n        oldInFunction = this.inFunction;\n    this.initFunction(node);\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = !!isGenerator;\n    }\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"FunctionExpression\");\n  };\n\n  lp$2.parseArrowExpression = function (node, params, isAsync) {\n    var oldInAsync = this.inAsync,\n        oldInFunction = this.inFunction;\n    this.initFunction(node);\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    node.expression = this.tok.type !== acorn.tokTypes.braceL;\n\n    if (node.expression) {\n      node.body = this.parseMaybeAssign();\n    } else {\n      node.body = this.parseBlock();\n      this.toks.adaptDirectivePrologue(node.body.body);\n    }\n\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  };\n\n  lp$2.parseExprList = function (close, allowEmpty) {\n    this.pushCx();\n    var indent = this.curIndent,\n        line = this.curLineStart,\n        elts = [];\n    this.next(); // Opening bracket\n\n    while (!this.closes(close, indent + 1, line)) {\n      if (this.eat(acorn.tokTypes.comma)) {\n        elts.push(allowEmpty ? null : this.dummyIdent());\n        continue;\n      }\n\n      var elt = this.parseMaybeAssign();\n\n      if (isDummy(elt)) {\n        if (this.closes(close, indent, line)) {\n          break;\n        }\n\n        this.next();\n      } else {\n        elts.push(elt);\n      }\n\n      this.eat(acorn.tokTypes.comma);\n    }\n\n    this.popCx();\n\n    if (!this.eat(close)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n\n      if (this.options.locations) {\n        this.last.loc.end = this.tok.loc.start;\n      }\n    }\n\n    return elts;\n  };\n\n  lp$2.parseAwait = function () {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\");\n  }; // Acorn: Loose parser\n\n\n  acorn.defaultOptions.tabSize = 4;\n\n  function parse(input, options) {\n    return LooseParser.parse(input, options);\n  }\n\n  exports.LooseParser = LooseParser;\n  exports.parse = parse;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsdom/node_modules/acorn/acorn-loose/dist/acorn-loose.js"],"names":["global","factory","exports","module","require","define","amd","self","acorn","loose","noop","LooseParser","input","options","toks","constructor","BaseParser","tokenizer","tok","last","type","tokTypes","eof","start","end","validateRegExpFlags","validateRegExpPattern","locations","here","curPosition","loc","SourceLocation","ahead","context","curIndent","curLineStart","nextLineStart","lineEnd","inAsync","inFunction","prototype","startNode","Node","storeCurrentPos","startNodeAt","pos","finishNode","node","ranges","range","dummyNode","dummy","name","dummyIdent","dummyString","value","raw","eat","next","isContextual","eatContextual","canInsertSemicolon","braceR","lineBreak","test","slice","semicolon","semi","expect","i","lookAhead","j","pushCx","push","popCx","pop","length","isNewLine","charCodeAt","indentationAfter","count","ch","tabSize","closes","closeTok","indent","line","blockHeuristic","tokenStartsLine","p","extend","f","parse","parseTopLevel","plugins","len","arguments","cls","Parser","lp","isSpace","shift","readToken","dot","substr","ecmaVersion","ellipsis","Token","e","SyntaxError","msg","message","raisedAt","replace","string","re","RegExp","regexp","template","resetTo","getLineInfo","charAt","exprAllowed","curLine","lineStart","lineBreakG","lastIndex","match","exec","index","n","isDummy","lp$1","body","parseStatement","adaptDirectivePrologue","sourceType","starttype","kind","isLet","_var","_break","_continue","isBreak","label","parseIdent","_debugger","_do","_while","parseParenExpression","_for","isAwait","parenL","parseFor","_const","init$1","parseVar","declarations","_in","await","parseForIn","init","parseExpression","toAssignable","_function","parseFunction","_if","consequent","alternate","_else","_return","argument","_switch","blockIndent","discriminant","cases","braceL","cur","_case","_default","isCase","colon","_throw","_try","block","parseBlock","handler","_catch","clause","param","parseExprAtom","parenR","finalizer","_finally","_with","object","_class","parseClass","_import","expression","parseImport","_export","parseExport","isAsyncFunction","expr","update","left","right","noIn","decl","id","eq","parseMaybeAssign","comma","decl$1","isStatement","superClass","_extends","method","isGenerator","isAsync","static","star","parsePropertyName","key","computed","parseMethod","oldInAsync","oldInFunction","initFunction","generator","async","params","parseFunctionParams","source","fNode","declaration","keyword","specifiers","parseExportSpecifierList","elt","local","parseImportSpecifiers","unshift","elts","continuedLine","elt$1","imported","exported","lp$2","checkLVal","expressions","val","startsExpr","delegate","parseMaybeConditional","isAssign","node$1","operator","parseExprOps","question","parseExprOp","parseMaybeUnary","minPrec","prec","binop","rightStart","sawUnary","allowAwaitOutsideFunction","parseAwait","prefix","incDec","parseExprSubscripts","postfix","node$2","starstar","node$3","parseSubscripts","base","noCalls","startIndent","maybeAsyncArrow","property","parsePropertyAccessor","bracketL","bracketR","exprList","parseExprList","arrow","parseArrowExpression","callee","backQuote","tag","quasi","parseTemplate","_this","_super","regex","pattern","flags","num","bigint","_null","_true","_false","parenStart","inner","preserveParens","par","elements","parseObj","_new","parseNew","parseDynamicImport","meta","parseTemplateElement","elem","invalidTemplate","cooked","tail","curElt","quasis","properties","prop","shorthand","isAsyncProp","assign","binding","list","toAssignableList","close","allowEmpty","defaultOptions","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('acorn')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'acorn'], factory) :\n  (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.loose = {}), global.acorn));\n}(this, function (exports, acorn) { 'use strict';\n\n  function noop() {}\n\n  var LooseParser = function LooseParser(input, options) {\n    if ( options === void 0 ) options = {};\n\n    this.toks = this.constructor.BaseParser.tokenizer(input, options);\n    this.options = this.toks.options;\n    this.input = this.toks.input;\n    this.tok = this.last = {type: acorn.tokTypes.eof, start: 0, end: 0};\n    this.tok.validateRegExpFlags = noop;\n    this.tok.validateRegExpPattern = noop;\n    if (this.options.locations) {\n      var here = this.toks.curPosition();\n      this.tok.loc = new acorn.SourceLocation(this.toks, here, here);\n    }\n    this.ahead = []; // Tokens ahead\n    this.context = []; // Indentation contexted\n    this.curIndent = 0;\n    this.curLineStart = 0;\n    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    this.inAsync = false;\n    this.inFunction = false;\n  };\n\n  LooseParser.prototype.startNode = function startNode () {\n    return new acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n  };\n\n  LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n  };\n\n  LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n    if (this.options.locations) {\n      return new acorn.Node(this.toks, pos[0], pos[1])\n    } else {\n      return new acorn.Node(this.toks, pos)\n    }\n  };\n\n  LooseParser.prototype.finishNode = function finishNode (node, type) {\n    node.type = type;\n    node.end = this.last.end;\n    if (this.options.locations)\n      { node.loc.end = this.last.loc.end; }\n    if (this.options.ranges)\n      { node.range[1] = this.last.end; }\n    return node\n  };\n\n  LooseParser.prototype.dummyNode = function dummyNode (type) {\n    var dummy = this.startNode();\n    dummy.type = type;\n    dummy.end = dummy.start;\n    if (this.options.locations)\n      { dummy.loc.end = dummy.loc.start; }\n    if (this.options.ranges)\n      { dummy.range[1] = dummy.start; }\n    this.last = {type: acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n    return dummy\n  };\n\n  LooseParser.prototype.dummyIdent = function dummyIdent () {\n    var dummy = this.dummyNode(\"Identifier\");\n    dummy.name = \"✖\";\n    return dummy\n  };\n\n  LooseParser.prototype.dummyString = function dummyString () {\n    var dummy = this.dummyNode(\"Literal\");\n    dummy.value = dummy.raw = \"✖\";\n    return dummy\n  };\n\n  LooseParser.prototype.eat = function eat (type) {\n    if (this.tok.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  LooseParser.prototype.isContextual = function isContextual (name) {\n    return this.tok.type === acorn.tokTypes.name && this.tok.value === name\n  };\n\n  LooseParser.prototype.eatContextual = function eatContextual (name) {\n    return this.tok.value === name && this.eat(acorn.tokTypes.name)\n  };\n\n  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n    return this.tok.type === acorn.tokTypes.eof || this.tok.type === acorn.tokTypes.braceR ||\n      acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n  };\n\n  LooseParser.prototype.semicolon = function semicolon () {\n    return this.eat(acorn.tokTypes.semi)\n  };\n\n  LooseParser.prototype.expect = function expect (type) {\n    if (this.eat(type)) { return true }\n    for (var i = 1; i <= 2; i++) {\n      if (this.lookAhead(i).type === type) {\n        for (var j = 0; j < i; j++) { this.next(); }\n        return true\n      }\n    }\n  };\n\n  LooseParser.prototype.pushCx = function pushCx () {\n    this.context.push(this.curIndent);\n  };\n\n  LooseParser.prototype.popCx = function popCx () {\n    this.curIndent = this.context.pop();\n  };\n\n  LooseParser.prototype.lineEnd = function lineEnd (pos) {\n    while (pos < this.input.length && !acorn.isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n    return pos\n  };\n\n  LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n    for (var count = 0;; ++pos) {\n      var ch = this.input.charCodeAt(pos);\n      if (ch === 32) { ++count; }\n      else if (ch === 9) { count += this.options.tabSize; }\n      else { return count }\n    }\n  };\n\n  LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n    if (this.tok.type === closeTok || this.tok.type === acorn.tokTypes.eof) { return true }\n    return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n      (!blockHeuristic || this.nextLineStart >= this.input.length ||\n       this.indentationAfter(this.nextLineStart) < indent)\n  };\n\n  LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n      var ch = this.input.charCodeAt(p);\n      if (ch !== 9 && ch !== 32) { return false }\n    }\n    return true\n  };\n\n  LooseParser.prototype.extend = function extend (name, f) {\n    this[name] = f(this[name]);\n  };\n\n  LooseParser.prototype.parse = function parse () {\n    this.next();\n    return this.parseTopLevel()\n  };\n\n  LooseParser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  LooseParser.parse = function parse (input, options) {\n    return new this(input, options).parse()\n  };\n\n  // Allows plugins to extend the base parser / tokenizer used\n  LooseParser.BaseParser = acorn.Parser;\n\n  var lp = LooseParser.prototype;\n\n  function isSpace(ch) {\n    return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || acorn.isNewLine(ch)\n  }\n\n  lp.next = function() {\n    this.last = this.tok;\n    if (this.ahead.length)\n      { this.tok = this.ahead.shift(); }\n    else\n      { this.tok = this.readToken(); }\n\n    if (this.tok.start >= this.nextLineStart) {\n      while (this.tok.start >= this.nextLineStart) {\n        this.curLineStart = this.nextLineStart;\n        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n      }\n      this.curIndent = this.indentationAfter(this.curLineStart);\n    }\n  };\n\n  lp.readToken = function() {\n    for (;;) {\n      try {\n        this.toks.next();\n        if (this.toks.type === acorn.tokTypes.dot &&\n            this.input.substr(this.toks.end, 1) === \".\" &&\n            this.options.ecmaVersion >= 6) {\n          this.toks.end++;\n          this.toks.type = acorn.tokTypes.ellipsis;\n        }\n        return new acorn.Token(this.toks)\n      } catch (e) {\n        if (!(e instanceof SyntaxError)) { throw e }\n\n        // Try to skip some text, based on the error message, and then continue\n        var msg = e.message, pos = e.raisedAt, replace = true;\n        if (/unterminated/i.test(msg)) {\n          pos = this.lineEnd(e.pos + 1);\n          if (/string/.test(msg)) {\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.string, value: this.input.slice(e.pos + 1, pos)};\n          } else if (/regular expr/i.test(msg)) {\n            var re = this.input.slice(e.pos, pos);\n            try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.regexp, value: re};\n          } else if (/template/.test(msg)) {\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.template,\n              value: this.input.slice(e.pos, pos)\n            };\n          } else {\n            replace = false;\n          }\n        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n          while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n        } else if (/character escape|expected hexadecimal/i.test(msg)) {\n          while (pos < this.input.length) {\n            var ch = this.input.charCodeAt(pos++);\n            if (ch === 34 || ch === 39 || acorn.isNewLine(ch)) { break }\n          }\n        } else if (/unexpected character/i.test(msg)) {\n          pos++;\n          replace = false;\n        } else if (/regular expression/i.test(msg)) {\n          replace = true;\n        } else {\n          throw e\n        }\n        this.resetTo(pos);\n        if (replace === true) { replace = {start: pos, end: pos, type: acorn.tokTypes.name, value: \"✖\"}; }\n        if (replace) {\n          if (this.options.locations)\n            { replace.loc = new acorn.SourceLocation(\n              this.toks,\n              acorn.getLineInfo(this.input, replace.start),\n              acorn.getLineInfo(this.input, replace.end)); }\n          return replace\n        }\n      }\n    }\n  };\n\n  lp.resetTo = function(pos) {\n    this.toks.pos = pos;\n    var ch = this.input.charAt(pos - 1);\n    this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n      /[enwfd]/.test(ch) &&\n      /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n    if (this.options.locations) {\n      this.toks.curLine = 1;\n      this.toks.lineStart = acorn.lineBreakG.lastIndex = 0;\n      var match;\n      while ((match = acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n        ++this.toks.curLine;\n        this.toks.lineStart = match.index + match[0].length;\n      }\n    }\n  };\n\n  lp.lookAhead = function(n) {\n    while (n > this.ahead.length)\n      { this.ahead.push(this.readToken()); }\n    return this.ahead[n - 1]\n  };\n\n  function isDummy(node) { return node.name === \"✖\" }\n\n  var lp$1 = LooseParser.prototype;\n\n  lp$1.parseTopLevel = function() {\n    var node = this.startNodeAt(this.options.locations ? [0, acorn.getLineInfo(this.input, 0)] : 0);\n    node.body = [];\n    while (this.tok.type !== acorn.tokTypes.eof) { node.body.push(this.parseStatement()); }\n    this.toks.adaptDirectivePrologue(node.body);\n    this.last = this.tok;\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  lp$1.parseStatement = function() {\n    var starttype = this.tok.type, node = this.startNode(), kind;\n\n    if (this.toks.isLet()) {\n      starttype = acorn.tokTypes._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n    case acorn.tokTypes._break: case acorn.tokTypes._continue:\n      this.next();\n      var isBreak = starttype === acorn.tokTypes._break;\n      if (this.semicolon() || this.canInsertSemicolon()) {\n        node.label = null;\n      } else {\n        node.label = this.tok.type === acorn.tokTypes.name ? this.parseIdent() : null;\n        this.semicolon();\n      }\n      return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n    case acorn.tokTypes._debugger:\n      this.next();\n      this.semicolon();\n      return this.finishNode(node, \"DebuggerStatement\")\n\n    case acorn.tokTypes._do:\n      this.next();\n      node.body = this.parseStatement();\n      node.test = this.eat(acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n      this.semicolon();\n      return this.finishNode(node, \"DoWhileStatement\")\n\n    case acorn.tokTypes._for:\n      this.next(); // `for` keyword\n      var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n\n      this.pushCx();\n      this.expect(acorn.tokTypes.parenL);\n      if (this.tok.type === acorn.tokTypes.semi) { return this.parseFor(node, null) }\n      var isLet = this.toks.isLet();\n      if (isLet || this.tok.type === acorn.tokTypes._var || this.tok.type === acorn.tokTypes._const) {\n        var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n        if (init$1.declarations.length === 1 && (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\"))) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n            node.await = isAwait;\n          }\n          return this.parseForIn(node, init$1)\n        }\n        return this.parseFor(node, init$1)\n      }\n      var init = this.parseExpression(true);\n      if (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\")) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n          node.await = isAwait;\n        }\n        return this.parseForIn(node, this.toAssignable(init))\n      }\n      return this.parseFor(node, init)\n\n    case acorn.tokTypes._function:\n      this.next();\n      return this.parseFunction(node, true)\n\n    case acorn.tokTypes._if:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.consequent = this.parseStatement();\n      node.alternate = this.eat(acorn.tokTypes._else) ? this.parseStatement() : null;\n      return this.finishNode(node, \"IfStatement\")\n\n    case acorn.tokTypes._return:\n      this.next();\n      if (this.eat(acorn.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n      else { node.argument = this.parseExpression(); this.semicolon(); }\n      return this.finishNode(node, \"ReturnStatement\")\n\n    case acorn.tokTypes._switch:\n      var blockIndent = this.curIndent, line = this.curLineStart;\n      this.next();\n      node.discriminant = this.parseParenExpression();\n      node.cases = [];\n      this.pushCx();\n      this.expect(acorn.tokTypes.braceL);\n\n      var cur;\n      while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {\n        if (this.tok.type === acorn.tokTypes._case || this.tok.type === acorn.tokTypes._default) {\n          var isCase = this.tok.type === acorn.tokTypes._case;\n          if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          this.next();\n          if (isCase) { cur.test = this.parseExpression(); }\n          else { cur.test = null; }\n          this.expect(acorn.tokTypes.colon);\n        } else {\n          if (!cur) {\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            cur.test = null;\n          }\n          cur.consequent.push(this.parseStatement());\n        }\n      }\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      this.popCx();\n      this.eat(acorn.tokTypes.braceR);\n      return this.finishNode(node, \"SwitchStatement\")\n\n    case acorn.tokTypes._throw:\n      this.next();\n      node.argument = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ThrowStatement\")\n\n    case acorn.tokTypes._try:\n      this.next();\n      node.block = this.parseBlock();\n      node.handler = null;\n      if (this.tok.type === acorn.tokTypes._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(acorn.tokTypes.parenL)) {\n          clause.param = this.toAssignable(this.parseExprAtom(), true);\n          this.expect(acorn.tokTypes.parenR);\n        } else {\n          clause.param = null;\n        }\n        clause.body = this.parseBlock();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n      }\n      node.finalizer = this.eat(acorn.tokTypes._finally) ? this.parseBlock() : null;\n      if (!node.handler && !node.finalizer) { return node.block }\n      return this.finishNode(node, \"TryStatement\")\n\n    case acorn.tokTypes._var:\n    case acorn.tokTypes._const:\n      return this.parseVar(node, false, kind || this.tok.value)\n\n    case acorn.tokTypes._while:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WhileStatement\")\n\n    case acorn.tokTypes._with:\n      this.next();\n      node.object = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WithStatement\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseBlock()\n\n    case acorn.tokTypes.semi:\n      this.next();\n      return this.finishNode(node, \"EmptyStatement\")\n\n    case acorn.tokTypes._class:\n      return this.parseClass(true)\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === acorn.tokTypes.parenL) {\n        node.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n\n      return this.parseImport()\n\n    case acorn.tokTypes._export:\n      return this.parseExport()\n\n    default:\n      if (this.toks.isAsyncFunction()) {\n        this.next();\n        this.next();\n        return this.parseFunction(node, true, true)\n      }\n      var expr = this.parseExpression();\n      if (isDummy(expr)) {\n        this.next();\n        if (this.tok.type === acorn.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n        return this.parseStatement()\n      } else if (starttype === acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(acorn.tokTypes.colon)) {\n        node.body = this.parseStatement();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\")\n      } else {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n    }\n  };\n\n  lp$1.parseBlock = function() {\n    var node = this.startNode();\n    this.pushCx();\n    this.expect(acorn.tokTypes.braceL);\n    var blockIndent = this.curIndent, line = this.curLineStart;\n    node.body = [];\n    while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true))\n      { node.body.push(this.parseStatement()); }\n    this.popCx();\n    this.eat(acorn.tokTypes.braceR);\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  lp$1.parseFor = function(node, init) {\n    node.init = init;\n    node.test = node.update = null;\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.semi) { node.test = this.parseExpression(); }\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.parenR) { node.update = this.parseExpression(); }\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  lp$1.parseForIn = function(node, init) {\n    var type = this.tok.type === acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, type)\n  };\n\n  lp$1.parseVar = function(node, noIn, kind) {\n    node.kind = kind;\n    this.next();\n    node.declarations = [];\n    do {\n      var decl = this.startNode();\n      decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n      decl.init = this.eat(acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    } while (this.eat(acorn.tokTypes.comma))\n    if (!node.declarations.length) {\n      var decl$1 = this.startNode();\n      decl$1.id = this.dummyIdent();\n      node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n    }\n    if (!noIn) { this.semicolon(); }\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  lp$1.parseClass = function(isStatement) {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    else { node.id = null; }\n    node.superClass = this.eat(acorn.tokTypes._extends) ? this.parseExpression() : null;\n    node.body = this.startNode();\n    node.body.body = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      if (this.semicolon()) { continue }\n      var method = this.startNode(), isGenerator = (void 0), isAsync = (void 0);\n      if (this.options.ecmaVersion >= 6) {\n        method.static = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(method);\n      if (isDummy(method.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n          (this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL)) {\n        method.static = true;\n        isGenerator = this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        method.static = false;\n      }\n      if (!method.computed &&\n          method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== acorn.tokTypes.parenL &&\n          !this.canInsertSemicolon()) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        isAsync = false;\n      }\n      if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n          !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n          this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL) {\n        method.kind = method.key.name;\n        this.parsePropertyName(method);\n        method.value = this.parseMethod(false);\n      } else {\n        if (!method.computed && !method.static && !isGenerator && !isAsync && (\n          method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n            method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n        method.value = this.parseMethod(isGenerator, isAsync);\n      }\n      node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    this.semicolon();\n    this.finishNode(node.body, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  lp$1.parseFunction = function(node, isStatement, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = this.eat(acorn.tokTypes.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  lp$1.parseExport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.eat(acorn.tokTypes.star)) {\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(acorn.tokTypes._default)) {\n      // export default (function foo() {}) // This is FunctionExpression.\n      var isAsync;\n      if (this.tok.type === acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n      } else if (this.tok.type === acorn.tokTypes._class) {\n        node.declaration = this.parseClass(\"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n      node.declaration = this.parseStatement();\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifierList();\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  lp$1.parseImport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.string) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      var elt;\n      if (this.tok.type === acorn.tokTypes.name && this.tok.value !== \"from\") {\n        elt = this.startNode();\n        elt.local = this.parseIdent();\n        this.finishNode(elt, \"ImportDefaultSpecifier\");\n        this.eat(acorn.tokTypes.comma);\n      }\n      node.specifiers = this.parseImportSpecifiers();\n      node.source = this.eatContextual(\"from\") && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n      if (elt) { node.specifiers.unshift(elt); }\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  lp$1.parseImportSpecifiers = function() {\n    var elts = [];\n    if (this.tok.type === acorn.tokTypes.star) {\n      var elt = this.startNode();\n      this.next();\n      elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n      elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n    } else {\n      var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n      this.pushCx();\n      this.eat(acorn.tokTypes.braceL);\n      if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n      while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n        var elt$1 = this.startNode();\n        if (this.eat(acorn.tokTypes.star)) {\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n          this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n        } else {\n          if (this.isContextual(\"from\")) { break }\n          elt$1.imported = this.parseIdent();\n          if (isDummy(elt$1.imported)) { break }\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n          this.finishNode(elt$1, \"ImportSpecifier\");\n        }\n        elts.push(elt$1);\n        this.eat(acorn.tokTypes.comma);\n      }\n      this.eat(acorn.tokTypes.braceR);\n      this.popCx();\n    }\n    return elts\n  };\n\n  lp$1.parseExportSpecifierList = function() {\n    var elts = [];\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      if (this.isContextual(\"from\")) { break }\n      var elt = this.startNode();\n      elt.local = this.parseIdent();\n      if (isDummy(elt.local)) { break }\n      elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n      this.finishNode(elt, \"ExportSpecifier\");\n      elts.push(elt);\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.eat(acorn.tokTypes.braceR);\n    this.popCx();\n    return elts\n  };\n\n  var lp$2 = LooseParser.prototype;\n\n  lp$2.checkLVal = function(expr) {\n    if (!expr) { return expr }\n    switch (expr.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n      return expr\n\n    case \"ParenthesizedExpression\":\n      expr.expression = this.checkLVal(expr.expression);\n      return expr\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseExpression = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseMaybeAssign(noIn);\n    if (this.tok.type === acorn.tokTypes.comma) {\n      var node = this.startNodeAt(start);\n      node.expressions = [expr];\n      while (this.eat(acorn.tokTypes.comma)) { node.expressions.push(this.parseMaybeAssign(noIn)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseParenExpression = function() {\n    this.pushCx();\n    this.expect(acorn.tokTypes.parenL);\n    var val = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    return val\n  };\n\n  lp$2.parseMaybeAssign = function(noIn) {\n    if (this.toks.isContextual(\"yield\")) {\n      var node = this.startNode();\n      this.next();\n      if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n        node.delegate = false;\n        node.argument = null;\n      } else {\n        node.delegate = this.eat(acorn.tokTypes.star);\n        node.argument = this.parseMaybeAssign();\n      }\n      return this.finishNode(node, \"YieldExpression\")\n    }\n\n    var start = this.storeCurrentPos();\n    var left = this.parseMaybeConditional(noIn);\n    if (this.tok.type.isAssign) {\n      var node$1 = this.startNodeAt(start);\n      node$1.operator = this.tok.value;\n      node$1.left = this.tok.type === acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n      this.next();\n      node$1.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node$1, \"AssignmentExpression\")\n    }\n    return left\n  };\n\n  lp$2.parseMaybeConditional = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseExprOps(noIn);\n    if (this.eat(acorn.tokTypes.question)) {\n      var node = this.startNodeAt(start);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      node.alternate = this.expect(acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseExprOps = function(noIn) {\n    var start = this.storeCurrentPos();\n    var indent = this.curIndent, line = this.curLineStart;\n    return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n  };\n\n  lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n    if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n    var prec = this.tok.type.binop;\n    if (prec != null && (!noIn || this.tok.type !== acorn.tokTypes._in)) {\n      if (prec > minPrec) {\n        var node = this.startNodeAt(start);\n        node.left = left;\n        node.operator = this.tok.value;\n        this.next();\n        if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n          node.right = this.dummyIdent();\n        } else {\n          var rightStart = this.storeCurrentPos();\n          node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n        }\n        this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n      }\n    }\n    return left\n  };\n\n  lp$2.parseMaybeUnary = function(sawUnary) {\n    var start = this.storeCurrentPos(), expr;\n    if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n      (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n    ) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.tok.type.prefix) {\n      var node = this.startNode(), update = this.tok.type === acorn.tokTypes.incDec;\n      if (!update) { sawUnary = true; }\n      node.operator = this.tok.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(true);\n      if (update) { node.argument = this.checkLVal(node.argument); }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (this.tok.type === acorn.tokTypes.ellipsis) {\n      var node$1 = this.startNode();\n      this.next();\n      node$1.argument = this.parseMaybeUnary(sawUnary);\n      expr = this.finishNode(node$1, \"SpreadElement\");\n    } else {\n      expr = this.parseExprSubscripts();\n      while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n        var node$2 = this.startNodeAt(start);\n        node$2.operator = this.tok.value;\n        node$2.prefix = false;\n        node$2.argument = this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$2, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(acorn.tokTypes.starstar)) {\n      var node$3 = this.startNodeAt(start);\n      node$3.operator = \"**\";\n      node$3.left = expr;\n      node$3.right = this.parseMaybeUnary(false);\n      return this.finishNode(node$3, \"BinaryExpression\")\n    }\n\n    return expr\n  };\n\n  lp$2.parseExprSubscripts = function() {\n    var start = this.storeCurrentPos();\n    return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n  };\n\n  lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n    for (;;) {\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        if (this.tok.type === acorn.tokTypes.dot && this.curIndent === startIndent)\n          { --startIndent; }\n        else\n          { return base }\n      }\n\n      var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n      if (this.eat(acorn.tokTypes.dot)) {\n        var node = this.startNodeAt(start);\n        node.object = base;\n        if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine())\n          { node.property = this.dummyIdent(); }\n        else\n          { node.property = this.parsePropertyAccessor() || this.dummyIdent(); }\n        node.computed = false;\n        base = this.finishNode(node, \"MemberExpression\");\n      } else if (this.tok.type === acorn.tokTypes.bracketL) {\n        this.pushCx();\n        this.next();\n        var node$1 = this.startNodeAt(start);\n        node$1.object = base;\n        node$1.property = this.parseExpression();\n        node$1.computed = true;\n        this.popCx();\n        this.expect(acorn.tokTypes.bracketR);\n        base = this.finishNode(node$1, \"MemberExpression\");\n      } else if (!noCalls && this.tok.type === acorn.tokTypes.parenL) {\n        var exprList = this.parseExprList(acorn.tokTypes.parenR);\n        if (maybeAsyncArrow && this.eat(acorn.tokTypes.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(start), exprList, true) }\n        var node$2 = this.startNodeAt(start);\n        node$2.callee = base;\n        node$2.arguments = exprList;\n        base = this.finishNode(node$2, \"CallExpression\");\n      } else if (this.tok.type === acorn.tokTypes.backQuote) {\n        var node$3 = this.startNodeAt(start);\n        node$3.tag = base;\n        node$3.quasi = this.parseTemplate();\n        base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n      } else {\n        return base\n      }\n    }\n  };\n\n  lp$2.parseExprAtom = function() {\n    var node;\n    switch (this.tok.type) {\n    case acorn.tokTypes._this:\n    case acorn.tokTypes._super:\n      var type = this.tok.type === acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type)\n\n    case acorn.tokTypes.name:\n      var start = this.storeCurrentPos();\n      var id = this.parseIdent();\n      var isAsync = false;\n      if (id.name === \"async\" && !this.canInsertSemicolon()) {\n        if (this.eat(acorn.tokTypes._function))\n          { return this.parseFunction(this.startNodeAt(start), false, true) }\n        if (this.tok.type === acorn.tokTypes.name) {\n          id = this.parseIdent();\n          isAsync = true;\n        }\n      }\n      return this.eat(acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n    case acorn.tokTypes.regexp:\n      node = this.startNode();\n      var val = this.tok.value;\n      node.regex = {pattern: val.pattern, flags: val.flags};\n      node.value = val.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.num: case acorn.tokTypes.string:\n      node = this.startNode();\n      node.value = this.tok.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      if (this.tok.type === acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes._null: case acorn.tokTypes._true: case acorn.tokTypes._false:\n      node = this.startNode();\n      node.value = this.tok.type === acorn.tokTypes._null ? null : this.tok.type === acorn.tokTypes._true;\n      node.raw = this.tok.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.parenL:\n      var parenStart = this.storeCurrentPos();\n      this.next();\n      var inner = this.parseExpression();\n      this.expect(acorn.tokTypes.parenR);\n      if (this.eat(acorn.tokTypes.arrow)) {\n        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n        var params = inner.expressions || [inner];\n        if (params.length && isDummy(params[params.length - 1]))\n          { params.pop(); }\n        return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n      }\n      if (this.options.preserveParens) {\n        var par = this.startNodeAt(parenStart);\n        par.expression = inner;\n        inner = this.finishNode(par, \"ParenthesizedExpression\");\n      }\n      return inner\n\n    case acorn.tokTypes.bracketL:\n      node = this.startNode();\n      node.elements = this.parseExprList(acorn.tokTypes.bracketR, true);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseObj()\n\n    case acorn.tokTypes._class:\n      return this.parseClass(false)\n\n    case acorn.tokTypes._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false)\n\n    case acorn.tokTypes._new:\n      return this.parseNew()\n\n    case acorn.tokTypes.backQuote:\n      return this.parseTemplate()\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport()\n      } else {\n        return this.dummyIdent()\n      }\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseDynamicImport = function() {\n    var node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"Import\")\n  };\n\n  lp$2.parseNew = function() {\n    var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(acorn.tokTypes.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var start = this.storeCurrentPos();\n    node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n    if (this.tok.type === acorn.tokTypes.parenL) {\n      node.arguments = this.parseExprList(acorn.tokTypes.parenR);\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  lp$2.parseTemplateElement = function() {\n    var elem = this.startNode();\n\n    // The loose parser accepts invalid unicode escapes even in untagged templates.\n    if (this.tok.type === acorn.tokTypes.invalidTemplate) {\n      elem.value = {\n        raw: this.tok.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.tok.value\n      };\n    }\n    this.next();\n    elem.tail = this.tok.type === acorn.tokTypes.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  lp$2.parseTemplate = function() {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      this.next();\n      node.expressions.push(this.parseExpression());\n      if (this.expect(acorn.tokTypes.braceR)) {\n        curElt = this.parseTemplateElement();\n      } else {\n        curElt = this.startNode();\n        curElt.value = {cooked: \"\", raw: \"\"};\n        curElt.tail = true;\n        this.finishNode(curElt, \"TemplateElement\");\n      }\n      node.quasis.push(curElt);\n    }\n    this.expect(acorn.tokTypes.backQuote);\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  lp$2.parseObj = function() {\n    var node = this.startNode();\n    node.properties = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      var prop = this.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n      if (this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.ellipsis)) {\n        prop.argument = this.parseMaybeAssign();\n        node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n        this.eat(acorn.tokTypes.comma);\n        continue\n      }\n      if (this.options.ecmaVersion >= 6) {\n        start = this.storeCurrentPos();\n        prop.method = false;\n        prop.shorthand = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(prop);\n      if (this.toks.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(prop);\n      } else {\n        isAsync = false;\n      }\n      if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (this.eat(acorn.tokTypes.colon)) {\n        prop.kind = \"init\";\n        prop.value = this.parseMaybeAssign();\n      } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn.tokTypes.parenL || this.tok.type === acorn.tokTypes.braceL)) {\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n      } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n                 (this.tok.type !== acorn.tokTypes.comma && this.tok.type !== acorn.tokTypes.braceR && this.tok.type !== acorn.tokTypes.eq)) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n      } else {\n        prop.kind = \"init\";\n        if (this.options.ecmaVersion >= 6) {\n          if (this.eat(acorn.tokTypes.eq)) {\n            var assign = this.startNodeAt(start);\n            assign.operator = \"=\";\n            assign.left = prop.key;\n            assign.right = this.parseMaybeAssign();\n            prop.value = this.finishNode(assign, \"AssignmentExpression\");\n          } else {\n            prop.value = prop.key;\n          }\n        } else {\n          prop.value = this.dummyIdent();\n        }\n        prop.shorthand = true;\n      }\n      node.properties.push(this.finishNode(prop, \"Property\"));\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return this.finishNode(node, \"ObjectExpression\")\n  };\n\n  lp$2.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(acorn.tokTypes.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseExpression();\n        this.expect(acorn.tokTypes.bracketR);\n        return\n      } else {\n        prop.computed = false;\n      }\n    }\n    var key = (this.tok.type === acorn.tokTypes.num || this.tok.type === acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n    prop.key = key || this.dummyIdent();\n  };\n\n  lp$2.parsePropertyAccessor = function() {\n    if (this.tok.type === acorn.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n  };\n\n  lp$2.parseIdent = function() {\n    var name = this.tok.type === acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n    if (!name) { return this.dummyIdent() }\n    var node = this.startNode();\n    this.next();\n    node.name = name;\n    return this.finishNode(node, \"Identifier\")\n  };\n\n  lp$2.initFunction = function(node) {\n    node.id = null;\n    node.params = [];\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = false; }\n  };\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  lp$2.toAssignable = function(node, binding) {\n    if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) ; else if (node.type === \"ParenthesizedExpression\") {\n      this.toAssignable(node.expression, binding);\n    } else if (this.options.ecmaVersion < 6) {\n      return this.dummyIdent()\n    } else if (node.type === \"ObjectExpression\") {\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1)\n        {\n        var prop = list[i];\n\n        this.toAssignable(prop, binding);\n      }\n    } else if (node.type === \"ArrayExpression\") {\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, binding);\n    } else if (node.type === \"Property\") {\n      this.toAssignable(node.value, binding);\n    } else if (node.type === \"SpreadElement\") {\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, binding);\n    } else if (node.type === \"AssignmentExpression\") {\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n    } else {\n      return this.dummyIdent()\n    }\n    return node\n  };\n\n  lp$2.toAssignableList = function(exprList, binding) {\n    for (var i = 0, list = exprList; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      this.toAssignable(expr, binding);\n    }\n    return exprList\n  };\n\n  lp$2.parseFunctionParams = function(params) {\n    params = this.parseExprList(acorn.tokTypes.parenR);\n    return this.toAssignableList(params, true)\n  };\n\n  lp$2.parseMethod = function(isGenerator, isAsync) {\n    var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = !!isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  lp$2.parseArrowExpression = function(node, params, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    node.expression = this.tok.type !== acorn.tokTypes.braceL;\n    if (node.expression) {\n      node.body = this.parseMaybeAssign();\n    } else {\n      node.body = this.parseBlock();\n      this.toks.adaptDirectivePrologue(node.body.body);\n    }\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  lp$2.parseExprList = function(close, allowEmpty) {\n    this.pushCx();\n    var indent = this.curIndent, line = this.curLineStart, elts = [];\n    this.next(); // Opening bracket\n    while (!this.closes(close, indent + 1, line)) {\n      if (this.eat(acorn.tokTypes.comma)) {\n        elts.push(allowEmpty ? null : this.dummyIdent());\n        continue\n      }\n      var elt = this.parseMaybeAssign();\n      if (isDummy(elt)) {\n        if (this.closes(close, indent, line)) { break }\n        this.next();\n      } else {\n        elts.push(elt);\n      }\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(close)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return elts\n  };\n\n  lp$2.parseAwait = function() {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  // Acorn: Loose parser\n\n  acorn.defaultOptions.tabSize = 4;\n\n  function parse(input, options) {\n    return LooseParser.parse(input, options)\n  }\n\n  exports.LooseParser = LooseParser;\n  exports.parse = parse;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]},"metadata":{},"sourceType":"script"}