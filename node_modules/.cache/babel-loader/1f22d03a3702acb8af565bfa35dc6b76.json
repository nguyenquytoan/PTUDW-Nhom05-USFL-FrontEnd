{"ast":null,"code":"/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\nconst NODE_DESCRIPTIONS = {\n  DoWhileStatement: \"a 'do...while' statement\",\n  ForStatement: \"a 'for' statement\",\n  IfStatement: \"an 'if' statement\",\n  WhileStatement: \"a 'while' statement\"\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignment operators in conditional expressions\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-cond-assign\"\n    },\n    schema: [{\n      enum: [\"except-parens\", \"always\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected assignment within {{type}}.\",\n      // must match JSHint's error message\n      missing: \"Expected a conditional expression and instead saw an assignment.\"\n    }\n  },\n\n  create(context) {\n    const prohibitAssign = context.options[0] || \"except-parens\";\n    const sourceCode = context.getSourceCode();\n    /**\n     * Check whether an AST node is the test expression for a conditional statement.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n     */\n\n    function isConditionalTestExpression(node) {\n      return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;\n    }\n    /**\n     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n     * @param {!Object} node The node to use at the start of the search.\n     * @returns {?Object} The closest ancestor node that represents a conditional statement.\n     */\n\n\n    function findConditionalAncestor(node) {\n      let currentAncestor = node;\n\n      do {\n        if (isConditionalTestExpression(currentAncestor)) {\n          return currentAncestor.parent;\n        }\n      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n      return null;\n    }\n    /**\n     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n     */\n\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n    /**\n     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n     * @param {!Object} node The node for the conditional statement.\n     * @returns {void}\n     */\n\n\n    function testForAssign(node) {\n      if (node.test && node.test.type === \"AssignmentExpression\" && (node.type === \"ForStatement\" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {\n        context.report({\n          node: node.test,\n          messageId: \"missing\"\n        });\n      }\n    }\n    /**\n     * Check whether an assignment expression is descended from a conditional statement's test expression.\n     * @param {!Object} node The node for the assignment expression.\n     * @returns {void}\n     */\n\n\n    function testForConditionalAncestor(node) {\n      const ancestor = findConditionalAncestor(node);\n\n      if (ancestor) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n          }\n        });\n      }\n    }\n\n    if (prohibitAssign === \"always\") {\n      return {\n        AssignmentExpression: testForConditionalAncestor\n      };\n    }\n\n    return {\n      DoWhileStatement: testForAssign,\n      ForStatement: testForAssign,\n      IfStatement: testForAssign,\n      WhileStatement: testForAssign,\n      ConditionalExpression: testForAssign\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-cond-assign.js"],"names":["astUtils","require","TEST_CONDITION_PARENT_TYPES","Set","NODE_DESCRIPTIONS","DoWhileStatement","ForStatement","IfStatement","WhileStatement","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","messages","unexpected","missing","create","context","prohibitAssign","options","sourceCode","getSourceCode","isConditionalTestExpression","node","parent","has","test","findConditionalAncestor","currentAncestor","isFunction","isParenthesisedTwice","previousToken","getTokenBefore","nextToken","getTokenAfter","isParenthesised","isOpeningParenToken","range","isClosingParenToken","testForAssign","report","messageId","testForConditionalAncestor","ancestor","data","AssignmentExpression","ConditionalExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-cond-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected assignment within {{type}}.\",\n\n            // must match JSHint's error message\n            missing: \"Expected a conditional expression and instead saw an assignment.\"\n        }\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                TEST_CONDITION_PARENT_TYPES.has(node.parent.type) &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                context.report({\n                    node: node.test,\n                    messageId: \"missing\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: {\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                    }\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign,\n            ConditionalExpression: testForAssign\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}