{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.mjs';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { cleanRedirect } from './utils/cleanRedirect.mjs';\nimport { createCacheKey } from './utils/createCacheKey.mjs';\nimport { printCleanupDetails } from './utils/printCleanupDetails.mjs';\nimport { printInstallDetails } from './utils/printInstallDetails.mjs';\nimport './_version.mjs';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\n\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n\n\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n\n    for (const entry of entries) {\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n\n\n  async install({\n    event,\n    plugins\n  } = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins'\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(request => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map(url => {\n      return this._addURLToCache({\n        event,\n        plugins,\n        url\n      });\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached\n    };\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n\n\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n    const deletedURLs = [];\n\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {\n      deletedURLs\n    };\n  }\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n\n\n  async _addURLToCache({\n    url,\n    event,\n    plugins\n  }) {\n    const request = new Request(url, {\n      credentials: 'same-origin'\n    });\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request\n    }); // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n\n    let cacheWillUpdateCallback;\n\n    for (const plugin of plugins || []) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ? // Use a callback if provided. It returns a truthy value if valid.\n    cacheWillUpdateCallback({\n      event,\n      request,\n      response\n    }) : // Otherwise, default to considering any response status under 400 valid.\n    // This includes, by default, considering opaque responses valid.\n    response.status < 400; // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true\n      }\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n\n\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n\n\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n\n\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n\n}\n\nexport { PrecacheController };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-precaching/PrecacheController.mjs"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","WorkboxError","cleanRedirect","createCacheKey","printCleanupDetails","printInstallDetails","PrecacheController","constructor","cacheName","_cacheName","getPrecacheName","_urlsToCacheKeys","Map","addToCacheList","entries","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","entry","cacheKey","url","has","get","firstEntry","secondEntry","set","install","event","plugins","urlsToPrecache","urlsAlreadyPrecached","cache","caches","open","alreadyCachedRequests","keys","alreadyCachedURLs","Set","map","request","values","push","precacheRequests","_addURLToCache","Promise","all","updatedURLs","notUpdatedURLs","activate","currentlyCachedRequests","expectedCacheKeys","deletedURLs","delete","Request","credentials","response","fetch","cacheWillUpdateCallback","plugin","cacheWillUpdate","bind","isValidResponse","status","redirected","put","matchOptions","ignoreSearch","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {cleanRedirect} from './utils/cleanRedirect.mjs';\nimport {createCacheKey} from './utils/createCacheKey.mjs';\nimport {printCleanupDetails} from './utils/printCleanupDetails.mjs';\nimport {printInstallDetails} from './utils/printInstallDetails.mjs';\n\nimport './_version.mjs';\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    for (const entry of entries) {\n      const {cacheKey, url} = createCacheKey(entry);\n      if (this._urlsToCacheKeys.has(url) &&\n          this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey,\n        });\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n    }\n  }\n\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<workbox.precaching.InstallResult>}\n   */\n  async install({event, plugins} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins',\n        });\n      }\n    }\n\n    const urlsToPrecache = [];\n    const urlsAlreadyPrecached = [];\n\n    const cache = await caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const alreadyCachedURLs = new Set(alreadyCachedRequests.map(\n        (request) => request.url));\n\n    for (const cacheKey of this._urlsToCacheKeys.values()) {\n      if (alreadyCachedURLs.has(cacheKey)) {\n        urlsAlreadyPrecached.push(cacheKey);\n      } else {\n        urlsToPrecache.push(cacheKey);\n      }\n    }\n\n    const precacheRequests = urlsToPrecache.map((url) => {\n      return this._addURLToCache({event, plugins, url});\n    });\n    await Promise.all(precacheRequests);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(urlsToPrecache, urlsAlreadyPrecached);\n    }\n\n    return {\n      updatedURLs: urlsToPrecache,\n      notUpdatedURLs: urlsAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<workbox.precaching.CleanupResult>}\n   */\n  async activate() {\n    const cache = await caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n\n    const deletedURLs = [];\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {deletedURLs};\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   */\n  async _addURLToCache({url, event, plugins}) {\n    const request = new Request(url, {credentials: 'same-origin'});\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request,\n    });\n\n    // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a workbox.cacheableResponse.Plugin instance.\n    let cacheWillUpdateCallback;\n    for (const plugin of (plugins || [])) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdateCallback = plugin.cacheWillUpdate.bind(plugin);\n      }\n    }\n\n    const isValidResponse = cacheWillUpdateCallback ?\n      // Use a callback if provided. It returns a truthy value if valid.\n      cacheWillUpdateCallback({event, request, response}) :\n      // Otherwise, default to considering any response status under 400 valid.\n      // This includes, by default, considering opaque responses valid.\n      response.status < 400;\n\n    // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status,\n      });\n    }\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      request,\n      response,\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true,\n      },\n    });\n  }\n\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n}\n\nexport {PrecacheController};\n"]},"metadata":{},"sourceType":"module"}