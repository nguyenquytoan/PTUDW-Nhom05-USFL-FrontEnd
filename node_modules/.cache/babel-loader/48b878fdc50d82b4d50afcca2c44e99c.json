{"ast":null,"code":"/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node A node to check.\n * @param {string} name An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\n\n\nfunction isIdentifier(node, name) {\n  return node.type === \"Identifier\" && node.name === name;\n}\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\n\n\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n/**\n * Checks whether a given node is a `constructor` method in an ES6 class\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is a `constructor` method\n */\n\n\nfunction isClassConstructor(node) {\n  return node.type === \"FunctionExpression\" && node.parent && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements to either always or never specify values\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        treatUndefinedAsUnspecified: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingReturn: \"Expected to return a value at the end of {{name}}.\",\n      missingReturnValue: \"{{name}} expected a return value.\",\n      unexpectedReturnValue: \"{{name}} expected no return value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n    let funcInfo = null;\n    /**\n     * Checks whether of not the implicit returning is consistent if the last\n     * code path segment is reachable.\n     * @param {ASTNode} node A program/function node to check.\n     * @returns {void}\n     */\n\n    function checkLastSegment(node) {\n      let loc, name;\n      /*\n       * Skip if it expected no return value or unreachable.\n       * When unreachable, all paths are returned or thrown.\n       */\n\n      if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {\n        return;\n      } // Adjust a location and a message.\n\n\n      if (node.type === \"Program\") {\n        // The head of program.\n        loc = {\n          line: 1,\n          column: 0\n        };\n        name = \"program\";\n      } else if (node.type === \"ArrowFunctionExpression\") {\n        // `=>` token\n        loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;\n      } else if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        // Method name.\n        loc = node.parent.key.loc.start;\n      } else {\n        // Function name or `function` keyword.\n        loc = (node.id || node).loc.start;\n      }\n\n      if (!name) {\n        name = astUtils.getFunctionNameWithKind(node);\n      } // Reports.\n\n\n      context.report({\n        node,\n        loc,\n        messageId: \"missingReturn\",\n        data: {\n          name\n        }\n      });\n    }\n\n    return {\n      // Initializes/Disposes state of each code path.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          hasReturnValue: false,\n          messageId: \"\",\n          node\n        };\n      },\n\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Reports a given return statement if it's inconsistent.\n      ReturnStatement(node) {\n        const argument = node.argument;\n        let hasReturnValue = Boolean(argument);\n\n        if (treatUndefinedAsUnspecified && hasReturnValue) {\n          hasReturnValue = !isIdentifier(argument, \"undefined\") && argument.operator !== \"void\";\n        }\n\n        if (!funcInfo.hasReturn) {\n          funcInfo.hasReturn = true;\n          funcInfo.hasReturnValue = hasReturnValue;\n          funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n          funcInfo.data = {\n            name: funcInfo.node.type === \"Program\" ? \"Program\" : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n          };\n        } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n          context.report({\n            node,\n            messageId: funcInfo.messageId,\n            data: funcInfo.data\n          });\n        }\n      },\n\n      // Reports a given program/function if the implicit returning is not consistent.\n      \"Program:exit\": checkLastSegment,\n      \"FunctionDeclaration:exit\": checkLastSegment,\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/consistent-return.js"],"names":["lodash","require","astUtils","isIdentifier","node","name","type","isUnreachable","segment","reachable","isClassConstructor","parent","kind","module","exports","meta","docs","description","category","recommended","url","schema","properties","treatUndefinedAsUnspecified","default","additionalProperties","messages","missingReturn","missingReturnValue","unexpectedReturnValue","create","context","options","funcInfo","checkLastSegment","loc","hasReturnValue","codePath","currentSegments","every","isES5Constructor","line","column","getSourceCode","getTokenBefore","body","isArrowToken","start","method","key","id","getFunctionNameWithKind","report","messageId","data","onCodePathStart","upper","hasReturn","onCodePathEnd","ReturnStatement","argument","Boolean","operator","upperFirst"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node A node to check.\n * @param {string} name An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * Checks whether a given node is a `constructor` method in an ES6 class\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is a `constructor` method\n */\nfunction isClassConstructor(node) {\n    return node.type === \"FunctionExpression\" &&\n        node.parent &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements to either always or never specify values\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingReturn: \"Expected to return a value at the end of {{name}}.\",\n            missingReturnValue: \"{{name}} expected a return value.\",\n            unexpectedReturnValue: \"{{name}} expected no return value.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        let funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         * @param {ASTNode} node A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            let loc, name;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\n                astUtils.isES5Constructor(node) ||\n                isClassConstructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = { line: 1, column: 0 };\n                name = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc.start;\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || node).loc.start;\n            }\n\n            if (!name) {\n                name = astUtils.getFunctionNameWithKind(node);\n            }\n\n            // Reports.\n            context.report({\n                node,\n                loc,\n                messageId: \"missingReturn\",\n                data: { name }\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    messageId: \"\",\n                    node\n                };\n            },\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement(node) {\n                const argument = node.argument;\n                let hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !isIdentifier(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n                    funcInfo.data = {\n                        name: funcInfo.node.type === \"Program\"\n                            ? \"Program\"\n                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                    };\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({\n                        node,\n                        messageId: funcInfo.messageId,\n                        data: funcInfo.data\n                    });\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}