{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar valueParser = _interopDefault(require('postcss-values-parser')); // return whether a node is a valid comma\n\n\nvar getComma = node => Object(node).type === 'comma';\n\nconst imageSetFunctionMatchRegExp = /^(-webkit-)?image-set$/i; // return a valid image\n\nvar getImage = node => // <url> | <image()> | <cross-fade()> | <gradient>\n// the image-set() function can not be nested inside of itself\nObject(node).type === 'func' && /^(cross-fade|image|(repeating-)?(conic|linear|radial)-gradient|url)$/i.test(node.value) && !(node.parent.parent && node.parent.parent.type === 'func' && imageSetFunctionMatchRegExp.test(node.parent.parent.value)) ? String(node) : Object(node).type === 'string' ? node.value : false;\n\nconst dpiRatios = {\n  dpcm: 2.54,\n  dpi: 1,\n  dppx: 96,\n  x: 96\n}; // return a valid @media rule\n\nvar getMedia = (node, mediasByDpr) => {\n  if (Object(node).type === 'number' && node.unit in dpiRatios) {\n    // calculate min-device-pixel-ratio and min-resolution\n    const dpi = Number(node.value) * dpiRatios[node.unit.toLowerCase()];\n    const dpr = Math.floor(dpi / dpiRatios.x * 100) / 100;\n\n    if (dpi in mediasByDpr) {\n      return false;\n    } else {\n      const media = mediasByDpr[dpi] = postcss.atRule({\n        name: 'media',\n        params: `(-webkit-min-device-pixel-ratio: ${dpr}), (min-resolution: ${dpi}dpi)`\n      });\n      return media;\n    }\n  } else {\n    return false;\n  }\n};\n\nvar handleInvalidation = (opts, message, word) => {\n  if (opts.oninvalid === 'warn') {\n    opts.decl.warn(opts.result, message, {\n      word: String(word)\n    });\n  } else if (opts.oninvalid === 'throw') {\n    throw opts.decl.error(message, {\n      word: String(word)\n    });\n  }\n};\n\nvar processImageSet = (imageSetOptionNodes, decl, opts) => {\n  const parent = decl.parent;\n  const mediasByDpr = {};\n  let length = imageSetOptionNodes.length;\n  let index = -1;\n\n  while (index < length) {\n    const _ref = [index < 0 ? true : getComma(imageSetOptionNodes[index]), getImage(imageSetOptionNodes[index + 1]), getMedia(imageSetOptionNodes[index + 2], mediasByDpr)],\n          comma = _ref[0],\n          value = _ref[1],\n          media = _ref[2]; // handle invalidations\n\n    if (!comma) {\n      return handleInvalidation(opts, 'unexpected comma', imageSetOptionNodes[index]);\n    } else if (!value) {\n      return handleInvalidation(opts, 'unexpected image', imageSetOptionNodes[index + 1]);\n    } else if (!media) {\n      return handleInvalidation(opts, 'unexpected resolution', imageSetOptionNodes[index + 2]);\n    } // prepare @media { decl: <image> }\n\n\n    const parentClone = parent.clone().removeAll();\n    const declClone = decl.clone({\n      value\n    });\n    parentClone.append(declClone);\n    media.append(parentClone);\n    index += 3;\n  }\n\n  const medias = Object.keys(mediasByDpr).sort((a, b) => a - b).map(params => mediasByDpr[params]); // conditionally prepend previous siblings\n\n  if (medias.length) {\n    const firstDecl = medias[0].nodes[0].nodes[0];\n\n    if (medias.length === 1) {\n      decl.value = firstDecl.value;\n    } else {\n      const siblings = parent.nodes;\n      const previousSiblings = siblings.slice(0, siblings.indexOf(decl)).concat(firstDecl);\n\n      if (previousSiblings.length) {\n        const parentClone = parent.cloneBefore().removeAll();\n        parentClone.append(previousSiblings);\n      } // prepend any @media { decl: <image> } rules\n\n\n      parent.before(medias.slice(1)); // conditionally remove the current rule\n\n      if (!opts.preserve) {\n        decl.remove(); // and then conditionally remove its parent\n\n        if (!parent.nodes.length) {\n          parent.remove();\n        }\n      }\n    }\n  }\n};\n\nconst imageSetValueMatchRegExp = /(^|[^\\w-])(-webkit-)?image-set\\(/;\nconst imageSetFunctionMatchRegExp$1 = /^(-webkit-)?image-set$/i;\nvar index = postcss.plugin('postcss-image-set-function', opts => {\n  // prepare options\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;\n  const oninvalid = 'oninvalid' in Object(opts) ? opts.oninvalid : 'ignore';\n  return (root, result) => {\n    // for every declaration\n    root.walkDecls(decl => {\n      const value = decl.value; // if a declaration likely uses an image-set() function\n\n      if (imageSetValueMatchRegExp.test(value)) {\n        const valueAST = valueParser(value).parse(); // process every image-set() function\n\n        valueAST.walkType('func', node => {\n          if (imageSetFunctionMatchRegExp$1.test(node.value)) {\n            processImageSet(node.nodes.slice(1, -1), decl, {\n              decl,\n              oninvalid,\n              preserve,\n              result\n            });\n          }\n        });\n      }\n    });\n  };\n});\nmodule.exports = index;","map":{"version":3,"sources":["lib/get-comma.js","lib/get-image.js","lib/get-media.js","lib/handle-invalidation.js","lib/process-image-set.js","index.js"],"names":["node","Object","imageSetFunctionMatchRegExp","String","dpiRatios","dpcm","dpi","dppx","x","Number","dpr","Math","media","mediasByDpr","name","params","opts","word","parent","decl","length","imageSetOptionNodes","index","comma","value","getComma","getImage","getMedia","handleInvalidation","parentClone","declClone","medias","a","firstDecl","siblings","previousSiblings","imageSetValueMatchRegExp","preserve","Boolean","oninvalid","root","valueAST","valueParser","processImageSet","result"],"mappings":";;;;;;;;qEAAA;;;AACA,IAAA,QAAA,GAAeA,IAAI,IAAIC,MAAM,CAANA,IAAM,CAANA,CAAAA,IAAAA,KAAvB,OAAA;;ACDA,MAAMC,2BAA2B,GAAjC,yBAAA,C,CAAA;;AAGA,IAAA,QAAA,GAAeF,IAAI,IAAA;;AAGlBC,MAAM,CAANA,IAAM,CAANA,CAAAA,IAAAA,KAAAA,MAAAA,IAAgC,wEAAA,IAAA,CAA6ED,IAAI,CAAjHC,KAAgC,CAAhCA,IAA4H,EAC3HD,IAAI,CAAJA,MAAAA,CAAAA,MAAAA,IAAsBA,IAAI,CAAJA,MAAAA,CAAAA,MAAAA,CAAAA,IAAAA,KAAtBA,MAAAA,IAA4DE,2BAA2B,CAA3BA,IAAAA,CAAiCF,IAAI,CAAJA,MAAAA,CAAAA,MAAAA,CAD9FC,KAC6DC,CAD+D,CAA5HD,GAGEE,MAAM,CAHRF,IAGQ,CAHRA,GAICA,MAAM,CAANA,IAAM,CAANA,CAAAA,IAAAA,KAAAA,QAAAA,GACCD,IAAI,CADLC,KAAAA,GAPF,KAAA;;ACDA,MAAMG,SAAS,GAAG;AAAEC,EAAAA,IAAI,EAAN,IAAA;AAAcC,EAAAA,GAAG,EAAjB,CAAA;AAAsBC,EAAAA,IAAI,EAA1B,EAAA;AAAgCC,EAAAA,CAAC,EAAE;AAAnC,CAAlB,C,CAAA;;AAGA,IAAA,QAAA,GAAe,CAAA,IAAA,EAAA,WAAA,KAAuB;MACjCP,MAAM,CAANA,IAAM,CAANA,CAAAA,IAAAA,KAAAA,QAAAA,IAAkCD,IAAI,CAAJA,IAAAA,IAAtC,S,EAA8D;;UAEvDM,GAAG,GAAGG,MAAM,CAACT,IAAI,CAAXS,KAAM,CAANA,GAAqBL,SAAS,CAACJ,IAAI,CAAJA,IAAAA,CAA3C,WAA2CA,EAAD,C;UACpCU,GAAG,GAAGC,IAAI,CAAJA,KAAAA,CAAWL,GAAG,GAAGF,SAAS,CAAfE,CAAAA,GAAXK,GAAAA,IAAZ,G;;QAEIL,GAAG,IAAP,W,EAAwB;aACvB,K;AADD,K,MAEO;YACAM,KAAK,GAAGC,WAAW,CAAXA,GAAW,CAAXA,GAAmB,OAAO,CAAP,MAAA,CAAe;AAC/CC,QAAAA,IAAI,EAD2C,OAAA;AAE/CC,QAAAA,MAAM,EAAG,oCAAmCL,GAAI,uBAAsBJ,GAAI;AAF3B,OAAf,C;aAKjC,K;;AAbF,G,MAeO;WACN,K;;AAjBF,CAAA;;ACLA,IAAA,kBAAA,GAAe,CAAA,IAAA,EAAA,OAAA,EAAA,IAAA,KAAyB;MACnCU,IAAI,CAAJA,SAAAA,KAAJ,M,EAA+B;AAC9BA,IAAAA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CAAeA,IAAI,CAAnBA,MAAAA,EAAAA,OAAAA,EAAqC;AAAEC,MAAAA,IAAI,EAAEd,MAAM,CAAA,IAAA;AAAd,KAArCa;AADD,G,MAEO,IAAIA,IAAI,CAAJA,SAAAA,KAAJ,OAAA,EAAgC;UAChC,IAAI,CAAJ,IAAA,CAAA,KAAA,CAAA,OAAA,EAAyB;AAAEC,MAAAA,IAAI,EAAEd,MAAM,CAAA,IAAA;AAAd,KAAzB,C;;AAJR,CAAA;;ACKA,IAAA,eAAA,GAAe,CAAA,mBAAA,EAAA,IAAA,EAAA,IAAA,KAAqC;QAC7Ce,MAAM,GAAGC,IAAI,CAAnB,M;QACMN,WAAW,GAAjB,E;MAEIO,MAAM,GAAGC,mBAAmB,CAAhC,M;MACIC,KAAK,GAAG,CAAZ,C;;SAEOA,KAAK,GAAZ,M,EAAuB;iBACQ,CAC7BA,KAAK,GAALA,CAAAA,GAAAA,IAAAA,GAAmBG,QAAQ,CAACJ,mBAAmB,CADlB,KACkB,CAApB,CADE,EAE7BK,QAAQ,CAACL,mBAAmB,CAACC,KAAK,GAFL,CAED,CAApB,CAFqB,EAG7BK,QAAQ,CAACN,mBAAmB,CAACC,KAAK,GAA1B,CAAoB,CAApB,EAJa,WAIb,CAHqB,C;UAAvBC,KADe,GAAA,IAAA,CAAA,CAAA,C;UACRC,KADQ,GAAA,IAAA,CAAA,CAAA,C;UACDZ,KADC,GAAA,IAAA,CAAA,CAAA,C,CAAA,CAAA;;QAQlB,CAAJ,K,EAAY;aACJgB,kBAAkB,CAAA,IAAA,EAAA,kBAAA,EAA2BP,mBAAmB,CAAvE,KAAuE,CAA9C,C;AAD1B,K,MAEO,IAAI,CAAJ,KAAA,EAAY;aACXO,kBAAkB,CAAA,IAAA,EAAA,kBAAA,EAA2BP,mBAAmB,CAACC,KAAK,GAA7E,CAAuE,CAA9C,C;AADnB,KAAA,MAEA,IAAI,CAAJ,KAAA,EAAY;aACXM,kBAAkB,CAAA,IAAA,EAAA,uBAAA,EAAgCP,mBAAmB,CAACC,KAAK,GAAlF,CAA4E,CAAnD,C;AAbJ,KAAA,CAAA;;;UAiBhBO,WAAW,GAAGX,MAAM,CAANA,KAAAA,GAApB,SAAoBA,E;UACdY,SAAS,GAAG,IAAI,CAAJ,KAAA,CAAW;AAAEN,MAAAA;AAAF,KAAX,C;AAElBK,IAAAA,WAAW,CAAXA,MAAAA,CAAAA,SAAAA;AACAjB,IAAAA,KAAK,CAALA,MAAAA,CAAAA,WAAAA;AAEAU,IAAAA,KAAK,IAALA,CAAAA;;;QAGKS,MAAM,GAAG9B,MAAM,CAANA,IAAAA,CAAAA,WAAAA,EAAAA,IAAAA,CAA8B,CAAA,CAAA,EAAA,CAAA,KAAU+B,CAAC,GAAzC/B,CAAAA,EAAAA,GAAAA,CAAmDc,MAAM,IAAIF,WAAW,CAjCpC,MAiCoC,CAAxEZ,C,CAjCoC,CAAA;;MAoC/C8B,MAAM,CAAV,M,EAAmB;UACZE,SAAS,GAAGF,MAAM,CAANA,CAAM,CAANA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAlB,CAAkBA,C;;QAEdA,MAAM,CAANA,MAAAA,KAAJ,C,EAAyB;AACxBZ,MAAAA,IAAI,CAAJA,KAAAA,GAAac,SAAS,CAAtBd,KAAAA;AADD,K,MAEO;YACAe,QAAQ,GAAGhB,MAAM,CAAvB,K;YACMiB,gBAAgB,GAAGD,QAAQ,CAARA,KAAAA,CAAAA,CAAAA,EAAkBA,QAAQ,CAARA,OAAAA,CAAlBA,IAAkBA,CAAlBA,EAAAA,MAAAA,CAAzB,SAAyBA,C;;UAErBC,gBAAgB,CAApB,M,EAA6B;cACtBN,WAAW,GAAGX,MAAM,CAANA,WAAAA,GAApB,SAAoBA,E;AAEpBW,QAAAA,WAAW,CAAXA,MAAAA,CAAAA,gBAAAA;AAPK,OAAA,CAAA;;;AAWNX,MAAAA,MAAM,CAANA,MAAAA,CAAca,MAAM,CAANA,KAAAA,CAXR,CAWQA,CAAdb,EAXM,CAAA;;UAcF,CAACF,IAAI,CAAT,Q,EAAoB;AACnBG,QAAAA,IAAI,CADe,MACnBA,GADmB,CAAA;;YAIf,CAACD,MAAM,CAANA,KAAAA,CAAL,M,EAA0B;AACzBA,UAAAA,MAAM,CAANA,MAAAA;;;;;AA5DL,CAAA;;ACDA,MAAMkB,wBAAwB,GAA9B,kCAAA;AACA,MAAMlC,6BAA2B,GAAjC,yBAAA;AAEA,IAAA,KAAA,GAAe,OAAO,CAAP,MAAA,CAAA,4BAAA,EAA6Cc,IAAI,IAAI;;QAE7DqB,QAAQ,GAAG,cAAcpC,MAAM,CAApB,IAAoB,CAApB,GAA6BqC,OAAO,CAACtB,IAAI,CAAzC,QAAoC,CAApC,GAAjB,I;QACMuB,SAAS,GAAG,eAAetC,MAAM,CAArB,IAAqB,CAArB,GAA8Be,IAAI,CAAlC,SAAA,GAAlB,Q;SAEO,CAAA,IAAA,EAAA,MAAA,KAAkB;;AAExBwB,IAAAA,IAAI,CAAJA,SAAAA,CAAerB,IAAI,IAAI;YACdK,KADc,GACJL,IADI,CAAA,K,CAAA,CAAA;;UAIlBiB,wBAAwB,CAAxBA,IAAAA,CAAJ,KAAIA,C,EAAsC;cACnCK,QAAQ,GAAGC,WAAW,CAAXA,KAAW,CAAXA,CADwB,KACxBA,E,CADwB,CAAA;;AAIzCD,QAAAA,QAAQ,CAARA,QAAAA,CAAAA,MAAAA,EAA0BzC,IAAI,IAAI;cAC7BE,6BAA2B,CAA3BA,IAAAA,CAAiCF,IAAI,CAAzC,KAAIE,C,EAA8C;AACjDyC,YAAAA,eAAe,CACd3C,IAAI,CAAJA,KAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAoB,CADN,CACdA,CADc,EAAA,IAAA,EAGd;AAAA,cAAA,IAAA;AAAA,cAAA,SAAA;AAAA,cAAA,QAAA;AAA6B4C,cAAAA;AAA7B,aAHc,CAAfD;;AAFFF,SAAAA;;AARFD,KAAAA;AAFD,G;AALD,CAAe,CAAf","sourcesContent":["// return whether a node is a valid comma\nexport default node => Object(node).type === 'comma';\n","const imageSetFunctionMatchRegExp = /^(-webkit-)?image-set$/i\n\n// return a valid image\nexport default node =>\n\t// <url> | <image()> | <cross-fade()> | <gradient>\n\t// the image-set() function can not be nested inside of itself\n\tObject(node).type === 'func' && /^(cross-fade|image|(repeating-)?(conic|linear|radial)-gradient|url)$/i.test(node.value) && !(\n\t\tnode.parent.parent && node.parent.parent.type === 'func' && imageSetFunctionMatchRegExp.test(node.parent.parent.value)\n\t)\n\t? String(node)\n: Object(node).type === 'string'\n\t? node.value\n: false;\n","import postcss from 'postcss';\n\nconst dpiRatios = { dpcm: 2.54, dpi: 1, dppx: 96, x: 96 };\n\n// return a valid @media rule\nexport default (node, mediasByDpr) => {\n\tif (Object(node).type === 'number' && node.unit in dpiRatios) {\n\t\t// calculate min-device-pixel-ratio and min-resolution\n\t\tconst dpi = Number(node.value) * dpiRatios[node.unit.toLowerCase()];\n\t\tconst dpr = Math.floor(dpi / dpiRatios.x * 100) / 100;\n\n\t\tif (dpi in mediasByDpr) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconst media = mediasByDpr[dpi] = postcss.atRule({\n\t\t\t\tname: 'media',\n\t\t\t\tparams: `(-webkit-min-device-pixel-ratio: ${dpr}), (min-resolution: ${dpi}dpi)`\n\t\t\t});\n\n\t\t\treturn media;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n};\n","export default (opts, message, word) => {\n\tif (opts.oninvalid === 'warn') {\n\t\topts.decl.warn(opts.result, message, { word: String(word) });\n\t} else if (opts.oninvalid === 'throw') {\n\t\tthrow opts.decl.error(message, { word: String(word) });\n\t}\n};\n","import getComma from './get-comma';\nimport getImage from './get-image';\nimport getMedia from './get-media';\nimport handleInvalidation from './handle-invalidation';\n\nexport default (imageSetOptionNodes, decl, opts) => {\n\tconst parent = decl.parent;\n\tconst mediasByDpr = {};\n\n\tlet length = imageSetOptionNodes.length;\n\tlet index = -1;\n\n\twhile (index < length) {\n\t\tconst [comma, value, media] = [\n\t\t\tindex < 0 ? true : getComma(imageSetOptionNodes[index]),\n\t\t\tgetImage(imageSetOptionNodes[index + 1]),\n\t\t\tgetMedia(imageSetOptionNodes[index + 2], mediasByDpr)\n\t\t];\n\n\t\t// handle invalidations\n\t\tif (!comma) {\n\t\t\treturn handleInvalidation(opts, 'unexpected comma', imageSetOptionNodes[index]);\n\t\t} else if (!value) {\n\t\t\treturn handleInvalidation(opts, 'unexpected image', imageSetOptionNodes[index + 1]);\n\t\t} else if (!media) {\n\t\t\treturn handleInvalidation(opts, 'unexpected resolution', imageSetOptionNodes[index + 2]);\n\t\t}\n\n\t\t// prepare @media { decl: <image> }\n\t\tconst parentClone = parent.clone().removeAll();\n\t\tconst declClone = decl.clone({ value });\n\n\t\tparentClone.append(declClone);\n\t\tmedia.append(parentClone);\n\n\t\tindex += 3\n\t}\n\n\tconst medias = Object.keys(mediasByDpr).sort((a, b) => a - b).map(params => mediasByDpr[params]);\n\n\t// conditionally prepend previous siblings\n\tif (medias.length) {\n\t\tconst firstDecl = medias[0].nodes[0].nodes[0];\n\n\t\tif (medias.length === 1) {\n\t\t\tdecl.value = firstDecl.value\n\t\t} else {\n\t\t\tconst siblings = parent.nodes;\n\t\t\tconst previousSiblings = siblings.slice(0, siblings.indexOf(decl)).concat(firstDecl);\n\n\t\t\tif (previousSiblings.length) {\n\t\t\t\tconst parentClone = parent.cloneBefore().removeAll();\n\n\t\t\t\tparentClone.append(previousSiblings);\n\t\t\t}\n\n\t\t\t// prepend any @media { decl: <image> } rules\n\t\t\tparent.before(medias.slice(1));\n\n\t\t\t// conditionally remove the current rule\n\t\t\tif (!opts.preserve) {\n\t\t\t\tdecl.remove();\n\n\t\t\t\t// and then conditionally remove its parent\n\t\t\t\tif (!parent.nodes.length) {\n\t\t\t\t\tparent.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import postcss from 'postcss';\nimport valueParser from 'postcss-values-parser';\nimport processImageSet from './lib/process-image-set';\n\nconst imageSetValueMatchRegExp = /(^|[^\\w-])(-webkit-)?image-set\\(/\nconst imageSetFunctionMatchRegExp = /^(-webkit-)?image-set$/i\n\nexport default postcss.plugin('postcss-image-set-function', opts => {\n\t// prepare options\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;\n\tconst oninvalid = 'oninvalid' in Object(opts) ? opts.oninvalid : 'ignore';\n\n\treturn (root, result) => {\n\t\t// for every declaration\n\t\troot.walkDecls(decl => {\n\t\t\tconst { value } = decl;\n\n\t\t\t// if a declaration likely uses an image-set() function\n\t\t\tif (imageSetValueMatchRegExp.test(value)) {\n\t\t\t\tconst valueAST = valueParser(value).parse();\n\n\t\t\t\t// process every image-set() function\n\t\t\t\tvalueAST.walkType('func', node => {\n\t\t\t\t\tif (imageSetFunctionMatchRegExp.test(node.value)) {\n\t\t\t\t\t\tprocessImageSet(\n\t\t\t\t\t\t\tnode.nodes.slice(1, -1),\n\t\t\t\t\t\t\tdecl,\n\t\t\t\t\t\t\t{ decl, oninvalid, preserve, result }\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}