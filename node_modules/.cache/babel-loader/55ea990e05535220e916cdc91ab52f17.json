{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.rangeRequests = function (e, n) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:range-requests:4.3.1\"] && _();\n  } catch (e) {}\n\n  async function t(e, t) {\n    try {\n      if (206 === t.status) return t;\n      const s = e.headers.get(\"range\");\n      if (!s) throw new n.WorkboxError(\"no-range-header\");\n\n      const a = function (e) {\n        const t = e.trim().toLowerCase();\n        if (!t.startsWith(\"bytes=\")) throw new n.WorkboxError(\"unit-must-be-bytes\", {\n          normalizedRangeHeader: t\n        });\n        if (t.includes(\",\")) throw new n.WorkboxError(\"single-range-only\", {\n          normalizedRangeHeader: t\n        });\n        const s = /(\\d*)-(\\d*)/.exec(t);\n        if (null === s || !s[1] && !s[2]) throw new n.WorkboxError(\"invalid-range-values\", {\n          normalizedRangeHeader: t\n        });\n        return {\n          start: \"\" === s[1] ? null : Number(s[1]),\n          end: \"\" === s[2] ? null : Number(s[2])\n        };\n      }(s),\n            r = await t.blob(),\n            i = function (e, t, s) {\n        const a = e.size;\n        if (s > a || t < 0) throw new n.WorkboxError(\"range-not-satisfiable\", {\n          size: a,\n          end: s,\n          start: t\n        });\n        let r, i;\n        return null === t ? (r = a - s, i = a) : null === s ? (r = t, i = a) : (r = t, i = s + 1), {\n          start: r,\n          end: i\n        };\n      }(r, a.start, a.end),\n            o = r.slice(i.start, i.end),\n            u = o.size,\n            l = new Response(o, {\n        status: 206,\n        statusText: \"Partial Content\",\n        headers: t.headers\n      });\n\n      return l.headers.set(\"Content-Length\", u), l.headers.set(\"Content-Range\", `bytes ${i.start}-${i.end - 1}/` + r.size), l;\n    } catch (e) {\n      return new Response(\"\", {\n        status: 416,\n        statusText: \"Range Not Satisfiable\"\n      });\n    }\n  }\n\n  return e.createPartialResponse = t, e.Plugin = class {\n    async cachedResponseWillBeUsed({\n      request: e,\n      cachedResponse: n\n    }) {\n      return n && e.headers.has(\"range\") ? await t(e, n) : n;\n    }\n\n  }, e;\n}({}, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../createPartialResponse.mjs","../utils/parseRangeHeader.mjs","../utils/calculateEffectiveBoundaries.mjs","../Plugin.mjs"],"names":["self","_","e","async","createPartialResponse","request","originalResponse","status","rangeHeader","headers","get","WorkboxError","boundaries","parseRangeHeader","originalBlob","blob","effectiveBoundaries","calculateEffectiveBoundaries","start","end","slicedBlob","slice","slicedBlobSize","size","slicedResponse","Response","statusText","set","error","normalizedRangeHeader","trim","toLowerCase","startsWith","includes","rangeParts","exec","Number","blobSize","effectiveStart","effectiveEnd","cachedResponse","has"],"mappings":";;;AAAA,MAAA;AAAIA,IAAAA,IAAAA,CAAK,8BAALA,CAAAA,IAAsCC,CAAAA,EAAtCD;AAA0C,GAA9C,CAA8C,OAAME,CAAN,EAAMA,CCoCpDC;;AAAAA,iBAAeC,CAAfD,CAAqCE,CAArCF,EAA8CG,CAA9CH,EAA8CG;AAAAA,QAAAA;AAAAA,UAgBV,QAA5BA,CAAAA,CAAiBC,MAhBqBD,EAgBrBC,OAGZD,CAHYC;AAGZD,YAGHE,CAAAA,GAAcH,CAAAA,CAAQI,OAARJ,CAAgBK,GAAhBL,CAAoB,OAApBA,CAHXC;AAG+B,UAAA,CACnCE,CADmC,EACnCA,MACG,IAAIG,CAAAA,CAAAA,YAAJ,CAAiB,iBAAjB,CADHH;;AACoB,YAGnBI,CAAAA,GC1CV,UAA0BJ,CAA1B,EAA0BA;AAAAA,cASlBqB,CAAAA,GAAwBrB,CAAAA,CAAYsB,IAAZtB,GAAmBuB,WAAnBvB,EATNA;AASyBuB,YAAAA,CAC5CF,CAAAA,CAAsBG,UAAtBH,CAAiC,QAAjCA,CAD4CE,EACX,MAC9B,IAAIpB,CAAAA,CAAAA,YAAJ,CAAiB,oBAAjB,EAAuC;AAACkB,UAAAA,qBAAAA,EAAAA;AAAD,SAAvC,CAD8B;AACUA,YAM5CA,CAAAA,CAAsBI,QAAtBJ,CAA+B,GAA/BA,CAN4CA,EAMb,MAC3B,IAAIlB,CAAAA,CAAAA,YAAJ,CAAiB,mBAAjB,EAAsC;AAACkB,UAAAA,qBAAAA,EAAAA;AAAD,SAAtC,CAD2B;AACYA,cAGzCK,CAAAA,GAAa,cAAcC,IAAd,CAAmBN,CAAnB,CAH4BA;AAGTA,YAEnB,SAAfK,CAAe,IAAfA,CAAyBA,CAAAA,CAAW,CAAXA,CAAzBA,IAAoC,CAAMA,CAAAA,CAAW,CAAXA,CAFRL,EAEmB,MACjD,IAAIlB,CAAAA,CAAAA,YAAJ,CAAiB,sBAAjB,EAAyC;AAACkB,UAAAA,qBAAAA,EAAAA;AAAD,SAAzC,CADiD;AACPA,eAG3C;AACLX,UAAAA,KAAAA,EAAyB,OAAlBgB,CAAAA,CAAW,CAAXA,CAAkB,GAAK,IAAL,GAAYE,MAAAA,CAAOF,CAAAA,CAAW,CAAXA,CAAPE,CADhC;AAELjB,UAAAA,GAAAA,EAAuB,OAAlBe,CAAAA,CAAW,CAAXA,CAAkB,GAAK,IAAL,GAAYE,MAAAA,CAAOF,CAAAA,CAAW,CAAXA,CAAPE;AAF9B,SAH2CP;ADkB7BhB,OC1CvB,CD0CwCL,CC1CxC,CDuC6B;AAAA,YAInBM,CAAAA,GAAAA,MAAqBR,CAAAA,CAAiBS,IAAjBT,EAJF;AAAA,YAMnBU,CAAAA,GE3CV,UAAsCD,CAAtC,EAA4CG,CAA5C,EAAmDC,CAAnD,EAAmDA;AAAAA,cAS3CkB,CAAAA,GAAWtB,CAAAA,CAAKQ,IAT2BJ;AAS3BI,YAElBJ,CAAAA,GAAMkB,CAANlB,IAAkBD,CAAAA,GAAQ,CAFRK,EAEQ,MACtB,IAAIZ,CAAAA,CAAAA,YAAJ,CAAiB,uBAAjB,EAA0C;AAC9CY,UAAAA,IAAAA,EAAMc,CADwC;AAE9ClB,UAAAA,GAAAA,EAAAA,CAF8C;AAG9CD,UAAAA,KAAAA,EAAAA;AAH8C,SAA1C,CADsB;AAI1BA,YAIAoB,CAJApB,EAKAqB,CALArB;AAKAqB,eAEU,SAAVrB,CAAU,IACZoB,CAAAA,GAAiBD,CAAAA,GAAWlB,CAA5BmB,EACAC,CAAAA,GAAeF,CAFH,IAGK,SAARlB,CAAQ,IACjBmB,CAAAA,GAAiBpB,CAAjBoB,EACAC,CAAAA,GAAeF,CAFE,KAIjBC,CAAAA,GAAiBpB,CAAjBoB,EAEAC,CAAAA,GAAepB,CAAAA,GAAM,CANJ,CAHL,EAYP;AACLD,UAAAA,KAAAA,EAAOoB,CADF;AAELnB,UAAAA,GAAAA,EAAKoB;AAFA,SAdHA;AFuB0BtB,OE3ChC,CF4CQH,CE5CR,EF4CsBF,CAAAA,CAAWM,KE5CjC,EF4CwCN,CAAAA,CAAWO,GE5CnD,CFqC6B;AAAA,YASnBC,CAAAA,GAAaN,CAAAA,CAAaO,KAAbP,CAAmBE,CAAAA,CAAoBE,KAAvCJ,EACfE,CAAAA,CAAoBG,GADLL,CATM;AAAA,YAWnBQ,CAAAA,GAAiBF,CAAAA,CAAWG,IAXT;AAAA,YAanBC,CAAAA,GAAiB,IAAIC,QAAJ,CAAaL,CAAb,EAAyB;AAG9Cb,QAAAA,MAAAA,EAAQ,GAHsC;AAI9CmB,QAAAA,UAAAA,EAAY,iBAJkC;AAK9CjB,QAAAA,OAAAA,EAASH,CAAAA,CAAiBG;AALoB,OAAzB,CAbE;;AAkBGA,aAG5Be,CAAAA,CAAef,OAAfe,CAAuBG,GAAvBH,CAA2B,gBAA3BA,EAA6CF,CAA7CE,GACAA,CAAAA,CAAef,OAAfe,CAAuBG,GAAvBH,CAA2B,eAA3BA,EAA2B,SACdR,CAAAA,CAAoBE,KAAAA,IAASF,CAAAA,CAAoBG,GAApBH,GAA0B,CAAA,GADzC,GAEzBF,CAAAA,CAAaS,IAFfC,CADAA,EAKOA,CARqBf;AAS5B,KAnD0CH,CAmD1C,OAAOsB,CAAP,EAAOA;AAAAA,aAWA,IAAIH,QAAJ,CAAa,EAAb,EAAiB;AACtBlB,QAAAA,MAAAA,EAAQ,GADc;AAEtBmB,QAAAA,UAAAA,EAAY;AAFU,OAAjB,CAXAE;AAaO;AAAA;;AAAA,SAAA,CAAA,CAAA,qBAAA,GAAA,CAAA,EAAA,CAAA,CAAA,MAAA,GG/ElB,MAAA;AAAA,UAAA,wBAAA,CAAA;AAYiCvB,MAAAA,OAAAA,EAACA,CAZlC;AAYiCA,MAAAA,cAAAA,EAAUmC;AAZ3C,KAAA,EAY2CA;AAAAA,aAGnCA,CAAAA,IAAkBnC,CAAAA,CAAQI,OAARJ,CAAgBoC,GAAhBpC,CAAoB,OAApBA,CAAlBmC,GAAsC,MAC3BpC,CAAAA,CAAsBC,CAAtBD,EAA+BoC,CAA/BpC,CADXoC,GAMGA,CATgCA;AAShCA;;AArBX,GH+EkB,EG1DPA,CH0DO;AG1DPA,C,CAAAA,E,EAAAA,OAAAA,CAAAA,IAAAA,CAAAA,Q","sourcesContent":["try{self['workbox:range-requests:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport {calculateEffectiveBoundaries} from\n  './utils/calculateEffectiveBoundaries.mjs';\nimport {parseRangeHeader} from './utils/parseRangeHeader.mjs';\n\nimport './_version.mjs';\n\n/**\n * Given a `Request` and `Response` objects as input, this will return a\n * promise for a new `Response`.\n *\n * If the original `Response` already contains partial content (i.e. it has\n * a status of 206), then this assumes it already fulfills the `Range:`\n * requirements, and will return it as-is.\n *\n * @param {Request} request A request, which should contain a Range:\n * header.\n * @param {Response} originalResponse A response.\n * @return {Promise<Response>} Either a `206 Partial Content` response, with\n * the response body set to the slice of content specified by the request's\n * `Range:` header, or a `416 Range Not Satisfiable` response if the\n * conditions of the `Range:` header can't be met.\n *\n * @memberof workbox.rangeRequests\n */\nasync function createPartialResponse(request, originalResponse) {\n  try {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-range-requests',\n        funcName: 'createPartialResponse',\n        paramName: 'request',\n      });\n\n      assert.isInstance(originalResponse, Response, {\n        moduleName: 'workbox-range-requests',\n        funcName: 'createPartialResponse',\n        paramName: 'originalResponse',\n      });\n    }\n\n    if (originalResponse.status === 206) {\n      // If we already have a 206, then just pass it through as-is;\n      // see https://github.com/GoogleChrome/workbox/issues/1720\n      return originalResponse;\n    }\n\n    const rangeHeader = request.headers.get('range');\n    if (!rangeHeader) {\n      throw new WorkboxError('no-range-header');\n    }\n\n    const boundaries = parseRangeHeader(rangeHeader);\n    const originalBlob = await originalResponse.blob();\n\n    const effectiveBoundaries = calculateEffectiveBoundaries(\n        originalBlob, boundaries.start, boundaries.end);\n\n    const slicedBlob = originalBlob.slice(effectiveBoundaries.start,\n        effectiveBoundaries.end);\n    const slicedBlobSize = slicedBlob.size;\n\n    const slicedResponse = new Response(slicedBlob, {\n      // Status code 206 is for a Partial Content response.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n      status: 206,\n      statusText: 'Partial Content',\n      headers: originalResponse.headers,\n    });\n\n    slicedResponse.headers.set('Content-Length', slicedBlobSize);\n    slicedResponse.headers.set('Content-Range',\n        `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` +\n      originalBlob.size);\n\n    return slicedResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.warn(`Unable to construct a partial response; returning a ` +\n        `416 Range Not Satisfiable response instead.`);\n      logger.groupCollapsed(`View details here.`);\n      logger.log(error);\n      logger.log(request);\n      logger.log(originalResponse);\n      logger.groupEnd();\n    }\n\n    return new Response('', {\n      status: 416,\n      statusText: 'Range Not Satisfiable',\n    });\n  }\n}\n\nexport {createPartialResponse};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport '../_version.mjs';\n\n/**\n * @param {string} rangeHeader A Range: header value.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the parsed value of the Range: header. If either the `start` or `end` are\n * omitted, then `null` will be returned.\n *\n * @private\n */\nfunction parseRangeHeader(rangeHeader) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(rangeHeader, 'string', {\n      moduleName: 'workbox-range-requests',\n      funcName: 'parseRangeHeader',\n      paramName: 'rangeHeader',\n    });\n  }\n\n  const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n  if (!normalizedRangeHeader.startsWith('bytes=')) {\n    throw new WorkboxError('unit-must-be-bytes', {normalizedRangeHeader});\n  }\n\n  // Specifying multiple ranges separate by commas is valid syntax, but this\n  // library only attempts to handle a single, contiguous sequence of bytes.\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n  if (normalizedRangeHeader.includes(',')) {\n    throw new WorkboxError('single-range-only', {normalizedRangeHeader});\n  }\n\n  const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n  // We need either at least one of the start or end values.\n  if (rangeParts === null || !(rangeParts[1] || rangeParts[2])) {\n    throw new WorkboxError('invalid-range-values', {normalizedRangeHeader});\n  }\n\n  return {\n    start: rangeParts[1] === '' ? null : Number(rangeParts[1]),\n    end: rangeParts[2] === '' ? null : Number(rangeParts[2]),\n  };\n}\n\nexport {parseRangeHeader};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport '../_version.mjs';\n\n/**\n * @param {Blob} blob A source blob.\n * @param {number|null} start The offset to use as the start of the\n * slice.\n * @param {number|null} end The offset to use as the end of the slice.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the effective boundaries to use given the size of the blob.\n *\n * @private\n */\nfunction calculateEffectiveBoundaries(blob, start, end) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(blob, Blob, {\n      moduleName: 'workbox-range-requests',\n      funcName: 'calculateEffectiveBoundaries',\n      paramName: 'blob',\n    });\n  }\n\n  const blobSize = blob.size;\n\n  if (end > blobSize || start < 0) {\n    throw new WorkboxError('range-not-satisfiable', {\n      size: blobSize,\n      end,\n      start,\n    });\n  }\n\n  let effectiveStart;\n  let effectiveEnd;\n\n  if (start === null) {\n    effectiveStart = blobSize - end;\n    effectiveEnd = blobSize;\n  } else if (end === null) {\n    effectiveStart = start;\n    effectiveEnd = blobSize;\n  } else {\n    effectiveStart = start;\n    // Range values are inclusive, so add 1 to the value.\n    effectiveEnd = end + 1;\n  }\n\n  return {\n    start: effectiveStart,\n    end: effectiveEnd,\n  };\n}\n\nexport {calculateEffectiveBoundaries};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {createPartialResponse} from './createPartialResponse.mjs';\n\nimport './_version.mjs';\n\n/**\n * The range request plugin makes it easy for a request with a 'Range' header to\n * be fulfilled by a cached response.\n *\n * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n * and returning the appropriate subset of the cached response body.\n *\n * @memberof workbox.rangeRequests\n */\nclass Plugin {\n  /**\n   * @param {Object} options\n   * @param {Request} options.request The original request, which may or may not\n   * contain a Range: header.\n   * @param {Response} options.cachedResponse The complete cached response.\n   * @return {Promise<Response>} If request contains a 'Range' header, then a\n   * new response with status 206 whose body is a subset of `cachedResponse` is\n   * returned. Otherwise, `cachedResponse` is returned as-is.\n   *\n   * @private\n   */\n  async cachedResponseWillBeUsed({request, cachedResponse}) {\n    // Only return a sliced response if there's something valid in the cache,\n    // and there's a Range: header in the request.\n    if (cachedResponse && request.headers.has('range')) {\n      return await createPartialResponse(request, cachedResponse);\n    }\n\n    // If there was no Range: header, or if cachedResponse wasn't valid, just\n    // pass it through as-is.\n    return cachedResponse;\n  }\n}\n\nexport {Plugin};\n"]},"metadata":{},"sourceType":"script"}