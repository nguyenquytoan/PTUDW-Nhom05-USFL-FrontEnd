{"ast":null,"code":"/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node A SwitchCase node to get comments.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\n\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n  const sourceCode = context.getSourceCode();\n  const comment = lodash.last(sourceCode.getCommentsBefore(node));\n  return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\n\n\nfunction hasBlankLinesBetween(node, token) {\n  return token.loc.start.line > node.loc.end.line + 1;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow fallthrough of `case` statements\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-fallthrough\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      case: \"Expected a 'break' statement before 'case'.\",\n      default: \"Expected a 'break' statement before 'default'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let currentCodePath = null;\n    const sourceCode = context.getSourceCode();\n    /*\n     * We need to use leading comments of the next SwitchCase node because\n     * trailing comments is wrong if semicolons are omitted.\n     */\n\n    let fallthroughCase = null;\n    let fallthroughCommentPattern = null;\n\n    if (options.commentPattern) {\n      fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n    } else {\n      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n    }\n\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      SwitchCase(node) {\n        /*\n         * Checks whether or not there is a fallthrough comment.\n         * And reports the previous fallthrough node if that does not exist.\n         */\n        if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n          context.report({\n            messageId: node.test ? \"case\" : \"default\",\n            node\n          });\n        }\n\n        fallthroughCase = null;\n      },\n\n      \"SwitchCase:exit\"(node) {\n        const nextToken = sourceCode.getTokenAfter(node);\n        /*\n         * `reachable` meant fall through because statements preceded by\n         * `break`, `return`, or `throw` are unreachable.\n         * And allows empty cases and the last case.\n         */\n\n        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && lodash.last(node.parent.cases) !== node) {\n          fallthroughCase = node;\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-fallthrough.js"],"names":["lodash","require","DEFAULT_FALLTHROUGH_COMMENT","hasFallthroughComment","node","context","fallthroughCommentPattern","sourceCode","getSourceCode","comment","last","getCommentsBefore","Boolean","test","value","isReachable","segment","reachable","hasBlankLinesBetween","token","loc","start","line","end","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","commentPattern","default","additionalProperties","messages","case","create","options","currentCodePath","fallthroughCase","RegExp","onCodePathStart","codePath","onCodePathEnd","upper","SwitchCase","report","messageId","nextToken","getTokenAfter","currentSegments","some","consequent","length","parent","cases"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node A SwitchCase node to get comments.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n    const comment = lodash.last(sourceCode.getCommentsBefore(node));\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        messageId: node.test ? \"case\" : \"default\",\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    lodash.last(node.parent.cases) !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}