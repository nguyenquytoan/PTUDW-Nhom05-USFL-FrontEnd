{"ast":null,"code":"/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce sorted import declarations within modules\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        },\n        memberSyntaxSortOrder: {\n          type: \"array\",\n          items: {\n            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n          },\n          uniqueItems: true,\n          minItems: 4,\n          maxItems: 4\n        },\n        ignoreDeclarationSort: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreMemberSort: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n          ignoreMemberSort = configuration.ignoreMemberSort || false,\n          memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n          sourceCode = context.getSourceCode();\n    let previousDeclaration = null;\n    /**\n     * Gets the used member syntax style.\n     *\n     * import \"my-module.js\" --> none\n     * import * as myModule from \"my-module.js\" --> all\n     * import {myMember} from \"my-module.js\" --> single\n     * import {foo, bar} from  \"my-module.js\" --> multiple\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n     */\n\n    function usedMemberSyntax(node) {\n      if (node.specifiers.length === 0) {\n        return \"none\";\n      }\n\n      if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n        return \"all\";\n      }\n\n      if (node.specifiers.length === 1) {\n        return \"single\";\n      }\n\n      return \"multiple\";\n    }\n    /**\n     * Gets the group by member parameter index for given declaration.\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {number} the declaration group by member index.\n     */\n\n\n    function getMemberParameterGroupIndex(node) {\n      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n    }\n    /**\n     * Gets the local name of the first imported module.\n     * @param {ASTNode} node the ImportDeclaration node.\n     * @returns {?string} the local name of the first imported module.\n     */\n\n\n    function getFirstLocalMemberName(node) {\n      if (node.specifiers[0]) {\n        return node.specifiers[0].local.name;\n      }\n\n      return null;\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (!ignoreDeclarationSort) {\n          if (previousDeclaration) {\n            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                  previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n            let currentLocalMemberName = getFirstLocalMemberName(node),\n                previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n            if (ignoreCase) {\n              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n            }\n            /*\n             * When the current declaration uses a different member syntax,\n             * then check if the ordering is correct.\n             * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n             */\n\n\n            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                context.report({\n                  node,\n                  message: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\",\n                  data: {\n                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                  }\n                });\n              }\n            } else {\n              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {\n                context.report({\n                  node,\n                  message: \"Imports should be sorted alphabetically.\"\n                });\n              }\n            }\n          }\n\n          previousDeclaration = node;\n        }\n\n        if (!ignoreMemberSort) {\n          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n          if (firstUnsortedIndex !== -1) {\n            context.report({\n              node: importSpecifiers[firstUnsortedIndex],\n              message: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n              data: {\n                memberName: importSpecifiers[firstUnsortedIndex].local.name\n              },\n\n              fix(fixer) {\n                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n                  // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                  return null;\n                }\n\n                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers // Clone the importSpecifiers array to avoid mutating it\n                .slice() // Sort the array into the desired order\n                .sort((specifierA, specifierB) => {\n                  const aName = getSortableName(specifierA);\n                  const bName = getSortableName(specifierB);\n                  return aName > bName ? 1 : -1;\n                }) // Build a string out of the sorted list of import specifiers and the text between the originals\n                .reduce((sourceText, specifier, index) => {\n                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? \"\" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                }, \"\"));\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/sort-imports.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","properties","ignoreCase","default","memberSyntaxSortOrder","items","enum","uniqueItems","minItems","maxItems","ignoreDeclarationSort","ignoreMemberSort","additionalProperties","fixable","create","context","configuration","options","sourceCode","getSourceCode","previousDeclaration","usedMemberSyntax","node","specifiers","length","getMemberParameterGroupIndex","indexOf","getFirstLocalMemberName","local","name","ImportDeclaration","currentMemberSyntaxGroupIndex","previousMemberSyntaxGroupIndex","currentLocalMemberName","previousLocalMemberName","toLowerCase","report","message","data","syntaxA","syntaxB","importSpecifiers","filter","specifier","getSortableName","firstUnsortedIndex","map","findIndex","index","array","memberName","fix","fixer","some","getCommentsBefore","getCommentsAfter","replaceTextRange","range","slice","sort","specifierA","specifierB","aName","bName","reduce","sourceText","textAfterSpecifier","getText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreDeclarationSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            }\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            }\n            if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (!ignoreDeclarationSort) {\n                    if (previousDeclaration) {\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                        if (ignoreCase) {\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                        }\n\n                        /*\n                         * When the current declaration uses a different member syntax,\n                         * then check if the ordering is correct.\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                         */\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                                context.report({\n                                    node,\n                                    message: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\",\n                                    data: {\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                    }\n                                });\n                            }\n                        } else {\n                            if (previousLocalMemberName &&\n                                currentLocalMemberName &&\n                                currentLocalMemberName < previousLocalMemberName\n                            ) {\n                                context.report({\n                                    node,\n                                    message: \"Imports should be sorted alphabetically.\"\n                                });\n                            }\n                        }\n                    }\n\n                    previousDeclaration = node;\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            message: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier =>\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}