{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRunner() {\n  const data = _interopRequireDefault(require('jest-runner'));\n\n  _jestRunner = function _jestRunner() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function _reporters() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function _testResult() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(require('./ReporterDispatcher'));\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // The default jest-runner is required because it is the default test runner\n// and required implicitly through the `runner` ProjectConfig option.\n\n\n_jestRunner().default;\n\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_context', void 0);\n\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n\n    this._setupReporters();\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  scheduleTests(tests, watcher) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const onStart = _this._dispatcher.onTestStart.bind(_this._dispatcher);\n\n      const timings = [];\n      const contexts = new Set();\n      tests.forEach(test => {\n        contexts.add(test.context);\n\n        if (test.duration) {\n          timings.push(test.duration);\n        }\n      });\n      const aggregatedResults = createAggregatedResults(tests.length);\n      const estimatedTime = Math.ceil(getEstimatedTime(timings, _this._globalConfig.maxWorkers) / 1000);\n      const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(tests, timings, _this._globalConfig);\n\n      const onResult = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (test, testResult) {\n          if (watcher.isInterrupted()) {\n            return Promise.resolve();\n          }\n\n          if (testResult.testResults.length === 0) {\n            const message = 'Your test suite must contain at least one test.';\n            return onFailure(test, {\n              message,\n              stack: new Error(message).stack\n            });\n          } // Throws when the context is leaked after executing a test.\n\n\n          if (testResult.leaks) {\n            const message = _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') + 'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' + '\\n' + 'There is a number of things that can leak memory:\\n' + '  - Async operations that have not finished (e.g. fs.readFile).\\n' + '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' + '  - Keeping references to the global scope.';\n            return onFailure(test, {\n              message,\n              stack: new Error(message).stack\n            });\n          }\n\n          (0, _testResult().addResult)(aggregatedResults, testResult);\n          yield _this._dispatcher.onTestResult(test, testResult, aggregatedResults);\n          return _this._bailIfNeeded(contexts, aggregatedResults, watcher);\n        });\n\n        return function onResult(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      const onFailure = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (test, error) {\n          if (watcher.isInterrupted()) {\n            return;\n          }\n\n          const testResult = (0, _testResult().buildFailureTestResult)(test.path, error);\n          testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(testResult.testExecError, test.context.config, _this._globalConfig, test.path);\n          (0, _testResult().addResult)(aggregatedResults, testResult);\n          yield _this._dispatcher.onTestResult(test, testResult, aggregatedResults);\n        });\n\n        return function onFailure(_x3, _x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      const updateSnapshotState = () => {\n        contexts.forEach(context => {\n          const status = _jestSnapshot().default.cleanup(context.hasteFS, _this._globalConfig.updateSnapshot, _jestSnapshot().default.buildSnapshotResolver(context.config), context.config.testPathIgnorePatterns);\n\n          aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n          aggregatedResults.snapshot.filesRemovedList = (aggregatedResults.snapshot.filesRemovedList || []).concat(status.filesRemovedList);\n        });\n        const updateAll = _this._globalConfig.updateSnapshot === 'all';\n        aggregatedResults.snapshot.didUpdate = updateAll;\n        aggregatedResults.snapshot.failure = !!(!updateAll && (aggregatedResults.snapshot.unchecked || aggregatedResults.snapshot.unmatched || aggregatedResults.snapshot.filesRemoved));\n      };\n\n      yield _this._dispatcher.onRunStart(aggregatedResults, {\n        estimatedTime,\n        showStatus: !runInBand\n      });\n      const testRunners = Object.create(null);\n      contexts.forEach(({\n        config\n      }) => {\n        if (!testRunners[config.runner]) {\n          const Runner = require(config.runner);\n\n          testRunners[config.runner] = new Runner(_this._globalConfig, {\n            changedFiles: _this._context && _this._context.changedFiles\n          });\n        }\n      });\n\n      const testsByRunner = _this._partitionTests(testRunners, tests);\n\n      if (testsByRunner) {\n        try {\n          var _arr = Object.keys(testRunners);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            const runner = _arr[_i];\n            yield testRunners[runner].runTests(testsByRunner[runner], watcher, onStart, onResult, onFailure, {\n              serial: runInBand || Boolean(testRunners[runner].isSerial)\n            });\n          }\n        } catch (error) {\n          if (!watcher.isInterrupted()) {\n            throw error;\n          }\n        }\n      }\n\n      updateSnapshotState();\n      aggregatedResults.wasInterrupted = watcher.isInterrupted();\n      yield _this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      const anyTestFailures = !(aggregatedResults.numFailedTests === 0 && aggregatedResults.numRuntimeErrorTestSuites === 0);\n\n      const anyReporterErrors = _this._dispatcher.hasErrors();\n\n      aggregatedResults.success = !(anyTestFailures || aggregatedResults.snapshot.failure || anyReporterErrors);\n      return aggregatedResults;\n    })();\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  _shouldAddDefaultReporters(reporters) {\n    return !reporters || !!reporters.find(reporter => this._getReporterProps(reporter).path === 'default');\n  }\n\n  _setupReporters() {\n    const _this$_globalConfig = this._globalConfig,\n          collectCoverage = _this$_globalConfig.collectCoverage,\n          notify = _this$_globalConfig.notify,\n          reporters = _this$_globalConfig.reporters;\n\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n\n    if (!isDefault && collectCoverage) {\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: this._context && this._context.changedFiles\n      }));\n    }\n\n    if (notify) {\n      this.addReporter(new (_reporters().NotifyReporter)(this._globalConfig, this._options.startRun, this._context));\n    }\n\n    if (reporters && Array.isArray(reporters)) {\n      this._addCustomReporters(reporters);\n    }\n  }\n\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(this._globalConfig.verbose ? new (_reporters().VerboseReporter)(this._globalConfig) : new (_reporters().DefaultReporter)(this._globalConfig));\n\n    if (collectCoverage) {\n      this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {\n        changedFiles: this._context && this._context.changedFiles\n      }));\n    }\n\n    this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));\n  }\n\n  _addCustomReporters(reporters) {\n    reporters.forEach(reporter => {\n      const _this$_getReporterPro = this._getReporterProps(reporter),\n            options = _this$_getReporterPro.options,\n            path = _this$_getReporterPro.path;\n\n      if (path === 'default') return;\n\n      try {\n        const Reporter = require(path);\n\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        throw new Error('An error occurred while adding the reporter at path \"' + path + '\".' + error.message);\n      }\n    });\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const _reporter = _slicedToArray(reporter, 2),\n            path = _reporter[0],\n            options = _reporter[1];\n\n      return {\n        options,\n        path\n      };\n    }\n\n    throw new Error('Reporter should be either a string or an array');\n  }\n\n  _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (this._globalConfig.bail !== 0 && aggregatedResults.numFailedTests >= this._globalConfig.bail) {\n      if (watcher.isWatchMode()) {\n        watcher.setState({\n          interrupted: true\n        });\n      } else {\n        const failureExit = () => (0, _exit().default)(1);\n\n        return this._dispatcher.onRunComplete(contexts, aggregatedResults).then(failureExit).catch(failureExit);\n      }\n    }\n\n    return Promise.resolve();\n  }\n\n}\n\nexports.default = TestScheduler;\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (!timings.length) {\n    return 0;\n  }\n\n  const max = Math.max.apply(null, timings);\n  return timings.length <= workers ? max : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@jest/core/build/TestScheduler.js"],"names":["Object","defineProperty","exports","value","default","_chalk","data","_interopRequireDefault","require","_jestMessageUtil","_jestSnapshot","_jestRunner","_reporters","_exit","_testResult","_ReporterDispatcher","_testSchedulerHelper","obj","__esModule","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","error","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","_defineProperty","enumerable","configurable","writable","TestScheduler","constructor","globalConfig","options","context","_dispatcher","_globalConfig","_options","_context","_setupReporters","addReporter","reporter","register","removeReporter","ReporterClass","unregister","scheduleTests","tests","watcher","_this","onStart","onTestStart","bind","timings","contexts","Set","forEach","test","add","duration","aggregatedResults","createAggregatedResults","estimatedTime","Math","ceil","getEstimatedTime","maxWorkers","runInBand","shouldRunInBand","onResult","_ref","testResult","isInterrupted","testResults","message","onFailure","stack","Error","leaks","red","bold","addResult","onTestResult","_bailIfNeeded","_x","_x2","_ref2","buildFailureTestResult","path","failureMessage","formatExecError","testExecError","config","_x3","_x4","updateSnapshotState","status","cleanup","hasteFS","updateSnapshot","buildSnapshotResolver","testPathIgnorePatterns","snapshot","filesRemoved","filesRemovedList","concat","updateAll","didUpdate","failure","unchecked","unmatched","onRunStart","showStatus","testRunners","create","runner","Runner","changedFiles","testsByRunner","_partitionTests","keys","runTests","serial","Boolean","isSerial","wasInterrupted","onRunComplete","anyTestFailures","numFailedTests","numRuntimeErrorTestSuites","anyReporterErrors","hasErrors","success","reduce","testRuns","assign","_shouldAddDefaultReporters","reporters","find","_getReporterProps","_this$_globalConfig","collectCoverage","notify","isDefault","_setupDefaultReporters","CoverageReporter","NotifyReporter","startRun","_addCustomReporters","verbose","VerboseReporter","DefaultReporter","SummaryReporter","_this$_getReporterPro","Reporter","_reporter","bail","isWatchMode","setState","interrupted","failureExit","catch","numTotalTestSuites","result","makeEmptyAggregatedTestResult","startTime","Date","now","workers","max","sum","time"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function _jestSnapshot() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRunner() {\n  const data = _interopRequireDefault(require('jest-runner'));\n\n  _jestRunner = function _jestRunner() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _reporters() {\n  const data = require('@jest/reporters');\n\n  _reporters = function _reporters() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _exit() {\n  const data = _interopRequireDefault(require('exit'));\n\n  _exit = function _exit() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _testResult() {\n  const data = require('@jest/test-result');\n\n  _testResult = function _testResult() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ReporterDispatcher = _interopRequireDefault(\n  require('./ReporterDispatcher')\n);\n\nvar _testSchedulerHelper = require('./testSchedulerHelper');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()\n  );\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (\n      var _i = arr[Symbol.iterator](), _s;\n      !(_n = (_s = _i.next()).done);\n      _n = true\n    ) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// The default jest-runner is required because it is the default test runner\n// and required implicitly through the `runner` ProjectConfig option.\n_jestRunner().default;\n\nclass TestScheduler {\n  constructor(globalConfig, options, context) {\n    _defineProperty(this, '_dispatcher', void 0);\n\n    _defineProperty(this, '_globalConfig', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_context', void 0);\n\n    this._dispatcher = new _ReporterDispatcher.default();\n    this._globalConfig = globalConfig;\n    this._options = options;\n    this._context = context;\n\n    this._setupReporters();\n  }\n\n  addReporter(reporter) {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(ReporterClass) {\n    this._dispatcher.unregister(ReporterClass);\n  }\n\n  scheduleTests(tests, watcher) {\n    var _this = this;\n\n    return _asyncToGenerator(function*() {\n      const onStart = _this._dispatcher.onTestStart.bind(_this._dispatcher);\n\n      const timings = [];\n      const contexts = new Set();\n      tests.forEach(test => {\n        contexts.add(test.context);\n\n        if (test.duration) {\n          timings.push(test.duration);\n        }\n      });\n      const aggregatedResults = createAggregatedResults(tests.length);\n      const estimatedTime = Math.ceil(\n        getEstimatedTime(timings, _this._globalConfig.maxWorkers) / 1000\n      );\n      const runInBand = (0, _testSchedulerHelper.shouldRunInBand)(\n        tests,\n        timings,\n        _this._globalConfig\n      );\n\n      const onResult =\n        /*#__PURE__*/\n        (function() {\n          var _ref = _asyncToGenerator(function*(test, testResult) {\n            if (watcher.isInterrupted()) {\n              return Promise.resolve();\n            }\n\n            if (testResult.testResults.length === 0) {\n              const message = 'Your test suite must contain at least one test.';\n              return onFailure(test, {\n                message,\n                stack: new Error(message).stack\n              });\n            } // Throws when the context is leaked after executing a test.\n\n            if (testResult.leaks) {\n              const message =\n                _chalk().default.red.bold('EXPERIMENTAL FEATURE!\\n') +\n                'Your test suite is leaking memory. Please ensure all references are cleaned.\\n' +\n                '\\n' +\n                'There is a number of things that can leak memory:\\n' +\n                '  - Async operations that have not finished (e.g. fs.readFile).\\n' +\n                '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' +\n                '  - Keeping references to the global scope.';\n              return onFailure(test, {\n                message,\n                stack: new Error(message).stack\n              });\n            }\n\n            (0, _testResult().addResult)(aggregatedResults, testResult);\n            yield _this._dispatcher.onTestResult(\n              test,\n              testResult,\n              aggregatedResults\n            );\n            return _this._bailIfNeeded(contexts, aggregatedResults, watcher);\n          });\n\n          return function onResult(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        })();\n\n      const onFailure =\n        /*#__PURE__*/\n        (function() {\n          var _ref2 = _asyncToGenerator(function*(test, error) {\n            if (watcher.isInterrupted()) {\n              return;\n            }\n\n            const testResult = (0, _testResult().buildFailureTestResult)(\n              test.path,\n              error\n            );\n            testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(\n              testResult.testExecError,\n              test.context.config,\n              _this._globalConfig,\n              test.path\n            );\n            (0, _testResult().addResult)(aggregatedResults, testResult);\n            yield _this._dispatcher.onTestResult(\n              test,\n              testResult,\n              aggregatedResults\n            );\n          });\n\n          return function onFailure(_x3, _x4) {\n            return _ref2.apply(this, arguments);\n          };\n        })();\n\n      const updateSnapshotState = () => {\n        contexts.forEach(context => {\n          const status = _jestSnapshot().default.cleanup(\n            context.hasteFS,\n            _this._globalConfig.updateSnapshot,\n            _jestSnapshot().default.buildSnapshotResolver(context.config),\n            context.config.testPathIgnorePatterns\n          );\n\n          aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n          aggregatedResults.snapshot.filesRemovedList = (\n            aggregatedResults.snapshot.filesRemovedList || []\n          ).concat(status.filesRemovedList);\n        });\n        const updateAll = _this._globalConfig.updateSnapshot === 'all';\n        aggregatedResults.snapshot.didUpdate = updateAll;\n        aggregatedResults.snapshot.failure = !!(\n          !updateAll &&\n          (aggregatedResults.snapshot.unchecked ||\n            aggregatedResults.snapshot.unmatched ||\n            aggregatedResults.snapshot.filesRemoved)\n        );\n      };\n\n      yield _this._dispatcher.onRunStart(aggregatedResults, {\n        estimatedTime,\n        showStatus: !runInBand\n      });\n      const testRunners = Object.create(null);\n      contexts.forEach(({config}) => {\n        if (!testRunners[config.runner]) {\n          const Runner = require(config.runner);\n\n          testRunners[config.runner] = new Runner(_this._globalConfig, {\n            changedFiles: _this._context && _this._context.changedFiles\n          });\n        }\n      });\n\n      const testsByRunner = _this._partitionTests(testRunners, tests);\n\n      if (testsByRunner) {\n        try {\n          var _arr = Object.keys(testRunners);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            const runner = _arr[_i];\n            yield testRunners[runner].runTests(\n              testsByRunner[runner],\n              watcher,\n              onStart,\n              onResult,\n              onFailure,\n              {\n                serial: runInBand || Boolean(testRunners[runner].isSerial)\n              }\n            );\n          }\n        } catch (error) {\n          if (!watcher.isInterrupted()) {\n            throw error;\n          }\n        }\n      }\n\n      updateSnapshotState();\n      aggregatedResults.wasInterrupted = watcher.isInterrupted();\n      yield _this._dispatcher.onRunComplete(contexts, aggregatedResults);\n      const anyTestFailures = !(\n        aggregatedResults.numFailedTests === 0 &&\n        aggregatedResults.numRuntimeErrorTestSuites === 0\n      );\n\n      const anyReporterErrors = _this._dispatcher.hasErrors();\n\n      aggregatedResults.success = !(\n        anyTestFailures ||\n        aggregatedResults.snapshot.failure ||\n        anyReporterErrors\n      );\n      return aggregatedResults;\n    })();\n  }\n\n  _partitionTests(testRunners, tests) {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests\n      });\n    } else {\n      return null;\n    }\n  }\n\n  _shouldAddDefaultReporters(reporters) {\n    return (\n      !reporters ||\n      !!reporters.find(\n        reporter => this._getReporterProps(reporter).path === 'default'\n      )\n    );\n  }\n\n  _setupReporters() {\n    const _this$_globalConfig = this._globalConfig,\n      collectCoverage = _this$_globalConfig.collectCoverage,\n      notify = _this$_globalConfig.notify,\n      reporters = _this$_globalConfig.reporters;\n\n    const isDefault = this._shouldAddDefaultReporters(reporters);\n\n    if (isDefault) {\n      this._setupDefaultReporters(collectCoverage);\n    }\n\n    if (!isDefault && collectCoverage) {\n      this.addReporter(\n        new (_reporters()).CoverageReporter(this._globalConfig, {\n          changedFiles: this._context && this._context.changedFiles\n        })\n      );\n    }\n\n    if (notify) {\n      this.addReporter(\n        new (_reporters()).NotifyReporter(\n          this._globalConfig,\n          this._options.startRun,\n          this._context\n        )\n      );\n    }\n\n    if (reporters && Array.isArray(reporters)) {\n      this._addCustomReporters(reporters);\n    }\n  }\n\n  _setupDefaultReporters(collectCoverage) {\n    this.addReporter(\n      this._globalConfig.verbose\n        ? new (_reporters()).VerboseReporter(this._globalConfig)\n        : new (_reporters()).DefaultReporter(this._globalConfig)\n    );\n\n    if (collectCoverage) {\n      this.addReporter(\n        new (_reporters()).CoverageReporter(this._globalConfig, {\n          changedFiles: this._context && this._context.changedFiles\n        })\n      );\n    }\n\n    this.addReporter(new (_reporters()).SummaryReporter(this._globalConfig));\n  }\n\n  _addCustomReporters(reporters) {\n    reporters.forEach(reporter => {\n      const _this$_getReporterPro = this._getReporterProps(reporter),\n        options = _this$_getReporterPro.options,\n        path = _this$_getReporterPro.path;\n\n      if (path === 'default') return;\n\n      try {\n        const Reporter = require(path);\n\n        this.addReporter(new Reporter(this._globalConfig, options));\n      } catch (error) {\n        throw new Error(\n          'An error occurred while adding the reporter at path \"' +\n            path +\n            '\".' +\n            error.message\n        );\n      }\n    });\n  }\n  /**\n   * Get properties of a reporter in an object\n   * to make dealing with them less painful.\n   */\n\n  _getReporterProps(reporter) {\n    if (typeof reporter === 'string') {\n      return {\n        options: this._options,\n        path: reporter\n      };\n    } else if (Array.isArray(reporter)) {\n      const _reporter = _slicedToArray(reporter, 2),\n        path = _reporter[0],\n        options = _reporter[1];\n\n      return {\n        options,\n        path\n      };\n    }\n\n    throw new Error('Reporter should be either a string or an array');\n  }\n\n  _bailIfNeeded(contexts, aggregatedResults, watcher) {\n    if (\n      this._globalConfig.bail !== 0 &&\n      aggregatedResults.numFailedTests >= this._globalConfig.bail\n    ) {\n      if (watcher.isWatchMode()) {\n        watcher.setState({\n          interrupted: true\n        });\n      } else {\n        const failureExit = () => (0, _exit().default)(1);\n\n        return this._dispatcher\n          .onRunComplete(contexts, aggregatedResults)\n          .then(failureExit)\n          .catch(failureExit);\n      }\n    }\n\n    return Promise.resolve();\n  }\n}\n\nexports.default = TestScheduler;\n\nconst createAggregatedResults = numTotalTestSuites => {\n  const result = (0, _testResult().makeEmptyAggregatedTestResult)();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings, workers) => {\n  if (!timings.length) {\n    return 0;\n  }\n\n  const max = Math.max.apply(null, timings);\n  return timings.length <= workers\n    ? max\n    : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};\n"]},"metadata":{},"sourceType":"script"}