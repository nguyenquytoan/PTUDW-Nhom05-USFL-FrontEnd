{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.rangeRequests = function (exports, WorkboxError_mjs, assert_mjs, logger_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:range-requests:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * @param {Blob} blob A source blob.\n   * @param {number|null} start The offset to use as the start of the\n   * slice.\n   * @param {number|null} end The offset to use as the end of the slice.\n   * @return {Object} An object with `start` and `end` properties, reflecting\n   * the effective boundaries to use given the size of the blob.\n   *\n   * @private\n   */\n\n\n  function calculateEffectiveBoundaries(blob, start, end) {\n    {\n      assert_mjs.assert.isInstance(blob, Blob, {\n        moduleName: 'workbox-range-requests',\n        funcName: 'calculateEffectiveBoundaries',\n        paramName: 'blob'\n      });\n    }\n    const blobSize = blob.size;\n\n    if (end > blobSize || start < 0) {\n      throw new WorkboxError_mjs.WorkboxError('range-not-satisfiable', {\n        size: blobSize,\n        end,\n        start\n      });\n    }\n\n    let effectiveStart;\n    let effectiveEnd;\n\n    if (start === null) {\n      effectiveStart = blobSize - end;\n      effectiveEnd = blobSize;\n    } else if (end === null) {\n      effectiveStart = start;\n      effectiveEnd = blobSize;\n    } else {\n      effectiveStart = start; // Range values are inclusive, so add 1 to the value.\n\n      effectiveEnd = end + 1;\n    }\n\n    return {\n      start: effectiveStart,\n      end: effectiveEnd\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * @param {string} rangeHeader A Range: header value.\n   * @return {Object} An object with `start` and `end` properties, reflecting\n   * the parsed value of the Range: header. If either the `start` or `end` are\n   * omitted, then `null` will be returned.\n   *\n   * @private\n   */\n\n\n  function parseRangeHeader(rangeHeader) {\n    {\n      assert_mjs.assert.isType(rangeHeader, 'string', {\n        moduleName: 'workbox-range-requests',\n        funcName: 'parseRangeHeader',\n        paramName: 'rangeHeader'\n      });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n\n    if (!normalizedRangeHeader.startsWith('bytes=')) {\n      throw new WorkboxError_mjs.WorkboxError('unit-must-be-bytes', {\n        normalizedRangeHeader\n      });\n    } // Specifying multiple ranges separate by commas is valid syntax, but this\n    // library only attempts to handle a single, contiguous sequence of bytes.\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n\n\n    if (normalizedRangeHeader.includes(',')) {\n      throw new WorkboxError_mjs.WorkboxError('single-range-only', {\n        normalizedRangeHeader\n      });\n    }\n\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader); // We need either at least one of the start or end values.\n\n    if (rangeParts === null || !(rangeParts[1] || rangeParts[2])) {\n      throw new WorkboxError_mjs.WorkboxError('invalid-range-values', {\n        normalizedRangeHeader\n      });\n    }\n\n    return {\n      start: rangeParts[1] === '' ? null : Number(rangeParts[1]),\n      end: rangeParts[2] === '' ? null : Number(rangeParts[2])\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Given a `Request` and `Response` objects as input, this will return a\n   * promise for a new `Response`.\n   *\n   * If the original `Response` already contains partial content (i.e. it has\n   * a status of 206), then this assumes it already fulfills the `Range:`\n   * requirements, and will return it as-is.\n   *\n   * @param {Request} request A request, which should contain a Range:\n   * header.\n   * @param {Response} originalResponse A response.\n   * @return {Promise<Response>} Either a `206 Partial Content` response, with\n   * the response body set to the slice of content specified by the request's\n   * `Range:` header, or a `416 Range Not Satisfiable` response if the\n   * conditions of the `Range:` header can't be met.\n   *\n   * @memberof workbox.rangeRequests\n   */\n\n\n  async function createPartialResponse(request, originalResponse) {\n    try {\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-range-requests',\n          funcName: 'createPartialResponse',\n          paramName: 'request'\n        });\n        assert_mjs.assert.isInstance(originalResponse, Response, {\n          moduleName: 'workbox-range-requests',\n          funcName: 'createPartialResponse',\n          paramName: 'originalResponse'\n        });\n      }\n\n      if (originalResponse.status === 206) {\n        // If we already have a 206, then just pass it through as-is;\n        // see https://github.com/GoogleChrome/workbox/issues/1720\n        return originalResponse;\n      }\n\n      const rangeHeader = request.headers.get('range');\n\n      if (!rangeHeader) {\n        throw new WorkboxError_mjs.WorkboxError('no-range-header');\n      }\n\n      const boundaries = parseRangeHeader(rangeHeader);\n      const originalBlob = await originalResponse.blob();\n      const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n      const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n      const slicedBlobSize = slicedBlob.size;\n      const slicedResponse = new Response(slicedBlob, {\n        // Status code 206 is for a Partial Content response.\n        // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n        status: 206,\n        statusText: 'Partial Content',\n        headers: originalResponse.headers\n      });\n      slicedResponse.headers.set('Content-Length', slicedBlobSize);\n      slicedResponse.headers.set('Content-Range', `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` + originalBlob.size);\n      return slicedResponse;\n    } catch (error) {\n      {\n        logger_mjs.logger.warn(`Unable to construct a partial response; returning a ` + `416 Range Not Satisfiable response instead.`);\n        logger_mjs.logger.groupCollapsed(`View details here.`);\n        logger_mjs.logger.log(error);\n        logger_mjs.logger.log(request);\n        logger_mjs.logger.log(originalResponse);\n        logger_mjs.logger.groupEnd();\n      }\n      return new Response('', {\n        status: 416,\n        statusText: 'Range Not Satisfiable'\n      });\n    }\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * The range request plugin makes it easy for a request with a 'Range' header to\n   * be fulfilled by a cached response.\n   *\n   * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n   * and returning the appropriate subset of the cached response body.\n   *\n   * @memberof workbox.rangeRequests\n   */\n\n\n  class Plugin {\n    /**\n     * @param {Object} options\n     * @param {Request} options.request The original request, which may or may not\n     * contain a Range: header.\n     * @param {Response} options.cachedResponse The complete cached response.\n     * @return {Promise<Response>} If request contains a 'Range' header, then a\n     * new response with status 206 whose body is a subset of `cachedResponse` is\n     * returned. Otherwise, `cachedResponse` is returned as-is.\n     *\n     * @private\n     */\n    async cachedResponseWillBeUsed({\n      request,\n      cachedResponse\n    }) {\n      // Only return a sliced response if there's something valid in the cache,\n      // and there's a Range: header in the request.\n      if (cachedResponse && request.headers.has('range')) {\n        return await createPartialResponse(request, cachedResponse);\n      } // If there was no Range: header, or if cachedResponse wasn't valid, just\n      // pass it through as-is.\n\n\n      return cachedResponse;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.createPartialResponse = createPartialResponse;\n  exports.Plugin = Plugin;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../utils/calculateEffectiveBoundaries.mjs","../utils/parseRangeHeader.mjs","../createPartialResponse.mjs","../Plugin.mjs","../index.mjs"],"names":["self","_","assert","moduleName","funcName","paramName","blobSize","blob","end","start","WorkboxError","size","effectiveStart","effectiveEnd","normalizedRangeHeader","rangeHeader","rangeParts","Number","originalResponse","request","boundaries","parseRangeHeader","originalBlob","effectiveBoundaries","calculateEffectiveBoundaries","slicedBlob","slicedBlobSize","slicedResponse","status","statusText","headers","logger","cachedResponse","createPartialResponse"],"mappings":";;;;;AAAA,MAAG;AAACA,IAAAA,IAAI,CAAJA,8BAAI,CAAJA,IAAsCC,CAAtCD,EAAAA;AAAJ,GAAA,CAA8C,OAAA,CAAA,EAAQ,CAAA,C,CAAA;;ACAtD;;;;;;;AAaA;;;;;;;;;;;;AAUA,WAAA,4BAAA,CAAA,IAAA,EAAA,KAAA,EAAA,GAAA,EAAwD;AACX;AACzCE,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAA8B;AAC5BC,QAAAA,UAAU,EADkB,wBAAA;AAE5BC,QAAAA,QAAQ,EAFoB,8BAAA;AAG5BC,QAAAA,SAAS,EAAE;AAHiB,OAA9BH;AAKD;AAED,UAAMI,QAAQ,GAAGC,IAAI,CAArB,IAAA;;AAEA,QAAIC,GAAG,GAAHA,QAAAA,IAAkBC,KAAK,GAA3B,CAAA,EAAiC;AAC/B,YAAM,IAAIC,gBAAAA,CAAJ,YAAA,CAAA,uBAAA,EAA0C;AAC9CC,QAAAA,IAAI,EAD0C,QAAA;AAAA,QAAA,GAAA;AAG9CF,QAAAA;AAH8C,OAA1C,CAAN;AAKD;;AAED,QAAA,cAAA;AACA,QAAA,YAAA;;AAEA,QAAIA,KAAK,KAAT,IAAA,EAAoB;AAClBG,MAAAA,cAAc,GAAGN,QAAQ,GAAzBM,GAAAA;AACAC,MAAAA,YAAY,GAAZA,QAAAA;AAFF,KAAA,MAGO,IAAIL,GAAG,KAAP,IAAA,EAAkB;AACvBI,MAAAA,cAAc,GAAdA,KAAAA;AACAC,MAAAA,YAAY,GAAZA,QAAAA;AAFK,KAAA,MAGA;AACLD,MAAAA,cAAc,GADT,KACLA,CADK,CAAA;;AAGLC,MAAAA,YAAY,GAAGL,GAAG,GAAlBK,CAAAA;AACD;;AAED,WAAO;AACLJ,MAAAA,KAAK,EADA,cAAA;AAELD,MAAAA,GAAG,EAAEK;AAFA,KAAP;AAID;AC7DD;;;;;;;AAaA;;;;;;;;;;AAQA,WAAA,gBAAA,CAAA,WAAA,EAAuC;AACM;AACzCX,MAAAA,UAAAA,CAAAA,MAAAA,CAAAA,MAAAA,CAAAA,WAAAA,EAAAA,QAAAA,EAAqC;AACnCC,QAAAA,UAAU,EADyB,wBAAA;AAEnCC,QAAAA,QAAQ,EAF2B,kBAAA;AAGnCC,QAAAA,SAAS,EAAE;AAHwB,OAArCH;AAKD;AAED,UAAMY,qBAAqB,GAAGC,WAAW,CAAXA,IAAAA,GAA9B,WAA8BA,EAA9B;;AACA,QAAI,CAACD,qBAAqB,CAArBA,UAAAA,CAAL,QAAKA,CAAL,EAAiD;AAC/C,YAAM,IAAIJ,gBAAAA,CAAJ,YAAA,CAAA,oBAAA,EAAuC;AAACI,QAAAA;AAAD,OAAvC,CAAN;AAXmC,KAAA,CAAA;AAerC;AACA;;;AACA,QAAIA,qBAAqB,CAArBA,QAAAA,CAAJ,GAAIA,CAAJ,EAAyC;AACvC,YAAM,IAAIJ,gBAAAA,CAAJ,YAAA,CAAA,mBAAA,EAAsC;AAACI,QAAAA;AAAD,OAAtC,CAAN;AACD;;AAED,UAAME,UAAU,GAAG,cAAA,IAAA,CArBkB,qBAqBlB,CAAnB,CArBqC,CAAA;;AAuBrC,QAAIA,UAAU,KAAVA,IAAAA,IAAuB,EAAEA,UAAU,CAAVA,CAAU,CAAVA,IAAiBA,UAAU,CAAxD,CAAwD,CAA7B,CAA3B,EAA8D;AAC5D,YAAM,IAAIN,gBAAAA,CAAJ,YAAA,CAAA,sBAAA,EAAyC;AAACI,QAAAA;AAAD,OAAzC,CAAN;AACD;;AAED,WAAO;AACLL,MAAAA,KAAK,EAAEO,UAAU,CAAVA,CAAU,CAAVA,KAAAA,EAAAA,GAAAA,IAAAA,GAA8BC,MAAM,CAACD,UAAU,CADjD,CACiD,CAAX,CADtC;AAELR,MAAAA,GAAG,EAAEQ,UAAU,CAAVA,CAAU,CAAVA,KAAAA,EAAAA,GAAAA,IAAAA,GAA8BC,MAAM,CAACD,UAAU,CAAX,CAAW,CAAX;AAFpC,KAAP;AAID;ACpDD;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;AAkBA,iBAAA,qBAAA,CAAA,OAAA,EAAA,gBAAA,EAAgE;AAC9D,QAAI;AACyC;AACzCd,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,UAAAA,CAAAA,OAAAA,EAAAA,OAAAA,EAAoC;AAClCC,UAAAA,UAAU,EADwB,wBAAA;AAElCC,UAAAA,QAAQ,EAF0B,uBAAA;AAGlCC,UAAAA,SAAS,EAAE;AAHuB,SAApCH;AAMAA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,UAAAA,CAAAA,gBAAAA,EAAAA,QAAAA,EAA8C;AAC5CC,UAAAA,UAAU,EADkC,wBAAA;AAE5CC,UAAAA,QAAQ,EAFoC,uBAAA;AAG5CC,UAAAA,SAAS,EAAE;AAHiC,SAA9CH;AAKD;;AAED,UAAIgB,gBAAgB,CAAhBA,MAAAA,KAAJ,GAAA,EAAqC;AACnC;AACA;AACA,eAAA,gBAAA;AACD;;AAED,YAAMH,WAAW,GAAGI,OAAO,CAAPA,OAAAA,CAAAA,GAAAA,CAApB,OAAoBA,CAApB;;AACA,UAAI,CAAJ,WAAA,EAAkB;AAChB,cAAM,IAAIT,gBAAAA,CAAJ,YAAA,CAAN,iBAAM,CAAN;AACD;;AAED,YAAMU,UAAU,GAAGC,gBAAgB,CAAnC,WAAmC,CAAnC;AACA,YAAMC,YAAY,GAAG,MAAMJ,gBAAgB,CAA3C,IAA2BA,EAA3B;AAEA,YAAMK,mBAAmB,GAAGC,4BAA4B,CAAA,YAAA,EACtCJ,UAAU,CAD4B,KAAA,EACpBA,UAAU,CAD9C,GAAwD,CAAxD;AAGA,YAAMK,UAAU,GAAGH,YAAY,CAAZA,KAAAA,CAAmBC,mBAAmB,CAAtCD,KAAAA,EACfC,mBAAmB,CADvB,GAAmBD,CAAnB;AAEA,YAAMI,cAAc,GAAGD,UAAU,CAAjC,IAAA;AAEA,YAAME,cAAc,GAAG,IAAA,QAAA,CAAA,UAAA,EAAyB;AAC9C;AACA;AACAC,QAAAA,MAAM,EAHwC,GAAA;AAI9CC,QAAAA,UAAU,EAJoC,iBAAA;AAK9CC,QAAAA,OAAO,EAAEZ,gBAAgB,CAACY;AALoB,OAAzB,CAAvB;AAQAH,MAAAA,cAAc,CAAdA,OAAAA,CAAAA,GAAAA,CAAAA,gBAAAA,EAAAA,cAAAA;AACAA,MAAAA,cAAc,CAAdA,OAAAA,CAAAA,GAAAA,CAAAA,eAAAA,EACK,SAAQJ,mBAAmB,CAACd,KAAM,IAAGc,mBAAmB,CAAnBA,GAAAA,GAA0B,CAAhE,GAAC,GACHD,YAAY,CAFdK,IAAAA;AAIA,aAAA,cAAA;AAjDF,KAAA,CAkDE,OAAA,KAAA,EAAc;AAC6B;AACzCI,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CAAY,sDAAC,GAAbA,6CAAAA;AAEAA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,cAAAA,CAAAA,oBAAAA;AACAA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,KAAAA;AACAA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,OAAAA;AACAA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,gBAAAA;AACAA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA;AACD;AAED,aAAO,IAAA,QAAA,CAAA,EAAA,EAAiB;AACtBH,QAAAA,MAAM,EADgB,GAAA;AAEtBC,QAAAA,UAAU,EAAE;AAFU,OAAjB,CAAP;AAID;AACF;ACvGD;;;;;;;AAYA;;;;;;;;;;;AASA,QAAA,MAAA,CAAa;AACX;;;;;;;;;;;AAWA,UAAA,wBAAA,CAA+B;AAAA,MAAA,OAAA;AAAUG,MAAAA;AAAV,KAA/B,EAA0D;AACxD;AACA;AACA,UAAIA,cAAc,IAAIb,OAAO,CAAPA,OAAAA,CAAAA,GAAAA,CAAtB,OAAsBA,CAAtB,EAAoD;AAClD,eAAO,MAAMc,qBAAqB,CAAA,OAAA,EAAlC,cAAkC,CAAlC;AAJsD,OAAA,CAAA;AAQxD;;;AACA,aAAA,cAAA;AACD;;AAtBU;ACrBb","sourcesContent":["try{self['workbox:range-requests:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport '../_version.mjs';\n\n/**\n * @param {Blob} blob A source blob.\n * @param {number|null} start The offset to use as the start of the\n * slice.\n * @param {number|null} end The offset to use as the end of the slice.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the effective boundaries to use given the size of the blob.\n *\n * @private\n */\nfunction calculateEffectiveBoundaries(blob, start, end) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(blob, Blob, {\n      moduleName: 'workbox-range-requests',\n      funcName: 'calculateEffectiveBoundaries',\n      paramName: 'blob',\n    });\n  }\n\n  const blobSize = blob.size;\n\n  if (end > blobSize || start < 0) {\n    throw new WorkboxError('range-not-satisfiable', {\n      size: blobSize,\n      end,\n      start,\n    });\n  }\n\n  let effectiveStart;\n  let effectiveEnd;\n\n  if (start === null) {\n    effectiveStart = blobSize - end;\n    effectiveEnd = blobSize;\n  } else if (end === null) {\n    effectiveStart = start;\n    effectiveEnd = blobSize;\n  } else {\n    effectiveStart = start;\n    // Range values are inclusive, so add 1 to the value.\n    effectiveEnd = end + 1;\n  }\n\n  return {\n    start: effectiveStart,\n    end: effectiveEnd,\n  };\n}\n\nexport {calculateEffectiveBoundaries};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport '../_version.mjs';\n\n/**\n * @param {string} rangeHeader A Range: header value.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the parsed value of the Range: header. If either the `start` or `end` are\n * omitted, then `null` will be returned.\n *\n * @private\n */\nfunction parseRangeHeader(rangeHeader) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(rangeHeader, 'string', {\n      moduleName: 'workbox-range-requests',\n      funcName: 'parseRangeHeader',\n      paramName: 'rangeHeader',\n    });\n  }\n\n  const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n  if (!normalizedRangeHeader.startsWith('bytes=')) {\n    throw new WorkboxError('unit-must-be-bytes', {normalizedRangeHeader});\n  }\n\n  // Specifying multiple ranges separate by commas is valid syntax, but this\n  // library only attempts to handle a single, contiguous sequence of bytes.\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n  if (normalizedRangeHeader.includes(',')) {\n    throw new WorkboxError('single-range-only', {normalizedRangeHeader});\n  }\n\n  const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n  // We need either at least one of the start or end values.\n  if (rangeParts === null || !(rangeParts[1] || rangeParts[2])) {\n    throw new WorkboxError('invalid-range-values', {normalizedRangeHeader});\n  }\n\n  return {\n    start: rangeParts[1] === '' ? null : Number(rangeParts[1]),\n    end: rangeParts[2] === '' ? null : Number(rangeParts[2]),\n  };\n}\n\nexport {parseRangeHeader};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport {calculateEffectiveBoundaries} from\n  './utils/calculateEffectiveBoundaries.mjs';\nimport {parseRangeHeader} from './utils/parseRangeHeader.mjs';\n\nimport './_version.mjs';\n\n/**\n * Given a `Request` and `Response` objects as input, this will return a\n * promise for a new `Response`.\n *\n * If the original `Response` already contains partial content (i.e. it has\n * a status of 206), then this assumes it already fulfills the `Range:`\n * requirements, and will return it as-is.\n *\n * @param {Request} request A request, which should contain a Range:\n * header.\n * @param {Response} originalResponse A response.\n * @return {Promise<Response>} Either a `206 Partial Content` response, with\n * the response body set to the slice of content specified by the request's\n * `Range:` header, or a `416 Range Not Satisfiable` response if the\n * conditions of the `Range:` header can't be met.\n *\n * @memberof workbox.rangeRequests\n */\nasync function createPartialResponse(request, originalResponse) {\n  try {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-range-requests',\n        funcName: 'createPartialResponse',\n        paramName: 'request',\n      });\n\n      assert.isInstance(originalResponse, Response, {\n        moduleName: 'workbox-range-requests',\n        funcName: 'createPartialResponse',\n        paramName: 'originalResponse',\n      });\n    }\n\n    if (originalResponse.status === 206) {\n      // If we already have a 206, then just pass it through as-is;\n      // see https://github.com/GoogleChrome/workbox/issues/1720\n      return originalResponse;\n    }\n\n    const rangeHeader = request.headers.get('range');\n    if (!rangeHeader) {\n      throw new WorkboxError('no-range-header');\n    }\n\n    const boundaries = parseRangeHeader(rangeHeader);\n    const originalBlob = await originalResponse.blob();\n\n    const effectiveBoundaries = calculateEffectiveBoundaries(\n        originalBlob, boundaries.start, boundaries.end);\n\n    const slicedBlob = originalBlob.slice(effectiveBoundaries.start,\n        effectiveBoundaries.end);\n    const slicedBlobSize = slicedBlob.size;\n\n    const slicedResponse = new Response(slicedBlob, {\n      // Status code 206 is for a Partial Content response.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n      status: 206,\n      statusText: 'Partial Content',\n      headers: originalResponse.headers,\n    });\n\n    slicedResponse.headers.set('Content-Length', slicedBlobSize);\n    slicedResponse.headers.set('Content-Range',\n        `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` +\n      originalBlob.size);\n\n    return slicedResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.warn(`Unable to construct a partial response; returning a ` +\n        `416 Range Not Satisfiable response instead.`);\n      logger.groupCollapsed(`View details here.`);\n      logger.log(error);\n      logger.log(request);\n      logger.log(originalResponse);\n      logger.groupEnd();\n    }\n\n    return new Response('', {\n      status: 416,\n      statusText: 'Range Not Satisfiable',\n    });\n  }\n}\n\nexport {createPartialResponse};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {createPartialResponse} from './createPartialResponse.mjs';\n\nimport './_version.mjs';\n\n/**\n * The range request plugin makes it easy for a request with a 'Range' header to\n * be fulfilled by a cached response.\n *\n * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n * and returning the appropriate subset of the cached response body.\n *\n * @memberof workbox.rangeRequests\n */\nclass Plugin {\n  /**\n   * @param {Object} options\n   * @param {Request} options.request The original request, which may or may not\n   * contain a Range: header.\n   * @param {Response} options.cachedResponse The complete cached response.\n   * @return {Promise<Response>} If request contains a 'Range' header, then a\n   * new response with status 206 whose body is a subset of `cachedResponse` is\n   * returned. Otherwise, `cachedResponse` is returned as-is.\n   *\n   * @private\n   */\n  async cachedResponseWillBeUsed({request, cachedResponse}) {\n    // Only return a sliced response if there's something valid in the cache,\n    // and there's a Range: header in the request.\n    if (cachedResponse && request.headers.has('range')) {\n      return await createPartialResponse(request, cachedResponse);\n    }\n\n    // If there was no Range: header, or if cachedResponse wasn't valid, just\n    // pass it through as-is.\n    return cachedResponse;\n  }\n}\n\nexport {Plugin};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {createPartialResponse} from './createPartialResponse.mjs';\nimport {Plugin} from './Plugin.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.rangeRequests\n */\n\nexport {\n  createPartialResponse,\n  Plugin,\n};\n"]},"metadata":{},"sourceType":"script"}