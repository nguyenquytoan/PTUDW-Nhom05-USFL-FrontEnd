{"ast":null,"code":"// Generated by LiveScript 1.2.0\n(function () {\n  var parsedTypeCheck,\n      types,\n      toString$ = {}.toString;\n  parsedTypeCheck = require('type-check').parsedTypeCheck;\n  types = {\n    '*': function (it) {\n      switch (toString$.call(it).slice(8, -1)) {\n        case 'Array':\n          return coerceType(it, {\n            type: 'Array'\n          });\n\n        case 'Object':\n          return coerceType(it, {\n            type: 'Object'\n          });\n\n        default:\n          return {\n            type: 'Just',\n            value: coerceTypes(it, [{\n              type: 'Undefined'\n            }, {\n              type: 'Null'\n            }, {\n              type: 'NaN'\n            }, {\n              type: 'Boolean'\n            }, {\n              type: 'Number'\n            }, {\n              type: 'Date'\n            }, {\n              type: 'RegExp'\n            }, {\n              type: 'Array'\n            }, {\n              type: 'Object'\n            }, {\n              type: 'String'\n            }], {\n              explicit: true\n            })\n          };\n      }\n    },\n    Undefined: function (it) {\n      if (it === 'undefined' || it === void 8) {\n        return {\n          type: 'Just',\n          value: void 8\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Null: function (it) {\n      if (it === 'null') {\n        return {\n          type: 'Just',\n          value: null\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    NaN: function (it) {\n      if (it === 'NaN') {\n        return {\n          type: 'Just',\n          value: NaN\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Boolean: function (it) {\n      if (it === 'true') {\n        return {\n          type: 'Just',\n          value: true\n        };\n      } else if (it === 'false') {\n        return {\n          type: 'Just',\n          value: false\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Number: function (it) {\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Int: function (it) {\n      return {\n        type: 'Just',\n        value: parseInt(it)\n      };\n    },\n    Float: function (it) {\n      return {\n        type: 'Just',\n        value: parseFloat(it)\n      };\n    },\n    Date: function (value, options) {\n      var that;\n\n      if (that = /^\\#(.*)\\#$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new Date(+that[1] || that[1])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new Date(+value || value)\n        };\n      }\n    },\n    RegExp: function (value, options) {\n      var that;\n\n      if (that = /^\\/(.*)\\/([gimy]*)$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new RegExp(that[1], that[2])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new RegExp(value)\n        };\n      }\n    },\n    Array: function (it) {\n      return coerceArray(it, {\n        of: [{\n          type: '*'\n        }]\n      });\n    },\n    Object: function (it) {\n      return coerceFields(it, {\n        of: {}\n      });\n    },\n    String: function (it) {\n      var that;\n\n      if (toString$.call(it).slice(8, -1) !== 'String') {\n        return {\n          type: 'Nothing'\n        };\n      }\n\n      if (that = it.match(/^'(.*)'$/)) {\n        return {\n          type: 'Just',\n          value: that[1]\n        };\n      } else if (that = it.match(/^\"(.*)\"$/)) {\n        return {\n          type: 'Just',\n          value: that[1]\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: it\n        };\n      }\n    }\n  };\n\n  function coerceArray(node, type) {\n    var typeOf, element;\n\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: function () {\n        var i$,\n            ref$,\n            len$,\n            results$ = [];\n\n        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {\n          element = ref$[i$];\n          results$.push(coerceTypes(element, typeOf));\n        }\n\n        return results$;\n      }()\n    };\n  }\n\n  function coerceTuple(node, type) {\n    var result, i$, ref$, len$, i, types, that;\n\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n\n    result = [];\n\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\n      i = i$;\n      types = ref$[i$];\n\n      if (that = coerceTypes(node[i], types)) {\n        result.push(that);\n      }\n    }\n\n    return {\n      type: 'Just',\n      value: result\n    };\n  }\n\n  function coerceFields(node, type) {\n    var typeOf, key, value;\n\n    if (toString$.call(node).slice(8, -1) !== 'Object') {\n      return {\n        type: 'Nothing'\n      };\n    }\n\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: function () {\n        var ref$,\n            results$ = {};\n\n        for (key in ref$ = node) {\n          value = ref$[key];\n          results$[key] = coerceTypes(value, typeOf[key] || [{\n            type: '*'\n          }]);\n        }\n\n        return results$;\n      }()\n    };\n  }\n\n  function coerceType(node, typeObj, options) {\n    var type, structure, coerceFunc;\n    type = typeObj.type, structure = typeObj.structure;\n\n    if (type) {\n      coerceFunc = types[type];\n      return coerceFunc(node, options);\n    } else {\n      switch (structure) {\n        case 'array':\n          return coerceArray(node, typeObj);\n\n        case 'tuple':\n          return coerceTuple(node, typeObj);\n\n        case 'fields':\n          return coerceFields(node, typeObj);\n      }\n    }\n  }\n\n  function coerceTypes(node, types, options) {\n    var i$, len$, type, ref$, valueType, value;\n\n    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {\n      type = types[i$];\n      ref$ = coerceType(node, type, options), valueType = ref$.type, value = ref$.value;\n\n      if (valueType === 'Nothing') {\n        continue;\n      }\n\n      if (parsedTypeCheck([type], value)) {\n        return value;\n      }\n    }\n\n    throw new Error(\"Value \" + JSON.stringify(node) + \" does not type check against \" + JSON.stringify(types) + \".\");\n  }\n\n  module.exports = coerceTypes;\n}).call(this);","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/levn/lib/coerce.js"],"names":["parsedTypeCheck","types","toString$","toString","require","it","call","slice","coerceType","type","value","coerceTypes","explicit","Undefined","Null","NaN","Boolean","Number","Int","parseInt","Float","parseFloat","Date","options","that","exec","RegExp","Array","coerceArray","of","Object","coerceFields","String","match","node","typeOf","element","i$","ref$","len$","results$","length","push","coerceTuple","result","i","key","typeObj","structure","coerceFunc","valueType","Error","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["// Generated by LiveScript 1.2.0\n(function(){\n  var parsedTypeCheck, types, toString$ = {}.toString;\n  parsedTypeCheck = require('type-check').parsedTypeCheck;\n  types = {\n    '*': function(it){\n      switch (toString$.call(it).slice(8, -1)) {\n      case 'Array':\n        return coerceType(it, {\n          type: 'Array'\n        });\n      case 'Object':\n        return coerceType(it, {\n          type: 'Object'\n        });\n      default:\n        return {\n          type: 'Just',\n          value: coerceTypes(it, [\n            {\n              type: 'Undefined'\n            }, {\n              type: 'Null'\n            }, {\n              type: 'NaN'\n            }, {\n              type: 'Boolean'\n            }, {\n              type: 'Number'\n            }, {\n              type: 'Date'\n            }, {\n              type: 'RegExp'\n            }, {\n              type: 'Array'\n            }, {\n              type: 'Object'\n            }, {\n              type: 'String'\n            }\n          ], {\n            explicit: true\n          })\n        };\n      }\n    },\n    Undefined: function(it){\n      if (it === 'undefined' || it === void 8) {\n        return {\n          type: 'Just',\n          value: void 8\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Null: function(it){\n      if (it === 'null') {\n        return {\n          type: 'Just',\n          value: null\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    NaN: function(it){\n      if (it === 'NaN') {\n        return {\n          type: 'Just',\n          value: NaN\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Boolean: function(it){\n      if (it === 'true') {\n        return {\n          type: 'Just',\n          value: true\n        };\n      } else if (it === 'false') {\n        return {\n          type: 'Just',\n          value: false\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Number: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Int: function(it){\n      return {\n        type: 'Just',\n        value: parseInt(it)\n      };\n    },\n    Float: function(it){\n      return {\n        type: 'Just',\n        value: parseFloat(it)\n      };\n    },\n    Date: function(value, options){\n      var that;\n      if (that = /^\\#(.*)\\#$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new Date(+that[1] || that[1])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new Date(+value || value)\n        };\n      }\n    },\n    RegExp: function(value, options){\n      var that;\n      if (that = /^\\/(.*)\\/([gimy]*)$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new RegExp(that[1], that[2])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new RegExp(value)\n        };\n      }\n    },\n    Array: function(it){\n      return coerceArray(it, {\n        of: [{\n          type: '*'\n        }]\n      });\n    },\n    Object: function(it){\n      return coerceFields(it, {\n        of: {}\n      });\n    },\n    String: function(it){\n      var that;\n      if (toString$.call(it).slice(8, -1) !== 'String') {\n        return {\n          type: 'Nothing'\n        };\n      }\n      if (that = it.match(/^'(.*)'$/)) {\n        return {\n          type: 'Just',\n          value: that[1]\n        };\n      } else if (that = it.match(/^\"(.*)\"$/)) {\n        return {\n          type: 'Just',\n          value: that[1]\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: it\n        };\n      }\n    }\n  };\n  function coerceArray(node, type){\n    var typeOf, element;\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: (function(){\n        var i$, ref$, len$, results$ = [];\n        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {\n          element = ref$[i$];\n          results$.push(coerceTypes(element, typeOf));\n        }\n        return results$;\n      }())\n    };\n  }\n  function coerceTuple(node, type){\n    var result, i$, ref$, len$, i, types, that;\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    result = [];\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\n      i = i$;\n      types = ref$[i$];\n      if (that = coerceTypes(node[i], types)) {\n        result.push(that);\n      }\n    }\n    return {\n      type: 'Just',\n      value: result\n    };\n  }\n  function coerceFields(node, type){\n    var typeOf, key, value;\n    if (toString$.call(node).slice(8, -1) !== 'Object') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: (function(){\n        var ref$, results$ = {};\n        for (key in ref$ = node) {\n          value = ref$[key];\n          results$[key] = coerceTypes(value, typeOf[key] || [{\n            type: '*'\n          }]);\n        }\n        return results$;\n      }())\n    };\n  }\n  function coerceType(node, typeObj, options){\n    var type, structure, coerceFunc;\n    type = typeObj.type, structure = typeObj.structure;\n    if (type) {\n      coerceFunc = types[type];\n      return coerceFunc(node, options);\n    } else {\n      switch (structure) {\n      case 'array':\n        return coerceArray(node, typeObj);\n      case 'tuple':\n        return coerceTuple(node, typeObj);\n      case 'fields':\n        return coerceFields(node, typeObj);\n      }\n    }\n  }\n  function coerceTypes(node, types, options){\n    var i$, len$, type, ref$, valueType, value;\n    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {\n      type = types[i$];\n      ref$ = coerceType(node, type, options), valueType = ref$.type, value = ref$.value;\n      if (valueType === 'Nothing') {\n        continue;\n      }\n      if (parsedTypeCheck([type], value)) {\n        return value;\n      }\n    }\n    throw new Error(\"Value \" + JSON.stringify(node) + \" does not type check against \" + JSON.stringify(types) + \".\");\n  }\n  module.exports = coerceTypes;\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}