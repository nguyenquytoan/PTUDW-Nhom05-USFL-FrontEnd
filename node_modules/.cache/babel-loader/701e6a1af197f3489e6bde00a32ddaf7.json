{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst emojisList = require('emojis-list');\n\nconst getHashDigest = require('./getHashDigest');\n\nconst emojiRegex = /[\\uD800-\\uDFFF]./;\nconst emojiList = emojisList.filter(emoji => emojiRegex.test(emoji));\nconst emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n  const emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    const index = Math.floor(Math.random() * emojiList.length);\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  const emojiEncoding = emojis.join('');\n  emojiCache[content] = emojiEncoding;\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  let filename;\n  const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === 'function') {\n    filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : undefined);\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n  let ext = 'bin';\n  let basename = 'file';\n  let directory = '';\n  let folder = '';\n  let query = '';\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path.relative(context, resourcePath + '_').replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n    const hashIdx = query.indexOf('#');\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))).replace(/\\[emoji(?::(\\d+))?\\]/gi, (all, length) => encodeStringToEmoji(content, parseInt(length, 10)));\n  }\n\n  url = url.replace(/\\[ext\\]/gi, () => ext).replace(/\\[name\\]/gi, () => basename).replace(/\\[path\\]/gi, () => directory).replace(/\\[folder\\]/gi, () => folder).replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach((matched, i) => {\n      url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n    });\n  }\n\n  if (typeof loaderContext.options === 'object' && typeof loaderContext.options.customInterpolateName === 'function') {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/loader-utils/lib/interpolateName.js"],"names":["path","require","emojisList","getHashDigest","emojiRegex","emojiList","filter","emoji","test","emojiCache","encodeStringToEmoji","content","length","emojis","Error","index","Math","floor","random","push","splice","emojiEncoding","join","interpolateName","loaderContext","name","options","filename","hasQuery","resourceQuery","resourcePath","undefined","context","regExp","ext","basename","directory","folder","query","parsed","parse","substr","dir","sep","relative","replace","hashIdx","indexOf","url","all","hashType","digestType","maxLength","parseInt","match","RegExp","forEach","matched","i","customInterpolateName","call","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst path = require('path');\nconst emojisList = require('emojis-list');\nconst getHashDigest = require('./getHashDigest');\n\nconst emojiRegex = /[\\uD800-\\uDFFF]./;\nconst emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));\nconst emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n\n  const emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    const index = Math.floor(Math.random() * emojiList.length);\n\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  const emojiEncoding = emojis.join('');\n\n  emojiCache[content] = emojiEncoding;\n\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === 'function') {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = 'bin';\n  let basename = 'file';\n  let directory = '';\n  let folder = '';\n  let query = '';\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path\n        .relative(context, resourcePath + '_')\n        .replace(/\\\\/g, '/')\n        .replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf('#');\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      )\n      .replace(/\\[emoji(?::(\\d+))?\\]/gi, (all, length) =>\n        encodeStringToEmoji(content, parseInt(length, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === 'object' &&\n    typeof loaderContext.options.customInterpolateName === 'function'\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;\n"]},"metadata":{},"sourceType":"script"}