{"ast":null,"code":"'use strict';\n\nvar Get = require('es-abstract/2019/Get');\n\nvar IsRegExp = require('es-abstract/2019/IsRegExp');\n\nvar Set = require('es-abstract/2019/Set');\n\nvar SpeciesConstructor = require('es-abstract/2019/SpeciesConstructor');\n\nvar ToBoolean = require('es-abstract/2019/ToBoolean');\n\nvar ToLength = require('es-abstract/2019/ToLength');\n\nvar ToString = require('es-abstract/2019/ToString');\n\nvar flagsGetter = require('regexp.prototype.flags');\n\nvar RegExpStringIterator = require('./RegExpStringIterator');\n\nvar OrigRegExp = RegExp;\n\nmodule.exports = function MatchAllIterator(R, O) {\n  var S = ToString(O);\n  var matcher, global, fullUnicode, flags;\n\n  if (IsRegExp(R)) {\n    var C = SpeciesConstructor(R, OrigRegExp);\n    flags = Get(R, 'flags');\n\n    if (typeof flags === 'string') {\n      matcher = new C(R, flags); // Construct(C, [R, flags]);\n    } else if (C === OrigRegExp) {\n      // workaround for older engines that lack RegExp.prototype.flags\n      matcher = new C(R.source, flagsGetter(R)); // Construct(C, [R.source, flagsGetter(R)]);\n    } else {\n      matcher = new C(R, flagsGetter(R)); // Construct(C, [R, flagsGetter(R)]);\n    }\n\n    global = ToBoolean(Get(matcher, 'global'));\n    fullUnicode = ToBoolean(Get(matcher, 'unicode'));\n    var lastIndex = ToLength(Get(R, 'lastIndex'));\n    Set(matcher, 'lastIndex', lastIndex, true);\n  } else {\n    flags = 'g';\n    matcher = new OrigRegExp(R, flags);\n    global = true;\n    fullUnicode = false;\n\n    if (Get(matcher, 'lastIndex') !== 0) {\n      throw new TypeError('Assertion failed: newly constructed RegExp had a lastIndex !== 0. Please report this!');\n    }\n  }\n\n  return new RegExpStringIterator(matcher, S, global, fullUnicode);\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/string.prototype.matchall/helpers/MatchAllIterator.js"],"names":["Get","require","IsRegExp","Set","SpeciesConstructor","ToBoolean","ToLength","ToString","flagsGetter","RegExpStringIterator","OrigRegExp","RegExp","module","exports","MatchAllIterator","R","O","S","matcher","global","fullUnicode","flags","C","source","lastIndex","TypeError"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,sBAAD,CAAjB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,2BAAD,CAAtB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,sBAAD,CAAjB;;AACA,IAAIG,kBAAkB,GAAGH,OAAO,CAAC,qCAAD,CAAhC;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,4BAAD,CAAvB;;AACA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,2BAAD,CAAtB;;AACA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,2BAAD,CAAtB;;AACA,IAAIO,WAAW,GAAGP,OAAO,CAAC,wBAAD,CAAzB;;AAEA,IAAIQ,oBAAoB,GAAGR,OAAO,CAAC,wBAAD,CAAlC;;AACA,IAAIS,UAAU,GAAGC,MAAjB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,gBAAT,CAA0BC,CAA1B,EAA6BC,CAA7B,EAAgC;AAChD,MAAIC,CAAC,GAAGV,QAAQ,CAACS,CAAD,CAAhB;AAEA,MAAIE,OAAJ,EAAaC,MAAb,EAAqBC,WAArB,EAAkCC,KAAlC;;AACA,MAAInB,QAAQ,CAACa,CAAD,CAAZ,EAAiB;AAChB,QAAIO,CAAC,GAAGlB,kBAAkB,CAACW,CAAD,EAAIL,UAAJ,CAA1B;AACAW,IAAAA,KAAK,GAAGrB,GAAG,CAACe,CAAD,EAAI,OAAJ,CAAX;;AACA,QAAI,OAAOM,KAAP,KAAiB,QAArB,EAA+B;AAC9BH,MAAAA,OAAO,GAAG,IAAII,CAAJ,CAAMP,CAAN,EAASM,KAAT,CAAV,CAD8B,CACH;AAC3B,KAFD,MAEO,IAAIC,CAAC,KAAKZ,UAAV,EAAsB;AAC5B;AACAQ,MAAAA,OAAO,GAAG,IAAII,CAAJ,CAAMP,CAAC,CAACQ,MAAR,EAAgBf,WAAW,CAACO,CAAD,CAA3B,CAAV,CAF4B,CAEe;AAC3C,KAHM,MAGA;AACNG,MAAAA,OAAO,GAAG,IAAII,CAAJ,CAAMP,CAAN,EAASP,WAAW,CAACO,CAAD,CAApB,CAAV,CADM,CAC8B;AACpC;;AACDI,IAAAA,MAAM,GAAGd,SAAS,CAACL,GAAG,CAACkB,OAAD,EAAU,QAAV,CAAJ,CAAlB;AACAE,IAAAA,WAAW,GAAGf,SAAS,CAACL,GAAG,CAACkB,OAAD,EAAU,SAAV,CAAJ,CAAvB;AACA,QAAIM,SAAS,GAAGlB,QAAQ,CAACN,GAAG,CAACe,CAAD,EAAI,WAAJ,CAAJ,CAAxB;AACAZ,IAAAA,GAAG,CAACe,OAAD,EAAU,WAAV,EAAuBM,SAAvB,EAAkC,IAAlC,CAAH;AACA,GAfD,MAeO;AACNH,IAAAA,KAAK,GAAG,GAAR;AACAH,IAAAA,OAAO,GAAG,IAAIR,UAAJ,CAAeK,CAAf,EAAkBM,KAAlB,CAAV;AACAF,IAAAA,MAAM,GAAG,IAAT;AACAC,IAAAA,WAAW,GAAG,KAAd;;AACA,QAAIpB,GAAG,CAACkB,OAAD,EAAU,WAAV,CAAH,KAA8B,CAAlC,EAAqC;AACpC,YAAM,IAAIO,SAAJ,CAAc,uFAAd,CAAN;AACA;AACD;;AACD,SAAO,IAAIhB,oBAAJ,CAAyBS,OAAzB,EAAkCD,CAAlC,EAAqCE,MAArC,EAA6CC,WAA7C,CAAP;AACA,CA7BD","sourcesContent":["'use strict';\n\nvar Get = require('es-abstract/2019/Get');\nvar IsRegExp = require('es-abstract/2019/IsRegExp');\nvar Set = require('es-abstract/2019/Set');\nvar SpeciesConstructor = require('es-abstract/2019/SpeciesConstructor');\nvar ToBoolean = require('es-abstract/2019/ToBoolean');\nvar ToLength = require('es-abstract/2019/ToLength');\nvar ToString = require('es-abstract/2019/ToString');\nvar flagsGetter = require('regexp.prototype.flags');\n\nvar RegExpStringIterator = require('./RegExpStringIterator');\nvar OrigRegExp = RegExp;\n\nmodule.exports = function MatchAllIterator(R, O) {\n\tvar S = ToString(O);\n\n\tvar matcher, global, fullUnicode, flags;\n\tif (IsRegExp(R)) {\n\t\tvar C = SpeciesConstructor(R, OrigRegExp);\n\t\tflags = Get(R, 'flags');\n\t\tif (typeof flags === 'string') {\n\t\t\tmatcher = new C(R, flags); // Construct(C, [R, flags]);\n\t\t} else if (C === OrigRegExp) {\n\t\t\t// workaround for older engines that lack RegExp.prototype.flags\n\t\t\tmatcher = new C(R.source, flagsGetter(R)); // Construct(C, [R.source, flagsGetter(R)]);\n\t\t} else {\n\t\t\tmatcher = new C(R, flagsGetter(R)); // Construct(C, [R, flagsGetter(R)]);\n\t\t}\n\t\tglobal = ToBoolean(Get(matcher, 'global'));\n\t\tfullUnicode = ToBoolean(Get(matcher, 'unicode'));\n\t\tvar lastIndex = ToLength(Get(R, 'lastIndex'));\n\t\tSet(matcher, 'lastIndex', lastIndex, true);\n\t} else {\n\t\tflags = 'g';\n\t\tmatcher = new OrigRegExp(R, flags);\n\t\tglobal = true;\n\t\tfullUnicode = false;\n\t\tif (Get(matcher, 'lastIndex') !== 0) {\n\t\t\tthrow new TypeError('Assertion failed: newly constructed RegExp had a lastIndex !== 0. Please report this!');\n\t\t}\n\t}\n\treturn new RegExpStringIterator(matcher, S, global, fullUnicode);\n};\n"]},"metadata":{},"sourceType":"script"}