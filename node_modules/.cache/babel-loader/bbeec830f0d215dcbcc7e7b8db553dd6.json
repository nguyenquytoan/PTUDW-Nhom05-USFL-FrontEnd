{"ast":null,"code":"/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newline at the end of files\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eol-last\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"unix\", \"windows\"]\n    }],\n    messages: {\n      missing: \"Newline required at end of file but not found.\",\n      unexpected: \"Newline not allowed at end of file.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n    return {\n      Program: function checkBadEOF(node) {\n        const sourceCode = context.getSourceCode(),\n              src = sourceCode.getText(),\n              location = {\n          column: lodash.last(sourceCode.lines).length,\n          line: sourceCode.lines.length\n        },\n              LF = \"\\n\",\n              CRLF = `\\r${LF}`,\n              endsWithNewline = lodash.endsWith(src, LF);\n        /*\n         * Empty source is always valid: No content in file so we don't\n         * need to lint for a newline on the last line of content.\n         */\n\n        if (!src.length) {\n          return;\n        }\n\n        let mode = context.options[0] || \"always\",\n            appendCRLF = false;\n\n        if (mode === \"unix\") {\n          // `\"unix\"` should behave exactly as `\"always\"`\n          mode = \"always\";\n        }\n\n        if (mode === \"windows\") {\n          // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n          mode = \"always\";\n          appendCRLF = true;\n        }\n\n        if (mode === \"always\" && !endsWithNewline) {\n          // File is not newline-terminated, but should be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"missing\",\n\n            fix(fixer) {\n              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n            }\n\n          });\n        } else if (mode === \"never\" && endsWithNewline) {\n          // File is newline-terminated, but shouldn't be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              const finalEOLs = /(?:\\r?\\n)+$/u,\n                    match = finalEOLs.exec(sourceCode.text),\n                    start = match.index,\n                    end = sourceCode.text.length;\n              return fixer.replaceTextRange([start, end], \"\");\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/eol-last.js"],"names":["lodash","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","missing","unexpected","create","context","Program","checkBadEOF","node","sourceCode","getSourceCode","src","getText","location","column","last","lines","length","line","LF","CRLF","endsWithNewline","endsWith","mode","options","appendCRLF","report","loc","messageId","fix","fixer","insertTextAfterRange","finalEOLs","match","exec","text","start","index","end","replaceTextRange"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eol-last\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ],\n\n        messages: {\n            missing: \"Newline required at end of file but not found.\",\n            unexpected: \"Newline not allowed at end of file.\"\n        }\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    location = {\n                        column: lodash.last(sourceCode.lines).length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = lodash.endsWith(src, LF);\n\n                /*\n                 * Empty source is always valid: No content in file so we don't\n                 * need to lint for a newline on the last line of content.\n                 */\n                if (!src.length) {\n                    return;\n                }\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"missing\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}