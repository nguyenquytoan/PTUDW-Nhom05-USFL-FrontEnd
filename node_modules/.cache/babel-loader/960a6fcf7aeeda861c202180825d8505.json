{"ast":null,"code":"/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent comma style\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-style\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"first\", \"last\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n      expectedCommaFirst: \"',' should be placed first.\",\n      expectedCommaLast: \"',' should be placed last.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"last\",\n          sourceCode = context.getSourceCode();\n    const exceptions = {\n      ArrayPattern: true,\n      ArrowFunctionExpression: true,\n      CallExpression: true,\n      FunctionDeclaration: true,\n      FunctionExpression: true,\n      ImportDeclaration: true,\n      ObjectPattern: true,\n      NewExpression: true\n    };\n\n    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n      const keys = Object.keys(context.options[1].exceptions);\n\n      for (let i = 0; i < keys.length; i++) {\n        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n      }\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Modified text based on the style\n     * @param {string} styleType Style type\n     * @param {string} text Source code text\n     * @returns {string} modified text\n     * @private\n     */\n\n\n    function getReplacedText(styleType, text) {\n      switch (styleType) {\n        case \"between\":\n          return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n        case \"first\":\n          return `${text},`;\n\n        case \"last\":\n          return `,${text}`;\n\n        default:\n          return \"\";\n      }\n    }\n    /**\n     * Determines the fixer function for a given style.\n     * @param {string} styleType comma style\n     * @param {ASTNode} previousItemToken The token to check.\n     * @param {ASTNode} commaToken The token to check.\n     * @param {ASTNode} currentItemToken The token to check.\n     * @returns {Function} Fixer function\n     * @private\n     */\n\n\n    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n      const range = [previousItemToken.range[1], currentItemToken.range[0]];\n      return function (fixer) {\n        return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n      };\n    }\n    /**\n     * Validates the spacing around single items in lists.\n     * @param {Token} previousItemToken The last token from the previous item.\n     * @param {Token} commaToken The token representing the comma.\n     * @param {Token} currentItemToken The first token of the current item.\n     * @param {Token} reportItem The item to use when reporting an error.\n     * @returns {void}\n     * @private\n     */\n\n\n    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n      // if single line\n      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {// do nothing.\n      } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n        const comment = sourceCode.getCommentsAfter(commaToken)[0];\n        const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : \"between\"; // lone comma\n\n        context.report({\n          node: reportItem,\n          loc: {\n            line: commaToken.loc.end.line,\n            column: commaToken.loc.start.column\n          },\n          messageId: \"unexpectedLineBeforeAndAfterComma\",\n          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          messageId: \"expectedCommaFirst\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: {\n            line: commaToken.loc.end.line,\n            column: commaToken.loc.end.column\n          },\n          messageId: \"expectedCommaLast\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      }\n    }\n    /**\n     * Checks the comma placement with regards to a declaration/property/element\n     * @param {ASTNode} node The binary expression node to check\n     * @param {string} property The property of the node containing child nodes.\n     * @private\n     * @returns {void}\n     */\n\n\n    function validateComma(node, property) {\n      const items = node[property],\n            arrayLiteral = node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\";\n\n      if (items.length > 1 || arrayLiteral) {\n        // seed as opening [\n        let previousItemToken = sourceCode.getFirstToken(node);\n        items.forEach(item => {\n          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                reportItem = item || currentItemToken;\n          /*\n           * This works by comparing three token locations:\n           * - previousItemToken is the last token of the previous item\n           * - commaToken is the location of the comma before the current item\n           * - currentItemToken is the first token of the current item\n           *\n           * These values get switched around if item is undefined.\n           * previousItemToken will refer to the last token not belonging\n           * to the current item, which could be a comma or an opening\n           * square bracket. currentItemToken could be a comma.\n           *\n           * All comparisons are done based on these tokens directly, so\n           * they are always valid regardless of an undefined item.\n           */\n\n          if (astUtils.isCommaToken(commaToken)) {\n            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n          }\n\n          if (item) {\n            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n          }\n        });\n        /*\n         * Special case for array literals that have empty last items, such\n         * as [ 1, 2, ]. These arrays only have two items show up in the\n         * AST, so we need to look at the token to verify that there's no\n         * dangling comma.\n         */\n\n        if (arrayLiteral) {\n          const lastToken = sourceCode.getLastToken(node),\n                nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n          if (astUtils.isCommaToken(nextToLastToken)) {\n            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    const nodes = {};\n\n    if (!exceptions.VariableDeclaration) {\n      nodes.VariableDeclaration = function (node) {\n        validateComma(node, \"declarations\");\n      };\n    }\n\n    if (!exceptions.ObjectExpression) {\n      nodes.ObjectExpression = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ObjectPattern) {\n      nodes.ObjectPattern = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ArrayExpression) {\n      nodes.ArrayExpression = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.ArrayPattern) {\n      nodes.ArrayPattern = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.FunctionDeclaration) {\n      nodes.FunctionDeclaration = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.FunctionExpression) {\n      nodes.FunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.ArrowFunctionExpression) {\n      nodes.ArrowFunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.CallExpression) {\n      nodes.CallExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    if (!exceptions.ImportDeclaration) {\n      nodes.ImportDeclaration = function (node) {\n        validateComma(node, \"specifiers\");\n      };\n    }\n\n    if (!exceptions.NewExpression) {\n      nodes.NewExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    return nodes;\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/comma-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptions","additionalProperties","messages","unexpectedLineBeforeAndAfterComma","expectedCommaFirst","expectedCommaLast","create","context","style","options","sourceCode","getSourceCode","ArrayPattern","ArrowFunctionExpression","CallExpression","FunctionDeclaration","FunctionExpression","ImportDeclaration","ObjectPattern","NewExpression","length","Object","prototype","hasOwnProperty","call","keys","i","getReplacedText","styleType","text","replace","LINEBREAK_MATCHER","getFixerFunction","previousItemToken","commaToken","currentItemToken","slice","range","fixer","replaceTextRange","validateCommaItemSpacing","reportItem","isTokenOnSameLine","comment","getCommentsAfter","report","node","loc","line","end","column","start","messageId","fix","validateComma","property","items","arrayLiteral","getFirstToken","forEach","item","getTokenBefore","getTokenAfter","isCommaToken","tokenAfterItem","isNotClosingParenToken","ast","tokens","lastToken","getLastToken","nextToLastToken","nodes","VariableDeclaration","ObjectExpression","ArrayExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-style\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n            expectedCommaFirst: \"',' should be placed first.\",\n            expectedCommaLast: \"',' should be placed last.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true,\n            NewExpression: true\n        };\n\n        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\n                    ? style\n                    : \"between\";\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.start.column\n                    },\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    messageId: \"expectedCommaFirst\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.end.column\n                    },\n                    messageId: \"expectedCommaLast\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken;\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken,\n                            currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\n                            : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n        if (!exceptions.NewExpression) {\n            nodes.NewExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n\n        return nodes;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}