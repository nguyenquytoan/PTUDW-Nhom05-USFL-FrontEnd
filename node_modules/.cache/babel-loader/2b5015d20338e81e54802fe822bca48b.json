{"ast":null,"code":"'use strict';\n\nexports.type = 'perItemReverse';\nexports.active = true;\nexports.description = 'moves elements attributes to the existing group wrapper';\n\nvar inheritableAttrs = require('./_collections').inheritableAttrs,\n    pathElems = require('./_collections.js').pathElems;\n/**\n * Collapse content's intersected and inheritable\n * attributes to the existing group wrapper.\n *\n * @example\n * <g attr1=\"val1\">\n *     <g attr2=\"val2\">\n *         text\n *     </g>\n *     <circle attr2=\"val2\" attr3=\"val3\"/>\n * </g>\n *              ⬇\n * <g attr1=\"val1\" attr2=\"val2\">\n *     <g>\n *         text\n *     </g>\n *    <circle attr3=\"val3\"/>\n * </g>\n *\n * @param {Object} item current iteration item\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\n\nexports.fn = function (item) {\n  if (item.isElem('g') && !item.isEmpty() && item.content.length > 1) {\n    var intersection = {},\n        hasTransform = false,\n        hasClip = item.hasAttr('clip-path') || item.hasAttr('mask'),\n        intersected = item.content.every(function (inner) {\n      if (inner.isElem() && inner.hasAttr()) {\n        // don't mess with possible styles (hack until CSS parsing is implemented)\n        if (inner.hasAttr('class')) return false;\n\n        if (!Object.keys(intersection).length) {\n          intersection = inner.attrs;\n        } else {\n          intersection = intersectInheritableAttrs(intersection, inner.attrs);\n          if (!intersection) return false;\n        }\n\n        return true;\n      }\n    }),\n        allPath = item.content.every(function (inner) {\n      return inner.isElem(pathElems);\n    });\n\n    if (intersected) {\n      item.content.forEach(function (g) {\n        for (var name in intersection) {\n          if (!allPath && !hasClip || name !== 'transform') {\n            g.removeAttr(name);\n\n            if (name === 'transform') {\n              if (!hasTransform) {\n                if (item.hasAttr('transform')) {\n                  item.attr('transform').value += ' ' + intersection[name].value;\n                } else {\n                  item.addAttr(intersection[name]);\n                }\n\n                hasTransform = true;\n              }\n            } else {\n              item.addAttr(intersection[name]);\n            }\n          }\n        }\n      });\n    }\n  }\n};\n/**\n * Intersect inheritable attributes.\n *\n * @param {Object} a first attrs object\n * @param {Object} b second attrs object\n *\n * @return {Object} intersected attrs object\n */\n\n\nfunction intersectInheritableAttrs(a, b) {\n  var c = {};\n\n  for (var n in a) {\n    if (b.hasOwnProperty(n) && inheritableAttrs.indexOf(n) > -1 && a[n].name === b[n].name && a[n].value === b[n].value && a[n].prefix === b[n].prefix && a[n].local === b[n].local) {\n      c[n] = a[n];\n    }\n  }\n\n  if (!Object.keys(c).length) return false;\n  return c;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/svgo/plugins/moveElemsAttrsToGroup.js"],"names":["exports","type","active","description","inheritableAttrs","require","pathElems","fn","item","isElem","isEmpty","content","length","intersection","hasTransform","hasClip","hasAttr","intersected","every","inner","Object","keys","attrs","intersectInheritableAttrs","allPath","forEach","g","name","removeAttr","attr","value","addAttr","a","b","c","n","hasOwnProperty","indexOf","prefix","local"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.type = 'perItemReverse';\n\nexports.active = true;\n\nexports.description = 'moves elements attributes to the existing group wrapper';\n\nvar inheritableAttrs = require('./_collections').inheritableAttrs,\n    pathElems = require('./_collections.js').pathElems;\n\n/**\n * Collapse content's intersected and inheritable\n * attributes to the existing group wrapper.\n *\n * @example\n * <g attr1=\"val1\">\n *     <g attr2=\"val2\">\n *         text\n *     </g>\n *     <circle attr2=\"val2\" attr3=\"val3\"/>\n * </g>\n *              ⬇\n * <g attr1=\"val1\" attr2=\"val2\">\n *     <g>\n *         text\n *     </g>\n *    <circle attr3=\"val3\"/>\n * </g>\n *\n * @param {Object} item current iteration item\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\nexports.fn = function(item) {\n\n    if (item.isElem('g') && !item.isEmpty() && item.content.length > 1) {\n\n        var intersection = {},\n            hasTransform = false,\n            hasClip = item.hasAttr('clip-path') || item.hasAttr('mask'),\n            intersected = item.content.every(function(inner) {\n                if (inner.isElem() && inner.hasAttr()) {\n                    // don't mess with possible styles (hack until CSS parsing is implemented)\n                    if (inner.hasAttr('class')) return false;\n                    if (!Object.keys(intersection).length) {\n                        intersection = inner.attrs;\n                    } else {\n                        intersection = intersectInheritableAttrs(intersection, inner.attrs);\n\n                        if (!intersection) return false;\n                    }\n\n                    return true;\n                }\n            }),\n            allPath = item.content.every(function(inner) {\n                return inner.isElem(pathElems);\n            });\n\n        if (intersected) {\n\n            item.content.forEach(function(g) {\n\n                for (var name in intersection) {\n\n                    if (!allPath && !hasClip || name !== 'transform') {\n\n                        g.removeAttr(name);\n\n                        if (name === 'transform') {\n                            if (!hasTransform) {\n                                if (item.hasAttr('transform')) {\n                                    item.attr('transform').value += ' ' + intersection[name].value;\n                                } else {\n                                    item.addAttr(intersection[name]);\n                                }\n\n                                hasTransform = true;\n                            }\n                        } else {\n                            item.addAttr(intersection[name]);\n                        }\n\n                    }\n                }\n\n            });\n\n        }\n\n    }\n\n};\n\n/**\n * Intersect inheritable attributes.\n *\n * @param {Object} a first attrs object\n * @param {Object} b second attrs object\n *\n * @return {Object} intersected attrs object\n */\nfunction intersectInheritableAttrs(a, b) {\n\n    var c = {};\n\n    for (var n in a) {\n        if (\n            b.hasOwnProperty(n) &&\n            inheritableAttrs.indexOf(n) > -1 &&\n            a[n].name === b[n].name &&\n            a[n].value === b[n].value &&\n            a[n].prefix === b[n].prefix &&\n            a[n].local === b[n].local\n        ) {\n            c[n] = a[n];\n        }\n    }\n\n    if (!Object.keys(c).length) return false;\n\n    return c;\n\n}\n"]},"metadata":{},"sourceType":"script"}