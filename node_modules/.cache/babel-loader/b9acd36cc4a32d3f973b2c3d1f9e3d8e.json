{"ast":null,"code":"/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent-legacy\"\n    },\n    deprecated: true,\n    replacedBy: [\"indent\"],\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0\n        },\n        VariableDeclarator: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            type: \"object\",\n            properties: {\n              var: {\n                type: \"integer\",\n                minimum: 0\n              },\n              let: {\n                type: \"integer\",\n                minimum: 0\n              },\n              const: {\n                type: \"integer\",\n                minimum: 0\n              }\n            }\n          }]\n        },\n        outerIIFEBody: {\n          type: \"integer\",\n          minimum: 0\n        },\n        MemberExpression: {\n          type: \"integer\",\n          minimum: 0\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            }\n          }\n        },\n        ArrayExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        },\n        ObjectExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n\n    const DEFAULT_FUNCTION_BODY_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: DEFAULT_VARIABLE_INDENT,\n        let: DEFAULT_VARIABLE_INDENT,\n        const: DEFAULT_VARIABLE_INDENT\n      },\n      outerIIFEBody: null,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      ArrayExpression: 1,\n      ObjectExpression: 1\n    };\n    const sourceCode = context.getSourceCode();\n\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else\n        /* istanbul ignore else : this will be caught by options validation */\n        if (typeof context.options[0] === \"number\") {\n          indentSize = context.options[0];\n          indentType = \"space\";\n        }\n\n      if (context.options[1]) {\n        const opts = context.options[1];\n        options.SwitchCase = opts.SwitchCase || 0;\n        const variableDeclaratorRules = opts.VariableDeclarator;\n\n        if (typeof variableDeclaratorRules === \"number\") {\n          options.VariableDeclarator = {\n            var: variableDeclaratorRules,\n            let: variableDeclaratorRules,\n            const: variableDeclaratorRules\n          };\n        } else if (typeof variableDeclaratorRules === \"object\") {\n          Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n        }\n\n        if (typeof opts.outerIIFEBody === \"number\") {\n          options.outerIIFEBody = opts.outerIIFEBody;\n        }\n\n        if (typeof opts.MemberExpression === \"number\") {\n          options.MemberExpression = opts.MemberExpression;\n        }\n\n        if (typeof opts.FunctionDeclaration === \"object\") {\n          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n        }\n\n        if (typeof opts.FunctionExpression === \"object\") {\n          Object.assign(options.FunctionExpression, opts.FunctionExpression);\n        }\n\n        if (typeof opts.CallExpression === \"object\") {\n          Object.assign(options.CallExpression, opts.CallExpression);\n        }\n\n        if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n          options.ArrayExpression = opts.ArrayExpression;\n        }\n\n        if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n          options.ObjectExpression = opts.ObjectExpression;\n        }\n      }\n    }\n\n    const caseIndentStore = {};\n    /**\n     * Creates an error message for a line, given the expected/actual indentation.\n     * @param {int} expectedAmount The expected amount of indentation characters for this line\n     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n     * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n     * @returns {string} An error message for this line\n     */\n\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n\n      let foundStatement;\n\n      if (actualSpaces > 0 && actualTabs > 0) {\n        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n      } else if (actualSpaces > 0) {\n        /*\n         * Abbreviate the message if the expected indentation is also spaces.\n         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n         */\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n    /**\n     * Reports a given indent violation\n     * @param {ASTNode} node Node violating the indent rule\n     * @param {int} needed Expected indentation character count\n     * @param {int} gottenSpaces Indentation space count in the actual node/code\n     * @param {int} gottenTabs Indentation tab count in the actual node/code\n     * @param {Object} [loc] Error line and column location\n     * @param {boolean} isLastNodeCheck Is the error for last node check\n     * @returns {void}\n     */\n\n\n    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n      if (gottenSpaces && gottenTabs) {\n        // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n        return;\n      }\n\n      const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n      context.report({\n        node,\n        loc,\n        messageId: \"expected\",\n        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n      });\n    }\n    /**\n     * Get the actual indent of node\n     * @param {ASTNode|Token} node Node to examine\n     * @param {boolean} [byLastLine=false] get indent of node's last line\n     * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n     * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n     * `badChar` is the amount of the other indentation character.\n     */\n\n\n    function getNodeIndent(node, byLastLine) {\n      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n      const spaces = indentChars.filter(char => char === \" \").length;\n      const tabs = indentChars.filter(char => char === \"\\t\").length;\n      return {\n        space: spaces,\n        tab: tabs,\n        goodChar: indentType === \"space\" ? spaces : tabs,\n        badChar: indentType === \"space\" ? tabs : spaces\n      };\n    }\n    /**\n     * Checks node is the first in its own start line. By default it looks by start line.\n     * @param {ASTNode} node The node to check\n     * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n     * @returns {boolean} true if its the first in the its start line\n     */\n\n\n    function isNodeFirstInLine(node, byEndLocation) {\n      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n            endLine = firstToken ? firstToken.loc.end.line : -1;\n      return startLine !== endLine;\n    }\n    /**\n     * Check indent for node\n     * @param {ASTNode} node Node to check\n     * @param {int} neededIndent needed indent\n     * @returns {void}\n     */\n\n\n    function checkNodeIndent(node, neededIndent) {\n      const actualIndent = getNodeIndent(node, false);\n\n      if (node.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, neededIndent, actualIndent.space, actualIndent.tab);\n      }\n\n      if (node.type === \"IfStatement\" && node.alternate) {\n        const elseToken = sourceCode.getTokenBefore(node.alternate);\n        checkNodeIndent(elseToken, neededIndent);\n\n        if (!isNodeFirstInLine(node.alternate)) {\n          checkNodeIndent(node.alternate, neededIndent);\n        }\n      }\n\n      if (node.type === \"TryStatement\" && node.handler) {\n        const catchToken = sourceCode.getFirstToken(node.handler);\n        checkNodeIndent(catchToken, neededIndent);\n      }\n\n      if (node.type === \"TryStatement\" && node.finalizer) {\n        const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n        checkNodeIndent(finallyToken, neededIndent);\n      }\n\n      if (node.type === \"DoWhileStatement\") {\n        const whileToken = sourceCode.getTokenAfter(node.body);\n        checkNodeIndent(whileToken, neededIndent);\n      }\n    }\n    /**\n     * Check indent for nodes list\n     * @param {ASTNode[]} nodes list of node objects\n     * @param {int} indent needed indent\n     * @returns {void}\n     */\n\n\n    function checkNodesIndent(nodes, indent) {\n      nodes.forEach(node => checkNodeIndent(node, indent));\n    }\n    /**\n     * Check last node line indent this detects, that block closed correctly\n     * @param {ASTNode} node Node to examine\n     * @param {int} lastLineIndent needed indent\n     * @returns {void}\n     */\n\n\n    function checkLastNodeLineIndent(node, lastLineIndent) {\n      const lastToken = sourceCode.getLastToken(node);\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n        report(node, lastLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n    /**\n     * Check last node line indent this detects, that block closed correctly\n     * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n     * @param {ASTNode} node Node to examine\n     * @param {int} firstLineIndent first line needed indent\n     * @returns {void}\n     */\n\n\n    function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n      /*\n       * in case if return statement ends with ');' we have traverse back to ')'\n       * otherwise we'll measure indent for ';' and replace ')'\n       */\n      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n      if (textBeforeClosingParenthesis.trim()) {\n        // There are tokens before the closing paren, don't report this case\n        return;\n      }\n\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if (endIndent.goodChar !== firstLineIndent) {\n        report(node, firstLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n    /**\n     * Check first node line indent is correct\n     * @param {ASTNode} node Node to examine\n     * @param {int} firstLineIndent needed indent\n     * @returns {void}\n     */\n\n\n    function checkFirstNodeLineIndent(node, firstLineIndent) {\n      const startIndent = getNodeIndent(node, false);\n\n      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, firstLineIndent, startIndent.space, startIndent.tab, {\n          line: node.loc.start.line,\n          column: node.loc.start.column\n        });\n      }\n    }\n    /**\n     * Returns a parent node of given node based on a specified type\n     * if not present then return null\n     * @param {ASTNode} node node to examine\n     * @param {string} type type that is being looked for\n     * @param {string} stopAtList end points for the evaluating code\n     * @returns {ASTNode|void} if found then node otherwise null\n     */\n\n\n    function getParentNodeByType(node, type, stopAtList) {\n      let parent = node.parent;\n      const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n        parent = parent.parent;\n      }\n\n      return parent.type === type ? parent : null;\n    }\n    /**\n     * Returns the VariableDeclarator based on the current node\n     * if not present then return null\n     * @param {ASTNode} node node to examine\n     * @returns {ASTNode|void} if found then node otherwise null\n     */\n\n\n    function getVariableDeclaratorNode(node) {\n      return getParentNodeByType(node, \"VariableDeclarator\");\n    }\n    /**\n     * Check to see if the node is part of the multi-line variable declaration.\n     * Also if its on the same line as the varNode\n     * @param {ASTNode} node node to check\n     * @param {ASTNode} varNode variable declaration node to check against\n     * @returns {boolean} True if all the above condition satisfy\n     */\n\n\n    function isNodeInVarOnTop(node, varNode) {\n      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;\n    }\n    /**\n     * Check to see if the argument before the callee node is multi-line and\n     * there should only be 1 argument before the callee node\n     * @param {ASTNode} node node to check\n     * @returns {boolean} True if arguments are multi-line\n     */\n\n\n    function isArgBeforeCalleeNodeMultiline(node) {\n      const parent = node.parent;\n\n      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n      }\n\n      return false;\n    }\n    /**\n     * Check to see if the node is a file level IIFE\n     * @param {ASTNode} node The function node to check.\n     * @returns {boolean} True if the node is the outer IIFE\n     */\n\n\n    function isOuterIIFE(node) {\n      const parent = node.parent;\n      let stmt = parent.parent;\n      /*\n       * Verify that the node is an IIEF\n       */\n\n      if (parent.type !== \"CallExpression\" || parent.callee !== node) {\n        return false;\n      }\n      /*\n       * Navigate legal ancestors to determine whether this IIEF is outer\n       */\n\n\n      while (stmt.type === \"UnaryExpression\" && (stmt.operator === \"!\" || stmt.operator === \"~\" || stmt.operator === \"+\" || stmt.operator === \"-\") || stmt.type === \"AssignmentExpression\" || stmt.type === \"LogicalExpression\" || stmt.type === \"SequenceExpression\" || stmt.type === \"VariableDeclarator\") {\n        stmt = stmt.parent;\n      }\n\n      return (stmt.type === \"ExpressionStatement\" || stmt.type === \"VariableDeclaration\") && stmt.parent && stmt.parent.type === \"Program\";\n    }\n    /**\n     * Check indent for function block content\n     * @param {ASTNode} node A BlockStatement node that is inside of a function.\n     * @returns {void}\n     */\n\n\n    function checkIndentInFunctionBlock(node) {\n      /*\n       * Search first caller in chain.\n       * Ex.:\n       *\n       * Models <- Identifier\n       *   .User\n       *   .find()\n       *   .exec(function() {\n       *   // function body\n       * });\n       *\n       * Looks for 'Models'\n       */\n      const calleeNode = node.parent; // FunctionExpression\n\n      let indent;\n\n      if (calleeNode.parent && (calleeNode.parent.type === \"Property\" || calleeNode.parent.type === \"ArrayExpression\")) {\n        // If function is part of array or object, comma can be put at left\n        indent = getNodeIndent(calleeNode, false).goodChar;\n      } else {\n        // If function is standalone, simple calculate indent\n        indent = getNodeIndent(calleeNode).goodChar;\n      }\n\n      if (calleeNode.parent.type === \"CallExpression\") {\n        const calleeParent = calleeNode.parent;\n\n        if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        } else {\n          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        }\n      }\n      /*\n       * function body indent should be indent + indent size, unless this\n       * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n       */\n\n\n      let functionOffset = indentSize;\n\n      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n        functionOffset = options.outerIIFEBody * indentSize;\n      } else if (calleeNode.type === \"FunctionExpression\") {\n        functionOffset = options.FunctionExpression.body * indentSize;\n      } else if (calleeNode.type === \"FunctionDeclaration\") {\n        functionOffset = options.FunctionDeclaration.body * indentSize;\n      }\n\n      indent += functionOffset; // check if the node is inside a variable\n\n      const parentVarNode = getVariableDeclaratorNode(node);\n\n      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      if (node.body.length > 0) {\n        checkNodesIndent(node.body, indent);\n      }\n\n      checkLastNodeLineIndent(node, indent - functionOffset);\n    }\n    /**\n     * Checks if the given node starts and ends on the same line\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} Whether or not the block starts and ends on the same line.\n     */\n\n\n    function isSingleLineNode(node) {\n      const lastToken = sourceCode.getLastToken(node),\n            startLine = node.loc.start.line,\n            endLine = lastToken.loc.end.line;\n      return startLine === endLine;\n    }\n    /**\n     * Check to see if the first element inside an array is an object and on the same line as the node\n     * If the node is not an array then it will return false.\n     * @param {ASTNode} node node to check\n     * @returns {boolean} success/failure\n     */\n\n\n    function isFirstArrayElementOnSameLine(node) {\n      if (node.type === \"ArrayExpression\" && node.elements[0]) {\n        return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === \"ObjectExpression\";\n      }\n\n      return false;\n    }\n    /**\n     * Check indent for array block content or object block content\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n\n\n    function checkIndentInArrayOrObjectBlock(node) {\n      // Skip inline\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      let elements = node.type === \"ArrayExpression\" ? node.elements : node.properties; // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n\n      elements = elements.filter(elem => elem !== null);\n      let nodeIndent;\n      let elementsIndent;\n      const parentVarNode = getVariableDeclaratorNode(node); // TODO - come up with a better strategy in future\n\n      if (isNodeFirstInLine(node)) {\n        const parent = node.parent;\n        nodeIndent = getNodeIndent(parent).goodChar;\n\n        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n          if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n            if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n              const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {\n                /*\n                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                 * e.g. [{\n                 *        foo: 1\n                 *      },\n                 *      {\n                 *        bar: 1\n                 *      }]\n                 * the second object is not indented.\n                 */\n              } else if (typeof options[parent.type] === \"number\") {\n                nodeIndent += options[parent.type] * indentSize;\n              } else {\n                nodeIndent = parentElements[0].loc.start.column;\n              }\n            } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n              if (typeof options.CallExpression.arguments === \"number\") {\n                nodeIndent += options.CallExpression.arguments * indentSize;\n              } else if (options.CallExpression.arguments === \"first\") {\n                if (parent.arguments.indexOf(node) !== -1) {\n                  nodeIndent = parent.arguments[0].loc.start.column;\n                }\n              } else {\n                nodeIndent += indentSize;\n              }\n            } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n              nodeIndent += indentSize;\n            }\n          }\n        } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== \"MemberExpression\" && parent.type !== \"ExpressionStatement\" && parent.type !== \"AssignmentExpression\" && parent.type !== \"Property\") {\n          nodeIndent += indentSize;\n        }\n\n        checkFirstNodeLineIndent(node, nodeIndent);\n      } else {\n        nodeIndent = getNodeIndent(node).goodChar;\n      }\n\n      if (options[node.type] === \"first\") {\n        elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n      } else {\n        elementsIndent = nodeIndent + indentSize * options[node.type];\n      }\n      /*\n       * Check if the node is a multiple variable declaration; if so, then\n       * make sure indentation takes that into account.\n       */\n\n\n      if (isNodeInVarOnTop(node, parentVarNode)) {\n        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      checkNodesIndent(elements, elementsIndent);\n\n      if (elements.length > 0) {\n        // Skip last block line check if last item in same line\n        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n          return;\n        }\n      }\n\n      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n    }\n    /**\n     * Check if the node or node body is a BlockStatement or not\n     * @param {ASTNode} node node to test\n     * @returns {boolean} True if it or its body is a block statement\n     */\n\n\n    function isNodeBodyBlock(node) {\n      return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || node.body && node.body.type === \"BlockStatement\" || node.consequent && node.consequent.type === \"BlockStatement\";\n    }\n    /**\n     * Check indentation for blocks\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function blockIndentationCheck(node) {\n      // Skip inline blocks\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"FunctionDeclaration\" || node.parent.type === \"ArrowFunctionExpression\")) {\n        checkIndentInFunctionBlock(node);\n        return;\n      }\n\n      let indent;\n      let nodesToCheck = [];\n      /*\n       * For this statements we should check indent from statement beginning,\n       * not from the beginning of the block.\n       */\n\n      const statementsWithProperties = [\"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"];\n\n      if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n        indent = getNodeIndent(node.parent).goodChar;\n      } else if (node.parent && node.parent.type === \"CatchClause\") {\n        indent = getNodeIndent(node.parent.parent).goodChar;\n      } else {\n        indent = getNodeIndent(node).goodChar;\n      }\n\n      if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n        nodesToCheck = [node.consequent];\n      } else if (Array.isArray(node.body)) {\n        nodesToCheck = node.body;\n      } else {\n        nodesToCheck = [node.body];\n      }\n\n      if (nodesToCheck.length > 0) {\n        checkNodesIndent(nodesToCheck, indent + indentSize);\n      }\n\n      if (node.type === \"BlockStatement\") {\n        checkLastNodeLineIndent(node, indent);\n      }\n    }\n    /**\n     * Filter out the elements which are on the same line of each other or the node.\n     * basically have only 1 elements from each line except the variable declaration line.\n     * @param {ASTNode} node Variable declaration node\n     * @returns {ASTNode[]} Filtered elements\n     */\n\n\n    function filterOutSameLineVars(node) {\n      return node.declarations.reduce((finalCollection, elem) => {\n        const lastElem = finalCollection[finalCollection.length - 1];\n\n        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {\n          finalCollection.push(elem);\n        }\n\n        return finalCollection;\n      }, []);\n    }\n    /**\n     * Check indentation for variable declarations\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n\n\n    function checkIndentInVariableDeclarations(node) {\n      const elements = filterOutSameLineVars(node);\n      const nodeIndent = getNodeIndent(node).goodChar;\n      const lastElement = elements[elements.length - 1];\n      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n      checkNodesIndent(elements, elementsIndent); // Only check the last line if there is any token after the last item\n\n      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n        return;\n      }\n\n      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n      if (tokenBeforeLastElement.value === \",\") {\n        // Special case for comma-first syntax where the semicolon is indented\n        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n      } else {\n        checkLastNodeLineIndent(node, elementsIndent - indentSize);\n      }\n    }\n    /**\n     * Check and decide whether to check for indentation for blockless nodes\n     * Scenarios are for or while statements without braces around them\n     * @param {ASTNode} node node to examine\n     * @returns {void}\n     */\n\n\n    function blockLessNodes(node) {\n      if (node.body.type !== \"BlockStatement\") {\n        blockIndentationCheck(node);\n      }\n    }\n    /**\n     * Returns the expected indentation for the case statement\n     * @param {ASTNode} node node to examine\n     * @param {int} [providedSwitchIndent] indent for switch statement\n     * @returns {int} indent size\n     */\n\n\n    function expectedCaseIndent(node, providedSwitchIndent) {\n      const switchNode = node.type === \"SwitchStatement\" ? node : node.parent;\n      const switchIndent = typeof providedSwitchIndent === \"undefined\" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;\n      let caseIndent;\n\n      if (caseIndentStore[switchNode.loc.start.line]) {\n        return caseIndentStore[switchNode.loc.start.line];\n      }\n\n      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n        caseIndent = switchIndent;\n      } else {\n        caseIndent = switchIndent + indentSize * options.SwitchCase;\n      }\n\n      caseIndentStore[switchNode.loc.start.line] = caseIndent;\n      return caseIndent;\n    }\n    /**\n     * Checks wether a return statement is wrapped in ()\n     * @param {ASTNode} node node to examine\n     * @returns {boolean} the result\n     */\n\n\n    function isWrappedInParenthesis(node) {\n      const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), \"\");\n      return regex.test(statementWithoutArgument);\n    }\n\n    return {\n      Program(node) {\n        if (node.body.length > 0) {\n          // Root nodes should have no indent\n          checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n        }\n      },\n\n      ClassBody: blockIndentationCheck,\n      BlockStatement: blockIndentationCheck,\n      WhileStatement: blockLessNodes,\n      ForStatement: blockLessNodes,\n      ForInStatement: blockLessNodes,\n      ForOfStatement: blockLessNodes,\n      DoWhileStatement: blockLessNodes,\n\n      IfStatement(node) {\n        if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n          blockIndentationCheck(node);\n        }\n      },\n\n      VariableDeclaration(node) {\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n          checkIndentInVariableDeclarations(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      ArrayExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      MemberExpression(node) {\n        if (typeof options.MemberExpression === \"undefined\") {\n          return;\n        }\n\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        /*\n         * The typical layout of variable declarations and assignments\n         * alter the expectation of correct indentation. Skip them.\n         * TODO: Add appropriate configuration options for variable\n         * declarations and assignments.\n         */\n\n\n        if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          return;\n        }\n\n        if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n          return;\n        }\n\n        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n        const checkNodes = [node.property];\n        const dot = sourceCode.getTokenBefore(node.property);\n\n        if (dot.type === \"Punctuator\" && dot.value === \".\") {\n          checkNodes.push(dot);\n        }\n\n        checkNodesIndent(checkNodes, propertyIndent);\n      },\n\n      SwitchStatement(node) {\n        // Switch is not a 'BlockStatement'\n        const switchIndent = getNodeIndent(node).goodChar;\n        const caseIndent = expectedCaseIndent(node, switchIndent);\n        checkNodesIndent(node.cases, caseIndent);\n        checkLastNodeLineIndent(node, switchIndent);\n      },\n\n      SwitchCase(node) {\n        // Skip inline cases\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const caseIndent = expectedCaseIndent(node);\n        checkNodesIndent(node.consequent, caseIndent + indentSize);\n      },\n\n      FunctionDeclaration(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionDeclaration.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n        }\n      },\n\n      FunctionExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionExpression.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n        }\n      },\n\n      ReturnStatement(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const firstLineIndent = getNodeIndent(node).goodChar; // in case if return statement is wrapped in parenthesis\n\n        if (isWrappedInParenthesis(node)) {\n          checkLastReturnStatementLineIndent(node, firstLineIndent);\n        } else {\n          checkNodeIndent(node, firstLineIndent);\n        }\n      },\n\n      CallExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n        } else if (options.CallExpression.arguments !== null) {\n          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/indent-legacy.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","deprecated","replacedBy","fixable","schema","oneOf","enum","minimum","properties","SwitchCase","VariableDeclarator","var","let","const","outerIIFEBody","MemberExpression","FunctionDeclaration","parameters","body","FunctionExpression","CallExpression","ArrayExpression","ObjectExpression","additionalProperties","messages","expected","create","context","DEFAULT_VARIABLE_INDENT","DEFAULT_PARAMETER_INDENT","DEFAULT_FUNCTION_BODY_INDENT","indentType","indentSize","options","arguments","sourceCode","getSourceCode","length","opts","variableDeclaratorRules","Object","assign","caseIndentStore","createErrorMessageData","expectedAmount","actualSpaces","actualTabs","expectedStatement","foundSpacesWord","foundTabsWord","foundStatement","actual","report","node","needed","gottenSpaces","gottenTabs","loc","isLastNodeCheck","desiredIndent","repeat","textRange","range","end","column","start","messageId","data","fix","fixer","replaceTextRange","getNodeIndent","byLastLine","token","getLastToken","getFirstToken","srcCharsBeforeNode","getText","split","indentChars","slice","findIndex","char","spaces","filter","tabs","space","tab","goodChar","badChar","isNodeFirstInLine","byEndLocation","firstToken","getTokenBefore","startLine","line","endLine","checkNodeIndent","neededIndent","actualIndent","alternate","elseToken","handler","catchToken","finalizer","finallyToken","whileToken","getTokenAfter","checkNodesIndent","nodes","indent","forEach","checkLastNodeLineIndent","lastLineIndent","lastToken","endIndent","checkLastReturnStatementLineIndent","firstLineIndent","isClosingParenToken","textBeforeClosingParenthesis","trim","checkFirstNodeLineIndent","startIndent","getParentNodeByType","stopAtList","parent","stopAtSet","Set","has","getVariableDeclaratorNode","isNodeInVarOnTop","varNode","declarations","isArgBeforeCalleeNodeMultiline","isOuterIIFE","stmt","callee","operator","checkIndentInFunctionBlock","calleeNode","calleeParent","functionOffset","parentVarNode","kind","isSingleLineNode","isFirstArrayElementOnSameLine","elements","checkIndentInArrayOrObjectBlock","elem","nodeIndent","elementsIndent","parentElements","indexOf","isNodeBodyBlock","consequent","blockIndentationCheck","nodesToCheck","statementsWithProperties","Array","isArray","filterOutSameLineVars","reduce","finalCollection","lastElem","push","checkIndentInVariableDeclarations","lastElement","tokenBeforeLastElement","value","blockLessNodes","expectedCaseIndent","providedSwitchIndent","switchNode","switchIndent","caseIndent","cases","isWrappedInParenthesis","regex","statementWithoutArgument","replace","argument","test","Program","ClassBody","BlockStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","DoWhileStatement","IfStatement","VariableDeclaration","propertyIndent","checkNodes","property","dot","SwitchStatement","params","ReturnStatement"],"mappings":"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","sourcesContent":["/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent-legacy\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"indent\"],\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object} [loc] Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                messageId: \"expected\",\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         * `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            /*\n             * in case if return statement ends with ');' we have traverse back to ')'\n             * otherwise we'll measure indent for ';' and replace ')'\n             */\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            /*\n             * function body indent should be indent + indent size, unless this\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n             */\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check to see if the first element inside an array is an object and on the same line as the node\n         * If the node is not an array then it will return false.\n         * @param {ASTNode} node node to check\n         * @returns {boolean} success/failure\n         */\n        function isFirstArrayElementOnSameLine(node) {\n            if (node.type === \"ArrayExpression\" && node.elements[0]) {\n                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === \"ObjectExpression\";\n            }\n            return false;\n\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] &&\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== \"MemberExpression\" && parent.type !== \"ExpressionStatement\" && parent.type !== \"AssignmentExpression\" && parent.type !== \"Property\") {\n                    nodeIndent += indentSize;\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent +\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [providedSwitchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, providedSwitchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\n                ? getNodeIndent(switchNode).goodChar\n                : providedSwitchIndent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks wether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                /*\n                 * The typical layout of variable declarations and assignments\n                 * alter the expectation of correct indentation. Skip them.\n                 * TODO: Add appropriate configuration options for variable\n                 * declarations and assignments.\n                 */\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}