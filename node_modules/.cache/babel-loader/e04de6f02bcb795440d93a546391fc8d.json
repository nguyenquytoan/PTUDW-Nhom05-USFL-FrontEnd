{"ast":null,"code":"/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before or after unary operators\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-unary-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        words: {\n          type: \"boolean\",\n          default: true\n        },\n        nonwords: {\n          type: \"boolean\",\n          default: false\n        },\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n      unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n      unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n      wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n      operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n      beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      words: true,\n      nonwords: false\n    };\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n     * @param {ASTnode} node AST node\n     * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n     */\n\n    function isFirstBangInBangBangExpression(node) {\n      return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" && node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n    }\n    /**\n     * Checks if an override exists for a given operator.\n     * @param {string} operator Operator\n     * @returns {boolean} Whether or not an override has been provided for the operator\n     */\n\n\n    function overrideExistsForOperator(operator) {\n      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n    }\n    /**\n     * Gets the value that the override was set to for this operator\n     * @param {string} operator Operator\n     * @returns {boolean} Whether or not an override enforces a space with this operator\n     */\n\n\n    function overrideEnforcesSpaces(operator) {\n      return options.overrides[operator];\n    }\n    /**\n     * Verify Unary Word Operator has spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n\n\n    function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n      if (secondToken.range[0] === firstToken.range[1]) {\n        context.report({\n          node,\n          messageId: \"wordOperator\",\n          data: {\n            word\n          },\n\n          fix(fixer) {\n            return fixer.insertTextAfter(firstToken, \" \");\n          }\n\n        });\n      }\n    }\n    /**\n     * Verify Unary Word Operator doesn't have spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n\n\n    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfterWord\",\n            data: {\n              word\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Check Unary Word Operators for spaces after the word operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken first token from the AST node\n     * @param {Object} secondToken second token from the AST node\n     * @param {string} word The word to be used for reporting\n     * @returns {void}\n     */\n\n\n    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n      if (overrideExistsForOperator(word)) {\n        if (overrideEnforcesSpaces(word)) {\n          verifyWordHasSpaces(node, firstToken, secondToken, word);\n        } else {\n          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n        }\n      } else if (options.words) {\n        verifyWordHasSpaces(node, firstToken, secondToken, word);\n      } else {\n        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n      }\n    }\n    /**\n     * Verifies YieldExpressions satisfy spacing requirements\n     * @param {ASTnode} node AST node\n     * @returns {void}\n     */\n\n\n    function checkForSpacesAfterYield(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3),\n            word = \"yield\";\n\n      if (!node.argument || node.delegate) {\n        return;\n      }\n\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n    }\n    /**\n     * Verifies AwaitExpressions satisfy spacing requirements\n     * @param {ASTNode} node AwaitExpression AST node\n     * @returns {void}\n     */\n\n\n    function checkForSpacesAfterAwait(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3);\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n    }\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken First token in the expression\n     * @param {Object} secondToken Second token in the expression\n     * @returns {void}\n     */\n\n\n    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (isFirstBangInBangBangExpression(node)) {\n          return;\n        }\n\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"operator\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(firstToken, \" \");\n            }\n\n          });\n        }\n      } else {\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"beforeUnaryExpressions\",\n            data: {\n              token: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(secondToken, \" \");\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n     * @param {ASTnode} node AST node\n     * @param {Object} firstToken First token in the expression\n     * @param {Object} secondToken Second token in the expression\n     * @returns {void}\n     */\n\n\n    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfter\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      } else {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedBefore\",\n            data: {\n              operator: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n     * @param {ASTnode} node AST node\n     * @returns {void}\n     */\n\n\n    function checkForSpaces(node) {\n      const tokens = node.type === \"UpdateExpression\" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);\n      const firstToken = tokens[0];\n      const secondToken = tokens[1];\n\n      if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n        return;\n      }\n\n      const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n      if (overrideExistsForOperator(operator)) {\n        if (overrideEnforcesSpaces(operator)) {\n          verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n        } else {\n          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n        }\n      } else if (options.nonwords) {\n        verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n      } else {\n        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      UnaryExpression: checkForSpaces,\n      UpdateExpression: checkForSpaces,\n      NewExpression: checkForSpaces,\n      YieldExpression: checkForSpacesAfterYield,\n      AwaitExpression: checkForSpacesAfterAwait\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/space-unary-ops.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","words","default","nonwords","overrides","additionalProperties","messages","unexpectedBefore","unexpectedAfter","unexpectedAfterWord","wordOperator","operator","beforeUnaryExpressions","create","context","options","sourceCode","getSourceCode","isFirstBangInBangBangExpression","node","argument","overrideExistsForOperator","Object","prototype","hasOwnProperty","call","overrideEnforcesSpaces","verifyWordHasSpaces","firstToken","secondToken","word","range","report","messageId","data","fix","fixer","insertTextAfter","verifyWordDoesntHaveSpaces","canTokensBeAdjacent","removeRange","checkUnaryWordOperatorForSpaces","checkForSpacesAfterYield","tokens","getFirstTokens","delegate","checkForSpacesAfterAwait","verifyNonWordsHaveSpaces","prefix","value","token","insertTextBefore","verifyNonWordsDontHaveSpaces","checkForSpaces","getLastTokens","UnaryExpression","UpdateExpression","NewExpression","YieldExpression","AwaitExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-unary-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    nonwords: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n         * @param {ASTnode} node AST node\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n         */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n         * Checks if an override exists for a given operator.\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override has been provided for the operator\n         */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n        }\n\n        /**\n         * Gets the value that the override was set to for this operator\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override enforces a space with this operator\n         */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n         * Verify Unary Word Operator has spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    messageId: \"wordOperator\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Verify Unary Word Operator doesn't have spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfterWord\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check Unary Word Operators for spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n         * Verifies YieldExpressions satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n         * Verifies AwaitExpressions satisfy spacing requirements\n         * @param {ASTNode} node AwaitExpression AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"operator\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"beforeUnaryExpressions\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfter\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedBefore\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}