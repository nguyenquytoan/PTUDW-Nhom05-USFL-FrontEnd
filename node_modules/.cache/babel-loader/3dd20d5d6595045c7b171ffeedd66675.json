{"ast":null,"code":"/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst importFresh = require(\"import-fresh\");\n\nconst stripComments = require(\"strip-json-comments\");\n\nconst {\n  validateConfigSchema\n} = require(\"../shared/config-validator\");\n\nconst naming = require(\"../shared/naming\");\n\nconst ModuleResolver = require(\"../shared/relative-module-resolver\");\n\nconst {\n  ConfigArray,\n  ConfigDependency,\n  IgnorePattern,\n  OverrideTester\n} = require(\"./config-array\");\n\nconst debug = require(\"debug\")(\"eslint:config-array-factory\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst eslintRecommendedPath = path.resolve(__dirname, \"../../conf/eslint-recommended.js\");\nconst eslintAllPath = path.resolve(__dirname, \"../../conf/eslint-all.js\");\nconst configFilenames = [\".eslintrc.js\", \".eslintrc.cjs\", \".eslintrc.yaml\", \".eslintrc.yml\", \".eslintrc.json\", \".eslintrc\", \"package.json\"]; // Define types for VSCode IntelliSense.\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").OverrideConfigData} OverrideConfigData */\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\n\nconst internalSlotsMap = new WeakMap();\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\n\nfunction isFilePath(nameOrPath) {\n  return /^\\.{1,2}[/\\\\]/u.test(nameOrPath) || path.isAbsolute(nameOrPath);\n}\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\n\n\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadYAMLConfigFile(filePath) {\n  debug(`Loading YAML config file: ${filePath}`); // lazy load YAML to improve performance when not used\n\n  const yaml = require(\"js-yaml\");\n\n  try {\n    // empty YAML file can be null, so always use\n    return yaml.safeLoad(readFile(filePath)) || {};\n  } catch (e) {\n    debug(`Error reading YAML file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadJSONConfigFile(filePath) {\n  debug(`Loading JSON config file: ${filePath}`);\n\n  try {\n    return JSON.parse(stripComments(readFile(filePath)));\n  } catch (e) {\n    debug(`Error reading JSON file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    e.messageTemplate = \"failed-to-read-json\";\n    e.messageData = {\n      path: filePath,\n      message: e.message\n    };\n    throw e;\n  }\n}\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadLegacyConfigFile(filePath) {\n  debug(`Loading legacy config file: ${filePath}`); // lazy load YAML to improve performance when not used\n\n  const yaml = require(\"js-yaml\");\n\n  try {\n    return yaml.safeLoad(stripComments(readFile(filePath))) ||\n    /* istanbul ignore next */\n    {};\n  } catch (e) {\n    debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadJSConfigFile(filePath) {\n  debug(`Loading JS config file: ${filePath}`);\n\n  try {\n    return importFresh(filePath);\n  } catch (e) {\n    debug(`Error reading JavaScript file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadPackageJSONConfigFile(filePath) {\n  debug(`Loading package.json config file: ${filePath}`);\n\n  try {\n    const packageData = loadJSONConfigFile(filePath);\n\n    if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n      throw Object.assign(new Error(\"package.json file doesn't have 'eslintConfig' field.\"), {\n        code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\"\n      });\n    }\n\n    return packageData.eslintConfig;\n  } catch (e) {\n    debug(`Error reading package.json file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\n\n\nfunction loadESLintIgnoreFile(filePath) {\n  debug(`Loading .eslintignore file: ${filePath}`);\n\n  try {\n    return readFile(filePath).split(/\\r?\\n/gu).filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n  } catch (e) {\n    debug(`Error reading .eslintignore file: ${filePath}`);\n    e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @returns {Error} The error object to throw\n * @private\n */\n\n\nfunction configMissingError(configName, importerName) {\n  return Object.assign(new Error(`Failed to load config \"${configName}\" to extend from.`), {\n    messageTemplate: \"extend-config-missing\",\n    messageData: {\n      configName,\n      importerName\n    }\n  });\n}\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\n\n\nfunction loadConfigFile(filePath) {\n  switch (path.extname(filePath)) {\n    case \".js\":\n    case \".cjs\":\n      return loadJSConfigFile(filePath);\n\n    case \".json\":\n      if (path.basename(filePath) === \"package.json\") {\n        return loadPackageJSONConfigFile(filePath);\n      }\n\n      return loadJSONConfigFile(filePath);\n\n    case \".yaml\":\n    case \".yml\":\n      return loadYAMLConfigFile(filePath);\n\n    default:\n      return loadLegacyConfigFile(filePath);\n  }\n}\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\n\n\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n  /* istanbul ignore next */\n  if (debug.enabled) {\n    let nameAndVersion = null;\n\n    try {\n      const packageJsonPath = ModuleResolver.resolve(`${request}/package.json`, relativeTo);\n\n      const {\n        version = \"unknown\"\n      } = require(packageJsonPath);\n\n      nameAndVersion = `${request}@${version}`;\n    } catch (error) {\n      debug(\"package.json was not found:\", error.message);\n      nameAndVersion = request;\n    }\n\n    debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n  }\n}\n/**\n * Concatenate two config data.\n * @param {IterableIterator<ConfigArrayElement>|null} elements The config elements.\n * @param {ConfigArray|null} parentConfigArray The parent config array.\n * @returns {ConfigArray} The concatenated config array.\n */\n\n\nfunction createConfigArray(elements, parentConfigArray) {\n  if (!elements) {\n    return parentConfigArray || new ConfigArray();\n  }\n\n  const configArray = new ConfigArray(...elements);\n\n  if (parentConfigArray && !configArray.isRoot()) {\n    configArray.unshift(...parentConfigArray);\n  }\n\n  return configArray;\n}\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\n\n\nfunction normalizePlugin(plugin) {\n  return {\n    configs: plugin.configs || {},\n    environments: plugin.environments || {},\n    processors: plugin.processors || {},\n    rules: plugin.rules || {}\n  };\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\n\n\nclass ConfigArrayFactory {\n  /**\n   * Initialize this instance.\n   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n   */\n  constructor({\n    additionalPluginPool = new Map(),\n    cwd = process.cwd(),\n    resolvePluginsRelativeTo = cwd\n  } = {}) {\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cwd,\n      resolvePluginsRelativeTo: path.resolve(cwd, resolvePluginsRelativeTo)\n    });\n  }\n  /**\n   * Create `ConfigArray` instance from a config data.\n   * @param {ConfigData|null} configData The config data to create.\n   * @param {Object} [options] The options.\n   * @param {string} [options.filePath] The path to this config data.\n   * @param {string} [options.name] The config name.\n   * @param {ConfigArray} [options.parent] The parent config array.\n   * @returns {ConfigArray} Loaded config.\n   */\n\n\n  create(configData, {\n    filePath,\n    name,\n    parent\n  } = {}) {\n    return createConfigArray(configData ? this._normalizeConfigData(configData, filePath, name) : null, parent);\n  }\n  /**\n   * Load a config file.\n   * @param {string} filePath The path to a config file.\n   * @param {Object} [options] The options.\n   * @param {string} [options.name] The config name.\n   * @param {ConfigArray} [options.parent] The parent config array.\n   * @returns {ConfigArray} Loaded config.\n   */\n\n\n  loadFile(filePath, {\n    name,\n    parent\n  } = {}) {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, filePath);\n    return createConfigArray(this._loadConfigData(absolutePath, name), parent);\n  }\n  /**\n   * Load the config file on a given directory if exists.\n   * @param {string} directoryPath The path to a directory.\n   * @param {Object} [options] The options.\n   * @param {string} [options.name] The config name.\n   * @param {ConfigArray} [options.parent] The parent config array.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadInDirectory(directoryPath, {\n    name,\n    parent\n  } = {}) {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, directoryPath);\n    return createConfigArray(this._loadConfigDataInDirectory(absolutePath, name), parent);\n  }\n  /**\n   * Load `.eslintignore` file.\n   * @param {string} filePath The path to a `.eslintignore` file to load.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadESLintIgnore(filePath) {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, filePath);\n    const name = path.relative(cwd, absolutePath);\n    const ignorePatterns = loadESLintIgnoreFile(absolutePath);\n    return createConfigArray(this._normalizeESLintIgnoreData(ignorePatterns, absolutePath, name));\n  }\n  /**\n   * Load `.eslintignore` file in the current working directory.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadDefaultESLintIgnore() {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const eslintIgnorePath = path.resolve(cwd, \".eslintignore\");\n    const packageJsonPath = path.resolve(cwd, \"package.json\");\n\n    if (fs.existsSync(eslintIgnorePath)) {\n      return this.loadESLintIgnore(eslintIgnorePath);\n    }\n\n    if (fs.existsSync(packageJsonPath)) {\n      const data = loadJSONConfigFile(packageJsonPath);\n\n      if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n        if (!Array.isArray(data.eslintIgnore)) {\n          throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n        }\n\n        return createConfigArray(this._normalizeESLintIgnoreData(data.eslintIgnore, packageJsonPath, \"eslintIgnore in package.json\"));\n      }\n    }\n\n    return new ConfigArray();\n  }\n  /**\n   * Load a given config file.\n   * @param {string} filePath The path to a config file.\n   * @param {string} name The config name.\n   * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n   * @private\n   */\n\n\n  _loadConfigData(filePath, name) {\n    return this._normalizeConfigData(loadConfigFile(filePath), filePath, name);\n  }\n  /**\n   * Load the config file in a given directory if exists.\n   * @param {string} directoryPath The path to a directory.\n   * @param {string} name The config name.\n   * @returns {IterableIterator<ConfigArrayElement> | null} Loaded config. `null` if any config doesn't exist.\n   * @private\n   */\n\n\n  _loadConfigDataInDirectory(directoryPath, name) {\n    for (const filename of configFilenames) {\n      const filePath = path.join(directoryPath, filename);\n\n      if (fs.existsSync(filePath)) {\n        let configData;\n\n        try {\n          configData = loadConfigFile(filePath);\n        } catch (error) {\n          if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n            throw error;\n          }\n        }\n\n        if (configData) {\n          debug(`Config file found: ${filePath}`);\n          return this._normalizeConfigData(configData, filePath, name);\n        }\n      }\n    }\n\n    debug(`Config file not found on ${directoryPath}`);\n    return null;\n  }\n  /**\n   * Normalize a given `.eslintignore` data to config array elements.\n   * @param {string[]} ignorePatterns The patterns to ignore files.\n   * @param {string|undefined} filePath The file path of this config.\n   * @param {string|undefined} name The name of this config.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeESLintIgnoreData(ignorePatterns, filePath, name) {\n    const elements = this._normalizeObjectConfigData({\n      ignorePatterns\n    }, filePath, name); // Set `ignorePattern.loose` flag for backward compatibility.\n\n\n    for (const element of elements) {\n      if (element.ignorePattern) {\n        element.ignorePattern.loose = true;\n      }\n\n      yield element;\n    }\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {string|undefined} providedFilePath The file path of this config.\n   * @param {string|undefined} providedName The name of this config.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _normalizeConfigData(configData, providedFilePath, providedName) {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : \"\";\n    const name = providedName || filePath && path.relative(cwd, filePath);\n    validateConfigSchema(configData, name || filePath);\n    return this._normalizeObjectConfigData(configData, filePath, name);\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n   * @param {string} filePath The file path of this config.\n   * @param {string} name The name of this config.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeObjectConfigData(configData, filePath, name) {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const {\n      files,\n      excludedFiles,\n      ...configBody\n    } = configData;\n    const basePath = filePath ? path.dirname(filePath) : cwd;\n    const criteria = OverrideTester.create(files, excludedFiles, basePath);\n\n    const elements = this._normalizeObjectConfigDataBody(configBody, filePath, name); // Apply the criteria to every element.\n\n\n    for (const element of elements) {\n      // Adopt the base path of the entry file (the outermost base path).\n      if (element.criteria) {\n        element.criteria.basePath = basePath;\n      }\n\n      if (element.ignorePattern) {\n        element.ignorePattern.basePath = basePath;\n      }\n      /*\n       * Merge the criteria; this is for only file extension processors in\n       * `overrides` section for now.\n       */\n\n\n      element.criteria = OverrideTester.and(criteria, element.criteria);\n      /*\n       * Remove `root` property to ignore `root` settings which came from\n       * `extends` in `overrides`.\n       */\n\n      if (element.criteria) {\n        element.root = void 0;\n      }\n\n      yield element;\n    }\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {string} filePath The file path of this config.\n   * @param {string} name The name of this config.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeObjectConfigDataBody({\n    env,\n    extends: extend,\n    globals,\n    ignorePatterns,\n    noInlineConfig,\n    parser: parserName,\n    parserOptions,\n    plugins: pluginList,\n    processor,\n    reportUnusedDisableDirectives,\n    root,\n    rules,\n    settings,\n    overrides: overrideList = []\n  }, filePath, name) {\n    const extendList = Array.isArray(extend) ? extend : [extend];\n    const ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], filePath ? path.dirname(filePath) : internalSlotsMap.get(this).cwd); // Flatten `extends`.\n\n    for (const extendName of extendList.filter(Boolean)) {\n      yield* this._loadExtends(extendName, filePath, name);\n    } // Load parser & plugins.\n\n\n    const parser = parserName && this._loadParser(parserName, filePath, name);\n\n    const plugins = pluginList && this._loadPlugins(pluginList, filePath, name); // Yield pseudo config data for file extension processors.\n\n\n    if (plugins) {\n      yield* this._takeFileExtensionProcessors(plugins, filePath, name);\n    } // Yield the config data except `extends` and `overrides`.\n\n\n    yield {\n      // Debug information.\n      name,\n      filePath,\n      // Config data.\n      criteria: null,\n      env,\n      globals,\n      ignorePattern,\n      noInlineConfig,\n      parser,\n      parserOptions,\n      plugins,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings\n    }; // Flatten `overries`.\n\n    for (let i = 0; i < overrideList.length; ++i) {\n      yield* this._normalizeObjectConfigData(overrideList[i], filePath, `${name}#overrides[${i}]`);\n    }\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {string} importerPath The file path which has the `extends` property.\n   * @param {string} importerName The name of the config which has the `extends` property.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtends(extendName, importerPath, importerName) {\n    debug(\"Loading {extends:%j} relative to %s\", extendName, importerPath);\n\n    try {\n      if (extendName.startsWith(\"eslint:\")) {\n        return this._loadExtendedBuiltInConfig(extendName, importerName);\n      }\n\n      if (extendName.startsWith(\"plugin:\")) {\n        return this._loadExtendedPluginConfig(extendName, importerPath, importerName);\n      }\n\n      return this._loadExtendedShareableConfig(extendName, importerPath, importerName);\n    } catch (error) {\n      error.message += `\\nReferenced from: ${importerPath || importerName}`;\n      throw error;\n    }\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {string} importerName The name of the config which has the `extends` property.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedBuiltInConfig(extendName, importerName) {\n    const name = `${importerName} » ${extendName}`;\n\n    if (extendName === \"eslint:recommended\") {\n      return this._loadConfigData(eslintRecommendedPath, name);\n    }\n\n    if (extendName === \"eslint:all\") {\n      return this._loadConfigData(eslintAllPath, name);\n    }\n\n    throw configMissingError(extendName, importerName);\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {string} importerPath The file path which has the `extends` property.\n   * @param {string} importerName The name of the config which has the `extends` property.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedPluginConfig(extendName, importerPath, importerName) {\n    const slashIndex = extendName.lastIndexOf(\"/\");\n    const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n    const configName = extendName.slice(slashIndex + 1);\n\n    if (isFilePath(pluginName)) {\n      throw new Error(\"'extends' cannot use a file path for plugins.\");\n    }\n\n    const plugin = this._loadPlugin(pluginName, importerPath, importerName);\n\n    const configData = plugin.definition && plugin.definition.configs[configName];\n\n    if (configData) {\n      return this._normalizeConfigData(configData, plugin.filePath, `${importerName} » plugin:${plugin.id}/${configName}`);\n    }\n\n    throw plugin.error || configMissingError(extendName, importerPath);\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {string} importerPath The file path which has the `extends` property.\n   * @param {string} importerName The name of the config which has the `extends` property.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedShareableConfig(extendName, importerPath, importerName) {\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const relativeTo = importerPath || path.join(cwd, \"__placeholder__.js\");\n    let request;\n\n    if (isFilePath(extendName)) {\n      request = extendName;\n    } else if (extendName.startsWith(\".\")) {\n      request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n    } else {\n      request = naming.normalizePackageName(extendName, \"eslint-config\");\n    }\n\n    let filePath;\n\n    try {\n      filePath = ModuleResolver.resolve(request, relativeTo);\n    } catch (error) {\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        throw configMissingError(extendName, importerPath);\n      }\n\n      throw error;\n    }\n\n    writeDebugLogForLoading(request, relativeTo, filePath);\n    return this._loadConfigData(filePath, `${importerName} » ${request}`);\n  }\n  /**\n   * Load given plugins.\n   * @param {string[]} names The plugin names to load.\n   * @param {string} importerPath The path to a config file that imports it. This is just a debug info.\n   * @param {string} importerName The name of a config file that imports it. This is just a debug info.\n   * @returns {Record<string,DependentPlugin>} The loaded parser.\n   * @private\n   */\n\n\n  _loadPlugins(names, importerPath, importerName) {\n    return names.reduce((map, name) => {\n      if (isFilePath(name)) {\n        throw new Error(\"Plugins array cannot includes file paths.\");\n      }\n\n      const plugin = this._loadPlugin(name, importerPath, importerName);\n\n      map[plugin.id] = plugin;\n      return map;\n    }, {});\n  }\n  /**\n   * Load a given parser.\n   * @param {string} nameOrPath The package name or the path to a parser file.\n   * @param {string} importerPath The path to a config file that imports it.\n   * @param {string} importerName The name of a config file that imports it. This is just a debug info.\n   * @returns {DependentParser} The loaded parser.\n   */\n\n\n  _loadParser(nameOrPath, importerPath, importerName) {\n    debug(\"Loading parser %j from %s\", nameOrPath, importerPath);\n    const {\n      cwd\n    } = internalSlotsMap.get(this);\n    const relativeTo = importerPath || path.join(cwd, \"__placeholder__.js\");\n\n    try {\n      const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);\n      writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n      return new ConfigDependency({\n        definition: require(filePath),\n        filePath,\n        id: nameOrPath,\n        importerName,\n        importerPath\n      });\n    } catch (error) {\n      // If the parser name is \"espree\", load the espree of ESLint.\n      if (nameOrPath === \"espree\") {\n        debug(\"Fallback espree.\");\n        return new ConfigDependency({\n          definition: require(\"espree\"),\n          filePath: require.resolve(\"espree\"),\n          id: nameOrPath,\n          importerName,\n          importerPath\n        });\n      }\n\n      debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, importerName);\n      error.message = `Failed to load parser '${nameOrPath}' declared in '${importerName}': ${error.message}`;\n      return new ConfigDependency({\n        error,\n        id: nameOrPath,\n        importerName,\n        importerPath\n      });\n    }\n  }\n  /**\n   * Load a given plugin.\n   * @param {string} name The plugin name to load.\n   * @param {string} importerPath The path to a config file that imports it. This is just a debug info.\n   * @param {string} importerName The name of a config file that imports it. This is just a debug info.\n   * @returns {DependentPlugin} The loaded plugin.\n   * @private\n   */\n\n\n  _loadPlugin(name, importerPath, importerName) {\n    debug(\"Loading plugin %j from %s\", name, importerPath);\n    const {\n      additionalPluginPool,\n      resolvePluginsRelativeTo\n    } = internalSlotsMap.get(this);\n    const request = naming.normalizePackageName(name, \"eslint-plugin\");\n    const id = naming.getShorthandName(request, \"eslint-plugin\");\n    const relativeTo = path.join(resolvePluginsRelativeTo, \"__placeholder__.js\");\n\n    if (name.match(/\\s+/u)) {\n      const error = Object.assign(new Error(`Whitespace found in plugin name '${name}'`), {\n        messageTemplate: \"whitespace-found\",\n        messageData: {\n          pluginName: request\n        }\n      });\n      return new ConfigDependency({\n        error,\n        id,\n        importerName,\n        importerPath\n      });\n    } // Check for additional pool.\n\n\n    const plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);\n\n    if (plugin) {\n      return new ConfigDependency({\n        definition: normalizePlugin(plugin),\n        filePath: importerPath,\n        id,\n        importerName,\n        importerPath\n      });\n    }\n\n    let filePath;\n    let error;\n\n    try {\n      filePath = ModuleResolver.resolve(request, relativeTo);\n    } catch (resolveError) {\n      error = resolveError;\n      /* istanbul ignore else */\n\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        error.messageTemplate = \"plugin-missing\";\n        error.messageData = {\n          pluginName: request,\n          resolvePluginsRelativeTo,\n          importerName\n        };\n      }\n    }\n\n    if (filePath) {\n      try {\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        const startTime = Date.now();\n\n        const pluginDefinition = require(filePath);\n\n        debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n        return new ConfigDependency({\n          definition: normalizePlugin(pluginDefinition),\n          filePath,\n          id,\n          importerName,\n          importerPath\n        });\n      } catch (loadError) {\n        error = loadError;\n      }\n    }\n\n    debug(\"Failed to load plugin '%s' declared in '%s'.\", name, importerName);\n    error.message = `Failed to load plugin '${name}' declared in '${importerName}': ${error.message}`;\n    return new ConfigDependency({\n      error,\n      id,\n      importerName,\n      importerPath\n    });\n  }\n  /**\n   * Take file expression processors as config array elements.\n   * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n   * @param {string} filePath The file path of this config.\n   * @param {string} name The name of this config.\n   * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n   * @private\n   */\n\n\n  *_takeFileExtensionProcessors(plugins, filePath, name) {\n    for (const pluginId of Object.keys(plugins)) {\n      const processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;\n\n      if (!processors) {\n        continue;\n      }\n\n      for (const processorId of Object.keys(processors)) {\n        if (processorId.startsWith(\".\")) {\n          yield* this._normalizeObjectConfigData({\n            files: [`*${processorId}`],\n            processor: `${pluginId}/${processorId}`\n          }, filePath, `${name}#processors[\"${pluginId}/${processorId}\"]`);\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = {\n  ConfigArrayFactory\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/cli-engine/config-array-factory.js"],"names":["fs","require","path","importFresh","stripComments","validateConfigSchema","naming","ModuleResolver","ConfigArray","ConfigDependency","IgnorePattern","OverrideTester","debug","eslintRecommendedPath","resolve","__dirname","eslintAllPath","configFilenames","internalSlotsMap","WeakMap","isFilePath","nameOrPath","test","isAbsolute","readFile","filePath","readFileSync","replace","loadYAMLConfigFile","yaml","safeLoad","e","message","loadJSONConfigFile","JSON","parse","messageTemplate","messageData","loadLegacyConfigFile","loadJSConfigFile","loadPackageJSONConfigFile","packageData","Object","hasOwnProperty","call","assign","Error","code","eslintConfig","loadESLintIgnoreFile","split","filter","line","trim","startsWith","configMissingError","configName","importerName","loadConfigFile","extname","basename","writeDebugLogForLoading","request","relativeTo","enabled","nameAndVersion","packageJsonPath","version","error","createConfigArray","elements","parentConfigArray","configArray","isRoot","unshift","normalizePlugin","plugin","configs","environments","processors","rules","ConfigArrayFactory","constructor","additionalPluginPool","Map","cwd","process","resolvePluginsRelativeTo","set","create","configData","name","parent","_normalizeConfigData","loadFile","get","absolutePath","_loadConfigData","loadInDirectory","directoryPath","_loadConfigDataInDirectory","loadESLintIgnore","relative","ignorePatterns","_normalizeESLintIgnoreData","loadDefaultESLintIgnore","eslintIgnorePath","existsSync","data","Array","isArray","eslintIgnore","filename","join","_normalizeObjectConfigData","element","ignorePattern","loose","providedFilePath","providedName","files","excludedFiles","configBody","basePath","dirname","criteria","_normalizeObjectConfigDataBody","and","root","env","extends","extend","globals","noInlineConfig","parser","parserName","parserOptions","plugins","pluginList","processor","reportUnusedDisableDirectives","settings","overrides","overrideList","extendList","extendName","Boolean","_loadExtends","_loadParser","_loadPlugins","_takeFileExtensionProcessors","i","length","importerPath","_loadExtendedBuiltInConfig","_loadExtendedPluginConfig","_loadExtendedShareableConfig","slashIndex","lastIndexOf","pluginName","slice","_loadPlugin","definition","id","normalizePackageName","names","reduce","map","getShorthandName","match","resolveError","startTime","Date","now","pluginDefinition","loadError","pluginId","keys","processorId","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,a,CAEA;AACA;AACA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,qBAAD,CAA7B;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAA2BJ,OAAO,CAAC,4BAAD,CAAxC;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,kBAAD,CAAtB;;AACA,MAAMM,cAAc,GAAGN,OAAO,CAAC,oCAAD,CAA9B;;AACA,MAAM;AACFO,EAAAA,WADE;AAEFC,EAAAA,gBAFE;AAGFC,EAAAA,aAHE;AAIFC,EAAAA;AAJE,IAKFV,OAAO,CAAC,gBAAD,CALX;;AAMA,MAAMW,KAAK,GAAGX,OAAO,CAAC,OAAD,CAAP,CAAiB,6BAAjB,CAAd,C,CAEA;AACA;AACA;;;AAEA,MAAMY,qBAAqB,GAAGX,IAAI,CAACY,OAAL,CAAaC,SAAb,EAAwB,kCAAxB,CAA9B;AACA,MAAMC,aAAa,GAAGd,IAAI,CAACY,OAAL,CAAaC,SAAb,EAAwB,0BAAxB,CAAtB;AACA,MAAME,eAAe,GAAG,CACpB,cADoB,EAEpB,eAFoB,EAGpB,gBAHoB,EAIpB,eAJoB,EAKpB,gBALoB,EAMpB,WANoB,EAOpB,cAPoB,CAAxB,C,CAUA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;;;;AAOA;;;;;;;AAOA;;AACA,MAAMC,gBAAgB,GAAG,IAAIC,OAAJ,EAAzB;AAEA;;;;;;AAKA,SAASC,UAAT,CAAoBC,UAApB,EAAgC;AAC5B,SACI,iBAAiBC,IAAjB,CAAsBD,UAAtB,KACAnB,IAAI,CAACqB,UAAL,CAAgBF,UAAhB,CAFJ;AAIH;AAED;;;;;;;;AAMA,SAASG,QAAT,CAAkBC,QAAlB,EAA4B;AACxB,SAAOzB,EAAE,CAAC0B,YAAH,CAAgBD,QAAhB,EAA0B,MAA1B,EAAkCE,OAAlC,CAA0C,UAA1C,EAAsD,EAAtD,CAAP;AACH;AAED;;;;;;;;;AAOA,SAASC,kBAAT,CAA4BH,QAA5B,EAAsC;AAClCb,EAAAA,KAAK,CAAE,6BAA4Ba,QAAS,EAAvC,CAAL,CADkC,CAGlC;;AACA,QAAMI,IAAI,GAAG5B,OAAO,CAAC,SAAD,CAApB;;AAEA,MAAI;AAEA;AACA,WAAO4B,IAAI,CAACC,QAAL,CAAcN,QAAQ,CAACC,QAAD,CAAtB,KAAqC,EAA5C;AACH,GAJD,CAIE,OAAOM,CAAP,EAAU;AACRnB,IAAAA,KAAK,CAAE,4BAA2Ba,QAAS,EAAtC,CAAL;AACAM,IAAAA,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;AACA,UAAMD,CAAN;AACH;AACJ;AAED;;;;;;;;;AAOA,SAASE,kBAAT,CAA4BR,QAA5B,EAAsC;AAClCb,EAAAA,KAAK,CAAE,6BAA4Ba,QAAS,EAAvC,CAAL;;AAEA,MAAI;AACA,WAAOS,IAAI,CAACC,KAAL,CAAW/B,aAAa,CAACoB,QAAQ,CAACC,QAAD,CAAT,CAAxB,CAAP;AACH,GAFD,CAEE,OAAOM,CAAP,EAAU;AACRnB,IAAAA,KAAK,CAAE,4BAA2Ba,QAAS,EAAtC,CAAL;AACAM,IAAAA,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;AACAD,IAAAA,CAAC,CAACK,eAAF,GAAoB,qBAApB;AACAL,IAAAA,CAAC,CAACM,WAAF,GAAgB;AACZnC,MAAAA,IAAI,EAAEuB,QADM;AAEZO,MAAAA,OAAO,EAAED,CAAC,CAACC;AAFC,KAAhB;AAIA,UAAMD,CAAN;AACH;AACJ;AAED;;;;;;;;;AAOA,SAASO,oBAAT,CAA8Bb,QAA9B,EAAwC;AACpCb,EAAAA,KAAK,CAAE,+BAA8Ba,QAAS,EAAzC,CAAL,CADoC,CAGpC;;AACA,QAAMI,IAAI,GAAG5B,OAAO,CAAC,SAAD,CAApB;;AAEA,MAAI;AACA,WAAO4B,IAAI,CAACC,QAAL,CAAc1B,aAAa,CAACoB,QAAQ,CAACC,QAAD,CAAT,CAA3B;AAAoD;AAA2B,MAAtF;AACH,GAFD,CAEE,OAAOM,CAAP,EAAU;AACRnB,IAAAA,KAAK,CAAC,iCAAD,EAAoCa,QAApC,EAA8CM,CAA9C,CAAL;AACAA,IAAAA,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;AACA,UAAMD,CAAN;AACH;AACJ;AAED;;;;;;;;;AAOA,SAASQ,gBAAT,CAA0Bd,QAA1B,EAAoC;AAChCb,EAAAA,KAAK,CAAE,2BAA0Ba,QAAS,EAArC,CAAL;;AACA,MAAI;AACA,WAAOtB,WAAW,CAACsB,QAAD,CAAlB;AACH,GAFD,CAEE,OAAOM,CAAP,EAAU;AACRnB,IAAAA,KAAK,CAAE,kCAAiCa,QAAS,EAA5C,CAAL;AACAM,IAAAA,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;AACA,UAAMD,CAAN;AACH;AACJ;AAED;;;;;;;;;AAOA,SAASS,yBAAT,CAAmCf,QAAnC,EAA6C;AACzCb,EAAAA,KAAK,CAAE,qCAAoCa,QAAS,EAA/C,CAAL;;AACA,MAAI;AACA,UAAMgB,WAAW,GAAGR,kBAAkB,CAACR,QAAD,CAAtC;;AAEA,QAAI,CAACiB,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BH,WAA3B,EAAwC,cAAxC,CAAL,EAA8D;AAC1D,YAAMC,MAAM,CAACG,MAAP,CACF,IAAIC,KAAJ,CAAU,sDAAV,CADE,EAEF;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAFE,CAAN;AAIH;;AAED,WAAON,WAAW,CAACO,YAAnB;AACH,GAXD,CAWE,OAAOjB,CAAP,EAAU;AACRnB,IAAAA,KAAK,CAAE,oCAAmCa,QAAS,EAA9C,CAAL;AACAM,IAAAA,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;AACA,UAAMD,CAAN;AACH;AACJ;AAED;;;;;;;;AAMA,SAASkB,oBAAT,CAA8BxB,QAA9B,EAAwC;AACpCb,EAAAA,KAAK,CAAE,+BAA8Ba,QAAS,EAAzC,CAAL;;AAEA,MAAI;AACA,WAAOD,QAAQ,CAACC,QAAD,CAAR,CACFyB,KADE,CACI,SADJ,EAEFC,MAFE,CAEKC,IAAI,IAAIA,IAAI,CAACC,IAAL,OAAgB,EAAhB,IAAsB,CAACD,IAAI,CAACE,UAAL,CAAgB,GAAhB,CAFpC,CAAP;AAGH,GAJD,CAIE,OAAOvB,CAAP,EAAU;AACRnB,IAAAA,KAAK,CAAE,qCAAoCa,QAAS,EAA/C,CAAL;AACAM,IAAAA,CAAC,CAACC,OAAF,GAAa,mCAAkCP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAA7E;AACA,UAAMD,CAAN;AACH;AACJ;AAED;;;;;;;;;AAOA,SAASwB,kBAAT,CAA4BC,UAA5B,EAAwCC,YAAxC,EAAsD;AAClD,SAAOf,MAAM,CAACG,MAAP,CACH,IAAIC,KAAJ,CAAW,0BAAyBU,UAAW,mBAA/C,CADG,EAEH;AACIpB,IAAAA,eAAe,EAAE,uBADrB;AAEIC,IAAAA,WAAW,EAAE;AAAEmB,MAAAA,UAAF;AAAcC,MAAAA;AAAd;AAFjB,GAFG,CAAP;AAOH;AAED;;;;;;;;;AAOA,SAASC,cAAT,CAAwBjC,QAAxB,EAAkC;AAC9B,UAAQvB,IAAI,CAACyD,OAAL,CAAalC,QAAb,CAAR;AACI,SAAK,KAAL;AACA,SAAK,MAAL;AACI,aAAOc,gBAAgB,CAACd,QAAD,CAAvB;;AAEJ,SAAK,OAAL;AACI,UAAIvB,IAAI,CAAC0D,QAAL,CAAcnC,QAAd,MAA4B,cAAhC,EAAgD;AAC5C,eAAOe,yBAAyB,CAACf,QAAD,CAAhC;AACH;;AACD,aAAOQ,kBAAkB,CAACR,QAAD,CAAzB;;AAEJ,SAAK,OAAL;AACA,SAAK,MAAL;AACI,aAAOG,kBAAkB,CAACH,QAAD,CAAzB;;AAEJ;AACI,aAAOa,oBAAoB,CAACb,QAAD,CAA3B;AAhBR;AAkBH;AAED;;;;;;;;;AAOA,SAASoC,uBAAT,CAAiCC,OAAjC,EAA0CC,UAA1C,EAAsDtC,QAAtD,EAAgE;AAC5D;AACA,MAAIb,KAAK,CAACoD,OAAV,EAAmB;AACf,QAAIC,cAAc,GAAG,IAArB;;AAEA,QAAI;AACA,YAAMC,eAAe,GAAG3D,cAAc,CAACO,OAAf,CACnB,GAAEgD,OAAQ,eADS,EAEpBC,UAFoB,CAAxB;;AAIA,YAAM;AAAEI,QAAAA,OAAO,GAAG;AAAZ,UAA0BlE,OAAO,CAACiE,eAAD,CAAvC;;AAEAD,MAAAA,cAAc,GAAI,GAAEH,OAAQ,IAAGK,OAAQ,EAAvC;AACH,KARD,CAQE,OAAOC,KAAP,EAAc;AACZxD,MAAAA,KAAK,CAAC,6BAAD,EAAgCwD,KAAK,CAACpC,OAAtC,CAAL;AACAiC,MAAAA,cAAc,GAAGH,OAAjB;AACH;;AAEDlD,IAAAA,KAAK,CAAC,iBAAD,EAAoBqD,cAApB,EAAoCxC,QAApC,CAAL;AACH;AACJ;AAED;;;;;;;;AAMA,SAAS4C,iBAAT,CAA2BC,QAA3B,EAAqCC,iBAArC,EAAwD;AACpD,MAAI,CAACD,QAAL,EAAe;AACX,WAAOC,iBAAiB,IAAI,IAAI/D,WAAJ,EAA5B;AACH;;AACD,QAAMgE,WAAW,GAAG,IAAIhE,WAAJ,CAAgB,GAAG8D,QAAnB,CAApB;;AAEA,MAAIC,iBAAiB,IAAI,CAACC,WAAW,CAACC,MAAZ,EAA1B,EAAgD;AAC5CD,IAAAA,WAAW,CAACE,OAAZ,CAAoB,GAAGH,iBAAvB;AACH;;AACD,SAAOC,WAAP;AACH;AAED;;;;;;;;;AAOA,SAASG,eAAT,CAAyBC,MAAzB,EAAiC;AAC7B,SAAO;AACHC,IAAAA,OAAO,EAAED,MAAM,CAACC,OAAP,IAAkB,EADxB;AAEHC,IAAAA,YAAY,EAAEF,MAAM,CAACE,YAAP,IAAuB,EAFlC;AAGHC,IAAAA,UAAU,EAAEH,MAAM,CAACG,UAAP,IAAqB,EAH9B;AAIHC,IAAAA,KAAK,EAAEJ,MAAM,CAACI,KAAP,IAAgB;AAJpB,GAAP;AAMH,C,CAED;AACA;AACA;;AAEA;;;;;AAGA,MAAMC,kBAAN,CAAyB;AAErB;;;;AAIAC,EAAAA,WAAW,CAAC;AACRC,IAAAA,oBAAoB,GAAG,IAAIC,GAAJ,EADf;AAERC,IAAAA,GAAG,GAAGC,OAAO,CAACD,GAAR,EAFE;AAGRE,IAAAA,wBAAwB,GAAGF;AAHnB,MAIR,EAJO,EAIH;AACJnE,IAAAA,gBAAgB,CAACsE,GAAjB,CAAqB,IAArB,EAA2B;AAAEL,MAAAA,oBAAF;AAAwBE,MAAAA,GAAxB;AAA6BE,MAAAA,wBAAwB,EAAErF,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkBE,wBAAlB;AAAvD,KAA3B;AACH;AAED;;;;;;;;;;;AASAE,EAAAA,MAAM,CAACC,UAAD,EAAa;AAAEjE,IAAAA,QAAF;AAAYkE,IAAAA,IAAZ;AAAkBC,IAAAA;AAAlB,MAA6B,EAA1C,EAA8C;AAChD,WAAOvB,iBAAiB,CACpBqB,UAAU,GACJ,KAAKG,oBAAL,CAA0BH,UAA1B,EAAsCjE,QAAtC,EAAgDkE,IAAhD,CADI,GAEJ,IAHc,EAIpBC,MAJoB,CAAxB;AAMH;AAED;;;;;;;;;;AAQAE,EAAAA,QAAQ,CAACrE,QAAD,EAAW;AAAEkE,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAmB,EAA9B,EAAkC;AACtC,UAAM;AAAEP,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMC,YAAY,GAAG9F,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkB5D,QAAlB,CAArB;AAEA,WAAO4C,iBAAiB,CACpB,KAAK4B,eAAL,CAAqBD,YAArB,EAAmCL,IAAnC,CADoB,EAEpBC,MAFoB,CAAxB;AAIH;AAED;;;;;;;;;;AAQAM,EAAAA,eAAe,CAACC,aAAD,EAAgB;AAAER,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAmB,EAAnC,EAAuC;AAClD,UAAM;AAAEP,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMC,YAAY,GAAG9F,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkBc,aAAlB,CAArB;AAEA,WAAO9B,iBAAiB,CACpB,KAAK+B,0BAAL,CAAgCJ,YAAhC,EAA8CL,IAA9C,CADoB,EAEpBC,MAFoB,CAAxB;AAIH;AAED;;;;;;;AAKAS,EAAAA,gBAAgB,CAAC5E,QAAD,EAAW;AACvB,UAAM;AAAE4D,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMC,YAAY,GAAG9F,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkB5D,QAAlB,CAArB;AACA,UAAMkE,IAAI,GAAGzF,IAAI,CAACoG,QAAL,CAAcjB,GAAd,EAAmBW,YAAnB,CAAb;AACA,UAAMO,cAAc,GAAGtD,oBAAoB,CAAC+C,YAAD,CAA3C;AAEA,WAAO3B,iBAAiB,CACpB,KAAKmC,0BAAL,CAAgCD,cAAhC,EAAgDP,YAAhD,EAA8DL,IAA9D,CADoB,CAAxB;AAGH;AAED;;;;;;AAIAc,EAAAA,uBAAuB,GAAG;AACtB,UAAM;AAAEpB,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMW,gBAAgB,GAAGxG,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkB,eAAlB,CAAzB;AACA,UAAMnB,eAAe,GAAGhE,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkB,cAAlB,CAAxB;;AAEA,QAAIrF,EAAE,CAAC2G,UAAH,CAAcD,gBAAd,CAAJ,EAAqC;AACjC,aAAO,KAAKL,gBAAL,CAAsBK,gBAAtB,CAAP;AACH;;AACD,QAAI1G,EAAE,CAAC2G,UAAH,CAAczC,eAAd,CAAJ,EAAoC;AAChC,YAAM0C,IAAI,GAAG3E,kBAAkB,CAACiC,eAAD,CAA/B;;AAEA,UAAIxB,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BgE,IAA3B,EAAiC,cAAjC,CAAJ,EAAsD;AAClD,YAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAI,CAACG,YAAnB,CAAL,EAAuC;AACnC,gBAAM,IAAIjE,KAAJ,CAAU,+DAAV,CAAN;AACH;;AACD,eAAOuB,iBAAiB,CACpB,KAAKmC,0BAAL,CACII,IAAI,CAACG,YADT,EAEI7C,eAFJ,EAGI,8BAHJ,CADoB,CAAxB;AAOH;AACJ;;AAED,WAAO,IAAI1D,WAAJ,EAAP;AACH;AAED;;;;;;;;;AAOAyF,EAAAA,eAAe,CAACxE,QAAD,EAAWkE,IAAX,EAAiB;AAC5B,WAAO,KAAKE,oBAAL,CACHnC,cAAc,CAACjC,QAAD,CADX,EAEHA,QAFG,EAGHkE,IAHG,CAAP;AAKH;AAED;;;;;;;;;AAOAS,EAAAA,0BAA0B,CAACD,aAAD,EAAgBR,IAAhB,EAAsB;AAC5C,SAAK,MAAMqB,QAAX,IAAuB/F,eAAvB,EAAwC;AACpC,YAAMQ,QAAQ,GAAGvB,IAAI,CAAC+G,IAAL,CAAUd,aAAV,EAAyBa,QAAzB,CAAjB;;AAEA,UAAIhH,EAAE,CAAC2G,UAAH,CAAclF,QAAd,CAAJ,EAA6B;AACzB,YAAIiE,UAAJ;;AAEA,YAAI;AACAA,UAAAA,UAAU,GAAGhC,cAAc,CAACjC,QAAD,CAA3B;AACH,SAFD,CAEE,OAAO2C,KAAP,EAAc;AACZ,cAAI,CAACA,KAAD,IAAUA,KAAK,CAACrB,IAAN,KAAe,+BAA7B,EAA8D;AAC1D,kBAAMqB,KAAN;AACH;AACJ;;AAED,YAAIsB,UAAJ,EAAgB;AACZ9E,UAAAA,KAAK,CAAE,sBAAqBa,QAAS,EAAhC,CAAL;AACA,iBAAO,KAAKoE,oBAAL,CAA0BH,UAA1B,EAAsCjE,QAAtC,EAAgDkE,IAAhD,CAAP;AACH;AACJ;AACJ;;AAED/E,IAAAA,KAAK,CAAE,4BAA2BuF,aAAc,EAA3C,CAAL;AACA,WAAO,IAAP;AACH;AAED;;;;;;;;;;AAQA,GAACK,0BAAD,CAA4BD,cAA5B,EAA4C9E,QAA5C,EAAsDkE,IAAtD,EAA4D;AACxD,UAAMrB,QAAQ,GAAG,KAAK4C,0BAAL,CACb;AAAEX,MAAAA;AAAF,KADa,EAEb9E,QAFa,EAGbkE,IAHa,CAAjB,CADwD,CAOxD;;;AACA,SAAK,MAAMwB,OAAX,IAAsB7C,QAAtB,EAAgC;AAC5B,UAAI6C,OAAO,CAACC,aAAZ,EAA2B;AACvBD,QAAAA,OAAO,CAACC,aAAR,CAAsBC,KAAtB,GAA8B,IAA9B;AACH;;AACD,YAAMF,OAAN;AACH;AACJ;AAED;;;;;;;;;;AAQAtB,EAAAA,oBAAoB,CAACH,UAAD,EAAa4B,gBAAb,EAA+BC,YAA/B,EAA6C;AAC7D,UAAM;AAAElC,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMtE,QAAQ,GAAG6F,gBAAgB,GAC3BpH,IAAI,CAACY,OAAL,CAAauE,GAAb,EAAkBiC,gBAAlB,CAD2B,GAE3B,EAFN;AAGA,UAAM3B,IAAI,GAAG4B,YAAY,IAAK9F,QAAQ,IAAIvB,IAAI,CAACoG,QAAL,CAAcjB,GAAd,EAAmB5D,QAAnB,CAA1C;AAEApB,IAAAA,oBAAoB,CAACqF,UAAD,EAAaC,IAAI,IAAIlE,QAArB,CAApB;AAEA,WAAO,KAAKyF,0BAAL,CAAgCxB,UAAhC,EAA4CjE,QAA5C,EAAsDkE,IAAtD,CAAP;AACH;AAED;;;;;;;;;;AAQA,GAACuB,0BAAD,CAA4BxB,UAA5B,EAAwCjE,QAAxC,EAAkDkE,IAAlD,EAAwD;AACpD,UAAM;AAAEN,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAM;AAAEyB,MAAAA,KAAF;AAASC,MAAAA,aAAT;AAAwB,SAAGC;AAA3B,QAA0ChC,UAAhD;AACA,UAAMiC,QAAQ,GAAGlG,QAAQ,GAAGvB,IAAI,CAAC0H,OAAL,CAAanG,QAAb,CAAH,GAA4B4D,GAArD;AACA,UAAMwC,QAAQ,GAAGlH,cAAc,CAAC8E,MAAf,CAAsB+B,KAAtB,EAA6BC,aAA7B,EAA4CE,QAA5C,CAAjB;;AACA,UAAMrD,QAAQ,GACV,KAAKwD,8BAAL,CAAoCJ,UAApC,EAAgDjG,QAAhD,EAA0DkE,IAA1D,CADJ,CALoD,CAQpD;;;AACA,SAAK,MAAMwB,OAAX,IAAsB7C,QAAtB,EAAgC;AAE5B;AACA,UAAI6C,OAAO,CAACU,QAAZ,EAAsB;AAClBV,QAAAA,OAAO,CAACU,QAAR,CAAiBF,QAAjB,GAA4BA,QAA5B;AACH;;AACD,UAAIR,OAAO,CAACC,aAAZ,EAA2B;AACvBD,QAAAA,OAAO,CAACC,aAAR,CAAsBO,QAAtB,GAAiCA,QAAjC;AACH;AAED;;;;;;AAIAR,MAAAA,OAAO,CAACU,QAAR,GAAmBlH,cAAc,CAACoH,GAAf,CAAmBF,QAAnB,EAA6BV,OAAO,CAACU,QAArC,CAAnB;AAEA;;;;;AAIA,UAAIV,OAAO,CAACU,QAAZ,EAAsB;AAClBV,QAAAA,OAAO,CAACa,IAAR,GAAe,KAAK,CAApB;AACH;;AAED,YAAMb,OAAN;AACH;AACJ;AAED;;;;;;;;;;AAQA,GAACW,8BAAD,CACI;AACIG,IAAAA,GADJ;AAEIC,IAAAA,OAAO,EAAEC,MAFb;AAGIC,IAAAA,OAHJ;AAII7B,IAAAA,cAJJ;AAKI8B,IAAAA,cALJ;AAMIC,IAAAA,MAAM,EAAEC,UANZ;AAOIC,IAAAA,aAPJ;AAQIC,IAAAA,OAAO,EAAEC,UARb;AASIC,IAAAA,SATJ;AAUIC,IAAAA,6BAVJ;AAWIZ,IAAAA,IAXJ;AAYIhD,IAAAA,KAZJ;AAaI6D,IAAAA,QAbJ;AAcIC,IAAAA,SAAS,EAAEC,YAAY,GAAG;AAd9B,GADJ,EAiBItH,QAjBJ,EAkBIkE,IAlBJ,EAmBE;AACE,UAAMqD,UAAU,GAAGnC,KAAK,CAACC,OAAN,CAAcqB,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAApD;AACA,UAAMf,aAAa,GAAGb,cAAc,IAAI,IAAI7F,aAAJ,CACpCmG,KAAK,CAACC,OAAN,CAAcP,cAAd,IAAgCA,cAAhC,GAAiD,CAACA,cAAD,CADb,EAEpC9E,QAAQ,GAAGvB,IAAI,CAAC0H,OAAL,CAAanG,QAAb,CAAH,GAA4BP,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,EAA2BV,GAF3B,CAAxC,CAFF,CAOE;;AACA,SAAK,MAAM4D,UAAX,IAAyBD,UAAU,CAAC7F,MAAX,CAAkB+F,OAAlB,CAAzB,EAAqD;AACjD,aAAO,KAAKC,YAAL,CAAkBF,UAAlB,EAA8BxH,QAA9B,EAAwCkE,IAAxC,CAAP;AACH,KAVH,CAYE;;;AACA,UAAM2C,MAAM,GACRC,UAAU,IAAI,KAAKa,WAAL,CAAiBb,UAAjB,EAA6B9G,QAA7B,EAAuCkE,IAAvC,CADlB;;AAEA,UAAM8C,OAAO,GACTC,UAAU,IAAI,KAAKW,YAAL,CAAkBX,UAAlB,EAA8BjH,QAA9B,EAAwCkE,IAAxC,CADlB,CAfF,CAkBE;;;AACA,QAAI8C,OAAJ,EAAa;AACT,aAAO,KAAKa,4BAAL,CAAkCb,OAAlC,EAA2ChH,QAA3C,EAAqDkE,IAArD,CAAP;AACH,KArBH,CAuBE;;;AACA,UAAM;AAEF;AACAA,MAAAA,IAHE;AAIFlE,MAAAA,QAJE;AAMF;AACAoG,MAAAA,QAAQ,EAAE,IAPR;AAQFI,MAAAA,GARE;AASFG,MAAAA,OATE;AAUFhB,MAAAA,aAVE;AAWFiB,MAAAA,cAXE;AAYFC,MAAAA,MAZE;AAaFE,MAAAA,aAbE;AAcFC,MAAAA,OAdE;AAeFE,MAAAA,SAfE;AAgBFC,MAAAA,6BAhBE;AAiBFZ,MAAAA,IAjBE;AAkBFhD,MAAAA,KAlBE;AAmBF6D,MAAAA;AAnBE,KAAN,CAxBF,CA8CE;;AACA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,YAAY,CAACS,MAAjC,EAAyC,EAAED,CAA3C,EAA8C;AAC1C,aAAO,KAAKrC,0BAAL,CACH6B,YAAY,CAACQ,CAAD,CADT,EAEH9H,QAFG,EAGF,GAAEkE,IAAK,cAAa4D,CAAE,GAHpB,CAAP;AAKH;AACJ;AAED;;;;;;;;;;AAQAJ,EAAAA,YAAY,CAACF,UAAD,EAAaQ,YAAb,EAA2BhG,YAA3B,EAAyC;AACjD7C,IAAAA,KAAK,CAAC,qCAAD,EAAwCqI,UAAxC,EAAoDQ,YAApD,CAAL;;AACA,QAAI;AACA,UAAIR,UAAU,CAAC3F,UAAX,CAAsB,SAAtB,CAAJ,EAAsC;AAClC,eAAO,KAAKoG,0BAAL,CACHT,UADG,EAEHxF,YAFG,CAAP;AAIH;;AACD,UAAIwF,UAAU,CAAC3F,UAAX,CAAsB,SAAtB,CAAJ,EAAsC;AAClC,eAAO,KAAKqG,yBAAL,CACHV,UADG,EAEHQ,YAFG,EAGHhG,YAHG,CAAP;AAKH;;AACD,aAAO,KAAKmG,4BAAL,CACHX,UADG,EAEHQ,YAFG,EAGHhG,YAHG,CAAP;AAKH,KAnBD,CAmBE,OAAOW,KAAP,EAAc;AACZA,MAAAA,KAAK,CAACpC,OAAN,IAAkB,sBAAqByH,YAAY,IAAIhG,YAAa,EAApE;AACA,YAAMW,KAAN;AACH;AACJ;AAED;;;;;;;;;AAOAsF,EAAAA,0BAA0B,CAACT,UAAD,EAAaxF,YAAb,EAA2B;AACjD,UAAMkC,IAAI,GAAI,GAAElC,YAAa,MAAKwF,UAAW,EAA7C;;AAEA,QAAIA,UAAU,KAAK,oBAAnB,EAAyC;AACrC,aAAO,KAAKhD,eAAL,CAAqBpF,qBAArB,EAA4C8E,IAA5C,CAAP;AACH;;AACD,QAAIsD,UAAU,KAAK,YAAnB,EAAiC;AAC7B,aAAO,KAAKhD,eAAL,CAAqBjF,aAArB,EAAoC2E,IAApC,CAAP;AACH;;AAED,UAAMpC,kBAAkB,CAAC0F,UAAD,EAAaxF,YAAb,CAAxB;AACH;AAED;;;;;;;;;;AAQAkG,EAAAA,yBAAyB,CAACV,UAAD,EAAaQ,YAAb,EAA2BhG,YAA3B,EAAyC;AAC9D,UAAMoG,UAAU,GAAGZ,UAAU,CAACa,WAAX,CAAuB,GAAvB,CAAnB;AACA,UAAMC,UAAU,GAAGd,UAAU,CAACe,KAAX,CAAiB,UAAUR,MAA3B,EAAmCK,UAAnC,CAAnB;AACA,UAAMrG,UAAU,GAAGyF,UAAU,CAACe,KAAX,CAAiBH,UAAU,GAAG,CAA9B,CAAnB;;AAEA,QAAIzI,UAAU,CAAC2I,UAAD,CAAd,EAA4B;AACxB,YAAM,IAAIjH,KAAJ,CAAU,+CAAV,CAAN;AACH;;AAED,UAAM8B,MAAM,GAAG,KAAKqF,WAAL,CAAiBF,UAAjB,EAA6BN,YAA7B,EAA2ChG,YAA3C,CAAf;;AACA,UAAMiC,UAAU,GACZd,MAAM,CAACsF,UAAP,IACAtF,MAAM,CAACsF,UAAP,CAAkBrF,OAAlB,CAA0BrB,UAA1B,CAFJ;;AAIA,QAAIkC,UAAJ,EAAgB;AACZ,aAAO,KAAKG,oBAAL,CACHH,UADG,EAEHd,MAAM,CAACnD,QAFJ,EAGF,GAAEgC,YAAa,aAAYmB,MAAM,CAACuF,EAAG,IAAG3G,UAAW,EAHjD,CAAP;AAKH;;AAED,UAAMoB,MAAM,CAACR,KAAP,IAAgBb,kBAAkB,CAAC0F,UAAD,EAAaQ,YAAb,CAAxC;AACH;AAED;;;;;;;;;;AAQAG,EAAAA,4BAA4B,CAACX,UAAD,EAAaQ,YAAb,EAA2BhG,YAA3B,EAAyC;AACjE,UAAM;AAAE4B,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMhC,UAAU,GAAG0F,YAAY,IAAIvJ,IAAI,CAAC+G,IAAL,CAAU5B,GAAV,EAAe,oBAAf,CAAnC;AACA,QAAIvB,OAAJ;;AAEA,QAAI1C,UAAU,CAAC6H,UAAD,CAAd,EAA4B;AACxBnF,MAAAA,OAAO,GAAGmF,UAAV;AACH,KAFD,MAEO,IAAIA,UAAU,CAAC3F,UAAX,CAAsB,GAAtB,CAAJ,EAAgC;AACnCQ,MAAAA,OAAO,GAAI,KAAImF,UAAW,EAA1B,CADmC,CACN;AAChC,KAFM,MAEA;AACHnF,MAAAA,OAAO,GAAGxD,MAAM,CAAC8J,oBAAP,CACNnB,UADM,EAEN,eAFM,CAAV;AAIH;;AAED,QAAIxH,QAAJ;;AAEA,QAAI;AACAA,MAAAA,QAAQ,GAAGlB,cAAc,CAACO,OAAf,CAAuBgD,OAAvB,EAAgCC,UAAhC,CAAX;AACH,KAFD,CAEE,OAAOK,KAAP,EAAc;AACZ;AACA,UAAIA,KAAK,IAAIA,KAAK,CAACrB,IAAN,KAAe,kBAA5B,EAAgD;AAC5C,cAAMQ,kBAAkB,CAAC0F,UAAD,EAAaQ,YAAb,CAAxB;AACH;;AACD,YAAMrF,KAAN;AACH;;AAEDP,IAAAA,uBAAuB,CAACC,OAAD,EAAUC,UAAV,EAAsBtC,QAAtB,CAAvB;AACA,WAAO,KAAKwE,eAAL,CAAqBxE,QAArB,EAAgC,GAAEgC,YAAa,MAAKK,OAAQ,EAA5D,CAAP;AACH;AAED;;;;;;;;;;AAQAuF,EAAAA,YAAY,CAACgB,KAAD,EAAQZ,YAAR,EAAsBhG,YAAtB,EAAoC;AAC5C,WAAO4G,KAAK,CAACC,MAAN,CAAa,CAACC,GAAD,EAAM5E,IAAN,KAAe;AAC/B,UAAIvE,UAAU,CAACuE,IAAD,CAAd,EAAsB;AAClB,cAAM,IAAI7C,KAAJ,CAAU,2CAAV,CAAN;AACH;;AACD,YAAM8B,MAAM,GAAG,KAAKqF,WAAL,CAAiBtE,IAAjB,EAAuB8D,YAAvB,EAAqChG,YAArC,CAAf;;AAEA8G,MAAAA,GAAG,CAAC3F,MAAM,CAACuF,EAAR,CAAH,GAAiBvF,MAAjB;AAEA,aAAO2F,GAAP;AACH,KATM,EASJ,EATI,CAAP;AAUH;AAED;;;;;;;;;AAOAnB,EAAAA,WAAW,CAAC/H,UAAD,EAAaoI,YAAb,EAA2BhG,YAA3B,EAAyC;AAChD7C,IAAAA,KAAK,CAAC,2BAAD,EAA8BS,UAA9B,EAA0CoI,YAA1C,CAAL;AAEA,UAAM;AAAEpE,MAAAA;AAAF,QAAUnE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAAhB;AACA,UAAMhC,UAAU,GAAG0F,YAAY,IAAIvJ,IAAI,CAAC+G,IAAL,CAAU5B,GAAV,EAAe,oBAAf,CAAnC;;AAEA,QAAI;AACA,YAAM5D,QAAQ,GAAGlB,cAAc,CAACO,OAAf,CAAuBO,UAAvB,EAAmC0C,UAAnC,CAAjB;AAEAF,MAAAA,uBAAuB,CAACxC,UAAD,EAAa0C,UAAb,EAAyBtC,QAAzB,CAAvB;AAEA,aAAO,IAAIhB,gBAAJ,CAAqB;AACxByJ,QAAAA,UAAU,EAAEjK,OAAO,CAACwB,QAAD,CADK;AAExBA,QAAAA,QAFwB;AAGxB0I,QAAAA,EAAE,EAAE9I,UAHoB;AAIxBoC,QAAAA,YAJwB;AAKxBgG,QAAAA;AALwB,OAArB,CAAP;AAOH,KAZD,CAYE,OAAOrF,KAAP,EAAc;AAEZ;AACA,UAAI/C,UAAU,KAAK,QAAnB,EAA6B;AACzBT,QAAAA,KAAK,CAAC,kBAAD,CAAL;AACA,eAAO,IAAIH,gBAAJ,CAAqB;AACxByJ,UAAAA,UAAU,EAAEjK,OAAO,CAAC,QAAD,CADK;AAExBwB,UAAAA,QAAQ,EAAExB,OAAO,CAACa,OAAR,CAAgB,QAAhB,CAFc;AAGxBqJ,UAAAA,EAAE,EAAE9I,UAHoB;AAIxBoC,UAAAA,YAJwB;AAKxBgG,UAAAA;AALwB,SAArB,CAAP;AAOH;;AAED7I,MAAAA,KAAK,CAAC,8CAAD,EAAiDS,UAAjD,EAA6DoC,YAA7D,CAAL;AACAW,MAAAA,KAAK,CAACpC,OAAN,GAAiB,0BAAyBX,UAAW,kBAAiBoC,YAAa,MAAKW,KAAK,CAACpC,OAAQ,EAAtG;AAEA,aAAO,IAAIvB,gBAAJ,CAAqB;AACxB2D,QAAAA,KADwB;AAExB+F,QAAAA,EAAE,EAAE9I,UAFoB;AAGxBoC,QAAAA,YAHwB;AAIxBgG,QAAAA;AAJwB,OAArB,CAAP;AAMH;AACJ;AAED;;;;;;;;;;AAQAQ,EAAAA,WAAW,CAACtE,IAAD,EAAO8D,YAAP,EAAqBhG,YAArB,EAAmC;AAC1C7C,IAAAA,KAAK,CAAC,2BAAD,EAA8B+E,IAA9B,EAAoC8D,YAApC,CAAL;AAEA,UAAM;AAAEtE,MAAAA,oBAAF;AAAwBI,MAAAA;AAAxB,QAAqDrE,gBAAgB,CAAC6E,GAAjB,CAAqB,IAArB,CAA3D;AACA,UAAMjC,OAAO,GAAGxD,MAAM,CAAC8J,oBAAP,CAA4BzE,IAA5B,EAAkC,eAAlC,CAAhB;AACA,UAAMwE,EAAE,GAAG7J,MAAM,CAACkK,gBAAP,CAAwB1G,OAAxB,EAAiC,eAAjC,CAAX;AACA,UAAMC,UAAU,GAAG7D,IAAI,CAAC+G,IAAL,CAAU1B,wBAAV,EAAoC,oBAApC,CAAnB;;AAEA,QAAII,IAAI,CAAC8E,KAAL,CAAW,MAAX,CAAJ,EAAwB;AACpB,YAAMrG,KAAK,GAAG1B,MAAM,CAACG,MAAP,CACV,IAAIC,KAAJ,CAAW,oCAAmC6C,IAAK,GAAnD,CADU,EAEV;AACIvD,QAAAA,eAAe,EAAE,kBADrB;AAEIC,QAAAA,WAAW,EAAE;AAAE0H,UAAAA,UAAU,EAAEjG;AAAd;AAFjB,OAFU,CAAd;AAQA,aAAO,IAAIrD,gBAAJ,CAAqB;AACxB2D,QAAAA,KADwB;AAExB+F,QAAAA,EAFwB;AAGxB1G,QAAAA,YAHwB;AAIxBgG,QAAAA;AAJwB,OAArB,CAAP;AAMH,KAvByC,CAyB1C;;;AACA,UAAM7E,MAAM,GACRO,oBAAoB,CAACY,GAArB,CAAyBjC,OAAzB,KACAqB,oBAAoB,CAACY,GAArB,CAAyBoE,EAAzB,CAFJ;;AAIA,QAAIvF,MAAJ,EAAY;AACR,aAAO,IAAInE,gBAAJ,CAAqB;AACxByJ,QAAAA,UAAU,EAAEvF,eAAe,CAACC,MAAD,CADH;AAExBnD,QAAAA,QAAQ,EAAEgI,YAFc;AAGxBU,QAAAA,EAHwB;AAIxB1G,QAAAA,YAJwB;AAKxBgG,QAAAA;AALwB,OAArB,CAAP;AAOH;;AAED,QAAIhI,QAAJ;AACA,QAAI2C,KAAJ;;AAEA,QAAI;AACA3C,MAAAA,QAAQ,GAAGlB,cAAc,CAACO,OAAf,CAAuBgD,OAAvB,EAAgCC,UAAhC,CAAX;AACH,KAFD,CAEE,OAAO2G,YAAP,EAAqB;AACnBtG,MAAAA,KAAK,GAAGsG,YAAR;AACA;;AACA,UAAItG,KAAK,IAAIA,KAAK,CAACrB,IAAN,KAAe,kBAA5B,EAAgD;AAC5CqB,QAAAA,KAAK,CAAChC,eAAN,GAAwB,gBAAxB;AACAgC,QAAAA,KAAK,CAAC/B,WAAN,GAAoB;AAChB0H,UAAAA,UAAU,EAAEjG,OADI;AAEhByB,UAAAA,wBAFgB;AAGhB9B,UAAAA;AAHgB,SAApB;AAKH;AACJ;;AAED,QAAIhC,QAAJ,EAAc;AACV,UAAI;AACAoC,QAAAA,uBAAuB,CAACC,OAAD,EAAUC,UAAV,EAAsBtC,QAAtB,CAAvB;AAEA,cAAMkJ,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;;AACA,cAAMC,gBAAgB,GAAG7K,OAAO,CAACwB,QAAD,CAAhC;;AAEAb,QAAAA,KAAK,CAAE,UAASa,QAAS,eAAcmJ,IAAI,CAACC,GAAL,KAAaF,SAAU,IAAzD,CAAL;AAEA,eAAO,IAAIlK,gBAAJ,CAAqB;AACxByJ,UAAAA,UAAU,EAAEvF,eAAe,CAACmG,gBAAD,CADH;AAExBrJ,UAAAA,QAFwB;AAGxB0I,UAAAA,EAHwB;AAIxB1G,UAAAA,YAJwB;AAKxBgG,UAAAA;AALwB,SAArB,CAAP;AAOH,OAfD,CAeE,OAAOsB,SAAP,EAAkB;AAChB3G,QAAAA,KAAK,GAAG2G,SAAR;AACH;AACJ;;AAEDnK,IAAAA,KAAK,CAAC,8CAAD,EAAiD+E,IAAjD,EAAuDlC,YAAvD,CAAL;AACAW,IAAAA,KAAK,CAACpC,OAAN,GAAiB,0BAAyB2D,IAAK,kBAAiBlC,YAAa,MAAKW,KAAK,CAACpC,OAAQ,EAAhG;AACA,WAAO,IAAIvB,gBAAJ,CAAqB;AACxB2D,MAAAA,KADwB;AAExB+F,MAAAA,EAFwB;AAGxB1G,MAAAA,YAHwB;AAIxBgG,MAAAA;AAJwB,KAArB,CAAP;AAMH;AAED;;;;;;;;;;AAQA,GAACH,4BAAD,CAA8Bb,OAA9B,EAAuChH,QAAvC,EAAiDkE,IAAjD,EAAuD;AACnD,SAAK,MAAMqF,QAAX,IAAuBtI,MAAM,CAACuI,IAAP,CAAYxC,OAAZ,CAAvB,EAA6C;AACzC,YAAM1D,UAAU,GACZ0D,OAAO,CAACuC,QAAD,CAAP,IACAvC,OAAO,CAACuC,QAAD,CAAP,CAAkBd,UADlB,IAEAzB,OAAO,CAACuC,QAAD,CAAP,CAAkBd,UAAlB,CAA6BnF,UAHjC;;AAKA,UAAI,CAACA,UAAL,EAAiB;AACb;AACH;;AAED,WAAK,MAAMmG,WAAX,IAA0BxI,MAAM,CAACuI,IAAP,CAAYlG,UAAZ,CAA1B,EAAmD;AAC/C,YAAImG,WAAW,CAAC5H,UAAZ,CAAuB,GAAvB,CAAJ,EAAiC;AAC7B,iBAAO,KAAK4D,0BAAL,CACH;AACIM,YAAAA,KAAK,EAAE,CAAE,IAAG0D,WAAY,EAAjB,CADX;AAEIvC,YAAAA,SAAS,EAAG,GAAEqC,QAAS,IAAGE,WAAY;AAF1C,WADG,EAKHzJ,QALG,EAMF,GAAEkE,IAAK,gBAAeqF,QAAS,IAAGE,WAAY,IAN5C,CAAP;AAQH;AACJ;AACJ;AACJ;;AAzpBoB;;AA4pBzBC,MAAM,CAACC,OAAP,GAAiB;AAAEnG,EAAAA;AAAF,CAAjB","sourcesContent":["/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst importFresh = require(\"import-fresh\");\nconst stripComments = require(\"strip-json-comments\");\nconst { validateConfigSchema } = require(\"../shared/config-validator\");\nconst naming = require(\"../shared/naming\");\nconst ModuleResolver = require(\"../shared/relative-module-resolver\");\nconst {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern,\n    OverrideTester\n} = require(\"./config-array\");\nconst debug = require(\"debug\")(\"eslint:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst eslintRecommendedPath = path.resolve(__dirname, \"../../conf/eslint-recommended.js\");\nconst eslintAllPath = path.resolve(__dirname, \"../../conf/eslint-all.js\");\nconst configFilenames = [\n    \".eslintrc.js\",\n    \".eslintrc.cjs\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n    return (\n        /^\\.{1,2}[/\\\\]/u.test(nameOrPath) ||\n        path.isAbsolute(nameOrPath)\n    );\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.safeLoad(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading legacy config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        const packageData = loadJSONConfigFile(filePath);\n\n        if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n            throw Object.assign(\n                new Error(\"package.json file doesn't have 'eslintConfig' field.\"),\n                { code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\" }\n            );\n        }\n\n        return packageData.eslintConfig;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n    debug(`Loading .eslintignore file: ${filePath}`);\n\n    try {\n        return readFile(filePath)\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n    } catch (e) {\n        debug(`Error reading .eslintignore file: ${filePath}`);\n        e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configMissingError(configName, importerName) {\n    return Object.assign(\n        new Error(`Failed to load config \"${configName}\" to extend from.`),\n        {\n            messageTemplate: \"extend-config-missing\",\n            messageData: { configName, importerName }\n        }\n    );\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n        case \".cjs\":\n            return loadJSConfigFile(filePath);\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                return loadPackageJSONConfigFile(filePath);\n            }\n            return loadJSONConfigFile(filePath);\n\n        case \".yaml\":\n        case \".yml\":\n            return loadYAMLConfigFile(filePath);\n\n        default:\n            return loadLegacyConfigFile(filePath);\n    }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n    /* istanbul ignore next */\n    if (debug.enabled) {\n        let nameAndVersion = null;\n\n        try {\n            const packageJsonPath = ModuleResolver.resolve(\n                `${request}/package.json`,\n                relativeTo\n            );\n            const { version = \"unknown\" } = require(packageJsonPath);\n\n            nameAndVersion = `${request}@${version}`;\n        } catch (error) {\n            debug(\"package.json was not found:\", error.message);\n            nameAndVersion = request;\n        }\n\n        debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n    }\n}\n\n/**\n * Concatenate two config data.\n * @param {IterableIterator<ConfigArrayElement>|null} elements The config elements.\n * @param {ConfigArray|null} parentConfigArray The parent config array.\n * @returns {ConfigArray} The concatenated config array.\n */\nfunction createConfigArray(elements, parentConfigArray) {\n    if (!elements) {\n        return parentConfigArray || new ConfigArray();\n    }\n    const configArray = new ConfigArray(...elements);\n\n    if (parentConfigArray && !configArray.isRoot()) {\n        configArray.unshift(...parentConfigArray);\n    }\n    return configArray;\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n    return {\n        configs: plugin.configs || {},\n        environments: plugin.environments || {},\n        processors: plugin.processors || {},\n        rules: plugin.rules || {}\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n\n    /**\n     * Initialize this instance.\n     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        cwd = process.cwd(),\n        resolvePluginsRelativeTo = cwd\n    } = {}) {\n        internalSlotsMap.set(this, { additionalPluginPool, cwd, resolvePluginsRelativeTo: path.resolve(cwd, resolvePluginsRelativeTo) });\n    }\n\n    /**\n     * Create `ConfigArray` instance from a config data.\n     * @param {ConfigData|null} configData The config data to create.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to this config data.\n     * @param {string} [options.name] The config name.\n     * @param {ConfigArray} [options.parent] The parent config array.\n     * @returns {ConfigArray} Loaded config.\n     */\n    create(configData, { filePath, name, parent } = {}) {\n        return createConfigArray(\n            configData\n                ? this._normalizeConfigData(configData, filePath, name)\n                : null,\n            parent\n        );\n    }\n\n    /**\n     * Load a config file.\n     * @param {string} filePath The path to a config file.\n     * @param {Object} [options] The options.\n     * @param {string} [options.name] The config name.\n     * @param {ConfigArray} [options.parent] The parent config array.\n     * @returns {ConfigArray} Loaded config.\n     */\n    loadFile(filePath, { name, parent } = {}) {\n        const { cwd } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, filePath);\n\n        return createConfigArray(\n            this._loadConfigData(absolutePath, name),\n            parent\n        );\n    }\n\n    /**\n     * Load the config file on a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {Object} [options] The options.\n     * @param {string} [options.name] The config name.\n     * @param {ConfigArray} [options.parent] The parent config array.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadInDirectory(directoryPath, { name, parent } = {}) {\n        const { cwd } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, directoryPath);\n\n        return createConfigArray(\n            this._loadConfigDataInDirectory(absolutePath, name),\n            parent\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file.\n     * @param {string} filePath The path to a `.eslintignore` file to load.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadESLintIgnore(filePath) {\n        const { cwd } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, filePath);\n        const name = path.relative(cwd, absolutePath);\n        const ignorePatterns = loadESLintIgnoreFile(absolutePath);\n\n        return createConfigArray(\n            this._normalizeESLintIgnoreData(ignorePatterns, absolutePath, name)\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file in the current working directory.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadDefaultESLintIgnore() {\n        const { cwd } = internalSlotsMap.get(this);\n        const eslintIgnorePath = path.resolve(cwd, \".eslintignore\");\n        const packageJsonPath = path.resolve(cwd, \"package.json\");\n\n        if (fs.existsSync(eslintIgnorePath)) {\n            return this.loadESLintIgnore(eslintIgnorePath);\n        }\n        if (fs.existsSync(packageJsonPath)) {\n            const data = loadJSONConfigFile(packageJsonPath);\n\n            if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n                if (!Array.isArray(data.eslintIgnore)) {\n                    throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n                }\n                return createConfigArray(\n                    this._normalizeESLintIgnoreData(\n                        data.eslintIgnore,\n                        packageJsonPath,\n                        \"eslintIgnore in package.json\"\n                    )\n                );\n            }\n        }\n\n        return new ConfigArray();\n    }\n\n    /**\n     * Load a given config file.\n     * @param {string} filePath The path to a config file.\n     * @param {string} name The config name.\n     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n     * @private\n     */\n    _loadConfigData(filePath, name) {\n        return this._normalizeConfigData(\n            loadConfigFile(filePath),\n            filePath,\n            name\n        );\n    }\n\n    /**\n     * Load the config file in a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {string} name The config name.\n     * @returns {IterableIterator<ConfigArrayElement> | null} Loaded config. `null` if any config doesn't exist.\n     * @private\n     */\n    _loadConfigDataInDirectory(directoryPath, name) {\n        for (const filename of configFilenames) {\n            const filePath = path.join(directoryPath, filename);\n\n            if (fs.existsSync(filePath)) {\n                let configData;\n\n                try {\n                    configData = loadConfigFile(filePath);\n                } catch (error) {\n                    if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n                        throw error;\n                    }\n                }\n\n                if (configData) {\n                    debug(`Config file found: ${filePath}`);\n                    return this._normalizeConfigData(configData, filePath, name);\n                }\n            }\n        }\n\n        debug(`Config file not found on ${directoryPath}`);\n        return null;\n    }\n\n    /**\n     * Normalize a given `.eslintignore` data to config array elements.\n     * @param {string[]} ignorePatterns The patterns to ignore files.\n     * @param {string|undefined} filePath The file path of this config.\n     * @param {string|undefined} name The name of this config.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeESLintIgnoreData(ignorePatterns, filePath, name) {\n        const elements = this._normalizeObjectConfigData(\n            { ignorePatterns },\n            filePath,\n            name\n        );\n\n        // Set `ignorePattern.loose` flag for backward compatibility.\n        for (const element of elements) {\n            if (element.ignorePattern) {\n                element.ignorePattern.loose = true;\n            }\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {string|undefined} providedFilePath The file path of this config.\n     * @param {string|undefined} providedName The name of this config.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _normalizeConfigData(configData, providedFilePath, providedName) {\n        const { cwd } = internalSlotsMap.get(this);\n        const filePath = providedFilePath\n            ? path.resolve(cwd, providedFilePath)\n            : \"\";\n        const name = providedName || (filePath && path.relative(cwd, filePath));\n\n        validateConfigSchema(configData, name || filePath);\n\n        return this._normalizeObjectConfigData(configData, filePath, name);\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n     * @param {string} filePath The file path of this config.\n     * @param {string} name The name of this config.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigData(configData, filePath, name) {\n        const { cwd } = internalSlotsMap.get(this);\n        const { files, excludedFiles, ...configBody } = configData;\n        const basePath = filePath ? path.dirname(filePath) : cwd;\n        const criteria = OverrideTester.create(files, excludedFiles, basePath);\n        const elements =\n            this._normalizeObjectConfigDataBody(configBody, filePath, name);\n\n        // Apply the criteria to every element.\n        for (const element of elements) {\n\n            // Adopt the base path of the entry file (the outermost base path).\n            if (element.criteria) {\n                element.criteria.basePath = basePath;\n            }\n            if (element.ignorePattern) {\n                element.ignorePattern.basePath = basePath;\n            }\n\n            /*\n             * Merge the criteria; this is for only file extension processors in\n             * `overrides` section for now.\n             */\n            element.criteria = OverrideTester.and(criteria, element.criteria);\n\n            /*\n             * Remove `root` property to ignore `root` settings which came from\n             * `extends` in `overrides`.\n             */\n            if (element.criteria) {\n                element.root = void 0;\n            }\n\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {string} filePath The file path of this config.\n     * @param {string} name The name of this config.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigDataBody(\n        {\n            env,\n            extends: extend,\n            globals,\n            ignorePatterns,\n            noInlineConfig,\n            parser: parserName,\n            parserOptions,\n            plugins: pluginList,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings,\n            overrides: overrideList = []\n        },\n        filePath,\n        name\n    ) {\n        const extendList = Array.isArray(extend) ? extend : [extend];\n        const ignorePattern = ignorePatterns && new IgnorePattern(\n            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],\n            filePath ? path.dirname(filePath) : internalSlotsMap.get(this).cwd\n        );\n\n        // Flatten `extends`.\n        for (const extendName of extendList.filter(Boolean)) {\n            yield* this._loadExtends(extendName, filePath, name);\n        }\n\n        // Load parser & plugins.\n        const parser =\n            parserName && this._loadParser(parserName, filePath, name);\n        const plugins =\n            pluginList && this._loadPlugins(pluginList, filePath, name);\n\n        // Yield pseudo config data for file extension processors.\n        if (plugins) {\n            yield* this._takeFileExtensionProcessors(plugins, filePath, name);\n        }\n\n        // Yield the config data except `extends` and `overrides`.\n        yield {\n\n            // Debug information.\n            name,\n            filePath,\n\n            // Config data.\n            criteria: null,\n            env,\n            globals,\n            ignorePattern,\n            noInlineConfig,\n            parser,\n            parserOptions,\n            plugins,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings\n        };\n\n        // Flatten `overries`.\n        for (let i = 0; i < overrideList.length; ++i) {\n            yield* this._normalizeObjectConfigData(\n                overrideList[i],\n                filePath,\n                `${name}#overrides[${i}]`\n            );\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {string} importerPath The file path which has the `extends` property.\n     * @param {string} importerName The name of the config which has the `extends` property.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtends(extendName, importerPath, importerName) {\n        debug(\"Loading {extends:%j} relative to %s\", extendName, importerPath);\n        try {\n            if (extendName.startsWith(\"eslint:\")) {\n                return this._loadExtendedBuiltInConfig(\n                    extendName,\n                    importerName\n                );\n            }\n            if (extendName.startsWith(\"plugin:\")) {\n                return this._loadExtendedPluginConfig(\n                    extendName,\n                    importerPath,\n                    importerName\n                );\n            }\n            return this._loadExtendedShareableConfig(\n                extendName,\n                importerPath,\n                importerName\n            );\n        } catch (error) {\n            error.message += `\\nReferenced from: ${importerPath || importerName}`;\n            throw error;\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {string} importerName The name of the config which has the `extends` property.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedBuiltInConfig(extendName, importerName) {\n        const name = `${importerName} » ${extendName}`;\n\n        if (extendName === \"eslint:recommended\") {\n            return this._loadConfigData(eslintRecommendedPath, name);\n        }\n        if (extendName === \"eslint:all\") {\n            return this._loadConfigData(eslintAllPath, name);\n        }\n\n        throw configMissingError(extendName, importerName);\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {string} importerPath The file path which has the `extends` property.\n     * @param {string} importerName The name of the config which has the `extends` property.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedPluginConfig(extendName, importerPath, importerName) {\n        const slashIndex = extendName.lastIndexOf(\"/\");\n        const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n        const configName = extendName.slice(slashIndex + 1);\n\n        if (isFilePath(pluginName)) {\n            throw new Error(\"'extends' cannot use a file path for plugins.\");\n        }\n\n        const plugin = this._loadPlugin(pluginName, importerPath, importerName);\n        const configData =\n            plugin.definition &&\n            plugin.definition.configs[configName];\n\n        if (configData) {\n            return this._normalizeConfigData(\n                configData,\n                plugin.filePath,\n                `${importerName} » plugin:${plugin.id}/${configName}`\n            );\n        }\n\n        throw plugin.error || configMissingError(extendName, importerPath);\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {string} importerPath The file path which has the `extends` property.\n     * @param {string} importerName The name of the config which has the `extends` property.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedShareableConfig(extendName, importerPath, importerName) {\n        const { cwd } = internalSlotsMap.get(this);\n        const relativeTo = importerPath || path.join(cwd, \"__placeholder__.js\");\n        let request;\n\n        if (isFilePath(extendName)) {\n            request = extendName;\n        } else if (extendName.startsWith(\".\")) {\n            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n        } else {\n            request = naming.normalizePackageName(\n                extendName,\n                \"eslint-config\"\n            );\n        }\n\n        let filePath;\n\n        try {\n            filePath = ModuleResolver.resolve(request, relativeTo);\n        } catch (error) {\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                throw configMissingError(extendName, importerPath);\n            }\n            throw error;\n        }\n\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        return this._loadConfigData(filePath, `${importerName} » ${request}`);\n    }\n\n    /**\n     * Load given plugins.\n     * @param {string[]} names The plugin names to load.\n     * @param {string} importerPath The path to a config file that imports it. This is just a debug info.\n     * @param {string} importerName The name of a config file that imports it. This is just a debug info.\n     * @returns {Record<string,DependentPlugin>} The loaded parser.\n     * @private\n     */\n    _loadPlugins(names, importerPath, importerName) {\n        return names.reduce((map, name) => {\n            if (isFilePath(name)) {\n                throw new Error(\"Plugins array cannot includes file paths.\");\n            }\n            const plugin = this._loadPlugin(name, importerPath, importerName);\n\n            map[plugin.id] = plugin;\n\n            return map;\n        }, {});\n    }\n\n    /**\n     * Load a given parser.\n     * @param {string} nameOrPath The package name or the path to a parser file.\n     * @param {string} importerPath The path to a config file that imports it.\n     * @param {string} importerName The name of a config file that imports it. This is just a debug info.\n     * @returns {DependentParser} The loaded parser.\n     */\n    _loadParser(nameOrPath, importerPath, importerName) {\n        debug(\"Loading parser %j from %s\", nameOrPath, importerPath);\n\n        const { cwd } = internalSlotsMap.get(this);\n        const relativeTo = importerPath || path.join(cwd, \"__placeholder__.js\");\n\n        try {\n            const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);\n\n            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n\n            return new ConfigDependency({\n                definition: require(filePath),\n                filePath,\n                id: nameOrPath,\n                importerName,\n                importerPath\n            });\n        } catch (error) {\n\n            // If the parser name is \"espree\", load the espree of ESLint.\n            if (nameOrPath === \"espree\") {\n                debug(\"Fallback espree.\");\n                return new ConfigDependency({\n                    definition: require(\"espree\"),\n                    filePath: require.resolve(\"espree\"),\n                    id: nameOrPath,\n                    importerName,\n                    importerPath\n                });\n            }\n\n            debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, importerName);\n            error.message = `Failed to load parser '${nameOrPath}' declared in '${importerName}': ${error.message}`;\n\n            return new ConfigDependency({\n                error,\n                id: nameOrPath,\n                importerName,\n                importerPath\n            });\n        }\n    }\n\n    /**\n     * Load a given plugin.\n     * @param {string} name The plugin name to load.\n     * @param {string} importerPath The path to a config file that imports it. This is just a debug info.\n     * @param {string} importerName The name of a config file that imports it. This is just a debug info.\n     * @returns {DependentPlugin} The loaded plugin.\n     * @private\n     */\n    _loadPlugin(name, importerPath, importerName) {\n        debug(\"Loading plugin %j from %s\", name, importerPath);\n\n        const { additionalPluginPool, resolvePluginsRelativeTo } = internalSlotsMap.get(this);\n        const request = naming.normalizePackageName(name, \"eslint-plugin\");\n        const id = naming.getShorthandName(request, \"eslint-plugin\");\n        const relativeTo = path.join(resolvePluginsRelativeTo, \"__placeholder__.js\");\n\n        if (name.match(/\\s+/u)) {\n            const error = Object.assign(\n                new Error(`Whitespace found in plugin name '${name}'`),\n                {\n                    messageTemplate: \"whitespace-found\",\n                    messageData: { pluginName: request }\n                }\n            );\n\n            return new ConfigDependency({\n                error,\n                id,\n                importerName,\n                importerPath\n            });\n        }\n\n        // Check for additional pool.\n        const plugin =\n            additionalPluginPool.get(request) ||\n            additionalPluginPool.get(id);\n\n        if (plugin) {\n            return new ConfigDependency({\n                definition: normalizePlugin(plugin),\n                filePath: importerPath,\n                id,\n                importerName,\n                importerPath\n            });\n        }\n\n        let filePath;\n        let error;\n\n        try {\n            filePath = ModuleResolver.resolve(request, relativeTo);\n        } catch (resolveError) {\n            error = resolveError;\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                error.messageTemplate = \"plugin-missing\";\n                error.messageData = {\n                    pluginName: request,\n                    resolvePluginsRelativeTo,\n                    importerName\n                };\n            }\n        }\n\n        if (filePath) {\n            try {\n                writeDebugLogForLoading(request, relativeTo, filePath);\n\n                const startTime = Date.now();\n                const pluginDefinition = require(filePath);\n\n                debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n\n                return new ConfigDependency({\n                    definition: normalizePlugin(pluginDefinition),\n                    filePath,\n                    id,\n                    importerName,\n                    importerPath\n                });\n            } catch (loadError) {\n                error = loadError;\n            }\n        }\n\n        debug(\"Failed to load plugin '%s' declared in '%s'.\", name, importerName);\n        error.message = `Failed to load plugin '${name}' declared in '${importerName}': ${error.message}`;\n        return new ConfigDependency({\n            error,\n            id,\n            importerName,\n            importerPath\n        });\n    }\n\n    /**\n     * Take file expression processors as config array elements.\n     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n     * @param {string} filePath The file path of this config.\n     * @param {string} name The name of this config.\n     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n     * @private\n     */\n    *_takeFileExtensionProcessors(plugins, filePath, name) {\n        for (const pluginId of Object.keys(plugins)) {\n            const processors =\n                plugins[pluginId] &&\n                plugins[pluginId].definition &&\n                plugins[pluginId].definition.processors;\n\n            if (!processors) {\n                continue;\n            }\n\n            for (const processorId of Object.keys(processors)) {\n                if (processorId.startsWith(\".\")) {\n                    yield* this._normalizeObjectConfigData(\n                        {\n                            files: [`*${processorId}`],\n                            processor: `${pluginId}/${processorId}`\n                        },\n                        filePath,\n                        `${name}#processors[\"${pluginId}/${processorId}\"]`\n                    );\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = { ConfigArrayFactory };\n"]},"metadata":{},"sourceType":"script"}