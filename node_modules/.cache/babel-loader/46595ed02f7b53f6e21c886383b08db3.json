{"ast":null,"code":"/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst ruleFixer = require(\"./rule-fixer\");\n\nconst interpolate = require(\"./interpolate\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\n\n\nfunction normalizeMultiArgReportCall(...args) {\n  // If there is one argument, it is considered to be a new-style call already.\n  if (args.length === 1) {\n    // Shallow clone the object to avoid surprises if reusing the descriptor\n    return Object.assign({}, args[0]);\n  } // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n\n\n  if (typeof args[1] === \"string\") {\n    return {\n      node: args[0],\n      message: args[1],\n      data: args[2],\n      fix: args[3]\n    };\n  } // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n\n\n  return {\n    node: args[0],\n    loc: args[1],\n    message: args[2],\n    data: args[3],\n    fix: args[4]\n  };\n}\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\n\n\nfunction assertValidNodeInfo(descriptor) {\n  if (descriptor.node) {\n    assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n  } else {\n    assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n  }\n}\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\n\n\nfunction normalizeReportLoc(descriptor) {\n  if (descriptor.loc) {\n    if (descriptor.loc.start) {\n      return descriptor.loc;\n    }\n\n    return {\n      start: descriptor.loc,\n      end: null\n    };\n  }\n\n  return descriptor.node.loc;\n}\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\n\n\nfunction compareFixesByRange(a, b) {\n  return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\n\n\nfunction mergeFixes(fixes, sourceCode) {\n  if (fixes.length === 0) {\n    return null;\n  }\n\n  if (fixes.length === 1) {\n    return fixes[0];\n  }\n\n  fixes.sort(compareFixesByRange);\n  const originalText = sourceCode.text;\n  const start = fixes[0].range[0];\n  const end = fixes[fixes.length - 1].range[1];\n  let text = \"\";\n  let lastPos = Number.MIN_SAFE_INTEGER;\n\n  for (const fix of fixes) {\n    assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n    if (fix.range[0] >= 0) {\n      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n    }\n\n    text += fix.text;\n    lastPos = fix.range[1];\n  }\n\n  text += originalText.slice(Math.max(0, start, lastPos), end);\n  return {\n    range: [start, end],\n    text\n  };\n}\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\n\n\nfunction normalizeFixes(descriptor, sourceCode) {\n  if (typeof descriptor.fix !== \"function\") {\n    return null;\n  } // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n\n\n  const fix = descriptor.fix(ruleFixer); // Merge to one.\n\n  if (fix && Symbol.iterator in fix) {\n    return mergeFixes(Array.from(fix), sourceCode);\n  }\n\n  return fix;\n}\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\n\n\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n    return [];\n  }\n\n  return descriptor.suggest.map(suggestInfo => {\n    const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n    return { ...suggestInfo,\n      desc: interpolate(computedDesc, suggestInfo.data),\n      fix: normalizeFixes(suggestInfo, sourceCode)\n    };\n  });\n}\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\n\nfunction createProblem(options) {\n  const problem = {\n    ruleId: options.ruleId,\n    severity: options.severity,\n    message: options.message,\n    line: options.loc.start.line,\n    column: options.loc.start.column + 1,\n    nodeType: options.node && options.node.type || null\n  };\n  /*\n   * If this isn’t in the conditional, some of the tests fail\n   * because `messageId` is present in the problem object\n   */\n\n  if (options.messageId) {\n    problem.messageId = options.messageId;\n  }\n\n  if (options.loc.end) {\n    problem.endLine = options.loc.end.line;\n    problem.endColumn = options.loc.end.column + 1;\n  }\n\n  if (options.fix) {\n    problem.fix = options.fix;\n  }\n\n  if (options.suggestions && options.suggestions.length > 0) {\n    problem.suggestions = options.suggestions;\n  }\n\n  return problem;\n}\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\n\n\nfunction validateSuggestions(suggest, messages) {\n  if (suggest && Array.isArray(suggest)) {\n    suggest.forEach(suggestion => {\n      if (suggestion.messageId) {\n        const {\n          messageId\n        } = suggestion;\n\n        if (!messages) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n        }\n\n        if (!messages[messageId]) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n        }\n\n        if (suggestion.desc) {\n          throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n        }\n      } else if (!suggestion.desc) {\n        throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n      }\n\n      if (typeof suggestion.fix !== \"function\") {\n        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n      }\n    });\n  }\n}\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\n\nmodule.exports = function createReportTranslator(metadata) {\n  /*\n   * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n   * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n   * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n   * majority of rules don't report any problems for a given file).\n   */\n  return (...args) => {\n    const descriptor = normalizeMultiArgReportCall(...args);\n    const messages = metadata.messageIds;\n    assertValidNodeInfo(descriptor);\n    let computedMessage;\n\n    if (descriptor.messageId) {\n      if (!messages) {\n        throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n      }\n\n      const id = descriptor.messageId;\n\n      if (descriptor.message) {\n        throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n      }\n\n      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n      }\n\n      computedMessage = messages[id];\n    } else if (descriptor.message) {\n      computedMessage = descriptor.message;\n    } else {\n      throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n    }\n\n    validateSuggestions(descriptor.suggest, messages);\n    return createProblem({\n      ruleId: metadata.ruleId,\n      severity: metadata.severity,\n      node: descriptor.node,\n      message: interpolate(computedMessage, descriptor.data),\n      messageId: descriptor.messageId,\n      loc: normalizeReportLoc(descriptor),\n      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n    });\n  };\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/report-translator.js"],"names":["assert","require","ruleFixer","interpolate","normalizeMultiArgReportCall","args","length","Object","assign","node","message","data","fix","loc","assertValidNodeInfo","descriptor","normalizeReportLoc","start","end","compareFixesByRange","a","b","range","mergeFixes","fixes","sourceCode","sort","originalText","text","lastPos","Number","MIN_SAFE_INTEGER","slice","Math","max","normalizeFixes","Symbol","iterator","Array","from","mapSuggestions","messages","suggest","isArray","map","suggestInfo","computedDesc","desc","messageId","createProblem","options","problem","ruleId","severity","line","column","nodeType","type","endLine","endColumn","suggestions","validateSuggestions","forEach","suggestion","TypeError","JSON","stringify","module","exports","createReportTranslator","metadata","messageIds","computedMessage","id","prototype","hasOwnProperty","call","disableFixes"],"mappings":"AAAA;;;;AAKA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B,C,CAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;;AAGA;;;;;;;AAKA,SAASG,2BAAT,CAAqC,GAAGC,IAAxC,EAA8C;AAE1C;AACA,MAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AAEnB;AACA,WAAOC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,IAAI,CAAC,CAAD,CAAtB,CAAP;AACH,GAPyC,CAS1C;;;AACA,MAAI,OAAOA,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAvB,EAAiC;AAC7B,WAAO;AACHI,MAAAA,IAAI,EAAEJ,IAAI,CAAC,CAAD,CADP;AAEHK,MAAAA,OAAO,EAAEL,IAAI,CAAC,CAAD,CAFV;AAGHM,MAAAA,IAAI,EAAEN,IAAI,CAAC,CAAD,CAHP;AAIHO,MAAAA,GAAG,EAAEP,IAAI,CAAC,CAAD;AAJN,KAAP;AAMH,GAjByC,CAmB1C;;;AACA,SAAO;AACHI,IAAAA,IAAI,EAAEJ,IAAI,CAAC,CAAD,CADP;AAEHQ,IAAAA,GAAG,EAAER,IAAI,CAAC,CAAD,CAFN;AAGHK,IAAAA,OAAO,EAAEL,IAAI,CAAC,CAAD,CAHV;AAIHM,IAAAA,IAAI,EAAEN,IAAI,CAAC,CAAD,CAJP;AAKHO,IAAAA,GAAG,EAAEP,IAAI,CAAC,CAAD;AALN,GAAP;AAOH;AAED;;;;;;;;AAMA,SAASS,mBAAT,CAA6BC,UAA7B,EAAyC;AACrC,MAAIA,UAAU,CAACN,IAAf,EAAqB;AACjBT,IAAAA,MAAM,CAAC,OAAOe,UAAU,CAACN,IAAlB,KAA2B,QAA5B,EAAsC,wBAAtC,CAAN;AACH,GAFD,MAEO;AACHT,IAAAA,MAAM,CAACe,UAAU,CAACF,GAAZ,EAAiB,wEAAjB,CAAN;AACH;AACJ;AAED;;;;;;;;AAMA,SAASG,kBAAT,CAA4BD,UAA5B,EAAwC;AACpC,MAAIA,UAAU,CAACF,GAAf,EAAoB;AAChB,QAAIE,UAAU,CAACF,GAAX,CAAeI,KAAnB,EAA0B;AACtB,aAAOF,UAAU,CAACF,GAAlB;AACH;;AACD,WAAO;AAAEI,MAAAA,KAAK,EAAEF,UAAU,CAACF,GAApB;AAAyBK,MAAAA,GAAG,EAAE;AAA9B,KAAP;AACH;;AACD,SAAOH,UAAU,CAACN,IAAX,CAAgBI,GAAvB;AACH;AAED;;;;;;;;;AAOA,SAASM,mBAAT,CAA6BC,CAA7B,EAAgCC,CAAhC,EAAmC;AAC/B,SAAOD,CAAC,CAACE,KAAF,CAAQ,CAAR,IAAaD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAb,IAA2BF,CAAC,CAACE,KAAF,CAAQ,CAAR,IAAaD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAA/C;AACH;AAED;;;;;;;;AAMA,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,UAA3B,EAAuC;AACnC,MAAID,KAAK,CAAClB,MAAN,KAAiB,CAArB,EAAwB;AACpB,WAAO,IAAP;AACH;;AACD,MAAIkB,KAAK,CAAClB,MAAN,KAAiB,CAArB,EAAwB;AACpB,WAAOkB,KAAK,CAAC,CAAD,CAAZ;AACH;;AAEDA,EAAAA,KAAK,CAACE,IAAN,CAAWP,mBAAX;AAEA,QAAMQ,YAAY,GAAGF,UAAU,CAACG,IAAhC;AACA,QAAMX,KAAK,GAAGO,KAAK,CAAC,CAAD,CAAL,CAASF,KAAT,CAAe,CAAf,CAAd;AACA,QAAMJ,GAAG,GAAGM,KAAK,CAACA,KAAK,CAAClB,MAAN,GAAe,CAAhB,CAAL,CAAwBgB,KAAxB,CAA8B,CAA9B,CAAZ;AACA,MAAIM,IAAI,GAAG,EAAX;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,gBAArB;;AAEA,OAAK,MAAMnB,GAAX,IAAkBY,KAAlB,EAAyB;AACrBxB,IAAAA,MAAM,CAACY,GAAG,CAACU,KAAJ,CAAU,CAAV,KAAgBO,OAAjB,EAA0B,iDAA1B,CAAN;;AAEA,QAAIjB,GAAG,CAACU,KAAJ,CAAU,CAAV,KAAgB,CAApB,EAAuB;AACnBM,MAAAA,IAAI,IAAID,YAAY,CAACK,KAAb,CAAmBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYjB,KAAZ,EAAmBY,OAAnB,CAAnB,EAAgDjB,GAAG,CAACU,KAAJ,CAAU,CAAV,CAAhD,CAAR;AACH;;AACDM,IAAAA,IAAI,IAAIhB,GAAG,CAACgB,IAAZ;AACAC,IAAAA,OAAO,GAAGjB,GAAG,CAACU,KAAJ,CAAU,CAAV,CAAV;AACH;;AACDM,EAAAA,IAAI,IAAID,YAAY,CAACK,KAAb,CAAmBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYjB,KAAZ,EAAmBY,OAAnB,CAAnB,EAAgDX,GAAhD,CAAR;AAEA,SAAO;AAAEI,IAAAA,KAAK,EAAE,CAACL,KAAD,EAAQC,GAAR,CAAT;AAAuBU,IAAAA;AAAvB,GAAP;AACH;AAED;;;;;;;;;AAOA,SAASO,cAAT,CAAwBpB,UAAxB,EAAoCU,UAApC,EAAgD;AAC5C,MAAI,OAAOV,UAAU,CAACH,GAAlB,KAA0B,UAA9B,EAA0C;AACtC,WAAO,IAAP;AACH,GAH2C,CAK5C;;;AACA,QAAMA,GAAG,GAAGG,UAAU,CAACH,GAAX,CAAeV,SAAf,CAAZ,CAN4C,CAQ5C;;AACA,MAAIU,GAAG,IAAIwB,MAAM,CAACC,QAAP,IAAmBzB,GAA9B,EAAmC;AAC/B,WAAOW,UAAU,CAACe,KAAK,CAACC,IAAN,CAAW3B,GAAX,CAAD,EAAkBa,UAAlB,CAAjB;AACH;;AACD,SAAOb,GAAP;AACH;AAED;;;;;;;;;AAOA,SAAS4B,cAAT,CAAwBzB,UAAxB,EAAoCU,UAApC,EAAgDgB,QAAhD,EAA0D;AACtD,MAAI,CAAC1B,UAAU,CAAC2B,OAAZ,IAAuB,CAACJ,KAAK,CAACK,OAAN,CAAc5B,UAAU,CAAC2B,OAAzB,CAA5B,EAA+D;AAC3D,WAAO,EAAP;AACH;;AAED,SAAO3B,UAAU,CAAC2B,OAAX,CAAmBE,GAAnB,CAAuBC,WAAW,IAAI;AACzC,UAAMC,YAAY,GAAGD,WAAW,CAACE,IAAZ,IAAoBN,QAAQ,CAACI,WAAW,CAACG,SAAb,CAAjD;AAEA,WAAO,EACH,GAAGH,WADA;AAEHE,MAAAA,IAAI,EAAE5C,WAAW,CAAC2C,YAAD,EAAeD,WAAW,CAAClC,IAA3B,CAFd;AAGHC,MAAAA,GAAG,EAAEuB,cAAc,CAACU,WAAD,EAAcpB,UAAd;AAHhB,KAAP;AAKH,GARM,CAAP;AASH;AAED;;;;;;;;;;;;;;;AAaA,SAASwB,aAAT,CAAuBC,OAAvB,EAAgC;AAC5B,QAAMC,OAAO,GAAG;AACZC,IAAAA,MAAM,EAAEF,OAAO,CAACE,MADJ;AAEZC,IAAAA,QAAQ,EAAEH,OAAO,CAACG,QAFN;AAGZ3C,IAAAA,OAAO,EAAEwC,OAAO,CAACxC,OAHL;AAIZ4C,IAAAA,IAAI,EAAEJ,OAAO,CAACrC,GAAR,CAAYI,KAAZ,CAAkBqC,IAJZ;AAKZC,IAAAA,MAAM,EAAEL,OAAO,CAACrC,GAAR,CAAYI,KAAZ,CAAkBsC,MAAlB,GAA2B,CALvB;AAMZC,IAAAA,QAAQ,EAAEN,OAAO,CAACzC,IAAR,IAAgByC,OAAO,CAACzC,IAAR,CAAagD,IAA7B,IAAqC;AANnC,GAAhB;AASA;;;;;AAIA,MAAIP,OAAO,CAACF,SAAZ,EAAuB;AACnBG,IAAAA,OAAO,CAACH,SAAR,GAAoBE,OAAO,CAACF,SAA5B;AACH;;AAED,MAAIE,OAAO,CAACrC,GAAR,CAAYK,GAAhB,EAAqB;AACjBiC,IAAAA,OAAO,CAACO,OAAR,GAAkBR,OAAO,CAACrC,GAAR,CAAYK,GAAZ,CAAgBoC,IAAlC;AACAH,IAAAA,OAAO,CAACQ,SAAR,GAAoBT,OAAO,CAACrC,GAAR,CAAYK,GAAZ,CAAgBqC,MAAhB,GAAyB,CAA7C;AACH;;AAED,MAAIL,OAAO,CAACtC,GAAZ,EAAiB;AACbuC,IAAAA,OAAO,CAACvC,GAAR,GAAcsC,OAAO,CAACtC,GAAtB;AACH;;AAED,MAAIsC,OAAO,CAACU,WAAR,IAAuBV,OAAO,CAACU,WAAR,CAAoBtD,MAApB,GAA6B,CAAxD,EAA2D;AACvD6C,IAAAA,OAAO,CAACS,WAAR,GAAsBV,OAAO,CAACU,WAA9B;AACH;;AAED,SAAOT,OAAP;AACH;AAED;;;;;;;;AAMA,SAASU,mBAAT,CAA6BnB,OAA7B,EAAsCD,QAAtC,EAAgD;AAC5C,MAAIC,OAAO,IAAIJ,KAAK,CAACK,OAAN,CAAcD,OAAd,CAAf,EAAuC;AACnCA,IAAAA,OAAO,CAACoB,OAAR,CAAgBC,UAAU,IAAI;AAC1B,UAAIA,UAAU,CAACf,SAAf,EAA0B;AACtB,cAAM;AAAEA,UAAAA;AAAF,YAAgBe,UAAtB;;AAEA,YAAI,CAACtB,QAAL,EAAe;AACX,gBAAM,IAAIuB,SAAJ,CAAe,mEAAkEhB,SAAU,uDAA3F,CAAN;AACH;;AAED,YAAI,CAACP,QAAQ,CAACO,SAAD,CAAb,EAA0B;AACtB,gBAAM,IAAIgB,SAAJ,CAAe,mEAAkEhB,SAAU,oDAAmDiB,IAAI,CAACC,SAAL,CAAezB,QAAf,EAAyB,IAAzB,EAA+B,CAA/B,CAAkC,EAAhL,CAAN;AACH;;AAED,YAAIsB,UAAU,CAAChB,IAAf,EAAqB;AACjB,gBAAM,IAAIiB,SAAJ,CAAc,oHAAd,CAAN;AACH;AACJ,OAdD,MAcO,IAAI,CAACD,UAAU,CAAChB,IAAhB,EAAsB;AACzB,cAAM,IAAIiB,SAAJ,CAAc,gGAAd,CAAN;AACH;;AAED,UAAI,OAAOD,UAAU,CAACnD,GAAlB,KAA0B,UAA9B,EAA0C;AACtC,cAAM,IAAIoD,SAAJ,CAAe,8EAA6ED,UAAW,EAAvG,CAAN;AACH;AACJ,KAtBD;AAuBH;AACJ;AAED;;;;;;;;;AAQAI,MAAM,CAACC,OAAP,GAAiB,SAASC,sBAAT,CAAgCC,QAAhC,EAA0C;AAEvD;;;;;;AAMA,SAAO,CAAC,GAAGjE,IAAJ,KAAa;AAChB,UAAMU,UAAU,GAAGX,2BAA2B,CAAC,GAAGC,IAAJ,CAA9C;AACA,UAAMoC,QAAQ,GAAG6B,QAAQ,CAACC,UAA1B;AAEAzD,IAAAA,mBAAmB,CAACC,UAAD,CAAnB;AAEA,QAAIyD,eAAJ;;AAEA,QAAIzD,UAAU,CAACiC,SAAf,EAA0B;AACtB,UAAI,CAACP,QAAL,EAAe;AACX,cAAM,IAAIuB,SAAJ,CAAc,8FAAd,CAAN;AACH;;AACD,YAAMS,EAAE,GAAG1D,UAAU,CAACiC,SAAtB;;AAEA,UAAIjC,UAAU,CAACL,OAAf,EAAwB;AACpB,cAAM,IAAIsD,SAAJ,CAAc,+EAAd,CAAN;AACH;;AACD,UAAI,CAACvB,QAAD,IAAa,CAAClC,MAAM,CAACmE,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCnC,QAArC,EAA+CgC,EAA/C,CAAlB,EAAsE;AAClE,cAAM,IAAIT,SAAJ,CAAe,gDAA+CS,EAAG,oDAAmDR,IAAI,CAACC,SAAL,CAAezB,QAAf,EAAyB,IAAzB,EAA+B,CAA/B,CAAkC,EAAtJ,CAAN;AACH;;AACD+B,MAAAA,eAAe,GAAG/B,QAAQ,CAACgC,EAAD,CAA1B;AACH,KAbD,MAaO,IAAI1D,UAAU,CAACL,OAAf,EAAwB;AAC3B8D,MAAAA,eAAe,GAAGzD,UAAU,CAACL,OAA7B;AACH,KAFM,MAEA;AACH,YAAM,IAAIsD,SAAJ,CAAc,gGAAd,CAAN;AACH;;AAEDH,IAAAA,mBAAmB,CAAC9C,UAAU,CAAC2B,OAAZ,EAAqBD,QAArB,CAAnB;AAEA,WAAOQ,aAAa,CAAC;AACjBG,MAAAA,MAAM,EAAEkB,QAAQ,CAAClB,MADA;AAEjBC,MAAAA,QAAQ,EAAEiB,QAAQ,CAACjB,QAFF;AAGjB5C,MAAAA,IAAI,EAAEM,UAAU,CAACN,IAHA;AAIjBC,MAAAA,OAAO,EAAEP,WAAW,CAACqE,eAAD,EAAkBzD,UAAU,CAACJ,IAA7B,CAJH;AAKjBqC,MAAAA,SAAS,EAAEjC,UAAU,CAACiC,SALL;AAMjBnC,MAAAA,GAAG,EAAEG,kBAAkB,CAACD,UAAD,CANN;AAOjBH,MAAAA,GAAG,EAAE0D,QAAQ,CAACO,YAAT,GAAwB,IAAxB,GAA+B1C,cAAc,CAACpB,UAAD,EAAauD,QAAQ,CAAC7C,UAAtB,CAPjC;AAQjBmC,MAAAA,WAAW,EAAEU,QAAQ,CAACO,YAAT,GAAwB,EAAxB,GAA6BrC,cAAc,CAACzB,UAAD,EAAauD,QAAQ,CAAC7C,UAAtB,EAAkCgB,QAAlC;AARvC,KAAD,CAApB;AAUH,GAvCD;AAwCH,CAhDD","sourcesContent":["/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./rule-fixer\");\nconst interpolate = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (args.length === 1) {\n\n        // Shallow clone the object to avoid surprises if reusing the descriptor\n        return Object.assign({}, args[0]);\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof args[1] === \"string\") {\n        return {\n            node: args[0],\n            message: args[1],\n            data: args[2],\n            fix: args[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: args[0],\n        loc: args[1],\n        message: args[2],\n        data: args[3],\n        fix: args[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc) {\n        if (descriptor.loc.start) {\n            return descriptor.loc;\n        }\n        return { start: descriptor.loc, end: null };\n    }\n    return descriptor.node.loc;\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return fixes[0];\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes[fixes.length - 1].range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n    return fix;\n}\n\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n        return [];\n    }\n\n    return descriptor.suggest.map(suggestInfo => {\n        const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n\n        return {\n            ...suggestInfo,\n            desc: interpolate(computedDesc, suggestInfo.data),\n            fix: normalizeFixes(suggestInfo, sourceCode)\n        };\n    });\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\nfunction createProblem(options) {\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line,\n        column: options.loc.start.column + 1,\n        nodeType: options.node && options.node.type || null\n    };\n\n    /*\n     * If this isn’t in the conditional, some of the tests fail\n     * because `messageId` is present in the problem object\n     */\n    if (options.messageId) {\n        problem.messageId = options.messageId;\n    }\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line;\n        problem.endColumn = options.loc.end.column + 1;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    if (options.suggestions && options.suggestions.length > 0) {\n        problem.suggestions = options.suggestions;\n    }\n\n    return problem;\n}\n\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\nfunction validateSuggestions(suggest, messages) {\n    if (suggest && Array.isArray(suggest)) {\n        suggest.forEach(suggestion => {\n            if (suggestion.messageId) {\n                const { messageId } = suggestion;\n\n                if (!messages) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n                }\n\n                if (!messages[messageId]) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n                }\n\n                if (suggestion.desc) {\n                    throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n                }\n            } else if (!suggestion.desc) {\n                throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n            }\n\n            if (typeof suggestion.fix !== \"function\") {\n                throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n            }\n        });\n    }\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return (...args) => {\n        const descriptor = normalizeMultiArgReportCall(...args);\n        const messages = metadata.messageIds;\n\n        assertValidNodeInfo(descriptor);\n\n        let computedMessage;\n\n        if (descriptor.messageId) {\n            if (!messages) {\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n            }\n            const id = descriptor.messageId;\n\n            if (descriptor.message) {\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n            }\n            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n            }\n            computedMessage = messages[id];\n        } else if (descriptor.message) {\n            computedMessage = descriptor.message;\n        } else {\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n        }\n\n        validateSuggestions(descriptor.suggest, messages);\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: interpolate(computedMessage, descriptor.data),\n            messageId: descriptor.messageId,\n            loc: normalizeReportLoc(descriptor),\n            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n            suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n        });\n    };\n};\n"]},"metadata":{},"sourceType":"script"}