{"ast":null,"code":"/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\n\nfunction isInitialized(node) {\n  return Boolean(node.init);\n}\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\n\n\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n/**\n * The class to distinguish consecutive unreachable statements.\n */\n\n\nclass ConsecutiveRange {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.startNode = null;\n    this.endNode = null;\n  }\n  /**\n   * The location object of this range.\n   * @type {Object}\n   */\n\n\n  get location() {\n    return {\n      start: this.startNode.loc.start,\n      end: this.endNode.loc.end\n    };\n  }\n  /**\n   * `true` if this range is empty.\n   * @type {boolean}\n   */\n\n\n  get isEmpty() {\n    return !(this.startNode && this.endNode);\n  }\n  /**\n   * Checks whether the given node is inside of this range.\n   * @param {ASTNode|Token} node The node to check.\n   * @returns {boolean} `true` if the node is inside of this range.\n   */\n\n\n  contains(node) {\n    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];\n  }\n  /**\n   * Checks whether the given node is consecutive to this range.\n   * @param {ASTNode} node The node to check.\n   * @returns {boolean} `true` if the node is consecutive to this range.\n   */\n\n\n  isConsecutive(node) {\n    return this.contains(this.sourceCode.getTokenBefore(node));\n  }\n  /**\n   * Merges the given node to this range.\n   * @param {ASTNode} node The node to merge.\n   * @returns {void}\n   */\n\n\n  merge(node) {\n    this.endNode = node;\n  }\n  /**\n   * Resets this range by the given node or null.\n   * @param {ASTNode|null} node The node to reset, or null.\n   * @returns {void}\n   */\n\n\n  reset(node) {\n    this.startNode = this.endNode = node;\n  }\n\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unreachable\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    let currentCodePath = null;\n    const range = new ConsecutiveRange(context.getSourceCode());\n    /**\n     * Reports a given node if it's unreachable.\n     * @param {ASTNode} node A statement node to report.\n     * @returns {void}\n     */\n\n    function reportIfUnreachable(node) {\n      let nextNode = null;\n\n      if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n        // Store this statement to distinguish consecutive statements.\n        if (range.isEmpty) {\n          range.reset(node);\n          return;\n        } // Skip if this statement is inside of the current range.\n\n\n        if (range.contains(node)) {\n          return;\n        } // Merge if this statement is consecutive to the current range.\n\n\n        if (range.isConsecutive(node)) {\n          range.merge(node);\n          return;\n        }\n\n        nextNode = node;\n      }\n      /*\n       * Report the current range since this statement is reachable or is\n       * not consecutive to the current range.\n       */\n\n\n      if (!range.isEmpty) {\n        context.report({\n          message: \"Unreachable code.\",\n          loc: range.location,\n          node: range.startNode\n        });\n      } // Update the current range.\n\n\n      range.reset(nextNode);\n    }\n\n    return {\n      // Manages the current code path.\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      // Registers for all statement nodes (excludes FunctionDeclaration).\n      BlockStatement: reportIfUnreachable,\n      BreakStatement: reportIfUnreachable,\n      ClassDeclaration: reportIfUnreachable,\n      ContinueStatement: reportIfUnreachable,\n      DebuggerStatement: reportIfUnreachable,\n      DoWhileStatement: reportIfUnreachable,\n      ExpressionStatement: reportIfUnreachable,\n      ForInStatement: reportIfUnreachable,\n      ForOfStatement: reportIfUnreachable,\n      ForStatement: reportIfUnreachable,\n      IfStatement: reportIfUnreachable,\n      ImportDeclaration: reportIfUnreachable,\n      LabeledStatement: reportIfUnreachable,\n      ReturnStatement: reportIfUnreachable,\n      SwitchStatement: reportIfUnreachable,\n      ThrowStatement: reportIfUnreachable,\n      TryStatement: reportIfUnreachable,\n\n      VariableDeclaration(node) {\n        if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n          reportIfUnreachable(node);\n        }\n      },\n\n      WhileStatement: reportIfUnreachable,\n      WithStatement: reportIfUnreachable,\n      ExportNamedDeclaration: reportIfUnreachable,\n      ExportDefaultDeclaration: reportIfUnreachable,\n      ExportAllDeclaration: reportIfUnreachable,\n\n      \"Program:exit\"() {\n        reportIfUnreachable();\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-unreachable.js"],"names":["isInitialized","node","Boolean","init","isUnreachable","segment","reachable","ConsecutiveRange","constructor","sourceCode","startNode","endNode","location","start","loc","end","isEmpty","contains","range","isConsecutive","getTokenBefore","merge","reset","module","exports","meta","type","docs","description","category","recommended","url","schema","create","context","currentCodePath","getSourceCode","reportIfUnreachable","nextNode","currentSegments","every","report","message","onCodePathStart","codePath","onCodePathEnd","upper","BlockStatement","BreakStatement","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","ReturnStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","kind","declarations","some","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    message: \"Unreachable code.\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}