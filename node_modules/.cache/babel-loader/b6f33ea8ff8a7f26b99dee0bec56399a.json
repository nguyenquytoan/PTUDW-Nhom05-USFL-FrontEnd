{"ast":null,"code":"/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple spaces\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          patternProperties: {\n            \"^([A-Z][a-z]*)+$\": {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        },\n        ignoreEOLComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const ignoreEOLComments = options.ignoreEOLComments;\n    const exceptions = Object.assign({\n      Property: true\n    }, options.exceptions);\n    const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n    /**\n     * Formats value of given comment token for error message by truncating its length.\n     * @param {Token} token comment token\n     * @returns {string} formatted value\n     * @private\n     */\n\n    function formatReportedCommentValue(token) {\n      const valueLines = token.value.split(\"\\n\");\n      const value = valueLines[0];\n      const formattedValue = `${value.slice(0, 12)}...`;\n      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n          if (leftIndex === tokensAndComments.length - 1) {\n            return;\n          }\n\n          const rightToken = tokensAndComments[leftIndex + 1]; // Ignore tokens that don't have 2 spaces between them or are on different lines\n\n          if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") || leftToken.loc.end.line < rightToken.loc.start.line) {\n            return;\n          } // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n\n\n          if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {\n            return;\n          } // Ignore tokens that are in a node in the \"exceptions\" object\n\n\n          if (hasExceptions) {\n            const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n            if (parentNode && exceptions[parentNode.type]) {\n              return;\n            }\n          }\n\n          let displayValue;\n\n          if (rightToken.type === \"Block\") {\n            displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n          } else if (rightToken.type === \"Line\") {\n            displayValue = `//${formatReportedCommentValue(rightToken)}`;\n          } else {\n            displayValue = rightToken.value;\n          }\n\n          context.report({\n            node: rightToken,\n            loc: {\n              start: leftToken.loc.end,\n              end: rightToken.loc.start\n            },\n            message: \"Multiple spaces found before '{{displayValue}}'.\",\n            data: {\n              displayValue\n            },\n            fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n          });\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-multi-spaces.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","exceptions","patternProperties","additionalProperties","ignoreEOLComments","default","create","context","sourceCode","getSourceCode","options","Object","assign","Property","hasExceptions","keys","filter","key","length","formatReportedCommentValue","token","valueLines","value","split","formattedValue","slice","Program","tokensAndComments","forEach","leftToken","leftIndex","rightToken","text","range","includes","loc","end","line","start","isCommentToken","parentNode","getNodeByRangeIndex","displayValue","report","node","message","data","fix","fixer","replaceTextRange"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    ignoreEOLComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const ignoreEOLComments = options.ignoreEOLComments;\n        const exceptions = Object.assign({ Property: true }, options.exceptions);\n        const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n        /**\n         * Formats value of given comment token for error message by truncating its length.\n         * @param {Token} token comment token\n         * @returns {string} formatted value\n         * @private\n         */\n        function formatReportedCommentValue(token) {\n            const valueLines = token.value.split(\"\\n\");\n            const value = valueLines[0];\n            const formattedValue = `${value.slice(0, 12)}...`;\n\n            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n                    if (leftIndex === tokensAndComments.length - 1) {\n                        return;\n                    }\n                    const rightToken = tokensAndComments[leftIndex + 1];\n\n                    // Ignore tokens that don't have 2 spaces between them or are on different lines\n                    if (\n                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") ||\n                        leftToken.loc.end.line < rightToken.loc.start.line\n                    ) {\n                        return;\n                    }\n\n                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n                    if (\n                        ignoreEOLComments &&\n                        astUtils.isCommentToken(rightToken) &&\n                        (\n                            leftIndex === tokensAndComments.length - 2 ||\n                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line\n                        )\n                    ) {\n                        return;\n                    }\n\n                    // Ignore tokens that are in a node in the \"exceptions\" object\n                    if (hasExceptions) {\n                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n                        if (parentNode && exceptions[parentNode.type]) {\n                            return;\n                        }\n                    }\n\n                    let displayValue;\n\n                    if (rightToken.type === \"Block\") {\n                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n                    } else if (rightToken.type === \"Line\") {\n                        displayValue = `//${formatReportedCommentValue(rightToken)}`;\n                    } else {\n                        displayValue = rightToken.value;\n                    }\n\n                    context.report({\n                        node: rightToken,\n                        loc: { start: leftToken.loc.end, end: rightToken.loc.start },\n                        message: \"Multiple spaces found before '{{displayValue}}'.\",\n                        data: { displayValue },\n                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n                    });\n                });\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}