{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line between class members\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const sourceCode = context.getSourceCode();\n    /**\n     * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The last token among the consecutive tokens.\n     */\n\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n\n      return prevLastToken;\n    }\n    /**\n     * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The first token among the consecutive tokens.\n     */\n\n\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n\n      return nextFirstToken;\n    }\n    /**\n     * Checks if there is a token or comment between two tokens.\n     * @param {Token} before The token before.\n     * @param {Token} after The token after.\n     * @returns {boolean} True if there is a token or comment between two tokens.\n     */\n\n\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n\n    return {\n      ClassBody(node) {\n        const body = node.body;\n\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const curLast = sourceCode.getLastToken(body[i]);\n          const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n          if (options[0] === \"always\" && !skip && !isPadded || options[0] === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: isPadded ? \"never\" : \"always\",\n\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n\n                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\") : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/lines-between-class-members.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","exceptAfterSingleLine","default","additionalProperties","messages","never","always","create","context","options","sourceCode","getSourceCode","findLastConsecutiveTokenAfter","prevLastToken","nextFirstToken","maxLine","after","getTokenAfter","includeComments","loc","start","line","end","findFirstConsecutiveTokenBefore","before","getTokenBefore","hasTokenOrCommentBetween","getTokensBetween","length","ClassBody","node","body","i","curFirst","getFirstToken","curLast","getLastToken","nextFirst","isMulti","isTokenOnSameLine","skip","beforePadding","afterPadding","isPadded","hasTokenInPadding","curLineLastToken","report","messageId","fix","fixer","replaceTextRange","range","insertTextAfter"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line between class members\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const curLast = sourceCode.getLastToken(body[i]);\n                    const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\n                        (options[0] === \"never\" && isPadded)) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: isPadded ? \"never\" : \"always\",\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return isPadded\n                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\")\n                                    : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}