{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.mjs';\nconst CDN_PATH = `WORKBOX_CDN_ROOT_URL`;\nconst MODULE_KEY_TO_NAME_MAPPING = {\n  // TODO(philipwalton): add jsdoc tags to associate these with their module.\n  // @name backgroundSync\n  // @memberof workbox\n  // @see module:workbox-background-sync\n  backgroundSync: 'background-sync',\n  broadcastUpdate: 'broadcast-update',\n  cacheableResponse: 'cacheable-response',\n  core: 'core',\n  expiration: 'expiration',\n  googleAnalytics: 'offline-ga',\n  navigationPreload: 'navigation-preload',\n  precaching: 'precaching',\n  rangeRequests: 'range-requests',\n  routing: 'routing',\n  strategies: 'strategies',\n  streams: 'streams'\n};\n/**\n * This class can be used to make it easy to use the various parts of\n * Workbox.\n *\n * @private\n */\n\nexport class WorkboxSW {\n  /**\n   * Creates a proxy that automatically loads workbox namespaces on demand.\n   *\n   * @private\n   */\n  constructor() {\n    this.v = {};\n    this._options = {\n      debug: self.location.hostname === 'localhost',\n      modulePathPrefix: null,\n      modulePathCb: null\n    };\n    this._env = this._options.debug ? 'dev' : 'prod';\n    this._modulesLoaded = false;\n    return new Proxy(this, {\n      get(target, key) {\n        if (target[key]) {\n          return target[key];\n        }\n\n        const moduleName = MODULE_KEY_TO_NAME_MAPPING[key];\n\n        if (moduleName) {\n          target.loadModule(`workbox-${moduleName}`);\n        }\n\n        return target[key];\n      }\n\n    });\n  }\n  /**\n   * Updates the configuration options. You can specify whether to treat as a\n   * debug build and whether to use a CDN or a specific path when importing\n   * other workbox-modules\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.debug] If true, `dev` builds are using, otherwise\n   * `prod` builds are used. By default, `prod` is used unless on localhost.\n   * @param {Function} [options.modulePathPrefix] To avoid using the CDN with\n   * `workbox-sw` set the path prefix of where modules should be loaded from.\n   * For example `modulePathPrefix: '/third_party/workbox/v3.0.0/'`.\n   * @param {workbox~ModulePathCallback} [options.modulePathCb] If defined,\n   * this callback will be responsible for determining the path of each\n   * workbox module.\n   *\n   * @alias workbox.setConfig\n   */\n\n\n  setConfig(options = {}) {\n    if (!this._modulesLoaded) {\n      Object.assign(this._options, options);\n      this._env = this._options.debug ? 'dev' : 'prod';\n    } else {\n      throw new Error('Config must be set before accessing workbox.* modules');\n    }\n  }\n  /**\n   * Load a Workbox module by passing in the appropriate module name.\n   *\n   * This is not generally needed unless you know there are modules that are\n   * dynamically used and you want to safe guard use of the module while the\n   * user may be offline.\n   *\n   * @param {string} moduleName\n   *\n   * @alias workbox.loadModule\n   */\n\n\n  loadModule(moduleName) {\n    const modulePath = this._getImportPath(moduleName);\n\n    try {\n      importScripts(modulePath);\n      this._modulesLoaded = true;\n    } catch (err) {\n      // TODO Add context of this error if using the CDN vs the local file.\n      // We can't rely on workbox-core being loaded so using console\n      // eslint-disable-next-line\n      console.error(`Unable to import module '${moduleName}' from '${modulePath}'.`);\n      throw err;\n    }\n  }\n  /**\n   * This method will get the path / CDN URL to be used for importScript calls.\n   *\n   * @param {string} moduleName\n   * @return {string} URL to the desired module.\n   *\n   * @private\n   */\n\n\n  _getImportPath(moduleName) {\n    if (this._options.modulePathCb) {\n      return this._options.modulePathCb(moduleName, this._options.debug);\n    } // TODO: This needs to be dynamic some how.\n\n\n    let pathParts = [CDN_PATH];\n    const fileName = `${moduleName}.${this._env}.js`;\n    const pathPrefix = this._options.modulePathPrefix;\n\n    if (pathPrefix) {\n      // Split to avoid issues with developers ending / not ending with slash\n      pathParts = pathPrefix.split('/'); // We don't need a slash at the end as we will be adding\n      // a filename regardless\n\n      if (pathParts[pathParts.length - 1] === '') {\n        pathParts.splice(pathParts.length - 1, 1);\n      }\n    }\n\n    pathParts.push(fileName);\n    return pathParts.join('/');\n  }\n\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-sw/controllers/WorkboxSW.mjs"],"names":["CDN_PATH","MODULE_KEY_TO_NAME_MAPPING","backgroundSync","broadcastUpdate","cacheableResponse","core","expiration","googleAnalytics","navigationPreload","precaching","rangeRequests","routing","strategies","streams","WorkboxSW","constructor","v","_options","debug","self","location","hostname","modulePathPrefix","modulePathCb","_env","_modulesLoaded","Proxy","get","target","key","moduleName","loadModule","setConfig","options","Object","assign","Error","modulePath","_getImportPath","importScripts","err","console","error","pathParts","fileName","pathPrefix","split","length","splice","push","join"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nconst CDN_PATH = `WORKBOX_CDN_ROOT_URL`;\n\nconst MODULE_KEY_TO_NAME_MAPPING = {\n  // TODO(philipwalton): add jsdoc tags to associate these with their module.\n  // @name backgroundSync\n  // @memberof workbox\n  // @see module:workbox-background-sync\n  backgroundSync: 'background-sync',\n  broadcastUpdate: 'broadcast-update',\n  cacheableResponse: 'cacheable-response',\n  core: 'core',\n  expiration: 'expiration',\n  googleAnalytics: 'offline-ga',\n  navigationPreload: 'navigation-preload',\n  precaching: 'precaching',\n  rangeRequests: 'range-requests',\n  routing: 'routing',\n  strategies: 'strategies',\n  streams: 'streams',\n};\n\n/**\n * This class can be used to make it easy to use the various parts of\n * Workbox.\n *\n * @private\n */\nexport class WorkboxSW {\n  /**\n   * Creates a proxy that automatically loads workbox namespaces on demand.\n   *\n   * @private\n   */\n  constructor() {\n    this.v = {};\n    this._options = {\n      debug: self.location.hostname === 'localhost',\n      modulePathPrefix: null,\n      modulePathCb: null,\n    };\n\n    this._env = this._options.debug ? 'dev' : 'prod';\n    this._modulesLoaded = false;\n\n    return new Proxy(this, {\n      get(target, key) {\n        if (target[key]) {\n          return target[key];\n        }\n\n        const moduleName = MODULE_KEY_TO_NAME_MAPPING[key];\n        if (moduleName) {\n          target.loadModule(`workbox-${moduleName}`);\n        }\n\n        return target[key];\n      },\n    });\n  }\n\n  /**\n   * Updates the configuration options. You can specify whether to treat as a\n   * debug build and whether to use a CDN or a specific path when importing\n   * other workbox-modules\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.debug] If true, `dev` builds are using, otherwise\n   * `prod` builds are used. By default, `prod` is used unless on localhost.\n   * @param {Function} [options.modulePathPrefix] To avoid using the CDN with\n   * `workbox-sw` set the path prefix of where modules should be loaded from.\n   * For example `modulePathPrefix: '/third_party/workbox/v3.0.0/'`.\n   * @param {workbox~ModulePathCallback} [options.modulePathCb] If defined,\n   * this callback will be responsible for determining the path of each\n   * workbox module.\n   *\n   * @alias workbox.setConfig\n   */\n  setConfig(options = {}) {\n    if (!this._modulesLoaded) {\n      Object.assign(this._options, options);\n      this._env = this._options.debug ? 'dev' : 'prod';\n    } else {\n      throw new Error('Config must be set before accessing workbox.* modules');\n    }\n  }\n\n  /**\n   * Load a Workbox module by passing in the appropriate module name.\n   *\n   * This is not generally needed unless you know there are modules that are\n   * dynamically used and you want to safe guard use of the module while the\n   * user may be offline.\n   *\n   * @param {string} moduleName\n   *\n   * @alias workbox.loadModule\n   */\n  loadModule(moduleName) {\n    const modulePath = this._getImportPath(moduleName);\n    try {\n      importScripts(modulePath);\n      this._modulesLoaded = true;\n    } catch (err) {\n      // TODO Add context of this error if using the CDN vs the local file.\n\n      // We can't rely on workbox-core being loaded so using console\n      // eslint-disable-next-line\n      console.error(\n          `Unable to import module '${moduleName}' from '${modulePath}'.`);\n      throw err;\n    }\n  }\n\n  /**\n   * This method will get the path / CDN URL to be used for importScript calls.\n   *\n   * @param {string} moduleName\n   * @return {string} URL to the desired module.\n   *\n   * @private\n   */\n  _getImportPath(moduleName) {\n    if (this._options.modulePathCb) {\n      return this._options.modulePathCb(moduleName, this._options.debug);\n    }\n\n    // TODO: This needs to be dynamic some how.\n    let pathParts = [CDN_PATH];\n\n    const fileName = `${moduleName}.${this._env}.js`;\n\n    const pathPrefix = this._options.modulePathPrefix;\n    if (pathPrefix) {\n      // Split to avoid issues with developers ending / not ending with slash\n      pathParts = pathPrefix.split('/');\n\n      // We don't need a slash at the end as we will be adding\n      // a filename regardless\n      if (pathParts[pathParts.length - 1] === '') {\n        pathParts.splice(pathParts.length - 1, 1);\n      }\n    }\n\n    pathParts.push(fileName);\n\n    return pathParts.join('/');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}