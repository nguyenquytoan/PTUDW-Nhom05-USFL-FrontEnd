{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { Deferred } from 'workbox-core/_private/Deferred.mjs';\nimport { responsesAreSame } from './responsesAreSame.mjs';\nimport { broadcastUpdate } from './broadcastUpdate.mjs';\nimport { DEFAULT_HEADERS_TO_CHECK, DEFAULT_BROADCAST_CHANNEL_NAME, DEFAULT_DEFER_NOTIFICATION_TIMEOUT } from './utils/constants.mjs';\nimport './_version.mjs';\n/**\n * Uses the [Broadcast Channel API]{@link https://developers.google.com/web/updates/2016/09/broadcastchannel}\n * to notify interested parties when a cached response has been updated.\n * In browsers that do not support the Broadcast Channel API, the instance\n * falls back to sending the update via `postMessage()` to all window clients.\n *\n * For efficiency's sake, the underlying response bodies are not compared;\n * only specific response headers are checked.\n *\n * @memberof workbox.broadcastUpdate\n */\n\nclass BroadcastCacheUpdate {\n  /**\n   * Construct a BroadcastCacheUpdate instance with a specific `channelName` to\n   * broadcast messages on\n   *\n   * @param {Object} options\n   * @param {Array<string>}\n   *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n   *     A list of headers that will be used to determine whether the responses\n   *     differ.\n   * @param {string} [options.channelName='workbox'] The name that will be used\n   *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n   *     channel name used by the `workbox-window` package).\n   * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n   *     to wait for a ready message from the window on navigation requests\n   *     before sending the update.\n   */\n  constructor({\n    headersToCheck,\n    channelName,\n    deferNoticationTimeout\n  } = {}) {\n    this._headersToCheck = headersToCheck || DEFAULT_HEADERS_TO_CHECK;\n    this._channelName = channelName || DEFAULT_BROADCAST_CHANNEL_NAME;\n    this._deferNoticationTimeout = deferNoticationTimeout || DEFAULT_DEFER_NOTIFICATION_TIMEOUT;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(this._channelName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'channelName'\n      });\n      assert.isArray(this._headersToCheck, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'headersToCheck'\n      });\n    }\n\n    this._initWindowReadyDeferreds();\n  }\n  /**\n   * Compare two [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n   * and send a message via the\n   * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel API}\n   * if they differ.\n   *\n   * Neither of the Responses can be {@link http://stackoverflow.com/questions/39109789|opaque}.\n   *\n   * @param {Object} options\n   * @param {Response} options.oldResponse Cached response to compare.\n   * @param {Response} options.newResponse Possibly updated response to compare.\n   * @param {string} options.url The URL of the request.\n   * @param {string} options.cacheName Name of the cache the responses belong\n   *     to. This is included in the broadcast message.\n   * @param {Event} [options.event] event An optional event that triggered\n   *     this possible cache update.\n   * @return {Promise} Resolves once the update is sent.\n   */\n\n\n  notifyIfUpdated({\n    oldResponse,\n    newResponse,\n    url,\n    cacheName,\n    event\n  }) {\n    if (!responsesAreSame(oldResponse, newResponse, this._headersToCheck)) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Newer response found (and cached) for:`, url);\n      }\n\n      const sendUpdate = async () => {\n        // In the case of a navigation request, the requesting page will likely\n        // not have loaded its JavaScript in time to recevied the update\n        // notification, so we defer it until ready (or we timeout waiting).\n        if (event && event.request && event.request.mode === 'navigate') {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Original request was a navigation request, ` + `waiting for a ready message from the window`, event.request);\n          }\n\n          await this._windowReadyOrTimeout(event);\n        }\n\n        await this._broadcastUpdate({\n          channel: this._getChannel(),\n          cacheName,\n          url\n        });\n      }; // Send the update and ensure the SW stays alive until it's sent.\n\n\n      const done = sendUpdate();\n\n      if (event) {\n        try {\n          event.waitUntil(done);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive ` + `when broadcasting cache update for ` + `${getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n\n      return done;\n    }\n  }\n  /**\n   * NOTE: this is exposed on the instance primarily so it can be spied on\n   * in tests.\n   *\n   * @param {Object} opts\n   * @private\n   */\n\n\n  async _broadcastUpdate(opts) {\n    await broadcastUpdate(opts);\n  }\n  /**\n   * @return {BroadcastChannel|undefined} The BroadcastChannel instance used for\n   * broadcasting updates, or undefined if the browser doesn't support the\n   * Broadcast Channel API.\n   *\n   * @private\n   */\n\n\n  _getChannel() {\n    if ('BroadcastChannel' in self && !this._channel) {\n      this._channel = new BroadcastChannel(this._channelName);\n    }\n\n    return this._channel;\n  }\n  /**\n   * Waits for a message from the window indicating that it's capable of\n   * receiving broadcasts. By default, this will only wait for the amount of\n   * time specified via the `deferNoticationTimeout` option.\n   *\n   * @param {Event} event The navigation fetch event.\n   * @return {Promise}\n   * @private\n   */\n\n\n  _windowReadyOrTimeout(event) {\n    if (!this._navigationEventsDeferreds.has(event)) {\n      const deferred = new Deferred(); // Set the deferred on the `_navigationEventsDeferreds` map so it will\n      // be resolved when the next ready message event comes.\n\n      this._navigationEventsDeferreds.set(event, deferred); // But don't wait too long for the message since it may never come.\n\n\n      const timeout = setTimeout(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Timed out after ${this._deferNoticationTimeout}` + `ms waiting for message from window`);\n        }\n\n        deferred.resolve();\n      }, this._deferNoticationTimeout); // Ensure the timeout is cleared if the deferred promise is resolved.\n\n      deferred.promise.then(() => clearTimeout(timeout));\n    }\n\n    return this._navigationEventsDeferreds.get(event).promise;\n  }\n  /**\n   * Creates a mapping between navigation fetch events and deferreds, and adds\n   * a listener for message events from the window. When message events arrive,\n   * all deferreds in the mapping are resolved.\n   *\n   * Note: it would be easier if we could only resolve the deferred of\n   * navigation fetch event whose client ID matched the source ID of the\n   * message event, but currently client IDs are not exposed on navigation\n   * fetch events: https://www.chromestatus.com/feature/4846038800138240\n   *\n   * @private\n   */\n\n\n  _initWindowReadyDeferreds() {\n    // A mapping between navigation events and their deferreds.\n    this._navigationEventsDeferreds = new Map(); // The message listener needs to be added in the initial run of the\n    // service worker, but since we don't actually need to be listening for\n    // messages until the cache updates, we only invoke the callback if set.\n\n    self.addEventListener('message', event => {\n      if (event.data.type === 'WINDOW_READY' && event.data.meta === 'workbox-window' && this._navigationEventsDeferreds.size > 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Received WINDOW_READY event: `, event);\n        } // Resolve any pending deferreds.\n\n\n        for (const deferred of this._navigationEventsDeferreds.values()) {\n          deferred.resolve();\n        }\n\n        this._navigationEventsDeferreds.clear();\n      }\n    });\n  }\n\n}\n\nexport { BroadcastCacheUpdate };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-broadcast-update/BroadcastCacheUpdate.mjs"],"names":["assert","getFriendlyURL","logger","Deferred","responsesAreSame","broadcastUpdate","DEFAULT_HEADERS_TO_CHECK","DEFAULT_BROADCAST_CHANNEL_NAME","DEFAULT_DEFER_NOTIFICATION_TIMEOUT","BroadcastCacheUpdate","constructor","headersToCheck","channelName","deferNoticationTimeout","_headersToCheck","_channelName","_deferNoticationTimeout","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","isArray","_initWindowReadyDeferreds","notifyIfUpdated","oldResponse","newResponse","url","cacheName","event","log","sendUpdate","request","mode","debug","_windowReadyOrTimeout","_broadcastUpdate","channel","_getChannel","done","waitUntil","error","warn","opts","self","_channel","BroadcastChannel","_navigationEventsDeferreds","has","deferred","set","timeout","setTimeout","resolve","promise","then","clearTimeout","get","Map","addEventListener","data","type","meta","size","values","clear"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {responsesAreSame} from './responsesAreSame.mjs';\nimport {broadcastUpdate} from './broadcastUpdate.mjs';\n\nimport {DEFAULT_HEADERS_TO_CHECK, DEFAULT_BROADCAST_CHANNEL_NAME,\n  DEFAULT_DEFER_NOTIFICATION_TIMEOUT} from './utils/constants.mjs';\n\nimport './_version.mjs';\n\n/**\n * Uses the [Broadcast Channel API]{@link https://developers.google.com/web/updates/2016/09/broadcastchannel}\n * to notify interested parties when a cached response has been updated.\n * In browsers that do not support the Broadcast Channel API, the instance\n * falls back to sending the update via `postMessage()` to all window clients.\n *\n * For efficiency's sake, the underlying response bodies are not compared;\n * only specific response headers are checked.\n *\n * @memberof workbox.broadcastUpdate\n */\nclass BroadcastCacheUpdate {\n  /**\n   * Construct a BroadcastCacheUpdate instance with a specific `channelName` to\n   * broadcast messages on\n   *\n   * @param {Object} options\n   * @param {Array<string>}\n   *     [options.headersToCheck=['content-length', 'etag', 'last-modified']]\n   *     A list of headers that will be used to determine whether the responses\n   *     differ.\n   * @param {string} [options.channelName='workbox'] The name that will be used\n   *.    when creating the `BroadcastChannel`, which defaults to 'workbox' (the\n   *     channel name used by the `workbox-window` package).\n   * @param {string} [options.deferNoticationTimeout=10000] The amount of time\n   *     to wait for a ready message from the window on navigation requests\n   *     before sending the update.\n   */\n  constructor({headersToCheck, channelName, deferNoticationTimeout} = {}) {\n    this._headersToCheck = headersToCheck || DEFAULT_HEADERS_TO_CHECK;\n    this._channelName = channelName || DEFAULT_BROADCAST_CHANNEL_NAME;\n    this._deferNoticationTimeout =\n        deferNoticationTimeout || DEFAULT_DEFER_NOTIFICATION_TIMEOUT;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(this._channelName, 'string', {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'channelName',\n      });\n      assert.isArray(this._headersToCheck, {\n        moduleName: 'workbox-broadcast-update',\n        className: 'BroadcastCacheUpdate',\n        funcName: 'constructor',\n        paramName: 'headersToCheck',\n      });\n    }\n\n    this._initWindowReadyDeferreds();\n  }\n\n  /**\n   * Compare two [Responses](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n   * and send a message via the\n   * {@link https://developers.google.com/web/updates/2016/09/broadcastchannel|Broadcast Channel API}\n   * if they differ.\n   *\n   * Neither of the Responses can be {@link http://stackoverflow.com/questions/39109789|opaque}.\n   *\n   * @param {Object} options\n   * @param {Response} options.oldResponse Cached response to compare.\n   * @param {Response} options.newResponse Possibly updated response to compare.\n   * @param {string} options.url The URL of the request.\n   * @param {string} options.cacheName Name of the cache the responses belong\n   *     to. This is included in the broadcast message.\n   * @param {Event} [options.event] event An optional event that triggered\n   *     this possible cache update.\n   * @return {Promise} Resolves once the update is sent.\n   */\n  notifyIfUpdated({oldResponse, newResponse, url, cacheName, event}) {\n    if (!responsesAreSame(oldResponse, newResponse, this._headersToCheck)) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Newer response found (and cached) for:`, url);\n      }\n\n      const sendUpdate = async () => {\n        // In the case of a navigation request, the requesting page will likely\n        // not have loaded its JavaScript in time to recevied the update\n        // notification, so we defer it until ready (or we timeout waiting).\n        if (event && event.request && event.request.mode === 'navigate') {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Original request was a navigation request, ` +\n                `waiting for a ready message from the window`, event.request);\n          }\n          await this._windowReadyOrTimeout(event);\n        }\n        await this._broadcastUpdate({\n          channel: this._getChannel(),\n          cacheName,\n          url,\n        });\n      };\n\n      // Send the update and ensure the SW stays alive until it's sent.\n      const done = sendUpdate();\n\n      if (event) {\n        try {\n          event.waitUntil(done);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive ` +\n                `when broadcasting cache update for ` +\n                `${getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n      return done;\n    }\n  }\n\n  /**\n   * NOTE: this is exposed on the instance primarily so it can be spied on\n   * in tests.\n   *\n   * @param {Object} opts\n   * @private\n   */\n  async _broadcastUpdate(opts) {\n    await broadcastUpdate(opts);\n  }\n\n  /**\n   * @return {BroadcastChannel|undefined} The BroadcastChannel instance used for\n   * broadcasting updates, or undefined if the browser doesn't support the\n   * Broadcast Channel API.\n   *\n   * @private\n   */\n  _getChannel() {\n    if (('BroadcastChannel' in self) && !this._channel) {\n      this._channel = new BroadcastChannel(this._channelName);\n    }\n    return this._channel;\n  }\n\n  /**\n   * Waits for a message from the window indicating that it's capable of\n   * receiving broadcasts. By default, this will only wait for the amount of\n   * time specified via the `deferNoticationTimeout` option.\n   *\n   * @param {Event} event The navigation fetch event.\n   * @return {Promise}\n   * @private\n   */\n  _windowReadyOrTimeout(event) {\n    if (!this._navigationEventsDeferreds.has(event)) {\n      const deferred = new Deferred();\n\n      // Set the deferred on the `_navigationEventsDeferreds` map so it will\n      // be resolved when the next ready message event comes.\n      this._navigationEventsDeferreds.set(event, deferred);\n\n      // But don't wait too long for the message since it may never come.\n      const timeout = setTimeout(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Timed out after ${this._deferNoticationTimeout}` +\n              `ms waiting for message from window`);\n        }\n        deferred.resolve();\n      }, this._deferNoticationTimeout);\n\n      // Ensure the timeout is cleared if the deferred promise is resolved.\n      deferred.promise.then(() => clearTimeout(timeout));\n    }\n    return this._navigationEventsDeferreds.get(event).promise;\n  }\n\n  /**\n   * Creates a mapping between navigation fetch events and deferreds, and adds\n   * a listener for message events from the window. When message events arrive,\n   * all deferreds in the mapping are resolved.\n   *\n   * Note: it would be easier if we could only resolve the deferred of\n   * navigation fetch event whose client ID matched the source ID of the\n   * message event, but currently client IDs are not exposed on navigation\n   * fetch events: https://www.chromestatus.com/feature/4846038800138240\n   *\n   * @private\n   */\n  _initWindowReadyDeferreds() {\n    // A mapping between navigation events and their deferreds.\n    this._navigationEventsDeferreds = new Map();\n\n    // The message listener needs to be added in the initial run of the\n    // service worker, but since we don't actually need to be listening for\n    // messages until the cache updates, we only invoke the callback if set.\n    self.addEventListener('message', (event) => {\n      if (event.data.type === 'WINDOW_READY' &&\n          event.data.meta === 'workbox-window' &&\n          this._navigationEventsDeferreds.size > 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Received WINDOW_READY event: `, event);\n        }\n        // Resolve any pending deferreds.\n        for (const deferred of this._navigationEventsDeferreds.values()) {\n          deferred.resolve();\n        }\n        this._navigationEventsDeferreds.clear();\n      }\n    });\n  }\n}\n\nexport {BroadcastCacheUpdate};\n"]},"metadata":{},"sourceType":"module"}