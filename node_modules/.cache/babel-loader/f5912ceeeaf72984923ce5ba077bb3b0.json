{"ast":null,"code":"/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow reassigning `function` parameters\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-param-reassign\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [false]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [true]\n          },\n          ignorePropertyModificationsFor: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          },\n          ignorePropertyModificationsForRegex: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const props = context.options[0] && context.options[0].props;\n    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n    const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n    /**\n     * Checks whether or not the reference modifies properties of its variable.\n     * @param {Reference} reference A reference to check.\n     * @returns {boolean} Whether or not the reference modifies properties of its variable.\n     */\n\n    function isModifyingProp(reference) {\n      let node = reference.identifier;\n      let parent = node.parent;\n\n      while (parent && (!stopNodePattern.test(parent.type) || parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n        switch (parent.type) {\n          // e.g. foo.a = 0;\n          case \"AssignmentExpression\":\n            return parent.left === node;\n          // e.g. ++foo.a;\n\n          case \"UpdateExpression\":\n            return true;\n          // e.g. delete foo.a;\n\n          case \"UnaryExpression\":\n            if (parent.operator === \"delete\") {\n              return true;\n            }\n\n            break;\n          // e.g. for (foo.a in b) {}\n\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            if (parent.left === node) {\n              return true;\n            } // this is a stop node for parent.right and parent.body\n\n\n            return false;\n          // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n\n          case \"CallExpression\":\n            if (parent.callee !== node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. cache[foo.a] = 0;\n\n          case \"MemberExpression\":\n            if (parent.property === node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n\n          case \"Property\":\n            if (parent.key === node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. (foo ? a : b).c = bar;\n\n          case \"ConditionalExpression\":\n            if (parent.test === node) {\n              return false;\n            }\n\n            break;\n          // no default\n        }\n\n        node = parent;\n        parent = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Tests that an identifier name matches any of the ignored property assignments.\n     * First we test strings in ignoredPropertyAssignmentsFor.\n     * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n     * @param {string} identifierName A string that describes the name of an identifier to\n     * ignore property assignments for.\n     * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n     */\n\n\n    function isIgnoredPropertyAssignment(identifierName) {\n      return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n    }\n    /**\n     * Reports a reference if is non initializer and writable.\n     * @param {Reference} reference A reference to check.\n     * @param {int} index The index of the reference in the references.\n     * @param {Reference[]} references The array that the reference belongs to.\n     * @returns {void}\n     */\n\n\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n\n      if (identifier && !reference.init && (\n      /*\n       * Destructuring assignments can have multiple default value,\n       * so possibly there are multiple writeable references for the same identifier.\n       */\n      index === 0 || references[index - 1].identifier !== identifier)) {\n        if (reference.isWrite()) {\n          context.report({\n            node: identifier,\n            message: \"Assignment to function parameter '{{name}}'.\",\n            data: {\n              name: identifier.name\n            }\n          });\n        } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n          context.report({\n            node: identifier,\n            message: \"Assignment to property of function parameter '{{name}}'.\",\n            data: {\n              name: identifier.name\n            }\n          });\n        }\n      }\n    }\n    /**\n     * Finds and reports references that are non initializer and writable.\n     * @param {Variable} variable A variable to check.\n     * @returns {void}\n     */\n\n\n    function checkVariable(variable) {\n      if (variable.defs[0].type === \"Parameter\") {\n        variable.references.forEach(checkReference);\n      }\n    }\n    /**\n     * Checks parameters of a given function node.\n     * @param {ASTNode} node A function node to check.\n     * @returns {void}\n     */\n\n\n    function checkForFunction(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n      // `:exit` is needed for the `node.parent` property of identifier nodes.\n      \"FunctionDeclaration:exit\": checkForFunction,\n      \"FunctionExpression:exit\": checkForFunction,\n      \"ArrowFunctionExpression:exit\": checkForFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-param-reassign.js"],"names":["stopNodePattern","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","properties","props","enum","additionalProperties","ignorePropertyModificationsFor","items","uniqueItems","ignorePropertyModificationsForRegex","create","context","options","ignoredPropertyAssignmentsFor","ignoredPropertyAssignmentsForRegex","isModifyingProp","reference","node","identifier","parent","test","left","operator","callee","property","key","isIgnoredPropertyAssignment","identifierName","includes","some","ignored","RegExp","checkReference","index","references","init","isWrite","report","message","data","name","checkVariable","variable","defs","forEach","checkForFunction","getDeclaredVariables"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-param-reassign\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            },\n                            ignorePropertyModificationsForRegex: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const props = context.options[0] && context.options[0].props;\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && (!stopNodePattern.test(parent.type) ||\n                    parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // e.g. for (foo.a in b) {}\n                    case \"ForInStatement\":\n                    case \"ForOfStatement\":\n                        if (parent.left === node) {\n                            return true;\n                        }\n\n                        // this is a stop node for parent.right and parent.body\n                        return false;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\n                    case \"ConditionalExpression\":\n                        if (parent.test === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Tests that an identifier name matches any of the ignored property assignments.\n         * First we test strings in ignoredPropertyAssignmentsFor.\n         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n         * @param {string} identifierName A string that describes the name of an identifier to\n         * ignore property assignments for.\n         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n         */\n        function isIgnoredPropertyAssignment(identifierName) {\n            return ignoredPropertyAssignmentsFor.includes(identifierName) ||\n                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({ node: identifier, message: \"Assignment to function parameter '{{name}}'.\", data: { name: identifier.name } });\n                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n                    context.report({ node: identifier, message: \"Assignment to property of function parameter '{{name}}'.\", data: { name: identifier.name } });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}