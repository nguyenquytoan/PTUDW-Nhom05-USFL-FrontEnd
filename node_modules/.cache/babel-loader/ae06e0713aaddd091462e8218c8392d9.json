{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = normalize;\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function _glob() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestValidate() {\n  const data = require('jest-validate');\n\n  _jestValidate = function _jestValidate() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestGetType() {\n  const data = _interopRequireDefault(require('jest-get-type'));\n\n  _jestGetType = function _jestGetType() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _validatePattern = _interopRequireDefault(require('./validatePattern'));\n\nvar _getMaxWorkers = _interopRequireDefault(require('./getMaxWorkers'));\n\nvar _utils = require('./utils');\n\nvar _constants = require('./constants');\n\nvar _ReporterValidationErrors = require('./ReporterValidationErrors');\n\nvar _Defaults = _interopRequireDefault(require('./Defaults'));\n\nvar _Deprecated = _interopRequireDefault(require('./Deprecated'));\n\nvar _setFromArgv = _interopRequireDefault(require('./setFromArgv'));\n\nvar _ValidConfig = _interopRequireDefault(require('./ValidConfig'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ERROR = `${_utils.BULLET}Validation Error`;\nconst PRESET_EXTENSIONS = ['.json', '.js'];\nconst PRESET_NAME = 'jest-preset';\n\nconst createConfigError = message => new (_jestValidate().ValidationError)(ERROR, message, _utils.DOCUMENTATION_NOTE); // TS 3.5 forces us to split these into 2\n\n\nconst mergeModuleNameMapperWithPreset = (options, preset) => {\n  if (options['moduleNameMapper'] && preset['moduleNameMapper']) {\n    options['moduleNameMapper'] = _objectSpread({}, options['moduleNameMapper'], preset['moduleNameMapper'], options['moduleNameMapper']);\n  }\n};\n\nconst mergeTransformWithPreset = (options, preset) => {\n  if (options['transform'] && preset['transform']) {\n    options['transform'] = _objectSpread({}, options['transform'], preset['transform'], options['transform']);\n  }\n};\n\nconst setupPreset = (options, optionsPreset) => {\n  let preset;\n  const presetPath = (0, _utils.replaceRootDirInPath)(options.rootDir, optionsPreset);\n\n  const presetModule = _jestResolve().default.findNodeModule(presetPath.startsWith('.') ? presetPath : _path().default.join(presetPath, PRESET_NAME), {\n    basedir: options.rootDir,\n    extensions: PRESET_EXTENSIONS\n  });\n\n  try {\n    // Force re-evaluation to support multiple projects\n    try {\n      if (presetModule) {\n        delete require.cache[require.resolve(presetModule)];\n      }\n    } catch (e) {} // @ts-ignore: `presetModule` can be null?\n\n\n    preset = require(presetModule);\n  } catch (error) {\n    if (error instanceof SyntaxError || error instanceof TypeError) {\n      throw createConfigError(`  Preset ${_chalk().default.bold(presetPath)} is invalid:\\n\\n  ${error.message}\\n  ${error.stack}`);\n    }\n\n    const preset = _jestResolve().default.findNodeModule(presetPath, {\n      basedir: options.rootDir\n    });\n\n    if (preset) {\n      throw createConfigError(`  Module ${_chalk().default.bold(presetPath)} should have \"jest-preset.js\" or \"jest-preset.json\" file at the root.`);\n    }\n\n    throw createConfigError(`  Preset ${_chalk().default.bold(presetPath)} not found.`);\n  }\n\n  if (options.setupFiles) {\n    options.setupFiles = (preset.setupFiles || []).concat(options.setupFiles);\n  }\n\n  if (options.modulePathIgnorePatterns && preset.modulePathIgnorePatterns) {\n    options.modulePathIgnorePatterns = preset.modulePathIgnorePatterns.concat(options.modulePathIgnorePatterns);\n  }\n\n  mergeModuleNameMapperWithPreset(options, preset);\n  mergeTransformWithPreset(options, preset);\n  return _objectSpread({}, preset, options);\n};\n\nconst setupBabelJest = options => {\n  const transform = options.transform;\n  let babelJest;\n\n  if (transform) {\n    const customJSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.js') || regex.test('a.jsx');\n    });\n    const customTSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.ts') || regex.test('a.tsx');\n    });\n    [customJSPattern, customTSPattern].forEach(pattern => {\n      if (pattern) {\n        const customTransformer = transform[pattern];\n\n        if (Array.isArray(customTransformer)) {\n          if (customTransformer[0] === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            customTransformer[0] = babelJest;\n          } else if (customTransformer[0].includes('babel-jest')) {\n            babelJest = customTransformer[0];\n          }\n        } else {\n          if (customTransformer === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            transform[pattern] = babelJest;\n          } else if (customTransformer.includes('babel-jest')) {\n            babelJest = customTransformer;\n          }\n        }\n      }\n    });\n  } else {\n    babelJest = require.resolve('babel-jest');\n    options.transform = {\n      [_constants.DEFAULT_JS_PATTERN]: babelJest\n    };\n  }\n};\n\nconst normalizeCollectCoverageOnlyFrom = (options, key) => {\n  const initialCollectCoverageFrom = options[key];\n  const collectCoverageOnlyFrom = Array.isArray(initialCollectCoverageFrom) ? initialCollectCoverageFrom // passed from argv\n  : Object.keys(initialCollectCoverageFrom); // passed from options\n\n  return collectCoverageOnlyFrom.reduce((map, filePath) => {\n    filePath = _path().default.resolve(options.rootDir, (0, _utils.replaceRootDirInPath)(options.rootDir, filePath));\n    map[filePath] = true;\n    return map;\n  }, Object.create(null));\n};\n\nconst normalizeCollectCoverageFrom = (options, key) => {\n  const initialCollectCoverageFrom = options[key];\n  let value;\n\n  if (!initialCollectCoverageFrom) {\n    value = [];\n  }\n\n  if (!Array.isArray(initialCollectCoverageFrom)) {\n    try {\n      value = JSON.parse(initialCollectCoverageFrom);\n    } catch (e) {}\n\n    if (options[key] && !Array.isArray(value)) {\n      value = [initialCollectCoverageFrom];\n    }\n  } else {\n    value = initialCollectCoverageFrom;\n  }\n\n  if (value) {\n    value = value.map(filePath => filePath.replace(/^(!?)(<rootDir>\\/)(.*)/, '$1$3'));\n  }\n\n  return value;\n};\n\nconst normalizeUnmockedModulePathPatterns = (options, key // _replaceRootDirTags is specifically well-suited for substituting\n// <rootDir> in paths (it deals with properly interpreting relative path\n// separators, etc).\n//\n// For patterns, direct global substitution is far more ideal, so we\n// special case substitutions for patterns here.\n) => options[key].map(pattern => (0, _jestRegexUtil().replacePathSepForRegex)(pattern.replace(/<rootDir>/g, options.rootDir)));\n\nconst normalizePreprocessor = options => {\n  if (options.scriptPreprocessor && options.transform) {\n    throw createConfigError(`  Options: ${_chalk().default.bold('scriptPreprocessor')} and ${_chalk().default.bold('transform')} cannot be used together.\n  Please change your configuration to only use ${_chalk().default.bold('transform')}.`);\n  }\n\n  if (options.preprocessorIgnorePatterns && options.transformIgnorePatterns) {\n    throw createConfigError(`  Options ${_chalk().default.bold('preprocessorIgnorePatterns')} and ${_chalk().default.bold('transformIgnorePatterns')} cannot be used together.\n  Please change your configuration to only use ${_chalk().default.bold('transformIgnorePatterns')}.`);\n  }\n\n  if (options.scriptPreprocessor) {\n    options.transform = {\n      '.*': options.scriptPreprocessor\n    };\n  }\n\n  if (options.preprocessorIgnorePatterns) {\n    options.transformIgnorePatterns = options.preprocessorIgnorePatterns;\n  }\n\n  delete options.scriptPreprocessor;\n  delete options.preprocessorIgnorePatterns;\n  return options;\n};\n\nconst normalizeMissingOptions = (options, configPath, projectIndex) => {\n  if (!options.name) {\n    options.name = _crypto().default.createHash('md5').update(options.rootDir) // In case we load config from some path that has the same root dir\n    .update(configPath || '').update(String(projectIndex)).digest('hex');\n  }\n\n  if (!options.setupFiles) {\n    options.setupFiles = [];\n  }\n\n  return options;\n};\n\nconst normalizeRootDir = options => {\n  // Assert that there *is* a rootDir\n  if (!options.hasOwnProperty('rootDir')) {\n    throw createConfigError(`  Configuration option ${_chalk().default.bold('rootDir')} must be specified.`);\n  }\n\n  options.rootDir = _path().default.normalize(options.rootDir);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    options.rootDir = (0, _realpathNative().sync)(options.rootDir);\n  } catch (e) {// ignored\n  }\n\n  return options;\n};\n\nconst normalizeReporters = options => {\n  const reporters = options.reporters;\n\n  if (!reporters || !Array.isArray(reporters)) {\n    return options;\n  }\n\n  (0, _ReporterValidationErrors.validateReporters)(reporters);\n  options.reporters = reporters.map(reporterConfig => {\n    const normalizedReporterConfig = typeof reporterConfig === 'string' // if reporter config is a string, we wrap it in an array\n    ? // and pass an empty object for options argument, to normalize\n    [reporterConfig, {}] : reporterConfig;\n    const reporterPath = (0, _utils.replaceRootDirInPath)(options.rootDir, normalizedReporterConfig[0]);\n\n    if (reporterPath !== _constants.DEFAULT_REPORTER_LABEL) {\n      const reporter = _jestResolve().default.findNodeModule(reporterPath, {\n        basedir: options.rootDir\n      });\n\n      if (!reporter) {\n        throw new Error(`Could not resolve a module for a custom reporter.\\n` + `  Module name: ${reporterPath}`);\n      }\n\n      normalizedReporterConfig[0] = reporter;\n    }\n\n    return normalizedReporterConfig;\n  });\n  return options;\n};\n\nconst buildTestPathPattern = argv => {\n  const patterns = [];\n\n  if (argv._) {\n    patterns.push(...argv._);\n  }\n\n  if (argv.testPathPattern) {\n    patterns.push(...argv.testPathPattern);\n  }\n\n  const replacePosixSep = pattern => {\n    if (_path().default.sep === '/') {\n      return pattern;\n    }\n\n    return pattern.replace(/\\//g, '\\\\\\\\');\n  };\n\n  const testPathPattern = patterns.map(replacePosixSep).join('|');\n\n  if ((0, _validatePattern.default)(testPathPattern)) {\n    return testPathPattern;\n  } else {\n    showTestPathPatternError(testPathPattern);\n    return '';\n  }\n};\n\nconst showTestPathPatternError = testPathPattern => {\n  (0, _jestUtil().clearLine)(process.stdout);\n  console.log(_chalk().default.red(`  Invalid testPattern ${testPathPattern} supplied. ` + `Running all tests instead.`));\n};\n\nfunction normalize(options, argv, configPath, projectIndex = Infinity) {\n  const _validate = (0, _jestValidate().validate)(options, {\n    comment: _utils.DOCUMENTATION_NOTE,\n    deprecatedConfig: _Deprecated.default,\n    exampleConfig: _ValidConfig.default,\n    recursiveBlacklist: ['collectCoverageOnlyFrom', // 'coverageThreshold' allows to use 'global' and glob strings on the same\n    'coverageThreshold', 'globals', 'moduleNameMapper', 'testEnvironmentOptions', 'transform']\n  }),\n        hasDeprecationWarnings = _validate.hasDeprecationWarnings;\n\n  options = normalizePreprocessor(normalizeReporters(normalizeMissingOptions(normalizeRootDir((0, _setFromArgv.default)(options, argv)), configPath, projectIndex)));\n\n  if (options.preset) {\n    options = setupPreset(options, options.preset);\n  }\n\n  if (!options.setupFilesAfterEnv) {\n    options.setupFilesAfterEnv = [];\n  }\n\n  if (options.setupTestFrameworkScriptFile && options.setupFilesAfterEnv.length > 0) {\n    throw createConfigError(`  Options: ${_chalk().default.bold('setupTestFrameworkScriptFile')} and ${_chalk().default.bold('setupFilesAfterEnv')} cannot be used together.\n  Please change your configuration to only use ${_chalk().default.bold('setupFilesAfterEnv')}.`);\n  }\n\n  if (options.setupTestFrameworkScriptFile) {\n    options.setupFilesAfterEnv.push(options.setupTestFrameworkScriptFile);\n  }\n\n  options.testEnvironment = (0, _utils.getTestEnvironment)({\n    rootDir: options.rootDir,\n    testEnvironment: options.testEnvironment || _Defaults.default.testEnvironment\n  });\n\n  if (!options.roots && options.testPathDirs) {\n    options.roots = options.testPathDirs;\n    delete options.testPathDirs;\n  }\n\n  if (!options.roots) {\n    options.roots = [options.rootDir];\n  }\n\n  if (!options.testRunner || options.testRunner === 'jasmine2') {\n    options.testRunner = require.resolve('jest-jasmine2');\n  }\n\n  if (!options.coverageDirectory) {\n    options.coverageDirectory = _path().default.resolve(options.rootDir, 'coverage');\n  }\n\n  setupBabelJest(options); // TODO: Type this properly\n\n  const newOptions = _objectSpread({}, _Defaults.default);\n\n  if (options.resolver) {\n    newOptions.resolver = (0, _utils.resolve)(null, {\n      filePath: options.resolver,\n      key: 'resolver',\n      rootDir: options.rootDir\n    });\n  }\n\n  const optionKeys = Object.keys(options);\n  optionKeys.reduce((newOptions, key) => {\n    // The resolver has been resolved separately; skip it\n    if (key === 'resolver') {\n      return newOptions;\n    } // This is cheating, because it claims that all keys of InitialOptions are Required.\n    // We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,\n    // so oldOptions[key] is the only way it should be used.\n\n\n    const oldOptions = options;\n    let value;\n\n    switch (key) {\n      case 'collectCoverageOnlyFrom':\n        value = normalizeCollectCoverageOnlyFrom(oldOptions, key);\n        break;\n\n      case 'setupFiles':\n      case 'setupFilesAfterEnv':\n      case 'snapshotSerializers':\n        {\n          const option = oldOptions[key];\n          value = option && option.map(filePath => (0, _utils.resolve)(newOptions.resolver, {\n            filePath,\n            key,\n            rootDir: options.rootDir\n          }));\n        }\n        break;\n\n      case 'modulePaths':\n      case 'roots':\n        {\n          const option = oldOptions[key];\n          value = option && option.map(filePath => _path().default.resolve(options.rootDir, (0, _utils.replaceRootDirInPath)(options.rootDir, filePath)));\n        }\n        break;\n\n      case 'collectCoverageFrom':\n        value = normalizeCollectCoverageFrom(oldOptions, key);\n        break;\n\n      case 'cacheDirectory':\n      case 'coverageDirectory':\n        {\n          const option = oldOptions[key];\n          value = option && _path().default.resolve(options.rootDir, (0, _utils.replaceRootDirInPath)(options.rootDir, option));\n        }\n        break;\n\n      case 'dependencyExtractor':\n      case 'globalSetup':\n      case 'globalTeardown':\n      case 'moduleLoader':\n      case 'snapshotResolver':\n      case 'testResultsProcessor':\n      case 'testRunner':\n      case 'filter':\n        {\n          const option = oldOptions[key];\n          value = option && (0, _utils.resolve)(newOptions.resolver, {\n            filePath: option,\n            key,\n            rootDir: options.rootDir\n          });\n        }\n        break;\n\n      case 'runner':\n        {\n          const option = oldOptions[key];\n          value = option && (0, _utils.getRunner)(newOptions.resolver, {\n            filePath: option,\n            rootDir: options.rootDir\n          });\n        }\n        break;\n\n      case 'prettierPath':\n        {\n          // We only want this to throw if \"prettierPath\" is explicitly passed\n          // from config or CLI, and the requested path isn't found. Otherwise we\n          // set it to null and throw an error lazily when it is used.\n          const option = oldOptions[key];\n          value = option && (0, _utils.resolve)(newOptions.resolver, {\n            filePath: option,\n            key,\n            optional: option === _Defaults.default[key],\n            rootDir: options.rootDir\n          });\n        }\n        break;\n\n      case 'moduleNameMapper':\n        const moduleNameMapper = oldOptions[key];\n        value = moduleNameMapper && Object.keys(moduleNameMapper).map(regex => {\n          const item = moduleNameMapper && moduleNameMapper[regex];\n          return item && [regex, (0, _utils._replaceRootDirTags)(options.rootDir, item)];\n        });\n        break;\n\n      case 'transform':\n        const transform = oldOptions[key];\n        value = transform && Object.keys(transform).map(regex => {\n          const transformElement = transform[regex];\n          return [regex, (0, _utils.resolve)(newOptions.resolver, {\n            filePath: Array.isArray(transformElement) ? transformElement[0] : transformElement,\n            key,\n            rootDir: options.rootDir\n          }), ...(Array.isArray(transformElement) ? [transformElement[1]] : [])];\n        });\n        break;\n\n      case 'coveragePathIgnorePatterns':\n      case 'modulePathIgnorePatterns':\n      case 'testPathIgnorePatterns':\n      case 'transformIgnorePatterns':\n      case 'watchPathIgnorePatterns':\n      case 'unmockedModulePathPatterns':\n        value = normalizeUnmockedModulePathPatterns(oldOptions, key);\n        break;\n\n      case 'haste':\n        value = _objectSpread({}, oldOptions[key]);\n\n        if (value.hasteImplModulePath != null) {\n          const resolvedHasteImpl = (0, _utils.resolve)(newOptions.resolver, {\n            filePath: (0, _utils.replaceRootDirInPath)(options.rootDir, value.hasteImplModulePath),\n            key: 'haste.hasteImplModulePath',\n            rootDir: options.rootDir\n          });\n          value.hasteImplModulePath = resolvedHasteImpl || undefined;\n        }\n\n        break;\n\n      case 'projects':\n        value = (oldOptions[key] || []).map(project => typeof project === 'string' ? (0, _utils._replaceRootDirTags)(options.rootDir, project) : project).reduce((projects, project) => {\n          // Project can be specified as globs. If a glob matches any files,\n          // We expand it to these paths. If not, we keep the original path\n          // for the future resolution.\n          const globMatches = typeof project === 'string' ? _glob().default.sync(project) : [];\n          return projects.concat(globMatches.length ? globMatches : project);\n        }, []);\n        break;\n\n      case 'moduleDirectories':\n      case 'testMatch':\n        {\n          const replacedRootDirTags = (0, _utils._replaceRootDirTags)((0, _utils.escapeGlobCharacters)(options.rootDir), oldOptions[key]);\n\n          if (replacedRootDirTags) {\n            value = Array.isArray(replacedRootDirTags) ? replacedRootDirTags.map(_jestUtil().replacePathSepForGlob) : (0, _jestUtil().replacePathSepForGlob)(replacedRootDirTags);\n          } else {\n            value = replacedRootDirTags;\n          }\n        }\n        break;\n\n      case 'testRegex':\n        {\n          const option = oldOptions[key];\n          value = option ? (Array.isArray(option) ? option : [option]).map(_jestRegexUtil().replacePathSepForRegex) : [];\n        }\n        break;\n\n      case 'moduleFileExtensions':\n        {\n          value = oldOptions[key];\n\n          if (Array.isArray(value) && ( // If it's the wrong type, it can throw at a later time\n          options.runner === undefined || options.runner === _Defaults.default.runner) && // Only require 'js' for the default jest-runner\n          !value.includes('js')) {\n            const errorMessage = `  moduleFileExtensions must include 'js':\\n` + `  but instead received:\\n` + `    ${_chalk().default.bold.red(JSON.stringify(value))}`; // If `js` is not included, any dependency Jest itself injects into\n            // the environment, like jasmine or sourcemap-support, will need to\n            // `require` its modules with a file extension. This is not plausible\n            // in the long run, so it's way easier to just fail hard early.\n            // We might consider throwing if `json` is missing as well, as it's a\n            // fair assumption from modules that they can do\n            // `require('some-package/package') without the trailing `.json` as it\n            // works in Node normally.\n\n            throw createConfigError(errorMessage + \"\\n  Please change your configuration to include 'js'.\");\n          }\n\n          break;\n        }\n\n      case 'bail':\n        {\n          const bail = oldOptions[key];\n\n          if (typeof bail === 'boolean') {\n            value = bail ? 1 : 0;\n          } else if (typeof bail === 'string') {\n            value = 1; // If Jest is invoked as `jest --bail someTestPattern` then need to\n            // move the pattern from the `bail` configuration and into `argv._`\n            // to be processed as an extra parameter\n\n            argv._.push(bail);\n          } else {\n            value = oldOptions[key];\n          }\n\n          break;\n        }\n\n      case 'displayName':\n        {\n          const displayName = oldOptions[key];\n\n          if (typeof displayName === 'string') {\n            value = displayName;\n            break;\n          }\n          /**\n           * Ensuring that displayName shape is correct here so that the\n           * reporters can trust the shape of the data\n           * TODO: Normalize \"displayName\" such that given a config option\n           * {\n           *  \"displayName\": \"Test\"\n           * }\n           * becomes\n           * {\n           *   displayName: {\n           *     name: \"Test\",\n           *     color: \"white\"\n           *   }\n           * }\n           *\n           * This can't be done now since this will be a breaking change\n           * for custom reporters\n           */\n\n\n          if ((0, _jestGetType().default)(displayName) === 'object') {\n            const errorMessage = `  Option \"${_chalk().default.bold('displayName')}\" must be of type:\\n\\n` + '  {\\n' + '    name: string;\\n' + '    color: string;\\n' + '  }\\n';\n            const name = displayName.name,\n                  color = displayName.color;\n\n            if (!name || !color || typeof name !== 'string' || typeof color !== 'string') {\n              throw createConfigError(errorMessage);\n            }\n          }\n\n          value = oldOptions[key];\n          break;\n        }\n\n      case 'testTimeout':\n        {\n          if (oldOptions[key] < 0) {\n            throw createConfigError(`  Option \"${_chalk().default.bold('testTimeout')}\" must be a natural number.`);\n          }\n\n          value = oldOptions[key];\n          break;\n        }\n\n      case 'automock':\n      case 'browser':\n      case 'cache':\n      case 'changedSince':\n      case 'changedFilesWithAncestor':\n      case 'clearMocks':\n      case 'collectCoverage':\n      case 'coverageReporters':\n      case 'coverageThreshold':\n      case 'detectLeaks':\n      case 'detectOpenHandles':\n      case 'errorOnDeprecated':\n      case 'expand':\n      case 'extraGlobals':\n      case 'globals':\n      case 'findRelatedTests':\n      case 'forceCoverageMatch':\n      case 'forceExit':\n      case 'lastCommit':\n      case 'listTests':\n      case 'logHeapUsage':\n      case 'maxConcurrency':\n      case 'mapCoverage':\n      case 'name':\n      case 'noStackTrace':\n      case 'notify':\n      case 'notifyMode':\n      case 'onlyChanged':\n      case 'outputFile':\n      case 'passWithNoTests':\n      case 'replname':\n      case 'reporters':\n      case 'resetMocks':\n      case 'resetModules':\n      case 'restoreMocks':\n      case 'rootDir':\n      case 'runTestsByPath':\n      case 'silent':\n      case 'skipFilter':\n      case 'skipNodeResolution':\n      case 'testEnvironment':\n      case 'testEnvironmentOptions':\n      case 'testFailureExitCode':\n      case 'testLocationInResults':\n      case 'testNamePattern':\n      case 'testURL':\n      case 'timers':\n      case 'useStderr':\n      case 'verbose':\n      case 'watch':\n      case 'watchAll':\n      case 'watchman':\n        value = oldOptions[key];\n        break;\n\n      case 'watchPlugins':\n        value = (oldOptions[key] || []).map(watchPlugin => {\n          if (typeof watchPlugin === 'string') {\n            return {\n              config: {},\n              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {\n                filePath: watchPlugin,\n                rootDir: options.rootDir\n              })\n            };\n          } else {\n            return {\n              config: watchPlugin[1] || {},\n              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {\n                filePath: watchPlugin[0],\n                rootDir: options.rootDir\n              })\n            };\n          }\n        });\n        break;\n    } // @ts-ignore: automock is missing in GlobalConfig, so what\n\n\n    newOptions[key] = value;\n    return newOptions;\n  }, newOptions);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    newOptions.cwd = (0, _realpathNative().sync)(process.cwd());\n  } catch (e) {// ignored\n  }\n\n  newOptions.testSequencer = (0, _utils.getSequencer)(newOptions.resolver, {\n    filePath: options.testSequencer || _Defaults.default.testSequencer,\n    rootDir: options.rootDir\n  });\n  newOptions.nonFlagArgs = argv._;\n  newOptions.testPathPattern = buildTestPathPattern(argv);\n  newOptions.json = !!argv.json;\n  newOptions.testFailureExitCode = parseInt(newOptions.testFailureExitCode, 10);\n\n  if (newOptions.lastCommit || newOptions.changedFilesWithAncestor || newOptions.changedSince) {\n    newOptions.onlyChanged = true;\n  }\n\n  if (argv.all) {\n    newOptions.onlyChanged = false;\n  } else if (newOptions.testPathPattern) {\n    // When passing a test path pattern we don't want to only monitor changed\n    // files unless `--watch` is also passed.\n    newOptions.onlyChanged = newOptions.watch;\n  }\n\n  newOptions.updateSnapshot = argv.ci && !argv.updateSnapshot ? 'none' : argv.updateSnapshot ? 'all' : 'new';\n  newOptions.maxConcurrency = parseInt(newOptions.maxConcurrency, 10);\n  newOptions.maxWorkers = (0, _getMaxWorkers.default)(argv, options);\n\n  if (newOptions.testRegex.length && options.testMatch) {\n    throw createConfigError(`  Configuration options ${_chalk().default.bold('testMatch')} and` + ` ${_chalk().default.bold('testRegex')} cannot be used together.`);\n  }\n\n  if (newOptions.testRegex.length && !options.testMatch) {\n    // Prevent the default testMatch conflicting with any explicitly\n    // configured `testRegex` value\n    newOptions.testMatch = [];\n  } // If argv.json is set, coverageReporters shouldn't print a text report.\n\n\n  if (argv.json) {\n    newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(reporter => reporter !== 'text');\n  } // If collectCoverage is enabled while using --findRelatedTests we need to\n  // avoid having false negatives in the generated coverage report.\n  // The following: `--findRelatedTests '/rootDir/file1.js' --coverage`\n  // Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`\n  // where arguments to `--collectCoverageFrom` should be globs (or relative\n  // paths to the rootDir)\n\n\n  if (newOptions.collectCoverage && argv.findRelatedTests) {\n    let collectCoverageFrom = argv._.map(filename => {\n      filename = (0, _utils.replaceRootDirInPath)(options.rootDir, filename);\n      return _path().default.isAbsolute(filename) ? _path().default.relative(options.rootDir, filename) : filename;\n    }); // Don't override existing collectCoverageFrom options\n\n\n    if (newOptions.collectCoverageFrom) {\n      collectCoverageFrom = collectCoverageFrom.reduce((patterns, filename) => {\n        if (!_micromatch().default.some((0, _jestUtil().replacePathSepForGlob)(_path().default.relative(options.rootDir, filename)), newOptions.collectCoverageFrom)) {\n          return patterns;\n        }\n\n        return [...patterns, filename];\n      }, newOptions.collectCoverageFrom);\n    }\n\n    newOptions.collectCoverageFrom = collectCoverageFrom;\n  }\n\n  return {\n    hasDeprecationWarnings,\n    options: newOptions\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-config/build/normalize.js"],"names":["Object","defineProperty","exports","value","default","normalize","_crypto","data","_interopRequireDefault","require","_path","_glob","_jestValidate","_jestUtil","_chalk","_micromatch","_realpathNative","_jestResolve","_jestRegexUtil","_jestGetType","_validatePattern","_getMaxWorkers","_utils","_constants","_ReporterValidationErrors","_Defaults","_Deprecated","_setFromArgv","_ValidConfig","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","ERROR","BULLET","PRESET_EXTENSIONS","PRESET_NAME","createConfigError","message","ValidationError","DOCUMENTATION_NOTE","mergeModuleNameMapperWithPreset","options","preset","mergeTransformWithPreset","setupPreset","optionsPreset","presetPath","replaceRootDirInPath","rootDir","presetModule","findNodeModule","startsWith","join","basedir","extensions","cache","resolve","e","error","SyntaxError","TypeError","bold","stack","setupFiles","modulePathIgnorePatterns","setupBabelJest","transform","babelJest","customJSPattern","find","pattern","regex","RegExp","test","customTSPattern","customTransformer","Array","isArray","includes","DEFAULT_JS_PATTERN","normalizeCollectCoverageOnlyFrom","initialCollectCoverageFrom","collectCoverageOnlyFrom","reduce","map","filePath","create","normalizeCollectCoverageFrom","JSON","parse","replace","normalizeUnmockedModulePathPatterns","replacePathSepForRegex","normalizePreprocessor","scriptPreprocessor","preprocessorIgnorePatterns","transformIgnorePatterns","normalizeMissingOptions","configPath","projectIndex","name","createHash","update","String","digest","normalizeRootDir","hasOwnProperty","sync","normalizeReporters","reporters","validateReporters","reporterConfig","normalizedReporterConfig","reporterPath","DEFAULT_REPORTER_LABEL","reporter","Error","buildTestPathPattern","argv","patterns","_","push","testPathPattern","replacePosixSep","sep","showTestPathPatternError","clearLine","process","stdout","console","log","red","Infinity","_validate","validate","comment","deprecatedConfig","exampleConfig","recursiveBlacklist","hasDeprecationWarnings","setupFilesAfterEnv","setupTestFrameworkScriptFile","testEnvironment","getTestEnvironment","roots","testPathDirs","testRunner","coverageDirectory","newOptions","resolver","optionKeys","oldOptions","option","getRunner","optional","moduleNameMapper","item","_replaceRootDirTags","transformElement","hasteImplModulePath","resolvedHasteImpl","undefined","project","projects","globMatches","replacedRootDirTags","escapeGlobCharacters","replacePathSepForGlob","runner","errorMessage","stringify","bail","displayName","color","watchPlugin","config","path","getWatchPlugin","cwd","testSequencer","getSequencer","nonFlagArgs","json","testFailureExitCode","parseInt","lastCommit","changedFilesWithAncestor","changedSince","onlyChanged","all","watch","updateSnapshot","ci","maxConcurrency","maxWorkers","testRegex","testMatch","coverageReporters","collectCoverage","findRelatedTests","collectCoverageFrom","filename","isAbsolute","relative","some"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = normalize;\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _glob() {\n  const data = _interopRequireDefault(require('glob'));\n\n  _glob = function _glob() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestValidate() {\n  const data = require('jest-validate');\n\n  _jestValidate = function _jestValidate() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function _micromatch() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function _jestResolve() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function _jestRegexUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestGetType() {\n  const data = _interopRequireDefault(require('jest-get-type'));\n\n  _jestGetType = function _jestGetType() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _validatePattern = _interopRequireDefault(require('./validatePattern'));\n\nvar _getMaxWorkers = _interopRequireDefault(require('./getMaxWorkers'));\n\nvar _utils = require('./utils');\n\nvar _constants = require('./constants');\n\nvar _ReporterValidationErrors = require('./ReporterValidationErrors');\n\nvar _Defaults = _interopRequireDefault(require('./Defaults'));\n\nvar _Deprecated = _interopRequireDefault(require('./Deprecated'));\n\nvar _setFromArgv = _interopRequireDefault(require('./setFromArgv'));\n\nvar _ValidConfig = _interopRequireDefault(require('./ValidConfig'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst ERROR = `${_utils.BULLET}Validation Error`;\nconst PRESET_EXTENSIONS = ['.json', '.js'];\nconst PRESET_NAME = 'jest-preset';\n\nconst createConfigError = message =>\n  new (_jestValidate()).ValidationError(\n    ERROR,\n    message,\n    _utils.DOCUMENTATION_NOTE\n  ); // TS 3.5 forces us to split these into 2\n\nconst mergeModuleNameMapperWithPreset = (options, preset) => {\n  if (options['moduleNameMapper'] && preset['moduleNameMapper']) {\n    options['moduleNameMapper'] = _objectSpread(\n      {},\n      options['moduleNameMapper'],\n      preset['moduleNameMapper'],\n      options['moduleNameMapper']\n    );\n  }\n};\n\nconst mergeTransformWithPreset = (options, preset) => {\n  if (options['transform'] && preset['transform']) {\n    options['transform'] = _objectSpread(\n      {},\n      options['transform'],\n      preset['transform'],\n      options['transform']\n    );\n  }\n};\n\nconst setupPreset = (options, optionsPreset) => {\n  let preset;\n  const presetPath = (0, _utils.replaceRootDirInPath)(\n    options.rootDir,\n    optionsPreset\n  );\n\n  const presetModule = _jestResolve().default.findNodeModule(\n    presetPath.startsWith('.')\n      ? presetPath\n      : _path().default.join(presetPath, PRESET_NAME),\n    {\n      basedir: options.rootDir,\n      extensions: PRESET_EXTENSIONS\n    }\n  );\n\n  try {\n    // Force re-evaluation to support multiple projects\n    try {\n      if (presetModule) {\n        delete require.cache[require.resolve(presetModule)];\n      }\n    } catch (e) {} // @ts-ignore: `presetModule` can be null?\n\n    preset = require(presetModule);\n  } catch (error) {\n    if (error instanceof SyntaxError || error instanceof TypeError) {\n      throw createConfigError(\n        `  Preset ${_chalk().default.bold(presetPath)} is invalid:\\n\\n  ${\n          error.message\n        }\\n  ${error.stack}`\n      );\n    }\n\n    const preset = _jestResolve().default.findNodeModule(presetPath, {\n      basedir: options.rootDir\n    });\n\n    if (preset) {\n      throw createConfigError(\n        `  Module ${_chalk().default.bold(\n          presetPath\n        )} should have \"jest-preset.js\" or \"jest-preset.json\" file at the root.`\n      );\n    }\n\n    throw createConfigError(\n      `  Preset ${_chalk().default.bold(presetPath)} not found.`\n    );\n  }\n\n  if (options.setupFiles) {\n    options.setupFiles = (preset.setupFiles || []).concat(options.setupFiles);\n  }\n\n  if (options.modulePathIgnorePatterns && preset.modulePathIgnorePatterns) {\n    options.modulePathIgnorePatterns = preset.modulePathIgnorePatterns.concat(\n      options.modulePathIgnorePatterns\n    );\n  }\n\n  mergeModuleNameMapperWithPreset(options, preset);\n  mergeTransformWithPreset(options, preset);\n  return _objectSpread({}, preset, options);\n};\n\nconst setupBabelJest = options => {\n  const transform = options.transform;\n  let babelJest;\n\n  if (transform) {\n    const customJSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.js') || regex.test('a.jsx');\n    });\n    const customTSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.ts') || regex.test('a.tsx');\n    });\n    [customJSPattern, customTSPattern].forEach(pattern => {\n      if (pattern) {\n        const customTransformer = transform[pattern];\n\n        if (Array.isArray(customTransformer)) {\n          if (customTransformer[0] === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            customTransformer[0] = babelJest;\n          } else if (customTransformer[0].includes('babel-jest')) {\n            babelJest = customTransformer[0];\n          }\n        } else {\n          if (customTransformer === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            transform[pattern] = babelJest;\n          } else if (customTransformer.includes('babel-jest')) {\n            babelJest = customTransformer;\n          }\n        }\n      }\n    });\n  } else {\n    babelJest = require.resolve('babel-jest');\n    options.transform = {\n      [_constants.DEFAULT_JS_PATTERN]: babelJest\n    };\n  }\n};\n\nconst normalizeCollectCoverageOnlyFrom = (options, key) => {\n  const initialCollectCoverageFrom = options[key];\n  const collectCoverageOnlyFrom = Array.isArray(initialCollectCoverageFrom)\n    ? initialCollectCoverageFrom // passed from argv\n    : Object.keys(initialCollectCoverageFrom); // passed from options\n\n  return collectCoverageOnlyFrom.reduce((map, filePath) => {\n    filePath = _path().default.resolve(\n      options.rootDir,\n      (0, _utils.replaceRootDirInPath)(options.rootDir, filePath)\n    );\n    map[filePath] = true;\n    return map;\n  }, Object.create(null));\n};\n\nconst normalizeCollectCoverageFrom = (options, key) => {\n  const initialCollectCoverageFrom = options[key];\n  let value;\n\n  if (!initialCollectCoverageFrom) {\n    value = [];\n  }\n\n  if (!Array.isArray(initialCollectCoverageFrom)) {\n    try {\n      value = JSON.parse(initialCollectCoverageFrom);\n    } catch (e) {}\n\n    if (options[key] && !Array.isArray(value)) {\n      value = [initialCollectCoverageFrom];\n    }\n  } else {\n    value = initialCollectCoverageFrom;\n  }\n\n  if (value) {\n    value = value.map(filePath =>\n      filePath.replace(/^(!?)(<rootDir>\\/)(.*)/, '$1$3')\n    );\n  }\n\n  return value;\n};\n\nconst normalizeUnmockedModulePathPatterns = (\n  options,\n  key // _replaceRootDirTags is specifically well-suited for substituting\n  // <rootDir> in paths (it deals with properly interpreting relative path\n  // separators, etc).\n  //\n  // For patterns, direct global substitution is far more ideal, so we\n  // special case substitutions for patterns here.\n) =>\n  options[key].map(pattern =>\n    (0, _jestRegexUtil().replacePathSepForRegex)(\n      pattern.replace(/<rootDir>/g, options.rootDir)\n    )\n  );\n\nconst normalizePreprocessor = options => {\n  if (options.scriptPreprocessor && options.transform) {\n    throw createConfigError(`  Options: ${_chalk().default.bold(\n      'scriptPreprocessor'\n    )} and ${_chalk().default.bold('transform')} cannot be used together.\n  Please change your configuration to only use ${_chalk().default.bold(\n    'transform'\n  )}.`);\n  }\n\n  if (options.preprocessorIgnorePatterns && options.transformIgnorePatterns) {\n    throw createConfigError(`  Options ${_chalk().default.bold(\n      'preprocessorIgnorePatterns'\n    )} and ${_chalk().default.bold(\n      'transformIgnorePatterns'\n    )} cannot be used together.\n  Please change your configuration to only use ${_chalk().default.bold(\n    'transformIgnorePatterns'\n  )}.`);\n  }\n\n  if (options.scriptPreprocessor) {\n    options.transform = {\n      '.*': options.scriptPreprocessor\n    };\n  }\n\n  if (options.preprocessorIgnorePatterns) {\n    options.transformIgnorePatterns = options.preprocessorIgnorePatterns;\n  }\n\n  delete options.scriptPreprocessor;\n  delete options.preprocessorIgnorePatterns;\n  return options;\n};\n\nconst normalizeMissingOptions = (options, configPath, projectIndex) => {\n  if (!options.name) {\n    options.name = _crypto()\n      .default.createHash('md5')\n      .update(options.rootDir) // In case we load config from some path that has the same root dir\n      .update(configPath || '')\n      .update(String(projectIndex))\n      .digest('hex');\n  }\n\n  if (!options.setupFiles) {\n    options.setupFiles = [];\n  }\n\n  return options;\n};\n\nconst normalizeRootDir = options => {\n  // Assert that there *is* a rootDir\n  if (!options.hasOwnProperty('rootDir')) {\n    throw createConfigError(\n      `  Configuration option ${_chalk().default.bold(\n        'rootDir'\n      )} must be specified.`\n    );\n  }\n\n  options.rootDir = _path().default.normalize(options.rootDir);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    options.rootDir = (0, _realpathNative().sync)(options.rootDir);\n  } catch (e) {\n    // ignored\n  }\n\n  return options;\n};\n\nconst normalizeReporters = options => {\n  const reporters = options.reporters;\n\n  if (!reporters || !Array.isArray(reporters)) {\n    return options;\n  }\n\n  (0, _ReporterValidationErrors.validateReporters)(reporters);\n  options.reporters = reporters.map(reporterConfig => {\n    const normalizedReporterConfig =\n      typeof reporterConfig === 'string' // if reporter config is a string, we wrap it in an array\n        ? // and pass an empty object for options argument, to normalize\n          [reporterConfig, {}]\n        : reporterConfig;\n    const reporterPath = (0, _utils.replaceRootDirInPath)(\n      options.rootDir,\n      normalizedReporterConfig[0]\n    );\n\n    if (reporterPath !== _constants.DEFAULT_REPORTER_LABEL) {\n      const reporter = _jestResolve().default.findNodeModule(reporterPath, {\n        basedir: options.rootDir\n      });\n\n      if (!reporter) {\n        throw new Error(\n          `Could not resolve a module for a custom reporter.\\n` +\n            `  Module name: ${reporterPath}`\n        );\n      }\n\n      normalizedReporterConfig[0] = reporter;\n    }\n\n    return normalizedReporterConfig;\n  });\n  return options;\n};\n\nconst buildTestPathPattern = argv => {\n  const patterns = [];\n\n  if (argv._) {\n    patterns.push(...argv._);\n  }\n\n  if (argv.testPathPattern) {\n    patterns.push(...argv.testPathPattern);\n  }\n\n  const replacePosixSep = pattern => {\n    if (_path().default.sep === '/') {\n      return pattern;\n    }\n\n    return pattern.replace(/\\//g, '\\\\\\\\');\n  };\n\n  const testPathPattern = patterns.map(replacePosixSep).join('|');\n\n  if ((0, _validatePattern.default)(testPathPattern)) {\n    return testPathPattern;\n  } else {\n    showTestPathPatternError(testPathPattern);\n    return '';\n  }\n};\n\nconst showTestPathPatternError = testPathPattern => {\n  (0, _jestUtil().clearLine)(process.stdout);\n  console.log(\n    _chalk().default.red(\n      `  Invalid testPattern ${testPathPattern} supplied. ` +\n        `Running all tests instead.`\n    )\n  );\n};\n\nfunction normalize(options, argv, configPath, projectIndex = Infinity) {\n  const _validate = (0, _jestValidate().validate)(options, {\n      comment: _utils.DOCUMENTATION_NOTE,\n      deprecatedConfig: _Deprecated.default,\n      exampleConfig: _ValidConfig.default,\n      recursiveBlacklist: [\n        'collectCoverageOnlyFrom', // 'coverageThreshold' allows to use 'global' and glob strings on the same\n        'coverageThreshold',\n        'globals',\n        'moduleNameMapper',\n        'testEnvironmentOptions',\n        'transform'\n      ]\n    }),\n    hasDeprecationWarnings = _validate.hasDeprecationWarnings;\n\n  options = normalizePreprocessor(\n    normalizeReporters(\n      normalizeMissingOptions(\n        normalizeRootDir((0, _setFromArgv.default)(options, argv)),\n        configPath,\n        projectIndex\n      )\n    )\n  );\n\n  if (options.preset) {\n    options = setupPreset(options, options.preset);\n  }\n\n  if (!options.setupFilesAfterEnv) {\n    options.setupFilesAfterEnv = [];\n  }\n\n  if (\n    options.setupTestFrameworkScriptFile &&\n    options.setupFilesAfterEnv.length > 0\n  ) {\n    throw createConfigError(`  Options: ${_chalk().default.bold(\n      'setupTestFrameworkScriptFile'\n    )} and ${_chalk().default.bold(\n      'setupFilesAfterEnv'\n    )} cannot be used together.\n  Please change your configuration to only use ${_chalk().default.bold(\n    'setupFilesAfterEnv'\n  )}.`);\n  }\n\n  if (options.setupTestFrameworkScriptFile) {\n    options.setupFilesAfterEnv.push(options.setupTestFrameworkScriptFile);\n  }\n\n  options.testEnvironment = (0, _utils.getTestEnvironment)({\n    rootDir: options.rootDir,\n    testEnvironment:\n      options.testEnvironment || _Defaults.default.testEnvironment\n  });\n\n  if (!options.roots && options.testPathDirs) {\n    options.roots = options.testPathDirs;\n    delete options.testPathDirs;\n  }\n\n  if (!options.roots) {\n    options.roots = [options.rootDir];\n  }\n\n  if (!options.testRunner || options.testRunner === 'jasmine2') {\n    options.testRunner = require.resolve('jest-jasmine2');\n  }\n\n  if (!options.coverageDirectory) {\n    options.coverageDirectory = _path().default.resolve(\n      options.rootDir,\n      'coverage'\n    );\n  }\n\n  setupBabelJest(options); // TODO: Type this properly\n\n  const newOptions = _objectSpread({}, _Defaults.default);\n\n  if (options.resolver) {\n    newOptions.resolver = (0, _utils.resolve)(null, {\n      filePath: options.resolver,\n      key: 'resolver',\n      rootDir: options.rootDir\n    });\n  }\n\n  const optionKeys = Object.keys(options);\n  optionKeys.reduce((newOptions, key) => {\n    // The resolver has been resolved separately; skip it\n    if (key === 'resolver') {\n      return newOptions;\n    } // This is cheating, because it claims that all keys of InitialOptions are Required.\n    // We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,\n    // so oldOptions[key] is the only way it should be used.\n\n    const oldOptions = options;\n    let value;\n\n    switch (key) {\n      case 'collectCoverageOnlyFrom':\n        value = normalizeCollectCoverageOnlyFrom(oldOptions, key);\n        break;\n\n      case 'setupFiles':\n      case 'setupFilesAfterEnv':\n      case 'snapshotSerializers':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            option.map(filePath =>\n              (0, _utils.resolve)(newOptions.resolver, {\n                filePath,\n                key,\n                rootDir: options.rootDir\n              })\n            );\n        }\n        break;\n\n      case 'modulePaths':\n      case 'roots':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            option.map(filePath =>\n              _path().default.resolve(\n                options.rootDir,\n                (0, _utils.replaceRootDirInPath)(options.rootDir, filePath)\n              )\n            );\n        }\n        break;\n\n      case 'collectCoverageFrom':\n        value = normalizeCollectCoverageFrom(oldOptions, key);\n        break;\n\n      case 'cacheDirectory':\n      case 'coverageDirectory':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            _path().default.resolve(\n              options.rootDir,\n              (0, _utils.replaceRootDirInPath)(options.rootDir, option)\n            );\n        }\n        break;\n\n      case 'dependencyExtractor':\n      case 'globalSetup':\n      case 'globalTeardown':\n      case 'moduleLoader':\n      case 'snapshotResolver':\n      case 'testResultsProcessor':\n      case 'testRunner':\n      case 'filter':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            (0, _utils.resolve)(newOptions.resolver, {\n              filePath: option,\n              key,\n              rootDir: options.rootDir\n            });\n        }\n        break;\n\n      case 'runner':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            (0, _utils.getRunner)(newOptions.resolver, {\n              filePath: option,\n              rootDir: options.rootDir\n            });\n        }\n        break;\n\n      case 'prettierPath':\n        {\n          // We only want this to throw if \"prettierPath\" is explicitly passed\n          // from config or CLI, and the requested path isn't found. Otherwise we\n          // set it to null and throw an error lazily when it is used.\n          const option = oldOptions[key];\n          value =\n            option &&\n            (0, _utils.resolve)(newOptions.resolver, {\n              filePath: option,\n              key,\n              optional: option === _Defaults.default[key],\n              rootDir: options.rootDir\n            });\n        }\n        break;\n\n      case 'moduleNameMapper':\n        const moduleNameMapper = oldOptions[key];\n        value =\n          moduleNameMapper &&\n          Object.keys(moduleNameMapper).map(regex => {\n            const item = moduleNameMapper && moduleNameMapper[regex];\n            return (\n              item && [\n                regex,\n                (0, _utils._replaceRootDirTags)(options.rootDir, item)\n              ]\n            );\n          });\n        break;\n\n      case 'transform':\n        const transform = oldOptions[key];\n        value =\n          transform &&\n          Object.keys(transform).map(regex => {\n            const transformElement = transform[regex];\n            return [\n              regex,\n              (0, _utils.resolve)(newOptions.resolver, {\n                filePath: Array.isArray(transformElement)\n                  ? transformElement[0]\n                  : transformElement,\n                key,\n                rootDir: options.rootDir\n              }),\n              ...(Array.isArray(transformElement) ? [transformElement[1]] : [])\n            ];\n          });\n        break;\n\n      case 'coveragePathIgnorePatterns':\n      case 'modulePathIgnorePatterns':\n      case 'testPathIgnorePatterns':\n      case 'transformIgnorePatterns':\n      case 'watchPathIgnorePatterns':\n      case 'unmockedModulePathPatterns':\n        value = normalizeUnmockedModulePathPatterns(oldOptions, key);\n        break;\n\n      case 'haste':\n        value = _objectSpread({}, oldOptions[key]);\n\n        if (value.hasteImplModulePath != null) {\n          const resolvedHasteImpl = (0, _utils.resolve)(newOptions.resolver, {\n            filePath: (0, _utils.replaceRootDirInPath)(\n              options.rootDir,\n              value.hasteImplModulePath\n            ),\n            key: 'haste.hasteImplModulePath',\n            rootDir: options.rootDir\n          });\n          value.hasteImplModulePath = resolvedHasteImpl || undefined;\n        }\n\n        break;\n\n      case 'projects':\n        value = (oldOptions[key] || [])\n          .map(project =>\n            typeof project === 'string'\n              ? (0, _utils._replaceRootDirTags)(options.rootDir, project)\n              : project\n          )\n          .reduce((projects, project) => {\n            // Project can be specified as globs. If a glob matches any files,\n            // We expand it to these paths. If not, we keep the original path\n            // for the future resolution.\n            const globMatches =\n              typeof project === 'string' ? _glob().default.sync(project) : [];\n            return projects.concat(globMatches.length ? globMatches : project);\n          }, []);\n        break;\n\n      case 'moduleDirectories':\n      case 'testMatch':\n        {\n          const replacedRootDirTags = (0, _utils._replaceRootDirTags)(\n            (0, _utils.escapeGlobCharacters)(options.rootDir),\n            oldOptions[key]\n          );\n\n          if (replacedRootDirTags) {\n            value = Array.isArray(replacedRootDirTags)\n              ? replacedRootDirTags.map(_jestUtil().replacePathSepForGlob)\n              : (0, _jestUtil().replacePathSepForGlob)(replacedRootDirTags);\n          } else {\n            value = replacedRootDirTags;\n          }\n        }\n        break;\n\n      case 'testRegex':\n        {\n          const option = oldOptions[key];\n          value = option\n            ? (Array.isArray(option) ? option : [option]).map(\n                _jestRegexUtil().replacePathSepForRegex\n              )\n            : [];\n        }\n        break;\n\n      case 'moduleFileExtensions': {\n        value = oldOptions[key];\n\n        if (\n          Array.isArray(value) && // If it's the wrong type, it can throw at a later time\n          (options.runner === undefined ||\n            options.runner === _Defaults.default.runner) && // Only require 'js' for the default jest-runner\n          !value.includes('js')\n        ) {\n          const errorMessage =\n            `  moduleFileExtensions must include 'js':\\n` +\n            `  but instead received:\\n` +\n            `    ${_chalk().default.bold.red(JSON.stringify(value))}`; // If `js` is not included, any dependency Jest itself injects into\n          // the environment, like jasmine or sourcemap-support, will need to\n          // `require` its modules with a file extension. This is not plausible\n          // in the long run, so it's way easier to just fail hard early.\n          // We might consider throwing if `json` is missing as well, as it's a\n          // fair assumption from modules that they can do\n          // `require('some-package/package') without the trailing `.json` as it\n          // works in Node normally.\n\n          throw createConfigError(\n            errorMessage +\n              \"\\n  Please change your configuration to include 'js'.\"\n          );\n        }\n\n        break;\n      }\n\n      case 'bail': {\n        const bail = oldOptions[key];\n\n        if (typeof bail === 'boolean') {\n          value = bail ? 1 : 0;\n        } else if (typeof bail === 'string') {\n          value = 1; // If Jest is invoked as `jest --bail someTestPattern` then need to\n          // move the pattern from the `bail` configuration and into `argv._`\n          // to be processed as an extra parameter\n\n          argv._.push(bail);\n        } else {\n          value = oldOptions[key];\n        }\n\n        break;\n      }\n\n      case 'displayName': {\n        const displayName = oldOptions[key];\n\n        if (typeof displayName === 'string') {\n          value = displayName;\n          break;\n        }\n        /**\n         * Ensuring that displayName shape is correct here so that the\n         * reporters can trust the shape of the data\n         * TODO: Normalize \"displayName\" such that given a config option\n         * {\n         *  \"displayName\": \"Test\"\n         * }\n         * becomes\n         * {\n         *   displayName: {\n         *     name: \"Test\",\n         *     color: \"white\"\n         *   }\n         * }\n         *\n         * This can't be done now since this will be a breaking change\n         * for custom reporters\n         */\n\n        if ((0, _jestGetType().default)(displayName) === 'object') {\n          const errorMessage =\n            `  Option \"${_chalk().default.bold(\n              'displayName'\n            )}\" must be of type:\\n\\n` +\n            '  {\\n' +\n            '    name: string;\\n' +\n            '    color: string;\\n' +\n            '  }\\n';\n          const name = displayName.name,\n            color = displayName.color;\n\n          if (\n            !name ||\n            !color ||\n            typeof name !== 'string' ||\n            typeof color !== 'string'\n          ) {\n            throw createConfigError(errorMessage);\n          }\n        }\n\n        value = oldOptions[key];\n        break;\n      }\n\n      case 'testTimeout': {\n        if (oldOptions[key] < 0) {\n          throw createConfigError(\n            `  Option \"${_chalk().default.bold(\n              'testTimeout'\n            )}\" must be a natural number.`\n          );\n        }\n\n        value = oldOptions[key];\n        break;\n      }\n\n      case 'automock':\n      case 'browser':\n      case 'cache':\n      case 'changedSince':\n      case 'changedFilesWithAncestor':\n      case 'clearMocks':\n      case 'collectCoverage':\n      case 'coverageReporters':\n      case 'coverageThreshold':\n      case 'detectLeaks':\n      case 'detectOpenHandles':\n      case 'errorOnDeprecated':\n      case 'expand':\n      case 'extraGlobals':\n      case 'globals':\n      case 'findRelatedTests':\n      case 'forceCoverageMatch':\n      case 'forceExit':\n      case 'lastCommit':\n      case 'listTests':\n      case 'logHeapUsage':\n      case 'maxConcurrency':\n      case 'mapCoverage':\n      case 'name':\n      case 'noStackTrace':\n      case 'notify':\n      case 'notifyMode':\n      case 'onlyChanged':\n      case 'outputFile':\n      case 'passWithNoTests':\n      case 'replname':\n      case 'reporters':\n      case 'resetMocks':\n      case 'resetModules':\n      case 'restoreMocks':\n      case 'rootDir':\n      case 'runTestsByPath':\n      case 'silent':\n      case 'skipFilter':\n      case 'skipNodeResolution':\n      case 'testEnvironment':\n      case 'testEnvironmentOptions':\n      case 'testFailureExitCode':\n      case 'testLocationInResults':\n      case 'testNamePattern':\n      case 'testURL':\n      case 'timers':\n      case 'useStderr':\n      case 'verbose':\n      case 'watch':\n      case 'watchAll':\n      case 'watchman':\n        value = oldOptions[key];\n        break;\n\n      case 'watchPlugins':\n        value = (oldOptions[key] || []).map(watchPlugin => {\n          if (typeof watchPlugin === 'string') {\n            return {\n              config: {},\n              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {\n                filePath: watchPlugin,\n                rootDir: options.rootDir\n              })\n            };\n          } else {\n            return {\n              config: watchPlugin[1] || {},\n              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {\n                filePath: watchPlugin[0],\n                rootDir: options.rootDir\n              })\n            };\n          }\n        });\n        break;\n    } // @ts-ignore: automock is missing in GlobalConfig, so what\n\n    newOptions[key] = value;\n    return newOptions;\n  }, newOptions);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    newOptions.cwd = (0, _realpathNative().sync)(process.cwd());\n  } catch (e) {\n    // ignored\n  }\n\n  newOptions.testSequencer = (0, _utils.getSequencer)(newOptions.resolver, {\n    filePath: options.testSequencer || _Defaults.default.testSequencer,\n    rootDir: options.rootDir\n  });\n  newOptions.nonFlagArgs = argv._;\n  newOptions.testPathPattern = buildTestPathPattern(argv);\n  newOptions.json = !!argv.json;\n  newOptions.testFailureExitCode = parseInt(newOptions.testFailureExitCode, 10);\n\n  if (\n    newOptions.lastCommit ||\n    newOptions.changedFilesWithAncestor ||\n    newOptions.changedSince\n  ) {\n    newOptions.onlyChanged = true;\n  }\n\n  if (argv.all) {\n    newOptions.onlyChanged = false;\n  } else if (newOptions.testPathPattern) {\n    // When passing a test path pattern we don't want to only monitor changed\n    // files unless `--watch` is also passed.\n    newOptions.onlyChanged = newOptions.watch;\n  }\n\n  newOptions.updateSnapshot =\n    argv.ci && !argv.updateSnapshot\n      ? 'none'\n      : argv.updateSnapshot\n      ? 'all'\n      : 'new';\n  newOptions.maxConcurrency = parseInt(newOptions.maxConcurrency, 10);\n  newOptions.maxWorkers = (0, _getMaxWorkers.default)(argv, options);\n\n  if (newOptions.testRegex.length && options.testMatch) {\n    throw createConfigError(\n      `  Configuration options ${_chalk().default.bold('testMatch')} and` +\n        ` ${_chalk().default.bold('testRegex')} cannot be used together.`\n    );\n  }\n\n  if (newOptions.testRegex.length && !options.testMatch) {\n    // Prevent the default testMatch conflicting with any explicitly\n    // configured `testRegex` value\n    newOptions.testMatch = [];\n  } // If argv.json is set, coverageReporters shouldn't print a text report.\n\n  if (argv.json) {\n    newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(\n      reporter => reporter !== 'text'\n    );\n  } // If collectCoverage is enabled while using --findRelatedTests we need to\n  // avoid having false negatives in the generated coverage report.\n  // The following: `--findRelatedTests '/rootDir/file1.js' --coverage`\n  // Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`\n  // where arguments to `--collectCoverageFrom` should be globs (or relative\n  // paths to the rootDir)\n\n  if (newOptions.collectCoverage && argv.findRelatedTests) {\n    let collectCoverageFrom = argv._.map(filename => {\n      filename = (0, _utils.replaceRootDirInPath)(options.rootDir, filename);\n      return _path().default.isAbsolute(filename)\n        ? _path().default.relative(options.rootDir, filename)\n        : filename;\n    }); // Don't override existing collectCoverageFrom options\n\n    if (newOptions.collectCoverageFrom) {\n      collectCoverageFrom = collectCoverageFrom.reduce((patterns, filename) => {\n        if (\n          !_micromatch().default.some(\n            (0, _jestUtil().replacePathSepForGlob)(\n              _path().default.relative(options.rootDir, filename)\n            ),\n            newOptions.collectCoverageFrom\n          )\n        ) {\n          return patterns;\n        }\n\n        return [...patterns, filename];\n      }, newOptions.collectCoverageFrom);\n    }\n\n    newOptions.collectCoverageFrom = collectCoverageFrom;\n  }\n\n  return {\n    hasDeprecationWarnings,\n    options: newOptions\n  };\n}\n"]},"metadata":{},"sourceType":"script"}