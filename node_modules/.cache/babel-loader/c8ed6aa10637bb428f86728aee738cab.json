{"ast":null,"code":"/**\n * Socket wrapping functions for TLS.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2012 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./tls');\n/**\n * Wraps a forge.net socket with a TLS layer.\n *\n * @param options:\n *   sessionId: a session ID to reuse, null for a new connection if no session\n *     cache is provided or it is empty.\n *   caStore: an array of certificates to trust.\n *   sessionCache: a session cache to use.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     tls.CipherSuites.\n *   socket: the socket to wrap.\n *   virtualHost: the virtual server name to use in a TLS SNI extension.\n *   verify: a handler used to custom verify certificates in the chain.\n *   getCertificate: an optional callback used to get a certificate.\n *   getPrivateKey: an optional callback used to get a private key.\n *   getSignature: an optional callback used to get a signature.\n *   deflate: function(inBytes) if provided, will deflate TLS records using\n *     the deflate algorithm if the server supports it.\n *   inflate: function(inBytes) if provided, will inflate TLS records using\n *     the deflate algorithm if the server supports it.\n *\n * @return the TLS-wrapped socket.\n */\n\n\nforge.tls.wrapSocket = function (options) {\n  // get raw socket\n  var socket = options.socket; // create TLS socket\n\n  var tlsSocket = {\n    id: socket.id,\n    // set handlers\n    connected: socket.connected || function (e) {},\n    closed: socket.closed || function (e) {},\n    data: socket.data || function (e) {},\n    error: socket.error || function (e) {}\n  }; // create TLS connection\n\n  var c = forge.tls.createConnection({\n    server: false,\n    sessionId: options.sessionId || null,\n    caStore: options.caStore || [],\n    sessionCache: options.sessionCache || null,\n    cipherSuites: options.cipherSuites || null,\n    virtualHost: options.virtualHost,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature,\n    deflate: options.deflate,\n    inflate: options.inflate,\n    connected: function (c) {\n      // first handshake complete, call handler\n      if (c.handshakes === 1) {\n        tlsSocket.connected({\n          id: socket.id,\n          type: 'connect',\n          bytesAvailable: c.data.length()\n        });\n      }\n    },\n    tlsDataReady: function (c) {\n      // send TLS data over socket\n      return socket.send(c.tlsData.getBytes());\n    },\n    dataReady: function (c) {\n      // indicate application data is ready\n      tlsSocket.data({\n        id: socket.id,\n        type: 'socketData',\n        bytesAvailable: c.data.length()\n      });\n    },\n    closed: function (c) {\n      // close socket\n      socket.close();\n    },\n    error: function (c, e) {\n      // send error, close socket\n      tlsSocket.error({\n        id: socket.id,\n        type: 'tlsError',\n        message: e.message,\n        bytesAvailable: 0,\n        error: e\n      });\n      socket.close();\n    }\n  }); // handle doing handshake after connecting\n\n  socket.connected = function (e) {\n    c.handshake(options.sessionId);\n  }; // handle closing TLS connection\n\n\n  socket.closed = function (e) {\n    if (c.open && c.handshaking) {\n      // error\n      tlsSocket.error({\n        id: socket.id,\n        type: 'ioError',\n        message: 'Connection closed during handshake.',\n        bytesAvailable: 0\n      });\n    }\n\n    c.close(); // call socket handler\n\n    tlsSocket.closed({\n      id: socket.id,\n      type: 'close',\n      bytesAvailable: 0\n    });\n  }; // handle error on socket\n\n\n  socket.error = function (e) {\n    // error\n    tlsSocket.error({\n      id: socket.id,\n      type: e.type,\n      message: e.message,\n      bytesAvailable: 0\n    });\n    c.close();\n  }; // handle receiving raw TLS data from socket\n\n\n  var _requiredBytes = 0;\n\n  socket.data = function (e) {\n    // drop data if connection not open\n    if (!c.open) {\n      socket.receive(e.bytesAvailable);\n    } else {\n      // only receive if there are enough bytes available to\n      // process a record\n      if (e.bytesAvailable >= _requiredBytes) {\n        var count = Math.max(e.bytesAvailable, _requiredBytes);\n        var data = socket.receive(count);\n\n        if (data !== null) {\n          _requiredBytes = c.process(data);\n        }\n      }\n    }\n  };\n  /**\n   * Destroys this socket.\n   */\n\n\n  tlsSocket.destroy = function () {\n    socket.destroy();\n  };\n  /**\n   * Sets this socket's TLS session cache. This should be called before\n   * the socket is connected or after it is closed.\n   *\n   * The cache is an object mapping session IDs to internal opaque state.\n   * An application might need to change the cache used by a particular\n   * tlsSocket between connections if it accesses multiple TLS hosts.\n   *\n   * @param cache the session cache to use.\n   */\n\n\n  tlsSocket.setSessionCache = function (cache) {\n    c.sessionCache = tls.createSessionCache(cache);\n  };\n  /**\n   * Connects this socket.\n   *\n   * @param options:\n   *           host: the host to connect to.\n   *           port: the port to connect to.\n   *           policyPort: the policy port to use (if non-default), 0 to\n   *              use the flash default.\n   *           policyUrl: the policy file URL to use (instead of port).\n   */\n\n\n  tlsSocket.connect = function (options) {\n    socket.connect(options);\n  };\n  /**\n   * Closes this socket.\n   */\n\n\n  tlsSocket.close = function () {\n    c.close();\n  };\n  /**\n   * Determines if the socket is connected or not.\n   *\n   * @return true if connected, false if not.\n   */\n\n\n  tlsSocket.isConnected = function () {\n    return c.isConnected && socket.isConnected();\n  };\n  /**\n   * Writes bytes to this socket.\n   *\n   * @param bytes the bytes (as a string) to write.\n   *\n   * @return true on success, false on failure.\n   */\n\n\n  tlsSocket.send = function (bytes) {\n    return c.prepare(bytes);\n  };\n  /**\n   * Reads bytes from this socket (non-blocking). Fewer than the number of\n   * bytes requested may be read if enough bytes are not available.\n   *\n   * This method should be called from the data handler if there are enough\n   * bytes available. To see how many bytes are available, check the\n   * 'bytesAvailable' property on the event in the data handler or call the\n   * bytesAvailable() function on the socket. If the browser is msie, then the\n   * bytesAvailable() function should be used to avoid race conditions.\n   * Otherwise, using the property on the data handler's event may be quicker.\n   *\n   * @param count the maximum number of bytes to read.\n   *\n   * @return the bytes read (as a string) or null on error.\n   */\n\n\n  tlsSocket.receive = function (count) {\n    return c.data.getBytes(count);\n  };\n  /**\n   * Gets the number of bytes available for receiving on the socket.\n   *\n   * @return the number of bytes available for receiving.\n   */\n\n\n  tlsSocket.bytesAvailable = function () {\n    return c.data.length();\n  };\n\n  return tlsSocket;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/node-forge/lib/tlssocket.js"],"names":["forge","require","tls","wrapSocket","options","socket","tlsSocket","id","connected","e","closed","data","error","c","createConnection","server","sessionId","caStore","sessionCache","cipherSuites","virtualHost","verify","getCertificate","getPrivateKey","getSignature","deflate","inflate","handshakes","type","bytesAvailable","length","tlsDataReady","send","tlsData","getBytes","dataReady","close","message","handshake","open","handshaking","_requiredBytes","receive","count","Math","max","process","destroy","setSessionCache","cache","createSessionCache","connect","isConnected","bytes","prepare"],"mappings":"AAAA;;;;;;;AAOA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,OAAD,CAAP;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBAD,KAAK,CAACE,GAAN,CAAUC,UAAV,GAAuB,UAASC,OAAT,EAAkB;AACvC;AACA,MAAIC,MAAM,GAAGD,OAAO,CAACC,MAArB,CAFuC,CAIvC;;AACA,MAAIC,SAAS,GAAG;AACdC,IAAAA,EAAE,EAAEF,MAAM,CAACE,EADG;AAEd;AACAC,IAAAA,SAAS,EAAEH,MAAM,CAACG,SAAP,IAAoB,UAASC,CAAT,EAAY,CAAE,CAH/B;AAIdC,IAAAA,MAAM,EAAEL,MAAM,CAACK,MAAP,IAAiB,UAASD,CAAT,EAAY,CAAE,CAJzB;AAKdE,IAAAA,IAAI,EAAEN,MAAM,CAACM,IAAP,IAAe,UAASF,CAAT,EAAY,CAAE,CALrB;AAMdG,IAAAA,KAAK,EAAEP,MAAM,CAACO,KAAP,IAAgB,UAASH,CAAT,EAAY,CAAE;AANvB,GAAhB,CALuC,CAcvC;;AACA,MAAII,CAAC,GAAGb,KAAK,CAACE,GAAN,CAAUY,gBAAV,CAA2B;AACjCC,IAAAA,MAAM,EAAE,KADyB;AAEjCC,IAAAA,SAAS,EAAEZ,OAAO,CAACY,SAAR,IAAqB,IAFC;AAGjCC,IAAAA,OAAO,EAAEb,OAAO,CAACa,OAAR,IAAmB,EAHK;AAIjCC,IAAAA,YAAY,EAAEd,OAAO,CAACc,YAAR,IAAwB,IAJL;AAKjCC,IAAAA,YAAY,EAAEf,OAAO,CAACe,YAAR,IAAwB,IALL;AAMjCC,IAAAA,WAAW,EAAEhB,OAAO,CAACgB,WANY;AAOjCC,IAAAA,MAAM,EAAEjB,OAAO,CAACiB,MAPiB;AAQjCC,IAAAA,cAAc,EAAElB,OAAO,CAACkB,cARS;AASjCC,IAAAA,aAAa,EAAEnB,OAAO,CAACmB,aATU;AAUjCC,IAAAA,YAAY,EAAEpB,OAAO,CAACoB,YAVW;AAWjCC,IAAAA,OAAO,EAAErB,OAAO,CAACqB,OAXgB;AAYjCC,IAAAA,OAAO,EAAEtB,OAAO,CAACsB,OAZgB;AAajClB,IAAAA,SAAS,EAAE,UAASK,CAAT,EAAY;AACrB;AACA,UAAGA,CAAC,CAACc,UAAF,KAAiB,CAApB,EAAuB;AACrBrB,QAAAA,SAAS,CAACE,SAAV,CAAoB;AAClBD,UAAAA,EAAE,EAAEF,MAAM,CAACE,EADO;AAElBqB,UAAAA,IAAI,EAAE,SAFY;AAGlBC,UAAAA,cAAc,EAAEhB,CAAC,CAACF,IAAF,CAAOmB,MAAP;AAHE,SAApB;AAKD;AACF,KAtBgC;AAuBjCC,IAAAA,YAAY,EAAE,UAASlB,CAAT,EAAY;AACxB;AACA,aAAOR,MAAM,CAAC2B,IAAP,CAAYnB,CAAC,CAACoB,OAAF,CAAUC,QAAV,EAAZ,CAAP;AACD,KA1BgC;AA2BjCC,IAAAA,SAAS,EAAE,UAAStB,CAAT,EAAY;AACrB;AACAP,MAAAA,SAAS,CAACK,IAAV,CAAe;AACbJ,QAAAA,EAAE,EAAEF,MAAM,CAACE,EADE;AAEbqB,QAAAA,IAAI,EAAE,YAFO;AAGbC,QAAAA,cAAc,EAAEhB,CAAC,CAACF,IAAF,CAAOmB,MAAP;AAHH,OAAf;AAKD,KAlCgC;AAmCjCpB,IAAAA,MAAM,EAAE,UAASG,CAAT,EAAY;AAClB;AACAR,MAAAA,MAAM,CAAC+B,KAAP;AACD,KAtCgC;AAuCjCxB,IAAAA,KAAK,EAAE,UAASC,CAAT,EAAYJ,CAAZ,EAAe;AACpB;AACAH,MAAAA,SAAS,CAACM,KAAV,CAAgB;AACdL,QAAAA,EAAE,EAAEF,MAAM,CAACE,EADG;AAEdqB,QAAAA,IAAI,EAAE,UAFQ;AAGdS,QAAAA,OAAO,EAAE5B,CAAC,CAAC4B,OAHG;AAIdR,QAAAA,cAAc,EAAE,CAJF;AAKdjB,QAAAA,KAAK,EAAEH;AALO,OAAhB;AAOAJ,MAAAA,MAAM,CAAC+B,KAAP;AACD;AAjDgC,GAA3B,CAAR,CAfuC,CAmEvC;;AACA/B,EAAAA,MAAM,CAACG,SAAP,GAAmB,UAASC,CAAT,EAAY;AAC7BI,IAAAA,CAAC,CAACyB,SAAF,CAAYlC,OAAO,CAACY,SAApB;AACD,GAFD,CApEuC,CAwEvC;;;AACAX,EAAAA,MAAM,CAACK,MAAP,GAAgB,UAASD,CAAT,EAAY;AAC1B,QAAGI,CAAC,CAAC0B,IAAF,IAAU1B,CAAC,CAAC2B,WAAf,EAA4B;AAC1B;AACAlC,MAAAA,SAAS,CAACM,KAAV,CAAgB;AACdL,QAAAA,EAAE,EAAEF,MAAM,CAACE,EADG;AAEdqB,QAAAA,IAAI,EAAE,SAFQ;AAGdS,QAAAA,OAAO,EAAE,qCAHK;AAIdR,QAAAA,cAAc,EAAE;AAJF,OAAhB;AAMD;;AACDhB,IAAAA,CAAC,CAACuB,KAAF,GAV0B,CAY1B;;AACA9B,IAAAA,SAAS,CAACI,MAAV,CAAiB;AACfH,MAAAA,EAAE,EAAEF,MAAM,CAACE,EADI;AAEfqB,MAAAA,IAAI,EAAE,OAFS;AAGfC,MAAAA,cAAc,EAAE;AAHD,KAAjB;AAKD,GAlBD,CAzEuC,CA6FvC;;;AACAxB,EAAAA,MAAM,CAACO,KAAP,GAAe,UAASH,CAAT,EAAY;AACzB;AACAH,IAAAA,SAAS,CAACM,KAAV,CAAgB;AACdL,MAAAA,EAAE,EAAEF,MAAM,CAACE,EADG;AAEdqB,MAAAA,IAAI,EAAEnB,CAAC,CAACmB,IAFM;AAGdS,MAAAA,OAAO,EAAE5B,CAAC,CAAC4B,OAHG;AAIdR,MAAAA,cAAc,EAAE;AAJF,KAAhB;AAMAhB,IAAAA,CAAC,CAACuB,KAAF;AACD,GATD,CA9FuC,CAyGvC;;;AACA,MAAIK,cAAc,GAAG,CAArB;;AACApC,EAAAA,MAAM,CAACM,IAAP,GAAc,UAASF,CAAT,EAAY;AACxB;AACA,QAAG,CAACI,CAAC,CAAC0B,IAAN,EAAY;AACVlC,MAAAA,MAAM,CAACqC,OAAP,CAAejC,CAAC,CAACoB,cAAjB;AACD,KAFD,MAEO;AACL;AACA;AACA,UAAGpB,CAAC,CAACoB,cAAF,IAAoBY,cAAvB,EAAuC;AACrC,YAAIE,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASpC,CAAC,CAACoB,cAAX,EAA2BY,cAA3B,CAAZ;AACA,YAAI9B,IAAI,GAAGN,MAAM,CAACqC,OAAP,CAAeC,KAAf,CAAX;;AACA,YAAGhC,IAAI,KAAK,IAAZ,EAAkB;AAChB8B,UAAAA,cAAc,GAAG5B,CAAC,CAACiC,OAAF,CAAUnC,IAAV,CAAjB;AACD;AACF;AACF;AACF,GAfD;AAiBA;;;;;AAGAL,EAAAA,SAAS,CAACyC,OAAV,GAAoB,YAAW;AAC7B1C,IAAAA,MAAM,CAAC0C,OAAP;AACD,GAFD;AAIA;;;;;;;;;;;;AAUAzC,EAAAA,SAAS,CAAC0C,eAAV,GAA4B,UAASC,KAAT,EAAgB;AAC1CpC,IAAAA,CAAC,CAACK,YAAF,GAAiBhB,GAAG,CAACgD,kBAAJ,CAAuBD,KAAvB,CAAjB;AACD,GAFD;AAIA;;;;;;;;;;;;AAUA3C,EAAAA,SAAS,CAAC6C,OAAV,GAAoB,UAAS/C,OAAT,EAAkB;AACpCC,IAAAA,MAAM,CAAC8C,OAAP,CAAe/C,OAAf;AACD,GAFD;AAIA;;;;;AAGAE,EAAAA,SAAS,CAAC8B,KAAV,GAAkB,YAAW;AAC3BvB,IAAAA,CAAC,CAACuB,KAAF;AACD,GAFD;AAIA;;;;;;;AAKA9B,EAAAA,SAAS,CAAC8C,WAAV,GAAwB,YAAW;AACjC,WAAOvC,CAAC,CAACuC,WAAF,IAAiB/C,MAAM,CAAC+C,WAAP,EAAxB;AACD,GAFD;AAIA;;;;;;;;;AAOA9C,EAAAA,SAAS,CAAC0B,IAAV,GAAiB,UAASqB,KAAT,EAAgB;AAC/B,WAAOxC,CAAC,CAACyC,OAAF,CAAUD,KAAV,CAAP;AACD,GAFD;AAIA;;;;;;;;;;;;;;;;;AAeA/C,EAAAA,SAAS,CAACoC,OAAV,GAAoB,UAASC,KAAT,EAAgB;AAClC,WAAO9B,CAAC,CAACF,IAAF,CAAOuB,QAAP,CAAgBS,KAAhB,CAAP;AACD,GAFD;AAIA;;;;;;;AAKArC,EAAAA,SAAS,CAACuB,cAAV,GAA2B,YAAW;AACpC,WAAOhB,CAAC,CAACF,IAAF,CAAOmB,MAAP,EAAP;AACD,GAFD;;AAIA,SAAOxB,SAAP;AACD,CAvND","sourcesContent":["/**\n * Socket wrapping functions for TLS.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2012 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./tls');\n\n/**\n * Wraps a forge.net socket with a TLS layer.\n *\n * @param options:\n *   sessionId: a session ID to reuse, null for a new connection if no session\n *     cache is provided or it is empty.\n *   caStore: an array of certificates to trust.\n *   sessionCache: a session cache to use.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     tls.CipherSuites.\n *   socket: the socket to wrap.\n *   virtualHost: the virtual server name to use in a TLS SNI extension.\n *   verify: a handler used to custom verify certificates in the chain.\n *   getCertificate: an optional callback used to get a certificate.\n *   getPrivateKey: an optional callback used to get a private key.\n *   getSignature: an optional callback used to get a signature.\n *   deflate: function(inBytes) if provided, will deflate TLS records using\n *     the deflate algorithm if the server supports it.\n *   inflate: function(inBytes) if provided, will inflate TLS records using\n *     the deflate algorithm if the server supports it.\n *\n * @return the TLS-wrapped socket.\n */\nforge.tls.wrapSocket = function(options) {\n  // get raw socket\n  var socket = options.socket;\n\n  // create TLS socket\n  var tlsSocket = {\n    id: socket.id,\n    // set handlers\n    connected: socket.connected || function(e) {},\n    closed: socket.closed || function(e) {},\n    data: socket.data || function(e) {},\n    error: socket.error || function(e) {}\n  };\n\n  // create TLS connection\n  var c = forge.tls.createConnection({\n    server: false,\n    sessionId: options.sessionId || null,\n    caStore: options.caStore || [],\n    sessionCache: options.sessionCache || null,\n    cipherSuites: options.cipherSuites || null,\n    virtualHost: options.virtualHost,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature,\n    deflate: options.deflate,\n    inflate: options.inflate,\n    connected: function(c) {\n      // first handshake complete, call handler\n      if(c.handshakes === 1) {\n        tlsSocket.connected({\n          id: socket.id,\n          type: 'connect',\n          bytesAvailable: c.data.length()\n        });\n      }\n    },\n    tlsDataReady: function(c) {\n      // send TLS data over socket\n      return socket.send(c.tlsData.getBytes());\n    },\n    dataReady: function(c) {\n      // indicate application data is ready\n      tlsSocket.data({\n        id: socket.id,\n        type: 'socketData',\n        bytesAvailable: c.data.length()\n      });\n    },\n    closed: function(c) {\n      // close socket\n      socket.close();\n    },\n    error: function(c, e) {\n      // send error, close socket\n      tlsSocket.error({\n        id: socket.id,\n        type: 'tlsError',\n        message: e.message,\n        bytesAvailable: 0,\n        error: e\n      });\n      socket.close();\n    }\n  });\n\n  // handle doing handshake after connecting\n  socket.connected = function(e) {\n    c.handshake(options.sessionId);\n  };\n\n  // handle closing TLS connection\n  socket.closed = function(e) {\n    if(c.open && c.handshaking) {\n      // error\n      tlsSocket.error({\n        id: socket.id,\n        type: 'ioError',\n        message: 'Connection closed during handshake.',\n        bytesAvailable: 0\n      });\n    }\n    c.close();\n\n    // call socket handler\n    tlsSocket.closed({\n      id: socket.id,\n      type: 'close',\n      bytesAvailable: 0\n    });\n  };\n\n  // handle error on socket\n  socket.error = function(e) {\n    // error\n    tlsSocket.error({\n      id: socket.id,\n      type: e.type,\n      message: e.message,\n      bytesAvailable: 0\n    });\n    c.close();\n  };\n\n  // handle receiving raw TLS data from socket\n  var _requiredBytes = 0;\n  socket.data = function(e) {\n    // drop data if connection not open\n    if(!c.open) {\n      socket.receive(e.bytesAvailable);\n    } else {\n      // only receive if there are enough bytes available to\n      // process a record\n      if(e.bytesAvailable >= _requiredBytes) {\n        var count = Math.max(e.bytesAvailable, _requiredBytes);\n        var data = socket.receive(count);\n        if(data !== null) {\n          _requiredBytes = c.process(data);\n        }\n      }\n    }\n  };\n\n  /**\n   * Destroys this socket.\n   */\n  tlsSocket.destroy = function() {\n    socket.destroy();\n  };\n\n  /**\n   * Sets this socket's TLS session cache. This should be called before\n   * the socket is connected or after it is closed.\n   *\n   * The cache is an object mapping session IDs to internal opaque state.\n   * An application might need to change the cache used by a particular\n   * tlsSocket between connections if it accesses multiple TLS hosts.\n   *\n   * @param cache the session cache to use.\n   */\n  tlsSocket.setSessionCache = function(cache) {\n    c.sessionCache = tls.createSessionCache(cache);\n  };\n\n  /**\n   * Connects this socket.\n   *\n   * @param options:\n   *           host: the host to connect to.\n   *           port: the port to connect to.\n   *           policyPort: the policy port to use (if non-default), 0 to\n   *              use the flash default.\n   *           policyUrl: the policy file URL to use (instead of port).\n   */\n  tlsSocket.connect = function(options) {\n    socket.connect(options);\n  };\n\n  /**\n   * Closes this socket.\n   */\n  tlsSocket.close = function() {\n    c.close();\n  };\n\n  /**\n   * Determines if the socket is connected or not.\n   *\n   * @return true if connected, false if not.\n   */\n  tlsSocket.isConnected = function() {\n    return c.isConnected && socket.isConnected();\n  };\n\n  /**\n   * Writes bytes to this socket.\n   *\n   * @param bytes the bytes (as a string) to write.\n   *\n   * @return true on success, false on failure.\n   */\n  tlsSocket.send = function(bytes) {\n    return c.prepare(bytes);\n  };\n\n  /**\n   * Reads bytes from this socket (non-blocking). Fewer than the number of\n   * bytes requested may be read if enough bytes are not available.\n   *\n   * This method should be called from the data handler if there are enough\n   * bytes available. To see how many bytes are available, check the\n   * 'bytesAvailable' property on the event in the data handler or call the\n   * bytesAvailable() function on the socket. If the browser is msie, then the\n   * bytesAvailable() function should be used to avoid race conditions.\n   * Otherwise, using the property on the data handler's event may be quicker.\n   *\n   * @param count the maximum number of bytes to read.\n   *\n   * @return the bytes read (as a string) or null on error.\n   */\n  tlsSocket.receive = function(count) {\n    return c.data.getBytes(count);\n  };\n\n  /**\n   * Gets the number of bytes available for receiving on the socket.\n   *\n   * @return the number of bytes available for receiving.\n   */\n  tlsSocket.bytesAvailable = function() {\n    return c.data.length();\n  };\n\n  return tlsSocket;\n};\n"]},"metadata":{},"sourceType":"script"}