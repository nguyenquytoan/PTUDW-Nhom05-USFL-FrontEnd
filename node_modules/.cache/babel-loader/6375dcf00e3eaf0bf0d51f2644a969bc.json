{"ast":null,"code":"import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n  constructor(assertDeepEqual) {\n    super(VirtualAction, defaultMaxFrame);\n    this.assertDeepEqual = assertDeepEqual;\n    this.hotObservables = [];\n    this.coldObservables = [];\n    this.flushTests = [];\n    this.runMode = false;\n  }\n\n  createTime(marbles) {\n    const indexOf = marbles.indexOf('|');\n\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n\n    return indexOf * TestScheduler.frameTimeFactor;\n  }\n\n  createColdObservable(marbles, values, error) {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const cold = new ColdObservable(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  }\n\n  createHotObservable(marbles, values, error) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const subject = new HotObservable(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  }\n\n  materializeInnerObservable(observable, outerFrame) {\n    const messages = [];\n    observable.subscribe(value => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createNext(value)\n      });\n    }, err => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createError(err)\n      });\n    }, () => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createComplete()\n      });\n    });\n    return messages;\n  }\n\n  expectObservable(observable, subscriptionMarbles = null) {\n    const actual = [];\n    const flushTest = {\n      actual,\n      ready: false\n    };\n    const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n    const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ? 0 : subscriptionParsed.subscribedFrame;\n    const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n    let subscription;\n    this.schedule(() => {\n      subscription = observable.subscribe(x => {\n        let value = x;\n\n        if (x instanceof Observable) {\n          value = this.materializeInnerObservable(value, this.frame);\n        }\n\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createNext(value)\n        });\n      }, err => {\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createError(err)\n        });\n      }, () => {\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createComplete()\n        });\n      });\n    }, subscriptionFrame);\n\n    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n    const {\n      runMode\n    } = this;\n    return {\n      toBe(marbles, values, errorValue) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n      }\n\n    };\n  }\n\n  expectSubscriptions(actualSubscriptionLogs) {\n    const flushTest = {\n      actual: actualSubscriptionLogs,\n      ready: false\n    };\n    this.flushTests.push(flushTest);\n    const {\n      runMode\n    } = this;\n    return {\n      toBe(marbles) {\n        const marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n      }\n\n    };\n  }\n\n  flush() {\n    const hotObservables = this.hotObservables;\n\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n\n    super.flush();\n    this.flushTests = this.flushTests.filter(test => {\n      if (test.ready) {\n        this.assertDeepEqual(test.actual, test.expected);\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  static parseMarblesAsSubscriptions(marbles, runMode = false) {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Number.POSITIVE_INFINITY);\n    }\n\n    const len = marbles.length;\n    let groupStart = -1;\n    let subscriptionFrame = Number.POSITIVE_INFINITY;\n    let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n    let frame = 0;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n\n      const advanceFrameBy = count => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n\n      const c = marbles[i];\n\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n\n          break;\n\n        case '-':\n          advanceFrameBy(1);\n          break;\n\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n\n        case '^':\n          if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          advanceFrameBy(1);\n          break;\n\n        case '!':\n          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || marbles[i - 1] === ' ') {\n              const buffer = marbles.slice(i);\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n      }\n\n      frame = nextFrame;\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  }\n\n  static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n\n    const len = marbles.length;\n    const testMessages = [];\n    const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n    let frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    const getValue = typeof values !== 'object' ? x => x : x => {\n      if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n        return values[x].messages;\n      }\n\n      return values[x];\n    };\n    let groupStart = -1;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n\n      const advanceFrameBy = count => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n\n      let notification;\n      const c = marbles[i];\n\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n\n          break;\n\n        case '-':\n          advanceFrameBy(1);\n          break;\n\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n\n        case '|':\n          notification = Notification.createComplete();\n          advanceFrameBy(1);\n          break;\n\n        case '^':\n          advanceFrameBy(1);\n          break;\n\n        case '#':\n          notification = Notification.createError(errorValue || 'error');\n          advanceFrameBy(1);\n          break;\n\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || marbles[i - 1] === ' ') {\n              const buffer = marbles.slice(i);\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          notification = Notification.createNext(getValue(c));\n          advanceFrameBy(1);\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({\n          frame: groupStart > -1 ? groupStart : frame,\n          notification\n        });\n      }\n\n      frame = nextFrame;\n    }\n\n    return testMessages;\n  }\n\n  run(callback) {\n    const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n    const prevMaxFrames = this.maxFrames;\n    TestScheduler.frameTimeFactor = 1;\n    this.maxFrames = Number.POSITIVE_INFINITY;\n    this.runMode = true;\n    AsyncScheduler.delegate = this;\n    const helpers = {\n      cold: this.createColdObservable.bind(this),\n      hot: this.createHotObservable.bind(this),\n      flush: this.flush.bind(this),\n      expectObservable: this.expectObservable.bind(this),\n      expectSubscriptions: this.expectSubscriptions.bind(this)\n    };\n\n    try {\n      const ret = callback(helpers);\n      this.flush();\n      return ret;\n    } finally {\n      TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n      this.maxFrames = prevMaxFrames;\n      this.runMode = false;\n      AsyncScheduler.delegate = undefined;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/internal/testing/TestScheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n    constructor(assertDeepEqual) {\n        super(VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n        this.runMode = false;\n    }\n    createTime(marbles) {\n        const indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    }\n    createColdObservable(marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const cold = new ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    }\n    createHotObservable(marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const subject = new HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    }\n    materializeInnerObservable(observable, outerFrame) {\n        const messages = [];\n        observable.subscribe((value) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createNext(value) });\n        }, (err) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createError(err) });\n        }, () => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createComplete() });\n        });\n        return messages;\n    }\n    expectObservable(observable, subscriptionMarbles = null) {\n        const actual = [];\n        const flushTest = { actual, ready: false };\n        const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n        const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?\n            0 : subscriptionParsed.subscribedFrame;\n        const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n        let subscription;\n        this.schedule(() => {\n            subscription = observable.subscribe(x => {\n                let value = x;\n                if (x instanceof Observable) {\n                    value = this.materializeInnerObservable(value, this.frame);\n                }\n                actual.push({ frame: this.frame, notification: Notification.createNext(value) });\n            }, (err) => {\n                actual.push({ frame: this.frame, notification: Notification.createError(err) });\n            }, () => {\n                actual.push({ frame: this.frame, notification: Notification.createComplete() });\n            });\n        }, subscriptionFrame);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n            }\n        };\n    }\n    expectSubscriptions(actualSubscriptionLogs) {\n        const flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles) {\n                const marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n            }\n        };\n    }\n    flush() {\n        const hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        super.flush();\n        this.flushTests = this.flushTests.filter(test => {\n            if (test.ready) {\n                this.assertDeepEqual(test.actual, test.expected);\n                return false;\n            }\n            return true;\n        });\n    }\n    static parseMarblesAsSubscriptions(marbles, runMode = false) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        const len = marbles.length;\n        let groupStart = -1;\n        let subscriptionFrame = Number.POSITIVE_INFINITY;\n        let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        let frame = 0;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    advanceFrameBy(1);\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n            frame = nextFrame;\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    }\n    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        const len = marbles.length;\n        const testMessages = [];\n        const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n        let frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        const getValue = typeof values !== 'object' ?\n            (x) => x :\n            (x) => {\n                if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        let groupStart = -1;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            let notification;\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '|':\n                    notification = Notification.createComplete();\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    advanceFrameBy(1);\n                    break;\n                case '#':\n                    notification = Notification.createError(errorValue || 'error');\n                    advanceFrameBy(1);\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    notification = Notification.createNext(getValue(c));\n                    advanceFrameBy(1);\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n            }\n            frame = nextFrame;\n        }\n        return testMessages;\n    }\n    run(callback) {\n        const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n        const prevMaxFrames = this.maxFrames;\n        TestScheduler.frameTimeFactor = 1;\n        this.maxFrames = Number.POSITIVE_INFINITY;\n        this.runMode = true;\n        AsyncScheduler.delegate = this;\n        const helpers = {\n            cold: this.createColdObservable.bind(this),\n            hot: this.createHotObservable.bind(this),\n            flush: this.flush.bind(this),\n            expectObservable: this.expectObservable.bind(this),\n            expectSubscriptions: this.expectSubscriptions.bind(this),\n        };\n        try {\n            const ret = callback(helpers);\n            this.flush();\n            return ret;\n        }\n        finally {\n            TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n            this.maxFrames = prevMaxFrames;\n            this.runMode = false;\n            AsyncScheduler.delegate = undefined;\n        }\n    }\n}\n//# sourceMappingURL=TestScheduler.js.map"]},"metadata":{},"sourceType":"module"}