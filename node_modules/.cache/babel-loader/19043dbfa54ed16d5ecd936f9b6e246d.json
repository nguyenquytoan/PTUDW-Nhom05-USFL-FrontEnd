{"ast":null,"code":"/**\n * Filesystem cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n * @see https://github.com/babel/babel-loader/blob/master/src/fs-cache.js\n */\nvar crypto = require(\"crypto\");\n\nvar mkdirp = require(\"mkdirp\");\n\nvar findCacheDir = require(\"find-cache-dir\");\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar zlib = require(\"zlib\");\n\nvar defaultCacheDirectory = null; // Lazily instantiated when needed\n\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Function} callback\n */\n\nvar read = function (filename, callback) {\n  return fs.readFile(filename, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    return zlib.gunzip(data, function (err, content) {\n      var result = {};\n\n      if (err) {\n        return callback(err);\n      }\n\n      try {\n        result = JSON.parse(content);\n      } catch (e) {\n        return callback(e);\n      }\n\n      return callback(null, result);\n    });\n  });\n};\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {String} result\n * @params {Function} callback\n */\n\n\nvar write = function (filename, result, callback) {\n  var content = JSON.stringify(result);\n  return zlib.gzip(content, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    return fs.writeFile(filename, data, callback);\n  });\n};\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\n\n\nvar filename = function (source, identifier, options) {\n  var hash = crypto.createHash(\"SHA1\");\n  var contents = JSON.stringify({\n    source: source,\n    options: options,\n    identifier: identifier\n  });\n  hash.end(contents);\n  return hash.read().toString(\"hex\") + \".json.gz\";\n};\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n * @params {Function} callback\n */\n\n\nvar handleCache = function (directory, params, callback) {\n  var source = params.source;\n  var options = params.options || {};\n  var transform = params.transform;\n  var identifier = params.identifier;\n  var shouldFallback = typeof params.directory !== \"string\" && directory !== os.tmpdir(); // Make sure the directory exists.\n\n  mkdirp(directory, function (err) {\n    // Fallback to tmpdir if node_modules folder not writable\n    if (err) return shouldFallback ? handleCache(os.tmpdir(), params, callback) : callback(err);\n    var file = path.join(directory, filename(source, identifier, options));\n    return read(file, function (err, content) {\n      var result = {}; // No errors mean that the file was previously cached\n      // we just need to return it\n\n      if (!err) return callback(null, content); // Otherwise just transform the file\n      // return it to the user asap and write it in cache\n\n      try {\n        result = transform(source, options);\n      } catch (error) {\n        return callback(error);\n      }\n\n      return write(file, result, function (err) {\n        // Fallback to tmpdir if node_modules folder not writable\n        if (err) return shouldFallback ? handleCache(os.tmpdir(), params, callback) : callback(err);\n        callback(null, result);\n      });\n    });\n  });\n};\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.directory  Directory to store cached files\n * @param  {String}   params.identifier Unique identifier to bust cache\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n * @param  {Function} params.transform  Function that will transform the\n *                                      original file and whose result will be\n *                                      cached\n *\n * @param  {Function<err, result>} callback\n *\n * @example\n *\n *   cache({\n *     directory: '.tmp/cache',\n *     identifier: 'babel-loader-cachefile',\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *     transform: function(source, options) {\n *       var content = *do what you need with the source*\n *       return content\n *     }\n *   }, function(err, result) {\n *\n *   })\n */\n\n\nmodule.exports = function createFsCache(name) {\n  return function (params, callback) {\n    var directory;\n\n    if (typeof params.directory === \"string\") {\n      directory = params.directory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: name\n        }) || os.tmpdir();\n      }\n\n      directory = defaultCacheDirectory;\n    }\n\n    handleCache(directory, params, callback);\n  };\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/loader-fs-cache/index.js"],"names":["crypto","require","mkdirp","findCacheDir","fs","os","path","zlib","defaultCacheDirectory","read","filename","callback","readFile","err","data","gunzip","content","result","JSON","parse","e","write","stringify","gzip","writeFile","source","identifier","options","hash","createHash","contents","end","toString","handleCache","directory","params","transform","shouldFallback","tmpdir","file","join","error","module","exports","createFsCache","name"],"mappings":"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","sourcesContent":["/**\n * Filesystem cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n * @see https://github.com/babel/babel-loader/blob/master/src/fs-cache.js\n */\nvar crypto = require(\"crypto\");\nvar mkdirp = require(\"mkdirp\");\nvar findCacheDir = require(\"find-cache-dir\");\nvar fs = require(\"fs\");\nvar os = require(\"os\");\nvar path = require(\"path\");\nvar zlib = require(\"zlib\");\n\nvar defaultCacheDirectory = null; // Lazily instantiated when needed\n\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Function} callback\n */\nvar read = function(filename, callback) {\n  return fs.readFile(filename, function(err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    return zlib.gunzip(data, function(err, content) {\n      var result = {};\n\n      if (err) {\n        return callback(err);\n      }\n\n      try {\n        result = JSON.parse(content);\n      } catch (e) {\n        return callback(e);\n      }\n\n      return callback(null, result);\n    });\n  });\n};\n\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {String} result\n * @params {Function} callback\n */\nvar write = function(filename, result, callback) {\n  var content = JSON.stringify(result);\n\n  return zlib.gzip(content, function(err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    return fs.writeFile(filename, data, callback);\n  });\n};\n\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\nvar filename = function(source, identifier, options) {\n  var hash = crypto.createHash(\"SHA1\");\n  var contents = JSON.stringify({\n    source: source,\n    options: options,\n    identifier: identifier\n  });\n\n  hash.end(contents);\n\n  return hash.read().toString(\"hex\") + \".json.gz\";\n};\n\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n * @params {Function} callback\n */\nvar handleCache = function(directory, params, callback) {\n  var source = params.source;\n  var options = params.options || {};\n  var transform = params.transform;\n  var identifier = params.identifier;\n  var shouldFallback = typeof params.directory !== \"string\" &&\n    directory !== os.tmpdir();\n\n  // Make sure the directory exists.\n  mkdirp(directory, function(err) {\n    // Fallback to tmpdir if node_modules folder not writable\n    if (err)\n      return shouldFallback\n        ? handleCache(os.tmpdir(), params, callback)\n        : callback(err);\n\n    var file = path.join(directory, filename(source, identifier, options));\n\n    return read(file, function(err, content) {\n      var result = {};\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      if (!err) return callback(null, content);\n\n      // Otherwise just transform the file\n      // return it to the user asap and write it in cache\n      try {\n        result = transform(source, options);\n      } catch (error) {\n        return callback(error);\n      }\n\n      return write(file, result, function(err) {\n        // Fallback to tmpdir if node_modules folder not writable\n        if (err)\n          return shouldFallback\n            ? handleCache(os.tmpdir(), params, callback)\n            : callback(err);\n\n        callback(null, result);\n      });\n    });\n  });\n};\n\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.directory  Directory to store cached files\n * @param  {String}   params.identifier Unique identifier to bust cache\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n * @param  {Function} params.transform  Function that will transform the\n *                                      original file and whose result will be\n *                                      cached\n *\n * @param  {Function<err, result>} callback\n *\n * @example\n *\n *   cache({\n *     directory: '.tmp/cache',\n *     identifier: 'babel-loader-cachefile',\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *     transform: function(source, options) {\n *       var content = *do what you need with the source*\n *       return content\n *     }\n *   }, function(err, result) {\n *\n *   })\n */\n\nmodule.exports = function createFsCache(name) {\n  return function(params, callback) {\n    var directory;\n\n    if (typeof params.directory === \"string\") {\n      directory = params.directory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: name\n        }) ||\n          os.tmpdir();\n      }\n      directory = defaultCacheDirectory;\n    }\n    handleCache(directory, params, callback);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}