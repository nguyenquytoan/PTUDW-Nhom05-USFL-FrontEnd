{"ast":null,"code":"/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding within blocks\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padded-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          blocks: {\n            enum: [\"always\", \"never\"]\n          },\n          switches: {\n            enum: [\"always\", \"never\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLineBlocks: {\n          type: \"boolean\"\n        }\n      }\n    }]\n  },\n\n  create(context) {\n    const options = {};\n    const typeOptions = context.options[0] || \"always\";\n    const exceptOptions = context.options[1] || {};\n\n    if (typeof typeOptions === \"string\") {\n      const shouldHavePadding = typeOptions === \"always\";\n      options.blocks = shouldHavePadding;\n      options.switches = shouldHavePadding;\n      options.classes = shouldHavePadding;\n    } else {\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n        options.blocks = typeOptions.blocks === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n        options.switches = typeOptions.switches === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n        options.classes = typeOptions.classes === \"always\";\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n    }\n\n    const ALWAYS_MESSAGE = \"Block must be padded by blank lines.\",\n          NEVER_MESSAGE = \"Block must not be padded by blank lines.\";\n    const sourceCode = context.getSourceCode();\n    /**\n     * Gets the open brace token from a given node.\n     * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n     * @returns {Token} The token of the open brace.\n     */\n\n    function getOpenBrace(node) {\n      if (node.type === \"SwitchStatement\") {\n        return sourceCode.getTokenBefore(node.cases[0]);\n      }\n\n      return sourceCode.getFirstToken(node);\n    }\n    /**\n     * Checks if the given parameter is a comment node\n     * @param {ASTNode|Token} node An AST node or token\n     * @returns {boolean} True if node is a comment\n     */\n\n\n    function isComment(node) {\n      return node.type === \"Line\" || node.type === \"Block\";\n    }\n    /**\n     * Checks if there is padding between two tokens\n     * @param {Token} first The first token\n     * @param {Token} second The second token\n     * @returns {boolean} True if there is at least a line between the tokens\n     */\n\n\n    function isPaddingBetweenTokens(first, second) {\n      return second.loc.start.line - first.loc.end.line >= 2;\n    }\n    /**\n     * Checks if the given token has a blank line after it.\n     * @param {Token} token The token to check.\n     * @returns {boolean} Whether or not the token is followed by a blank line.\n     */\n\n\n    function getFirstBlockToken(token) {\n      let prev,\n          first = token;\n\n      do {\n        prev = first;\n        first = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        });\n      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n      return first;\n    }\n    /**\n     * Checks if the given token is preceeded by a blank line.\n     * @param {Token} token The token to check\n     * @returns {boolean} Whether or not the token is preceeded by a blank line\n     */\n\n\n    function getLastBlockToken(token) {\n      let last = token,\n          next;\n\n      do {\n        next = last;\n        last = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n      } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n      return last;\n    }\n    /**\n     * Checks if a node should be padded, according to the rule config.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {boolean} True if the node should be padded, false otherwise.\n     */\n\n\n    function requirePaddingFor(node) {\n      switch (node.type) {\n        case \"BlockStatement\":\n          return options.blocks;\n\n        case \"SwitchStatement\":\n          return options.switches;\n\n        case \"ClassBody\":\n          return options.classes;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n    }\n    /**\n     * Checks the given BlockStatement node to be padded if the block is not empty.\n     * @param {ASTNode} node The AST node of a BlockStatement.\n     * @returns {void} undefined.\n     */\n\n\n    function checkPadding(node) {\n      const openBrace = getOpenBrace(node),\n            firstBlockToken = getFirstBlockToken(openBrace),\n            tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {\n        includeComments: true\n      }),\n            closeBrace = sourceCode.getLastToken(node),\n            lastBlockToken = getLastBlockToken(closeBrace),\n            tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {\n        includeComments: true\n      }),\n            blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n            blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n        return;\n      }\n\n      if (requirePaddingFor(node)) {\n        if (!blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              line: tokenBeforeFirst.loc.start.line,\n              column: tokenBeforeFirst.loc.start.column\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n            },\n\n            message: ALWAYS_MESSAGE\n          });\n        }\n\n        if (!blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              line: tokenAfterLast.loc.end.line,\n              column: tokenAfterLast.loc.end.column - 1\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n            },\n\n            message: ALWAYS_MESSAGE\n          });\n        }\n      } else {\n        if (blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              line: tokenBeforeFirst.loc.start.line,\n              column: tokenBeforeFirst.loc.start.column\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n            },\n\n            message: NEVER_MESSAGE\n          });\n        }\n\n        if (blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              line: tokenAfterLast.loc.end.line,\n              column: tokenAfterLast.loc.end.column - 1\n            },\n            message: NEVER_MESSAGE,\n\n            fix(fixer) {\n              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n            }\n\n          });\n        }\n      }\n    }\n\n    const rule = {};\n\n    if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n      rule.SwitchStatement = function (node) {\n        if (node.cases.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n      rule.BlockStatement = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n      rule.ClassBody = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    return rule;\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/padded-blocks.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","blocks","switches","classes","additionalProperties","minProperties","allowSingleLineBlocks","create","context","options","typeOptions","exceptOptions","shouldHavePadding","Object","prototype","hasOwnProperty","call","ALWAYS_MESSAGE","NEVER_MESSAGE","sourceCode","getSourceCode","getOpenBrace","node","getTokenBefore","cases","getFirstToken","isComment","isPaddingBetweenTokens","first","second","loc","start","line","end","getFirstBlockToken","token","prev","getTokenAfter","includeComments","getLastBlockToken","last","next","requirePaddingFor","Error","checkPadding","openBrace","firstBlockToken","tokenBeforeFirst","closeBrace","getLastToken","lastBlockToken","tokenAfterLast","blockHasTopPadding","blockHasBottomPadding","isTokenOnSameLine","report","column","fix","fixer","insertTextAfter","message","insertTextBefore","replaceTextRange","range","rule","SwitchStatement","length","BlockStatement","body","ClassBody"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padded-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLineBlocks: {\n                        type: \"boolean\"\n                    }\n                }\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {};\n        const typeOptions = context.options[0] || \"always\";\n        const exceptOptions = context.options[1] || {};\n\n        if (typeof typeOptions === \"string\") {\n            const shouldHavePadding = typeOptions === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n                options.blocks = typeOptions.blocks === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n                options.switches = typeOptions.switches === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n                options.classes = typeOptions.classes === \"always\";\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n        }\n\n        const ALWAYS_MESSAGE = \"Block must be padded by blank lines.\",\n            NEVER_MESSAGE = \"Block must not be padded by blank lines.\";\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceeded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceeded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n                return;\n            }\n\n            if (requirePaddingFor(node)) {\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        message: NEVER_MESSAGE\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        message: NEVER_MESSAGE,\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}