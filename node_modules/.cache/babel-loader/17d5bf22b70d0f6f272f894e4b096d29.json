{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.expiration = function (t, e, s, i, a, n) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:expiration:4.3.1\"] && _();\n  } catch (t) {}\n\n  const h = \"workbox-expiration\",\n        c = \"cache-entries\",\n        r = t => {\n    const e = new URL(t, location);\n    return e.hash = \"\", e.href;\n  };\n\n  class o {\n    constructor(t) {\n      this.t = t, this.s = new e.DBWrapper(h, 1, {\n        onupgradeneeded: t => this.i(t)\n      });\n    }\n\n    i(t) {\n      const e = t.target.result.createObjectStore(c, {\n        keyPath: \"id\"\n      });\n      e.createIndex(\"cacheName\", \"cacheName\", {\n        unique: !1\n      }), e.createIndex(\"timestamp\", \"timestamp\", {\n        unique: !1\n      }), s.deleteDatabase(this.t);\n    }\n\n    async setTimestamp(t, e) {\n      t = r(t), await this.s.put(c, {\n        url: t,\n        timestamp: e,\n        cacheName: this.t,\n        id: this.h(t)\n      });\n    }\n\n    async getTimestamp(t) {\n      return (await this.s.get(c, this.h(t))).timestamp;\n    }\n\n    async expireEntries(t, e) {\n      const s = await this.s.transaction(c, \"readwrite\", (s, i) => {\n        const a = s.objectStore(c),\n              n = [];\n        let h = 0;\n\n        a.index(\"timestamp\").openCursor(null, \"prev\").onsuccess = ({\n          target: s\n        }) => {\n          const a = s.result;\n\n          if (a) {\n            const s = a.value;\n            s.cacheName === this.t && (t && s.timestamp < t || e && h >= e ? n.push(a.value) : h++), a.continue();\n          } else i(n);\n        };\n      }),\n            i = [];\n\n      for (const t of s) await this.s.delete(c, t.id), i.push(t.url);\n\n      return i;\n    }\n\n    h(t) {\n      return this.t + \"|\" + r(t);\n    }\n\n  }\n\n  class u {\n    constructor(t, e = {}) {\n      this.o = !1, this.u = !1, this.l = e.maxEntries, this.p = e.maxAgeSeconds, this.t = t, this.m = new o(t);\n    }\n\n    async expireEntries() {\n      if (this.o) return void (this.u = !0);\n      this.o = !0;\n      const t = this.p ? Date.now() - 1e3 * this.p : void 0,\n            e = await this.m.expireEntries(t, this.l),\n            s = await caches.open(this.t);\n\n      for (const t of e) await s.delete(t);\n\n      this.o = !1, this.u && (this.u = !1, this.expireEntries());\n    }\n\n    async updateTimestamp(t) {\n      await this.m.setTimestamp(t, Date.now());\n    }\n\n    async isURLExpired(t) {\n      return (await this.m.getTimestamp(t)) < Date.now() - 1e3 * this.p;\n    }\n\n    async delete() {\n      this.u = !1, await this.m.expireEntries(1 / 0);\n    }\n\n  }\n\n  return t.CacheExpiration = u, t.Plugin = class {\n    constructor(t = {}) {\n      this.D = t, this.p = t.maxAgeSeconds, this.g = new Map(), t.purgeOnQuotaError && n.registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n\n    k(t) {\n      if (t === a.cacheNames.getRuntimeName()) throw new i.WorkboxError(\"expire-custom-caches-only\");\n      let e = this.g.get(t);\n      return e || (e = new u(t, this.D), this.g.set(t, e)), e;\n    }\n\n    cachedResponseWillBeUsed({\n      event: t,\n      request: e,\n      cacheName: s,\n      cachedResponse: i\n    }) {\n      if (!i) return null;\n      let a = this.N(i);\n      const n = this.k(s);\n      n.expireEntries();\n      const h = n.updateTimestamp(e.url);\n      if (t) try {\n        t.waitUntil(h);\n      } catch (t) {}\n      return a ? i : null;\n    }\n\n    N(t) {\n      if (!this.p) return !0;\n\n      const e = this._(t);\n\n      return null === e || e >= Date.now() - 1e3 * this.p;\n    }\n\n    _(t) {\n      if (!t.headers.has(\"date\")) return null;\n      const e = t.headers.get(\"date\"),\n            s = new Date(e).getTime();\n      return isNaN(s) ? null : s;\n    }\n\n    async cacheDidUpdate({\n      cacheName: t,\n      request: e\n    }) {\n      const s = this.k(t);\n      await s.updateTimestamp(e.url), await s.expireEntries();\n    }\n\n    async deleteCacheAndMetadata() {\n      for (const [t, e] of this.g) await caches.delete(t), await e.delete();\n\n      this.g = new Map();\n    }\n\n  }, t;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core);","map":{"version":3,"sources":["../_version.mjs","../models/CacheTimestampsModel.mjs","../CacheExpiration.mjs","../Plugin.mjs"],"names":["self","_","e","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","URL","location","hash","href","CacheTimestampsModel","constructor","cacheName","_cacheName","_db","DBWrapper","onupgradeneeded","event","this","_handleUpgrade","target","result","objStore","createObjectStore","keyPath","createIndex","unique","deleteDatabase","timestamp","put","id","_getId","get","minTimestamp","maxCount","entriesToDelete","transaction","txn","done","store","objectStore","entriesNotDeletedCount","index","openCursor","onsuccess","cursor","value","push","continue","urlsDeleted","entry","delete","CacheExpiration","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_timestampModel","Date","now","undefined","urlsExpired","expireEntries","cache","caches","open","setTimestamp","getTimestamp","Infinity","_config","_cacheExpirations","Map","purgeOnQuotaError","registerQuotaErrorCallback","deleteCacheAndMetadata","_getCacheExpiration","cacheNames","getRuntimeName","WorkboxError","cacheExpiration","set","cachedResponseWillBeUsed","request","cachedResponse","isFresh","_isResponseDateFresh","updateTimestampDone","updateTimestamp","waitUntil","error","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","has","dateHeader","headerTime","getTime","isNaN"],"mappings":"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","sourcesContent":["try{self['workbox:expiration:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\nimport '../_version.mjs';\n\n\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\n\nconst normalizeURL = (unNormalizedUrl) => {\n  const url = new URL(unNormalizedUrl, location);\n  url.hash = '';\n\n  return url.href;\n};\n\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheName;\n\n    this._db = new DBWrapper(DB_NAME, 1, {\n      onupgradeneeded: (event) => this._handleUpgrade(event),\n    });\n  }\n\n  /**\n   * Should perform an upgrade of indexedDB.\n   *\n   * @param {Event} event\n   *\n   * @private\n   */\n  _handleUpgrade(event) {\n    const db = event.target.result;\n\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\n\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\n\n    // Previous versions of `workbox-expiration` used `this._cacheName`\n    // as the IDBDatabase name.\n    deleteDatabase(this._cacheName);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n\n    await this._db.put(OBJECT_STORE_NAME, {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url),\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n    return entry.timestamp;\n  }\n\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const entriesToDelete = await this._db.transaction(\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n          const store = txn.objectStore(OBJECT_STORE_NAME);\n          const entriesToDelete = [];\n          let entriesNotDeletedCount = 0;\n\n          store.index('timestamp')\n              .openCursor(null, 'prev')\n              .onsuccess = ({target}) => {\n                const cursor = target.result;\n                if (cursor) {\n                  const result = cursor.value;\n                  // TODO(philipwalton): once we can use a multi-key index, we\n                  // won't have to check `cacheName` here.\n                  if (result.cacheName === this._cacheName) {\n                    // Delete an entry if it's older than the max age or\n                    // if we already have the max number allowed.\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\n                      // TODO(philipwalton): we should be able to delete the\n                      // entry right here, but doing so causes an iteration\n                      // bug in Safari stable (fixed in TP). Instead we can\n                      // store the keys of the entries to delete, and then\n                      // delete the separate transactions.\n                      // https://github.com/GoogleChrome/workbox/issues/1978\n                      // cursor.delete();\n\n                      // We only need to return the URL, not the whole entry.\n                      entriesToDelete.push(cursor.value);\n                    } else {\n                      entriesNotDeletedCount++;\n                    }\n                  }\n                  cursor.continue();\n                } else {\n                  done(entriesToDelete);\n                }\n              };\n        });\n\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n}\n\nexport {CacheTimestampsModel};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const minTimestamp = this._maxAgeSeconds ?\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\n\n    const urlsExpired = await this._timestampModel.expireEntries(\n        minTimestamp, this._maxEntries);\n\n    // Delete URLs from the cache\n    const cache = await caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\n            `Expired ${urlsExpired.length} ` +\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\n            'URL' : 'URLs'}:`);\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._maxAgeSeconds) {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds',\n        });\n      }\n    }\n\n    const timestamp = await this._timestampModel.getTimestamp(url);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport {CacheExpiration};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {registerQuotaErrorCallback}\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\n\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n *\n * @memberof workbox.expiration\n */\nclass Plugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache the response is in.\n   * @param {Response} options.cachedResponse The `Response` object that's been\n   *     read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\n    if (!cachedResponse) {\n      return null;\n    }\n\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    // Update the metadata for the request URL to the current timestamp,\n    // but don't `await` it as we don't want to block the response.\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n    if (event) {\n      try {\n        event.waitUntil(updateTimestampDone);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n        }\n      }\n    }\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.strategies` handlers when an entry is added to a cache.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache that was updated.\n   * @param {string} options.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-expiration',\n        className: 'Plugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n\n\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\n\nexport {Plugin};\n"]},"metadata":{},"sourceType":"script"}