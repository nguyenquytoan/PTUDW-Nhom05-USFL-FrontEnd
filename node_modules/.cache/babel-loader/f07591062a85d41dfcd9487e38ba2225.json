{"ast":null,"code":"/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\n\nconst lodash = require(\"lodash\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\n\n\nfunction getPossibleTypes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"identifier\":\n      return [parsedSelector.value];\n\n    case \"matches\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n        if (typesForComponents.every(Boolean)) {\n          return lodash.union(...typesForComponents);\n        }\n\n        return null;\n      }\n\n    case \"compound\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent); // If all of the components could match any type, then the compound could also match any type.\n\n        if (!typesForComponents.length) {\n          return null;\n        }\n        /*\n         * If at least one of the components could only match a particular type, the compound could only match\n         * the intersection of those types.\n         */\n\n\n        return lodash.intersection(...typesForComponents);\n      }\n\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return getPossibleTypes(parsedSelector.right);\n\n    default:\n      return null;\n  }\n}\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\n\n\nfunction countClassAttributes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n    case \"attribute\":\n    case \"field\":\n    case \"nth-child\":\n    case \"nth-last-child\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\n\n\nfunction countIdentifiers(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n    case \"identifier\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\n\n\nfunction compareSpecificity(selectorA, selectorB) {\n  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\n\n\nfunction tryParseSelector(rawSelector) {\n  try {\n    return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n  } catch (err) {\n    if (typeof err.offset === \"number\") {\n      throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.offset}: ${err.message}`);\n    }\n\n    throw err;\n  }\n}\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\n\n\nconst parseSelector = lodash.memoize(rawSelector => {\n  const parsedSelector = tryParseSelector(rawSelector);\n  return {\n    rawSelector,\n    isExit: rawSelector.endsWith(\":exit\"),\n    parsedSelector,\n    listenerTypes: getPossibleTypes(parsedSelector),\n    attributeCount: countClassAttributes(parsedSelector),\n    identifierCount: countIdentifiers(parsedSelector)\n  };\n}); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\n\nclass NodeEventGenerator {\n  // eslint-disable-next-line jsdoc/require-description\n\n  /**\n   * @param {SafeEmitter} emitter\n   * An SafeEmitter which is the destination of events. This emitter must already\n   * have registered listeners for all of the events that it needs to listen for.\n   * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n   * @returns {NodeEventGenerator} new instance\n   */\n  constructor(emitter) {\n    this.emitter = emitter;\n    this.currentAncestry = [];\n    this.enterSelectorsByNodeType = new Map();\n    this.exitSelectorsByNodeType = new Map();\n    this.anyTypeEnterSelectors = [];\n    this.anyTypeExitSelectors = [];\n    emitter.eventNames().forEach(rawSelector => {\n      const selector = parseSelector(rawSelector);\n\n      if (selector.listenerTypes) {\n        const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n        selector.listenerTypes.forEach(nodeType => {\n          if (!typeMap.has(nodeType)) {\n            typeMap.set(nodeType, []);\n          }\n\n          typeMap.get(nodeType).push(selector);\n        });\n        return;\n      }\n\n      const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n      selectors.push(selector);\n    });\n    this.anyTypeEnterSelectors.sort(compareSpecificity);\n    this.anyTypeExitSelectors.sort(compareSpecificity);\n    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n  }\n  /**\n   * Checks a selector against a node, and emits it if it matches\n   * @param {ASTNode} node The node to check\n   * @param {ASTSelector} selector An AST selector descriptor\n   * @returns {void}\n   */\n\n\n  applySelector(node, selector) {\n    if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {\n      this.emitter.emit(selector.rawSelector, node);\n    }\n  }\n  /**\n   * Applies all appropriate selectors to a node, in specificity order\n   * @param {ASTNode} node The node to check\n   * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n   * @returns {void}\n   */\n\n\n  applySelectors(node, isExit) {\n    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n    /*\n     * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n     * Iterate through each of them, applying selectors in the right order.\n     */\n\n    let selectorsByTypeIndex = 0;\n    let anyTypeSelectorsIndex = 0;\n\n    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {\n        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n      } else {\n        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n      }\n    }\n  }\n  /**\n   * Emits an event of entering AST node.\n   * @param {ASTNode} node A node which was entered.\n   * @returns {void}\n   */\n\n\n  enterNode(node) {\n    if (node.parent) {\n      this.currentAncestry.unshift(node.parent);\n    }\n\n    this.applySelectors(node, false);\n  }\n  /**\n   * Emits an event of leaving AST node.\n   * @param {ASTNode} node A node which was left.\n   * @returns {void}\n   */\n\n\n  leaveNode(node) {\n    this.applySelectors(node, true);\n    this.currentAncestry.shift();\n  }\n\n}\n\nmodule.exports = NodeEventGenerator;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/node-event-generator.js"],"names":["esquery","require","lodash","getPossibleTypes","parsedSelector","type","value","typesForComponents","selectors","map","every","Boolean","union","filter","typesForComponent","length","intersection","right","countClassAttributes","left","reduce","sum","childSelector","countIdentifiers","compareSpecificity","selectorA","selectorB","attributeCount","identifierCount","rawSelector","tryParseSelector","parse","replace","err","offset","SyntaxError","message","parseSelector","memoize","isExit","endsWith","listenerTypes","NodeEventGenerator","constructor","emitter","currentAncestry","enterSelectorsByNodeType","Map","exitSelectorsByNodeType","anyTypeEnterSelectors","anyTypeExitSelectors","eventNames","forEach","selector","typeMap","nodeType","has","set","get","push","sort","selectorList","applySelector","node","matches","emit","applySelectors","selectorsByNodeType","anyTypeSelectors","selectorsByTypeIndex","anyTypeSelectorsIndex","enterNode","parent","unshift","leaveNode","shift","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(Boolean)) {\n                return lodash.union(...typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return lodash.intersection(...typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n    } catch (err) {\n        if (typeof err.offset === \"number\") {\n            throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nconst parseSelector = lodash.memoize(rawSelector => {\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    return {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n});\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {SafeEmitter} emitter\n     * An SafeEmitter which is the destination of events. This emitter must already\n     * have registered listeners for all of the events that it needs to listen for.\n     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n     * @returns {NodeEventGenerator} new instance\n     */\n    constructor(emitter) {\n        this.emitter = emitter;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        emitter.eventNames().forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                selector.listenerTypes.forEach(nodeType => {\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n                return;\n            }\n            const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n            selectors.push(selector);\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n"]},"metadata":{},"sourceType":"script"}