{"ast":null,"code":"/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n      ConfigOps = require(\"../shared/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\"); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\n\n\nmodule.exports = class ConfigCommentParser {\n  /**\n   * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n   * whitespace. Used for \"global\" and \"exported\" comments.\n   * @param {string} string The string to parse.\n   * @param {Comment} comment The comment node which has the string.\n   * @returns {Object} Result map object of names and string values, or null values if no value was provided\n   */\n  parseStringConfig(string, comment) {\n    debug(\"Parsing String config\");\n    const items = {}; // Collapse whitespace around `:` and `,` to make parsing easier\n\n    const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n    trimmedString.split(/\\s|,+/u).forEach(name => {\n      if (!name) {\n        return;\n      } // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n\n\n      const [key, value = null] = name.split(\":\");\n      items[key] = {\n        value,\n        comment\n      };\n    });\n    return items;\n  }\n  /**\n   * Parses a JSON-like config.\n   * @param {string} string The string to parse.\n   * @param {Object} location Start line and column of comments for potential error message.\n   * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n   */\n\n\n  parseJsonConfig(string, location) {\n    debug(\"Parsing JSON config\");\n    let items = {}; // Parses a JSON-like comment by the same way as parsing CLI option.\n\n    try {\n      items = levn.parse(\"Object\", string) || {}; // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n      // Also, commaless notations have invalid severity:\n      //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n      // Should ignore that case as well.\n\n      if (ConfigOps.isEverySeverityValid(items)) {\n        return {\n          success: true,\n          config: items\n        };\n      }\n    } catch (ex) {\n      debug(\"Levn parsing failed; falling back to manual parsing.\"); // ignore to parse the string by a fallback.\n    }\n    /*\n     * Optionator cannot parse commaless notations.\n     * But we are supporting that. So this is a fallback for that.\n     */\n\n\n    items = {};\n    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n    try {\n      items = JSON.parse(`{${normalizedString}}`);\n    } catch (ex) {\n      debug(\"Manual parsing failed.\");\n      return {\n        success: false,\n        error: {\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n          line: location.start.line,\n          column: location.start.column + 1\n        }\n      };\n    }\n\n    return {\n      success: true,\n      config: items\n    };\n  }\n  /**\n   * Parses a config of values separated by comma.\n   * @param {string} string The string to parse.\n   * @returns {Object} Result map of values and true values\n   */\n\n\n  parseListConfig(string) {\n    debug(\"Parsing list config\");\n    const items = {}; // Collapse whitespace around commas\n\n    string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n      const trimmedName = name.trim();\n\n      if (trimmedName) {\n        items[trimmedName] = true;\n      }\n    });\n    return items;\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/config-comment-parser.js"],"names":["levn","require","ConfigOps","debug","module","exports","ConfigCommentParser","parseStringConfig","string","comment","items","trimmedString","replace","split","forEach","name","key","value","parseJsonConfig","location","parse","isEverySeverityValid","success","config","ex","normalizedString","JSON","error","ruleId","fatal","severity","message","line","start","column","parseListConfig","trimmedName","trim"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n    ConfigOps = require(\"../shared/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" and \"exported\" comments.\n     * @param {string} string The string to parse.\n     * @param {Comment} comment The comment node which has the string.\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\n     */\n    parseStringConfig(string, comment) {\n        debug(\"Parsing String config\");\n\n        const items = {};\n\n        // Collapse whitespace around `:` and `,` to make parsing easier\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n\n        trimmedString.split(/\\s|,+/u).forEach(name => {\n            if (!name) {\n                return;\n            }\n\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n            const [key, value = null] = name.split(\":\");\n\n            items[key] = { value, comment };\n        });\n        return items;\n    }\n\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @param {Object} location Start line and column of comments for potential error message.\n     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n     */\n    parseJsonConfig(string, location) {\n        debug(\"Parsing JSON config\");\n\n        let items = {};\n\n        // Parses a JSON-like comment by the same way as parsing CLI option.\n        try {\n            items = levn.parse(\"Object\", string) || {};\n\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n            // Also, commaless notations have invalid severity:\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n            // Should ignore that case as well.\n            if (ConfigOps.isEverySeverityValid(items)) {\n                return {\n                    success: true,\n                    config: items\n                };\n            }\n        } catch (ex) {\n\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n            // ignore to parse the string by a fallback.\n        }\n\n        /*\n         * Optionator cannot parse commaless notations.\n         * But we are supporting that. So this is a fallback for that.\n         */\n        items = {};\n        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n        try {\n            items = JSON.parse(`{${normalizedString}}`);\n        } catch (ex) {\n            debug(\"Manual parsing failed.\");\n\n            return {\n                success: false,\n                error: {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n                    line: location.start.line,\n                    column: location.start.column + 1\n                }\n            };\n\n        }\n\n        return {\n            success: true,\n            config: items\n        };\n    }\n\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {Object} Result map of values and true values\n     */\n    parseListConfig(string) {\n        debug(\"Parsing list config\");\n\n        const items = {};\n\n        // Collapse whitespace around commas\n        string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n            const trimmedName = name.trim();\n\n            if (trimmedName) {\n                items[trimmedName] = true;\n            }\n        });\n        return items;\n    }\n\n};\n"]},"metadata":{},"sourceType":"script"}