{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = _interopRequireDefault(require('vm'));\n\n  _vm = function _vm() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function _core() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function _babelPluginIstanbul() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = _interopRequireDefault(require('convert-source-map'));\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function _fastJsonStableStringify() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function _slash() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = _interopRequireDefault(require('write-file-atomic'));\n\n  _writeFileAtomic = function _writeFileAtomic() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function _pirates() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n} // Use `require` to avoid TS rootDir\n\n\nconst _require = require('../package.json'),\n      VERSION = _require.version; // This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\n\n\nconst projectCaches = new WeakMap(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nfunction waitForPromiseWithCleanup(_x, _x2) {\n  return _waitForPromiseWithCleanup.apply(this, arguments);\n}\n\nfunction _waitForPromiseWithCleanup() {\n  _waitForPromiseWithCleanup = _asyncToGenerator(function* (promise, cleanup) {\n    try {\n      yield promise;\n    } finally {\n      cleanup();\n    }\n  });\n  return _waitForPromiseWithCleanup.apply(this, arguments);\n}\n\nclass ScriptTransformer {\n  constructor(config) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_transformCache', void 0);\n\n    _defineProperty(this, '_transformConfigCache', void 0);\n\n    this._config = config;\n    this._transformCache = new Map();\n    this._transformConfigCache = new Map();\n    let projectCache = projectCaches.get(config);\n\n    if (!projectCache) {\n      projectCache = {\n        configString: (0, _fastJsonStableStringify().default)(this._config),\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(config, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _getCacheKey(fileData, filename, instrument) {\n    const configString = this._cache.configString;\n\n    const transformer = this._getTransformer(filename);\n\n    if (transformer && typeof transformer.getCacheKey === 'function') {\n      return _crypto().default.createHash('md5').update(transformer.getCacheKey(fileData, filename, configString, {\n        config: this._config,\n        instrument,\n        rootDir: this._config.rootDir\n      })).update(CACHE_VERSION).digest('hex');\n    } else {\n      return _crypto().default.createHash('md5').update(fileData).update(configString).update(instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');\n    }\n  }\n\n  _getFileCachePath(filename, content, instrument) {\n    const baseCacheDir = _jestHasteMap().default.getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION);\n\n    const cacheKey = this._getCacheKey(content, filename, instrument); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n\n    const cacheDir = _path().default.join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n\n    const cacheFilenamePrefix = _path().default.basename(filename, _path().default.extname(filename)).replace(/\\W/g, '');\n\n    const cachePath = (0, _slash().default)(_path().default.join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        const transformPath = transformRegExp[i][1];\n\n        this._transformConfigCache.set(transformPath, transformRegExp[i][2]);\n\n        return transformPath;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getTransformer(filename) {\n    let transform = null;\n\n    if (!this._config.transform || !this._config.transform.length) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (transformPath) {\n      const transformer = this._transformCache.get(transformPath);\n\n      if (transformer != null) {\n        return transformer;\n      }\n\n      transform = require(transformPath);\n\n      const transformerConfig = this._transformConfigCache.get(transformPath);\n\n      if (typeof transform.createTransformer === 'function') {\n        transform = transform.createTransformer(transformerConfig);\n      }\n\n      if (typeof transform.process !== 'function') {\n        throw new TypeError('Jest: a transform must export a `process` function.');\n      }\n\n      this._transformCache.set(transformPath, transform);\n    }\n\n    return transform;\n  }\n\n  _instrumentFile(filename, content) {\n    const result = (0, _core().transformSync)(content, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsStaticESM: false\n      },\n      configFile: false,\n      filename,\n      plugins: [[_babelPluginIstanbul().default, {\n        compact: false,\n        // files outside `cwd` will not be instrumented\n        cwd: this._config.rootDir,\n        exclude: [],\n        useInlineSourceMaps: false\n      }]]\n    });\n\n    if (result) {\n      const code = result.code;\n\n      if (code) {\n        return code;\n      }\n    }\n\n    return content;\n  }\n\n  _getRealPath(filepath) {\n    try {\n      return (0, _realpathNative().sync)(filepath) || filepath;\n    } catch (err) {\n      return filepath;\n    }\n  } // We don't want to expose transformers to the outside - this function is just\n  // to warm up `this._transformCache`\n\n\n  preloadTransformer(filepath) {\n    this._getTransformer(filepath);\n  }\n\n  transformSource(filepath, content, instrument) {\n    const filename = this._getRealPath(filepath);\n\n    const transform = this._getTransformer(filename);\n\n    const cacheFilePath = this._getFileCachePath(filename, content, instrument);\n\n    let sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    let code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    const shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument = shouldCallTransform && transform && transform.canInstrument; // If we handle the coverage instrumentation, we should try to map code\n    // coverage against original source with any provided source map\n\n    const mapCoverage = instrument && !transformWillInstrument;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        mapCoverage,\n        sourceMapPath\n      };\n    }\n\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transform && shouldCallTransform) {\n      const processed = transform.process(content, filename, this._config, {\n        instrument\n      });\n\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new TypeError(\"Jest: a transform's `process` function must return a string, \" + 'or an object with `code` key containing this string.');\n      }\n    }\n\n    if (!transformed.map) {\n      //Could be a potential freeze here.\n      //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n      const inlineSourceMap = _convertSourceMap().default.fromSource(transformed.code);\n\n      if (inlineSourceMap) {\n        transformed.map = inlineSourceMap.toJSON();\n      }\n    }\n\n    if (!transformWillInstrument && instrument) {\n      code = this._instrumentFile(filename, transformed.code);\n    } else {\n      code = transformed.code;\n    }\n\n    if (transformed.map) {\n      const sourceMapContent = typeof transformed.map === 'string' ? transformed.map : JSON.stringify(transformed.map);\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      mapCoverage,\n      sourceMapPath\n    };\n  }\n\n  _transformAndBuildScript(filename, options, instrument, fileSource) {\n    const isInternalModule = !!(options && options.isInternalModule);\n    const isCoreModule = !!(options && options.isCoreModule);\n    const content = stripShebang(fileSource || _gracefulFs().default.readFileSync(filename, 'utf8'));\n    let wrappedCode;\n    let sourceMapPath = null;\n    let mapCoverage = false;\n    const willTransform = !isInternalModule && !isCoreModule && (this.shouldTransform(filename) || instrument);\n\n    try {\n      const extraGlobals = options && options.extraGlobals || [];\n\n      if (willTransform) {\n        const transformedSource = this.transformSource(filename, content, instrument);\n        wrappedCode = wrap(transformedSource.code, ...extraGlobals);\n        sourceMapPath = transformedSource.sourceMapPath;\n        mapCoverage = transformedSource.mapCoverage;\n      } else {\n        wrappedCode = wrap(content, ...extraGlobals);\n      }\n\n      return {\n        mapCoverage,\n        script: new (_vm().default.Script)(wrappedCode, {\n          displayErrors: true,\n          filename: isCoreModule ? 'jest-nodejs-core-' + filename : filename\n        }),\n        sourceMapPath\n      };\n    } catch (e) {\n      if (e.codeFrame) {\n        e.stack = e.message + '\\n' + e.codeFrame;\n      }\n\n      if (e instanceof SyntaxError && e.message.includes('Unexpected token') && !e.message.includes(' expected')) {\n        throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n      }\n\n      throw e;\n    }\n  }\n\n  transform(filename, options, fileSource) {\n    let scriptCacheKey = undefined;\n    let instrument = false;\n\n    if (!options.isCoreModule) {\n      instrument = (0, _shouldInstrument.default)(filename, options, this._config);\n      scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n      const result = this._cache.transformedFiles.get(scriptCacheKey);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    const result = this._transformAndBuildScript(filename, options, instrument, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const isInternalModule = options.isInternalModule;\n    const isCoreModule = options.isCoreModule;\n    const willTransform = !isInternalModule && !isCoreModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const _this$transformSource = this.transformSource(filename, fileSource, false),\n            transformedJsonSource = _this$transformSource.code;\n\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  requireAndTranspileModule(moduleName, callback) {\n    // Load the transformer to avoid a cycle where we need to load a\n    // transformer in order to transform it in the require hooks\n    this.preloadTransformer(moduleName);\n    let transforming = false;\n    const revertHook = (0, _pirates().addHook)((code, filename) => {\n      try {\n        transforming = true;\n        return this.transformSource(filename, code, false).code || code;\n      } finally {\n        transforming = false;\n      }\n    }, {\n      exts: [_path().default.extname(moduleName)],\n      ignoreNodeModules: false,\n      matcher: filename => {\n        if (transforming) {\n          // Don't transform any dependency required by the transformer itself\n          return false;\n        }\n\n        return this.shouldTransform(filename);\n      }\n    });\n\n    const module = require(moduleName);\n\n    if (!callback) {\n      revertHook();\n      return module;\n    }\n\n    try {\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);\n      }\n    } finally {\n      revertHook();\n    }\n\n    return module;\n  }\n  /**\n   * @deprecated use `this.shouldTransform` instead\n   */\n  // @ts-ignore: Unused and private - remove in Jest 25\n\n\n  _shouldTransform(filename) {\n    return this.shouldTransform(filename);\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return !!this._config.transform && !!this._config.transform.length && !isIgnored;\n  }\n\n}\n\nexports.default = ScriptTransformer;\n\n_defineProperty(ScriptTransformer, 'EVAL_RESULT_VARIABLE', void 0);\n\nconst removeFile = path => {\n  try {\n    _gracefulFs().default.unlinkSync(path);\n  } catch (e) {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = _crypto().default.createHash('md5').update(code).digest('hex');\n\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substr(33);\n\n  const checksum = _crypto().default.createHash('md5').update(code).digest('hex');\n\n  if (checksum === content.substr(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    _writeFileAtomic().default.sync(cachePath, fileData, {\n      encoding: 'utf8'\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) => process.platform === 'win32' && e.code === 'EPERM' && _gracefulFs().default.existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!_gracefulFs().default.existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = _gracefulFs().default.readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read cache file: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = _gracefulFs().default.statSync(filename).mtime;\n\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);\n  }\n\n  return transformRegexp;\n};\n\nconst wrap = (content, ...extras) => {\n  const globals = new Set(['module', 'exports', 'require', '__dirname', '__filename', 'global', 'jest', ...extras]);\n  return '({\"' + ScriptTransformer.EVAL_RESULT_VARIABLE + `\":function(${Array.from(globals).join(',')}){` + content + '\\n}});';\n}; // TODO: Can this be added to the static property?\n\n\nScriptTransformer.EVAL_RESULT_VARIABLE = 'Object.<anonymous>';","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@jest/transform/build/ScriptTransformer.js"],"names":["Object","defineProperty","exports","value","default","_crypto","data","_interopRequireDefault","require","_path","_vm","_jestUtil","_gracefulFs","_core","_babelPluginIstanbul","_convertSourceMap","_jestHasteMap","_fastJsonStableStringify","_slash","_writeFileAtomic","_realpathNative","_pirates","_shouldInstrument","_enhanceUnexpectedTokenMessage","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","_require","VERSION","version","projectCaches","WeakMap","CACHE_VERSION","waitForPromiseWithCleanup","_x","_x2","_waitForPromiseWithCleanup","promise","cleanup","ScriptTransformer","constructor","config","_config","_transformCache","Map","_transformConfigCache","projectCache","get","configString","ignorePatternsRegExp","calcIgnorePatternRegExp","transformRegExp","calcTransformRegExp","transformedFiles","set","_cache","_getCacheKey","fileData","filename","instrument","transformer","_getTransformer","getCacheKey","createHash","update","rootDir","digest","_getFileCachePath","content","baseCacheDir","getCacheFilePath","cacheDirectory","name","cacheKey","cacheDir","join","cacheFilenamePrefix","basename","extname","replace","cachePath","createDirectory","_getTransformPath","i","length","test","transformPath","transform","transformerConfig","createTransformer","process","TypeError","_instrumentFile","result","transformSync","auxiliaryCommentBefore","babelrc","caller","supportsStaticESM","configFile","plugins","compact","cwd","exclude","useInlineSourceMaps","code","_getRealPath","filepath","sync","preloadTransformer","transformSource","cacheFilePath","sourceMapPath","cache","readCodeCacheFile","shouldCallTransform","shouldTransform","transformWillInstrument","canInstrument","mapCoverage","transformed","map","processed","inlineSourceMap","fromSource","toJSON","sourceMapContent","JSON","stringify","writeCacheFile","writeCodeCacheFile","_transformAndBuildScript","options","fileSource","isInternalModule","isCoreModule","stripShebang","readFileSync","wrappedCode","willTransform","extraGlobals","transformedSource","wrap","script","Script","displayErrors","e","codeFrame","stack","message","SyntaxError","includes","scriptCacheKey","getScriptCacheKey","transformJson","_this$transformSource","transformedJsonSource","requireAndTranspileModule","moduleName","callback","transforming","revertHook","addHook","exts","ignoreNodeModules","matcher","module","cbResult","isPromise","_shouldTransform","ignoreRegexp","isIgnored","removeFile","path","unlinkSync","startsWith","checksum","readCacheFile","substr","encoding","cacheWriteErrorSafeToIgnore","platform","existsSync","mtime","statSync","getTime","transformIgnorePatterns","RegExp","transformRegexp","push","extras","globals","Set","EVAL_RESULT_VARIABLE","Array","from"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = _interopRequireDefault(require('vm'));\n\n  _vm = function _vm() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function _jestUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gracefulFs() {\n  const data = _interopRequireDefault(require('graceful-fs'));\n\n  _gracefulFs = function _gracefulFs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function _core() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function _babelPluginIstanbul() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = _interopRequireDefault(require('convert-source-map'));\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function _jestHasteMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function _fastJsonStableStringify() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function _slash() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = _interopRequireDefault(require('write-file-atomic'));\n\n  _writeFileAtomic = function _writeFileAtomic() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _realpathNative() {\n  const data = require('realpath-native');\n\n  _realpathNative = function _realpathNative() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function _pirates() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(\n  require('./enhanceUnexpectedTokenMessage')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\n// Use `require` to avoid TS rootDir\nconst _require = require('../package.json'),\n  VERSION = _require.version; // This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\n\nconst projectCaches = new WeakMap(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nfunction waitForPromiseWithCleanup(_x, _x2) {\n  return _waitForPromiseWithCleanup.apply(this, arguments);\n}\n\nfunction _waitForPromiseWithCleanup() {\n  _waitForPromiseWithCleanup = _asyncToGenerator(function*(promise, cleanup) {\n    try {\n      yield promise;\n    } finally {\n      cleanup();\n    }\n  });\n  return _waitForPromiseWithCleanup.apply(this, arguments);\n}\n\nclass ScriptTransformer {\n  constructor(config) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_transformCache', void 0);\n\n    _defineProperty(this, '_transformConfigCache', void 0);\n\n    this._config = config;\n    this._transformCache = new Map();\n    this._transformConfigCache = new Map();\n    let projectCache = projectCaches.get(config);\n\n    if (!projectCache) {\n      projectCache = {\n        configString: (0, _fastJsonStableStringify().default)(this._config),\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(config, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _getCacheKey(fileData, filename, instrument) {\n    const configString = this._cache.configString;\n\n    const transformer = this._getTransformer(filename);\n\n    if (transformer && typeof transformer.getCacheKey === 'function') {\n      return _crypto()\n        .default.createHash('md5')\n        .update(\n          transformer.getCacheKey(fileData, filename, configString, {\n            config: this._config,\n            instrument,\n            rootDir: this._config.rootDir\n          })\n        )\n        .update(CACHE_VERSION)\n        .digest('hex');\n    } else {\n      return _crypto()\n        .default.createHash('md5')\n        .update(fileData)\n        .update(configString)\n        .update(instrument ? 'instrument' : '')\n        .update(filename)\n        .update(CACHE_VERSION)\n        .digest('hex');\n    }\n  }\n\n  _getFileCachePath(filename, content, instrument) {\n    const baseCacheDir = _jestHasteMap().default.getCacheFilePath(\n      this._config.cacheDirectory,\n      'jest-transform-cache-' + this._config.name,\n      VERSION\n    );\n\n    const cacheKey = this._getCacheKey(content, filename, instrument); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = _path().default.join(\n      baseCacheDir,\n      cacheKey[0] + cacheKey[1]\n    );\n\n    const cacheFilenamePrefix = _path()\n      .default.basename(filename, _path().default.extname(filename))\n      .replace(/\\W/g, '');\n\n    const cachePath = (0, _slash().default)(\n      _path().default.join(cacheDir, cacheFilenamePrefix + '_' + cacheKey)\n    );\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        const transformPath = transformRegExp[i][1];\n\n        this._transformConfigCache.set(transformPath, transformRegExp[i][2]);\n\n        return transformPath;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getTransformer(filename) {\n    let transform = null;\n\n    if (!this._config.transform || !this._config.transform.length) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (transformPath) {\n      const transformer = this._transformCache.get(transformPath);\n\n      if (transformer != null) {\n        return transformer;\n      }\n\n      transform = require(transformPath);\n\n      const transformerConfig = this._transformConfigCache.get(transformPath);\n\n      if (typeof transform.createTransformer === 'function') {\n        transform = transform.createTransformer(transformerConfig);\n      }\n\n      if (typeof transform.process !== 'function') {\n        throw new TypeError(\n          'Jest: a transform must export a `process` function.'\n        );\n      }\n\n      this._transformCache.set(transformPath, transform);\n    }\n\n    return transform;\n  }\n\n  _instrumentFile(filename, content) {\n    const result = (0, _core().transformSync)(content, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsStaticESM: false\n      },\n      configFile: false,\n      filename,\n      plugins: [\n        [\n          _babelPluginIstanbul().default,\n          {\n            compact: false,\n            // files outside `cwd` will not be instrumented\n            cwd: this._config.rootDir,\n            exclude: [],\n            useInlineSourceMaps: false\n          }\n        ]\n      ]\n    });\n\n    if (result) {\n      const code = result.code;\n\n      if (code) {\n        return code;\n      }\n    }\n\n    return content;\n  }\n\n  _getRealPath(filepath) {\n    try {\n      return (0, _realpathNative().sync)(filepath) || filepath;\n    } catch (err) {\n      return filepath;\n    }\n  } // We don't want to expose transformers to the outside - this function is just\n  // to warm up `this._transformCache`\n\n  preloadTransformer(filepath) {\n    this._getTransformer(filepath);\n  }\n\n  transformSource(filepath, content, instrument) {\n    const filename = this._getRealPath(filepath);\n\n    const transform = this._getTransformer(filename);\n\n    const cacheFilePath = this._getFileCachePath(filename, content, instrument);\n\n    let sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    let code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    const shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument =\n      shouldCallTransform && transform && transform.canInstrument; // If we handle the coverage instrumentation, we should try to map code\n    // coverage against original source with any provided source map\n\n    const mapCoverage = instrument && !transformWillInstrument;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        mapCoverage,\n        sourceMapPath\n      };\n    }\n\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transform && shouldCallTransform) {\n      const processed = transform.process(content, filename, this._config, {\n        instrument\n      });\n\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new TypeError(\n          \"Jest: a transform's `process` function must return a string, \" +\n            'or an object with `code` key containing this string.'\n        );\n      }\n    }\n\n    if (!transformed.map) {\n      //Could be a potential freeze here.\n      //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n      const inlineSourceMap = _convertSourceMap().default.fromSource(\n        transformed.code\n      );\n\n      if (inlineSourceMap) {\n        transformed.map = inlineSourceMap.toJSON();\n      }\n    }\n\n    if (!transformWillInstrument && instrument) {\n      code = this._instrumentFile(filename, transformed.code);\n    } else {\n      code = transformed.code;\n    }\n\n    if (transformed.map) {\n      const sourceMapContent =\n        typeof transformed.map === 'string'\n          ? transformed.map\n          : JSON.stringify(transformed.map);\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      mapCoverage,\n      sourceMapPath\n    };\n  }\n\n  _transformAndBuildScript(filename, options, instrument, fileSource) {\n    const isInternalModule = !!(options && options.isInternalModule);\n    const isCoreModule = !!(options && options.isCoreModule);\n    const content = stripShebang(\n      fileSource || _gracefulFs().default.readFileSync(filename, 'utf8')\n    );\n    let wrappedCode;\n    let sourceMapPath = null;\n    let mapCoverage = false;\n    const willTransform =\n      !isInternalModule &&\n      !isCoreModule &&\n      (this.shouldTransform(filename) || instrument);\n\n    try {\n      const extraGlobals = (options && options.extraGlobals) || [];\n\n      if (willTransform) {\n        const transformedSource = this.transformSource(\n          filename,\n          content,\n          instrument\n        );\n        wrappedCode = wrap(transformedSource.code, ...extraGlobals);\n        sourceMapPath = transformedSource.sourceMapPath;\n        mapCoverage = transformedSource.mapCoverage;\n      } else {\n        wrappedCode = wrap(content, ...extraGlobals);\n      }\n\n      return {\n        mapCoverage,\n        script: new (_vm()).default.Script(wrappedCode, {\n          displayErrors: true,\n          filename: isCoreModule ? 'jest-nodejs-core-' + filename : filename\n        }),\n        sourceMapPath\n      };\n    } catch (e) {\n      if (e.codeFrame) {\n        e.stack = e.message + '\\n' + e.codeFrame;\n      }\n\n      if (\n        e instanceof SyntaxError &&\n        e.message.includes('Unexpected token') &&\n        !e.message.includes(' expected')\n      ) {\n        throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n      }\n\n      throw e;\n    }\n  }\n\n  transform(filename, options, fileSource) {\n    let scriptCacheKey = undefined;\n    let instrument = false;\n\n    if (!options.isCoreModule) {\n      instrument = (0, _shouldInstrument.default)(\n        filename,\n        options,\n        this._config\n      );\n      scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n      const result = this._cache.transformedFiles.get(scriptCacheKey);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    const result = this._transformAndBuildScript(\n      filename,\n      options,\n      instrument,\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const isInternalModule = options.isInternalModule;\n    const isCoreModule = options.isCoreModule;\n    const willTransform =\n      !isInternalModule && !isCoreModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const _this$transformSource = this.transformSource(\n          filename,\n          fileSource,\n          false\n        ),\n        transformedJsonSource = _this$transformSource.code;\n\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  requireAndTranspileModule(moduleName, callback) {\n    // Load the transformer to avoid a cycle where we need to load a\n    // transformer in order to transform it in the require hooks\n    this.preloadTransformer(moduleName);\n    let transforming = false;\n    const revertHook = (0, _pirates().addHook)(\n      (code, filename) => {\n        try {\n          transforming = true;\n          return this.transformSource(filename, code, false).code || code;\n        } finally {\n          transforming = false;\n        }\n      },\n      {\n        exts: [_path().default.extname(moduleName)],\n        ignoreNodeModules: false,\n        matcher: filename => {\n          if (transforming) {\n            // Don't transform any dependency required by the transformer itself\n            return false;\n          }\n\n          return this.shouldTransform(filename);\n        }\n      }\n    );\n\n    const module = require(moduleName);\n\n    if (!callback) {\n      revertHook();\n      return module;\n    }\n\n    try {\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(\n          () => module\n        );\n      }\n    } finally {\n      revertHook();\n    }\n\n    return module;\n  }\n  /**\n   * @deprecated use `this.shouldTransform` instead\n   */\n  // @ts-ignore: Unused and private - remove in Jest 25\n\n  _shouldTransform(filename) {\n    return this.shouldTransform(filename);\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return (\n      !!this._config.transform && !!this._config.transform.length && !isIgnored\n    );\n  }\n}\n\nexports.default = ScriptTransformer;\n\n_defineProperty(ScriptTransformer, 'EVAL_RESULT_VARIABLE', void 0);\n\nconst removeFile = path => {\n  try {\n    _gracefulFs().default.unlinkSync(path);\n  } catch (e) {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = _crypto()\n    .default.createHash('md5')\n    .update(code)\n    .digest('hex');\n\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substr(33);\n\n  const checksum = _crypto()\n    .default.createHash('md5')\n    .update(code)\n    .digest('hex');\n\n  if (checksum === content.substr(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    _writeFileAtomic().default.sync(cachePath, fileData, {\n      encoding: 'utf8'\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message =\n      'jest: failed to cache transform results in: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) =>\n  process.platform === 'win32' &&\n  e.code === 'EPERM' &&\n  _gracefulFs().default.existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!_gracefulFs().default.existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = _gracefulFs().default.readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message =\n      'jest: failed to read cache file: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = _gracefulFs().default.statSync(filename).mtime;\n\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (\n    !config.transformIgnorePatterns ||\n    config.transformIgnorePatterns.length === 0\n  ) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([\n      new RegExp(config.transform[i][0]),\n      config.transform[i][1],\n      config.transform[i][2]\n    ]);\n  }\n\n  return transformRegexp;\n};\n\nconst wrap = (content, ...extras) => {\n  const globals = new Set([\n    'module',\n    'exports',\n    'require',\n    '__dirname',\n    '__filename',\n    'global',\n    'jest',\n    ...extras\n  ]);\n  return (\n    '({\"' +\n    ScriptTransformer.EVAL_RESULT_VARIABLE +\n    `\":function(${Array.from(globals).join(',')}){` +\n    content +\n    '\\n}});'\n  );\n}; // TODO: Can this be added to the static property?\n\nScriptTransformer.EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\n"]},"metadata":{},"sourceType":"script"}