{"ast":null,"code":"'use strict';\n\nconst inspect = require('util').inspect;\n\nconst path = require('path');\n\nconst Parser = require('yargs-parser');\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/; // handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\n\nmodule.exports = function command(yargs, usage, validation, globalMiddleware) {\n  const self = {};\n  let handlers = {};\n  let aliasMap = {};\n  let defaultCommand;\n  globalMiddleware = globalMiddleware || [];\n\n  self.addHandler = function addHandler(cmd, description, builder, handler, middlewares) {\n    let aliases = [];\n\n    handler = handler || (() => {});\n\n    middlewares = middlewares || [];\n    globalMiddleware.push(...middlewares);\n    middlewares = globalMiddleware;\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1);\n      cmd = cmd[0];\n    } else if (typeof cmd === 'object') {\n      let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares);\n      return;\n    } // allow a module to be provided instead of separate builder and handler\n\n\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares);\n      return;\n    } // parse positionals out of cmd string\n\n\n    const parsedCommand = self.parseCommand(cmd); // remove positional args from aliases only\n\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd); // check for default and filter out '*''\n\n    let isDefault = false;\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true;\n        return false;\n      }\n\n      return true;\n    }); // standardize on $0 for default command.\n\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0'); // shift cmd and aliases after filtering out '*'\n\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0];\n      aliases = parsedAliases.slice(1);\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n    } // populate aliasMap\n\n\n    aliases.forEach(alias => {\n      aliasMap[alias] = parsedCommand.cmd;\n    });\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases);\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    };\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n  };\n\n  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n    opts = opts || {}; // disable recursion to support nested directories of subcommands\n\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false; // exclude 'json', 'coffee' from require-directory defaults\n\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']; // allow consumer to define their own visitor function\n\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o; // call addHandler via visitor function\n\n    opts.visit = function visit(obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename); // allow consumer to skip modules with their own visitor\n\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited; // keep track of visited files in context.files\n\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n\n      return visited;\n    };\n\n    require('require-directory')({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  }; // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n\n\n  function moduleName(obj) {\n    const mod = require('which-module')(obj);\n\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`);\n    return commandFromFilename(mod.filename);\n  } // derive command name from filename\n\n\n  function commandFromFilename(filename) {\n    return path.basename(filename, path.extname(filename));\n  }\n\n  function extractDesc(obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]];\n      if (typeof test === 'string' || typeof test === 'boolean') return test;\n    }\n\n    return false;\n  }\n\n  self.parseCommand = function parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const parsedCommand = {\n      cmd: splitCommand.shift().replace(bregex, ''),\n      demanded: [],\n      optional: []\n    };\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false;\n      cmd = cmd.replace(/\\s/g, '');\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;\n\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        });\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        });\n      }\n    });\n    return parsedCommand;\n  };\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n\n  self.getCommandHandlers = () => handlers;\n\n  self.hasDefaultCommand = () => !!defaultCommand;\n\n  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases;\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    const currentContext = yargs.getContext();\n    let numFiles = currentContext.files.length;\n    const parentCommands = currentContext.commands.slice(); // what does yargs look like after the buidler is run?\n\n    let innerArgv = parsed.argv;\n    let innerYargs = null;\n    let positionalMap = {};\n\n    if (command) {\n      currentContext.commands.push(command);\n      currentContext.fullCommands.push(commandHandler.original);\n    }\n\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases)); // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n\n      if (yargs.parsed === false) {\n        if (shouldUpdateUsage(yargs)) {\n          yargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n        }\n\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex);\n      } else {\n        innerArgv = yargs.parsed.argv;\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases;else aliases = yargs.parsed.aliases;\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases);\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      Object.keys(commandHandler.builder).forEach(key => {\n        innerYargs.option(key, commandHandler.builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs);\n    } // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n\n\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error);\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput();\n\n      if (commandHandler.middlewares.length > 0) {\n        const middlewareArgs = commandHandler.middlewares.reduce(function (initialObj, middleware) {\n          return Object.assign(initialObj, middleware(innerArgv));\n        }, {});\n        Object.assign(innerArgv, middlewareArgs);\n      }\n\n      const handlerResult = commandHandler.handler(innerArgv);\n\n      if (handlerResult && typeof handlerResult.then === 'function') {\n        handlerResult.then(null, error => yargs.getUsageInstance().fail(null, error));\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop();\n      currentContext.fullCommands.pop();\n    }\n\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  };\n\n  function shouldUpdateUsage(yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;\n  }\n\n  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n    const pc = parentCommands.filter(c => {\n      return !DEFAULT_MARKER.test(c);\n    });\n    pc.push(c);\n    return `$0 ${pc.join(' ')}`;\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n      yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n    }\n\n    const builder = defaultCommand.builder;\n\n    if (typeof builder === 'function') {\n      builder(yargs);\n    } else {\n      Object.keys(builder).forEach(key => {\n        yargs.option(key, builder[key]);\n      });\n    }\n  }; // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n\n\n  function populatePositionals(commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length); // nuke the current commands\n\n    const demanded = commandHandler.demanded.slice(0);\n    const optional = commandHandler.optional.slice(0);\n    const positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n\n    while (demanded.length) {\n      const demand = demanded.shift();\n      populatePositional(demand, argv, positionalMap);\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift();\n      populatePositional(maybe, argv, positionalMap);\n    }\n\n    argv._ = context.commands.concat(argv._);\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n    return positionalMap;\n  }\n\n  function populatePositional(positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0];\n\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String);\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];\n    }\n  } // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n\n\n  function postProcessPositionals(argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions());\n    options.default = Object.assign(parseOptions.default, options.default);\n    options.alias = Object.assign(parseOptions.alias, options.alias);\n    options.array = options.array.concat(parseOptions.array);\n    delete options.config; //  don't load config when processing positionals.\n\n    const unparsed = [];\n    Object.keys(positionalMap).forEach(key => {\n      positionalMap[key].map(value => {\n        unparsed.push(`--${key}`);\n        unparsed.push(value);\n      });\n    }); // short-circuit parse.\n\n    if (!unparsed.length) return;\n    const parsed = Parser.detailed(unparsed, options);\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap);\n      Object.keys(positionalMap).forEach(key => {\n        [].push.apply(positionalKeys, parsed.aliases[key]);\n      });\n      Object.keys(parsed.argv).forEach(key => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];\n          argv[key] = parsed.argv[key];\n        }\n      });\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    };\n    const parsed = self.parseCommand(cmdString);\n    parsed.demanded.forEach(d => {\n      const cmds = d.cmd.slice(0);\n      const cmd = cmds.shift();\n\n      if (d.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      cmds.forEach(c => {\n        parseOptions.alias[cmd] = c;\n      });\n      parseOptions.demand[cmd] = true;\n    });\n    parsed.optional.forEach(o => {\n      const cmds = o.cmd.slice(0);\n      const cmd = cmds.shift();\n\n      if (o.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      cmds.forEach(c => {\n        parseOptions.alias[cmd] = c;\n      });\n    });\n    return parseOptions;\n  };\n\n  self.reset = () => {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  }; // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n\n\n  let frozen;\n\n  self.freeze = () => {\n    frozen = {};\n    frozen.handlers = handlers;\n    frozen.aliasMap = aliasMap;\n    frozen.defaultCommand = defaultCommand;\n  };\n\n  self.unfreeze = () => {\n    handlers = frozen.handlers;\n    aliasMap = frozen.aliasMap;\n    defaultCommand = frozen.defaultCommand;\n    frozen = undefined;\n  };\n\n  return self;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/webpack-dev-server/node_modules/yargs/lib/command.js"],"names":["inspect","require","path","Parser","DEFAULT_MARKER","module","exports","command","yargs","usage","validation","globalMiddleware","self","handlers","aliasMap","defaultCommand","addHandler","cmd","description","builder","handler","middlewares","aliases","push","Array","isArray","slice","moduleName","concat","extractDesc","parsedCommand","parseCommand","map","alias","isDefault","parsedAliases","filter","c","test","length","replace","forEach","original","demanded","optional","addDirectory","dir","context","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","obj","joined","filename","visited","files","indexOf","mod","Error","commandFromFilename","basename","extname","keys","i","l","extraSpacesStrippedCommand","splitCommand","split","bregex","shift","variadic","getCommands","Object","getCommandHandlers","hasDefaultCommand","runCommand","parsed","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","argv","innerYargs","positionalMap","fullCommands","reset","shouldUpdateUsage","getUsageInstance","usageFromParentCommandsCommandHandler","_parseArgs","key","option","_hasOutput","populatePositionals","_runValidation","error","_setHasOutput","middlewareArgs","reduce","initialObj","middleware","assign","handlerResult","then","fail","pop","splice","getUsageDisabled","getUsage","trim","pc","join","runDefaultBuilderOn","commandString","_","positionalCount","demand","populatePositional","maybe","postProcessPositionals","cmdToParseOptions","positional","parseOptions","String","options","getOptions","default","array","config","unparsed","value","detailed","message","positionalKeys","apply","cmdString","d","cmds","undefined","frozen","freeze","unfreeze"],"mappings":"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","sourcesContent":["'use strict'\n\nconst inspect = require('util').inspect\nconst path = require('path')\nconst Parser = require('yargs-parser')\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function command (yargs, usage, validation, globalMiddleware) {\n  const self = {}\n  let handlers = {}\n  let aliasMap = {}\n  let defaultCommand\n  globalMiddleware = globalMiddleware || []\n  self.addHandler = function addHandler (cmd, description, builder, handler, middlewares) {\n    let aliases = []\n    handler = handler || (() => {})\n    middlewares = middlewares || []\n    globalMiddleware.push(...middlewares)\n    middlewares = globalMiddleware\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares)\n      return\n    }\n\n    // parse positionals out of cmd string\n    const parsedCommand = self.parseCommand(cmd)\n\n    // remove positional args from aliases only\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd)\n\n    // check for default and filter out '*''\n    let isDefault = false\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true\n        return false\n      }\n      return true\n    })\n\n    // standardize on $0 for default command.\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0')\n\n    // shift cmd and aliases after filtering out '*'\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0]\n      aliases = parsedAliases.slice(1)\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)\n    }\n\n    // populate aliasMap\n    aliases.forEach((alias) => {\n      aliasMap[alias] = parsedCommand.cmd\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]\n  }\n\n  self.addDirectory = function addDirectory (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o\n    // call addHandler via visitor function\n    opts.visit = function visit (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`)\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  self.parseCommand = function parseCommand (cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/)\n    const bregex = /\\.*[\\][<>]/g\n    const parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false\n      cmd = cmd.replace(/\\s/g, '')\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap))\n\n  self.getCommandHandlers = () => handlers\n\n  self.hasDefaultCommand = () => !!defaultCommand\n\n  self.runCommand = function runCommand (command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand\n    const currentContext = yargs.getContext()\n    let numFiles = currentContext.files.length\n    const parentCommands = currentContext.commands.slice()\n\n    // what does yargs look like after the buidler is run?\n    let innerArgv = parsed.argv\n    let innerYargs = null\n    let positionalMap = {}\n    if (command) {\n      currentContext.commands.push(command)\n      currentContext.fullCommands.push(commandHandler.original)\n    }\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))\n      // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n      if (yargs.parsed === false) {\n        if (shouldUpdateUsage(yargs)) {\n          yargs.getUsageInstance().usage(\n            usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n            commandHandler.description\n          )\n        }\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex)\n      } else {\n        innerArgv = yargs.parsed.argv\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases\n      else aliases = yargs.parsed.aliases\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases)\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(\n          usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n          commandHandler.description\n        )\n      }\n      Object.keys(commandHandler.builder).forEach((key) => {\n        innerYargs.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)\n      aliases = innerYargs.parsed.aliases\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)\n    }\n\n    // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput()\n      if (commandHandler.middlewares.length > 0) {\n        const middlewareArgs = commandHandler.middlewares.reduce(function (initialObj, middleware) {\n          return Object.assign(initialObj, middleware(innerArgv))\n        }, {})\n        Object.assign(innerArgv, middlewareArgs)\n      }\n      const handlerResult = commandHandler.handler(innerArgv)\n      if (handlerResult && typeof handlerResult.then === 'function') {\n        handlerResult.then(\n          null,\n          (error) => yargs.getUsageInstance().fail(null, error)\n        )\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop()\n      currentContext.fullCommands.pop()\n    }\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n\n    return innerArgv\n  }\n\n  function shouldUpdateUsage (yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() &&\n      yargs.getUsageInstance().getUsage().length === 0\n  }\n\n  function usageFromParentCommandsCommandHandler (parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original\n    const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c) })\n    pc.push(c)\n    return `$0 ${pc.join(' ')}`\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n        ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ')\n      yargs.getUsageInstance().usage(\n        commandString,\n        defaultCommand.description\n      )\n    }\n    const builder = defaultCommand.builder\n    if (typeof builder === 'function') {\n      builder(yargs)\n    } else {\n      Object.keys(builder).forEach((key) => {\n        yargs.option(key, builder[key])\n      })\n    }\n  }\n\n  // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n  function populatePositionals (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    const demanded = commandHandler.demanded.slice(0)\n    const optional = commandHandler.optional.slice(0)\n    const positionalMap = {}\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      const demand = demanded.shift()\n      populatePositional(demand, argv, positionalMap)\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift()\n      populatePositional(maybe, argv, positionalMap)\n    }\n\n    argv._ = context.commands.concat(argv._)\n\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original))\n\n    return positionalMap\n  }\n\n  function populatePositional (positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0]\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String)\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())]\n    }\n  }\n\n  // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n  function postProcessPositionals (argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions())\n    options.default = Object.assign(parseOptions.default, options.default)\n    options.alias = Object.assign(parseOptions.alias, options.alias)\n    options.array = options.array.concat(parseOptions.array)\n    delete options.config //  don't load config when processing positionals.\n\n    const unparsed = []\n    Object.keys(positionalMap).forEach((key) => {\n      positionalMap[key].map((value) => {\n        unparsed.push(`--${key}`)\n        unparsed.push(value)\n      })\n    })\n\n    // short-circuit parse.\n    if (!unparsed.length) return\n\n    const parsed = Parser.detailed(unparsed, options)\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error)\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap)\n      Object.keys(positionalMap).forEach((key) => {\n        [].push.apply(positionalKeys, parsed.aliases[key])\n      })\n\n      Object.keys(parsed.argv).forEach((key) => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key]\n          argv[key] = parsed.argv[key]\n        }\n      })\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    }\n\n    const parsed = self.parseCommand(cmdString)\n    parsed.demanded.forEach((d) => {\n      const cmds = d.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (d.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n      parseOptions.demand[cmd] = true\n    })\n\n    parsed.optional.forEach((o) => {\n      const cmds = o.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (o.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n    })\n\n    return parseOptions\n  }\n\n  self.reset = () => {\n    handlers = {}\n    aliasMap = {}\n    defaultCommand = undefined\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  let frozen\n  self.freeze = () => {\n    frozen = {}\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n    frozen.defaultCommand = defaultCommand\n  }\n  self.unfreeze = () => {\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    defaultCommand = frozen.defaultCommand\n    frozen = undefined\n  }\n\n  return self\n}\n"]},"metadata":{},"sourceType":"script"}