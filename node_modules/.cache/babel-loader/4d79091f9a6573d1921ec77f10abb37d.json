{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, \"u\");\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\n\nfunction newKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\n\n\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\n\n\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\n\n\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\n\n\nfunction isIIFEStatement(node) {\n  if (node.type === \"ExpressionStatement\") {\n    let call = node.expression;\n\n    if (call.type === \"UnaryExpression\") {\n      call = call.argument;\n    }\n\n    return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n  }\n\n  return false;\n}\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\n\n\nfunction isBlockLikeStatement(sourceCode, node) {\n  // do-while with a block is a block-like statement.\n  if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n    return true;\n  }\n  /*\n   * IIFE is a block-like statement specially from\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\n   */\n\n\n  if (isIIFEStatement(node)) {\n    return true;\n  } // Checks the last token is a closing brace of blocks.\n\n\n  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return Boolean(belongingNode) && (belongingNode.type === \"BlockStatement\" || belongingNode.type === \"SwitchStatement\");\n}\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\n\n\nfunction isDirective(node, sourceCode) {\n  return node.type === \"ExpressionStatement\" && (node.parent.type === \"Program\" || node.parent.type === \"BlockStatement\" && astUtils.isFunction(node.parent.parent)) && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\" && !astUtils.isParenthesised(sourceCode, node.expression);\n}\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\n\n\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\n\n\nfunction getActualLastToken(sourceCode, node) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\n\n\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\n\n\nfunction verifyForAny() {}\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\n\n\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    message: \"Unexpected blank line before this statement.\",\n\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n\n  });\n}\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\n\n\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    message: \"Expected blank line before this statement.\",\n\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n\n        /**\n         * Skip the trailing comments of the previous node.\n         * This inserts a blank line after the last trailing comment.\n         *\n         * For example:\n         *\n         *     foo(); // trailing comment.\n         *     // comment.\n         *     bar();\n         *\n         * Get fixed to:\n         *\n         *     foo(); // trailing comment.\n         *\n         *     // comment.\n         *     bar();\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is not a trailing comment.\n         * @private\n         */\n        filter(token) {\n          if (astUtils.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n\n          return true;\n        }\n\n      }) || nextNode;\n      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? \"\\n\\n\" : \"\\n\";\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n\n  });\n}\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\n\n\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\n\nconst StatementTypes = {\n  \"*\": {\n    test: () => true\n  },\n  \"block-like\": {\n    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n  },\n  \"cjs-export\": {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n  },\n  \"cjs-import\": {\n    test: (node, sourceCode) => node.type === \"VariableDeclaration\" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  \"multiline-block-like\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)\n  },\n  \"multiline-expression\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  \"multiline-const\": newMultilineKeywordTester(\"const\"),\n  \"multiline-let\": newMultilineKeywordTester(\"let\"),\n  \"multiline-var\": newMultilineKeywordTester(\"var\"),\n  \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n  \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n  \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n  block: newNodeTypeTester(\"BlockStatement\"),\n  empty: newNodeTypeTester(\"EmptyStatement\"),\n  function: newNodeTypeTester(\"FunctionDeclaration\"),\n  break: newKeywordTester(\"break\"),\n  case: newKeywordTester(\"case\"),\n  class: newKeywordTester(\"class\"),\n  const: newKeywordTester(\"const\"),\n  continue: newKeywordTester(\"continue\"),\n  debugger: newKeywordTester(\"debugger\"),\n  default: newKeywordTester(\"default\"),\n  do: newKeywordTester(\"do\"),\n  export: newKeywordTester(\"export\"),\n  for: newKeywordTester(\"for\"),\n  if: newKeywordTester(\"if\"),\n  import: newKeywordTester(\"import\"),\n  let: newKeywordTester(\"let\"),\n  return: newKeywordTester(\"return\"),\n  switch: newKeywordTester(\"switch\"),\n  throw: newKeywordTester(\"throw\"),\n  try: newKeywordTester(\"try\"),\n  var: newKeywordTester(\"var\"),\n  while: newKeywordTester(\"while\"),\n  with: newKeywordTester(\"with\")\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding lines between statements\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: \"array\",\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          blankLine: {\n            $ref: \"#/definitions/paddingType\"\n          },\n          prev: {\n            $ref: \"#/definitions/statementType\"\n          },\n          next: {\n            $ref: \"#/definitions/statementType\"\n          }\n        },\n        additionalProperties: false,\n        required: [\"blankLine\", \"prev\", \"next\"]\n      },\n      additionalItems: false\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const configureList = context.options || [];\n    let scopeInfo = null;\n    /**\n     * Processes to enter to new scope.\n     * This manages the current previous statement.\n     * @returns {void}\n     * @private\n     */\n\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n    /**\n     * Processes to exit from the current scope.\n     * @returns {void}\n     * @private\n     */\n\n\n    function exitScope() {\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\n     * Checks whether the given node matches the given type.\n     * @param {ASTNode} node The statement node to check.\n     * @param {string|string[]} type The statement type to check.\n     * @returns {boolean} `true` if the statement node matched the type.\n     * @private\n     */\n\n\n    function match(node, type) {\n      let innerStatementNode = node;\n\n      while (innerStatementNode.type === \"LabeledStatement\") {\n        innerStatementNode = innerStatementNode.body;\n      }\n\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n    /**\n     * Finds the last matched configure from configureList.\n     * @param {ASTNode} prevNode The previous statement to match.\n     * @param {ASTNode} nextNode The current statement to match.\n     * @returns {Object} The tester of the last matched configure.\n     * @private\n     */\n\n\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n\n        if (matched) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n\n      return PaddingTypes.any;\n    }\n    /**\n     * Gets padding line sequences between the given 2 statements.\n     * Comments are separators of the padding line sequences.\n     * @param {ASTNode} prevNode The previous statement to count.\n     * @param {ASTNode} nextNode The current statement to count.\n     * @returns {Array<Token[]>} The array of token pairs.\n     * @private\n     */\n\n\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n\n      return pairs;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n\n\n    function verify(node) {\n      const parentType = node.parent.type;\n      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === \"SwitchStatement\";\n\n      if (!validParent) {\n        return;\n      } // Save this node as the current previous statement.\n\n\n      const prevNode = scopeInfo.prevNode; // Verify.\n\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n\n      scopeInfo.prevNode = node;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * Then process to enter to new scope.\n     * @param {ASTNode} node The node to verify.\n     * @returns {void}\n     * @private\n     */\n\n\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      \"Program:exit\": exitScope,\n      \"BlockStatement:exit\": exitScope,\n      \"SwitchStatement:exit\": exitScope,\n      \":statement\": verify,\n      SwitchCase: verifyThenEnterScope,\n      \"SwitchCase:exit\": exitScope\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/padding-line-between-statements.js"],"names":["astUtils","require","LT","Array","from","LINEBREAKS","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","CJS_EXPORT","CJS_IMPORT","newKeywordTester","keyword","test","node","sourceCode","getFirstToken","value","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","type","isIIFEStatement","call","expression","argument","isFunction","callee","isBlockLikeStatement","body","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","Boolean","isDirective","parent","isParenthesised","isDirectivePrologue","sibling","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","length","report","message","fix","fixer","text","getSourceCode","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","getText","left","declarations","init","directive","iife","block","empty","function","break","case","class","const","continue","debugger","default","do","export","for","if","import","let","return","switch","throw","try","var","while","with","module","exports","meta","docs","description","category","recommended","url","fixable","schema","definitions","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","additionalItems","properties","blankLine","$ref","prev","next","additionalProperties","required","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","isArray","some","bind","getPaddingType","i","configure","matched","getPaddingLineSequences","pairs","push","parentType","validParent","STATEMENT_LIST_PARENTS","has","verifyThenEnterScope","Program","BlockStatement","SwitchStatement","SwitchCase"],"mappings":"AAAA;;;;AAKA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEA,MAAMC,EAAE,GAAI,IAAGC,KAAK,CAACC,IAAN,CAAWJ,QAAQ,CAACK,UAApB,EAAgCC,IAAhC,CAAqC,EAArC,CAAyC,GAAxD;AACA,MAAMC,qBAAqB,GAAG,IAAIC,MAAJ,CAC1BC,MAAM,CAACC,GAAI,SAAQR,EAAG,OAAMA,EAAG,UADL,EAE1B,GAF0B,CAA9B;AAIA,MAAMS,UAAU,GAAG,+CAAnB;AACA,MAAMC,UAAU,GAAG,aAAnB;AAEA;;;;;;;AAMA,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;AAC/B,SAAO;AACHC,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFA,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;AAF1C,GAAP;AAIH;AAED;;;;;;;;AAMA,SAASM,0BAAT,CAAoCN,OAApC,EAA6C;AACzC,SAAO;AACHC,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAN,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;AAH1C,GAAP;AAKH;AAED;;;;;;;;AAMA,SAASW,yBAAT,CAAmCX,OAAnC,EAA4C;AACxC,SAAO;AACHC,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAN,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;AAH1C,GAAP;AAKH;AAED;;;;;;;;AAMA,SAASY,iBAAT,CAA2BC,IAA3B,EAAiC;AAC7B,SAAO;AACHZ,IAAAA,IAAI,EAAEC,IAAI,IACNA,IAAI,CAACW,IAAL,KAAcA;AAFf,GAAP;AAIH;AAED;;;;;;;;AAMA,SAASC,eAAT,CAAyBZ,IAAzB,EAA+B;AAC3B,MAAIA,IAAI,CAACW,IAAL,KAAc,qBAAlB,EAAyC;AACrC,QAAIE,IAAI,GAAGb,IAAI,CAACc,UAAhB;;AAEA,QAAID,IAAI,CAACF,IAAL,KAAc,iBAAlB,EAAqC;AACjCE,MAAAA,IAAI,GAAGA,IAAI,CAACE,QAAZ;AACH;;AACD,WAAOF,IAAI,CAACF,IAAL,KAAc,gBAAd,IAAkC3B,QAAQ,CAACgC,UAAT,CAAoBH,IAAI,CAACI,MAAzB,CAAzC;AACH;;AACD,SAAO,KAAP;AACH;AAED;;;;;;;;;;AAQA,SAASC,oBAAT,CAA8BjB,UAA9B,EAA0CD,IAA1C,EAAgD;AAE5C;AACA,MAAIA,IAAI,CAACW,IAAL,KAAc,kBAAd,IAAoCX,IAAI,CAACmB,IAAL,CAAUR,IAAV,KAAmB,gBAA3D,EAA6E;AACzE,WAAO,IAAP;AACH;AAED;;;;;;AAIA,MAAIC,eAAe,CAACZ,IAAD,CAAnB,EAA2B;AACvB,WAAO,IAAP;AACH,GAb2C,CAe5C;;;AACA,QAAMoB,SAAS,GAAGnB,UAAU,CAACoB,YAAX,CAAwBrB,IAAxB,EAA8BhB,QAAQ,CAACsC,mBAAvC,CAAlB;AACA,QAAMC,aAAa,GAAGH,SAAS,IAAIpC,QAAQ,CAACwC,mBAAT,CAA6BJ,SAA7B,CAAb,GAChBnB,UAAU,CAACwB,mBAAX,CAA+BL,SAAS,CAACM,KAAV,CAAgB,CAAhB,CAA/B,CADgB,GAEhB,IAFN;AAIA,SAAOC,OAAO,CAACJ,aAAD,CAAP,KACHA,aAAa,CAACZ,IAAd,KAAuB,gBAAvB,IACAY,aAAa,CAACZ,IAAd,KAAuB,iBAFpB,CAAP;AAIH;AAED;;;;;;;;AAMA,SAASiB,WAAT,CAAqB5B,IAArB,EAA2BC,UAA3B,EAAuC;AACnC,SACID,IAAI,CAACW,IAAL,KAAc,qBAAd,KAEIX,IAAI,CAAC6B,MAAL,CAAYlB,IAAZ,KAAqB,SAArB,IAEIX,IAAI,CAAC6B,MAAL,CAAYlB,IAAZ,KAAqB,gBAArB,IACA3B,QAAQ,CAACgC,UAAT,CAAoBhB,IAAI,CAAC6B,MAAL,CAAYA,MAAhC,CALR,KAQA7B,IAAI,CAACc,UAAL,CAAgBH,IAAhB,KAAyB,SARzB,IASA,OAAOX,IAAI,CAACc,UAAL,CAAgBX,KAAvB,KAAiC,QATjC,IAUA,CAACnB,QAAQ,CAAC8C,eAAT,CAAyB7B,UAAzB,EAAqCD,IAAI,CAACc,UAA1C,CAXL;AAaH;AAED;;;;;;;;AAMA,SAASiB,mBAAT,CAA6B/B,IAA7B,EAAmCC,UAAnC,EAA+C;AAC3C,MAAI2B,WAAW,CAAC5B,IAAD,EAAOC,UAAP,CAAf,EAAmC;AAC/B,SAAK,MAAM+B,OAAX,IAAsBhC,IAAI,CAAC6B,MAAL,CAAYV,IAAlC,EAAwC;AACpC,UAAIa,OAAO,KAAKhC,IAAhB,EAAsB;AAClB;AACH;;AACD,UAAI,CAAC4B,WAAW,CAACI,OAAD,EAAU/B,UAAV,CAAhB,EAAuC;AACnC,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;AAED;;;;;;;;;;;;;;;AAaA,SAASgC,kBAAT,CAA4BhC,UAA5B,EAAwCD,IAAxC,EAA8C;AAC1C,QAAMkC,SAAS,GAAGjC,UAAU,CAACoB,YAAX,CAAwBrB,IAAxB,CAAlB;AACA,QAAMmC,SAAS,GAAGlC,UAAU,CAACmC,cAAX,CAA0BF,SAA1B,CAAlB;AACA,QAAMG,SAAS,GAAGpC,UAAU,CAACqC,aAAX,CAAyBJ,SAAzB,CAAlB;AACA,QAAMK,oBAAoB,GAAGZ,OAAO,CAChCQ,SAAS,IACTE,SADA,IAEAF,SAAS,CAACT,KAAV,CAAgB,CAAhB,KAAsB1B,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAFtB,IAGA1C,QAAQ,CAACwD,gBAAT,CAA0BN,SAA1B,CAHA,IAIAA,SAAS,CAAC7B,GAAV,CAAcC,KAAd,CAAoBC,IAApB,KAA6B4B,SAAS,CAAC9B,GAAV,CAAcG,GAAd,CAAkBD,IAJ/C,IAKA2B,SAAS,CAAC7B,GAAV,CAAcG,GAAd,CAAkBD,IAAlB,KAA2B8B,SAAS,CAAChC,GAAV,CAAcC,KAAd,CAAoBC,IANf,CAApC;AASA,SAAOgC,oBAAoB,GAAGJ,SAAH,GAAeD,SAA1C;AACH;AAED;;;;;;;;;;AAQA,SAASO,4BAAT,CAAsCC,CAAtC,EAAyCC,cAAzC,EAAyDC,YAAzD,EAAuE;AACnE,SAAOD,cAAc,GAAGC,YAAxB;AACH;AAED;;;;;;;;AAMA,SAASC,YAAT,GAAwB,CACvB;AAED;;;;;;;;;;;;;;;AAaA,SAASC,cAAT,CAAwBC,OAAxB,EAAiCL,CAAjC,EAAoCM,QAApC,EAA8CC,YAA9C,EAA4D;AACxD,MAAIA,YAAY,CAACC,MAAb,KAAwB,CAA5B,EAA+B;AAC3B;AACH;;AAEDH,EAAAA,OAAO,CAACI,MAAR,CAAe;AACXnD,IAAAA,IAAI,EAAEgD,QADK;AAEXI,IAAAA,OAAO,EAAE,8CAFE;;AAGXC,IAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,UAAIL,YAAY,CAACC,MAAb,IAAuB,CAA3B,EAA8B;AAC1B,eAAO,IAAP;AACH;;AAED,YAAMf,SAAS,GAAGc,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,CAAlB;AACA,YAAMZ,SAAS,GAAGY,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,CAAlB;AACA,YAAM3C,KAAK,GAAG6B,SAAS,CAACT,KAAV,CAAgB,CAAhB,CAAd;AACA,YAAMlB,GAAG,GAAG6B,SAAS,CAACX,KAAV,CAAgB,CAAhB,CAAZ;AACA,YAAM6B,IAAI,GAAGR,OAAO,CAACS,aAAR,GAAwBD,IAAxB,CACRE,KADQ,CACFnD,KADE,EACKE,GADL,EAERkD,OAFQ,CAEAnE,qBAFA,EAEuBkD,4BAFvB,CAAb;AAIA,aAAOa,KAAK,CAACK,gBAAN,CAAuB,CAACrD,KAAD,EAAQE,GAAR,CAAvB,EAAqC+C,IAArC,CAAP;AACH;;AAjBU,GAAf;AAmBH;AAED;;;;;;;;;;;;;;;AAaA,SAASK,eAAT,CAAyBb,OAAzB,EAAkCc,QAAlC,EAA4Cb,QAA5C,EAAsDC,YAAtD,EAAoE;AAChE,MAAIA,YAAY,CAACC,MAAb,GAAsB,CAA1B,EAA6B;AACzB;AACH;;AAEDH,EAAAA,OAAO,CAACI,MAAR,CAAe;AACXnD,IAAAA,IAAI,EAAEgD,QADK;AAEXI,IAAAA,OAAO,EAAE,4CAFE;;AAGXC,IAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,YAAMrD,UAAU,GAAG8C,OAAO,CAACS,aAAR,EAAnB;AACA,UAAIrB,SAAS,GAAGF,kBAAkB,CAAChC,UAAD,EAAa4D,QAAb,CAAlC;AACA,YAAMxB,SAAS,GAAGpC,UAAU,CAAC6D,oBAAX,CACd3B,SADc,EAEda,QAFc,EAGd;AACIe,QAAAA,eAAe,EAAE,IADrB;;AAGI;;;;;;;;;;;;;;;;;;;;AAoBAC,QAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,cAAIjF,QAAQ,CAACkF,iBAAT,CAA2B/B,SAA3B,EAAsC8B,KAAtC,CAAJ,EAAkD;AAC9C9B,YAAAA,SAAS,GAAG8B,KAAZ;AACA,mBAAO,KAAP;AACH;;AACD,iBAAO,IAAP;AACH;;AA7BL,OAHc,KAkCbjB,QAlCL;AAmCA,YAAMmB,UAAU,GAAGnF,QAAQ,CAACkF,iBAAT,CAA2B/B,SAA3B,EAAsCE,SAAtC,IACb,MADa,GAEb,IAFN;AAIA,aAAOiB,KAAK,CAACc,eAAN,CAAsBjC,SAAtB,EAAiCgC,UAAjC,CAAP;AACH;;AA9CU,GAAf;AAgDH;AAED;;;;;;;;AAMA,MAAME,YAAY,GAAG;AACjBC,EAAAA,GAAG,EAAE;AAAEC,IAAAA,MAAM,EAAE1B;AAAV,GADY;AAEjB2B,EAAAA,KAAK,EAAE;AAAED,IAAAA,MAAM,EAAEzB;AAAV,GAFU;AAGjB2B,EAAAA,MAAM,EAAE;AAAEF,IAAAA,MAAM,EAAEX;AAAV;AAHS,CAArB;AAMA;;;;;;AAKA,MAAMc,cAAc,GAAG;AACnB,OAAK;AAAE3E,IAAAA,IAAI,EAAE,MAAM;AAAd,GADc;AAEnB,gBAAc;AACVA,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KAAsBiB,oBAAoB,CAACjB,UAAD,EAAaD,IAAb;AADtC,GAFK;AAKnB,gBAAc;AACVD,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACAX,IAAI,CAACc,UAAL,CAAgBH,IAAhB,KAAyB,sBADzB,IAEAhB,UAAU,CAACI,IAAX,CAAgBE,UAAU,CAAC0E,OAAX,CAAmB3E,IAAI,CAACc,UAAL,CAAgB8D,IAAnC,CAAhB;AAJM,GALK;AAWnB,gBAAc;AACV7E,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACAX,IAAI,CAAC6E,YAAL,CAAkB3B,MAAlB,GAA2B,CAD3B,IAEAvB,OAAO,CAAC3B,IAAI,CAAC6E,YAAL,CAAkB,CAAlB,EAAqBC,IAAtB,CAFP,IAGAlF,UAAU,CAACG,IAAX,CAAgBE,UAAU,CAAC0E,OAAX,CAAmB3E,IAAI,CAAC6E,YAAL,CAAkB,CAAlB,EAAqBC,IAAxC,CAAhB;AALM,GAXK;AAkBnBC,EAAAA,SAAS,EAAE;AACPhF,IAAAA,IAAI,EAAEgC;AADC,GAlBQ;AAqBnBjB,EAAAA,UAAU,EAAE;AACRf,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACA,CAACoB,mBAAmB,CAAC/B,IAAD,EAAOC,UAAP;AAHhB,GArBO;AA0BnB+E,EAAAA,IAAI,EAAE;AACFjF,IAAAA,IAAI,EAAEa;AADJ,GA1Ba;AA6BnB,0BAAwB;AACpBb,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAW,oBAAoB,CAACjB,UAAD,EAAaD,IAAb;AAHJ,GA7BL;AAkCnB,0BAAwB;AACpBD,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAP,IAAI,CAACW,IAAL,KAAc,qBADd,IAEA,CAACoB,mBAAmB,CAAC/B,IAAD,EAAOC,UAAP;AAJJ,GAlCL;AAyCnB,qBAAmBQ,yBAAyB,CAAC,OAAD,CAzCzB;AA0CnB,mBAAiBA,yBAAyB,CAAC,KAAD,CA1CvB;AA2CnB,mBAAiBA,yBAAyB,CAAC,KAAD,CA3CvB;AA4CnB,sBAAoBL,0BAA0B,CAAC,OAAD,CA5C3B;AA6CnB,oBAAkBA,0BAA0B,CAAC,KAAD,CA7CzB;AA8CnB,oBAAkBA,0BAA0B,CAAC,KAAD,CA9CzB;AAgDnB6E,EAAAA,KAAK,EAAEvE,iBAAiB,CAAC,gBAAD,CAhDL;AAiDnBwE,EAAAA,KAAK,EAAExE,iBAAiB,CAAC,gBAAD,CAjDL;AAkDnByE,EAAAA,QAAQ,EAAEzE,iBAAiB,CAAC,qBAAD,CAlDR;AAoDnB0E,EAAAA,KAAK,EAAEvF,gBAAgB,CAAC,OAAD,CApDJ;AAqDnBwF,EAAAA,IAAI,EAAExF,gBAAgB,CAAC,MAAD,CArDH;AAsDnByF,EAAAA,KAAK,EAAEzF,gBAAgB,CAAC,OAAD,CAtDJ;AAuDnB0F,EAAAA,KAAK,EAAE1F,gBAAgB,CAAC,OAAD,CAvDJ;AAwDnB2F,EAAAA,QAAQ,EAAE3F,gBAAgB,CAAC,UAAD,CAxDP;AAyDnB4F,EAAAA,QAAQ,EAAE5F,gBAAgB,CAAC,UAAD,CAzDP;AA0DnB6F,EAAAA,OAAO,EAAE7F,gBAAgB,CAAC,SAAD,CA1DN;AA2DnB8F,EAAAA,EAAE,EAAE9F,gBAAgB,CAAC,IAAD,CA3DD;AA4DnB+F,EAAAA,MAAM,EAAE/F,gBAAgB,CAAC,QAAD,CA5DL;AA6DnBgG,EAAAA,GAAG,EAAEhG,gBAAgB,CAAC,KAAD,CA7DF;AA8DnBiG,EAAAA,EAAE,EAAEjG,gBAAgB,CAAC,IAAD,CA9DD;AA+DnBkG,EAAAA,MAAM,EAAElG,gBAAgB,CAAC,QAAD,CA/DL;AAgEnBmG,EAAAA,GAAG,EAAEnG,gBAAgB,CAAC,KAAD,CAhEF;AAiEnBoG,EAAAA,MAAM,EAAEpG,gBAAgB,CAAC,QAAD,CAjEL;AAkEnBqG,EAAAA,MAAM,EAAErG,gBAAgB,CAAC,QAAD,CAlEL;AAmEnBsG,EAAAA,KAAK,EAAEtG,gBAAgB,CAAC,OAAD,CAnEJ;AAoEnBuG,EAAAA,GAAG,EAAEvG,gBAAgB,CAAC,KAAD,CApEF;AAqEnBwG,EAAAA,GAAG,EAAExG,gBAAgB,CAAC,KAAD,CArEF;AAsEnByG,EAAAA,KAAK,EAAEzG,gBAAgB,CAAC,OAAD,CAtEJ;AAuEnB0G,EAAAA,IAAI,EAAE1G,gBAAgB,CAAC,MAAD;AAvEH,CAAvB,C,CA0EA;AACA;AACA;;AAEA2G,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACF/F,IAAAA,IAAI,EAAE,QADJ;AAGFgG,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,sDADX;AAEFC,MAAAA,QAAQ,EAAE,kBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,OAAO,EAAE,YAVP;AAYFC,IAAAA,MAAM,EAAE;AACJC,MAAAA,WAAW,EAAE;AACTC,QAAAA,WAAW,EAAE;AACTC,UAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAYjD,YAAZ;AADG,SADJ;AAITkD,QAAAA,aAAa,EAAE;AACXC,UAAAA,KAAK,EAAE,CACH;AAAEJ,YAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAY5C,cAAZ;AAAR,WADG,EAEH;AACI/D,YAAAA,IAAI,EAAE,OADV;AAEI8G,YAAAA,KAAK,EAAE;AAAEL,cAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAY5C,cAAZ;AAAR,aAFX;AAGIgD,YAAAA,QAAQ,EAAE,CAHd;AAIIC,YAAAA,WAAW,EAAE,IAJjB;AAKIC,YAAAA,eAAe,EAAE;AALrB,WAFG;AADI;AAJN,OADT;AAkBJjH,MAAAA,IAAI,EAAE,OAlBF;AAmBJ8G,MAAAA,KAAK,EAAE;AACH9G,QAAAA,IAAI,EAAE,QADH;AAEHkH,QAAAA,UAAU,EAAE;AACRC,UAAAA,SAAS,EAAE;AAAEC,YAAAA,IAAI,EAAE;AAAR,WADH;AAERC,UAAAA,IAAI,EAAE;AAAED,YAAAA,IAAI,EAAE;AAAR,WAFE;AAGRE,UAAAA,IAAI,EAAE;AAAEF,YAAAA,IAAI,EAAE;AAAR;AAHE,SAFT;AAOHG,QAAAA,oBAAoB,EAAE,KAPnB;AAQHC,QAAAA,QAAQ,EAAE,CAAC,WAAD,EAAc,MAAd,EAAsB,MAAtB;AARP,OAnBH;AA6BJP,MAAAA,eAAe,EAAE;AA7Bb;AAZN,GADO;;AA8CbQ,EAAAA,MAAM,CAACrF,OAAD,EAAU;AACZ,UAAM9C,UAAU,GAAG8C,OAAO,CAACS,aAAR,EAAnB;AACA,UAAM6E,aAAa,GAAGtF,OAAO,CAACuF,OAAR,IAAmB,EAAzC;AACA,QAAIC,SAAS,GAAG,IAAhB;AAEA;;;;;;;AAMA,aAASC,UAAT,GAAsB;AAClBD,MAAAA,SAAS,GAAG;AACRE,QAAAA,KAAK,EAAEF,SADC;AAER1E,QAAAA,QAAQ,EAAE;AAFF,OAAZ;AAIH;AAED;;;;;;;AAKA,aAAS6E,SAAT,GAAqB;AACjBH,MAAAA,SAAS,GAAGA,SAAS,CAACE,KAAtB;AACH;AAED;;;;;;;;;AAOA,aAASE,KAAT,CAAe3I,IAAf,EAAqBW,IAArB,EAA2B;AACvB,UAAIiI,kBAAkB,GAAG5I,IAAzB;;AAEA,aAAO4I,kBAAkB,CAACjI,IAAnB,KAA4B,kBAAnC,EAAuD;AACnDiI,QAAAA,kBAAkB,GAAGA,kBAAkB,CAACzH,IAAxC;AACH;;AACD,UAAIhC,KAAK,CAAC0J,OAAN,CAAclI,IAAd,CAAJ,EAAyB;AACrB,eAAOA,IAAI,CAACmI,IAAL,CAAUH,KAAK,CAACI,IAAN,CAAW,IAAX,EAAiBH,kBAAjB,CAAV,CAAP;AACH;;AACD,aAAOlE,cAAc,CAAC/D,IAAD,CAAd,CAAqBZ,IAArB,CAA0B6I,kBAA1B,EAA8C3I,UAA9C,CAAP;AACH;AAED;;;;;;;;;AAOA,aAAS+I,cAAT,CAAwBnF,QAAxB,EAAkCb,QAAlC,EAA4C;AACxC,WAAK,IAAIiG,CAAC,GAAGZ,aAAa,CAACnF,MAAd,GAAuB,CAApC,EAAuC+F,CAAC,IAAI,CAA5C,EAA+C,EAAEA,CAAjD,EAAoD;AAChD,cAAMC,SAAS,GAAGb,aAAa,CAACY,CAAD,CAA/B;AACA,cAAME,OAAO,GACTR,KAAK,CAAC9E,QAAD,EAAWqF,SAAS,CAAClB,IAArB,CAAL,IACAW,KAAK,CAAC3F,QAAD,EAAWkG,SAAS,CAACjB,IAArB,CAFT;;AAIA,YAAIkB,OAAJ,EAAa;AACT,iBAAO9E,YAAY,CAAC6E,SAAS,CAACpB,SAAX,CAAnB;AACH;AACJ;;AACD,aAAOzD,YAAY,CAACC,GAApB;AACH;AAED;;;;;;;;;;AAQA,aAAS8E,uBAAT,CAAiCvF,QAAjC,EAA2Cb,QAA3C,EAAqD;AACjD,YAAMqG,KAAK,GAAG,EAAd;AACA,UAAIlH,SAAS,GAAGF,kBAAkB,CAAChC,UAAD,EAAa4D,QAAb,CAAlC;;AAEA,UAAIb,QAAQ,CAAC3C,GAAT,CAAaC,KAAb,CAAmBC,IAAnB,GAA0B4B,SAAS,CAAC9B,GAAV,CAAcG,GAAd,CAAkBD,IAA5C,IAAoD,CAAxD,EAA2D;AACvD,WAAG;AACC,gBAAM0D,KAAK,GAAGhE,UAAU,CAACqC,aAAX,CACVH,SADU,EAEV;AAAE4B,YAAAA,eAAe,EAAE;AAAnB,WAFU,CAAd;;AAKA,cAAIE,KAAK,CAAC5D,GAAN,CAAUC,KAAV,CAAgBC,IAAhB,GAAuB4B,SAAS,CAAC9B,GAAV,CAAcG,GAAd,CAAkBD,IAAzC,IAAiD,CAArD,EAAwD;AACpD8I,YAAAA,KAAK,CAACC,IAAN,CAAW,CAACnH,SAAD,EAAY8B,KAAZ,CAAX;AACH;;AACD9B,UAAAA,SAAS,GAAG8B,KAAZ;AAEH,SAXD,QAWS9B,SAAS,CAACT,KAAV,CAAgB,CAAhB,IAAqBsB,QAAQ,CAACtB,KAAT,CAAe,CAAf,CAX9B;AAYH;;AAED,aAAO2H,KAAP;AACH;AAED;;;;;;;;AAMA,aAAS9E,MAAT,CAAgBvE,IAAhB,EAAsB;AAClB,YAAMuJ,UAAU,GAAGvJ,IAAI,CAAC6B,MAAL,CAAYlB,IAA/B;AACA,YAAM6I,WAAW,GACbxK,QAAQ,CAACyK,sBAAT,CAAgCC,GAAhC,CAAoCH,UAApC,KACAA,UAAU,KAAK,iBAFnB;;AAIA,UAAI,CAACC,WAAL,EAAkB;AACd;AACH,OARiB,CAUlB;;;AACA,YAAM3F,QAAQ,GAAG0E,SAAS,CAAC1E,QAA3B,CAXkB,CAalB;;AACA,UAAIA,QAAJ,EAAc;AACV,cAAMlD,IAAI,GAAGqI,cAAc,CAACnF,QAAD,EAAW7D,IAAX,CAA3B;AACA,cAAMiD,YAAY,GAAGmG,uBAAuB,CAACvF,QAAD,EAAW7D,IAAX,CAA5C;AAEAW,QAAAA,IAAI,CAAC4D,MAAL,CAAYxB,OAAZ,EAAqBc,QAArB,EAA+B7D,IAA/B,EAAqCiD,YAArC;AACH;;AAEDsF,MAAAA,SAAS,CAAC1E,QAAV,GAAqB7D,IAArB;AACH;AAED;;;;;;;;;AAOA,aAAS2J,oBAAT,CAA8B3J,IAA9B,EAAoC;AAChCuE,MAAAA,MAAM,CAACvE,IAAD,CAAN;AACAwI,MAAAA,UAAU;AACb;;AAED,WAAO;AACHoB,MAAAA,OAAO,EAAEpB,UADN;AAEHqB,MAAAA,cAAc,EAAErB,UAFb;AAGHsB,MAAAA,eAAe,EAAEtB,UAHd;AAIH,sBAAgBE,SAJb;AAKH,6BAAuBA,SALpB;AAMH,8BAAwBA,SANrB;AAQH,oBAAcnE,MARX;AAUHwF,MAAAA,UAAU,EAAEJ,oBAVT;AAWH,yBAAmBjB;AAXhB,KAAP;AAaH;;AAtMY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\n    \"u\"\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line === node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = node.expression;\n\n        if (call.type === \"UnaryExpression\") {\n            call = call.argument;\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    /*\n     * IIFE is a block-like statement specially from\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\n     */\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n    return (\n        node.type === \"ExpressionStatement\" &&\n        (\n            node.parent.type === \"Program\" ||\n            (\n                node.parent.type === \"BlockStatement\" &&\n                astUtils.isFunction(node.parent.parent)\n            )\n        ) &&\n        node.expression.type === \"Literal\" &&\n        typeof node.expression.value === \"string\" &&\n        !astUtils.isParenthesised(sourceCode, node.expression)\n    );\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n    if (isDirective(node, sourceCode)) {\n        for (const sibling of node.parent.body) {\n            if (sibling === node) {\n                break;\n            }\n            if (!isDirective(sibling, sourceCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        message: \"Unexpected blank line before this statement.\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.getSourceCode().text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        message: \"Expected blank line before this statement.\",\n        fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: isDirectivePrologue\n    },\n    expression: {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n    iife: {\n        test: isIIFEStatement\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n    \"multiline-expression\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding lines between statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true,\n                            additionalItems: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            additionalItems: false\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            let innerStatementNode = node;\n\n            while (innerStatementNode.type === \"LabeledStatement\") {\n                innerStatementNode = innerStatementNode.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, innerStatementNode));\n            }\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}