{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.streams = function (e) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:streams:4.3.1\"] && _();\n  } catch (e) {}\n\n  function n(e) {\n    const n = e.map(e => Promise.resolve(e).then(e => function (e) {\n      return e.body && e.body.getReader ? e.body.getReader() : e.getReader ? e.getReader() : new Response(e).body.getReader();\n    }(e)));\n    let t, r;\n    const s = new Promise((e, n) => {\n      t = e, r = n;\n    });\n    let o = 0;\n    return {\n      done: s,\n      stream: new ReadableStream({\n        pull(e) {\n          return n[o].then(e => e.read()).then(r => {\n            if (r.done) return ++o >= n.length ? (e.close(), void t()) : this.pull(e);\n            e.enqueue(r.value);\n          }).catch(e => {\n            throw r(e), e;\n          });\n        },\n\n        cancel() {\n          t();\n        }\n\n      })\n    };\n  }\n\n  function t(e = {}) {\n    const n = new Headers(e);\n    return n.has(\"content-type\") || n.set(\"content-type\", \"text/html\"), n;\n  }\n\n  function r(e, r) {\n    const {\n      done: s,\n      stream: o\n    } = n(e),\n          a = t(r);\n    return {\n      done: s,\n      response: new Response(o, {\n        headers: a\n      })\n    };\n  }\n\n  let s = void 0;\n\n  function o() {\n    if (void 0 === s) try {\n      new ReadableStream({\n        start() {}\n\n      }), s = !0;\n    } catch (e) {\n      s = !1;\n    }\n    return s;\n  }\n\n  return e.concatenate = n, e.concatenateToResponse = r, e.isSupported = o, e.strategy = function (e, n) {\n    return async ({\n      event: s,\n      url: a,\n      params: c\n    }) => {\n      if (o()) {\n        const {\n          done: t,\n          response: o\n        } = r(e.map(e => e({\n          event: s,\n          url: a,\n          params: c\n        })), n);\n        return s.waitUntil(t), o;\n      }\n\n      const i = await Promise.all(e.map(e => e({\n        event: s,\n        url: a,\n        params: c\n      })).map(async e => {\n        const n = await e;\n        return n instanceof Response ? n.blob() : n;\n      })),\n            u = t(n);\n      return new Response(new Blob(i), {\n        headers: u\n      });\n    };\n  }, e;\n}({});","map":{"version":3,"sources":["../_version.mjs","../concatenate.mjs","../utils/createHeaders.mjs","../concatenateToResponse.mjs","../isSupported.mjs","../strategy.mjs"],"names":["self","_","e","source","body","getReader","Response","concatenate","sourcePromises","readerPromises","map","sourcePromise","Promise","resolve","then","fullyStreamedResolve","fullyStreamedReject","done","reject","i","ReadableStream","pull","controller","reader","read","result","length","close","this","enqueue","value","catch","error","cancel","stream","createHeaders","headersInit","headers","Headers","has","set","concatenateToResponse","response","cachedIsSupported","undefined","isSupported","start","sourceFunctions","async","event","url","params","fn","waitUntil","parts","all","sourceFunction","responsePromise","blob","Blob"],"mappings":"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","sourcesContent":["try{self['workbox:streams:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {workbox.streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n  if (source.body && source.body.getReader) {\n    return source.body.getReader();\n  }\n\n  if (source.getReader) {\n    return source.getReader();\n  }\n\n  // TODO: This should be possible to do by constructing a ReadableStream, but\n  // I can't get it to work. As a hack, construct a new Response, and use the\n  // reader associated with its body.\n  return new Response(source).body.getReader();\n}\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenate(sourcePromises) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isArray(sourcePromises, {\n      moduleName: 'workbox-streams',\n      funcName: 'concatenate',\n      paramName: 'sourcePromises',\n    });\n  }\n\n  const readerPromises = sourcePromises.map((sourcePromise) => {\n    return Promise.resolve(sourcePromise).then((source) => {\n      return _getReaderFromSource(source);\n    });\n  });\n\n  let fullyStreamedResolve;\n  let fullyStreamedReject;\n  const done = new Promise((resolve, reject) => {\n    fullyStreamedResolve = resolve;\n    fullyStreamedReject = reject;\n  });\n\n  let i = 0;\n  const logMessages = [];\n  const stream = new ReadableStream({\n    pull(controller) {\n      return readerPromises[i]\n          .then((reader) => reader.read())\n          .then((result) => {\n            if (result.done) {\n              if (process.env.NODE_ENV !== 'production') {\n                logMessages.push(['Reached the end of source:',\n                  sourcePromises[i]]);\n              }\n\n              i++;\n              if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.groupCollapsed(\n                      `Concatenating ${readerPromises.length} sources.`);\n                  for (const message of logMessages) {\n                    if (Array.isArray(message)) {\n                      logger.log(...message);\n                    } else {\n                      logger.log(message);\n                    }\n                  }\n                  logger.log('Finished reading all sources.');\n                  logger.groupEnd();\n                }\n\n                controller.close();\n                fullyStreamedResolve();\n                return;\n              }\n\n              return this.pull(controller);\n            } else {\n              controller.enqueue(result.value);\n            }\n          }).catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error('An error occurred:', error);\n            }\n            fullyStreamedReject(error);\n            throw error;\n          });\n    },\n\n    cancel() {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('The ReadableStream was cancelled.');\n      }\n\n      fullyStreamedResolve();\n    },\n  });\n\n  return {done, stream};\n}\n\nexport {concatenate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox.streams\n */\nfunction createHeaders(headersInit = {}) {\n  // See https://github.com/GoogleChrome/workbox/issues/1461\n  const headers = new Headers(headersInit);\n  if (!headers.has('content-type')) {\n    headers.set('content-type', 'text/html');\n  }\n  return headers;\n}\n\nexport {createHeaders};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenate} from './concatenate.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n  const {done, stream} = concatenate(sourcePromises);\n\n  const headers = createHeaders(headersInit);\n  const response = new Response(stream, {headers});\n\n  return {done, response};\n}\n\nexport {concatenateToResponse};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\nlet cachedIsSupported = undefined;\n\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox.streams\n */\nfunction isSupported() {\n  if (cachedIsSupported === undefined) {\n    // See https://github.com/GoogleChrome/workbox/issues/1473\n    try {\n      new ReadableStream({start() {}});\n      cachedIsSupported = true;\n    } catch (error) {\n      cachedIsSupported = false;\n    }\n  }\n\n  return cachedIsSupported;\n}\n\nexport {isSupported};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenateToResponse} from './concatenateToResponse.mjs';\nimport {isSupported} from './isSupported.mjs';\n\nimport './_version.mjs';\n\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {\n *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n * Each function should return a {@link workbox.streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {workbox.routing.Route~handlerCallback}\n *\n * @memberof workbox.streams\n */\nexport function strategy(sourceFunctions, headersInit) {\n  return async ({event, url, params}) => {\n    if (isSupported()) {\n      const {done, response} = concatenateToResponse(sourceFunctions.map(\n          (fn) => fn({event, url, params})), headersInit);\n      event.waitUntil(done);\n      return response;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`The current browser doesn't support creating response ` +\n        `streams. Falling back to non-streaming response instead.`);\n    }\n\n    // Fallback to waiting for everything to finish, and concatenating the\n    // responses.\n    const parts = await Promise.all(\n        sourceFunctions.map(\n            (sourceFunction) => sourceFunction({event, url, params})\n        ).map(async (responsePromise) => {\n          const response = await responsePromise;\n          if (response instanceof Response) {\n            return response.blob();\n          }\n\n          // Otherwise, assume it's something like a string which can be used\n          // as-is when constructing the final composite blob.\n          return response;\n        })\n    );\n\n    const headers = createHeaders(headersInit);\n    // Constructing a new Response from a Blob source is well-supported.\n    // So is constructing a new Blob from multiple source Blobs or strings.\n    return new Response(new Blob(parts), {headers});\n  };\n}\n"]},"metadata":{},"sourceType":"script"}