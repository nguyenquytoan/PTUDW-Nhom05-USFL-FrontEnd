{"ast":null,"code":"/*!\n * write <https://github.com/jonschlinkert/write>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar mkdirp = require('mkdirp');\n/**\n * Asynchronously writes data to a file, replacing the file if it already\n * exists and creating any intermediate directories if they don't already\n * exist. Data can be a string or a buffer. Returns a promise if a callback\n * function is not passed.\n *\n * ```js\n * var writeFile = require('write');\n * writeFile('foo.txt', 'This is content...', function(err) {\n *   if (err) console.log(err);\n * });\n *\n * // promise\n * writeFile('foo.txt', 'This is content...')\n *   .then(function() {\n *     // do stuff\n *   });\n * ```\n * @name writeFile\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {string|Buffer|Uint8Array} `data` String to write to disk.\n * @param {object} `options` Options to pass to [fs.writeFile][fs]{#fs_fs_writefile_file_data_options_callback} and/or [mkdirp][]\n * @param {Function} `callback` (optional) If no callback is provided, a promise is returned.\n * @api public\n */\n\n\nfunction writeFile(filepath, data, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (typeof cb !== 'function') {\n    return writeFile.promise.apply(null, arguments);\n  }\n\n  if (typeof filepath !== 'string') {\n    cb(new TypeError('expected filepath to be a string'));\n    return;\n  }\n\n  mkdirp(path.dirname(filepath), options, function (err) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    fs.writeFile(filepath, data, options, cb);\n  });\n}\n\n;\n/**\n * The promise version of [writeFile](#writefile). Returns a promise.\n *\n * ```js\n * var writeFile = require('write');\n * writeFile.promise('foo.txt', 'This is content...')\n *   .then(function() {\n *     // do stuff\n *   });\n * ```\n * @name .promise\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {string|Buffer|Uint8Array} `val` String or buffer to write to disk.\n * @param {object} `options` Options to pass to [fs.writeFile][fs]{#fs_fs_writefile_file_data_options_callback} and/or [mkdirp][]\n * @return {Promise}\n * @api public\n */\n\nwriteFile.promise = function (filepath, val, options) {\n  if (typeof filepath !== 'string') {\n    return Promise.reject(new TypeError('expected filepath to be a string'));\n  }\n\n  return new Promise(function (resolve, reject) {\n    mkdirp(path.dirname(filepath), options, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      fs.writeFile(filepath, val, options, function (err) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(val);\n      });\n    });\n  });\n};\n/**\n * The synchronous version of [writeFile](#writefile). Returns undefined.\n *\n * ```js\n * var writeFile = require('write');\n * writeFile.sync('foo.txt', 'This is content...');\n * ```\n * @name .sync\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {string|Buffer|Uint8Array} `data` String or buffer to write to disk.\n * @param {object} `options` Options to pass to [fs.writeFileSync][fs]{#fs_fs_writefilesync_file_data_options} and/or [mkdirp][]\n * @return {undefined}\n * @api public\n */\n\n\nwriteFile.sync = function (filepath, data, options) {\n  if (typeof filepath !== 'string') {\n    throw new TypeError('expected filepath to be a string');\n  }\n\n  mkdirp.sync(path.dirname(filepath), options);\n  fs.writeFileSync(filepath, data, options);\n};\n/**\n * Uses `fs.createWriteStream` to write data to a file, replacing the\n * file if it already exists and creating any intermediate directories\n * if they don't already exist. Data can be a string or a buffer. Returns\n * a new [WriteStream](https://nodejs.org/api/fs.html#fs_class_fs_writestream)\n * object.\n *\n * ```js\n * var fs = require('fs');\n * var writeFile = require('write');\n * fs.createReadStream('README.md')\n *   .pipe(writeFile.stream('a/b/c/other-file.md'))\n *   .on('close', function() {\n *     // do stuff\n *   });\n * ```\n * @name .stream\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {object} `options` Options to pass to [mkdirp][] and [fs.createWriteStream][fs]{#fs_fs_createwritestream_path_options}\n * @return {Stream} Returns a new [WriteStream](https://nodejs.org/api/fs.html#fs_class_fs_writestream) object. (See [Writable Stream](https://nodejs.org/api/stream.html#stream_class_stream_writable)).\n * @api public\n */\n\n\nwriteFile.stream = function (filepath, options) {\n  mkdirp.sync(path.dirname(filepath), options);\n  return fs.createWriteStream(filepath, options);\n};\n/**\n * Expose `writeFile`\n */\n\n\nmodule.exports = writeFile;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/write/index.js"],"names":["fs","require","path","mkdirp","writeFile","filepath","data","options","cb","promise","apply","arguments","TypeError","dirname","err","val","Promise","reject","resolve","sync","writeFileSync","stream","createWriteStream","module","exports"],"mappings":"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","sourcesContent":["/*!\n * write <https://github.com/jonschlinkert/write>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar mkdirp = require('mkdirp');\n\n/**\n * Asynchronously writes data to a file, replacing the file if it already\n * exists and creating any intermediate directories if they don't already\n * exist. Data can be a string or a buffer. Returns a promise if a callback\n * function is not passed.\n *\n * ```js\n * var writeFile = require('write');\n * writeFile('foo.txt', 'This is content...', function(err) {\n *   if (err) console.log(err);\n * });\n *\n * // promise\n * writeFile('foo.txt', 'This is content...')\n *   .then(function() {\n *     // do stuff\n *   });\n * ```\n * @name writeFile\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {string|Buffer|Uint8Array} `data` String to write to disk.\n * @param {object} `options` Options to pass to [fs.writeFile][fs]{#fs_fs_writefile_file_data_options_callback} and/or [mkdirp][]\n * @param {Function} `callback` (optional) If no callback is provided, a promise is returned.\n * @api public\n */\n\nfunction writeFile(filepath, data, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (typeof cb !== 'function') {\n    return writeFile.promise.apply(null, arguments);\n  }\n\n  if (typeof filepath !== 'string') {\n    cb(new TypeError('expected filepath to be a string'));\n    return;\n  }\n\n  mkdirp(path.dirname(filepath), options, function(err) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    fs.writeFile(filepath, data, options, cb);\n  });\n};\n\n/**\n * The promise version of [writeFile](#writefile). Returns a promise.\n *\n * ```js\n * var writeFile = require('write');\n * writeFile.promise('foo.txt', 'This is content...')\n *   .then(function() {\n *     // do stuff\n *   });\n * ```\n * @name .promise\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {string|Buffer|Uint8Array} `val` String or buffer to write to disk.\n * @param {object} `options` Options to pass to [fs.writeFile][fs]{#fs_fs_writefile_file_data_options_callback} and/or [mkdirp][]\n * @return {Promise}\n * @api public\n */\n\nwriteFile.promise = function(filepath, val, options) {\n  if (typeof filepath !== 'string') {\n    return Promise.reject(new TypeError('expected filepath to be a string'));\n  }\n\n  return new Promise(function(resolve, reject) {\n    mkdirp(path.dirname(filepath), options, function(err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      fs.writeFile(filepath, val, options, function(err) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(val);\n      });\n    });\n  });\n};\n\n/**\n * The synchronous version of [writeFile](#writefile). Returns undefined.\n *\n * ```js\n * var writeFile = require('write');\n * writeFile.sync('foo.txt', 'This is content...');\n * ```\n * @name .sync\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {string|Buffer|Uint8Array} `data` String or buffer to write to disk.\n * @param {object} `options` Options to pass to [fs.writeFileSync][fs]{#fs_fs_writefilesync_file_data_options} and/or [mkdirp][]\n * @return {undefined}\n * @api public\n */\n\nwriteFile.sync = function(filepath, data, options) {\n  if (typeof filepath !== 'string') {\n    throw new TypeError('expected filepath to be a string');\n  }\n  mkdirp.sync(path.dirname(filepath), options);\n  fs.writeFileSync(filepath, data, options);\n};\n\n/**\n * Uses `fs.createWriteStream` to write data to a file, replacing the\n * file if it already exists and creating any intermediate directories\n * if they don't already exist. Data can be a string or a buffer. Returns\n * a new [WriteStream](https://nodejs.org/api/fs.html#fs_class_fs_writestream)\n * object.\n *\n * ```js\n * var fs = require('fs');\n * var writeFile = require('write');\n * fs.createReadStream('README.md')\n *   .pipe(writeFile.stream('a/b/c/other-file.md'))\n *   .on('close', function() {\n *     // do stuff\n *   });\n * ```\n * @name .stream\n * @param {string|Buffer|integer} `filepath` filepath or file descriptor.\n * @param {object} `options` Options to pass to [mkdirp][] and [fs.createWriteStream][fs]{#fs_fs_createwritestream_path_options}\n * @return {Stream} Returns a new [WriteStream](https://nodejs.org/api/fs.html#fs_class_fs_writestream) object. (See [Writable Stream](https://nodejs.org/api/stream.html#stream_class_stream_writable)).\n * @api public\n */\n\nwriteFile.stream = function(filepath, options) {\n  mkdirp.sync(path.dirname(filepath), options);\n  return fs.createWriteStream(filepath, options);\n};\n\n/**\n * Expose `writeFile`\n */\n\nmodule.exports = writeFile;\n"]},"metadata":{},"sourceType":"script"}