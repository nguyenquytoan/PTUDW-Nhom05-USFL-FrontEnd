{"ast":null,"code":"/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-underscore-dangle: 0 */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n// none!\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n// Esprima Token Types\n\nconst Token = {\n  Boolean: \"Boolean\",\n  EOF: \"<end>\",\n  Identifier: \"Identifier\",\n  Keyword: \"Keyword\",\n  Null: \"Null\",\n  Numeric: \"Numeric\",\n  Punctuator: \"Punctuator\",\n  String: \"String\",\n  RegularExpression: \"RegularExpression\",\n  Template: \"Template\",\n  JSXIdentifier: \"JSXIdentifier\",\n  JSXText: \"JSXText\"\n};\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\n\nfunction convertTemplatePart(tokens, code) {\n  const firstToken = tokens[0],\n        lastTemplateToken = tokens[tokens.length - 1];\n  const token = {\n    type: Token.Template,\n    value: code.slice(firstToken.start, lastTemplateToken.end)\n  };\n\n  if (firstToken.loc) {\n    token.loc = {\n      start: firstToken.loc.start,\n      end: lastTemplateToken.loc.end\n    };\n  }\n\n  if (firstToken.range) {\n    token.start = firstToken.range[0];\n    token.end = lastTemplateToken.range[1];\n    token.range = [token.start, token.end];\n  }\n\n  return token;\n}\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\n\n\nfunction TokenTranslator(acornTokTypes, code) {\n  // token types\n  this._acornTokTypes = acornTokTypes; // token buffer for templates\n\n  this._tokens = []; // track the last curly brace\n\n  this._curlyBrace = null; // the source code\n\n  this._code = code;\n}\n\nTokenTranslator.prototype = {\n  constructor: TokenTranslator,\n\n  /**\n   * Translates a single Esprima token to a single Acorn token. This may be\n   * inaccurate due to how templates are handled differently in Esprima and\n   * Acorn, but should be accurate for all other tokens.\n   * @param {AcornToken} token The Acorn token to translate.\n   * @param {Object} extra Espree extra object.\n   * @returns {EsprimaToken} The Esprima version of the token.\n   */\n  translate(token, extra) {\n    const type = token.type,\n          tt = this._acornTokTypes;\n\n    if (type === tt.name) {\n      token.type = Token.Identifier; // TODO: See if this is an Acorn bug\n\n      if (token.value === \"static\") {\n        token.type = Token.Keyword;\n      }\n\n      if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n        token.type = Token.Keyword;\n      }\n    } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type.binop && !type.keyword || type.isAssign) {\n      token.type = Token.Punctuator;\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.jsxName) {\n      token.type = Token.JSXIdentifier;\n    } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n      token.type = Token.JSXText;\n    } else if (type.keyword) {\n      if (type.keyword === \"true\" || type.keyword === \"false\") {\n        token.type = Token.Boolean;\n      } else if (type.keyword === \"null\") {\n        token.type = Token.Null;\n      } else {\n        token.type = Token.Keyword;\n      }\n    } else if (type === tt.num) {\n      token.type = Token.Numeric;\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.string) {\n      if (extra.jsxAttrValueToken) {\n        extra.jsxAttrValueToken = false;\n        token.type = Token.JSXText;\n      } else {\n        token.type = Token.String;\n      }\n\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.regexp) {\n      token.type = Token.RegularExpression;\n      const value = token.value;\n      token.regex = {\n        flags: value.flags,\n        pattern: value.pattern\n      };\n      token.value = `/${value.pattern}/${value.flags}`;\n    }\n\n    return token;\n  },\n\n  /**\n   * Function to call during Acorn's onToken handler.\n   * @param {AcornToken} token The Acorn token.\n   * @param {Object} extra The Espree extra object.\n   * @returns {void}\n   */\n  onToken(token, extra) {\n    const that = this,\n          tt = this._acornTokTypes,\n          tokens = extra.tokens,\n          templateTokens = this._tokens;\n    /**\n     * Flushes the buffered template tokens and resets the template\n     * tracking.\n     * @returns {void}\n     * @private\n     */\n\n    function translateTemplateTokens() {\n      tokens.push(convertTemplatePart(that._tokens, that._code));\n      that._tokens = [];\n    }\n\n    if (token.type === tt.eof) {\n      // might be one last curlyBrace\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n      }\n\n      return;\n    }\n\n    if (token.type === tt.backQuote) {\n      // if there's already a curly, it's not part of the template\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n        this._curlyBrace = null;\n      }\n\n      templateTokens.push(token); // it's the end\n\n      if (templateTokens.length > 1) {\n        translateTemplateTokens();\n      }\n\n      return;\n    }\n\n    if (token.type === tt.dollarBraceL) {\n      templateTokens.push(token);\n      translateTemplateTokens();\n      return;\n    }\n\n    if (token.type === tt.braceR) {\n      // if there's already a curly, it's not part of the template\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n      } // store new curly for later\n\n\n      this._curlyBrace = token;\n      return;\n    }\n\n    if (token.type === tt.template || token.type === tt.invalidTemplate) {\n      if (this._curlyBrace) {\n        templateTokens.push(this._curlyBrace);\n        this._curlyBrace = null;\n      }\n\n      templateTokens.push(token);\n      return;\n    }\n\n    if (this._curlyBrace) {\n      tokens.push(this.translate(this._curlyBrace, extra));\n      this._curlyBrace = null;\n    }\n\n    tokens.push(this.translate(token, extra));\n  }\n\n}; //------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = TokenTranslator;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/espree/lib/token-translator.js"],"names":["Token","Boolean","EOF","Identifier","Keyword","Null","Numeric","Punctuator","String","RegularExpression","Template","JSXIdentifier","JSXText","convertTemplatePart","tokens","code","firstToken","lastTemplateToken","length","token","type","value","slice","start","end","loc","range","TokenTranslator","acornTokTypes","_acornTokTypes","_tokens","_curlyBrace","_code","prototype","constructor","translate","extra","tt","name","ecmaVersion","semi","comma","parenL","parenR","braceL","braceR","dot","bracketL","colon","question","bracketR","ellipsis","arrow","jsxTagStart","incDec","starstar","jsxTagEnd","prefix","binop","keyword","isAssign","jsxName","label","jsxAttrValueToken","num","string","regexp","regex","flags","pattern","onToken","that","templateTokens","translateTemplateTokens","push","eof","backQuote","dollarBraceL","template","invalidTemplate","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n/* eslint no-underscore-dangle: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n\n// Esprima Token Types\nconst Token = {\n    Boolean: \"Boolean\",\n    EOF: \"<end>\",\n    Identifier: \"Identifier\",\n    Keyword: \"Keyword\",\n    Null: \"Null\",\n    Numeric: \"Numeric\",\n    Punctuator: \"Punctuator\",\n    String: \"String\",\n    RegularExpression: \"RegularExpression\",\n    Template: \"Template\",\n    JSXIdentifier: \"JSXIdentifier\",\n    JSXText: \"JSXText\"\n};\n\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\nfunction convertTemplatePart(tokens, code) {\n    const firstToken = tokens[0],\n        lastTemplateToken = tokens[tokens.length - 1];\n\n    const token = {\n        type: Token.Template,\n        value: code.slice(firstToken.start, lastTemplateToken.end)\n    };\n\n    if (firstToken.loc) {\n        token.loc = {\n            start: firstToken.loc.start,\n            end: lastTemplateToken.loc.end\n        };\n    }\n\n    if (firstToken.range) {\n        token.start = firstToken.range[0];\n        token.end = lastTemplateToken.range[1];\n        token.range = [token.start, token.end];\n    }\n\n    return token;\n}\n\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\nfunction TokenTranslator(acornTokTypes, code) {\n\n    // token types\n    this._acornTokTypes = acornTokTypes;\n\n    // token buffer for templates\n    this._tokens = [];\n\n    // track the last curly brace\n    this._curlyBrace = null;\n\n    // the source code\n    this._code = code;\n\n}\n\nTokenTranslator.prototype = {\n    constructor: TokenTranslator,\n\n    /**\n     * Translates a single Esprima token to a single Acorn token. This may be\n     * inaccurate due to how templates are handled differently in Esprima and\n     * Acorn, but should be accurate for all other tokens.\n     * @param {AcornToken} token The Acorn token to translate.\n     * @param {Object} extra Espree extra object.\n     * @returns {EsprimaToken} The Esprima version of the token.\n     */\n    translate(token, extra) {\n\n        const type = token.type,\n            tt = this._acornTokTypes;\n\n        if (type === tt.name) {\n            token.type = Token.Identifier;\n\n            // TODO: See if this is an Acorn bug\n            if (token.value === \"static\") {\n                token.type = Token.Keyword;\n            }\n\n            if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                token.type = Token.Keyword;\n            }\n\n        } else if (type === tt.semi || type === tt.comma ||\n                 type === tt.parenL || type === tt.parenR ||\n                 type === tt.braceL || type === tt.braceR ||\n                 type === tt.dot || type === tt.bracketL ||\n                 type === tt.colon || type === tt.question ||\n                 type === tt.bracketR || type === tt.ellipsis ||\n                 type === tt.arrow || type === tt.jsxTagStart ||\n                 type === tt.incDec || type === tt.starstar ||\n                 type === tt.jsxTagEnd || type === tt.prefix ||\n                 (type.binop && !type.keyword) ||\n                 type.isAssign) {\n\n            token.type = Token.Punctuator;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.jsxName) {\n            token.type = Token.JSXIdentifier;\n        } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n            token.type = Token.JSXText;\n        } else if (type.keyword) {\n            if (type.keyword === \"true\" || type.keyword === \"false\") {\n                token.type = Token.Boolean;\n            } else if (type.keyword === \"null\") {\n                token.type = Token.Null;\n            } else {\n                token.type = Token.Keyword;\n            }\n        } else if (type === tt.num) {\n            token.type = Token.Numeric;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.string) {\n\n            if (extra.jsxAttrValueToken) {\n                extra.jsxAttrValueToken = false;\n                token.type = Token.JSXText;\n            } else {\n                token.type = Token.String;\n            }\n\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.regexp) {\n            token.type = Token.RegularExpression;\n            const value = token.value;\n\n            token.regex = {\n                flags: value.flags,\n                pattern: value.pattern\n            };\n            token.value = `/${value.pattern}/${value.flags}`;\n        }\n\n        return token;\n    },\n\n    /**\n     * Function to call during Acorn's onToken handler.\n     * @param {AcornToken} token The Acorn token.\n     * @param {Object} extra The Espree extra object.\n     * @returns {void}\n     */\n    onToken(token, extra) {\n\n        const that = this,\n            tt = this._acornTokTypes,\n            tokens = extra.tokens,\n            templateTokens = this._tokens;\n\n        /**\n         * Flushes the buffered template tokens and resets the template\n         * tracking.\n         * @returns {void}\n         * @private\n         */\n        function translateTemplateTokens() {\n            tokens.push(convertTemplatePart(that._tokens, that._code));\n            that._tokens = [];\n        }\n\n        if (token.type === tt.eof) {\n\n            // might be one last curlyBrace\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            return;\n        }\n\n        if (token.type === tt.backQuote) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n\n            // it's the end\n            if (templateTokens.length > 1) {\n                translateTemplateTokens();\n            }\n\n            return;\n        }\n        if (token.type === tt.dollarBraceL) {\n            templateTokens.push(token);\n            translateTemplateTokens();\n            return;\n        }\n        if (token.type === tt.braceR) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            // store new curly for later\n            this._curlyBrace = token;\n            return;\n        }\n        if (token.type === tt.template || token.type === tt.invalidTemplate) {\n            if (this._curlyBrace) {\n                templateTokens.push(this._curlyBrace);\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n            return;\n        }\n\n        if (this._curlyBrace) {\n            tokens.push(this.translate(this._curlyBrace, extra));\n            this._curlyBrace = null;\n        }\n\n        tokens.push(this.translate(token, extra));\n    }\n};\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nmodule.exports = TokenTranslator;\n"]},"metadata":{},"sourceType":"script"}