{"ast":null,"code":"/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst {\n  isCommentToken,\n  isNotOpeningParenToken\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the location of arrow function bodies\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"beside\", \"below\"]\n    }],\n    messages: {\n      expected: \"Expected a linebreak before this expression.\",\n      unexpected: \"Expected no linebreak before this expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"beside\";\n    /**\n     * Validates the location of an arrow function body\n     * @param {ASTNode} node The arrow function body\n     * @returns {void}\n     */\n\n    function validateExpression(node) {\n      if (node.body.type === \"BlockStatement\") {\n        return;\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"expected\",\n          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n        });\n      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {\n              includeComments: true,\n              filter: isCommentToken\n            })) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n          }\n\n        });\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrowFunctionExpression: node => validateExpression(node)\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/implicit-arrow-linebreak.js"],"names":["isCommentToken","isNotOpeningParenToken","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","messages","expected","unexpected","create","context","sourceCode","getSourceCode","option","options","validateExpression","node","body","arrowToken","getTokenBefore","firstTokenOfBody","getTokenAfter","loc","end","line","start","report","messageId","fix","fixer","insertTextBefore","getFirstTokenBetween","includeComments","filter","replaceTextRange","range","ArrowFunctionExpression"],"mappings":"AAAA;;;;AAIA;;AAEA,MAAM;AAAEA,EAAAA,cAAF;AAAkBC,EAAAA;AAAlB,IAA6CC,OAAO,CAAC,mBAAD,CAA1D,C,CAEA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,+CADX;AAEFC,MAAAA,QAAQ,EAAE,kBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,OAAO,EAAE,YAVP;AAYFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;AADV,KADI,CAZN;AAiBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,EAAE,8CADJ;AAENC,MAAAA,UAAU,EAAE;AAFN;AAjBR,GADO;;AAwBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AACA,UAAMC,MAAM,GAAGH,OAAO,CAACI,OAAR,CAAgB,CAAhB,KAAsB,QAArC;AAEA;;;;;;AAKA,aAASC,kBAAT,CAA4BC,IAA5B,EAAkC;AAC9B,UAAIA,IAAI,CAACC,IAAL,CAAUpB,IAAV,KAAmB,gBAAvB,EAAyC;AACrC;AACH;;AAED,YAAMqB,UAAU,GAAGP,UAAU,CAACQ,cAAX,CAA0BH,IAAI,CAACC,IAA/B,EAAqCzB,sBAArC,CAAnB;AACA,YAAM4B,gBAAgB,GAAGT,UAAU,CAACU,aAAX,CAAyBH,UAAzB,CAAzB;;AAEA,UAAIA,UAAU,CAACI,GAAX,CAAeC,GAAf,CAAmBC,IAAnB,KAA4BJ,gBAAgB,CAACE,GAAjB,CAAqBG,KAArB,CAA2BD,IAAvD,IAA+DX,MAAM,KAAK,OAA9E,EAAuF;AACnFH,QAAAA,OAAO,CAACgB,MAAR,CAAe;AACXV,UAAAA,IAAI,EAAEI,gBADK;AAEXO,UAAAA,SAAS,EAAE,UAFA;AAGXC,UAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,gBAAN,CAAuBV,gBAAvB,EAAyC,IAAzC;AAHH,SAAf;AAKH,OAND,MAMO,IAAIF,UAAU,CAACI,GAAX,CAAeC,GAAf,CAAmBC,IAAnB,KAA4BJ,gBAAgB,CAACE,GAAjB,CAAqBG,KAArB,CAA2BD,IAAvD,IAA+DX,MAAM,KAAK,QAA9E,EAAwF;AAC3FH,QAAAA,OAAO,CAACgB,MAAR,CAAe;AACXV,UAAAA,IAAI,EAAEI,gBADK;AAEXO,UAAAA,SAAS,EAAE,YAFA;;AAGXC,UAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,gBAAIlB,UAAU,CAACoB,oBAAX,CAAgCb,UAAhC,EAA4CE,gBAA5C,EAA8D;AAAEY,cAAAA,eAAe,EAAE,IAAnB;AAAyBC,cAAAA,MAAM,EAAE1C;AAAjC,aAA9D,CAAJ,EAAsH;AAClH,qBAAO,IAAP;AACH;;AAED,mBAAOsC,KAAK,CAACK,gBAAN,CAAuB,CAAChB,UAAU,CAACiB,KAAX,CAAiB,CAAjB,CAAD,EAAsBf,gBAAgB,CAACe,KAAjB,CAAuB,CAAvB,CAAtB,CAAvB,EAAyE,GAAzE,CAAP;AACH;;AATU,SAAf;AAWH;AACJ,KApCW,CAsCZ;AACA;AACA;;;AACA,WAAO;AACHC,MAAAA,uBAAuB,EAAEpB,IAAI,IAAID,kBAAkB,CAACC,IAAD;AADhD,KAAP;AAGH;;AApEY,CAAjB","sourcesContent":["/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst { isCommentToken, isNotOpeningParenToken } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of arrow function bodies\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"beside\", \"below\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected a linebreak before this expression.\",\n            unexpected: \"Expected no linebreak before this expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"beside\";\n\n        /**\n         * Validates the location of an arrow function body\n         * @param {ASTNode} node The arrow function body\n         * @returns {void}\n         */\n        function validateExpression(node) {\n            if (node.body.type === \"BlockStatement\") {\n                return;\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n            const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n            if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"expected\",\n                    fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n                });\n            } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ArrowFunctionExpression: node => validateExpression(node)\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}