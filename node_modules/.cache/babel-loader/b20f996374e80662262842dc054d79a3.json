{"ast":null,"code":"'use strict';\n\nconst postcss = require('postcss');\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst valueParser = require('postcss-value-parser');\n\nconst {\n  extractICSS\n} = require('icss-utils');\n\nconst isSpacing = node => node.type === 'combinator' && node.value === ' ';\n\nfunction getImportLocalAliases(icssImports) {\n  const localAliases = new Map();\n  Object.keys(icssImports).forEach(key => {\n    Object.keys(icssImports[key]).forEach(prop => {\n      localAliases.set(prop, icssImports[key][prop]);\n    });\n  });\n  return localAliases;\n}\n\nfunction maybeLocalizeValue(value, localAliasMap) {\n  if (localAliasMap.has(value)) return value;\n}\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n  nodes.forEach(function (x) {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(function (item) {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const isScopePseudo = node => node.value === ':local' || node.value === ':global';\n\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error('Missing whitespace after ' + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error('Missing whitespace before ' + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case 'root':\n        {\n          let resultingGlobal;\n          context.hasPureGlobals = false;\n          newNodes = node.nodes.map(function (n) {\n            const nContext = {\n              global: context.global,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: false\n            };\n            n = transform(n, nContext);\n\n            if (typeof resultingGlobal === 'undefined') {\n              resultingGlobal = nContext.global;\n            } else if (resultingGlobal !== nContext.global) {\n              throw new Error('Inconsistent rule global/local result in rule \"' + node + '\" (multiple selectors must result in the same mode for the rule)');\n            }\n\n            if (!nContext.hasLocals) {\n              context.hasPureGlobals = true;\n            }\n\n            return n;\n          });\n          context.global = resultingGlobal;\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n\n      case 'selector':\n        {\n          newNodes = node.map(childNode => transform(childNode, context));\n          node = node.clone();\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n\n      case 'combinator':\n        {\n          if (isSpacing(node)) {\n            if (context.ignoreNextSpacing) {\n              context.ignoreNextSpacing = false;\n              context.lastWasSpacing = false;\n              context.enforceNoSpacing = false;\n              return null;\n            }\n\n            context.lastWasSpacing = true;\n            return node;\n          }\n\n          break;\n        }\n\n      case 'pseudo':\n        {\n          let childContext;\n          const isNested = !!node.length;\n          const isScoped = isScopePseudo(node); // :local(.foo)\n\n          if (isNested) {\n            if (isScoped) {\n              if (node.nodes.length === 0) {\n                throw new Error(`${node.value}() can't be empty`);\n              }\n\n              if (context.inside) {\n                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n              }\n\n              childContext = {\n                global: node.value === ':global',\n                inside: node.value,\n                hasLocals: false,\n                explicit: true\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);\n\n              if (newNodes.length) {\n                const {\n                  before,\n                  after\n                } = node.spaces;\n                const first = newNodes[0];\n                const last = newNodes[newNodes.length - 1];\n                first.spaces = {\n                  before,\n                  after: first.spaces.after\n                };\n                last.spaces = {\n                  before: last.spaces.before,\n                  after\n                };\n              }\n\n              node = newNodes;\n              break;\n            } else {\n              childContext = {\n                global: context.global,\n                inside: context.inside,\n                lastWasSpacing: true,\n                hasLocals: false,\n                explicit: context.explicit\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext));\n              node = node.clone();\n              node.nodes = normalizeNodeArray(newNodes);\n\n              if (childContext.hasLocals) {\n                context.hasLocals = true;\n              }\n            }\n\n            break; //:local .foo .bar\n          } else if (isScoped) {\n            if (context.inside) {\n              throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n            }\n\n            const addBackSpacing = !!node.spaces.before;\n            context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;\n            context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;\n            context.global = node.value === ':global';\n            context.explicit = true; // because this node has spacing that is lost when we remove it\n            // we make up for it by adding an extra combinator in since adding\n            // spacing on the parent selector doesn't work\n\n            return addBackSpacing ? selectorParser.combinator({\n              value: ' '\n            }) : null;\n          }\n\n          break;\n        }\n\n      case 'id':\n      case 'class':\n        {\n          if (!node.value) {\n            throw new Error('Invalid class or id selector syntax');\n          }\n\n          if (context.global) {\n            break;\n          }\n\n          const isImportedValue = localAliasMap.has(node.value);\n          const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n          if (!isImportedValue || isImportedWithExplicitScope) {\n            const innerNode = node.clone();\n            innerNode.spaces = {\n              before: '',\n              after: ''\n            };\n            node = selectorParser.pseudo({\n              value: ':local',\n              nodes: [innerNode],\n              spaces: node.spaces\n            });\n            context.hasLocals = true;\n          }\n\n          break;\n        }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === 'global',\n    hasPureGlobals: false\n  };\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, {\n    updateSelector: false,\n    lossless: true\n  });\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case 'word':\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = ':local(' + node.value + ')';\n          context.localizeNextItem = false;\n        }\n      }\n\n      break;\n\n    case 'function':\n      if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === 'url') {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== 'string' && nestedNode.type !== 'word') {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);\n\n          switch (nestedNode.type) {\n            case 'string':\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n\n            case 'word':\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, '\\\\$1');\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n\n      break;\n  }\n\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode ? functionNode.nodes.some(functionNodeChild => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;\n}\n\nfunction localizeAnimationShorthandDeclValues(decl, context) {\n  const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n  /*\n  The spec defines some keywords that you can use to describe properties such as the timing\n  function. These are still valid animation names, so as long as there is a property that accepts\n  a keyword, it is given priority. Only when all the properties that can take a keyword are\n  exhausted can the animation name be set to the keyword. I.e.\n   animation: infinite infinite;\n   The animation will repeat an infinite number of times from the first argument, and will have an\n  animation name of infinite from the second.\n  */\n\n  const animationKeywords = {\n    $alternate: 1,\n    '$alternate-reverse': 1,\n    $backwards: 1,\n    $both: 1,\n    $ease: 1,\n    '$ease-in': 1,\n    '$ease-in-out': 1,\n    '$ease-out': 1,\n    $forwards: 1,\n    $infinite: 1,\n    $linear: 1,\n    $none: Infinity,\n    // No matter how many times you write none, it will never be an animation name\n    $normal: 1,\n    $paused: 1,\n    $reverse: 1,\n    $running: 1,\n    '$step-end': 1,\n    '$step-start': 1,\n    $initial: Infinity,\n    $inherit: Infinity,\n    $unset: Infinity\n  };\n  const didParseAnimationName = false;\n  let parsedAnimationKeywords = {};\n  let stepsFunctionNode = null;\n  const valueNodes = valueParser(decl.value).walk(node => {\n    /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n    if (node.type === 'div') {\n      parsedAnimationKeywords = {};\n    }\n\n    if (node.type === 'function' && node.value.toLowerCase() === 'steps') {\n      stepsFunctionNode = node;\n    }\n\n    const value = node.type === 'word' && !isWordAFunctionArgument(node, stepsFunctionNode) ? node.value.toLowerCase() : null;\n    let shouldParseAnimationName = false;\n\n    if (!didParseAnimationName && value && validIdent.test(value)) {\n      if ('$' + value in animationKeywords) {\n        parsedAnimationKeywords['$' + value] = '$' + value in parsedAnimationKeywords ? parsedAnimationKeywords['$' + value] + 1 : 0;\n        shouldParseAnimationName = parsedAnimationKeywords['$' + value] >= animationKeywords['$' + value];\n      } else {\n        shouldParseAnimationName = true;\n      }\n    }\n\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: shouldParseAnimationName && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    return localizeDeclNode(node, subContext);\n  });\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDeclValues(localize, decl, context) {\n  const valueNodes = valueParser(decl.value);\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDecl(decl, context) {\n  const isAnimation = /animation$/i.test(decl.prop);\n\n  if (isAnimation) {\n    return localizeAnimationShorthandDeclValues(decl, context);\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(decl.prop);\n\n  if (isAnimationName) {\n    return localizeDeclValues(true, decl, context);\n  }\n\n  const hasUrl = /url\\(/i.test(decl.value);\n\n  if (hasUrl) {\n    return localizeDeclValues(false, decl, context);\n  }\n}\n\nmodule.exports = postcss.plugin('postcss-modules-local-by-default', function (options) {\n  if (typeof options !== 'object') {\n    options = {}; // If options is undefined or not an object the plugin fails\n  }\n\n  if (options && options.mode) {\n    if (options.mode !== 'global' && options.mode !== 'local' && options.mode !== 'pure') {\n      throw new Error('options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")');\n    }\n  }\n\n  const pureMode = options && options.mode === 'pure';\n  const globalMode = options && options.mode === 'global';\n  return function (css) {\n    const {\n      icssImports\n    } = extractICSS(css, false);\n    const localAliasMap = getImportLocalAliases(icssImports);\n    css.walkAtRules(function (atrule) {\n      if (/keyframes$/i.test(atrule.name)) {\n        const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        let globalKeyframes = globalMode;\n\n        if (globalMatch) {\n          if (pureMode) {\n            throw atrule.error('@keyframes :global(...) is not allowed in pure mode');\n          }\n\n          atrule.params = globalMatch[1];\n          globalKeyframes = true;\n        } else if (localMatch) {\n          atrule.params = localMatch[0];\n          globalKeyframes = false;\n        } else if (!globalMode) {\n          if (atrule.params && !localAliasMap.has(atrule.params)) atrule.params = ':local(' + atrule.params + ')';\n        }\n\n        atrule.walkDecls(function (decl) {\n          localizeDecl(decl, {\n            localAliasMap,\n            options: options,\n            global: globalKeyframes\n          });\n        });\n      } else if (atrule.nodes) {\n        atrule.nodes.forEach(function (decl) {\n          if (decl.type === 'decl') {\n            localizeDecl(decl, {\n              localAliasMap,\n              options: options,\n              global: globalMode\n            });\n          }\n        });\n      }\n    });\n    css.walkRules(function (rule) {\n      if (rule.parent && rule.parent.type === 'atrule' && /keyframes$/i.test(rule.parent.name)) {\n        // ignore keyframe rules\n        return;\n      }\n\n      if (rule.nodes && rule.selector.slice(0, 2) === '--' && rule.selector.slice(-1) === ':') {\n        // ignore custom property set\n        return;\n      }\n\n      const context = localizeNode(rule, options.mode, localAliasMap);\n      context.options = options;\n      context.localAliasMap = localAliasMap;\n\n      if (pureMode && context.hasPureGlobals) {\n        throw rule.error('Selector \"' + rule.selector + '\" is not pure ' + '(pure selectors must contain at least one local class or id)');\n      }\n\n      rule.selector = context.selector; // Less-syntax mixins parse as rules with no nodes\n\n      if (rule.nodes) {\n        rule.nodes.forEach(decl => localizeDecl(decl, context));\n      }\n    });\n  };\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-modules-local-by-default/index.js"],"names":["postcss","require","selectorParser","valueParser","extractICSS","isSpacing","node","type","value","getImportLocalAliases","icssImports","localAliases","Map","Object","keys","forEach","key","prop","set","maybeLocalizeValue","localAliasMap","has","normalizeNodeArray","nodes","array","x","Array","isArray","item","push","length","pop","localizeNode","rule","mode","isScopePseudo","transform","context","ignoreNextSpacing","Error","enforceNoSpacing","newNodes","resultingGlobal","hasPureGlobals","map","n","nContext","global","lastWasSpacing","hasLocals","explicit","childNode","clone","childContext","isNested","isScoped","inside","reduce","acc","next","concat","before","after","spaces","first","last","addBackSpacing","combinator","isImportedValue","isImportedWithExplicitScope","innerNode","pseudo","rootContext","selector","root","processSync","updateSelector","lossless","localizeDeclNode","localizeNextItem","options","rewriteUrl","toLowerCase","nestedNode","newUrl","quote","replace","isWordAFunctionArgument","wordNode","functionNode","some","functionNodeChild","sourceIndex","localizeAnimationShorthandDeclValues","decl","validIdent","animationKeywords","$alternate","$backwards","$both","$ease","$forwards","$infinite","$linear","$none","Infinity","$normal","$paused","$reverse","$running","$initial","$inherit","$unset","didParseAnimationName","parsedAnimationKeywords","stepsFunctionNode","valueNodes","walk","shouldParseAnimationName","test","subContext","toString","localizeDeclValues","localize","index","localizeDecl","isAnimation","isAnimationName","hasUrl","module","exports","plugin","pureMode","globalMode","css","walkAtRules","atrule","name","globalMatch","exec","params","localMatch","globalKeyframes","error","walkDecls","walkRules","parent","slice"],"mappings":"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","sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst selectorParser = require('postcss-selector-parser');\nconst valueParser = require('postcss-value-parser');\nconst { extractICSS } = require('icss-utils');\n\nconst isSpacing = node => node.type === 'combinator' && node.value === ' ';\n\nfunction getImportLocalAliases(icssImports) {\n  const localAliases = new Map();\n  Object.keys(icssImports).forEach(key => {\n    Object.keys(icssImports[key]).forEach(prop => {\n      localAliases.set(prop, icssImports[key][prop]);\n    });\n  });\n  return localAliases;\n}\n\nfunction maybeLocalizeValue(value, localAliasMap) {\n  if (localAliasMap.has(value)) return value;\n}\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach(function(x) {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(function(item) {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const isScopePseudo = node =>\n    node.value === ':local' || node.value === ':global';\n\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error('Missing whitespace after ' + context.ignoreNextSpacing);\n    }\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error('Missing whitespace before ' + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n    switch (node.type) {\n      case 'root': {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map(function(n) {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === 'undefined') {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case 'selector': {\n        newNodes = node.map(childNode => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case 'combinator': {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case 'pseudo': {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = isScopePseudo(node);\n\n        // :local(.foo)\n        if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${\n                  context.inside\n                }(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === ':global',\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map(childNode => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map(childNode =>\n              transform(childNode, childContext)\n            );\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${\n                context.inside\n              }(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === ':global';\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser.combinator({ value: ' ' })\n            : null;\n        }\n        break;\n      }\n      case 'id':\n      case 'class': {\n        if (!node.value) {\n          throw new Error('Invalid class or id selector syntax');\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: '', after: '' };\n\n          node = selectorParser.pseudo({\n            value: ':local',\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === 'global',\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case 'word':\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = ':local(' + node.value + ')';\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case 'function':\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === 'url'\n      ) {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== 'string' && nestedNode.type !== 'word') {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case 'string':\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, '\\\\$1').replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case 'word':\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, '\\\\$1');\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode\n    ? functionNode.nodes.some(\n        functionNodeChild =>\n          functionNodeChild.sourceIndex === wordNode.sourceIndex\n      )\n    : false;\n}\n\nfunction localizeAnimationShorthandDeclValues(decl, context) {\n  const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n\n  /*\n  The spec defines some keywords that you can use to describe properties such as the timing\n  function. These are still valid animation names, so as long as there is a property that accepts\n  a keyword, it is given priority. Only when all the properties that can take a keyword are\n  exhausted can the animation name be set to the keyword. I.e.\n\n  animation: infinite infinite;\n\n  The animation will repeat an infinite number of times from the first argument, and will have an\n  animation name of infinite from the second.\n  */\n  const animationKeywords = {\n    $alternate: 1,\n    '$alternate-reverse': 1,\n    $backwards: 1,\n    $both: 1,\n    $ease: 1,\n    '$ease-in': 1,\n    '$ease-in-out': 1,\n    '$ease-out': 1,\n    $forwards: 1,\n    $infinite: 1,\n    $linear: 1,\n    $none: Infinity, // No matter how many times you write none, it will never be an animation name\n    $normal: 1,\n    $paused: 1,\n    $reverse: 1,\n    $running: 1,\n    '$step-end': 1,\n    '$step-start': 1,\n    $initial: Infinity,\n    $inherit: Infinity,\n    $unset: Infinity,\n  };\n\n  const didParseAnimationName = false;\n  let parsedAnimationKeywords = {};\n  let stepsFunctionNode = null;\n  const valueNodes = valueParser(decl.value).walk(node => {\n    /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n    if (node.type === 'div') {\n      parsedAnimationKeywords = {};\n    }\n    if (node.type === 'function' && node.value.toLowerCase() === 'steps') {\n      stepsFunctionNode = node;\n    }\n    const value =\n      node.type === 'word' && !isWordAFunctionArgument(node, stepsFunctionNode)\n        ? node.value.toLowerCase()\n        : null;\n\n    let shouldParseAnimationName = false;\n\n    if (!didParseAnimationName && value && validIdent.test(value)) {\n      if ('$' + value in animationKeywords) {\n        parsedAnimationKeywords['$' + value] =\n          '$' + value in parsedAnimationKeywords\n            ? parsedAnimationKeywords['$' + value] + 1\n            : 0;\n\n        shouldParseAnimationName =\n          parsedAnimationKeywords['$' + value] >=\n          animationKeywords['$' + value];\n      } else {\n        shouldParseAnimationName = true;\n      }\n    }\n\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: shouldParseAnimationName && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    return localizeDeclNode(node, subContext);\n  });\n\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDeclValues(localize, decl, context) {\n  const valueNodes = valueParser(decl.value);\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  decl.value = valueNodes.toString();\n}\n\nfunction localizeDecl(decl, context) {\n  const isAnimation = /animation$/i.test(decl.prop);\n\n  if (isAnimation) {\n    return localizeAnimationShorthandDeclValues(decl, context);\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(decl.prop);\n\n  if (isAnimationName) {\n    return localizeDeclValues(true, decl, context);\n  }\n\n  const hasUrl = /url\\(/i.test(decl.value);\n\n  if (hasUrl) {\n    return localizeDeclValues(false, decl, context);\n  }\n}\n\nmodule.exports = postcss.plugin('postcss-modules-local-by-default', function(\n  options\n) {\n  if (typeof options !== 'object') {\n    options = {}; // If options is undefined or not an object the plugin fails\n  }\n\n  if (options && options.mode) {\n    if (\n      options.mode !== 'global' &&\n      options.mode !== 'local' &&\n      options.mode !== 'pure'\n    ) {\n      throw new Error(\n        'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n      );\n    }\n  }\n\n  const pureMode = options && options.mode === 'pure';\n  const globalMode = options && options.mode === 'global';\n\n  return function(css) {\n    const { icssImports } = extractICSS(css, false);\n    const localAliasMap = getImportLocalAliases(icssImports);\n\n    css.walkAtRules(function(atrule) {\n      if (/keyframes$/i.test(atrule.name)) {\n        const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        let globalKeyframes = globalMode;\n        if (globalMatch) {\n          if (pureMode) {\n            throw atrule.error(\n              '@keyframes :global(...) is not allowed in pure mode'\n            );\n          }\n          atrule.params = globalMatch[1];\n          globalKeyframes = true;\n        } else if (localMatch) {\n          atrule.params = localMatch[0];\n          globalKeyframes = false;\n        } else if (!globalMode) {\n          if (atrule.params && !localAliasMap.has(atrule.params))\n            atrule.params = ':local(' + atrule.params + ')';\n        }\n        atrule.walkDecls(function(decl) {\n          localizeDecl(decl, {\n            localAliasMap,\n            options: options,\n            global: globalKeyframes,\n          });\n        });\n      } else if (atrule.nodes) {\n        atrule.nodes.forEach(function(decl) {\n          if (decl.type === 'decl') {\n            localizeDecl(decl, {\n              localAliasMap,\n              options: options,\n              global: globalMode,\n            });\n          }\n        });\n      }\n    });\n\n    css.walkRules(function(rule) {\n      if (\n        rule.parent &&\n        rule.parent.type === 'atrule' &&\n        /keyframes$/i.test(rule.parent.name)\n      ) {\n        // ignore keyframe rules\n        return;\n      }\n\n      if (\n        rule.nodes &&\n        rule.selector.slice(0, 2) === '--' &&\n        rule.selector.slice(-1) === ':'\n      ) {\n        // ignore custom property set\n        return;\n      }\n\n      const context = localizeNode(rule, options.mode, localAliasMap);\n\n      context.options = options;\n      context.localAliasMap = localAliasMap;\n\n      if (pureMode && context.hasPureGlobals) {\n        throw rule.error(\n          'Selector \"' +\n            rule.selector +\n            '\" is not pure ' +\n            '(pure selectors must contain at least one local class or id)'\n        );\n      }\n\n      rule.selector = context.selector;\n\n      // Less-syntax mixins parse as rules with no nodes\n      if (rule.nodes) {\n        rule.nodes.forEach(decl => localizeDecl(decl, context));\n      }\n    });\n  };\n});\n"]},"metadata":{},"sourceType":"script"}