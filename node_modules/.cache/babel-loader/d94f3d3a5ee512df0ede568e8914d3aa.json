{"ast":null,"code":"/*!\n * XRegExp Unicode Base 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\nexport default (XRegExp => {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  const unicode = {}; // Reuse utils\n\n  const dec = XRegExp._dec;\n  const hex = XRegExp._hex;\n  const pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    const esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    let output = '';\n    let lastEnd = -1;\n    XRegExp.forEach(range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, m => {\n      const start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += `\\\\u${pad4(hex(lastEnd + 1))}`;\n\n        if (start > lastEnd + 2) {\n          output += `-\\\\u${pad4(hex(start - 1))}`;\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += `\\\\u${pad4(hex(lastEnd + 1))}`;\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    const prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    const item = unicode[slug];\n    let combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      combined = `[${item.bmp}]${item.astral ? '|' : ''}`;\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      combined += `${item.astral ? '|' : ''}[${item.bmp}]`;\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? `(?:(?!${combined})(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))` : `(?:${combined})`;\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    const prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, (match, scope, flags) => {\n    const ERR_DOUBLE_NEG = 'Invalid double negation ';\n    const ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    const ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    const ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    const ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    let isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    const isAstralMode = flags.includes('A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    let slug = normalize(match[4] || match[3]); // Token data object\n\n    let item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        throw new ReferenceError(`${ERR_UNKNOWN_REF + match[0]} -> ${item.inverseOf}`);\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : `${(isNegated ? '[^' : '[') + item.bmp}]`;\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = data => {\n    const ERR_NO_NAME = 'Unicode token requires name';\n    const ERR_NO_DATA = 'Unicode token has no character data ';\n\n    for (const item of data) {\n      if (!item.name) {\n        throw new Error(ERR_NO_NAME);\n      }\n\n      if (!(item.inverseOf || item.bmp || item.astral)) {\n        throw new Error(ERR_NO_DATA + item.name);\n      }\n\n      unicode[normalize(item.name)] = item;\n\n      if (item.alias) {\n        unicode[normalize(item.alias)] = item;\n      }\n    } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n    // flags might now produce different results\n\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = name => {\n    const slug = normalize(name);\n    return unicode[slug];\n  };\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/src/addons/unicode-base.js"],"names":["XRegExp","unicode","dec","_dec","hex","_hex","pad4","_pad4","normalize","name","replace","toLowerCase","charCode","chr","esc","exec","charCodeAt","invertBmp","range","output","lastEnd","forEach","m","start","cacheInvertedBmp","slug","prop","bmp","buildAstral","isNegated","item","combined","isBmpLast","astral","cacheAstral","addToken","match","scope","flags","ERR_DOUBLE_NEG","ERR_UNKNOWN_NAME","ERR_UNKNOWN_REF","ERR_ASTRAL_ONLY","ERR_ASTRAL_IN_CLASS","isAstralMode","includes","SyntaxError","hasOwnProperty","inverseOf","ReferenceError","optionalFlags","leadChar","addUnicodeData","data","ERR_NO_NAME","ERR_NO_DATA","Error","alias","cache","flush","_getUnicodeProperty"],"mappings":"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","sourcesContent":["/*!\n * XRegExp Unicode Base 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\n\nexport default (XRegExp) => {\n\n    /**\n     * Adds base support for Unicode matching:\n     * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n     *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n     *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n     * - Adds flag A (astral), which enables 21-bit Unicode support.\n     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n     *\n     * Unicode Base relies on externally provided Unicode character data. Official addons are\n     * available to provide data for Unicode categories, scripts, blocks, and properties.\n     *\n     * @requires XRegExp\n     */\n\n    // ==--------------------------==\n    // Private stuff\n    // ==--------------------------==\n\n    // Storage for Unicode data\n    const unicode = {};\n\n    // Reuse utils\n    const dec = XRegExp._dec;\n    const hex = XRegExp._hex;\n    const pad4 = XRegExp._pad4;\n\n    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n    function normalize(name) {\n        return name.replace(/[- _]+/g, '').toLowerCase();\n    }\n\n    // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n    function charCode(chr) {\n        const esc = /^\\\\[xu](.+)/.exec(chr);\n        return esc ?\n            dec(esc[1]) :\n            chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n    }\n\n    // Inverts a list of ordered BMP characters and ranges\n    function invertBmp(range) {\n        let output = '';\n        let lastEnd = -1;\n\n        XRegExp.forEach(\n            range,\n            /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,\n            (m) => {\n                const start = charCode(m[1]);\n                if (start > (lastEnd + 1)) {\n                    output += `\\\\u${pad4(hex(lastEnd + 1))}`;\n                    if (start > (lastEnd + 2)) {\n                        output += `-\\\\u${pad4(hex(start - 1))}`;\n                    }\n                }\n                lastEnd = charCode(m[2] || m[1]);\n            }\n        );\n\n        if (lastEnd < 0xFFFF) {\n            output += `\\\\u${pad4(hex(lastEnd + 1))}`;\n            if (lastEnd < 0xFFFE) {\n                output += '-\\\\uFFFF';\n            }\n        }\n\n        return output;\n    }\n\n    // Generates an inverted BMP range on first use\n    function cacheInvertedBmp(slug) {\n        const prop = 'b!';\n        return (\n            unicode[slug][prop] ||\n            (unicode[slug][prop] = invertBmp(unicode[slug].bmp))\n        );\n    }\n\n    // Combines and optionally negates BMP and astral data\n    function buildAstral(slug, isNegated) {\n        const item = unicode[slug];\n        let combined = '';\n\n        if (item.bmp && !item.isBmpLast) {\n            combined = `[${item.bmp}]${item.astral ? '|' : ''}`;\n        }\n        if (item.astral) {\n            combined += item.astral;\n        }\n        if (item.isBmpLast && item.bmp) {\n            combined += `${item.astral ? '|' : ''}[${item.bmp}]`;\n        }\n\n        // Astral Unicode tokens always match a code point, never a code unit\n        return isNegated ?\n            `(?:(?!${combined})(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))` :\n            `(?:${combined})`;\n    }\n\n    // Builds a complete astral pattern on first use\n    function cacheAstral(slug, isNegated) {\n        const prop = isNegated ? 'a!' : 'a=';\n        return (\n            unicode[slug][prop] ||\n            (unicode[slug][prop] = buildAstral(slug, isNegated))\n        );\n    }\n\n    // ==--------------------------==\n    // Core functionality\n    // ==--------------------------==\n\n    /*\n     * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n     */\n    XRegExp.addToken(\n        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n        /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,\n        (match, scope, flags) => {\n            const ERR_DOUBLE_NEG = 'Invalid double negation ';\n            const ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n            const ERR_UNKNOWN_REF = 'Unicode token missing data ';\n            const ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n            const ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';\n            // Negated via \\P{..} or \\p{^..}\n            let isNegated = match[1] === 'P' || !!match[2];\n            // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n            const isAstralMode = flags.includes('A');\n            // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n            let slug = normalize(match[4] || match[3]);\n            // Token data object\n            let item = unicode[slug];\n\n            if (match[1] === 'P' && match[2]) {\n                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n            }\n            if (!unicode.hasOwnProperty(slug)) {\n                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n            }\n\n            // Switch to the negated form of the referenced Unicode token\n            if (item.inverseOf) {\n                slug = normalize(item.inverseOf);\n                if (!unicode.hasOwnProperty(slug)) {\n                    throw new ReferenceError(`${ERR_UNKNOWN_REF + match[0]} -> ${item.inverseOf}`);\n                }\n                item = unicode[slug];\n                isNegated = !isNegated;\n            }\n\n            if (!(item.bmp || isAstralMode)) {\n                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n            }\n            if (isAstralMode) {\n                if (scope === 'class') {\n                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n                }\n\n                return cacheAstral(slug, isNegated);\n            }\n\n            return scope === 'class' ?\n                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :\n                `${(isNegated ? '[^' : '[') + item.bmp}]`;\n        },\n        {\n            scope: 'all',\n            optionalFlags: 'A',\n            leadChar: '\\\\'\n        }\n    );\n\n    /**\n     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n     *\n     * @memberOf XRegExp\n     * @param {Array} data Objects with named character ranges. Each object may have properties\n     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n     *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n     *   character classes and alternation, and should use surrogate pairs to represent astral code\n     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n     *   defined as the exact inverse of another token.\n     * @example\n     *\n     * // Basic use\n     * XRegExp.addUnicodeData([{\n     *   name: 'XDigit',\n     *   alias: 'Hexadecimal',\n     *   bmp: '0-9A-Fa-f'\n     * }]);\n     * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n     */\n    XRegExp.addUnicodeData = (data) => {\n        const ERR_NO_NAME = 'Unicode token requires name';\n        const ERR_NO_DATA = 'Unicode token has no character data ';\n\n        for (const item of data) {\n            if (!item.name) {\n                throw new Error(ERR_NO_NAME);\n            }\n            if (!(item.inverseOf || item.bmp || item.astral)) {\n                throw new Error(ERR_NO_DATA + item.name);\n            }\n            unicode[normalize(item.name)] = item;\n            if (item.alias) {\n                unicode[normalize(item.alias)] = item;\n            }\n        }\n\n        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n        // flags might now produce different results\n        XRegExp.cache.flush('patterns');\n    };\n\n    /**\n     * @ignore\n     *\n     * Return a reference to the internal Unicode definition structure for the given Unicode\n     * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n     * constructs.\n     *\n     * @memberOf XRegExp\n     * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n     *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n     *   Properties and Property Aliases.\n     * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n     *\n     * @note\n     * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n     *\n     * @note\n     * This method is *not* part of the officially documented API and may change or be removed in\n     * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n     * structures set up by XRegExp.\n     */\n    XRegExp._getUnicodeProperty = (name) => {\n        const slug = normalize(name);\n        return unicode[slug];\n    };\n};\n"]},"metadata":{},"sourceType":"module"}