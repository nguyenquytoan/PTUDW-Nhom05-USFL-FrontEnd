{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\n\n\nfunction isComparisonOperator(operator) {\n  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\n\n\nfunction isEqualityOperator(operator) {\n  return /^(==|===)$/u.test(operator);\n}\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\n\n\nfunction isRangeTestOperator(operator) {\n  return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\n\n\nfunction looksLikeLiteral(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.prefix && node.argument.type === \"Literal\" && typeof node.argument.value === \"number\";\n}\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @param {number} [defaultValue] The default value to be returned if the node\n *                                is not a Literal.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. The Literal node which has the `defaultValue` argument if it exists.\n *  4. Otherwise `null`.\n */\n\n\nfunction getNormalizedLiteral(node, defaultValue) {\n  if (node.type === \"Literal\") {\n    return node;\n  }\n\n  if (looksLikeLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: -node.argument.value,\n      raw: `-${node.argument.value}`\n    };\n  }\n\n  if (defaultValue) {\n    return {\n      type: \"Literal\",\n      value: defaultValue,\n      raw: String(defaultValue)\n    };\n  }\n\n  return null;\n}\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\n\n\nfunction same(a, b) {\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  switch (a.type) {\n    case \"Identifier\":\n      return a.name === b.name;\n\n    case \"Literal\":\n      return a.value === b.value;\n\n    case \"MemberExpression\":\n      {\n        const nameA = astUtils.getStaticPropertyName(a); // x.y = x[\"y\"]\n\n        if (nameA !== null) {\n          return same(a.object, b.object) && nameA === astUtils.getStaticPropertyName(b);\n        }\n        /*\n         * x[0] = x[0]\n         * x[y] = x[y]\n         * x.y = x.y\n         */\n\n\n        return a.computed === b.computed && same(a.object, b.object) && same(a.property, b.property);\n      }\n\n    case \"ThisExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow \\\"Yoda\\\" conditions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/yoda\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptRange: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyEquality: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n    }\n  },\n\n  create(context) {\n    // Default to \"never\" (!always) if no option\n    const always = context.options[0] === \"always\";\n    const exceptRange = context.options[1] && context.options[1].exceptRange;\n    const onlyEquality = context.options[1] && context.options[1].onlyEquality;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines whether node represents a range test.\n     * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n     * both operators must be `<` or `<=`. Finally, the literal on the left side\n     * must be less than or equal to the literal on the right side so that the\n     * test makes any sense.\n     * @param {ASTNode} node LogicalExpression node to test.\n     * @returns {boolean} Whether node is a range test.\n     */\n\n    function isRangeTest(node) {\n      const left = node.left,\n            right = node.right;\n      /**\n       * Determines whether node is of the form `0 <= x && x < 1`.\n       * @returns {boolean} Whether node is a \"between\" range test.\n       */\n\n      function isBetweenTest() {\n        let leftLiteral, rightLiteral;\n        return node.operator === \"&&\" && (leftLiteral = getNormalizedLiteral(left.left)) && (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) && leftLiteral.value <= rightLiteral.value && same(left.right, right.left);\n      }\n      /**\n       * Determines whether node is of the form `x < 0 || 1 <= x`.\n       * @returns {boolean} Whether node is an \"outside\" range test.\n       */\n\n\n      function isOutsideTest() {\n        let leftLiteral, rightLiteral;\n        return node.operator === \"||\" && (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) && (rightLiteral = getNormalizedLiteral(right.left)) && leftLiteral.value <= rightLiteral.value && same(left.left, right.right);\n      }\n      /**\n       * Determines whether node is wrapped in parentheses.\n       * @returns {boolean} Whether node is preceded immediately by an open\n       *                    paren token and followed immediately by a close\n       *                    paren token.\n       */\n\n\n      function isParenWrapped() {\n        return astUtils.isParenthesised(sourceCode, node);\n      }\n\n      return node.type === \"LogicalExpression\" && left.type === \"BinaryExpression\" && right.type === \"BinaryExpression\" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();\n    }\n\n    const OPERATOR_FLIP_MAP = {\n      \"===\": \"===\",\n      \"!==\": \"!==\",\n      \"==\": \"==\",\n      \"!=\": \"!=\",\n      \"<\": \">\",\n      \">\": \"<\",\n      \"<=\": \">=\",\n      \">=\": \"<=\"\n    };\n    /**\n     * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n     * @param {ASTNode} node The BinaryExpression node\n     * @returns {string} A string representation of the node with the sides and operator flipped\n     */\n\n    function getFlippedString(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);\n      const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);\n      const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);\n      const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n      const rightText = sourceCode.getText().slice(firstRightToken.range[0], node.range[1]);\n      let prefix = \"\";\n\n      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n        prefix = \" \";\n      }\n\n      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BinaryExpression(node) {\n        const expectedLiteral = always ? node.left : node.right;\n        const expectedNonLiteral = always ? node.right : node.left; // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n\n        if ((expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              operator: node.operator,\n              expectedSide: always ? \"left\" : \"right\"\n            },\n            fix: fixer => fixer.replaceText(node, getFlippedString(node))\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/yoda.js"],"names":["astUtils","require","isComparisonOperator","operator","test","isEqualityOperator","isRangeTestOperator","indexOf","looksLikeLiteral","node","type","prefix","argument","value","getNormalizedLiteral","defaultValue","raw","String","same","a","b","name","nameA","getStaticPropertyName","object","computed","property","module","exports","meta","docs","description","category","recommended","url","schema","enum","properties","exceptRange","default","onlyEquality","additionalProperties","fixable","messages","expected","create","context","always","options","sourceCode","getSourceCode","isRangeTest","left","right","isBetweenTest","leftLiteral","rightLiteral","Number","POSITIVE_INFINITY","isOutsideTest","NEGATIVE_INFINITY","isParenWrapped","isParenthesised","OPERATOR_FLIP_MAP","getFlippedString","tokenBefore","getTokenBefore","operatorToken","getFirstTokenBetween","token","textBeforeOperator","getText","slice","range","textAfterOperator","getTokenAfter","leftText","firstRightToken","rightText","canTokensBeAdjacent","BinaryExpression","expectedLiteral","expectedNonLiteral","getAncestors","pop","report","messageId","data","expectedSide","fix","fixer","replaceText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return (/^(==|===|!=|!==|<|>|<=|>=)$/u).test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return (/^(==|===)$/u).test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction looksLikeLiteral(node) {\n    return (node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        node.argument.type === \"Literal\" &&\n        typeof node.argument.value === \"number\");\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @param {number} [defaultValue] The default value to be returned if the node\n *                                is not a Literal.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. The Literal node which has the `defaultValue` argument if it exists.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node, defaultValue) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (looksLikeLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (defaultValue) {\n        return {\n            type: \"Literal\",\n            value: defaultValue,\n            raw: String(defaultValue)\n        };\n    }\n\n    return null;\n}\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\": {\n            const nameA = astUtils.getStaticPropertyName(a);\n\n            // x.y = x[\"y\"]\n            if (nameA !== null) {\n                return (\n                    same(a.object, b.object) &&\n                    nameA === astUtils.getStaticPropertyName(b)\n                );\n            }\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return (\n                a.computed === b.computed &&\n                same(a.object, b.object) &&\n                same(a.property, b.property)\n            );\n        }\n\n        case \"ThisExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow \\\"Yoda\\\" conditions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyEquality: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = (context.options[0] === \"always\");\n        const exceptRange = (context.options[1] && context.options[1].exceptRange);\n        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"&&\" &&\n                    (leftLiteral = getNormalizedLiteral(left.left)) &&\n                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.right, right.left));\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"||\" &&\n                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&\n                    (rightLiteral = getNormalizedLiteral(right.left)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.left, right.right));\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped());\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);\n            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);\n            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n            const rightText = sourceCode.getText().slice(firstRightToken.range[0], node.range[1]);\n\n            let prefix = \"\";\n\n            if (tokenBefore && tokenBefore.range[1] === node.range[0] &&\n                    !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n                prefix = \" \";\n            }\n\n            return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) &&\n                    !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer => fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}