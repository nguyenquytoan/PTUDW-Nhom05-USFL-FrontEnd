{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport assert from \"assert\";\nimport { Emitter } from \"./emit\";\nimport { inherits } from \"util\";\nimport { getTypes } from \"./util\";\n\nfunction Entry() {\n  assert.ok(this instanceof Entry);\n}\n\nfunction FunctionEntry(returnLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(returnLoc);\n  this.returnLoc = returnLoc;\n}\n\ninherits(FunctionEntry, Entry);\nexports.FunctionEntry = FunctionEntry;\n\nfunction LoopEntry(breakLoc, continueLoc, label) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(breakLoc);\n  t.assertLiteral(continueLoc);\n\n  if (label) {\n    t.assertIdentifier(label);\n  } else {\n    label = null;\n  }\n\n  this.breakLoc = breakLoc;\n  this.continueLoc = continueLoc;\n  this.label = label;\n}\n\ninherits(LoopEntry, Entry);\nexports.LoopEntry = LoopEntry;\n\nfunction SwitchEntry(breakLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(breakLoc);\n  this.breakLoc = breakLoc;\n}\n\ninherits(SwitchEntry, Entry);\nexports.SwitchEntry = SwitchEntry;\n\nfunction TryEntry(firstLoc, catchEntry, finallyEntry) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n\n  if (catchEntry) {\n    assert.ok(catchEntry instanceof CatchEntry);\n  } else {\n    catchEntry = null;\n  }\n\n  if (finallyEntry) {\n    assert.ok(finallyEntry instanceof FinallyEntry);\n  } else {\n    finallyEntry = null;\n  } // Have to have one or the other (or both).\n\n\n  assert.ok(catchEntry || finallyEntry);\n  this.firstLoc = firstLoc;\n  this.catchEntry = catchEntry;\n  this.finallyEntry = finallyEntry;\n}\n\ninherits(TryEntry, Entry);\nexports.TryEntry = TryEntry;\n\nfunction CatchEntry(firstLoc, paramId) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n  t.assertIdentifier(paramId);\n  this.firstLoc = firstLoc;\n  this.paramId = paramId;\n}\n\ninherits(CatchEntry, Entry);\nexports.CatchEntry = CatchEntry;\n\nfunction FinallyEntry(firstLoc, afterLoc) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n  t.assertLiteral(afterLoc);\n  this.firstLoc = firstLoc;\n  this.afterLoc = afterLoc;\n}\n\ninherits(FinallyEntry, Entry);\nexports.FinallyEntry = FinallyEntry;\n\nfunction LabeledEntry(breakLoc, label) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(breakLoc);\n  t.assertIdentifier(label);\n  this.breakLoc = breakLoc;\n  this.label = label;\n}\n\ninherits(LabeledEntry, Entry);\nexports.LabeledEntry = LabeledEntry;\n\nfunction LeapManager(emitter) {\n  assert.ok(this instanceof LeapManager);\n  assert.ok(emitter instanceof Emitter);\n  this.emitter = emitter;\n  this.entryStack = [new FunctionEntry(emitter.finalLoc)];\n}\n\nlet LMp = LeapManager.prototype;\nexports.LeapManager = LeapManager;\n\nLMp.withEntry = function (entry, callback) {\n  assert.ok(entry instanceof Entry);\n  this.entryStack.push(entry);\n\n  try {\n    callback.call(this.emitter);\n  } finally {\n    let popped = this.entryStack.pop();\n    assert.strictEqual(popped, entry);\n  }\n};\n\nLMp._findLeapLocation = function (property, label) {\n  for (let i = this.entryStack.length - 1; i >= 0; --i) {\n    let entry = this.entryStack[i];\n    let loc = entry[property];\n\n    if (loc) {\n      if (label) {\n        if (entry.label && entry.label.name === label.name) {\n          return loc;\n        }\n      } else if (entry instanceof LabeledEntry) {// Ignore LabeledEntry entries unless we are actually breaking to\n        // a label.\n      } else {\n        return loc;\n      }\n    }\n  }\n\n  return null;\n};\n\nLMp.getBreakLoc = function (label) {\n  return this._findLeapLocation(\"breakLoc\", label);\n};\n\nLMp.getContinueLoc = function (label) {\n  return this._findLeapLocation(\"continueLoc\", label);\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/regenerator-transform/src/leap.js"],"names":["assert","Emitter","inherits","getTypes","Entry","ok","FunctionEntry","returnLoc","call","assertLiteral","exports","LoopEntry","breakLoc","continueLoc","label","t","assertIdentifier","SwitchEntry","TryEntry","firstLoc","catchEntry","finallyEntry","CatchEntry","FinallyEntry","paramId","afterLoc","LabeledEntry","LeapManager","emitter","entryStack","finalLoc","LMp","prototype","withEntry","entry","callback","push","popped","pop","strictEqual","_findLeapLocation","property","i","length","loc","name","getBreakLoc","getContinueLoc"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport assert from \"assert\";\nimport { Emitter } from \"./emit\";\nimport { inherits } from \"util\";\nimport { getTypes } from \"./util\";\n\nfunction Entry() {\n  assert.ok(this instanceof Entry);\n}\n\nfunction FunctionEntry(returnLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(returnLoc);\n  this.returnLoc = returnLoc;\n}\n\ninherits(FunctionEntry, Entry);\nexports.FunctionEntry = FunctionEntry;\n\nfunction LoopEntry(breakLoc, continueLoc, label) {\n  Entry.call(this);\n\n  const t = getTypes();\n\n  t.assertLiteral(breakLoc);\n  t.assertLiteral(continueLoc);\n\n  if (label) {\n    t.assertIdentifier(label);\n  } else {\n    label = null;\n  }\n\n  this.breakLoc = breakLoc;\n  this.continueLoc = continueLoc;\n  this.label = label;\n}\n\ninherits(LoopEntry, Entry);\nexports.LoopEntry = LoopEntry;\n\nfunction SwitchEntry(breakLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(breakLoc);\n  this.breakLoc = breakLoc;\n}\n\ninherits(SwitchEntry, Entry);\nexports.SwitchEntry = SwitchEntry;\n\nfunction TryEntry(firstLoc, catchEntry, finallyEntry) {\n  Entry.call(this);\n\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n\n  if (catchEntry) {\n    assert.ok(catchEntry instanceof CatchEntry);\n  } else {\n    catchEntry = null;\n  }\n\n  if (finallyEntry) {\n    assert.ok(finallyEntry instanceof FinallyEntry);\n  } else {\n    finallyEntry = null;\n  }\n\n  // Have to have one or the other (or both).\n  assert.ok(catchEntry || finallyEntry);\n\n  this.firstLoc = firstLoc;\n  this.catchEntry = catchEntry;\n  this.finallyEntry = finallyEntry;\n}\n\ninherits(TryEntry, Entry);\nexports.TryEntry = TryEntry;\n\nfunction CatchEntry(firstLoc, paramId) {\n  Entry.call(this);\n\n  const t = getTypes();\n\n  t.assertLiteral(firstLoc);\n  t.assertIdentifier(paramId);\n\n  this.firstLoc = firstLoc;\n  this.paramId = paramId;\n}\n\ninherits(CatchEntry, Entry);\nexports.CatchEntry = CatchEntry;\n\nfunction FinallyEntry(firstLoc, afterLoc) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n  t.assertLiteral(afterLoc);\n  this.firstLoc = firstLoc;\n  this.afterLoc = afterLoc;\n}\n\ninherits(FinallyEntry, Entry);\nexports.FinallyEntry = FinallyEntry;\n\nfunction LabeledEntry(breakLoc, label) {\n  Entry.call(this);\n\n  const t = getTypes();\n\n  t.assertLiteral(breakLoc);\n  t.assertIdentifier(label);\n\n  this.breakLoc = breakLoc;\n  this.label = label;\n}\n\ninherits(LabeledEntry, Entry);\nexports.LabeledEntry = LabeledEntry;\n\nfunction LeapManager(emitter) {\n  assert.ok(this instanceof LeapManager);\n\n  assert.ok(emitter instanceof Emitter);\n\n  this.emitter = emitter;\n  this.entryStack = [new FunctionEntry(emitter.finalLoc)];\n}\n\nlet LMp = LeapManager.prototype;\nexports.LeapManager = LeapManager;\n\nLMp.withEntry = function(entry, callback) {\n  assert.ok(entry instanceof Entry);\n  this.entryStack.push(entry);\n  try {\n    callback.call(this.emitter);\n  } finally {\n    let popped = this.entryStack.pop();\n    assert.strictEqual(popped, entry);\n  }\n};\n\nLMp._findLeapLocation = function(property, label) {\n  for (let i = this.entryStack.length - 1; i >= 0; --i) {\n    let entry = this.entryStack[i];\n    let loc = entry[property];\n    if (loc) {\n      if (label) {\n        if (entry.label &&\n            entry.label.name === label.name) {\n          return loc;\n        }\n      } else if (entry instanceof LabeledEntry) {\n        // Ignore LabeledEntry entries unless we are actually breaking to\n        // a label.\n      } else {\n        return loc;\n      }\n    }\n  }\n\n  return null;\n};\n\nLMp.getBreakLoc = function(label) {\n  return this._findLeapLocation(\"breakLoc\", label);\n};\n\nLMp.getContinueLoc = function(label) {\n  return this._findLeapLocation(\"continueLoc\", label);\n};\n"]},"metadata":{},"sourceType":"module"}