{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line after variable declarations\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-after-var\"\n    },\n    schema: [{\n      enum: [\"never\", \"always\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected blank line after variable declarations.\",\n      unexpected: \"Unexpected blank line after variable declarations.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Default `mode` to \"always\".\n\n    const mode = context.options[0] === \"never\" ? \"never\" : \"always\"; // Cache starting and ending line numbers of comments for faster lookup\n\n    const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n      result[token.loc.start.line] = token.loc.end.line;\n      return result;\n    }, {}); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets a token from the given node to compare line to the next statement.\n     *\n     * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n     *\n     * - The last token is semicolon.\n     * - The semicolon is on a different line from the previous token of the semicolon.\n     *\n     * This behavior would address semicolon-less style code. e.g.:\n     *\n     *     var foo = 1\n     *\n     *     ;(a || b).doSomething()\n     * @param {ASTNode} node The node to get.\n     * @returns {Token} The token to compare line to the next statement.\n     */\n\n    function getLastToken(node) {\n      const lastToken = sourceCode.getLastToken(node);\n\n      if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n        const prevToken = sourceCode.getTokenBefore(lastToken);\n\n        if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n          return prevToken;\n        }\n      }\n\n      return lastToken;\n    }\n    /**\n     * Determine if provided keyword is a variable declaration\n     * @private\n     * @param {string} keyword keyword to test\n     * @returns {boolean} True if `keyword` is a type of var\n     */\n\n\n    function isVar(keyword) {\n      return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n    }\n    /**\n     * Determine if provided keyword is a variant of for specifiers\n     * @private\n     * @param {string} keyword keyword to test\n     * @returns {boolean} True if `keyword` is a variant of for specifier\n     */\n\n\n    function isForTypeSpecifier(keyword) {\n      return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n    }\n    /**\n     * Determine if provided keyword is an export specifiers\n     * @private\n     * @param {string} nodeType nodeType to test\n     * @returns {boolean} True if `nodeType` is an export specifier\n     */\n\n\n    function isExportSpecifier(nodeType) {\n      return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" || nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n    }\n    /**\n     * Determine if provided node is the last of their parent block.\n     * @private\n     * @param {ASTNode} node node to test\n     * @returns {boolean} True if `node` is last of their parent block.\n     */\n\n\n    function isLastNode(node) {\n      const token = sourceCode.getTokenAfter(node);\n      return !token || token.type === \"Punctuator\" && token.value === \"}\";\n    }\n    /**\n     * Gets the last line of a group of consecutive comments\n     * @param {number} commentStartLine The starting line of the group\n     * @returns {number} The number of the last comment line of the group\n     */\n\n\n    function getLastCommentLineOfBlock(commentStartLine) {\n      const currentCommentEnd = commentEndLine[commentStartLine];\n      return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n    }\n    /**\n     * Determine if a token starts more than one line after a comment ends\n     * @param  {token}   token            The token being checked\n     * @param {integer}  commentStartLine The line number on which the comment starts\n     * @returns {boolean}                 True if `token` does not start immediately after a comment\n     */\n\n\n    function hasBlankLineAfterComment(token, commentStartLine) {\n      return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n    }\n    /**\n     * Checks that a blank line exists after a variable declaration when mode is\n     * set to \"always\", or checks that there is no blank line when mode is set\n     * to \"never\"\n     * @private\n     * @param {ASTNode} node `VariableDeclaration` node to test\n     * @returns {void}\n     */\n\n\n    function checkForBlankLine(node) {\n      /*\n       * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n       * sometimes be second-last if there is a semicolon on a different line.\n       */\n      const lastToken = getLastToken(node),\n\n      /*\n       * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n       * is the last token of the node.\n       */\n      nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n            nextLineNum = lastToken.loc.end.line + 1; // Ignore if there is no following statement\n\n      if (!nextToken) {\n        return;\n      } // Ignore if parent of node is a for variant\n\n\n      if (isForTypeSpecifier(node.parent.type)) {\n        return;\n      } // Ignore if parent of node is an export specifier\n\n\n      if (isExportSpecifier(node.parent.type)) {\n        return;\n      }\n      /*\n       * Some coding styles use multiple `var` statements, so do nothing if\n       * the next token is a `var` statement.\n       */\n\n\n      if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n        return;\n      } // Ignore if it is last statement in a block\n\n\n      if (isLastNode(node)) {\n        return;\n      } // Next statement is not a `var`...\n\n\n      const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n      const hasNextLineComment = typeof commentEndLine[nextLineNum] !== \"undefined\";\n\n      if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            identifier: node.name\n          },\n\n          fix(fixer) {\n            const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n            return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n          }\n\n        });\n      } // Token on the next line, or comment without blank line\n\n\n      if (mode === \"always\" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {\n        context.report({\n          node,\n          messageId: \"expected\",\n          data: {\n            identifier: node.name\n          },\n\n          fix(fixer) {\n            if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n              return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n            }\n\n            return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n          }\n\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclaration: checkForBlankLine\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/newline-after-var.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","mode","options","commentEndLine","getAllComments","reduce","result","token","loc","start","line","end","getLastToken","node","lastToken","value","prevToken","getTokenBefore","isVar","keyword","isForTypeSpecifier","isExportSpecifier","nodeType","isLastNode","getTokenAfter","getLastCommentLineOfBlock","commentStartLine","currentCommentEnd","hasBlankLineAfterComment","checkForBlankLine","nextToken","nextLineNum","parent","noNextLineToken","hasNextLineComment","report","messageId","data","identifier","name","fix","fixer","linesBetween","getText","slice","range","split","LINEBREAK_MATCHER","replaceTextRange","join","length","insertTextBefore","insertTextBeforeRange","column","VariableDeclaration"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line after variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-after-var\"\n        },\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected blank line after variable declarations.\",\n            unexpected: \"Unexpected blank line after variable declarations.\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a token from the given node to compare line to the next statement.\n         *\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n         *\n         * - The last token is semicolon.\n         * - The semicolon is on a different line from the previous token of the semicolon.\n         *\n         * This behavior would address semicolon-less style code. e.g.:\n         *\n         *     var foo = 1\n         *\n         *     ;(a || b).doSomething()\n         * @param {ASTNode} node The node to get.\n         * @returns {Token} The token to compare line to the next statement.\n         */\n        function getLastToken(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n                const prevToken = sourceCode.getTokenBefore(lastToken);\n\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n                    return prevToken;\n                }\n            }\n\n            return lastToken;\n        }\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n         * Gets the last line of a group of consecutive comments\n         * @param {number} commentStartLine The starting line of the group\n         * @returns {number} The number of the last comment line of the group\n         */\n        function getLastCommentLineOfBlock(commentStartLine) {\n            const currentCommentEnd = commentEndLine[commentStartLine];\n\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n\n            /*\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n             * sometimes be second-last if there is a semicolon on a different line.\n             */\n            const lastToken = getLastToken(node),\n\n                /*\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n                 * is the last token of the node.\n                 */\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n                nextLineNum = lastToken.loc.end.line + 1;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            /*\n             * Some coding styles use multiple `var` statements, so do nothing if\n             * the next token is a `var` statement.\n             */\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n                    }\n                });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report({\n                    node,\n                    messageId: \"expected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n                        }\n\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}