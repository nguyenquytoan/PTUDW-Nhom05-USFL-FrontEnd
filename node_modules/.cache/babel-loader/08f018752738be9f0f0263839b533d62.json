{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.svgParser = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function getLocator(source, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n      var end = start + line.length + 1;\n      var range = {\n        start: start,\n        end: end,\n        line: i\n      };\n      start = end;\n      return range;\n    });\n    var i = 0;\n\n    function rangeContains(range, index) {\n      return range.start <= index && index < range.end;\n    }\n\n    function getLocation(range, index) {\n      return {\n        line: offsetLine + range.line,\n        column: offsetColumn + index - range.start,\n        character: index\n      };\n    }\n\n    function locate(search, startIndex) {\n      if (typeof search === 'string') {\n        search = source.indexOf(search, startIndex || 0);\n      }\n\n      var range = lineRanges[i];\n      var d = search >= range.end ? 1 : -1;\n\n      while (range) {\n        if (rangeContains(range, search)) return getLocation(range, search);\n        i += d;\n        range = lineRanges[i];\n      }\n    }\n\n    return locate;\n  }\n\n  function locate(source, search, options) {\n    if (typeof options === 'number') {\n      throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n\n    return getLocator(source, options)(search, options && options.startIndex);\n  }\n\n  var validNameCharacters = /[a-zA-Z0-9:_-]/;\n  var whitespace = /[\\s\\t\\r\\n]/;\n  var quotemark = /['\"]/;\n\n  function repeat(str, i) {\n    var result = '';\n\n    while (i--) {\n      result += str;\n    }\n\n    return result;\n  }\n\n  function parse(source) {\n    var header = '';\n    var stack = [];\n    var state = metadata;\n    var currentElement = null;\n    var root = null;\n\n    function error(message) {\n      var ref = locate(source, i);\n      var line = ref.line;\n      var column = ref.column;\n      var before = source.slice(0, i);\n      var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n      var after = source.slice(i);\n      var afterLine = /.*(\\n|$)/.exec(after)[0];\n      var snippet = \"\" + beforeLine + afterLine + \"\\n\" + repeat(' ', beforeLine.length) + \"^\";\n      throw new Error(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues â€“ thanks!\\n\\n\" + snippet);\n    }\n\n    function metadata() {\n      while (i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])) {\n        header += source[i++];\n      }\n\n      return neutral();\n    }\n\n    function neutral() {\n      var text = '';\n\n      while (i < source.length && source[i] !== '<') {\n        text += source[i++];\n      }\n\n      if (/\\S/.test(text)) {\n        currentElement.children.push({\n          type: 'text',\n          value: text\n        });\n      }\n\n      if (source[i] === '<') {\n        return tag;\n      }\n\n      return neutral;\n    }\n\n    function tag() {\n      var char = source[i];\n\n      if (char === '?') {\n        return neutral;\n      } // <?xml...\n\n\n      if (char === '!') {\n        if (source.slice(i + 1, i + 3) === '--') {\n          return comment;\n        }\n\n        if (source.slice(i + 1, i + 8) === '[CDATA[') {\n          return cdata;\n        }\n\n        if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n          return neutral;\n        }\n      }\n\n      if (char === '/') {\n        return closingTag;\n      }\n\n      var tagName = getName();\n      var element = {\n        type: 'element',\n        tagName: tagName,\n        properties: {},\n        children: []\n      };\n\n      if (currentElement) {\n        currentElement.children.push(element);\n      } else {\n        root = element;\n      }\n\n      var attribute;\n\n      while (i < source.length && (attribute = getAttribute())) {\n        element.properties[attribute.name] = attribute.value;\n      }\n\n      var selfClosing = false;\n\n      if (source[i] === '/') {\n        i += 1;\n        selfClosing = true;\n      }\n\n      if (source[i] !== '>') {\n        error('Expected >');\n      }\n\n      if (!selfClosing) {\n        currentElement = element;\n        stack.push(element);\n      }\n\n      return neutral;\n    }\n\n    function comment() {\n      var index = source.indexOf('-->', i);\n\n      if (!~index) {\n        error('expected -->');\n      }\n\n      i = index + 2;\n      return neutral;\n    }\n\n    function cdata() {\n      var index = source.indexOf(']]>', i);\n\n      if (!~index) {\n        error('expected ]]>');\n      }\n\n      currentElement.children.push(source.slice(i + 7, index));\n      i = index + 2;\n      return neutral;\n    }\n\n    function closingTag() {\n      var tagName = getName();\n\n      if (!tagName) {\n        error('Expected tag name');\n      }\n\n      if (tagName !== currentElement.tagName) {\n        error(\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + currentElement.tagName + \">\");\n      }\n\n      allowSpaces();\n\n      if (source[i] !== '>') {\n        error('Expected >');\n      }\n\n      stack.pop();\n      currentElement = stack[stack.length - 1];\n      return neutral;\n    }\n\n    function getName() {\n      var name = '';\n\n      while (i < source.length && validNameCharacters.test(source[i])) {\n        name += source[i++];\n      }\n\n      return name;\n    }\n\n    function getAttribute() {\n      if (!whitespace.test(source[i])) {\n        return null;\n      }\n\n      allowSpaces();\n      var name = getName();\n\n      if (!name) {\n        return null;\n      }\n\n      var value = true;\n      allowSpaces();\n\n      if (source[i] === '=') {\n        i += 1;\n        allowSpaces();\n        value = getAttributeValue();\n\n        if (!isNaN(value) && value.trim() !== '') {\n          value = +value;\n        } // TODO whitelist numeric attributes?\n\n      }\n\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    function getAttributeValue() {\n      return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n    }\n\n    function getUnquotedAttributeValue() {\n      var value = '';\n\n      do {\n        var char = source[i];\n\n        if (char === ' ' || char === '>' || char === '/') {\n          return value;\n        }\n\n        value += char;\n        i += 1;\n      } while (i < source.length);\n\n      return value;\n    }\n\n    function getQuotedAttributeValue() {\n      var quotemark = source[i++];\n      var value = '';\n      var escaped = false;\n\n      while (i < source.length) {\n        var char = source[i++];\n\n        if (char === quotemark && !escaped) {\n          return value;\n        }\n\n        if (char === '\\\\' && !escaped) {\n          escaped = true;\n        }\n\n        value += escaped ? \"\\\\\" + char : char;\n        escaped = false;\n      }\n    }\n\n    function allowSpaces() {\n      while (i < source.length && whitespace.test(source[i])) {\n        i += 1;\n      }\n    }\n\n    var i = metadata.length;\n\n    while (i < source.length) {\n      if (!state) {\n        error('Unexpected character');\n      }\n\n      state = state();\n      i += 1;\n    }\n\n    if (state !== neutral) {\n      error('Unexpected end of input');\n    }\n\n    if (root.tagName === 'svg') {\n      root.metadata = header;\n    }\n\n    return {\n      type: 'root',\n      children: [root]\n    };\n  }\n\n  exports.parse = parse;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../node_modules/locate-character/dist/locate-character.es.js","../src/index.js"],"names":["const","let"],"mappings":"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","sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues â€“ thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"]},"metadata":{},"sourceType":"script"}