{"ast":null,"code":"import Promise from './promise';\nimport { noop, resolve, reject } from './-internal';\n\nfunction makeObject(_, argumentNames) {\n  let obj = {};\n  let length = _.length;\n  let args = new Array(length);\n\n  for (let x = 0; x < length; x++) {\n    args[x] = _[x];\n  }\n\n  for (let i = 0; i < argumentNames.length; i++) {\n    let name = argumentNames[i];\n    obj[name] = args[i + 1];\n  }\n\n  return obj;\n}\n\nfunction arrayResult(_) {\n  let length = _.length;\n  let args = new Array(length - 1);\n\n  for (let i = 1; i < length; i++) {\n    args[i - 1] = _[i];\n  }\n\n  return args;\n}\n\nfunction wrapThenable(then, promise) {\n  return {\n    then(onFulFillment, onRejection) {\n      return then.call(promise, onFulFillment, onRejection);\n    }\n\n  };\n}\n/**\n  `denodeify` takes a 'node-style' function and returns a function that\n  will return an `Promise`. You can use `denodeify` in Node.js or the\n  browser when you'd prefer to use promises over using callbacks. For example,\n  `denodeify` transforms the following:\n\n  ```javascript\n  let fs = require('fs');\n\n  fs.readFile('myfile.txt', function(err, data){\n    if (err) return handleError(err);\n    handleData(data);\n  });\n  ```\n\n  into:\n\n  ```javascript\n  let fs = require('fs');\n  let readFile = denodeify(fs.readFile);\n\n  readFile('myfile.txt').then(handleData, handleError);\n  ```\n\n  If the node function has multiple success parameters, then `denodeify`\n  just returns the first one:\n\n  ```javascript\n  let request = denodeify(require('request'));\n\n  request('http://example.com').then(function(res) {\n    // ...\n  });\n  ```\n\n  However, if you need all success parameters, setting `denodeify`'s\n  second parameter to `true` causes it to return all success parameters\n  as an array:\n\n  ```javascript\n  let request = denodeify(require('request'), true);\n\n  request('http://example.com').then(function(result) {\n    // result[0] -> res\n    // result[1] -> body\n  });\n  ```\n\n  Or if you pass it an array with names it returns the parameters as a hash:\n\n  ```javascript\n  let request = denodeify(require('request'), ['res', 'body']);\n\n  request('http://example.com').then(function(result) {\n    // result.res\n    // result.body\n  });\n  ```\n\n  Sometimes you need to retain the `this`:\n\n  ```javascript\n  let app = require('express')();\n  let render = denodeify(app.render.bind(app));\n  ```\n\n  The denodified function inherits from the original function. It works in all\n  environments, except IE 10 and below. Consequently all properties of the original\n  function are available to you. However, any properties you change on the\n  denodeified function won't be changed on the original function. Example:\n\n  ```javascript\n  let request = denodeify(require('request')),\n      cookieJar = request.jar(); // <- Inheritance is used here\n\n  request('http://example.com', {jar: cookieJar}).then(function(res) {\n    // cookieJar.cookies holds now the cookies returned by example.com\n  });\n  ```\n\n  Using `denodeify` makes it easier to compose asynchronous operations instead\n  of using callbacks. For example, instead of:\n\n  ```javascript\n  let fs = require('fs');\n\n  fs.readFile('myfile.txt', function(err, data){\n    if (err) { ... } // Handle error\n    fs.writeFile('myfile2.txt', data, function(err){\n      if (err) { ... } // Handle error\n      console.log('done')\n    });\n  });\n  ```\n\n  you can chain the operations together using `then` from the returned promise:\n\n  ```javascript\n  let fs = require('fs');\n  let readFile = denodeify(fs.readFile);\n  let writeFile = denodeify(fs.writeFile);\n\n  readFile('myfile.txt').then(function(data){\n    return writeFile('myfile2.txt', data);\n  }).then(function(){\n    console.log('done')\n  }).catch(function(error){\n    // Handle error\n  });\n  ```\n\n  @method denodeify\n  @public\n  @static\n  @for rsvp\n  @param {Function} nodeFunc a 'node-style' function that takes a callback as\n  its last argument. The callback expects an error to be passed as its first\n  argument (if an error occurred, otherwise null), and the value from the\n  operation as its second argument ('function(err, value){ }').\n  @param {Boolean|Array} [options] An optional paramter that if set\n  to `true` causes the promise to fulfill with the callback's success arguments\n  as an array. This is useful if the node function has multiple success\n  paramters. If you set this paramter to an array with names, the promise will\n  fulfill with a hash with these names as keys and the success parameters as\n  values.\n  @return {Function} a function that wraps `nodeFunc` to return a `Promise`\n*/\n\n\nexport default function denodeify(nodeFunc, options) {\n  let fn = function () {\n    let l = arguments.length;\n    let args = new Array(l + 1);\n    let promiseInput = false;\n\n    for (let i = 0; i < l; ++i) {\n      let arg = arguments[i];\n      let then; // TODO: this code really needs to be cleaned up\n\n      if (!promiseInput) {\n        if (arg !== null && typeof arg === 'object') {\n          if (arg.constructor === Promise) {\n            promiseInput = true;\n          } else {\n            try {\n              promiseInput = arg.then;\n            } catch (error) {\n              let p = new Promise(noop);\n              reject(p, error);\n              return p;\n            }\n          }\n        } else {\n          promiseInput = false;\n        }\n\n        if (promiseInput && promiseInput !== true) {\n          arg = wrapThenable(promiseInput, arg);\n        }\n      }\n\n      args[i] = arg;\n    }\n\n    let promise = new Promise(noop);\n\n    args[l] = function (err, val) {\n      if (err) {\n        reject(promise, err);\n      } else if (options === undefined) {\n        resolve(promise, val);\n      } else if (options === true) {\n        resolve(promise, arrayResult(arguments));\n      } else if (Array.isArray(options)) {\n        resolve(promise, makeObject(arguments, options));\n      } else {\n        resolve(promise, val);\n      }\n    };\n\n    if (promiseInput) {\n      return handlePromiseInput(promise, args, nodeFunc, this);\n    } else {\n      return handleValueInput(promise, args, nodeFunc, this);\n    }\n  };\n\n  fn.__proto__ = nodeFunc;\n  return fn;\n}\n\nfunction handleValueInput(promise, args, nodeFunc, self) {\n  try {\n    nodeFunc.apply(self, args);\n  } catch (error) {\n    reject(promise, error);\n  }\n\n  return promise;\n}\n\nfunction handlePromiseInput(promise, args, nodeFunc, self) {\n  return Promise.all(args).then(args => handleValueInput(promise, args, nodeFunc, self));\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/rsvp/lib/rsvp/node.js"],"names":["Promise","noop","resolve","reject","makeObject","_","argumentNames","obj","length","args","Array","x","i","name","arrayResult","wrapThenable","then","promise","onFulFillment","onRejection","call","denodeify","nodeFunc","options","fn","l","arguments","promiseInput","arg","constructor","error","p","err","val","undefined","isArray","handlePromiseInput","handleValueInput","__proto__","self","apply","all"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,SACEC,IADF,EAEEC,OAFF,EAGEC,MAHF,QAIO,aAJP;;AAMA,SAASC,UAAT,CAAoBC,CAApB,EAAuBC,aAAvB,EAAsC;AACpC,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,MAAM,GAAGH,CAAC,CAACG,MAAf;AACA,MAAIC,IAAI,GAAG,IAAIC,KAAJ,CAAUF,MAAV,CAAX;;AAEA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAApB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/BF,IAAAA,IAAI,CAACE,CAAD,CAAJ,GAAUN,CAAC,CAACM,CAAD,CAAX;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,aAAa,CAACE,MAAlC,EAA0CI,CAAC,EAA3C,EAA+C;AAC7C,QAAIC,IAAI,GAAGP,aAAa,CAACM,CAAD,CAAxB;AACAL,IAAAA,GAAG,CAACM,IAAD,CAAH,GAAYJ,IAAI,CAACG,CAAC,GAAG,CAAL,CAAhB;AACD;;AAED,SAAOL,GAAP;AACD;;AAED,SAASO,WAAT,CAAqBT,CAArB,EAAwB;AACtB,MAAIG,MAAM,GAAGH,CAAC,CAACG,MAAf;AACA,MAAIC,IAAI,GAAG,IAAIC,KAAJ,CAAUF,MAAM,GAAG,CAAnB,CAAX;;AAEA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4BI,CAAC,EAA7B,EAAiC;AAC/BH,IAAAA,IAAI,CAACG,CAAC,GAAG,CAAL,CAAJ,GAAcP,CAAC,CAACO,CAAD,CAAf;AACD;;AAED,SAAOH,IAAP;AACD;;AAED,SAASM,YAAT,CAAsBC,IAAtB,EAA4BC,OAA5B,EAAqC;AACnC,SAAO;AACLD,IAAAA,IAAI,CAACE,aAAD,EAAgBC,WAAhB,EAA6B;AAC/B,aAAOH,IAAI,CAACI,IAAL,CAAUH,OAAV,EAAmBC,aAAnB,EAAkCC,WAAlC,CAAP;AACD;;AAHI,GAAP;AAKD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+HA,eAAe,SAASE,SAAT,CAAmBC,QAAnB,EAA6BC,OAA7B,EAAsC;AACnD,MAAIC,EAAE,GAAG,YAAW;AAClB,QAAIC,CAAC,GAAGC,SAAS,CAAClB,MAAlB;AACA,QAAIC,IAAI,GAAG,IAAIC,KAAJ,CAAUe,CAAC,GAAG,CAAd,CAAX;AACA,QAAIE,YAAY,GAAG,KAAnB;;AAEA,SAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGa,CAApB,EAAuB,EAAEb,CAAzB,EAA4B;AAC1B,UAAIgB,GAAG,GAAGF,SAAS,CAACd,CAAD,CAAnB;AACA,UAAII,IAAJ,CAF0B,CAI1B;;AACA,UAAI,CAACW,YAAL,EAAmB;AACjB,YAAIC,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAnC,EAA6C;AAC3C,cAAIA,GAAG,CAACC,WAAJ,KAAoB7B,OAAxB,EAAiC;AAC/B2B,YAAAA,YAAY,GAAG,IAAf;AACD,WAFD,MAEO;AACL,gBAAI;AACFA,cAAAA,YAAY,GAAGC,GAAG,CAACZ,IAAnB;AACD,aAFD,CAEE,OAAMc,KAAN,EAAa;AACb,kBAAIC,CAAC,GAAG,IAAI/B,OAAJ,CAAYC,IAAZ,CAAR;AACAE,cAAAA,MAAM,CAAC4B,CAAD,EAAID,KAAJ,CAAN;AACA,qBAAOC,CAAP;AACD;AACF;AACF,SAZD,MAYO;AACLJ,UAAAA,YAAY,GAAG,KAAf;AACD;;AACD,YAAIA,YAAY,IAAIA,YAAY,KAAK,IAArC,EAA2C;AACzCC,UAAAA,GAAG,GAAGb,YAAY,CAACY,YAAD,EAAeC,GAAf,CAAlB;AACD;AACF;;AACDnB,MAAAA,IAAI,CAACG,CAAD,CAAJ,GAAUgB,GAAV;AACD;;AAED,QAAIX,OAAO,GAAG,IAAIjB,OAAJ,CAAYC,IAAZ,CAAd;;AAEAQ,IAAAA,IAAI,CAACgB,CAAD,CAAJ,GAAU,UAASO,GAAT,EAAcC,GAAd,EAAmB;AAC3B,UAAID,GAAJ,EAAS;AACP7B,QAAAA,MAAM,CAACc,OAAD,EAAUe,GAAV,CAAN;AACD,OAFD,MAEO,IAAIT,OAAO,KAAKW,SAAhB,EAA2B;AAChChC,QAAAA,OAAO,CAACe,OAAD,EAAUgB,GAAV,CAAP;AACD,OAFM,MAEA,IAAIV,OAAO,KAAK,IAAhB,EAAsB;AAC3BrB,QAAAA,OAAO,CAACe,OAAD,EAAUH,WAAW,CAACY,SAAD,CAArB,CAAP;AACD,OAFM,MAEA,IAAIhB,KAAK,CAACyB,OAAN,CAAcZ,OAAd,CAAJ,EAA4B;AACjCrB,QAAAA,OAAO,CAACe,OAAD,EAAUb,UAAU,CAACsB,SAAD,EAAYH,OAAZ,CAApB,CAAP;AACD,OAFM,MAEA;AACLrB,QAAAA,OAAO,CAACe,OAAD,EAAUgB,GAAV,CAAP;AACD;AACF,KAZD;;AAcA,QAAIN,YAAJ,EAAkB;AAChB,aAAOS,kBAAkB,CAACnB,OAAD,EAAUR,IAAV,EAAgBa,QAAhB,EAA0B,IAA1B,CAAzB;AACD,KAFD,MAEO;AACL,aAAOe,gBAAgB,CAACpB,OAAD,EAAUR,IAAV,EAAgBa,QAAhB,EAA0B,IAA1B,CAAvB;AACD;AACF,GAtDD;;AAwDAE,EAAAA,EAAE,CAACc,SAAH,GAAehB,QAAf;AAEA,SAAOE,EAAP;AACD;;AAED,SAASa,gBAAT,CAA0BpB,OAA1B,EAAmCR,IAAnC,EAAyCa,QAAzC,EAAmDiB,IAAnD,EAAyD;AACvD,MAAI;AACFjB,IAAAA,QAAQ,CAACkB,KAAT,CAAeD,IAAf,EAAqB9B,IAArB;AACD,GAFD,CAEE,OAAOqB,KAAP,EAAc;AACd3B,IAAAA,MAAM,CAACc,OAAD,EAAUa,KAAV,CAAN;AACD;;AACD,SAAOb,OAAP;AACD;;AAED,SAASmB,kBAAT,CAA4BnB,OAA5B,EAAqCR,IAArC,EAA2Ca,QAA3C,EAAqDiB,IAArD,EAA0D;AACxD,SAAOvC,OAAO,CAACyC,GAAR,CAAYhC,IAAZ,EACJO,IADI,CACCP,IAAI,IAAI4B,gBAAgB,CAACpB,OAAD,EAAUR,IAAV,EAAgBa,QAAhB,EAA0BiB,IAA1B,CADzB,CAAP;AAED","sourcesContent":["import Promise from './promise';\nimport {\n  noop,\n  resolve,\n  reject,\n} from './-internal';\n\nfunction makeObject(_, argumentNames) {\n  let obj = {};\n  let length = _.length;\n  let args = new Array(length);\n\n  for (let x = 0; x < length; x++) {\n    args[x] = _[x];\n  }\n\n  for (let i = 0; i < argumentNames.length; i++) {\n    let name = argumentNames[i];\n    obj[name] = args[i + 1];\n  }\n\n  return obj;\n}\n\nfunction arrayResult(_) {\n  let length = _.length;\n  let args = new Array(length - 1);\n\n  for (let i = 1; i < length; i++) {\n    args[i - 1] = _[i];\n  }\n\n  return args;\n}\n\nfunction wrapThenable(then, promise) {\n  return {\n    then(onFulFillment, onRejection) {\n      return then.call(promise, onFulFillment, onRejection);\n    }\n  };\n}\n\n/**\n  `denodeify` takes a 'node-style' function and returns a function that\n  will return an `Promise`. You can use `denodeify` in Node.js or the\n  browser when you'd prefer to use promises over using callbacks. For example,\n  `denodeify` transforms the following:\n\n  ```javascript\n  let fs = require('fs');\n\n  fs.readFile('myfile.txt', function(err, data){\n    if (err) return handleError(err);\n    handleData(data);\n  });\n  ```\n\n  into:\n\n  ```javascript\n  let fs = require('fs');\n  let readFile = denodeify(fs.readFile);\n\n  readFile('myfile.txt').then(handleData, handleError);\n  ```\n\n  If the node function has multiple success parameters, then `denodeify`\n  just returns the first one:\n\n  ```javascript\n  let request = denodeify(require('request'));\n\n  request('http://example.com').then(function(res) {\n    // ...\n  });\n  ```\n\n  However, if you need all success parameters, setting `denodeify`'s\n  second parameter to `true` causes it to return all success parameters\n  as an array:\n\n  ```javascript\n  let request = denodeify(require('request'), true);\n\n  request('http://example.com').then(function(result) {\n    // result[0] -> res\n    // result[1] -> body\n  });\n  ```\n\n  Or if you pass it an array with names it returns the parameters as a hash:\n\n  ```javascript\n  let request = denodeify(require('request'), ['res', 'body']);\n\n  request('http://example.com').then(function(result) {\n    // result.res\n    // result.body\n  });\n  ```\n\n  Sometimes you need to retain the `this`:\n\n  ```javascript\n  let app = require('express')();\n  let render = denodeify(app.render.bind(app));\n  ```\n\n  The denodified function inherits from the original function. It works in all\n  environments, except IE 10 and below. Consequently all properties of the original\n  function are available to you. However, any properties you change on the\n  denodeified function won't be changed on the original function. Example:\n\n  ```javascript\n  let request = denodeify(require('request')),\n      cookieJar = request.jar(); // <- Inheritance is used here\n\n  request('http://example.com', {jar: cookieJar}).then(function(res) {\n    // cookieJar.cookies holds now the cookies returned by example.com\n  });\n  ```\n\n  Using `denodeify` makes it easier to compose asynchronous operations instead\n  of using callbacks. For example, instead of:\n\n  ```javascript\n  let fs = require('fs');\n\n  fs.readFile('myfile.txt', function(err, data){\n    if (err) { ... } // Handle error\n    fs.writeFile('myfile2.txt', data, function(err){\n      if (err) { ... } // Handle error\n      console.log('done')\n    });\n  });\n  ```\n\n  you can chain the operations together using `then` from the returned promise:\n\n  ```javascript\n  let fs = require('fs');\n  let readFile = denodeify(fs.readFile);\n  let writeFile = denodeify(fs.writeFile);\n\n  readFile('myfile.txt').then(function(data){\n    return writeFile('myfile2.txt', data);\n  }).then(function(){\n    console.log('done')\n  }).catch(function(error){\n    // Handle error\n  });\n  ```\n\n  @method denodeify\n  @public\n  @static\n  @for rsvp\n  @param {Function} nodeFunc a 'node-style' function that takes a callback as\n  its last argument. The callback expects an error to be passed as its first\n  argument (if an error occurred, otherwise null), and the value from the\n  operation as its second argument ('function(err, value){ }').\n  @param {Boolean|Array} [options] An optional paramter that if set\n  to `true` causes the promise to fulfill with the callback's success arguments\n  as an array. This is useful if the node function has multiple success\n  paramters. If you set this paramter to an array with names, the promise will\n  fulfill with a hash with these names as keys and the success parameters as\n  values.\n  @return {Function} a function that wraps `nodeFunc` to return a `Promise`\n*/\nexport default function denodeify(nodeFunc, options) {\n  let fn = function() {\n    let l = arguments.length;\n    let args = new Array(l + 1);\n    let promiseInput = false;\n\n    for (let i = 0; i < l; ++i) {\n      let arg = arguments[i];\n      let then;\n\n      // TODO: this code really needs to be cleaned up\n      if (!promiseInput) {\n        if (arg !== null && typeof arg === 'object') {\n          if (arg.constructor === Promise) {\n            promiseInput = true;\n          } else {\n            try {\n              promiseInput = arg.then;\n            } catch(error) {\n              let p = new Promise(noop);\n              reject(p, error);\n              return p;\n            }\n          }\n        } else {\n          promiseInput = false;\n        }\n        if (promiseInput && promiseInput !== true) {\n          arg = wrapThenable(promiseInput, arg);\n        }\n      }\n      args[i] = arg;\n    }\n\n    let promise = new Promise(noop);\n\n    args[l] = function(err, val) {\n      if (err) {\n        reject(promise, err);\n      } else if (options === undefined) {\n        resolve(promise, val);\n      } else if (options === true) {\n        resolve(promise, arrayResult(arguments));\n      } else if (Array.isArray(options)) {\n        resolve(promise, makeObject(arguments, options));\n      } else {\n        resolve(promise, val);\n      }\n    };\n\n    if (promiseInput) {\n      return handlePromiseInput(promise, args, nodeFunc, this);\n    } else {\n      return handleValueInput(promise, args, nodeFunc, this);\n    }\n  };\n\n  fn.__proto__ = nodeFunc;\n\n  return fn;\n}\n\nfunction handleValueInput(promise, args, nodeFunc, self) {\n  try {\n    nodeFunc.apply(self, args);\n  } catch (error) {\n    reject(promise, error);\n  }\n  return promise;\n}\n\nfunction handlePromiseInput(promise, args, nodeFunc, self){\n  return Promise.all(args)\n    .then(args => handleValueInput(promise, args, nodeFunc, self));\n}\n"]},"metadata":{},"sourceType":"module"}