{"ast":null,"code":"// @ts-check\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Chunk.js\")} WebpackChunk */\n'use strict';\n/**\n * @file\n * This file uses webpack to compile a template with a child compiler.\n *\n * [TEMPLATE] -> [JAVASCRIPT]\n *\n */\n\n'use strict';\n\nconst NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');\n\nconst NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');\n\nconst LoaderTargetPlugin = require('webpack/lib/LoaderTargetPlugin');\n\nconst LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');\n\nconst SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');\n/**\n * The HtmlWebpackChildCompiler is a helper to allow resusing one childCompiler\n * for multile HtmlWebpackPlugin instances to improve the compilation performance.\n */\n\n\nclass HtmlWebpackChildCompiler {\n  constructor() {\n    /**\n     * @type {string[]} templateIds\n     * The template array will allow us to keep track which input generated which output\n     */\n    this.templates = [];\n    /**\n     * @type {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}\n     */\n\n    this.compilationPromise; // eslint-disable-line\n\n    /**\n     * @type {number}\n     */\n\n    this.compilationStartedTimestamp; // eslint-disable-line\n\n    /**\n     * @type {number}\n     */\n\n    this.compilationEndedTimestamp; // eslint-disable-line\n\n    /**\n     * All file dependencies of the child compiler\n     * @type {string[]}\n     */\n\n    this.fileDependencies = [];\n  }\n  /**\n   * Add a templatePath to the child compiler\n   * The given template will be compiled by `compileTemplates`\n   * @param {string} template - The webpack path to the template e.g. `'!!html-loader!index.html'`\n   * @returns {boolean} true if the template is new\n   */\n\n\n  addTemplate(template) {\n    const templateId = this.templates.indexOf(template); // Don't add the template to the compiler if a similar template was already added\n\n    if (templateId !== -1) {\n      return false;\n    } // A child compiler can compile only once\n    // throw an error if a new template is added after the compilation started\n\n\n    if (this.isCompiling()) {\n      throw new Error('New templates can only be added before `compileTemplates` was called.');\n    } // Add the template to the childCompiler\n\n\n    this.templates.push(template); // Mark the cache invalid\n\n    return true;\n  }\n  /**\n   * Returns true if the childCompiler is currently compiling\n   * @retuns {boolean}\n   */\n\n\n  isCompiling() {\n    return !this.didCompile() && this.compilationStartedTimestamp !== undefined;\n  }\n  /**\n   * Returns true if the childCOmpiler is done compiling\n   */\n\n\n  didCompile() {\n    return this.compilationEndedTimestamp !== undefined;\n  }\n  /**\n   * This function will start the template compilation\n   * once it is started no more templates can be added\n   *\n   * @param {WebpackCompilation} mainCompilation\n   * @returns {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}\n   */\n\n\n  compileTemplates(mainCompilation) {\n    // To prevent multiple compilations for the same template\n    // the compilation is cached in a promise.\n    // If it already exists return\n    if (this.compilationPromise) {\n      return this.compilationPromise;\n    } // The entry file is just an empty helper as the dynamic template\n    // require is added in \"loader.js\"\n\n\n    const outputOptions = {\n      filename: '__child-[name]',\n      publicPath: mainCompilation.outputOptions.publicPath\n    };\n    const compilerName = 'HtmlWebpackCompiler'; // Create an additional child compiler which takes the template\n    // and turns it into an Node.JS html factory.\n    // This allows us to use loaders during the compilation\n\n    const childCompiler = mainCompilation.createChildCompiler(compilerName, outputOptions); // The file path context which webpack uses to resolve all relative files to\n\n    childCompiler.context = mainCompilation.compiler.context; // Compile the template to nodejs javascript\n\n    new NodeTemplatePlugin(outputOptions).apply(childCompiler);\n    new NodeTargetPlugin().apply(childCompiler);\n    new LibraryTemplatePlugin('HTML_WEBPACK_PLUGIN_RESULT', 'var').apply(childCompiler);\n    new LoaderTargetPlugin('node').apply(childCompiler); // Add all templates\n\n    this.templates.forEach((template, index) => {\n      new SingleEntryPlugin(childCompiler.context, template, `HtmlWebpackPlugin_${index}`).apply(childCompiler);\n    });\n    this.compilationStartedTimestamp = new Date().getTime();\n    this.compilationPromise = new Promise((resolve, reject) => {\n      childCompiler.runAsChild((err, entries, childCompilation) => {\n        // Extract templates\n        const compiledTemplates = entries ? extractHelperFilesFromCompilation(mainCompilation, childCompilation, outputOptions.filename, entries) : []; // Extract file dependencies\n\n        if (entries) {\n          this.fileDependencies = Array.from(childCompilation.fileDependencies);\n        } // Reject the promise if the childCompilation contains error\n\n\n        if (childCompilation && childCompilation.errors && childCompilation.errors.length) {\n          const errorDetails = childCompilation.errors.map(error => error.message + (error.error ? ':\\n' + error.error : '')).join('\\n');\n          reject(new Error('Child compilation failed:\\n' + errorDetails));\n          return;\n        } // Reject if the error object contains errors\n\n\n        if (err) {\n          reject(err);\n          return;\n        }\n        /**\n         * @type {{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}}\n         */\n\n\n        const result = {};\n        compiledTemplates.forEach((templateSource, entryIndex) => {\n          // The compiledTemplates are generated from the entries added in\n          // the addTemplate function.\n          // Therefore the array index of this.templates should be the as entryIndex.\n          result[this.templates[entryIndex]] = {\n            content: templateSource,\n            hash: childCompilation.hash,\n            entry: entries[entryIndex]\n          };\n        });\n        this.compilationEndedTimestamp = new Date().getTime();\n        resolve(result);\n      });\n    });\n    return this.compilationPromise;\n  }\n\n}\n/**\n * The webpack child compilation will create files as a side effect.\n * This function will extract them and clean them up so they won't be written to disk.\n *\n * Returns the source code of the compiled templates as string\n *\n * @returns Array<string>\n */\n\n\nfunction extractHelperFilesFromCompilation(mainCompilation, childCompilation, filename, childEntryChunks) {\n  const helperAssetNames = childEntryChunks.map((entryChunk, index) => {\n    return mainCompilation.mainTemplate.getAssetPath(filename, {\n      hash: childCompilation.hash,\n      chunk: entryChunk,\n      name: `HtmlWebpackPlugin_${index}`\n    });\n  });\n  helperAssetNames.forEach(helperFileName => {\n    delete mainCompilation.assets[helperFileName];\n  });\n  const helperContents = helperAssetNames.map(helperFileName => {\n    return childCompilation.assets[helperFileName].source();\n  });\n  return helperContents;\n}\n/**\n * @type {WeakMap<WebpackCompiler, HtmlWebpackChildCompiler>}}\n */\n\n\nconst childCompilerCache = new WeakMap();\n/**\n * Get child compiler from cache or a new child compiler for the given mainCompilation\n *\n * @param {WebpackCompiler} mainCompiler\n */\n\nfunction getChildCompiler(mainCompiler) {\n  const cachedChildCompiler = childCompilerCache.get(mainCompiler);\n\n  if (cachedChildCompiler) {\n    return cachedChildCompiler;\n  }\n\n  const newCompiler = new HtmlWebpackChildCompiler();\n  childCompilerCache.set(mainCompiler, newCompiler);\n  return newCompiler;\n}\n/**\n * Remove the childCompiler from the cache\n *\n * @param {WebpackCompiler} mainCompiler\n */\n\n\nfunction clearCache(mainCompiler) {\n  const childCompiler = getChildCompiler(mainCompiler); // If this childCompiler was already used\n  // remove the entire childCompiler from the cache\n\n  if (childCompiler.isCompiling() || childCompiler.didCompile()) {\n    childCompilerCache.delete(mainCompiler);\n  }\n}\n/**\n * Register a template for the current main compiler\n * @param {WebpackCompiler} mainCompiler\n * @param {string} templatePath\n */\n\n\nfunction addTemplateToCompiler(mainCompiler, templatePath) {\n  const childCompiler = getChildCompiler(mainCompiler);\n  const isNew = childCompiler.addTemplate(templatePath);\n\n  if (isNew) {\n    clearCache(mainCompiler);\n  }\n}\n/**\n * Starts the compilation for all templates.\n * This has to be called once all templates where added.\n *\n * If this function is called multiple times it will use a cache inside\n * the childCompiler\n *\n * @param {string} templatePath\n * @param {string} outputFilename\n * @param {WebpackCompilation} mainCompilation\n */\n\n\nfunction compileTemplate(templatePath, outputFilename, mainCompilation) {\n  const childCompiler = getChildCompiler(mainCompilation.compiler);\n  return childCompiler.compileTemplates(mainCompilation).then(compiledTemplates => {\n    if (!compiledTemplates[templatePath]) console.log(Object.keys(compiledTemplates), templatePath);\n    const compiledTemplate = compiledTemplates[templatePath]; // Replace [hash] placeholders in filename\n\n    const outputName = mainCompilation.mainTemplate.getAssetPath(outputFilename, {\n      hash: compiledTemplate.hash,\n      chunk: compiledTemplate.entry\n    });\n    return {\n      // Hash of the template entry point\n      hash: compiledTemplate.hash,\n      // Output name\n      outputName: outputName,\n      // Compiled code\n      content: compiledTemplate.content\n    };\n  });\n}\n/**\n * Return all file dependencies of the last child compilation\n *\n * @param {WebpackCompiler} compiler\n * @returns {Array<string>}\n */\n\n\nfunction getFileDependencies(compiler) {\n  const childCompiler = getChildCompiler(compiler);\n  return childCompiler.fileDependencies;\n}\n/**\n * @type {WeakMap<WebpackCompilation, WeakMap<HtmlWebpackChildCompiler, boolean>>}}\n */\n\n\nconst hasOutdatedCompilationDependenciesMap = new WeakMap();\n/**\n * Returns `true` if the file dependencies of the current childCompiler\n * for the given mainCompilation are outdated.\n *\n * Uses the `hasOutdatedCompilationDependenciesMap` cache if possible.\n *\n * @param {WebpackCompilation} mainCompilation\n * @returns {boolean}\n */\n\nfunction hasOutDatedTemplateCache(mainCompilation) {\n  const childCompiler = getChildCompiler(mainCompilation.compiler);\n  /**\n   * @type {WeakMap<HtmlWebpackChildCompiler, boolean>|undefined}\n   */\n\n  let hasOutdatedChildCompilerDependenciesMap = hasOutdatedCompilationDependenciesMap.get(mainCompilation); // Create map for childCompiler if none exist\n\n  if (!hasOutdatedChildCompilerDependenciesMap) {\n    hasOutdatedChildCompilerDependenciesMap = new WeakMap();\n    hasOutdatedCompilationDependenciesMap.set(mainCompilation, hasOutdatedChildCompilerDependenciesMap);\n  } // Try to get the `checkChildCompilerCache` result from cache\n\n\n  let isOutdated = hasOutdatedChildCompilerDependenciesMap.get(childCompiler);\n\n  if (isOutdated !== undefined) {\n    return isOutdated;\n  } // If `checkChildCompilerCache` has never been called for the given\n  // `mainCompilation` and `childCompiler` combination call it:\n\n\n  isOutdated = isChildCompilerCacheOutdated(mainCompilation, childCompiler);\n  hasOutdatedChildCompilerDependenciesMap.set(childCompiler, isOutdated);\n  return isOutdated;\n}\n/**\n * Returns `true` if the file dependencies of the given childCompiler are outdated.\n *\n * @param {WebpackCompilation} mainCompilation\n * @param {HtmlWebpackChildCompiler} childCompiler\n * @returns {boolean}\n */\n\n\nfunction isChildCompilerCacheOutdated(mainCompilation, childCompiler) {\n  // If the compilation was never run there is no invalid cache\n  if (!childCompiler.compilationStartedTimestamp) {\n    return false;\n  } // Check if any dependent file was changed after the last compilation\n\n\n  const fileTimestamps = mainCompilation.fileTimestamps;\n  const isCacheOutOfDate = childCompiler.fileDependencies.some(fileDependency => {\n    const timestamp = fileTimestamps.get(fileDependency); // If the timestamp is not known the file is new\n    // If the timestamp is larger then the file has changed\n    // Otherwise the file is still the same\n\n    return !timestamp || timestamp > childCompiler.compilationStartedTimestamp;\n  });\n  return isCacheOutOfDate;\n}\n\nmodule.exports = {\n  addTemplateToCompiler,\n  compileTemplate,\n  hasOutDatedTemplateCache,\n  clearCache,\n  getFileDependencies\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/html-webpack-plugin/lib/compiler.js"],"names":["NodeTemplatePlugin","require","NodeTargetPlugin","LoaderTargetPlugin","LibraryTemplatePlugin","SingleEntryPlugin","HtmlWebpackChildCompiler","constructor","templates","compilationPromise","compilationStartedTimestamp","compilationEndedTimestamp","fileDependencies","addTemplate","template","templateId","indexOf","isCompiling","Error","push","didCompile","undefined","compileTemplates","mainCompilation","outputOptions","filename","publicPath","compilerName","childCompiler","createChildCompiler","context","compiler","apply","forEach","index","Date","getTime","Promise","resolve","reject","runAsChild","err","entries","childCompilation","compiledTemplates","extractHelperFilesFromCompilation","Array","from","errors","length","errorDetails","map","error","message","join","result","templateSource","entryIndex","content","hash","entry","childEntryChunks","helperAssetNames","entryChunk","mainTemplate","getAssetPath","chunk","name","helperFileName","assets","helperContents","source","childCompilerCache","WeakMap","getChildCompiler","mainCompiler","cachedChildCompiler","get","newCompiler","set","clearCache","delete","addTemplateToCompiler","templatePath","isNew","compileTemplate","outputFilename","then","console","log","Object","keys","compiledTemplate","outputName","getFileDependencies","hasOutdatedCompilationDependenciesMap","hasOutDatedTemplateCache","hasOutdatedChildCompilerDependenciesMap","isOutdated","isChildCompilerCacheOutdated","fileTimestamps","isCacheOutOfDate","some","fileDependency","timestamp","module","exports"],"mappings":"AAAA;;AACA;;AACA;;AACA;AACA;AACA;;;;;;;;AAOA;;AACA,MAAMA,kBAAkB,GAAGC,OAAO,CAAC,qCAAD,CAAlC;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,mCAAD,CAAhC;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,gCAAD,CAAlC;;AACA,MAAMG,qBAAqB,GAAGH,OAAO,CAAC,mCAAD,CAArC;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,+BAAD,CAAjC;AAEA;;;;;;AAIA,MAAMK,wBAAN,CAA+B;AAC7BC,EAAAA,WAAW,GAAI;AACb;;;;AAIA,SAAKC,SAAL,GAAiB,EAAjB;AACA;;;;AAGA,SAAKC,kBAAL,CATa,CASY;;AACzB;;;;AAGA,SAAKC,2BAAL,CAba,CAaqB;;AAClC;;;;AAGA,SAAKC,yBAAL,CAjBa,CAiBmB;;AAChC;;;;;AAIA,SAAKC,gBAAL,GAAwB,EAAxB;AACD;AAED;;;;;;;;AAMAC,EAAAA,WAAW,CAAEC,QAAF,EAAY;AACrB,UAAMC,UAAU,GAAG,KAAKP,SAAL,CAAeQ,OAAf,CAAuBF,QAAvB,CAAnB,CADqB,CAErB;;AACA,QAAIC,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB,aAAO,KAAP;AACD,KALoB,CAMrB;AACA;;;AACA,QAAI,KAAKE,WAAL,EAAJ,EAAwB;AACtB,YAAM,IAAIC,KAAJ,CAAU,uEAAV,CAAN;AACD,KAVoB,CAWrB;;;AACA,SAAKV,SAAL,CAAeW,IAAf,CAAoBL,QAApB,EAZqB,CAarB;;AACA,WAAO,IAAP;AACD;AAED;;;;;;AAIAG,EAAAA,WAAW,GAAI;AACb,WAAO,CAAC,KAAKG,UAAL,EAAD,IAAsB,KAAKV,2BAAL,KAAqCW,SAAlE;AACD;AAED;;;;;AAGAD,EAAAA,UAAU,GAAI;AACZ,WAAO,KAAKT,yBAAL,KAAmCU,SAA1C;AACD;AAED;;;;;;;;;AAOAC,EAAAA,gBAAgB,CAAEC,eAAF,EAAmB;AACjC;AACA;AACA;AACA,QAAI,KAAKd,kBAAT,EAA6B;AAC3B,aAAO,KAAKA,kBAAZ;AACD,KANgC,CAQjC;AACA;;;AACA,UAAMe,aAAa,GAAG;AACpBC,MAAAA,QAAQ,EAAE,gBADU;AAEpBC,MAAAA,UAAU,EAAEH,eAAe,CAACC,aAAhB,CAA8BE;AAFtB,KAAtB;AAIA,UAAMC,YAAY,GAAG,qBAArB,CAdiC,CAejC;AACA;AACA;;AACA,UAAMC,aAAa,GAAGL,eAAe,CAACM,mBAAhB,CAAoCF,YAApC,EAAkDH,aAAlD,CAAtB,CAlBiC,CAmBjC;;AACAI,IAAAA,aAAa,CAACE,OAAd,GAAwBP,eAAe,CAACQ,QAAhB,CAAyBD,OAAjD,CApBiC,CAqBjC;;AACA,QAAI9B,kBAAJ,CAAuBwB,aAAvB,EAAsCQ,KAAtC,CAA4CJ,aAA5C;AACA,QAAI1B,gBAAJ,GAAuB8B,KAAvB,CAA6BJ,aAA7B;AACA,QAAIxB,qBAAJ,CAA0B,4BAA1B,EAAwD,KAAxD,EAA+D4B,KAA/D,CAAqEJ,aAArE;AACA,QAAIzB,kBAAJ,CAAuB,MAAvB,EAA+B6B,KAA/B,CAAqCJ,aAArC,EAzBiC,CA2BjC;;AACA,SAAKpB,SAAL,CAAeyB,OAAf,CAAuB,CAACnB,QAAD,EAAWoB,KAAX,KAAqB;AAC1C,UAAI7B,iBAAJ,CAAsBuB,aAAa,CAACE,OAApC,EAA6ChB,QAA7C,EAAwD,qBAAoBoB,KAAM,EAAlF,EAAqFF,KAArF,CAA2FJ,aAA3F;AACD,KAFD;AAIA,SAAKlB,2BAAL,GAAmC,IAAIyB,IAAJ,GAAWC,OAAX,EAAnC;AACA,SAAK3B,kBAAL,GAA0B,IAAI4B,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACzDX,MAAAA,aAAa,CAACY,UAAd,CAAyB,CAACC,GAAD,EAAMC,OAAN,EAAeC,gBAAf,KAAoC;AAC3D;AACA,cAAMC,iBAAiB,GAAGF,OAAO,GAC7BG,iCAAiC,CAACtB,eAAD,EAAkBoB,gBAAlB,EAAoCnB,aAAa,CAACC,QAAlD,EAA4DiB,OAA5D,CADJ,GAE7B,EAFJ,CAF2D,CAK3D;;AACA,YAAIA,OAAJ,EAAa;AACX,eAAK9B,gBAAL,GAAwBkC,KAAK,CAACC,IAAN,CAAWJ,gBAAgB,CAAC/B,gBAA5B,CAAxB;AACD,SAR0D,CAS3D;;;AACA,YAAI+B,gBAAgB,IAAIA,gBAAgB,CAACK,MAArC,IAA+CL,gBAAgB,CAACK,MAAjB,CAAwBC,MAA3E,EAAmF;AACjF,gBAAMC,YAAY,GAAGP,gBAAgB,CAACK,MAAjB,CAAwBG,GAAxB,CAA4BC,KAAK,IAAIA,KAAK,CAACC,OAAN,IAAiBD,KAAK,CAACA,KAAN,GAAc,QAAQA,KAAK,CAACA,KAA5B,GAAoC,EAArD,CAArC,EAA+FE,IAA/F,CAAoG,IAApG,CAArB;AACAf,UAAAA,MAAM,CAAC,IAAIrB,KAAJ,CAAU,gCAAgCgC,YAA1C,CAAD,CAAN;AACA;AACD,SAd0D,CAe3D;;;AACA,YAAIT,GAAJ,EAAS;AACPF,UAAAA,MAAM,CAACE,GAAD,CAAN;AACA;AACD;AACD;;;;;AAGA,cAAMc,MAAM,GAAG,EAAf;AACAX,QAAAA,iBAAiB,CAACX,OAAlB,CAA0B,CAACuB,cAAD,EAAiBC,UAAjB,KAAgC;AACxD;AACA;AACA;AACAF,UAAAA,MAAM,CAAC,KAAK/C,SAAL,CAAeiD,UAAf,CAAD,CAAN,GAAqC;AACnCC,YAAAA,OAAO,EAAEF,cAD0B;AAEnCG,YAAAA,IAAI,EAAEhB,gBAAgB,CAACgB,IAFY;AAGnCC,YAAAA,KAAK,EAAElB,OAAO,CAACe,UAAD;AAHqB,WAArC;AAKD,SATD;AAUA,aAAK9C,yBAAL,GAAiC,IAAIwB,IAAJ,GAAWC,OAAX,EAAjC;AACAE,QAAAA,OAAO,CAACiB,MAAD,CAAP;AACD,OApCD;AAqCD,KAtCyB,CAA1B;AAwCA,WAAO,KAAK9C,kBAAZ;AACD;;AAjJ4B;AAoJ/B;;;;;;;;;;AAQA,SAASoC,iCAAT,CAA4CtB,eAA5C,EAA6DoB,gBAA7D,EAA+ElB,QAA/E,EAAyFoC,gBAAzF,EAA2G;AACzG,QAAMC,gBAAgB,GAAGD,gBAAgB,CAACV,GAAjB,CAAqB,CAACY,UAAD,EAAa7B,KAAb,KAAuB;AACnE,WAAOX,eAAe,CAACyC,YAAhB,CAA6BC,YAA7B,CAA0CxC,QAA1C,EAAoD;AACzDkC,MAAAA,IAAI,EAAEhB,gBAAgB,CAACgB,IADkC;AAEzDO,MAAAA,KAAK,EAAEH,UAFkD;AAGzDI,MAAAA,IAAI,EAAG,qBAAoBjC,KAAM;AAHwB,KAApD,CAAP;AAKD,GANwB,CAAzB;AAQA4B,EAAAA,gBAAgB,CAAC7B,OAAjB,CAA0BmC,cAAD,IAAoB;AAC3C,WAAO7C,eAAe,CAAC8C,MAAhB,CAAuBD,cAAvB,CAAP;AACD,GAFD;AAIA,QAAME,cAAc,GAAGR,gBAAgB,CAACX,GAAjB,CAAsBiB,cAAD,IAAoB;AAC9D,WAAOzB,gBAAgB,CAAC0B,MAAjB,CAAwBD,cAAxB,EAAwCG,MAAxC,EAAP;AACD,GAFsB,CAAvB;AAIA,SAAOD,cAAP;AACD;AAED;;;;;AAGA,MAAME,kBAAkB,GAAG,IAAIC,OAAJ,EAA3B;AAEA;;;;;;AAKA,SAASC,gBAAT,CAA2BC,YAA3B,EAAyC;AACvC,QAAMC,mBAAmB,GAAGJ,kBAAkB,CAACK,GAAnB,CAAuBF,YAAvB,CAA5B;;AACA,MAAIC,mBAAJ,EAAyB;AACvB,WAAOA,mBAAP;AACD;;AACD,QAAME,WAAW,GAAG,IAAIxE,wBAAJ,EAApB;AACAkE,EAAAA,kBAAkB,CAACO,GAAnB,CAAuBJ,YAAvB,EAAqCG,WAArC;AACA,SAAOA,WAAP;AACD;AAED;;;;;;;AAKA,SAASE,UAAT,CAAqBL,YAArB,EAAmC;AACjC,QAAM/C,aAAa,GAAG8C,gBAAgB,CAACC,YAAD,CAAtC,CADiC,CAEjC;AACA;;AACA,MAAI/C,aAAa,CAACX,WAAd,MAA+BW,aAAa,CAACR,UAAd,EAAnC,EAA+D;AAC7DoD,IAAAA,kBAAkB,CAACS,MAAnB,CAA0BN,YAA1B;AACD;AACF;AAED;;;;;;;AAKA,SAASO,qBAAT,CAAgCP,YAAhC,EAA8CQ,YAA9C,EAA4D;AAC1D,QAAMvD,aAAa,GAAG8C,gBAAgB,CAACC,YAAD,CAAtC;AACA,QAAMS,KAAK,GAAGxD,aAAa,CAACf,WAAd,CAA0BsE,YAA1B,CAAd;;AACA,MAAIC,KAAJ,EAAW;AACTJ,IAAAA,UAAU,CAACL,YAAD,CAAV;AACD;AACF;AAED;;;;;;;;;;;;;AAWA,SAASU,eAAT,CAA0BF,YAA1B,EAAwCG,cAAxC,EAAwD/D,eAAxD,EAAyE;AACvE,QAAMK,aAAa,GAAG8C,gBAAgB,CAACnD,eAAe,CAACQ,QAAjB,CAAtC;AACA,SAAOH,aAAa,CAACN,gBAAd,CAA+BC,eAA/B,EAAgDgE,IAAhD,CAAsD3C,iBAAD,IAAuB;AACjF,QAAI,CAACA,iBAAiB,CAACuC,YAAD,CAAtB,EAAsCK,OAAO,CAACC,GAAR,CAAYC,MAAM,CAACC,IAAP,CAAY/C,iBAAZ,CAAZ,EAA4CuC,YAA5C;AACtC,UAAMS,gBAAgB,GAAGhD,iBAAiB,CAACuC,YAAD,CAA1C,CAFiF,CAGjF;;AACA,UAAMU,UAAU,GAAGtE,eAAe,CAACyC,YAAhB,CAA6BC,YAA7B,CAA0CqB,cAA1C,EAA0D;AAC3E3B,MAAAA,IAAI,EAAEiC,gBAAgB,CAACjC,IADoD;AAE3EO,MAAAA,KAAK,EAAE0B,gBAAgB,CAAChC;AAFmD,KAA1D,CAAnB;AAIA,WAAO;AACL;AACAD,MAAAA,IAAI,EAAEiC,gBAAgB,CAACjC,IAFlB;AAGL;AACAkC,MAAAA,UAAU,EAAEA,UAJP;AAKL;AACAnC,MAAAA,OAAO,EAAEkC,gBAAgB,CAAClC;AANrB,KAAP;AAQD,GAhBM,CAAP;AAiBD;AAED;;;;;;;;AAMA,SAASoC,mBAAT,CAA8B/D,QAA9B,EAAwC;AACtC,QAAMH,aAAa,GAAG8C,gBAAgB,CAAC3C,QAAD,CAAtC;AACA,SAAOH,aAAa,CAAChB,gBAArB;AACD;AAED;;;;;AAGA,MAAMmF,qCAAqC,GAAG,IAAItB,OAAJ,EAA9C;AACA;;;;;;;;;;AASA,SAASuB,wBAAT,CAAmCzE,eAAnC,EAAoD;AAClD,QAAMK,aAAa,GAAG8C,gBAAgB,CAACnD,eAAe,CAACQ,QAAjB,CAAtC;AACA;;;;AAGA,MAAIkE,uCAAuC,GAAGF,qCAAqC,CAAClB,GAAtC,CAA0CtD,eAA1C,CAA9C,CALkD,CAMlD;;AACA,MAAI,CAAC0E,uCAAL,EAA8C;AAC5CA,IAAAA,uCAAuC,GAAG,IAAIxB,OAAJ,EAA1C;AACAsB,IAAAA,qCAAqC,CAAChB,GAAtC,CAA0CxD,eAA1C,EAA2D0E,uCAA3D;AACD,GAViD,CAWlD;;;AACA,MAAIC,UAAU,GAAGD,uCAAuC,CAACpB,GAAxC,CAA4CjD,aAA5C,CAAjB;;AACA,MAAIsE,UAAU,KAAK7E,SAAnB,EAA8B;AAC5B,WAAO6E,UAAP;AACD,GAfiD,CAgBlD;AACA;;;AACAA,EAAAA,UAAU,GAAGC,4BAA4B,CAAC5E,eAAD,EAAkBK,aAAlB,CAAzC;AACAqE,EAAAA,uCAAuC,CAAClB,GAAxC,CAA4CnD,aAA5C,EAA2DsE,UAA3D;AACA,SAAOA,UAAP;AACD;AAED;;;;;;;;;AAOA,SAASC,4BAAT,CAAuC5E,eAAvC,EAAwDK,aAAxD,EAAuE;AACrE;AACA,MAAI,CAACA,aAAa,CAAClB,2BAAnB,EAAgD;AAC9C,WAAO,KAAP;AACD,GAJoE,CAKrE;;;AACA,QAAM0F,cAAc,GAAG7E,eAAe,CAAC6E,cAAvC;AACA,QAAMC,gBAAgB,GAAGzE,aAAa,CAAChB,gBAAd,CAA+B0F,IAA/B,CAAqCC,cAAD,IAAoB;AAC/E,UAAMC,SAAS,GAAGJ,cAAc,CAACvB,GAAf,CAAmB0B,cAAnB,CAAlB,CAD+E,CAE/E;AACA;AACA;;AACA,WAAO,CAACC,SAAD,IAAcA,SAAS,GAAG5E,aAAa,CAAClB,2BAA/C;AACD,GANwB,CAAzB;AAOA,SAAO2F,gBAAP;AACD;;AAEDI,MAAM,CAACC,OAAP,GAAiB;AACfxB,EAAAA,qBADe;AAEfG,EAAAA,eAFe;AAGfW,EAAAA,wBAHe;AAIfhB,EAAAA,UAJe;AAKfc,EAAAA;AALe,CAAjB","sourcesContent":["// @ts-check\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n/** @typedef {import(\"webpack/lib/Chunk.js\")} WebpackChunk */\n'use strict';\n/**\n * @file\n * This file uses webpack to compile a template with a child compiler.\n *\n * [TEMPLATE] -> [JAVASCRIPT]\n *\n */\n'use strict';\nconst NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');\nconst NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');\nconst LoaderTargetPlugin = require('webpack/lib/LoaderTargetPlugin');\nconst LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');\nconst SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');\n\n/**\n * The HtmlWebpackChildCompiler is a helper to allow resusing one childCompiler\n * for multile HtmlWebpackPlugin instances to improve the compilation performance.\n */\nclass HtmlWebpackChildCompiler {\n  constructor () {\n    /**\n     * @type {string[]} templateIds\n     * The template array will allow us to keep track which input generated which output\n     */\n    this.templates = [];\n    /**\n     * @type {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}\n     */\n    this.compilationPromise; // eslint-disable-line\n    /**\n     * @type {number}\n     */\n    this.compilationStartedTimestamp; // eslint-disable-line\n    /**\n     * @type {number}\n     */\n    this.compilationEndedTimestamp; // eslint-disable-line\n    /**\n     * All file dependencies of the child compiler\n     * @type {string[]}\n     */\n    this.fileDependencies = [];\n  }\n\n  /**\n   * Add a templatePath to the child compiler\n   * The given template will be compiled by `compileTemplates`\n   * @param {string} template - The webpack path to the template e.g. `'!!html-loader!index.html'`\n   * @returns {boolean} true if the template is new\n   */\n  addTemplate (template) {\n    const templateId = this.templates.indexOf(template);\n    // Don't add the template to the compiler if a similar template was already added\n    if (templateId !== -1) {\n      return false;\n    }\n    // A child compiler can compile only once\n    // throw an error if a new template is added after the compilation started\n    if (this.isCompiling()) {\n      throw new Error('New templates can only be added before `compileTemplates` was called.');\n    }\n    // Add the template to the childCompiler\n    this.templates.push(template);\n    // Mark the cache invalid\n    return true;\n  }\n\n  /**\n   * Returns true if the childCompiler is currently compiling\n   * @retuns {boolean}\n   */\n  isCompiling () {\n    return !this.didCompile() && this.compilationStartedTimestamp !== undefined;\n  }\n\n  /**\n   * Returns true if the childCOmpiler is done compiling\n   */\n  didCompile () {\n    return this.compilationEndedTimestamp !== undefined;\n  }\n\n  /**\n   * This function will start the template compilation\n   * once it is started no more templates can be added\n   *\n   * @param {WebpackCompilation} mainCompilation\n   * @returns {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}\n   */\n  compileTemplates (mainCompilation) {\n    // To prevent multiple compilations for the same template\n    // the compilation is cached in a promise.\n    // If it already exists return\n    if (this.compilationPromise) {\n      return this.compilationPromise;\n    }\n\n    // The entry file is just an empty helper as the dynamic template\n    // require is added in \"loader.js\"\n    const outputOptions = {\n      filename: '__child-[name]',\n      publicPath: mainCompilation.outputOptions.publicPath\n    };\n    const compilerName = 'HtmlWebpackCompiler';\n    // Create an additional child compiler which takes the template\n    // and turns it into an Node.JS html factory.\n    // This allows us to use loaders during the compilation\n    const childCompiler = mainCompilation.createChildCompiler(compilerName, outputOptions);\n    // The file path context which webpack uses to resolve all relative files to\n    childCompiler.context = mainCompilation.compiler.context;\n    // Compile the template to nodejs javascript\n    new NodeTemplatePlugin(outputOptions).apply(childCompiler);\n    new NodeTargetPlugin().apply(childCompiler);\n    new LibraryTemplatePlugin('HTML_WEBPACK_PLUGIN_RESULT', 'var').apply(childCompiler);\n    new LoaderTargetPlugin('node').apply(childCompiler);\n\n    // Add all templates\n    this.templates.forEach((template, index) => {\n      new SingleEntryPlugin(childCompiler.context, template, `HtmlWebpackPlugin_${index}`).apply(childCompiler);\n    });\n\n    this.compilationStartedTimestamp = new Date().getTime();\n    this.compilationPromise = new Promise((resolve, reject) => {\n      childCompiler.runAsChild((err, entries, childCompilation) => {\n        // Extract templates\n        const compiledTemplates = entries\n          ? extractHelperFilesFromCompilation(mainCompilation, childCompilation, outputOptions.filename, entries)\n          : [];\n        // Extract file dependencies\n        if (entries) {\n          this.fileDependencies = Array.from(childCompilation.fileDependencies);\n        }\n        // Reject the promise if the childCompilation contains error\n        if (childCompilation && childCompilation.errors && childCompilation.errors.length) {\n          const errorDetails = childCompilation.errors.map(error => error.message + (error.error ? ':\\n' + error.error : '')).join('\\n');\n          reject(new Error('Child compilation failed:\\n' + errorDetails));\n          return;\n        }\n        // Reject if the error object contains errors\n        if (err) {\n          reject(err);\n          return;\n        }\n        /**\n         * @type {{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}}\n         */\n        const result = {};\n        compiledTemplates.forEach((templateSource, entryIndex) => {\n          // The compiledTemplates are generated from the entries added in\n          // the addTemplate function.\n          // Therefore the array index of this.templates should be the as entryIndex.\n          result[this.templates[entryIndex]] = {\n            content: templateSource,\n            hash: childCompilation.hash,\n            entry: entries[entryIndex]\n          };\n        });\n        this.compilationEndedTimestamp = new Date().getTime();\n        resolve(result);\n      });\n    });\n\n    return this.compilationPromise;\n  }\n}\n\n/**\n * The webpack child compilation will create files as a side effect.\n * This function will extract them and clean them up so they won't be written to disk.\n *\n * Returns the source code of the compiled templates as string\n *\n * @returns Array<string>\n */\nfunction extractHelperFilesFromCompilation (mainCompilation, childCompilation, filename, childEntryChunks) {\n  const helperAssetNames = childEntryChunks.map((entryChunk, index) => {\n    return mainCompilation.mainTemplate.getAssetPath(filename, {\n      hash: childCompilation.hash,\n      chunk: entryChunk,\n      name: `HtmlWebpackPlugin_${index}`\n    });\n  });\n\n  helperAssetNames.forEach((helperFileName) => {\n    delete mainCompilation.assets[helperFileName];\n  });\n\n  const helperContents = helperAssetNames.map((helperFileName) => {\n    return childCompilation.assets[helperFileName].source();\n  });\n\n  return helperContents;\n}\n\n/**\n * @type {WeakMap<WebpackCompiler, HtmlWebpackChildCompiler>}}\n */\nconst childCompilerCache = new WeakMap();\n\n/**\n * Get child compiler from cache or a new child compiler for the given mainCompilation\n *\n * @param {WebpackCompiler} mainCompiler\n */\nfunction getChildCompiler (mainCompiler) {\n  const cachedChildCompiler = childCompilerCache.get(mainCompiler);\n  if (cachedChildCompiler) {\n    return cachedChildCompiler;\n  }\n  const newCompiler = new HtmlWebpackChildCompiler();\n  childCompilerCache.set(mainCompiler, newCompiler);\n  return newCompiler;\n}\n\n/**\n * Remove the childCompiler from the cache\n *\n * @param {WebpackCompiler} mainCompiler\n */\nfunction clearCache (mainCompiler) {\n  const childCompiler = getChildCompiler(mainCompiler);\n  // If this childCompiler was already used\n  // remove the entire childCompiler from the cache\n  if (childCompiler.isCompiling() || childCompiler.didCompile()) {\n    childCompilerCache.delete(mainCompiler);\n  }\n}\n\n/**\n * Register a template for the current main compiler\n * @param {WebpackCompiler} mainCompiler\n * @param {string} templatePath\n */\nfunction addTemplateToCompiler (mainCompiler, templatePath) {\n  const childCompiler = getChildCompiler(mainCompiler);\n  const isNew = childCompiler.addTemplate(templatePath);\n  if (isNew) {\n    clearCache(mainCompiler);\n  }\n}\n\n/**\n * Starts the compilation for all templates.\n * This has to be called once all templates where added.\n *\n * If this function is called multiple times it will use a cache inside\n * the childCompiler\n *\n * @param {string} templatePath\n * @param {string} outputFilename\n * @param {WebpackCompilation} mainCompilation\n */\nfunction compileTemplate (templatePath, outputFilename, mainCompilation) {\n  const childCompiler = getChildCompiler(mainCompilation.compiler);\n  return childCompiler.compileTemplates(mainCompilation).then((compiledTemplates) => {\n    if (!compiledTemplates[templatePath]) console.log(Object.keys(compiledTemplates), templatePath);\n    const compiledTemplate = compiledTemplates[templatePath];\n    // Replace [hash] placeholders in filename\n    const outputName = mainCompilation.mainTemplate.getAssetPath(outputFilename, {\n      hash: compiledTemplate.hash,\n      chunk: compiledTemplate.entry\n    });\n    return {\n      // Hash of the template entry point\n      hash: compiledTemplate.hash,\n      // Output name\n      outputName: outputName,\n      // Compiled code\n      content: compiledTemplate.content\n    };\n  });\n}\n\n/**\n * Return all file dependencies of the last child compilation\n *\n * @param {WebpackCompiler} compiler\n * @returns {Array<string>}\n */\nfunction getFileDependencies (compiler) {\n  const childCompiler = getChildCompiler(compiler);\n  return childCompiler.fileDependencies;\n}\n\n/**\n * @type {WeakMap<WebpackCompilation, WeakMap<HtmlWebpackChildCompiler, boolean>>}}\n */\nconst hasOutdatedCompilationDependenciesMap = new WeakMap();\n/**\n * Returns `true` if the file dependencies of the current childCompiler\n * for the given mainCompilation are outdated.\n *\n * Uses the `hasOutdatedCompilationDependenciesMap` cache if possible.\n *\n * @param {WebpackCompilation} mainCompilation\n * @returns {boolean}\n */\nfunction hasOutDatedTemplateCache (mainCompilation) {\n  const childCompiler = getChildCompiler(mainCompilation.compiler);\n  /**\n   * @type {WeakMap<HtmlWebpackChildCompiler, boolean>|undefined}\n   */\n  let hasOutdatedChildCompilerDependenciesMap = hasOutdatedCompilationDependenciesMap.get(mainCompilation);\n  // Create map for childCompiler if none exist\n  if (!hasOutdatedChildCompilerDependenciesMap) {\n    hasOutdatedChildCompilerDependenciesMap = new WeakMap();\n    hasOutdatedCompilationDependenciesMap.set(mainCompilation, hasOutdatedChildCompilerDependenciesMap);\n  }\n  // Try to get the `checkChildCompilerCache` result from cache\n  let isOutdated = hasOutdatedChildCompilerDependenciesMap.get(childCompiler);\n  if (isOutdated !== undefined) {\n    return isOutdated;\n  }\n  // If `checkChildCompilerCache` has never been called for the given\n  // `mainCompilation` and `childCompiler` combination call it:\n  isOutdated = isChildCompilerCacheOutdated(mainCompilation, childCompiler);\n  hasOutdatedChildCompilerDependenciesMap.set(childCompiler, isOutdated);\n  return isOutdated;\n}\n\n/**\n * Returns `true` if the file dependencies of the given childCompiler are outdated.\n *\n * @param {WebpackCompilation} mainCompilation\n * @param {HtmlWebpackChildCompiler} childCompiler\n * @returns {boolean}\n */\nfunction isChildCompilerCacheOutdated (mainCompilation, childCompiler) {\n  // If the compilation was never run there is no invalid cache\n  if (!childCompiler.compilationStartedTimestamp) {\n    return false;\n  }\n  // Check if any dependent file was changed after the last compilation\n  const fileTimestamps = mainCompilation.fileTimestamps;\n  const isCacheOutOfDate = childCompiler.fileDependencies.some((fileDependency) => {\n    const timestamp = fileTimestamps.get(fileDependency);\n    // If the timestamp is not known the file is new\n    // If the timestamp is larger then the file has changed\n    // Otherwise the file is still the same\n    return !timestamp || timestamp > childCompiler.compilationStartedTimestamp;\n  });\n  return isCacheOutOfDate;\n}\n\nmodule.exports = {\n  addTemplateToCompiler,\n  compileTemplate,\n  hasOutDatedTemplateCache,\n  clearCache,\n  getFileDependencies\n};\n"]},"metadata":{},"sourceType":"script"}