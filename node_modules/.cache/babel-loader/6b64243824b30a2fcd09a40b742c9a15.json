{"ast":null,"code":"'use strict';\n/* eslint-disable\n  class-methods-use-this\n*/\n\nconst ws = require('ws');\n\nconst BaseServer = require('./BaseServer');\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  constructor(server) {\n    super(server);\n    this.wsServer = new ws.Server({\n      noServer: true,\n      path: this.server.sockPath\n    });\n    this.server.listeningApp.on('upgrade', (req, sock, head) => {\n      if (!this.wsServer.shouldHandle(req)) {\n        return;\n      }\n\n      this.wsServer.handleUpgrade(req, sock, head, connection => {\n        this.wsServer.emit('connection', connection, req);\n      });\n    });\n    this.wsServer.on('error', err => {\n      this.server.log.error(err.message);\n    });\n\n    const noop = () => {};\n\n    setInterval(() => {\n      this.wsServer.clients.forEach(ws => {\n        if (ws.isAlive === false) return ws.terminate();\n        ws.isAlive = false;\n        ws.ping(noop);\n      });\n    }, this.server.heartbeatInterval);\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.send(message);\n  }\n\n  close(connection) {\n    connection.close();\n  } // f should be passed the resulting connection and the connection headers\n\n\n  onConnection(f) {\n    this.wsServer.on('connection', (connection, req) => {\n      connection.isAlive = true;\n      connection.on('pong', () => {\n        connection.isAlive = true;\n      });\n      f(connection, req.headers);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/webpack-dev-server/lib/servers/WebsocketServer.js"],"names":["ws","require","BaseServer","module","exports","WebsocketServer","constructor","server","wsServer","Server","noServer","path","sockPath","listeningApp","on","req","sock","head","shouldHandle","handleUpgrade","connection","emit","err","log","error","message","noop","setInterval","clients","forEach","isAlive","terminate","ping","heartbeatInterval","send","readyState","close","onConnection","f","headers","onConnectionClose"],"mappings":"AAAA;AAEA;;;;AAGA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AAEAE,MAAM,CAACC,OAAP,GAAiB,MAAMC,eAAN,SAA8BH,UAA9B,CAAyC;AACxDI,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,UAAMA,MAAN;AACA,SAAKC,QAAL,GAAgB,IAAIR,EAAE,CAACS,MAAP,CAAc;AAC5BC,MAAAA,QAAQ,EAAE,IADkB;AAE5BC,MAAAA,IAAI,EAAE,KAAKJ,MAAL,CAAYK;AAFU,KAAd,CAAhB;AAKA,SAAKL,MAAL,CAAYM,YAAZ,CAAyBC,EAAzB,CAA4B,SAA5B,EAAuC,CAACC,GAAD,EAAMC,IAAN,EAAYC,IAAZ,KAAqB;AAC1D,UAAI,CAAC,KAAKT,QAAL,CAAcU,YAAd,CAA2BH,GAA3B,CAAL,EAAsC;AACpC;AACD;;AAED,WAAKP,QAAL,CAAcW,aAAd,CAA4BJ,GAA5B,EAAiCC,IAAjC,EAAuCC,IAAvC,EAA8CG,UAAD,IAAgB;AAC3D,aAAKZ,QAAL,CAAca,IAAd,CAAmB,YAAnB,EAAiCD,UAAjC,EAA6CL,GAA7C;AACD,OAFD;AAGD,KARD;AAUA,SAAKP,QAAL,CAAcM,EAAd,CAAiB,OAAjB,EAA2BQ,GAAD,IAAS;AACjC,WAAKf,MAAL,CAAYgB,GAAZ,CAAgBC,KAAhB,CAAsBF,GAAG,CAACG,OAA1B;AACD,KAFD;;AAIA,UAAMC,IAAI,GAAG,MAAM,CAAE,CAArB;;AAEAC,IAAAA,WAAW,CAAC,MAAM;AAChB,WAAKnB,QAAL,CAAcoB,OAAd,CAAsBC,OAAtB,CAA+B7B,EAAD,IAAQ;AACpC,YAAIA,EAAE,CAAC8B,OAAH,KAAe,KAAnB,EAA0B,OAAO9B,EAAE,CAAC+B,SAAH,EAAP;AAE1B/B,QAAAA,EAAE,CAAC8B,OAAH,GAAa,KAAb;AACA9B,QAAAA,EAAE,CAACgC,IAAH,CAAQN,IAAR;AACD,OALD;AAMD,KAPU,EAOR,KAAKnB,MAAL,CAAY0B,iBAPJ,CAAX;AAQD;;AAEDC,EAAAA,IAAI,CAACd,UAAD,EAAaK,OAAb,EAAsB;AACxB;AACA,QAAIL,UAAU,CAACe,UAAX,KAA0B,CAA9B,EAAiC;AAC/B;AACD;;AAEDf,IAAAA,UAAU,CAACc,IAAX,CAAgBT,OAAhB;AACD;;AAEDW,EAAAA,KAAK,CAAChB,UAAD,EAAa;AAChBA,IAAAA,UAAU,CAACgB,KAAX;AACD,GA7CuD,CA+CxD;;;AACAC,EAAAA,YAAY,CAACC,CAAD,EAAI;AACd,SAAK9B,QAAL,CAAcM,EAAd,CAAiB,YAAjB,EAA+B,CAACM,UAAD,EAAaL,GAAb,KAAqB;AAClDK,MAAAA,UAAU,CAACU,OAAX,GAAqB,IAArB;AACAV,MAAAA,UAAU,CAACN,EAAX,CAAc,MAAd,EAAsB,MAAM;AAC1BM,QAAAA,UAAU,CAACU,OAAX,GAAqB,IAArB;AACD,OAFD;AAGAQ,MAAAA,CAAC,CAAClB,UAAD,EAAaL,GAAG,CAACwB,OAAjB,CAAD;AACD,KAND;AAOD;;AAEDC,EAAAA,iBAAiB,CAACpB,UAAD,EAAakB,CAAb,EAAgB;AAC/BlB,IAAAA,UAAU,CAACN,EAAX,CAAc,OAAd,EAAuBwB,CAAvB;AACD;;AA5DuD,CAA1D","sourcesContent":["'use strict';\n\n/* eslint-disable\n  class-methods-use-this\n*/\nconst ws = require('ws');\nconst BaseServer = require('./BaseServer');\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  constructor(server) {\n    super(server);\n    this.wsServer = new ws.Server({\n      noServer: true,\n      path: this.server.sockPath,\n    });\n\n    this.server.listeningApp.on('upgrade', (req, sock, head) => {\n      if (!this.wsServer.shouldHandle(req)) {\n        return;\n      }\n\n      this.wsServer.handleUpgrade(req, sock, head, (connection) => {\n        this.wsServer.emit('connection', connection, req);\n      });\n    });\n\n    this.wsServer.on('error', (err) => {\n      this.server.log.error(err.message);\n    });\n\n    const noop = () => {};\n\n    setInterval(() => {\n      this.wsServer.clients.forEach((ws) => {\n        if (ws.isAlive === false) return ws.terminate();\n\n        ws.isAlive = false;\n        ws.ping(noop);\n      });\n    }, this.server.heartbeatInterval);\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.send(message);\n  }\n\n  close(connection) {\n    connection.close();\n  }\n\n  // f should be passed the resulting connection and the connection headers\n  onConnection(f) {\n    this.wsServer.on('connection', (connection, req) => {\n      connection.isAlive = true;\n      connection.on('pong', () => {\n        connection.isAlive = true;\n      });\n      f(connection, req.headers);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}