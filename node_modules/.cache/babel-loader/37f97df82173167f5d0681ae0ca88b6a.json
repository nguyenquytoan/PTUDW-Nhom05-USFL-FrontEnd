{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar punycode = require('punycode');\n\nvar queryString = require('query-string');\n\nvar prependHttp = require('prepend-http');\n\nvar sortKeys = require('sort-keys');\n\nvar objectAssign = require('object-assign');\n\nvar DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443,\n  'ftp:': 21\n}; // protocols that always contain a `//`` bit\n\nvar slashedProtocol = {\n  'http': true,\n  'https': true,\n  'ftp': true,\n  'gopher': true,\n  'file': true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\n\nfunction testParameter(name, filters) {\n  return filters.some(function (filter) {\n    return filter instanceof RegExp ? filter.test(name) : filter === name;\n  });\n}\n\nmodule.exports = function (str, opts) {\n  opts = objectAssign({\n    normalizeProtocol: true,\n    normalizeHttps: false,\n    stripFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeDirectoryIndex: false\n  }, opts);\n\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  var hasRelativeProtocol = str.indexOf('//') === 0; // prepend protocol\n\n  str = prependHttp(str.trim()).replace(/^\\/\\//, 'http://');\n  var urlObj = url.parse(str);\n\n  if (opts.normalizeHttps && urlObj.protocol === 'https:') {\n    urlObj.protocol = 'http:';\n  }\n\n  if (!urlObj.hostname && !urlObj.pathname) {\n    throw new Error('Invalid URL');\n  } // prevent these from being used by `url.format`\n\n\n  delete urlObj.host;\n  delete urlObj.query; // remove fragment\n\n  if (opts.stripFragment) {\n    delete urlObj.hash;\n  } // remove default port\n\n\n  var port = DEFAULT_PORTS[urlObj.protocol];\n\n  if (Number(urlObj.port) === port) {\n    delete urlObj.port;\n  } // remove duplicate slashes\n\n\n  if (urlObj.pathname) {\n    urlObj.pathname = urlObj.pathname.replace(/\\/{2,}/g, '/');\n  } // decode URI octets\n\n\n  if (urlObj.pathname) {\n    urlObj.pathname = decodeURI(urlObj.pathname);\n  } // remove directory index\n\n\n  if (opts.removeDirectoryIndex === true) {\n    opts.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n\n  if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length) {\n    var pathComponents = urlObj.pathname.split('/');\n    var lastComponent = pathComponents[pathComponents.length - 1];\n\n    if (testParameter(lastComponent, opts.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, pathComponents.length - 1);\n      urlObj.pathname = pathComponents.slice(1).join('/') + '/';\n    }\n  } // resolve relative paths, but only for slashed protocols\n\n\n  if (slashedProtocol[urlObj.protocol]) {\n    var domain = urlObj.protocol + '//' + urlObj.hostname;\n    var relative = url.resolve(domain, urlObj.pathname);\n    urlObj.pathname = relative.replace(domain, '');\n  }\n\n  if (urlObj.hostname) {\n    // IDN to Unicode\n    urlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase(); // remove trailing dot\n\n    urlObj.hostname = urlObj.hostname.replace(/\\.$/, ''); // remove `www.`\n\n    if (opts.stripWWW) {\n      urlObj.hostname = urlObj.hostname.replace(/^www\\./, '');\n    }\n  } // remove URL with empty query string\n\n\n  if (urlObj.search === '?') {\n    delete urlObj.search;\n  }\n\n  var queryParameters = queryString.parse(urlObj.search); // remove query unwanted parameters\n\n  if (Array.isArray(opts.removeQueryParameters)) {\n    for (var key in queryParameters) {\n      if (testParameter(key, opts.removeQueryParameters)) {\n        delete queryParameters[key];\n      }\n    }\n  } // sort query parameters\n\n\n  urlObj.search = queryString.stringify(sortKeys(queryParameters)); // decode query parameters\n\n  urlObj.search = decodeURIComponent(urlObj.search); // take advantage of many of the Node `url` normalizations\n\n  str = url.format(urlObj); // remove ending `/`\n\n  if (opts.removeTrailingSlash || urlObj.pathname === '/') {\n    str = str.replace(/\\/$/, '');\n  } // restore relative protocol, if applicable\n\n\n  if (hasRelativeProtocol && !opts.normalizeProtocol) {\n    str = str.replace(/^http:\\/\\//, '//');\n  }\n\n  return str;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/normalize-url/index.js"],"names":["url","require","punycode","queryString","prependHttp","sortKeys","objectAssign","DEFAULT_PORTS","slashedProtocol","testParameter","name","filters","some","filter","RegExp","test","module","exports","str","opts","normalizeProtocol","normalizeHttps","stripFragment","stripWWW","removeQueryParameters","removeTrailingSlash","removeDirectoryIndex","TypeError","hasRelativeProtocol","indexOf","trim","replace","urlObj","parse","protocol","hostname","pathname","Error","host","query","hash","port","Number","decodeURI","Array","isArray","length","pathComponents","split","lastComponent","slice","join","domain","relative","resolve","toUnicode","toLowerCase","search","queryParameters","key","stringify","decodeURIComponent","format"],"mappings":"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","sourcesContent":["'use strict';\nvar url = require('url');\nvar punycode = require('punycode');\nvar queryString = require('query-string');\nvar prependHttp = require('prepend-http');\nvar sortKeys = require('sort-keys');\nvar objectAssign = require('object-assign');\n\nvar DEFAULT_PORTS = {\n\t'http:': 80,\n\t'https:': 443,\n\t'ftp:': 21\n};\n\n// protocols that always contain a `//`` bit\nvar slashedProtocol = {\n\t'http': true,\n\t'https': true,\n\t'ftp': true,\n\t'gopher': true,\n\t'file': true,\n\t'http:': true,\n\t'https:': true,\n\t'ftp:': true,\n\t'gopher:': true,\n\t'file:': true\n};\n\nfunction testParameter(name, filters) {\n\treturn filters.some(function (filter) {\n\t\treturn filter instanceof RegExp ? filter.test(name) : filter === name;\n\t});\n}\n\nmodule.exports = function (str, opts) {\n\topts = objectAssign({\n\t\tnormalizeProtocol: true,\n\t\tnormalizeHttps: false,\n\t\tstripFragment: true,\n\t\tstripWWW: true,\n\t\tremoveQueryParameters: [/^utm_\\w+/i],\n\t\tremoveTrailingSlash: true,\n\t\tremoveDirectoryIndex: false\n\t}, opts);\n\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tvar hasRelativeProtocol = str.indexOf('//') === 0;\n\n\t// prepend protocol\n\tstr = prependHttp(str.trim()).replace(/^\\/\\//, 'http://');\n\n\tvar urlObj = url.parse(str);\n\n\tif (opts.normalizeHttps && urlObj.protocol === 'https:') {\n\t\turlObj.protocol = 'http:';\n\t}\n\n\tif (!urlObj.hostname && !urlObj.pathname) {\n\t\tthrow new Error('Invalid URL');\n\t}\n\n\t// prevent these from being used by `url.format`\n\tdelete urlObj.host;\n\tdelete urlObj.query;\n\n\t// remove fragment\n\tif (opts.stripFragment) {\n\t\tdelete urlObj.hash;\n\t}\n\n\t// remove default port\n\tvar port = DEFAULT_PORTS[urlObj.protocol];\n\tif (Number(urlObj.port) === port) {\n\t\tdelete urlObj.port;\n\t}\n\n\t// remove duplicate slashes\n\tif (urlObj.pathname) {\n\t\turlObj.pathname = urlObj.pathname.replace(/\\/{2,}/g, '/');\n\t}\n\n\t// decode URI octets\n\tif (urlObj.pathname) {\n\t\turlObj.pathname = decodeURI(urlObj.pathname);\n\t}\n\n\t// remove directory index\n\tif (opts.removeDirectoryIndex === true) {\n\t\topts.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n\t}\n\n\tif (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length) {\n\t\tvar pathComponents = urlObj.pathname.split('/');\n\t\tvar lastComponent = pathComponents[pathComponents.length - 1];\n\n\t\tif (testParameter(lastComponent, opts.removeDirectoryIndex)) {\n\t\t\tpathComponents = pathComponents.slice(0, pathComponents.length - 1);\n\t\t\turlObj.pathname = pathComponents.slice(1).join('/') + '/';\n\t\t}\n\t}\n\n\t// resolve relative paths, but only for slashed protocols\n\tif (slashedProtocol[urlObj.protocol]) {\n\t\tvar domain = urlObj.protocol + '//' + urlObj.hostname;\n\t\tvar relative = url.resolve(domain, urlObj.pathname);\n\t\turlObj.pathname = relative.replace(domain, '');\n\t}\n\n\tif (urlObj.hostname) {\n\t\t// IDN to Unicode\n\t\turlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase();\n\n\t\t// remove trailing dot\n\t\turlObj.hostname = urlObj.hostname.replace(/\\.$/, '');\n\n\t\t// remove `www.`\n\t\tif (opts.stripWWW) {\n\t\t\turlObj.hostname = urlObj.hostname.replace(/^www\\./, '');\n\t\t}\n\t}\n\n\t// remove URL with empty query string\n\tif (urlObj.search === '?') {\n\t\tdelete urlObj.search;\n\t}\n\n\tvar queryParameters = queryString.parse(urlObj.search);\n\n\t// remove query unwanted parameters\n\tif (Array.isArray(opts.removeQueryParameters)) {\n\t\tfor (var key in queryParameters) {\n\t\t\tif (testParameter(key, opts.removeQueryParameters)) {\n\t\t\t\tdelete queryParameters[key];\n\t\t\t}\n\t\t}\n\t}\n\n\t// sort query parameters\n\turlObj.search = queryString.stringify(sortKeys(queryParameters));\n\n\t// decode query parameters\n\turlObj.search = decodeURIComponent(urlObj.search);\n\n\t// take advantage of many of the Node `url` normalizations\n\tstr = url.format(urlObj);\n\n\t// remove ending `/`\n\tif (opts.removeTrailingSlash || urlObj.pathname === '/') {\n\t\tstr = str.replace(/\\/$/, '');\n\t}\n\n\t// restore relative protocol, if applicable\n\tif (hasRelativeProtocol && !opts.normalizeProtocol) {\n\t\tstr = str.replace(/^http:\\/\\//, '//');\n\t}\n\n\treturn str;\n};\n"]},"metadata":{},"sourceType":"script"}