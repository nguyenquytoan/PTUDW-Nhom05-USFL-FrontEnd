{"ast":null,"code":"var List = require('../common/List');\n\nvar SyntaxError = require('../common/SyntaxError');\n\nvar TokenStream = require('../common/TokenStream');\n\nvar Lexer = require('../lexer/Lexer');\n\nvar definitionSyntax = require('../definition-syntax');\n\nvar tokenize = require('../tokenizer');\n\nvar createParser = require('../parser/create');\n\nvar createGenerator = require('../generator/create');\n\nvar createConvertor = require('../convertor/create');\n\nvar createWalker = require('../walker/create');\n\nvar clone = require('../utils/clone');\n\nvar names = require('../utils/names');\n\nvar mix = require('./config/mix');\n\nfunction assign(dest, src) {\n  for (var key in src) {\n    dest[key] = src[key];\n  }\n\n  return dest;\n}\n\nfunction createSyntax(config) {\n  var parse = createParser(config);\n  var walk = createWalker(config);\n  var generate = createGenerator(config);\n  var convert = createConvertor(walk);\n  var syntax = {\n    List: List,\n    SyntaxError: SyntaxError,\n    TokenStream: TokenStream,\n    Lexer: Lexer,\n    vendorPrefix: names.vendorPrefix,\n    keyword: names.keyword,\n    property: names.property,\n    isCustomProperty: names.isCustomProperty,\n    definitionSyntax: definitionSyntax,\n    lexer: null,\n    createLexer: function (config) {\n      return new Lexer(config, syntax, syntax.lexer.structure);\n    },\n    tokenize: tokenize,\n    parse: parse,\n    walk: walk,\n    generate: generate,\n    find: walk.find,\n    findLast: walk.findLast,\n    findAll: walk.findAll,\n    clone: clone,\n    fromPlainObject: convert.fromPlainObject,\n    toPlainObject: convert.toPlainObject,\n    createSyntax: function (config) {\n      return createSyntax(mix({}, config));\n    },\n    fork: function (extension) {\n      var base = mix({}, config); // copy of config\n\n      return createSyntax(typeof extension === 'function' ? extension(base, assign) : mix(base, extension));\n    }\n  };\n  syntax.lexer = new Lexer({\n    generic: true,\n    types: config.types,\n    properties: config.properties,\n    node: config.node\n  }, syntax);\n  return syntax;\n}\n\n;\n\nexports.create = function (config) {\n  return createSyntax(mix({}, config));\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/css-tree/lib/syntax/create.js"],"names":["List","require","SyntaxError","TokenStream","Lexer","definitionSyntax","tokenize","createParser","createGenerator","createConvertor","createWalker","clone","names","mix","assign","dest","src","key","createSyntax","config","parse","walk","generate","convert","syntax","vendorPrefix","keyword","property","isCustomProperty","lexer","createLexer","structure","find","findLast","findAll","fromPlainObject","toPlainObject","fork","extension","base","generic","types","properties","node","exports","create"],"mappings":"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","sourcesContent":["var List = require('../common/List');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar Lexer = require('../lexer/Lexer');\nvar definitionSyntax = require('../definition-syntax');\nvar tokenize = require('../tokenizer');\nvar createParser = require('../parser/create');\nvar createGenerator = require('../generator/create');\nvar createConvertor = require('../convertor/create');\nvar createWalker = require('../walker/create');\nvar clone = require('../utils/clone');\nvar names = require('../utils/names');\nvar mix = require('./config/mix');\n\nfunction assign(dest, src) {\n    for (var key in src) {\n        dest[key] = src[key];\n    }\n\n    return dest;\n}\n\nfunction createSyntax(config) {\n    var parse = createParser(config);\n    var walk = createWalker(config);\n    var generate = createGenerator(config);\n    var convert = createConvertor(walk);\n\n    var syntax = {\n        List: List,\n        SyntaxError: SyntaxError,\n        TokenStream: TokenStream,\n        Lexer: Lexer,\n\n        vendorPrefix: names.vendorPrefix,\n        keyword: names.keyword,\n        property: names.property,\n        isCustomProperty: names.isCustomProperty,\n\n        definitionSyntax: definitionSyntax,\n        lexer: null,\n        createLexer: function(config) {\n            return new Lexer(config, syntax, syntax.lexer.structure);\n        },\n\n        tokenize: tokenize,\n        parse: parse,\n        walk: walk,\n        generate: generate,\n\n        find: walk.find,\n        findLast: walk.findLast,\n        findAll: walk.findAll,\n\n        clone: clone,\n        fromPlainObject: convert.fromPlainObject,\n        toPlainObject: convert.toPlainObject,\n\n        createSyntax: function(config) {\n            return createSyntax(mix({}, config));\n        },\n        fork: function(extension) {\n            var base = mix({}, config); // copy of config\n            return createSyntax(\n                typeof extension === 'function'\n                    ? extension(base, assign)\n                    : mix(base, extension)\n            );\n        }\n    };\n\n    syntax.lexer = new Lexer({\n        generic: true,\n        types: config.types,\n        properties: config.properties,\n        node: config.node\n    }, syntax);\n\n    return syntax;\n};\n\nexports.create = function(config) {\n    return createSyntax(mix({}, config));\n};\n"]},"metadata":{},"sourceType":"script"}