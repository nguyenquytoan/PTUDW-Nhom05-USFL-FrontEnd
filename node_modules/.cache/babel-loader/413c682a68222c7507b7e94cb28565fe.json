{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unused variables\",\n      category: \"Variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          }\n        }\n      }]\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n      }\n    }\n    /**\n     * Generate the warning message about the variable being\n     * defined and unused, including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {string} The warning message to be used with this unused variable.\n     */\n\n\n    function getDefinedMessage(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n\n      const additional = type ? ` Allowed unused ${type} must match ${pattern}.` : \"\";\n      return `'{{name}}' is defined but never used.${additional}`;\n    }\n    /**\n     * Generate the warning message about the variable being\n     * assigned and unused, including the ignore pattern if configured.\n     * @returns {string} The warning message to be used with this unused variable.\n     */\n\n\n    function getAssignedMessage() {\n      const additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : \"\";\n      return `'{{name}}' is assigned a value but never used.${additional}`;\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n\n    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n    /**\n     * Determines if a given variable is being exported from a module.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n\n    function isExported(variable) {\n      const definition = variable.defs[0];\n\n      if (definition) {\n        let node = definition.node;\n\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a variable has a sibling rest property\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n\n\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        return variable.defs.some(def => {\n          const propertyNode = def.name.parent;\n          const patternNode = propertyNode.parent;\n          return propertyNode.type === \"Property\" && patternNode.type === \"ObjectPattern\" && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);\n        });\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a reference is a read operation.\n     * @param {Reference} ref An eslint-scope Reference\n     * @returns {boolean} whether the given reference represents a read operation\n     * @private\n     */\n\n\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n    /**\n     * Determine if an identifier is referencing an enclosing function name.\n     * @param {Reference} ref The reference to check.\n     * @param {ASTNode[]} nodes The candidate function nodes.\n     * @returns {boolean} True if it's a self-reference, false if not.\n     * @private\n     */\n\n\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n\n      while (scope) {\n        if (nodes.indexOf(scope.block) >= 0) {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n    /**\n     * Gets a list of function definitions for a specified variable.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {ASTNode[]} Function nodes.\n     * @private\n     */\n\n\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def; // FunctionDeclarations\n\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        } // FunctionExpressions\n\n\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n    /**\n     * Checks the position of given nodes.\n     * @param {ASTNode} inner A node which is expected as inside.\n     * @param {ASTNode} outer A node which is expected as outside.\n     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n     * @private\n     */\n\n\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n    /**\n     * If a given reference is left-hand side of an assignment, this gets\n     * the right-hand side node of the assignment.\n     *\n     * In the following cases, this returns null.\n     *\n     * - The reference is not the LHS of an assignment expression.\n     * - The reference is inside of a loop.\n     * - The reference is inside of a function scope which is different from\n     *   the declaration.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} prevRhsNode The previous RHS node.\n     * @returns {ASTNode|null} The RHS node or null.\n     * @private\n     */\n\n\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const granpa = parent.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n      /*\n       * Inherits the previous node if this reference is in the node.\n       * This is for `a = a + a`-like code.\n       */\n\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n\n      if (parent.type === \"AssignmentExpression\" && granpa.type === \"ExpressionStatement\" && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n\n      return null;\n    }\n    /**\n     * Checks whether a given function node is stored to somewhere or not.\n     * If the function node is stored, the function can be used later.\n     * @param {ASTNode} funcNode A function node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if under the following conditions:\n     *      - the funcNode is assigned to a variable.\n     *      - the funcNode is bound as an argument of a function call.\n     *      - the function is bound to a property and the object satisfies above conditions.\n     * @private\n     */\n\n\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n\n            break;\n\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            if (STATEMENT_TYPE.test(parent.type)) {\n              /*\n               * If it encountered statements, this is a complex pattern.\n               * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.\n               */\n              return true;\n            }\n\n        }\n\n        node = parent;\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param {ASTNode} id An Identifier node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n     * @private\n     */\n\n\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n    /**\n     * Checks whether a given reference is a read to update itself or not.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} The reference is a read to update itself.\n     * @private\n     */\n\n\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const granpa = parent.parent;\n      return ref.isRead() && ( // self update. e.g. `a += 1`, `a++`\n      // in RHS of an assignment for itself. e.g. `a = a + 1`\n      parent.type === \"AssignmentExpression\" && granpa.type === \"ExpressionStatement\" && parent.left === id || parent.type === \"UpdateExpression\" && granpa.type === \"ExpressionStatement\" || rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n    /**\n     * Determine if an identifier is used either in for-in loops.\n     * @param {Reference} ref The reference to check.\n     * @returns {boolean} whether reference is used in the for-in loops\n     * @private\n     */\n\n\n    function isForInRef(ref) {\n      let target = ref.identifier.parent; // \"for (var ...) { return; }\"\n\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n\n      if (target.type !== \"ForInStatement\") {\n        return false;\n      } // \"for (...) { return; }\"\n\n\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0]; // \"for (...) return;\"\n      } else {\n        target = target.body;\n      } // For empty loop body\n\n\n      if (!target) {\n        return false;\n      }\n\n      return target.type === \"ReturnStatement\";\n    }\n    /**\n     * Determines if the variable is used.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} True if the variable is used\n     * @private\n     */\n\n\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n            isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInRef(ref)) {\n          return true;\n        }\n\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n    /**\n     * Checks whether the given variable is after the last used parameter.\n     * @param {eslint-scope.Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is defined after the last\n     * used parameter.\n     */\n\n\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = context.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1); // If any used parameters occur after this parameter, do not report.\n\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n    /**\n     * Gets an array of variables without read references.\n     * @param {Scope} scope an eslint-scope Scope object.\n     * @param {Variable[]} unusedVars an array that saving result.\n     * @returns {Variable[]} unused variables of the scope and descendant scopes.\n     * @private\n     */\n\n\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i]; // skip a variable of class itself name in the class scope\n\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          } // skip function expression names and variables marked with markVariableAsUsed()\n\n\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          } // skip implicit \"arguments\" variable\n\n\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          } // explicit global variables don't have definitions.\n\n\n          const def = variable.defs[0];\n\n          if (def) {\n            const type = def.type; // skip catch variables\n\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n\n            if (type === \"Parameter\") {\n              // skip any setter argument\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              } // if \"args\" option is \"none\", skip any parameter\n\n\n              if (config.args === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              } // if \"args\" option is \"after-used\", skip used variables\n\n\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              // skip ignored variables\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n\n      return unusedVars;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i]; // Report the first declaration.\n\n          if (unusedVar.defs.length > 0) {\n            context.report({\n              node: unusedVar.identifiers[0],\n              message: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessage() : getDefinedMessage(unusedVar),\n              data: unusedVar\n            }); // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              message: getDefinedMessage(unusedVar),\n              data: unusedVar\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-unused-vars.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","create","context","sourceCode","getSourceCode","REST_PROPERTY_TYPE","config","firstOption","options","RegExp","getDefinedMessage","unusedVar","defType","defs","pattern","toString","additional","getAssignedMessage","STATEMENT_TYPE","isExported","variable","definition","node","parent","indexOf","hasRestSpreadSibling","some","def","propertyNode","name","patternNode","test","length","isReadRef","ref","isRead","isSelfReference","nodes","scope","from","block","upper","getFunctionDefinitions","functionDefinitions","forEach","push","init","isInside","inner","outer","range","getRhsNode","prevRhsNode","id","identifier","granpa","refScope","variableScope","varScope","resolved","canBeUsedLater","isInLoop","left","right","isStorableFunction","funcNode","rhsNode","expressions","callee","isInsideOfStorableFunction","getUpperFunction","isReadForItself","isForInRef","target","body","isUsedVariable","functionNodes","isFunctionDefinition","references","forItself","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","v","eslintUsed","collectUnusedVariables","unusedVars","variables","childScopes","i","l","identifiers","functionExpressionScope","kind","isFunction","programNode","getScope","report","message","isWrite","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * defined and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {string} The warning message to be used with this unused variable.\n         */\n        function getDefinedMessage(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? ` Allowed unused ${type} must match ${pattern}.` : \"\";\n\n            return `'{{name}}' is defined but never used.${additional}`;\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @returns {string} The warning message to be used with this unused variable.\n         */\n        function getAssignedMessage() {\n            const additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : \"\";\n\n            return `'{{name}}' is assigned a value but never used.${additional}`;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                return variable.defs.some(def => {\n                    const propertyNode = def.name.parent;\n                    const patternNode = propertyNode.parent;\n\n                    return (\n                        propertyNode.type === \"Property\" &&\n                        patternNode.type === \"ObjectPattern\" &&\n                        REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type)\n                    );\n                });\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                granpa.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (// in RHS of an assignment for itself. e.g. `a = a + 1`\n                    ((\n                        parent.type === \"AssignmentExpression\" &&\n                    granpa.type === \"ExpressionStatement\" &&\n                    parent.left === id\n                    ) ||\n                (\n                    parent.type === \"UpdateExpression\" &&\n                    granpa.type === \"ExpressionStatement\"\n                ) || rhsNode &&\n                isInside(id, rhsNode) &&\n                !isInsideOfStorableFunction(id, rhsNode)))\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = context.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n                        context.report({\n                            node: unusedVar.identifiers[0],\n                            message: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessage()\n                                : getDefinedMessage(unusedVar),\n                            data: unusedVar\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            message: getDefinedMessage(unusedVar),\n                            data: unusedVar\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}