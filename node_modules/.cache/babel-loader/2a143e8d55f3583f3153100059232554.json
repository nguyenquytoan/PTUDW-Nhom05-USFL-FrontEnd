{"ast":null,"code":"/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce linebreaks after opening and before closing array brackets\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\"]\n      }, {\n        type: \"object\",\n        properties: {\n          multiline: {\n            type: \"boolean\"\n          },\n          minItems: {\n            type: [\"integer\", \"null\"],\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n      unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n      missingOpeningLinebreak: \"A linebreak is required after '['.\",\n      missingClosingLinebreak: \"A linebreak is required before ']'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} option An option value to parse.\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n     */\n\n    function normalizeOptionValue(option) {\n      let consistent = false;\n      let multiline = false;\n      let minItems = 0;\n\n      if (option) {\n        if (option === \"consistent\") {\n          consistent = true;\n          minItems = Number.POSITIVE_INFINITY;\n        } else if (option === \"always\" || option.minItems === 0) {\n          minItems = 0;\n        } else if (option === \"never\") {\n          minItems = Number.POSITIVE_INFINITY;\n        } else {\n          multiline = Boolean(option.multiline);\n          minItems = option.minItems || Number.POSITIVE_INFINITY;\n        }\n      } else {\n        consistent = false;\n        multiline = true;\n        minItems = Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} options An option value to parse.\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n     */\n\n\n    function normalizeOptions(options) {\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n    /**\n     * Reports that there shouldn't be a linebreak after the first token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportNoBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedOpeningLinebreak\",\n\n        fix(fixer) {\n          const nextToken = sourceCode.getTokenAfter(token, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(nextToken)) {\n            return null;\n          }\n\n          return fixer.removeRange([token.range[1], nextToken.range[0]]);\n        }\n\n      });\n    }\n    /**\n     * Reports that there shouldn't be a linebreak before the last token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportNoEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"unexpectedClosingLinebreak\",\n\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(token, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(previousToken)) {\n            return null;\n          }\n\n          return fixer.removeRange([previousToken.range[1], token.range[0]]);\n        }\n\n      });\n    }\n    /**\n     * Reports that there should be a linebreak after the first token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportRequiredBeginningLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingOpeningLinebreak\",\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, \"\\n\");\n        }\n\n      });\n    }\n    /**\n     * Reports that there should be a linebreak before the last token\n     * @param {ASTNode} node The node to report in the event of an error.\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportRequiredEndingLinebreak(node, token) {\n      context.report({\n        node,\n        loc: token.loc,\n        messageId: \"missingClosingLinebreak\",\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, \"\\n\");\n        }\n\n      });\n    }\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n      const openBracket = sourceCode.getFirstToken(node);\n      const closeBracket = sourceCode.getLastToken(node);\n      const firstIncComment = sourceCode.getTokenAfter(openBracket, {\n        includeComments: true\n      });\n      const lastIncComment = sourceCode.getTokenBefore(closeBracket, {\n        includeComments: true\n      });\n      const first = sourceCode.getTokenAfter(openBracket);\n      const last = sourceCode.getTokenBefore(closeBracket);\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === \"Block\" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;\n      /*\n       * Use tokens or comments to check multiline or not.\n       * But use only tokens to check whether linebreaks are needed.\n       * This allows:\n       *     var arr = [ // eslint-disable-line foo\n       *         'a'\n       *     ]\n       */\n\n      if (needsLinebreaks) {\n        if (astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportRequiredBeginningLinebreak(node, openBracket);\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportRequiredEndingLinebreak(node, closeBracket);\n        }\n      } else {\n        if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n          reportNoBeginningLinebreak(node, openBracket);\n        }\n\n        if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n          reportNoEndingLinebreak(node, closeBracket);\n        }\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/array-bracket-newline.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","messages","unexpectedOpeningLinebreak","unexpectedClosingLinebreak","missingOpeningLinebreak","missingClosingLinebreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","option","consistent","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","value","ArrayExpression","ArrayPattern","reportNoBeginningLinebreak","node","token","report","loc","messageId","fix","fixer","nextToken","getTokenAfter","includeComments","isCommentToken","removeRange","range","reportNoEndingLinebreak","previousToken","getTokenBefore","reportRequiredBeginningLinebreak","insertTextAfter","reportRequiredEndingLinebreak","insertTextBefore","check","elements","normalizedOptions","openBracket","getFirstToken","closeBracket","getLastToken","firstIncComment","lastIncComment","first","last","needsLinebreaks","length","start","line","end","isTokenOnSameLine"],"mappings":"AAAA;;;;AAKA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,oEADX;AAEFC,MAAAA,QAAQ,EAAE,kBAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,OAAO,EAAE,YAVP;AAYFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,KAAK,EAAE,CACH;AACIC,QAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,YAApB;AADV,OADG,EAIH;AACIT,QAAAA,IAAI,EAAE,QADV;AAEIU,QAAAA,UAAU,EAAE;AACRC,UAAAA,SAAS,EAAE;AACPX,YAAAA,IAAI,EAAE;AADC,WADH;AAIRY,UAAAA,QAAQ,EAAE;AACNZ,YAAAA,IAAI,EAAE,CAAC,SAAD,EAAY,MAAZ,CADA;AAENa,YAAAA,OAAO,EAAE;AAFH;AAJF,SAFhB;AAWIC,QAAAA,oBAAoB,EAAE;AAX1B,OAJG;AADX,KADI,CAZN;AAmCFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,0BAA0B,EAAE,yCADtB;AAENC,MAAAA,0BAA0B,EAAE,0CAFtB;AAGNC,MAAAA,uBAAuB,EAAE,oCAHnB;AAINC,MAAAA,uBAAuB,EAAE;AAJnB;AAnCR,GADO;;AA4CbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB,CADY,CAIZ;AACA;AACA;;AAEA;;;;;;AAKA,aAASC,oBAAT,CAA8BC,MAA9B,EAAsC;AAClC,UAAIC,UAAU,GAAG,KAAjB;AACA,UAAIf,SAAS,GAAG,KAAhB;AACA,UAAIC,QAAQ,GAAG,CAAf;;AAEA,UAAIa,MAAJ,EAAY;AACR,YAAIA,MAAM,KAAK,YAAf,EAA6B;AACzBC,UAAAA,UAAU,GAAG,IAAb;AACAd,UAAAA,QAAQ,GAAGe,MAAM,CAACC,iBAAlB;AACH,SAHD,MAGO,IAAIH,MAAM,KAAK,QAAX,IAAuBA,MAAM,CAACb,QAAP,KAAoB,CAA/C,EAAkD;AACrDA,UAAAA,QAAQ,GAAG,CAAX;AACH,SAFM,MAEA,IAAIa,MAAM,KAAK,OAAf,EAAwB;AAC3Bb,UAAAA,QAAQ,GAAGe,MAAM,CAACC,iBAAlB;AACH,SAFM,MAEA;AACHjB,UAAAA,SAAS,GAAGkB,OAAO,CAACJ,MAAM,CAACd,SAAR,CAAnB;AACAC,UAAAA,QAAQ,GAAGa,MAAM,CAACb,QAAP,IAAmBe,MAAM,CAACC,iBAArC;AACH;AACJ,OAZD,MAYO;AACHF,QAAAA,UAAU,GAAG,KAAb;AACAf,QAAAA,SAAS,GAAG,IAAZ;AACAC,QAAAA,QAAQ,GAAGe,MAAM,CAACC,iBAAlB;AACH;;AAED,aAAO;AAAEF,QAAAA,UAAF;AAAcf,QAAAA,SAAd;AAAyBC,QAAAA;AAAzB,OAAP;AACH;AAED;;;;;;;AAKA,aAASkB,gBAAT,CAA0BC,OAA1B,EAAmC;AAC/B,YAAMC,KAAK,GAAGR,oBAAoB,CAACO,OAAD,CAAlC;AAEA,aAAO;AAAEE,QAAAA,eAAe,EAAED,KAAnB;AAA0BE,QAAAA,YAAY,EAAEF;AAAxC,OAAP;AACH;AAED;;;;;;;;AAMA,aAASG,0BAAT,CAAoCC,IAApC,EAA0CC,KAA1C,EAAiD;AAC7ChB,MAAAA,OAAO,CAACiB,MAAR,CAAe;AACXF,QAAAA,IADW;AAEXG,QAAAA,GAAG,EAAEF,KAAK,CAACE,GAFA;AAGXC,QAAAA,SAAS,EAAE,4BAHA;;AAIXC,QAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,gBAAMC,SAAS,GAAGrB,UAAU,CAACsB,aAAX,CAAyBP,KAAzB,EAAgC;AAAEQ,YAAAA,eAAe,EAAE;AAAnB,WAAhC,CAAlB;;AAEA,cAAIlD,QAAQ,CAACmD,cAAT,CAAwBH,SAAxB,CAAJ,EAAwC;AACpC,mBAAO,IAAP;AACH;;AAED,iBAAOD,KAAK,CAACK,WAAN,CAAkB,CAACV,KAAK,CAACW,KAAN,CAAY,CAAZ,CAAD,EAAiBL,SAAS,CAACK,KAAV,CAAgB,CAAhB,CAAjB,CAAlB,CAAP;AACH;;AAZU,OAAf;AAcH;AAED;;;;;;;;AAMA,aAASC,uBAAT,CAAiCb,IAAjC,EAAuCC,KAAvC,EAA8C;AAC1ChB,MAAAA,OAAO,CAACiB,MAAR,CAAe;AACXF,QAAAA,IADW;AAEXG,QAAAA,GAAG,EAAEF,KAAK,CAACE,GAFA;AAGXC,QAAAA,SAAS,EAAE,4BAHA;;AAIXC,QAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,gBAAMQ,aAAa,GAAG5B,UAAU,CAAC6B,cAAX,CAA0Bd,KAA1B,EAAiC;AAAEQ,YAAAA,eAAe,EAAE;AAAnB,WAAjC,CAAtB;;AAEA,cAAIlD,QAAQ,CAACmD,cAAT,CAAwBI,aAAxB,CAAJ,EAA4C;AACxC,mBAAO,IAAP;AACH;;AAED,iBAAOR,KAAK,CAACK,WAAN,CAAkB,CAACG,aAAa,CAACF,KAAd,CAAoB,CAApB,CAAD,EAAyBX,KAAK,CAACW,KAAN,CAAY,CAAZ,CAAzB,CAAlB,CAAP;AACH;;AAZU,OAAf;AAcH;AAED;;;;;;;;AAMA,aAASI,gCAAT,CAA0ChB,IAA1C,EAAgDC,KAAhD,EAAuD;AACnDhB,MAAAA,OAAO,CAACiB,MAAR,CAAe;AACXF,QAAAA,IADW;AAEXG,QAAAA,GAAG,EAAEF,KAAK,CAACE,GAFA;AAGXC,QAAAA,SAAS,EAAE,yBAHA;;AAIXC,QAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,iBAAOA,KAAK,CAACW,eAAN,CAAsBhB,KAAtB,EAA6B,IAA7B,CAAP;AACH;;AANU,OAAf;AAQH;AAED;;;;;;;;AAMA,aAASiB,6BAAT,CAAuClB,IAAvC,EAA6CC,KAA7C,EAAoD;AAChDhB,MAAAA,OAAO,CAACiB,MAAR,CAAe;AACXF,QAAAA,IADW;AAEXG,QAAAA,GAAG,EAAEF,KAAK,CAACE,GAFA;AAGXC,QAAAA,SAAS,EAAE,yBAHA;;AAIXC,QAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,iBAAOA,KAAK,CAACa,gBAAN,CAAuBlB,KAAvB,EAA8B,IAA9B,CAAP;AACH;;AANU,OAAf;AAQH;AAED;;;;;;;AAKA,aAASmB,KAAT,CAAepB,IAAf,EAAqB;AACjB,YAAMqB,QAAQ,GAAGrB,IAAI,CAACqB,QAAtB;AACA,YAAMC,iBAAiB,GAAG5B,gBAAgB,CAACT,OAAO,CAACU,OAAR,CAAgB,CAAhB,CAAD,CAA1C;AACA,YAAMA,OAAO,GAAG2B,iBAAiB,CAACtB,IAAI,CAACpC,IAAN,CAAjC;AACA,YAAM2D,WAAW,GAAGrC,UAAU,CAACsC,aAAX,CAAyBxB,IAAzB,CAApB;AACA,YAAMyB,YAAY,GAAGvC,UAAU,CAACwC,YAAX,CAAwB1B,IAAxB,CAArB;AACA,YAAM2B,eAAe,GAAGzC,UAAU,CAACsB,aAAX,CAAyBe,WAAzB,EAAsC;AAAEd,QAAAA,eAAe,EAAE;AAAnB,OAAtC,CAAxB;AACA,YAAMmB,cAAc,GAAG1C,UAAU,CAAC6B,cAAX,CAA0BU,YAA1B,EAAwC;AAAEhB,QAAAA,eAAe,EAAE;AAAnB,OAAxC,CAAvB;AACA,YAAMoB,KAAK,GAAG3C,UAAU,CAACsB,aAAX,CAAyBe,WAAzB,CAAd;AACA,YAAMO,IAAI,GAAG5C,UAAU,CAAC6B,cAAX,CAA0BU,YAA1B,CAAb;AAEA,YAAMM,eAAe,GACjBV,QAAQ,CAACW,MAAT,IAAmBrC,OAAO,CAACnB,QAA3B,IAEImB,OAAO,CAACpB,SAAR,IACA8C,QAAQ,CAACW,MAAT,GAAkB,CADlB,IAEAL,eAAe,CAACxB,GAAhB,CAAoB8B,KAApB,CAA0BC,IAA1B,KAAmCN,cAAc,CAACzB,GAAf,CAAmBgC,GAAnB,CAAuBD,IAJ9D,IAOIb,QAAQ,CAACW,MAAT,KAAoB,CAApB,IACAL,eAAe,CAAC/D,IAAhB,KAAyB,OADzB,IAEA+D,eAAe,CAACxB,GAAhB,CAAoB8B,KAApB,CAA0BC,IAA1B,KAAmCN,cAAc,CAACzB,GAAf,CAAmBgC,GAAnB,CAAuBD,IAF1D,IAGAP,eAAe,KAAKC,cAVxB,IAaIjC,OAAO,CAACL,UAAR,IACAiC,WAAW,CAACpB,GAAZ,CAAgBgC,GAAhB,CAAoBD,IAApB,KAA6BL,KAAK,CAAC1B,GAAN,CAAU8B,KAAV,CAAgBC,IAfrD;AAmBA;;;;;;;;;AASA,UAAIH,eAAJ,EAAqB;AACjB,YAAIxE,QAAQ,CAAC6E,iBAAT,CAA2Bb,WAA3B,EAAwCM,KAAxC,CAAJ,EAAoD;AAChDb,UAAAA,gCAAgC,CAAChB,IAAD,EAAOuB,WAAP,CAAhC;AACH;;AACD,YAAIhE,QAAQ,CAAC6E,iBAAT,CAA2BN,IAA3B,EAAiCL,YAAjC,CAAJ,EAAoD;AAChDP,UAAAA,6BAA6B,CAAClB,IAAD,EAAOyB,YAAP,CAA7B;AACH;AACJ,OAPD,MAOO;AACH,YAAI,CAAClE,QAAQ,CAAC6E,iBAAT,CAA2Bb,WAA3B,EAAwCM,KAAxC,CAAL,EAAqD;AACjD9B,UAAAA,0BAA0B,CAACC,IAAD,EAAOuB,WAAP,CAA1B;AACH;;AACD,YAAI,CAAChE,QAAQ,CAAC6E,iBAAT,CAA2BN,IAA3B,EAAiCL,YAAjC,CAAL,EAAqD;AACjDZ,UAAAA,uBAAuB,CAACb,IAAD,EAAOyB,YAAP,CAAvB;AACH;AACJ;AACJ,KA7LW,CA+LZ;AACA;AACA;;;AAEA,WAAO;AACH3B,MAAAA,YAAY,EAAEsB,KADX;AAEHvB,MAAAA,eAAe,EAAEuB;AAFd,KAAP;AAIH;;AAnPY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce linebreaks after opening and before closing array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n            unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n            missingOpeningLinebreak: \"A linebreak is required after '['.\",\n            missingClosingLinebreak: \"A linebreak is required before ']'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} option An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let consistent = false;\n            let multiline = false;\n            let minItems = 0;\n\n            if (option) {\n                if (option === \"consistent\") {\n                    consistent = true;\n                    minItems = Number.POSITIVE_INFINITY;\n                } else if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                consistent = false;\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedOpeningLinebreak\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedClosingLinebreak\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingOpeningLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingClosingLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                ) ||\n                (\n                    elements.length === 0 &&\n                    firstIncComment.type === \"Block\" &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line &&\n                    firstIncComment === lastIncComment\n                ) ||\n                (\n                    options.consistent &&\n                    openBracket.loc.end.line !== first.loc.start.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}