{"ast":null,"code":"var hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar matchGraph = require('./match-graph');\n\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\n\nvar TYPE = require('../tokenizer/const').TYPE;\n\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\n\nfunction reverseList(list) {\n  var prev = null;\n  var next = null;\n  var item = list;\n\n  while (item !== null) {\n    next = item.prev;\n    item.prev = prev;\n    prev = item;\n    item = next;\n  }\n\n  return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n  if (testStr.length !== referenceStr.length) {\n    return false;\n  }\n\n  for (var i = 0; i < testStr.length; i++) {\n    var testCode = testStr.charCodeAt(i);\n    var referenceCode = referenceStr.charCodeAt(i); // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n\n    if (testCode >= 0x0041 && testCode <= 0x005A) {\n      testCode = testCode | 32;\n    }\n\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isCommaContextStart(token) {\n  if (token === null) {\n    return true;\n  }\n\n  return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || token.type === TYPE.Delim;\n}\n\nfunction isCommaContextEnd(token) {\n  if (token === null) {\n    return true;\n  }\n\n  return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n  function moveToNextToken() {\n    do {\n      tokenIndex++;\n      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n    } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n  }\n\n  function getNextToken(offset) {\n    var nextIndex = tokenIndex + offset;\n    return nextIndex < tokens.length ? tokens[nextIndex] : null;\n  }\n\n  function stateSnapshotFromSyntax(nextState, prev) {\n    return {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      thenStack: thenStack,\n      tokenIndex: tokenIndex,\n      prev: prev\n    };\n  }\n\n  function pushThenStack(nextState) {\n    thenStack = {\n      nextState: nextState,\n      matchStack: matchStack,\n      syntaxStack: syntaxStack,\n      prev: thenStack\n    };\n  }\n\n  function pushElseStack(nextState) {\n    elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n  }\n\n  function addTokenToMatch() {\n    matchStack = {\n      type: TOKEN,\n      syntax: state.syntax,\n      token: token,\n      prev: matchStack\n    };\n    moveToNextToken();\n    syntaxStash = null;\n\n    if (tokenIndex > longestMatch) {\n      longestMatch = tokenIndex;\n    }\n  }\n\n  function openSyntax() {\n    syntaxStack = {\n      syntax: state.syntax,\n      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,\n      prev: syntaxStack\n    };\n    matchStack = {\n      type: OPEN_SYNTAX,\n      syntax: state.syntax,\n      token: matchStack.token,\n      prev: matchStack\n    };\n  }\n\n  function closeSyntax() {\n    if (matchStack.type === OPEN_SYNTAX) {\n      matchStack = matchStack.prev;\n    } else {\n      matchStack = {\n        type: CLOSE_SYNTAX,\n        syntax: syntaxStack.syntax,\n        token: matchStack.token,\n        prev: matchStack\n      };\n    }\n\n    syntaxStack = syntaxStack.prev;\n  }\n\n  var syntaxStack = null;\n  var thenStack = null;\n  var elseStack = null; // null – stashing allowed, nothing stashed\n  // false – stashing disabled, nothing stashed\n  // anithing else – fail stashable syntaxes, some syntax stashed\n\n  var syntaxStash = null;\n  var iterationCount = 0; // count iterations and prevent infinite loop\n\n  var exitReason = null;\n  var token = null;\n  var tokenIndex = -1;\n  var longestMatch = 0;\n  var matchStack = {\n    type: STUB,\n    syntax: null,\n    token: null,\n    prev: null\n  };\n  moveToNextToken();\n\n  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n    // function mapList(list, fn) {\n    //     var result = [];\n    //     while (list) {\n    //         result.unshift(fn(list));\n    //         list = list.prev;\n    //     }\n    //     return result;\n    // }\n    // console.log('--\\n',\n    //     '#' + iterationCount,\n    //     require('util').inspect({\n    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n    //         token: token && token.value,\n    //         tokenIndex,\n    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n    //     }, { depth: null })\n    // );\n    switch (state.type) {\n      case 'Match':\n        if (thenStack === null) {\n          // turn to MISMATCH when some tokens left unmatched\n          if (token !== null) {\n            // doesn't mismatch if just one token left and it's an IE hack\n            if (tokenIndex !== tokens.length - 1 || token.value !== '\\\\0' && token.value !== '\\\\9') {\n              state = MISMATCH;\n              break;\n            }\n          } // break the main loop, return a result - MATCH\n\n\n          exitReason = EXIT_REASON_MATCH;\n          break;\n        } // go to next syntax (`then` branch)\n\n\n        state = thenStack.nextState; // check match is not empty\n\n        if (state === DISALLOW_EMPTY) {\n          if (thenStack.matchStack === matchStack) {\n            state = MISMATCH;\n            break;\n          } else {\n            state = MATCH;\n          }\n        } // close syntax if needed\n\n\n        while (thenStack.syntaxStack !== syntaxStack) {\n          closeSyntax();\n        } // pop stack\n\n\n        thenStack = thenStack.prev;\n        break;\n\n      case 'Mismatch':\n        // when some syntax is stashed\n        if (syntaxStash !== null && syntaxStash !== false) {\n          // there is no else branches or a branch reduce match stack\n          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n            // restore state from the stash\n            elseStack = syntaxStash;\n            syntaxStash = false; // disable stashing\n          }\n        } else if (elseStack === null) {\n          // no else branches -> break the main loop\n          // return a result - MISMATCH\n          exitReason = EXIT_REASON_MISMATCH;\n          break;\n        } // go to next syntax (`else` branch)\n\n\n        state = elseStack.nextState; // restore all the rest stack states\n\n        thenStack = elseStack.thenStack;\n        syntaxStack = elseStack.syntaxStack;\n        matchStack = elseStack.matchStack;\n        tokenIndex = elseStack.tokenIndex;\n        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null; // pop stack\n\n        elseStack = elseStack.prev;\n        break;\n\n      case 'MatchGraph':\n        state = state.match;\n        break;\n\n      case 'If':\n        // IMPORTANT: else stack push must go first,\n        // since it stores the state of thenStack before changes\n        if (state.else !== MISMATCH) {\n          pushElseStack(state.else);\n        }\n\n        if (state.then !== MATCH) {\n          pushThenStack(state.then);\n        }\n\n        state = state.match;\n        break;\n\n      case 'MatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state,\n          index: 0,\n          mask: 0\n        };\n        break;\n\n      case 'MatchOnceBuffer':\n        var terms = state.syntax.terms;\n\n        if (state.index === terms.length) {\n          // no matches at all or it's required all terms to be matched\n          if (state.mask === 0 || state.syntax.all) {\n            state = MISMATCH;\n            break;\n          } // a partial match is ok\n\n\n          state = MATCH;\n          break;\n        } // all terms are matched\n\n\n        if (state.mask === (1 << terms.length) - 1) {\n          state = MATCH;\n          break;\n        }\n\n        for (; state.index < terms.length; state.index++) {\n          var matchFlag = 1 << state.index;\n\n          if ((state.mask & matchFlag) === 0) {\n            // IMPORTANT: else stack push must go first,\n            // since it stores the state of thenStack before changes\n            pushElseStack(state);\n            pushThenStack({\n              type: 'AddMatchOnce',\n              syntax: state.syntax,\n              mask: state.mask | matchFlag\n            }); // match\n\n            state = terms[state.index++];\n            break;\n          }\n        }\n\n        break;\n\n      case 'AddMatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state.syntax,\n          index: 0,\n          mask: state.mask\n        };\n        break;\n\n      case 'Enum':\n        if (token !== null) {\n          var name = token.value.toLowerCase(); // drop \\0 and \\9 hack from keyword name\n\n          if (name.indexOf('\\\\') !== -1) {\n            name = name.replace(/\\\\[09].*$/, '');\n          }\n\n          if (hasOwnProperty.call(state.map, name)) {\n            state = state.map[name];\n            break;\n          }\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'Generic':\n        var opts = syntaxStack !== null ? syntaxStack.opts : null;\n        var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n        if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n\n        break;\n\n      case 'Type':\n      case 'Property':\n        var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n        var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n        if (!dictSyntax || !dictSyntax.match) {\n          throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\\'' + state.name + '\\'>'));\n        } // stash a syntax for types with low priority\n\n\n        if (syntaxStash !== false && token !== null && state.type === 'Type') {\n          var lowPriorityMatching = // https://drafts.csswg.org/css-values-4/#custom-idents\n          // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n          // can only claim the keyword if no other unfulfilled production can claim it.\n          state.name === 'custom-ident' && token.type === TYPE.Ident || // https://drafts.csswg.org/css-values-4/#lengths\n          // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n          // it must parse as a <number>\n          state.name === 'length' && token.value === '0';\n\n          if (lowPriorityMatching) {\n            if (syntaxStash === null) {\n              syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n            }\n\n            state = MISMATCH;\n            break;\n          }\n        }\n\n        openSyntax();\n        state = dictSyntax.match;\n        break;\n\n      case 'Keyword':\n        var name = state.name;\n\n        if (token !== null) {\n          var keywordName = token.value; // drop \\0 and \\9 hack from keyword name\n\n          if (keywordName.indexOf('\\\\') !== -1) {\n            keywordName = keywordName.replace(/\\\\[09].*$/, '');\n          }\n\n          if (areStringsEqualCaseInsensitive(keywordName, name)) {\n            addTokenToMatch();\n            state = MATCH;\n            break;\n          }\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'AtKeyword':\n      case 'Function':\n        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'Token':\n        if (token !== null && token.value === state.value) {\n          addTokenToMatch();\n          state = MATCH;\n          break;\n        }\n\n        state = MISMATCH;\n        break;\n\n      case 'Comma':\n        if (token !== null && token.type === TYPE.Comma) {\n          if (isCommaContextStart(matchStack.token)) {\n            state = MISMATCH;\n          } else {\n            addTokenToMatch();\n            state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n          }\n        } else {\n          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n        }\n\n        break;\n\n      case 'String':\n        var string = '';\n\n        for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n          string += tokens[lastTokenIndex].value;\n        }\n\n        if (areStringsEqualCaseInsensitive(string, state.value)) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n\n          state = MATCH;\n        } else {\n          state = MISMATCH;\n        }\n\n        break;\n\n      default:\n        throw new Error('Unknown node type: ' + state.type);\n    }\n  }\n\n  totalIterationCount += iterationCount;\n\n  switch (exitReason) {\n    case null:\n      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n      exitReason = EXIT_REASON_ITERATION_LIMIT;\n      matchStack = null;\n      break;\n\n    case EXIT_REASON_MATCH:\n      while (syntaxStack !== null) {\n        closeSyntax();\n      }\n\n      break;\n\n    default:\n      matchStack = null;\n  }\n\n  return {\n    tokens: tokens,\n    reason: exitReason,\n    iterations: iterationCount,\n    match: matchStack,\n    longestMatch: longestMatch\n  };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n  if (matchResult.match !== null) {\n    var item = reverseList(matchResult.match).prev;\n    matchResult.match = [];\n\n    while (item !== null) {\n      switch (item.type) {\n        case STUB:\n          break;\n\n        case OPEN_SYNTAX:\n        case CLOSE_SYNTAX:\n          matchResult.match.push({\n            type: item.type,\n            syntax: item.syntax\n          });\n          break;\n\n        default:\n          matchResult.match.push({\n            token: item.token.value,\n            node: item.token.node\n          });\n          break;\n      }\n\n      item = item.prev;\n    }\n  }\n\n  return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n  var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n  if (matchResult.match === null) {\n    return matchResult;\n  }\n\n  var item = matchResult.match;\n  var host = matchResult.match = {\n    syntax: matchGraph.syntax || null,\n    match: []\n  };\n  var hostStack = [host]; // revert a list and start with 2nd item since 1st is a stub item\n\n  item = reverseList(item).prev; // build a tree\n\n  while (item !== null) {\n    switch (item.type) {\n      case OPEN_SYNTAX:\n        host.match.push(host = {\n          syntax: item.syntax,\n          match: []\n        });\n        hostStack.push(host);\n        break;\n\n      case CLOSE_SYNTAX:\n        hostStack.pop();\n        host = hostStack[hostStack.length - 1];\n        break;\n\n      default:\n        host.match.push({\n          syntax: item.syntax || null,\n          token: item.token.value,\n          node: item.token.node\n        });\n    }\n\n    item = item.prev;\n  }\n\n  return matchResult;\n}\n\nmodule.exports = {\n  matchAsList: matchAsList,\n  matchAsTree: matchAsTree,\n  getTotalIterationCount: function () {\n    return totalIterationCount;\n  }\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/csso/node_modules/css-tree/lib/lexer/match.js"],"names":["hasOwnProperty","Object","prototype","matchGraph","require","MATCH","MISMATCH","DISALLOW_EMPTY","TYPE","STUB","TOKEN","OPEN_SYNTAX","CLOSE_SYNTAX","EXIT_REASON_MATCH","EXIT_REASON_MISMATCH","EXIT_REASON_ITERATION_LIMIT","ITERATION_LIMIT","totalIterationCount","reverseList","list","prev","next","item","areStringsEqualCaseInsensitive","testStr","referenceStr","length","i","testCode","charCodeAt","referenceCode","isCommaContextStart","token","type","Comma","Function","LeftParenthesis","LeftSquareBracket","LeftCurlyBracket","Delim","isCommaContextEnd","RightParenthesis","RightSquareBracket","RightCurlyBracket","internalMatch","tokens","state","syntaxes","moveToNextToken","tokenIndex","WhiteSpace","Comment","getNextToken","offset","nextIndex","stateSnapshotFromSyntax","nextState","matchStack","syntaxStack","thenStack","pushThenStack","pushElseStack","elseStack","addTokenToMatch","syntax","syntaxStash","longestMatch","openSyntax","opts","closeSyntax","iterationCount","exitReason","value","match","else","then","index","mask","terms","all","matchFlag","name","toLowerCase","indexOf","replace","call","map","lastTokenIndex","Math","floor","fn","isNaN","syntaxDict","dictSyntax","Error","lowPriorityMatching","Ident","keywordName","string","console","warn","reason","iterations","matchAsList","matchResult","push","node","matchAsTree","host","hostStack","pop","module","exports","getTotalIterationCount"],"mappings":"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","sourcesContent":["var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar matchGraph = require('./match-graph');\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\nvar TYPE = require('../tokenizer/const').TYPE;\n\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\n\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\n\nfunction reverseList(list) {\n    var prev = null;\n    var next = null;\n    var item = list;\n\n    while (item !== null) {\n        next = item.prev;\n        item.prev = prev;\n        prev = item;\n        item = next;\n    }\n\n    return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n    if (testStr.length !== referenceStr.length) {\n        return false;\n    }\n\n    for (var i = 0; i < testStr.length; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n        if (testCode >= 0x0041 && testCode <= 0x005A) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isCommaContextStart(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.Comma ||\n        token.type === TYPE.Function ||\n        token.type === TYPE.LeftParenthesis ||\n        token.type === TYPE.LeftSquareBracket ||\n        token.type === TYPE.LeftCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction isCommaContextEnd(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.RightParenthesis ||\n        token.type === TYPE.RightSquareBracket ||\n        token.type === TYPE.RightCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n    function moveToNextToken() {\n        do {\n            tokenIndex++;\n            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n    }\n\n    function getNextToken(offset) {\n        var nextIndex = tokenIndex + offset;\n\n        return nextIndex < tokens.length ? tokens[nextIndex] : null;\n    }\n\n    function stateSnapshotFromSyntax(nextState, prev) {\n        return {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            thenStack: thenStack,\n            tokenIndex: tokenIndex,\n            prev: prev\n        };\n    }\n\n    function pushThenStack(nextState) {\n        thenStack = {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            prev: thenStack\n        };\n    }\n\n    function pushElseStack(nextState) {\n        elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n    }\n\n    function addTokenToMatch() {\n        matchStack = {\n            type: TOKEN,\n            syntax: state.syntax,\n            token: token,\n            prev: matchStack\n        };\n\n        moveToNextToken();\n        syntaxStash = null;\n\n        if (tokenIndex > longestMatch) {\n            longestMatch = tokenIndex;\n        }\n    }\n\n    function openSyntax() {\n        syntaxStack = {\n            syntax: state.syntax,\n            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n            prev: syntaxStack\n        };\n\n        matchStack = {\n            type: OPEN_SYNTAX,\n            syntax: state.syntax,\n            token: matchStack.token,\n            prev: matchStack\n        };\n    }\n\n    function closeSyntax() {\n        if (matchStack.type === OPEN_SYNTAX) {\n            matchStack = matchStack.prev;\n        } else {\n            matchStack = {\n                type: CLOSE_SYNTAX,\n                syntax: syntaxStack.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        syntaxStack = syntaxStack.prev;\n    }\n\n    var syntaxStack = null;\n    var thenStack = null;\n    var elseStack = null;\n\n    // null – stashing allowed, nothing stashed\n    // false – stashing disabled, nothing stashed\n    // anithing else – fail stashable syntaxes, some syntax stashed\n    var syntaxStash = null;\n\n    var iterationCount = 0; // count iterations and prevent infinite loop\n    var exitReason = null;\n\n    var token = null;\n    var tokenIndex = -1;\n    var longestMatch = 0;\n    var matchStack = {\n        type: STUB,\n        syntax: null,\n        token: null,\n        prev: null\n    };\n\n    moveToNextToken();\n\n    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n        // function mapList(list, fn) {\n        //     var result = [];\n        //     while (list) {\n        //         result.unshift(fn(list));\n        //         list = list.prev;\n        //     }\n        //     return result;\n        // }\n        // console.log('--\\n',\n        //     '#' + iterationCount,\n        //     require('util').inspect({\n        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n        //         token: token && token.value,\n        //         tokenIndex,\n        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n        //     }, { depth: null })\n        // );\n        switch (state.type) {\n            case 'Match':\n                if (thenStack === null) {\n                    // turn to MISMATCH when some tokens left unmatched\n                    if (token !== null) {\n                        // doesn't mismatch if just one token left and it's an IE hack\n                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                            state = MISMATCH;\n                            break;\n                        }\n                    }\n\n                    // break the main loop, return a result - MATCH\n                    exitReason = EXIT_REASON_MATCH;\n                    break;\n                }\n\n                // go to next syntax (`then` branch)\n                state = thenStack.nextState;\n\n                // check match is not empty\n                if (state === DISALLOW_EMPTY) {\n                    if (thenStack.matchStack === matchStack) {\n                        state = MISMATCH;\n                        break;\n                    } else {\n                        state = MATCH;\n                    }\n                }\n\n                // close syntax if needed\n                while (thenStack.syntaxStack !== syntaxStack) {\n                    closeSyntax();\n                }\n\n                // pop stack\n                thenStack = thenStack.prev;\n                break;\n\n            case 'Mismatch':\n                // when some syntax is stashed\n                if (syntaxStash !== null && syntaxStash !== false) {\n                    // there is no else branches or a branch reduce match stack\n                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                        // restore state from the stash\n                        elseStack = syntaxStash;\n                        syntaxStash = false; // disable stashing\n                    }\n                } else if (elseStack === null) {\n                    // no else branches -> break the main loop\n                    // return a result - MISMATCH\n                    exitReason = EXIT_REASON_MISMATCH;\n                    break;\n                }\n\n                // go to next syntax (`else` branch)\n                state = elseStack.nextState;\n\n                // restore all the rest stack states\n                thenStack = elseStack.thenStack;\n                syntaxStack = elseStack.syntaxStack;\n                matchStack = elseStack.matchStack;\n                tokenIndex = elseStack.tokenIndex;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                // pop stack\n                elseStack = elseStack.prev;\n                break;\n\n            case 'MatchGraph':\n                state = state.match;\n                break;\n\n            case 'If':\n                // IMPORTANT: else stack push must go first,\n                // since it stores the state of thenStack before changes\n                if (state.else !== MISMATCH) {\n                    pushElseStack(state.else);\n                }\n\n                if (state.then !== MATCH) {\n                    pushThenStack(state.then);\n                }\n\n                state = state.match;\n                break;\n\n            case 'MatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state,\n                    index: 0,\n                    mask: 0\n                };\n                break;\n\n            case 'MatchOnceBuffer':\n                var terms = state.syntax.terms;\n\n                if (state.index === terms.length) {\n                    // no matches at all or it's required all terms to be matched\n                    if (state.mask === 0 || state.syntax.all) {\n                        state = MISMATCH;\n                        break;\n                    }\n\n                    // a partial match is ok\n                    state = MATCH;\n                    break;\n                }\n\n                // all terms are matched\n                if (state.mask === (1 << terms.length) - 1) {\n                    state = MATCH;\n                    break;\n                }\n\n                for (; state.index < terms.length; state.index++) {\n                    var matchFlag = 1 << state.index;\n\n                    if ((state.mask & matchFlag) === 0) {\n                        // IMPORTANT: else stack push must go first,\n                        // since it stores the state of thenStack before changes\n                        pushElseStack(state);\n                        pushThenStack({\n                            type: 'AddMatchOnce',\n                            syntax: state.syntax,\n                            mask: state.mask | matchFlag\n                        });\n\n                        // match\n                        state = terms[state.index++];\n                        break;\n                    }\n                }\n                break;\n\n            case 'AddMatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state.syntax,\n                    index: 0,\n                    mask: state.mask\n                };\n                break;\n\n            case 'Enum':\n                if (token !== null) {\n                    var name = token.value.toLowerCase();\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (name.indexOf('\\\\') !== -1) {\n                        name = name.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (hasOwnProperty.call(state.map, name)) {\n                        state = state.map[name];\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Generic':\n                var opts = syntaxStack !== null ? syntaxStack.opts : null;\n                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            case 'Type':\n            case 'Property':\n                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                if (!dictSyntax || !dictSyntax.match) {\n                    throw new Error(\n                        'Bad syntax reference: ' +\n                        (state.type === 'Type'\n                            ? '<' + state.name + '>'\n                            : '<\\'' + state.name + '\\'>')\n                    );\n                }\n\n                // stash a syntax for types with low priority\n                if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                    var lowPriorityMatching =\n                        // https://drafts.csswg.org/css-values-4/#custom-idents\n                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                        // can only claim the keyword if no other unfulfilled production can claim it.\n                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||\n\n                        // https://drafts.csswg.org/css-values-4/#lengths\n                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                        // it must parse as a <number>\n                        (state.name === 'length' && token.value === '0');\n\n                    if (lowPriorityMatching) {\n                        if (syntaxStash === null) {\n                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                        }\n\n                        state = MISMATCH;\n                        break;\n                    }\n                }\n\n                openSyntax();\n                state = dictSyntax.match;\n                break;\n\n            case 'Keyword':\n                var name = state.name;\n\n                if (token !== null) {\n                    var keywordName = token.value;\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (keywordName.indexOf('\\\\') !== -1) {\n                        keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                        addTokenToMatch();\n                        state = MATCH;\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'AtKeyword':\n            case 'Function':\n                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Token':\n                if (token !== null && token.value === state.value) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Comma':\n                if (token !== null && token.type === TYPE.Comma) {\n                    if (isCommaContextStart(matchStack.token)) {\n                        state = MISMATCH;\n                    } else {\n                        addTokenToMatch();\n                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n                    }\n                } else {\n                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n                }\n\n                break;\n\n            case 'String':\n                var string = '';\n\n                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                    string += tokens[lastTokenIndex].value;\n                }\n\n                if (areStringsEqualCaseInsensitive(string, state.value)) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            default:\n                throw new Error('Unknown node type: ' + state.type);\n        }\n    }\n\n    totalIterationCount += iterationCount;\n\n    switch (exitReason) {\n        case null:\n            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n            exitReason = EXIT_REASON_ITERATION_LIMIT;\n            matchStack = null;\n            break;\n\n        case EXIT_REASON_MATCH:\n            while (syntaxStack !== null) {\n                closeSyntax();\n            }\n            break;\n\n        default:\n            matchStack = null;\n    }\n\n    return {\n        tokens: tokens,\n        reason: exitReason,\n        iterations: iterationCount,\n        match: matchStack,\n        longestMatch: longestMatch\n    };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match !== null) {\n        var item = reverseList(matchResult.match).prev;\n\n        matchResult.match = [];\n\n        while (item !== null) {\n            switch (item.type) {\n                case STUB:\n                    break;\n\n                case OPEN_SYNTAX:\n                case CLOSE_SYNTAX:\n                    matchResult.match.push({\n                        type: item.type,\n                        syntax: item.syntax\n                    });\n                    break;\n\n                default:\n                    matchResult.match.push({\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n                    break;\n            }\n\n            item = item.prev;\n        }\n    }\n\n    return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match === null) {\n        return matchResult;\n    }\n\n    var item = matchResult.match;\n    var host = matchResult.match = {\n        syntax: matchGraph.syntax || null,\n        match: []\n    };\n    var hostStack = [host];\n\n    // revert a list and start with 2nd item since 1st is a stub item\n    item = reverseList(item).prev;\n\n    // build a tree\n    while (item !== null) {\n        switch (item.type) {\n            case OPEN_SYNTAX:\n                host.match.push(host = {\n                    syntax: item.syntax,\n                    match: []\n                });\n                hostStack.push(host);\n                break;\n\n            case CLOSE_SYNTAX:\n                hostStack.pop();\n                host = hostStack[hostStack.length - 1];\n                break;\n\n            default:\n                host.match.push({\n                    syntax: item.syntax || null,\n                    token: item.token.value,\n                    node: item.token.node\n                });\n        }\n\n        item = item.prev;\n    }\n\n    return matchResult;\n}\n\nmodule.exports = {\n    matchAsList: matchAsList,\n    matchAsTree: matchAsTree,\n    getTotalIterationCount: function() {\n        return totalIterationCount;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}