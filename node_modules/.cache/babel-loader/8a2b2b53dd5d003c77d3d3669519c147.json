{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar selectorParser = _interopDefault(require('postcss-selector-parser'));\n\nvar index = postcss.plugin('postcss-dir-pseudo-class', opts => {\n  const dir = Object(opts).dir;\n  const preserve = Boolean(Object(opts).preserve);\n  return root => {\n    // walk rules using the :dir pseudo-class\n    root.walkRules(/:dir\\([^\\)]*\\)/, rule => {\n      let currentRule = rule; // conditionally preserve the original rule\n\n      if (preserve) {\n        currentRule = rule.cloneBefore();\n      } // update the rule selector\n\n\n      currentRule.selector = selectorParser(selectors => {\n        // for each (comma separated) selector\n        selectors.nodes.forEach(selector => {\n          // walk all selector nodes that are :dir pseudo-classes\n          selector.walk(node => {\n            if ('pseudo' === node.type && ':dir' === node.value) {\n              // previous and next selector nodes\n              const prev = node.prev();\n              const next = node.next();\n              const prevIsSpaceCombinator = prev && prev.type && 'combinator' === prev.type && ' ' === prev.value;\n              const nextIsSpaceCombinator = next && next.type && 'combinator' === next.type && ' ' === next.value; // preserve the selector tree\n\n              if (prevIsSpaceCombinator && (nextIsSpaceCombinator || !next)) {\n                node.replaceWith(selectorParser.universal());\n              } else {\n                node.remove();\n              } // conditionally prepend a combinator before inserting the [dir] attribute\n\n\n              const first = selector.nodes[0];\n              const firstIsSpaceCombinator = first && 'combinator' === first.type && ' ' === first.value;\n              const firstIsHtml = first && 'tag' === first.type && 'html' === first.value;\n              const firstIsRoot = first && 'pseudo' === first.type && ':root' === first.value;\n\n              if (first && !firstIsHtml && !firstIsRoot && !firstIsSpaceCombinator) {\n                selector.prepend(selectorParser.combinator({\n                  value: ' '\n                }));\n              } // value of the :dir pseudo-class\n\n\n              const value = node.nodes.toString(); // whether :dir matches the presumed direction\n\n              const isdir = dir === value; // [dir] attribute\n\n              const dirAttr = selectorParser.attribute({\n                attribute: 'dir',\n                operator: '=',\n                quoteMark: '\"',\n                value: `\"${value}\"`\n              }); // not[dir] attribute\n\n              const notDirAttr = selectorParser.pseudo({\n                value: `${firstIsHtml || firstIsRoot ? '' : 'html'}:not`\n              });\n              notDirAttr.append(selectorParser.attribute({\n                attribute: 'dir',\n                operator: '=',\n                quoteMark: '\"',\n                value: `\"${'ltr' === value ? 'rtl' : 'ltr'}\"`\n              }));\n\n              if (isdir) {\n                // if the direction is presumed\n                if (firstIsHtml) {\n                  // insert :root after html tag\n                  selector.insertAfter(first, notDirAttr);\n                } else {\n                  // prepend :root\n                  selector.prepend(notDirAttr);\n                }\n              } else if (firstIsHtml) {\n                // otherwise, insert dir attribute after html tag\n                selector.insertAfter(first, dirAttr);\n              } else {\n                // otherwise, prepend the dir attribute\n                selector.prepend(dirAttr);\n              }\n            }\n          });\n        });\n      }).processSync(currentRule.selector);\n    });\n  };\n});\nmodule.exports = index;","map":{"version":3,"sources":["index.js"],"names":["opts","dir","Object","preserve","Boolean","root","rule","currentRule","selectors","selector","node","prev","next","prevIsSpaceCombinator","nextIsSpaceCombinator","selectorParser","first","firstIsSpaceCombinator","firstIsHtml","firstIsRoot","value","isdir","dirAttr","attribute","operator","quoteMark","notDirAttr"],"mappings":"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","sourcesContent":["import postcss from 'postcss';\nimport selectorParser from 'postcss-selector-parser';\n\nexport default postcss.plugin('postcss-dir-pseudo-class', opts => {\n\tconst dir = Object(opts).dir;\n\tconst preserve = Boolean(Object(opts).preserve);\n\n\treturn root => {\n\t\t// walk rules using the :dir pseudo-class\n\t\troot.walkRules(/:dir\\([^\\)]*\\)/, rule => {\n\t\t\tlet currentRule = rule\n\n\t\t\t// conditionally preserve the original rule\n\t\t\tif (preserve) {\n\t\t\t\tcurrentRule = rule.cloneBefore();\n\t\t\t}\n\n\t\t\t// update the rule selector\n\t\t\tcurrentRule.selector = selectorParser(selectors => {\n\t\t\t\t// for each (comma separated) selector\n\t\t\t\tselectors.nodes.forEach(selector => {\n\t\t\t\t\t// walk all selector nodes that are :dir pseudo-classes\n\t\t\t\t\tselector.walk(node => {\n\t\t\t\t\t\tif ('pseudo' === node.type && ':dir' === node.value) {\n\t\t\t\t\t\t\t// previous and next selector nodes\n\t\t\t\t\t\t\tconst prev = node.prev();\n\t\t\t\t\t\t\tconst next = node.next();\n\n\t\t\t\t\t\t\tconst prevIsSpaceCombinator = prev && prev.type && 'combinator' === prev.type && ' ' === prev.value;\n\t\t\t\t\t\t\tconst nextIsSpaceCombinator = next && next.type && 'combinator' === next.type && ' ' === next.value;\n\n\t\t\t\t\t\t\t// preserve the selector tree\n\t\t\t\t\t\t\tif (prevIsSpaceCombinator && (nextIsSpaceCombinator || !next)) {\n\t\t\t\t\t\t\t\tnode.replaceWith(\n\t\t\t\t\t\t\t\t\tselectorParser.universal()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnode.remove();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// conditionally prepend a combinator before inserting the [dir] attribute\n\t\t\t\t\t\t\tconst first = selector.nodes[0];\n\t\t\t\t\t\t\tconst firstIsSpaceCombinator = first && 'combinator' === first.type && ' ' === first.value;\n\t\t\t\t\t\t\tconst firstIsHtml = first && 'tag' === first.type && 'html' === first.value;\n\t\t\t\t\t\t\tconst firstIsRoot = first && 'pseudo' === first.type && ':root' === first.value;\n\n\t\t\t\t\t\t\tif (first && !firstIsHtml && !firstIsRoot && !firstIsSpaceCombinator) {\n\t\t\t\t\t\t\t\tselector.prepend(\n\t\t\t\t\t\t\t\t\tselectorParser.combinator({\n\t\t\t\t\t\t\t\t\t\tvalue: ' '\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// value of the :dir pseudo-class\n\t\t\t\t\t\t\tconst value = node.nodes.toString();\n\n\t\t\t\t\t\t\t// whether :dir matches the presumed direction\n\t\t\t\t\t\t\tconst isdir = dir === value;\n\n\t\t\t\t\t\t\t// [dir] attribute\n\t\t\t\t\t\t\tconst dirAttr = selectorParser.attribute({\n\t\t\t\t\t\t\t\tattribute: 'dir',\n\t\t\t\t\t\t\t\toperator:  '=',\n\t\t\t\t\t\t\t\tquoteMark: '\"',\n\t\t\t\t\t\t\t\tvalue:     `\"${ value }\"`\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// not[dir] attribute\n\t\t\t\t\t\t\tconst notDirAttr = selectorParser.pseudo({\n\t\t\t\t\t\t\t\tvalue: `${firstIsHtml || firstIsRoot ? '' : 'html'}:not`\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tnotDirAttr.append(\n\t\t\t\t\t\t\t\tselectorParser.attribute({\n\t\t\t\t\t\t\t\t\tattribute: 'dir',\n\t\t\t\t\t\t\t\t\toperator:  '=',\n\t\t\t\t\t\t\t\t\tquoteMark: '\"',\n\t\t\t\t\t\t\t\t\tvalue:     `\"${ 'ltr' === value ? 'rtl' : 'ltr' }\"`\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (isdir) {\n\t\t\t\t\t\t\t\t// if the direction is presumed\n\t\t\t\t\t\t\t\tif (firstIsHtml) {\n\t\t\t\t\t\t\t\t\t// insert :root after html tag\n\t\t\t\t\t\t\t\t\tselector.insertAfter(first, notDirAttr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// prepend :root\n\t\t\t\t\t\t\t\t\tselector.prepend(notDirAttr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (firstIsHtml) {\n\t\t\t\t\t\t\t\t// otherwise, insert dir attribute after html tag\n\t\t\t\t\t\t\t\tselector.insertAfter(first, dirAttr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// otherwise, prepend the dir attribute\n\t\t\t\t\t\t\t\tselector.prepend(dirAttr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}).processSync(currentRule.selector);\n\t\t});\n\t};\n});\n"]},"metadata":{},"sourceType":"script"}