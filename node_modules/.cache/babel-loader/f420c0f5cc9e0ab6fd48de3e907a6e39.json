{"ast":null,"code":"/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst BOM = \"\\uFEFF\";\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\n\nfunction compareMessagesByFixRange(a, b) {\n  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\n\n\nfunction compareMessagesByLocation(a, b) {\n  return a.line - b.line || a.column - b.column;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\n\n\nfunction SourceCodeFixer() {\n  Object.freeze(this);\n}\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\n\n\nSourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {\n  debug(\"Applying fixes\");\n\n  if (shouldFix === false) {\n    debug(\"shouldFix parameter was false, not attempting fixes\");\n    return {\n      fixed: false,\n      messages,\n      output: sourceText\n    };\n  } // clone the array\n\n\n  const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n  let lastPos = Number.NEGATIVE_INFINITY,\n      output = bom;\n  /**\n   * Try to use the 'fix' from a problem.\n   * @param   {Message} problem The message object to apply fixes from\n   * @returns {boolean}         Whether fix was successfully applied\n   */\n\n  function attemptFix(problem) {\n    const fix = problem.fix;\n    const start = fix.range[0];\n    const end = fix.range[1]; // Remain it as a problem if it's overlapped or it's a negative range\n\n    if (lastPos >= start || start > end) {\n      remainingMessages.push(problem);\n      return false;\n    } // Remove BOM.\n\n\n    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {\n      output = \"\";\n    } // Make output to this fix.\n\n\n    output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n    output += fix.text;\n    lastPos = end;\n    return true;\n  }\n\n  messages.forEach(problem => {\n    if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n      fixes.push(problem);\n    } else {\n      remainingMessages.push(problem);\n    }\n  });\n\n  if (fixes.length) {\n    debug(\"Found fixes to apply\");\n    let fixesWereApplied = false;\n\n    for (const problem of fixes.sort(compareMessagesByFixRange)) {\n      if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n        attemptFix(problem);\n        /*\n         * The only time attemptFix will fail is if a previous fix was\n         * applied which conflicts with it.  So we can mark this as true.\n         */\n\n        fixesWereApplied = true;\n      } else {\n        remainingMessages.push(problem);\n      }\n    }\n\n    output += text.slice(Math.max(0, lastPos));\n    return {\n      fixed: fixesWereApplied,\n      messages: remainingMessages.sort(compareMessagesByLocation),\n      output\n    };\n  }\n\n  debug(\"No fixes to apply\");\n  return {\n    fixed: false,\n    messages,\n    output: bom + text\n  };\n};\n\nmodule.exports = SourceCodeFixer;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/linter/source-code-fixer.js"],"names":["debug","require","BOM","compareMessagesByFixRange","a","b","fix","range","compareMessagesByLocation","line","column","SourceCodeFixer","Object","freeze","applyFixes","sourceText","messages","shouldFix","fixed","output","remainingMessages","fixes","bom","startsWith","text","slice","lastPos","Number","NEGATIVE_INFINITY","attemptFix","problem","start","end","push","Math","max","forEach","prototype","hasOwnProperty","call","length","fixesWereApplied","sort","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n"]},"metadata":{},"sourceType":"script"}