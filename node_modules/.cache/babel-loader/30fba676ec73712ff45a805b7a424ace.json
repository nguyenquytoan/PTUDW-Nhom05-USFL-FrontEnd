{"ast":null,"code":"/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow trailing whitespace at the end of lines\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipBlankLines: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n          SKIP_BLANK = `^${BLANK_CLASS}*$`,\n          NONBLANK = `${BLANK_CLASS}+$`;\n    const options = context.options[0] || {},\n          skipBlankLines = options.skipBlankLines || false,\n          ignoreComments = options.ignoreComments || false;\n    /**\n     * Report the error message\n     * @param {ASTNode} node node to report\n     * @param {int[]} location range information\n     * @param {int[]} fixRange Range based on the whole program\n     * @returns {void}\n     */\n\n    function report(node, location, fixRange) {\n      /*\n       * Passing node is a bit dirty, because message data will contain big\n       * text in `source`. But... who cares :) ?\n       * One more kludge will not make worse the bloody wizardry of this\n       * plugin.\n       */\n      context.report({\n        node,\n        loc: location,\n        message: \"Trailing spaces not allowed.\",\n\n        fix(fixer) {\n          return fixer.removeRange(fixRange);\n        }\n\n      });\n    }\n    /**\n     * Given a list of comment nodes, return the line numbers for those comments.\n     * @param {Array} comments An array of comment nodes.\n     * @returns {number[]} An array of line numbers containing comments.\n     */\n\n\n    function getCommentLineNumbers(comments) {\n      const lines = new Set();\n      comments.forEach(comment => {\n        const endLine = comment.type === \"Block\" ? comment.loc.end.line - 1 : comment.loc.end.line;\n\n        for (let i = comment.loc.start.line; i <= endLine; i++) {\n          lines.add(i);\n        }\n      });\n      return lines;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkTrailingSpaces(node) {\n        /*\n         * Let's hack. Since Espree does not return whitespace nodes,\n         * fetch the source code and do matching via regexps.\n         */\n        const re = new RegExp(NONBLANK, \"u\"),\n              skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n              lines = sourceCode.lines,\n              linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n              comments = sourceCode.getAllComments(),\n              commentLineNumbers = getCommentLineNumbers(comments);\n        let totalLength = 0,\n            fixRange = [];\n\n        for (let i = 0, ii = lines.length; i < ii; i++) {\n          const lineNumber = i + 1;\n          /*\n           * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n           * Because during the fix time they also reserve one spot in the array.\n           * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n           */\n\n          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n          const lineLength = lines[i].length + linebreakLength;\n          const matches = re.exec(lines[i]);\n\n          if (matches) {\n            const location = {\n              start: {\n                line: lineNumber,\n                column: matches.index\n              },\n              end: {\n                line: lineNumber,\n                column: lineLength - linebreakLength\n              }\n            };\n            const rangeStart = totalLength + location.start.column;\n            const rangeEnd = totalLength + location.end.column;\n            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n            if (containingNode && containingNode.type === \"TemplateElement\" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {\n              totalLength += lineLength;\n              continue;\n            }\n            /*\n             * If the line has only whitespace, and skipBlankLines\n             * is true, don't report it\n             */\n\n\n            if (skipBlankLines && skipMatch.test(lines[i])) {\n              totalLength += lineLength;\n              continue;\n            }\n\n            fixRange = [rangeStart, rangeEnd];\n\n            if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n              report(node, location, fixRange);\n            }\n          }\n\n          totalLength += lineLength;\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-trailing-spaces.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","skipBlankLines","default","ignoreComments","additionalProperties","create","context","sourceCode","getSourceCode","BLANK_CLASS","SKIP_BLANK","NONBLANK","options","report","node","location","fixRange","loc","message","fix","fixer","removeRange","getCommentLineNumbers","comments","lines","Set","forEach","comment","endLine","end","line","i","start","add","Program","checkTrailingSpaces","re","RegExp","skipMatch","linebreaks","getText","match","createGlobalLinebreakMatcher","getAllComments","commentLineNumbers","totalLength","ii","length","lineNumber","linebreakLength","lineLength","matches","exec","column","index","rangeStart","rangeEnd","containingNode","getNodeByRangeIndex","parent","range","test","has"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = options.ignoreComments || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                message: \"Trailing spaces not allowed.\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                const endLine = comment.type === \"Block\"\n                    ? comment.loc.end.line - 1\n                    : comment.loc.end.line;\n\n                for (let i = comment.loc.start.line; i <= endLine; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                /*\n                 * Let's hack. Since Espree does not return whitespace nodes,\n                 * fetch the source code and do matching via regexps.\n                 */\n\n                const re = new RegExp(NONBLANK, \"u\"),\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const lineNumber = i + 1;\n\n                    /*\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                     * Because during the fix time they also reserve one spot in the array.\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                     */\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    const matches = re.exec(lines[i]);\n\n                    if (matches) {\n                        const location = {\n                            start: {\n                                line: lineNumber,\n                                column: matches.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: lineLength - linebreakLength\n                            }\n                        };\n\n                        const rangeStart = totalLength + location.start.column;\n                        const rangeEnd = totalLength + location.end.column;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        /*\n                         * If the line has only whitespace, and skipBlankLines\n                         * is true, don't report it\n                         */\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}