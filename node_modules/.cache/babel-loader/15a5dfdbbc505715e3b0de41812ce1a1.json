{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nimport assert from \"assert\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport replaceShorthandObjectMethod from \"./replaceShorthandObjectMethod\";\nimport * as util from \"./util\";\nimport { makeAccessor } from \"private\";\n\nexports.getVisitor = ({\n  types: t\n}) => ({\n  Method(path, state) {\n    let node = path.node;\n    if (!shouldRegenerate(node, state)) return;\n    const container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n    path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n    // or generator the outer function should not be\n\n    node.async = false;\n    node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n    path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n  },\n\n  Function: {\n    exit: util.wrapWithTypes(t, function (path, state) {\n      let node = path.node;\n      if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n      path = replaceShorthandObjectMethod(path);\n      node = path.node;\n      let contextId = path.scope.generateUidIdentifier(\"context\");\n      let argsId = path.scope.generateUidIdentifier(\"args\");\n      path.ensureBlock();\n      let bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n      let outerBody = [];\n      let innerBody = [];\n      bodyBlockPath.get(\"body\").forEach(function (childPath) {\n        let node = childPath.node;\n\n        if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n          // Babylon represents directives like \"use strict\" as elements\n          // of a bodyBlockPath.node.directives array, but they could just\n          // as easily be represented (by other parsers) as traditional\n          // string-literal-valued expression statements, so we need to\n          // handle that here. (#248)\n          outerBody.push(node);\n        } else if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      let outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n\n      t.assertIdentifier(node.id);\n      let innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n\n      let vars = hoist(path);\n      let context = {\n        usesThis: false,\n        usesArguments: false,\n        getArgsId: () => t.clone(argsId)\n      };\n      path.traverse(argumentsThisVisitor, context);\n\n      if (context.usesArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n      }\n\n      let emitter = new Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      let wrapArgs = [emitter.getContextFunction(innerFnId)];\n      let tryLocsList = emitter.getTryLocsList();\n\n      if (node.generator) {\n        wrapArgs.push(outerFnExpr);\n      } else if (context.usesThis || tryLocsList || node.async) {\n        // Async functions that are not generators don't care about the\n        // outer function because they don't need it to be marked and don't\n        // inherit from its .prototype.\n        wrapArgs.push(t.nullLiteral());\n      }\n\n      if (context.usesThis) {\n        wrapArgs.push(t.thisExpression());\n      } else if (tryLocsList || node.async) {\n        wrapArgs.push(t.nullLiteral());\n      }\n\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      } else if (node.async) {\n        wrapArgs.push(t.nullLiteral());\n      }\n\n      if (node.async) {\n        // Rename any locally declared \"Promise\" variable,\n        // to use the global one.\n        let currentScope = path.scope;\n\n        do {\n          if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n        } while (currentScope = currentScope.parent);\n\n        wrapArgs.push(t.identifier(\"Promise\"));\n      }\n\n      let wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n      // so we need to add them to the scope.\n\n      path.get(\"body.body\").forEach(p => p.scope.registerDeclaration(p));\n      const oldDirectives = bodyBlockPath.node.directives;\n\n      if (oldDirectives) {\n        // Babylon represents directives like \"use strict\" as elements of\n        // a bodyBlockPath.node.directives array. (#248)\n        node.body.directives = oldDirectives;\n      }\n\n      let wasGeneratorFunction = node.generator;\n\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n\n      const insertedLocs = emitter.getInsertedLocs();\n      path.traverse({\n        NumericLiteral(path) {\n          if (!insertedLocs.has(path.node)) {\n            return;\n          }\n\n          path.replaceWith(t.numericLiteral(path.node.value));\n        }\n\n      }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n      path.requeue();\n    })\n  }\n}); // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  const t = util.getTypes();\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nconst getMarkInfo = makeAccessor();\n\nfunction getMarkedFunctionId(funPath) {\n  const t = util.getTypes();\n  const node = funPath.node;\n  t.assertIdentifier(node.id);\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  const block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n  const info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  assert.strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  const index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  const markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n  assert.strictEqual(markCallExpPath.node, markCallExp);\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nlet argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function (path) {\n    path.skip();\n  },\n  Identifier: function (path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function (path, state) {\n    state.usesThis = true;\n  }\n};\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let {\n      node\n    } = path;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      const t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n\n};\nlet awaitVisitor = {\n  Function: function (path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function (path) {\n    const t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    let argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/regenerator-transform/src/visit.js"],"names":["assert","hoist","Emitter","replaceShorthandObjectMethod","util","makeAccessor","exports","getVisitor","types","t","Method","path","state","node","shouldRegenerate","container","functionExpression","cloneNode","body","generator","async","get","set","returnStatement","callExpression","unwrapFunctionEnvironment","Function","exit","wrapWithTypes","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","usesThis","usesArguments","getArgsId","clone","argumentsThisVisitor","variableDeclaration","declarations","variableDeclarator","emitter","explode","wrapArgs","getContextFunction","tryLocsList","getTryLocsList","nullLiteral","thisExpression","currentScope","hasOwnBinding","rename","parent","wrapCall","runtimeProperty","blockStatement","p","registerDeclaration","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","insertedLocs","getInsertedLocs","NumericLiteral","has","replaceWith","numericLiteral","value","requeue","opts","asyncGenerators","generators","funPath","getTypes","assertFunction","isFunctionDeclaration","getMarkedFunctionId","getMarkInfo","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","skip","Identifier","isReference","ThisExpression","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\nimport assert from \"assert\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport replaceShorthandObjectMethod from \"./replaceShorthandObjectMethod\";\nimport * as util from \"./util\";\nimport { makeAccessor } from \"private\";\n\nexports.getVisitor = ({ types: t }) => ({\n  Method(path, state) {\n    let node = path.node;\n\n    if (!shouldRegenerate(node, state)) return;\n\n    const container = t.functionExpression(\n      null,\n      [],\n      t.cloneNode(node.body, false),\n      node.generator,\n      node.async,\n    );\n\n    path.get(\"body\").set(\"body\", [\n      t.returnStatement(\n        t.callExpression(container, []),\n      ),\n    ]);\n\n    // Regardless of whether or not the wrapped function is a an async method\n    // or generator the outer function should not be\n    node.async = false;\n    node.generator = false;\n\n    // Unwrap the wrapper IIFE's environment so super and this and such still work.\n    path\n      .get(\"body.body.0.argument.callee\")\n      .unwrapFunctionEnvironment();\n  },\n  Function: {\n    exit: util.wrapWithTypes(t, function(path, state) {\n      let node = path.node;\n\n      if (!shouldRegenerate(node, state)) return;\n\n      // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n      path = replaceShorthandObjectMethod(path);\n      node = path.node;\n\n      let contextId = path.scope.generateUidIdentifier(\"context\");\n      let argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      let bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      let outerBody = [];\n      let innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function(childPath) {\n        let node = childPath.node;\n        if (t.isExpressionStatement(node) &&\n            t.isStringLiteral(node.expression)) {\n          // Babylon represents directives like \"use strict\" as elements\n          // of a bodyBlockPath.node.directives array, but they could just\n          // as easily be represented (by other parsers) as traditional\n          // string-literal-valued expression statements, so we need to\n          // handle that here. (#248)\n          outerBody.push(node);\n        } else if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      let outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      let innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      let vars = hoist(path);\n\n      let context = {\n        usesThis: false,\n        usesArguments: false,\n        getArgsId: () => t.clone(argsId),\n      };\n      path.traverse(argumentsThisVisitor, context);\n\n      if (context.usesArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        vars.declarations.push(t.variableDeclarator(\n          t.clone(argsId),\n          t.identifier(\"arguments\"),\n        ));\n      }\n\n      let emitter = new Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      let wrapArgs = [emitter.getContextFunction(innerFnId)];\n      let tryLocsList = emitter.getTryLocsList();\n\n      if (node.generator) {\n        wrapArgs.push(outerFnExpr);\n      } else if (context.usesThis || tryLocsList || node.async) {\n        // Async functions that are not generators don't care about the\n        // outer function because they don't need it to be marked and don't\n        // inherit from its .prototype.\n        wrapArgs.push(t.nullLiteral());\n      }\n      if (context.usesThis) {\n        wrapArgs.push(t.thisExpression());\n      } else if (tryLocsList || node.async) {\n        wrapArgs.push(t.nullLiteral());\n      }\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      } else if (node.async) {\n        wrapArgs.push(t.nullLiteral());\n      }\n\n      if (node.async) {\n        // Rename any locally declared \"Promise\" variable,\n        // to use the global one.\n        let currentScope = path.scope;\n        do {\n          if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n        } while (currentScope = currentScope.parent);\n\n        wrapArgs.push(t.identifier(\"Promise\"));\n      }\n\n      let wrapCall = t.callExpression(\n        util.runtimeProperty(node.async ? \"async\" : \"wrap\"),\n        wrapArgs\n      );\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n      // We injected a few new variable declarations (for every hoisted var),\n      // so we need to add them to the scope.\n      path.get(\"body.body\").forEach(p => p.scope.registerDeclaration(p));\n\n      const oldDirectives = bodyBlockPath.node.directives;\n      if (oldDirectives) {\n        // Babylon represents directives like \"use strict\" as elements of\n        // a bodyBlockPath.node.directives array. (#248)\n        node.body.directives = oldDirectives;\n      }\n\n      let wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]))\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n\n      const insertedLocs = emitter.getInsertedLocs();\n\n      path.traverse({\n        NumericLiteral(path) {\n          if (!insertedLocs.has(path.node)) {\n            return;\n          }\n\n          path.replaceWith(t.numericLiteral(path.node.value));\n        },\n      })\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    })\n  }\n});\n\n// Check if a node should be transformed by regenerator\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n}\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  const t = util.getTypes();\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n      t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nconst getMarkInfo = makeAccessor();\n\nfunction getMarkedFunctionId(funPath) {\n  const t = util.getTypes();\n  const node = funPath.node;\n  t.assertIdentifier(node.id);\n\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  const block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n\n  const info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  assert.strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = t.callExpression(\n    util.runtimeProperty(\"mark\"),\n    [t.clone(node.id)]\n  );\n\n  const index = info.decl.declarations.push(\n    t.variableDeclarator(markedId, markCallExp)\n  ) - 1;\n\n  const markCallExpPath =\n    info.declPath.get(\"declarations.\" + index + \".init\");\n\n  assert.strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n\n  return t.clone(markedId);\n}\n\nlet argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function(path) {\n    path.skip();\n  },\n\n  Identifier: function(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n\n  ThisExpression: function(path, state) {\n    state.usesThis = true;\n  }\n};\n\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let { node } = path;\n\n    if (node.meta.name === \"function\" &&\n        node.property.name === \"sent\") {\n      const t = util.getTypes();\n      util.replaceWithOrRemove(\n        path,\n        t.memberExpression(\n          t.clone(this.context),\n          t.identifier(\"_sent\")\n        )\n      );\n    }\n  }\n};\n\nlet awaitVisitor = {\n  Function: function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function(path) {\n    const t = util.getTypes();\n\n    // Convert await expressions to yield expressions.\n    let argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(\n      t.callExpression(\n        util.runtimeProperty(\"awrap\"),\n        [argument]\n      ),\n      false\n    ));\n  }\n};\n"]},"metadata":{},"sourceType":"module"}