{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ts = require(\"typescript\");\n\nconst type_1 = require(\"../typeguard/type\");\n\nconst util_1 = require(\"./util\");\n\nconst node_1 = require(\"../typeguard/node\");\n\nfunction isEmptyObjectType(type) {\n  if (type_1.isObjectType(type) && type.objectFlags & ts.ObjectFlags.Anonymous && type.getProperties().length === 0 && type.getCallSignatures().length === 0 && type.getConstructSignatures().length === 0 && type.getStringIndexType() === undefined && type.getNumberIndexType() === undefined) {\n    const baseTypes = type.getBaseTypes();\n    return baseTypes === undefined || baseTypes.every(isEmptyObjectType);\n  }\n\n  return false;\n}\n\nexports.isEmptyObjectType = isEmptyObjectType;\n\nfunction removeOptionalityFromType(checker, type) {\n  if (!containsTypeWithFlag(type, ts.TypeFlags.Undefined)) return type;\n  const allowsNull = containsTypeWithFlag(type, ts.TypeFlags.Null);\n  type = checker.getNonNullableType(type);\n  return allowsNull ? checker.getNullableType(type, ts.TypeFlags.Null) : type;\n}\n\nexports.removeOptionalityFromType = removeOptionalityFromType;\n\nfunction containsTypeWithFlag(type, flag) {\n  for (const t of unionTypeParts(type)) if (util_1.isTypeFlagSet(t, flag)) return true;\n\n  return false;\n}\n\nfunction isTypeAssignableToNumber(checker, type) {\n  return isTypeAssignableTo(checker, type, ts.TypeFlags.NumberLike);\n}\n\nexports.isTypeAssignableToNumber = isTypeAssignableToNumber;\n\nfunction isTypeAssignableToString(checker, type) {\n  return isTypeAssignableTo(checker, type, ts.TypeFlags.StringLike);\n}\n\nexports.isTypeAssignableToString = isTypeAssignableToString;\n\nfunction isTypeAssignableTo(checker, type, flags) {\n  flags |= ts.TypeFlags.Any;\n  let typeParametersSeen;\n  return function check(t) {\n    if (type_1.isTypeParameter(t) && t.symbol !== undefined && t.symbol.declarations !== undefined) {\n      if (typeParametersSeen === undefined) {\n        typeParametersSeen = new Set([t]);\n      } else if (!typeParametersSeen.has(t)) {\n        typeParametersSeen.add(t);\n      } else {\n        return false;\n      }\n\n      const declaration = t.symbol.declarations[0];\n      if (declaration.constraint === undefined) return true;\n      return check(checker.getTypeFromTypeNode(declaration.constraint));\n    }\n\n    if (type_1.isUnionType(t)) return t.types.every(check);\n    if (type_1.isIntersectionType(t)) return t.types.some(check);\n    return util_1.isTypeFlagSet(t, flags);\n  }(type);\n}\n\nfunction getCallSignaturesOfType(type) {\n  if (type_1.isUnionType(type)) {\n    const signatures = [];\n\n    for (const t of type.types) signatures.push(...getCallSignaturesOfType(t));\n\n    return signatures;\n  }\n\n  if (type_1.isIntersectionType(type)) {\n    let signatures;\n\n    for (const t of type.types) {\n      const sig = getCallSignaturesOfType(t);\n\n      if (sig.length !== 0) {\n        if (signatures !== undefined) return [];\n        signatures = sig;\n      }\n    }\n\n    return signatures === undefined ? [] : signatures;\n  }\n\n  return type.getCallSignatures();\n}\n\nexports.getCallSignaturesOfType = getCallSignaturesOfType;\n\nfunction unionTypeParts(type) {\n  return type_1.isUnionType(type) ? type.types : [type];\n}\n\nexports.unionTypeParts = unionTypeParts;\n\nfunction intersectionTypeParts(type) {\n  return type_1.isIntersectionType(type) ? type.types : [type];\n}\n\nexports.intersectionTypeParts = intersectionTypeParts;\n\nfunction someTypePart(type, predicate, cb) {\n  return predicate(type) ? type.types.some(cb) : cb(type);\n}\n\nexports.someTypePart = someTypePart;\n\nfunction isThenableType(checker, node, type = checker.getTypeAtLocation(node)) {\n  for (const ty of unionTypeParts(checker.getApparentType(type))) {\n    const then = ty.getProperty('then');\n    if (then === undefined) continue;\n    const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n\n    for (const t of unionTypeParts(thenType)) for (const signature of t.getCallSignatures()) if (signature.parameters.length !== 0 && isCallback(checker, signature.parameters[0], node)) return true;\n  }\n\n  return false;\n}\n\nexports.isThenableType = isThenableType;\n\nfunction isCallback(checker, param, node) {\n  let type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n\n  if (param.valueDeclaration.dotDotDotToken) {\n    type = type.getNumberIndexType();\n    if (type === undefined) return false;\n  }\n\n  for (const t of unionTypeParts(type)) if (t.getCallSignatures().length !== 0) return true;\n\n  return false;\n}\n\nfunction isFalsyType(type) {\n  if (type.flags & (ts.TypeFlags.Undefined | ts.TypeFlags.Null | ts.TypeFlags.Void)) return true;\n  if (type_1.isLiteralType(type)) return !type.value;\n  return isBooleanLiteralType(type, false);\n}\n\nexports.isFalsyType = isFalsyType;\n\nfunction isBooleanLiteralType(type, literal) {\n  return util_1.isTypeFlagSet(type, ts.TypeFlags.BooleanLiteral) && type.intrinsicName === (literal ? 'true' : 'false');\n}\n\nexports.isBooleanLiteralType = isBooleanLiteralType;\n\nfunction getPropertyOfType(type, name) {\n  if (!name.startsWith('__')) return type.getProperty(name);\n  return type.getProperties().find(s => s.escapedName === name);\n}\n\nexports.getPropertyOfType = getPropertyOfType;\n\nfunction isPropertyReadonlyInType(type, name, checker) {\n  let seenProperty = false;\n  let seenReadonlySignature = false;\n\n  for (const t of unionTypeParts(type)) {\n    if (getPropertyOfType(t, name) === undefined) {\n      const index = (util_1.isNumericPropertyName(name) ? checker.getIndexInfoOfType(t, ts.IndexKind.Number) : undefined) || checker.getIndexInfoOfType(t, ts.IndexKind.String);\n\n      if (index !== undefined && index.isReadonly) {\n        if (seenProperty) return true;\n        seenReadonlySignature = true;\n      }\n    } else if (seenReadonlySignature || isReadonlyPropertyIntersection(t, name, checker)) {\n      return true;\n    } else {\n      seenProperty = true;\n    }\n  }\n\n  return false;\n}\n\nexports.isPropertyReadonlyInType = isPropertyReadonlyInType;\n\nfunction isReadonlyPropertyIntersection(type, name, checker) {\n  return someTypePart(type, type_1.isIntersectionType, t => {\n    const prop = getPropertyOfType(t, name);\n    if (prop === undefined) return false;\n\n    if (prop.flags & ts.SymbolFlags.Transient) {\n      if (/^(?:[1-9]\\d*|0)$/.test(name) && type_1.isTupleTypeReference(t)) return t.target.readonly;\n\n      switch (isReadonlyPropertyFromMappedType(t, name, checker)) {\n        case true:\n          return true;\n\n        case false:\n          return false;\n\n        default:\n      }\n    }\n\n    return util_1.isSymbolFlagSet(prop, ts.SymbolFlags.ValueModule) || symbolHasReadonlyDeclaration(prop, checker);\n  });\n}\n\nfunction isReadonlyPropertyFromMappedType(type, name, checker) {\n  if (!type_1.isObjectType(type) || !util_1.isObjectFlagSet(type, ts.ObjectFlags.Mapped)) return;\n  const declaration = type.symbol.declarations[0];\n  if (declaration.readonlyToken !== undefined && !/^__@[^@]+$/.test(name)) return declaration.readonlyToken.kind !== ts.SyntaxKind.MinusToken;\n  return isPropertyReadonlyInType(type.modifiersType, name, checker);\n}\n\nfunction symbolHasReadonlyDeclaration(symbol, checker) {\n  return (symbol.flags & ts.SymbolFlags.Accessor) === ts.SymbolFlags.GetAccessor || symbol.declarations !== undefined && symbol.declarations.some(node => util_1.isModifierFlagSet(node, ts.ModifierFlags.Readonly) || node_1.isVariableDeclaration(node) && util_1.isNodeFlagSet(node.parent, ts.NodeFlags.Const) || node_1.isCallExpression(node) && util_1.isReadonlyAssignmentDeclaration(node, checker) || node_1.isEnumMember(node) || (node_1.isPropertyAssignment(node) || node_1.isShorthandPropertyAssignment(node)) && util_1.isInConstContext(node.parent));\n}\n\nexports.symbolHasReadonlyDeclaration = symbolHasReadonlyDeclaration;\n\nfunction getPropertyNameFromType(type) {\n  if (type.flags & (ts.TypeFlags.StringLiteral | ts.TypeFlags.NumberLiteral)) {\n    const value = String(type.value);\n    return {\n      displayName: value,\n      symbolName: ts.escapeLeadingUnderscores(value)\n    };\n  }\n\n  if (type_1.isUniqueESSymbolType(type)) return {\n    displayName: `[${type.symbol ? type.symbol.name : type.escapedName.replace(/^__@|@\\d+$/g, '')}]`,\n    symbolName: type.escapedName\n  };\n}\n\nexports.getPropertyNameFromType = getPropertyNameFromType;\n\nfunction getConstructorTypeOfClassLikeDeclaration(node, checker) {\n  return checker.getDeclaredTypeOfSymbol(node.name !== undefined ? checker.getSymbolAtLocation(node.name) : checker.getTypeAtLocation(node).symbol);\n}\n\nexports.getConstructorTypeOfClassLikeDeclaration = getConstructorTypeOfClassLikeDeclaration;\n\nfunction getInstanceTypeOfClassLikeDeclaration(node, checker) {\n  return node.kind === ts.SyntaxKind.ClassDeclaration ? checker.getTypeAtLocation(node) : checker.getTypeOfSymbolAtLocation(checker.getTypeAtLocation(node).getProperty('prototype'), node);\n}\n\nexports.getInstanceTypeOfClassLikeDeclaration = getInstanceTypeOfClassLikeDeclaration;\n\nfunction getIteratorYieldResultFromIteratorResult(type, node, checker) {\n  return type_1.isUnionType(type) && type.types.find(t => {\n    const done = t.getProperty('done');\n    return done !== undefined && isBooleanLiteralType(removeOptionalityFromType(checker, checker.getTypeOfSymbolAtLocation(done, node)), false);\n  }) || type;\n}\n\nexports.getIteratorYieldResultFromIteratorResult = getIteratorYieldResultFromIteratorResult;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/tsutils/util/type.js"],"names":["Object","defineProperty","exports","value","ts","require","type_1","util_1","node_1","isEmptyObjectType","type","isObjectType","objectFlags","ObjectFlags","Anonymous","getProperties","length","getCallSignatures","getConstructSignatures","getStringIndexType","undefined","getNumberIndexType","baseTypes","getBaseTypes","every","removeOptionalityFromType","checker","containsTypeWithFlag","TypeFlags","Undefined","allowsNull","Null","getNonNullableType","getNullableType","flag","t","unionTypeParts","isTypeFlagSet","isTypeAssignableToNumber","isTypeAssignableTo","NumberLike","isTypeAssignableToString","StringLike","flags","Any","typeParametersSeen","check","isTypeParameter","symbol","declarations","Set","has","add","declaration","constraint","getTypeFromTypeNode","isUnionType","types","isIntersectionType","some","getCallSignaturesOfType","signatures","push","sig","intersectionTypeParts","someTypePart","predicate","cb","isThenableType","node","getTypeAtLocation","ty","getApparentType","then","getProperty","thenType","getTypeOfSymbolAtLocation","signature","parameters","isCallback","param","valueDeclaration","dotDotDotToken","isFalsyType","Void","isLiteralType","isBooleanLiteralType","literal","BooleanLiteral","intrinsicName","getPropertyOfType","name","startsWith","find","s","escapedName","isPropertyReadonlyInType","seenProperty","seenReadonlySignature","index","isNumericPropertyName","getIndexInfoOfType","IndexKind","Number","String","isReadonly","isReadonlyPropertyIntersection","prop","SymbolFlags","Transient","test","isTupleTypeReference","target","readonly","isReadonlyPropertyFromMappedType","isSymbolFlagSet","ValueModule","symbolHasReadonlyDeclaration","isObjectFlagSet","Mapped","readonlyToken","kind","SyntaxKind","MinusToken","modifiersType","Accessor","GetAccessor","isModifierFlagSet","ModifierFlags","Readonly","isVariableDeclaration","isNodeFlagSet","parent","NodeFlags","Const","isCallExpression","isReadonlyAssignmentDeclaration","isEnumMember","isPropertyAssignment","isShorthandPropertyAssignment","isInConstContext","getPropertyNameFromType","StringLiteral","NumberLiteral","displayName","symbolName","escapeLeadingUnderscores","isUniqueESSymbolType","replace","getConstructorTypeOfClassLikeDeclaration","getDeclaredTypeOfSymbol","getSymbolAtLocation","getInstanceTypeOfClassLikeDeclaration","ClassDeclaration","getIteratorYieldResultFromIteratorResult","done"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ts = require(\"typescript\");\nconst type_1 = require(\"../typeguard/type\");\nconst util_1 = require(\"./util\");\nconst node_1 = require(\"../typeguard/node\");\nfunction isEmptyObjectType(type) {\n    if (type_1.isObjectType(type) &&\n        type.objectFlags & ts.ObjectFlags.Anonymous &&\n        type.getProperties().length === 0 &&\n        type.getCallSignatures().length === 0 &&\n        type.getConstructSignatures().length === 0 &&\n        type.getStringIndexType() === undefined &&\n        type.getNumberIndexType() === undefined) {\n        const baseTypes = type.getBaseTypes();\n        return baseTypes === undefined || baseTypes.every(isEmptyObjectType);\n    }\n    return false;\n}\nexports.isEmptyObjectType = isEmptyObjectType;\nfunction removeOptionalityFromType(checker, type) {\n    if (!containsTypeWithFlag(type, ts.TypeFlags.Undefined))\n        return type;\n    const allowsNull = containsTypeWithFlag(type, ts.TypeFlags.Null);\n    type = checker.getNonNullableType(type);\n    return allowsNull ? checker.getNullableType(type, ts.TypeFlags.Null) : type;\n}\nexports.removeOptionalityFromType = removeOptionalityFromType;\nfunction containsTypeWithFlag(type, flag) {\n    for (const t of unionTypeParts(type))\n        if (util_1.isTypeFlagSet(t, flag))\n            return true;\n    return false;\n}\nfunction isTypeAssignableToNumber(checker, type) {\n    return isTypeAssignableTo(checker, type, ts.TypeFlags.NumberLike);\n}\nexports.isTypeAssignableToNumber = isTypeAssignableToNumber;\nfunction isTypeAssignableToString(checker, type) {\n    return isTypeAssignableTo(checker, type, ts.TypeFlags.StringLike);\n}\nexports.isTypeAssignableToString = isTypeAssignableToString;\nfunction isTypeAssignableTo(checker, type, flags) {\n    flags |= ts.TypeFlags.Any;\n    let typeParametersSeen;\n    return (function check(t) {\n        if (type_1.isTypeParameter(t) && t.symbol !== undefined && t.symbol.declarations !== undefined) {\n            if (typeParametersSeen === undefined) {\n                typeParametersSeen = new Set([t]);\n            }\n            else if (!typeParametersSeen.has(t)) {\n                typeParametersSeen.add(t);\n            }\n            else {\n                return false;\n            }\n            const declaration = t.symbol.declarations[0];\n            if (declaration.constraint === undefined)\n                return true;\n            return check(checker.getTypeFromTypeNode(declaration.constraint));\n        }\n        if (type_1.isUnionType(t))\n            return t.types.every(check);\n        if (type_1.isIntersectionType(t))\n            return t.types.some(check);\n        return util_1.isTypeFlagSet(t, flags);\n    })(type);\n}\nfunction getCallSignaturesOfType(type) {\n    if (type_1.isUnionType(type)) {\n        const signatures = [];\n        for (const t of type.types)\n            signatures.push(...getCallSignaturesOfType(t));\n        return signatures;\n    }\n    if (type_1.isIntersectionType(type)) {\n        let signatures;\n        for (const t of type.types) {\n            const sig = getCallSignaturesOfType(t);\n            if (sig.length !== 0) {\n                if (signatures !== undefined)\n                    return [];\n                signatures = sig;\n            }\n        }\n        return signatures === undefined ? [] : signatures;\n    }\n    return type.getCallSignatures();\n}\nexports.getCallSignaturesOfType = getCallSignaturesOfType;\nfunction unionTypeParts(type) {\n    return type_1.isUnionType(type) ? type.types : [type];\n}\nexports.unionTypeParts = unionTypeParts;\nfunction intersectionTypeParts(type) {\n    return type_1.isIntersectionType(type) ? type.types : [type];\n}\nexports.intersectionTypeParts = intersectionTypeParts;\nfunction someTypePart(type, predicate, cb) {\n    return predicate(type) ? type.types.some(cb) : cb(type);\n}\nexports.someTypePart = someTypePart;\nfunction isThenableType(checker, node, type = checker.getTypeAtLocation(node)) {\n    for (const ty of unionTypeParts(checker.getApparentType(type))) {\n        const then = ty.getProperty('then');\n        if (then === undefined)\n            continue;\n        const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n        for (const t of unionTypeParts(thenType))\n            for (const signature of t.getCallSignatures())\n                if (signature.parameters.length !== 0 && isCallback(checker, signature.parameters[0], node))\n                    return true;\n    }\n    return false;\n}\nexports.isThenableType = isThenableType;\nfunction isCallback(checker, param, node) {\n    let type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n    if (param.valueDeclaration.dotDotDotToken) {\n        type = type.getNumberIndexType();\n        if (type === undefined)\n            return false;\n    }\n    for (const t of unionTypeParts(type))\n        if (t.getCallSignatures().length !== 0)\n            return true;\n    return false;\n}\nfunction isFalsyType(type) {\n    if (type.flags & (ts.TypeFlags.Undefined | ts.TypeFlags.Null | ts.TypeFlags.Void))\n        return true;\n    if (type_1.isLiteralType(type))\n        return !type.value;\n    return isBooleanLiteralType(type, false);\n}\nexports.isFalsyType = isFalsyType;\nfunction isBooleanLiteralType(type, literal) {\n    return util_1.isTypeFlagSet(type, ts.TypeFlags.BooleanLiteral) &&\n        type.intrinsicName === (literal ? 'true' : 'false');\n}\nexports.isBooleanLiteralType = isBooleanLiteralType;\nfunction getPropertyOfType(type, name) {\n    if (!name.startsWith('__'))\n        return type.getProperty(name);\n    return type.getProperties().find((s) => s.escapedName === name);\n}\nexports.getPropertyOfType = getPropertyOfType;\nfunction isPropertyReadonlyInType(type, name, checker) {\n    let seenProperty = false;\n    let seenReadonlySignature = false;\n    for (const t of unionTypeParts(type)) {\n        if (getPropertyOfType(t, name) === undefined) {\n            const index = (util_1.isNumericPropertyName(name) ? checker.getIndexInfoOfType(t, ts.IndexKind.Number) : undefined) ||\n                checker.getIndexInfoOfType(t, ts.IndexKind.String);\n            if (index !== undefined && index.isReadonly) {\n                if (seenProperty)\n                    return true;\n                seenReadonlySignature = true;\n            }\n        }\n        else if (seenReadonlySignature || isReadonlyPropertyIntersection(t, name, checker)) {\n            return true;\n        }\n        else {\n            seenProperty = true;\n        }\n    }\n    return false;\n}\nexports.isPropertyReadonlyInType = isPropertyReadonlyInType;\nfunction isReadonlyPropertyIntersection(type, name, checker) {\n    return someTypePart(type, type_1.isIntersectionType, (t) => {\n        const prop = getPropertyOfType(t, name);\n        if (prop === undefined)\n            return false;\n        if (prop.flags & ts.SymbolFlags.Transient) {\n            if (/^(?:[1-9]\\d*|0)$/.test(name) && type_1.isTupleTypeReference(t))\n                return t.target.readonly;\n            switch (isReadonlyPropertyFromMappedType(t, name, checker)) {\n                case true:\n                    return true;\n                case false:\n                    return false;\n                default:\n            }\n        }\n        return (util_1.isSymbolFlagSet(prop, ts.SymbolFlags.ValueModule) ||\n            symbolHasReadonlyDeclaration(prop, checker));\n    });\n}\nfunction isReadonlyPropertyFromMappedType(type, name, checker) {\n    if (!type_1.isObjectType(type) || !util_1.isObjectFlagSet(type, ts.ObjectFlags.Mapped))\n        return;\n    const declaration = type.symbol.declarations[0];\n    if (declaration.readonlyToken !== undefined && !/^__@[^@]+$/.test(name))\n        return declaration.readonlyToken.kind !== ts.SyntaxKind.MinusToken;\n    return isPropertyReadonlyInType(type.modifiersType, name, checker);\n}\nfunction symbolHasReadonlyDeclaration(symbol, checker) {\n    return (symbol.flags & ts.SymbolFlags.Accessor) === ts.SymbolFlags.GetAccessor ||\n        symbol.declarations !== undefined &&\n            symbol.declarations.some((node) => util_1.isModifierFlagSet(node, ts.ModifierFlags.Readonly) ||\n                node_1.isVariableDeclaration(node) && util_1.isNodeFlagSet(node.parent, ts.NodeFlags.Const) ||\n                node_1.isCallExpression(node) && util_1.isReadonlyAssignmentDeclaration(node, checker) ||\n                node_1.isEnumMember(node) ||\n                (node_1.isPropertyAssignment(node) || node_1.isShorthandPropertyAssignment(node)) && util_1.isInConstContext(node.parent));\n}\nexports.symbolHasReadonlyDeclaration = symbolHasReadonlyDeclaration;\nfunction getPropertyNameFromType(type) {\n    if (type.flags & (ts.TypeFlags.StringLiteral | ts.TypeFlags.NumberLiteral)) {\n        const value = String(type.value);\n        return { displayName: value, symbolName: ts.escapeLeadingUnderscores(value) };\n    }\n    if (type_1.isUniqueESSymbolType(type))\n        return {\n            displayName: `[${type.symbol ? type.symbol.name : type.escapedName.replace(/^__@|@\\d+$/g, '')}]`,\n            symbolName: type.escapedName,\n        };\n}\nexports.getPropertyNameFromType = getPropertyNameFromType;\nfunction getConstructorTypeOfClassLikeDeclaration(node, checker) {\n    return checker.getDeclaredTypeOfSymbol(node.name !== undefined ? checker.getSymbolAtLocation(node.name) : checker.getTypeAtLocation(node).symbol);\n}\nexports.getConstructorTypeOfClassLikeDeclaration = getConstructorTypeOfClassLikeDeclaration;\nfunction getInstanceTypeOfClassLikeDeclaration(node, checker) {\n    return node.kind === ts.SyntaxKind.ClassDeclaration\n        ? checker.getTypeAtLocation(node)\n        : checker.getTypeOfSymbolAtLocation(checker.getTypeAtLocation(node).getProperty('prototype'), node);\n}\nexports.getInstanceTypeOfClassLikeDeclaration = getInstanceTypeOfClassLikeDeclaration;\nfunction getIteratorYieldResultFromIteratorResult(type, node, checker) {\n    return type_1.isUnionType(type) && type.types.find((t) => {\n        const done = t.getProperty('done');\n        return done !== undefined &&\n            isBooleanLiteralType(removeOptionalityFromType(checker, checker.getTypeOfSymbolAtLocation(done, node)), false);\n    }) || type;\n}\nexports.getIteratorYieldResultFromIteratorResult = getIteratorYieldResultFromIteratorResult;\n"]},"metadata":{},"sourceType":"script"}