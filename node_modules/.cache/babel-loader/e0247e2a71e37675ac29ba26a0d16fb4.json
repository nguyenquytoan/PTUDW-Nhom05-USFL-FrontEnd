{"ast":null,"code":"'use strict';\n\nvar camelcase = require('camelcase');\n\nvar debugMessage = require('./debug-message'),\n    toRegExp = require('./to-reg-exp'),\n    throwErrors = require('./throw-errors'),\n    decodeSourcesWith = require('./decode-sources-with'),\n    locateRootWith = require('./locate-root-with'),\n    encodeSourcesWith = require('./encode-sources-with'),\n    testCodec = require('./test-codec');\n\nvar CODECS = require('../../codec');\n/**\n * Process the given source-map per the given options.\n * @param {{resourcePath:string, context:string, output:{path:string}}} context A loader or compilation\n * @param {{debug:boolean, fail:boolean, format:string|boolean, root:string, codecs:object}} opt Options hash\n * @param {object|string} sourceMapOrSource An incoming source-map or single source path\n * @returns {undefined|object|string} An amended source-map or source path else undefined\n */\n\n\nfunction process(context, opt, sourceMapOrSource) {\n  // default options\n  var options = Object.assign({\n    sep: '/',\n    debug: false,\n    fail: false,\n    format: false,\n    root: false,\n    codecs: CODECS\n  }, opt); // validate codecs\n\n  var codecs = options.codecs.filter(testCodec); // determine what is present\n\n  var inputMap = !!sourceMapOrSource && typeof sourceMapOrSource === 'object' && sourceMapOrSource,\n      inputPath = typeof sourceMapOrSource === 'string' && sourceMapOrSource,\n      inputSources = inputMap && inputMap.sources || inputPath && [inputPath]; // what we need to produce\n\n  var absoluteSources, outputSources, outputRoot, outputMap;\n\n  if (inputSources) {\n    // decode each source with the first valid codec\n    absoluteSources = inputSources.map(decodeSourcesWith.call(context, codecs, options.fail)); // check for decode errors\n\n    throwErrors(context.resourcePath, absoluteSources); // output map is a copy unless absent or we are removing\n\n    outputMap = !inputMap || options.format === 'remove' ? undefined : Object.assign({}, inputMap); // some change in format\n\n    if (options.format) {\n      // find the specified codec in the codecs list\n      var codec = codecs.filter(testNamedCodec).pop();\n\n      if (!codec) {\n        throw new Error('Specified format \"' + options.format + '\" does not match any available codec.');\n      } // use the encoder where specified in 'format'\n\n\n      outputSources = absoluteSources.map(encodeSourcesWith.call(context, codec)).map(insertAbstractSources).map(convertPathSep);\n      outputRoot = !!options.root && locateRootWith.call(context, codec)() || undefined; // check for encode errors\n\n      throwErrors(context.resourcePath, outputSources.concat(outputRoot)); // commit the change\n\n      if (outputMap) {\n        outputMap.sources = outputSources;\n        outputMap.sourceRoot = outputRoot;\n      }\n    }\n  } // debugging information\n\n\n  var isDebug = toRegExp(options.debug).test(context.resourcePath);\n\n  if (isDebug) {\n    console.log(debugMessage(context, {\n      input: inputSources,\n      absolute: absoluteSources,\n      output: outputSources,\n      root: outputRoot\n    }));\n  } // complete\n\n\n  return inputMap ? outputMap : outputSources ? outputSources[0] : undefined;\n\n  function testNamedCodec(value) {\n    return camelcase(value.name) === options.format;\n  }\n\n  function insertAbstractSources(value, i) {\n    return value || inputSources[i];\n  }\n\n  function convertPathSep(value) {\n    return value instanceof Error ? value : value.replace(/[\\\\\\/]/g, options.sep);\n  }\n}\n\nmodule.exports = process;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/adjust-sourcemap-loader/lib/process/index.js"],"names":["camelcase","require","debugMessage","toRegExp","throwErrors","decodeSourcesWith","locateRootWith","encodeSourcesWith","testCodec","CODECS","process","context","opt","sourceMapOrSource","options","Object","assign","sep","debug","fail","format","root","codecs","filter","inputMap","inputPath","inputSources","sources","absoluteSources","outputSources","outputRoot","outputMap","map","call","resourcePath","undefined","codec","testNamedCodec","pop","Error","insertAbstractSources","convertPathSep","concat","sourceRoot","isDebug","test","console","log","input","absolute","output","value","name","i","replace","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar camelcase = require('camelcase');\n\nvar debugMessage      = require('./debug-message'),\n    toRegExp          = require('./to-reg-exp'),\n    throwErrors       = require('./throw-errors'),\n    decodeSourcesWith = require('./decode-sources-with'),\n    locateRootWith    = require('./locate-root-with'),\n    encodeSourcesWith = require('./encode-sources-with'),\n    testCodec         = require('./test-codec');\n\nvar CODECS = require('../../codec');\n\n/**\n * Process the given source-map per the given options.\n * @param {{resourcePath:string, context:string, output:{path:string}}} context A loader or compilation\n * @param {{debug:boolean, fail:boolean, format:string|boolean, root:string, codecs:object}} opt Options hash\n * @param {object|string} sourceMapOrSource An incoming source-map or single source path\n * @returns {undefined|object|string} An amended source-map or source path else undefined\n */\nfunction process(context, opt, sourceMapOrSource) {\n\n  // default options\n  var options = Object.assign({\n    sep   : '/',\n    debug : false,\n    fail  : false,\n    format: false,\n    root  : false,\n    codecs: CODECS\n  }, opt);\n\n  // validate codecs\n  var codecs = options.codecs\n    .filter(testCodec);\n\n  // determine what is present\n  var inputMap     = !!sourceMapOrSource && (typeof sourceMapOrSource === 'object') && sourceMapOrSource,\n      inputPath    = (typeof sourceMapOrSource === 'string') && sourceMapOrSource,\n      inputSources = inputMap && inputMap.sources || inputPath && [inputPath];\n\n  // what we need to produce\n  var absoluteSources,\n      outputSources,\n      outputRoot,\n      outputMap;\n\n  if (inputSources) {\n\n    // decode each source with the first valid codec\n    absoluteSources = inputSources\n      .map(decodeSourcesWith.call(context, codecs, options.fail));\n\n    // check for decode errors\n    throwErrors(context.resourcePath, absoluteSources);\n\n    // output map is a copy unless absent or we are removing\n    outputMap = (!inputMap || (options.format === 'remove')) ? undefined : Object.assign({}, inputMap);\n\n    // some change in format\n    if (options.format) {\n\n      // find the specified codec in the codecs list\n      var codec = codecs\n        .filter(testNamedCodec)\n        .pop();\n\n      if (!codec) {\n        throw new Error('Specified format \"' + options.format + '\" does not match any available codec.');\n      }\n\n      // use the encoder where specified in 'format'\n      outputSources = absoluteSources\n        .map(encodeSourcesWith.call(context, codec))\n        .map(insertAbstractSources)\n        .map(convertPathSep);\n\n      outputRoot = !!options.root && locateRootWith.call(context, codec)() || undefined;\n\n      // check for encode errors\n      throwErrors(context.resourcePath, outputSources.concat(outputRoot));\n\n      // commit the change\n      if (outputMap) {\n        outputMap.sources = outputSources;\n        outputMap.sourceRoot = outputRoot;\n      }\n    }\n  }\n\n  // debugging information\n  var isDebug = toRegExp(options.debug).test(context.resourcePath);\n  if (isDebug) {\n    console.log(debugMessage(context, {\n      input   : inputSources,\n      absolute: absoluteSources,\n      output  : outputSources,\n      root    : outputRoot\n    }));\n  }\n\n  // complete\n  return inputMap ? outputMap : outputSources ? outputSources[0] : undefined;\n\n  function testNamedCodec(value) {\n    return (camelcase(value.name) === options.format);\n  }\n\n  function insertAbstractSources(value, i) {\n    return value || inputSources[i];\n  }\n\n  function convertPathSep(value) {\n    return (value instanceof Error) ? value : value.replace(/[\\\\\\/]/g, options.sep);\n  }\n}\n\nmodule.exports = process;"]},"metadata":{},"sourceType":"script"}