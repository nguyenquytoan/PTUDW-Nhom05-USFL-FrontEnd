{"ast":null,"code":"/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst ALLOW_OPTIONS = Object.freeze([\"functions\", \"arrowFunctions\", \"generatorFunctions\", \"methods\", \"generatorMethods\", \"getters\", \"setters\", \"constructors\"]);\n/**\n * Gets the kind of a given function node.\n * @param {ASTNode} node A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\n\nfunction getKind(node) {\n  const parent = node.parent;\n  let kind = \"\";\n\n  if (node.type === \"ArrowFunctionExpression\") {\n    return \"arrowFunctions\";\n  } // Detects main kind.\n\n\n  if (parent.type === \"Property\") {\n    if (parent.kind === \"get\") {\n      return \"getters\";\n    }\n\n    if (parent.kind === \"set\") {\n      return \"setters\";\n    }\n\n    kind = parent.method ? \"methods\" : \"functions\";\n  } else if (parent.type === \"MethodDefinition\") {\n    if (parent.kind === \"get\") {\n      return \"getters\";\n    }\n\n    if (parent.kind === \"set\") {\n      return \"setters\";\n    }\n\n    if (parent.kind === \"constructor\") {\n      return \"constructors\";\n    }\n\n    kind = \"methods\";\n  } else {\n    kind = \"functions\";\n  } // Detects prefix.\n\n\n  let prefix = \"\";\n\n  if (node.generator) {\n    prefix = \"generator\";\n  } else if (node.async) {\n    prefix = \"async\";\n  } else {\n    return kind;\n  }\n\n  return prefix + kind[0].toUpperCase() + kind.slice(1);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow empty functions\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-empty-function\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOW_OPTIONS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected empty {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowed = options.allow || [];\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports a given function node if the node matches the following patterns.\n     *\n     * - Not allowed by options.\n     * - The body is empty.\n     * - The body doesn't have any comments.\n     * @param {ASTNode} node A function node to report. This is one of\n     *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n     *      FunctionExpression.\n     * @returns {void}\n     */\n\n    function reportIfEmpty(node) {\n      const kind = getKind(node);\n      const name = astUtils.getFunctionNameWithKind(node);\n      const innerComments = sourceCode.getTokens(node.body, {\n        includeComments: true,\n        filter: astUtils.isCommentToken\n      });\n\n      if (allowed.indexOf(kind) === -1 && node.body.type === \"BlockStatement\" && node.body.body.length === 0 && innerComments.length === 0) {\n        context.report({\n          node,\n          loc: node.body.loc.start,\n          messageId: \"unexpected\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: reportIfEmpty,\n      FunctionDeclaration: reportIfEmpty,\n      FunctionExpression: reportIfEmpty\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-empty-function.js"],"names":["astUtils","require","ALLOW_OPTIONS","Object","freeze","getKind","node","parent","kind","type","method","prefix","generator","async","toUpperCase","slice","module","exports","meta","docs","description","category","recommended","url","schema","properties","allow","items","enum","uniqueItems","additionalProperties","messages","unexpected","create","context","options","allowed","sourceCode","getSourceCode","reportIfEmpty","name","getFunctionNameWithKind","innerComments","getTokens","body","includeComments","filter","isCommentToken","indexOf","length","report","loc","start","messageId","data","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\n    \"functions\",\n    \"arrowFunctions\",\n    \"generatorFunctions\",\n    \"methods\",\n    \"generatorMethods\",\n    \"getters\",\n    \"setters\",\n    \"constructors\"\n]);\n\n/**\n * Gets the kind of a given function node.\n * @param {ASTNode} node A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n    const parent = node.parent;\n    let kind = \"\";\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        return \"arrowFunctions\";\n    }\n\n    // Detects main kind.\n    if (parent.type === \"Property\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        kind = parent.method ? \"methods\" : \"functions\";\n\n    } else if (parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        if (parent.kind === \"constructor\") {\n            return \"constructors\";\n        }\n        kind = \"methods\";\n\n    } else {\n        kind = \"functions\";\n    }\n\n    // Detects prefix.\n    let prefix = \"\";\n\n    if (node.generator) {\n        prefix = \"generator\";\n    } else if (node.async) {\n        prefix = \"async\";\n    } else {\n        return kind;\n    }\n    return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow empty functions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-empty-function\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: { enum: ALLOW_OPTIONS },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected empty {{name}}.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given function node if the node matches the following patterns.\n         *\n         * - Not allowed by options.\n         * - The body is empty.\n         * - The body doesn't have any comments.\n         * @param {ASTNode} node A function node to report. This is one of\n         *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n         *      FunctionExpression.\n         * @returns {void}\n         */\n        function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n            const innerComments = sourceCode.getTokens(node.body, {\n                includeComments: true,\n                filter: astUtils.isCommentToken\n            });\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                innerComments.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc.start,\n                    messageId: \"unexpected\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: reportIfEmpty,\n            FunctionDeclaration: reportIfEmpty,\n            FunctionExpression: reportIfEmpty\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}