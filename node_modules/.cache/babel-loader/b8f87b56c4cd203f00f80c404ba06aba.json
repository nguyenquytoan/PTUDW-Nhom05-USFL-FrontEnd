{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst ModuleFilenameHelpers = require('webpack/lib/ModuleFilenameHelpers');\n\nconst getAssetHash = require('./get-asset-hash');\n\nconst resolveWebpackURL = require('./resolve-webpack-url');\n/**\n * A single manifest entry that Workbox can precache.\n * When possible, we leave out the revision information, which tells Workbox\n * that the URL contains enough info to uniquely version the asset.\n *\n * @param {Array<string>} knownHashes All of the hashes that are associated\n * with this webpack build.\n * @param {string} url webpack asset url path\n * @param {string} [revision] A revision hash for the entry\n * @return {module:workbox-build.ManifestEntry} A single manifest entry\n *\n * @private\n */\n\n\nfunction getEntry(knownHashes, url, revision) {\n  // We're assuming that if the URL contains any of the known hashes\n  // (either the short or full chunk hash or compilation hash) then it's\n  // already revisioned, and we don't need additional out-of-band revisioning.\n  if (!revision || knownHashes.some(hash => url.includes(hash))) {\n    return {\n      url\n    };\n  }\n\n  return {\n    revision,\n    url\n  };\n}\n/**\n * Filter to narrow down the asset list to chunks that:\n * - have a name.\n * - if there's a whitelist, the chunk's name is in the whitelist.\n * - if there's a blacklist, the chunk's name is not in the blacklist.\n *\n * TODO:\n *  Filter files by size:\n *    https://github.com/GoogleChrome/workbox/pull/808#discussion_r139606242\n *  Filter files that match `staticFileGlobsIgnorePatterns` (or something)\n *  but filter for [/\\.map$/, /asset-manifest\\.json$/] by default:\n *    https://github.com/GoogleChrome/workbox/pull/808#discussion_r140565156\n *\n * @param {Object<string, Object>} assetMetadata Metadata about the assets.\n * @param {Array<string>} [whitelist] Chunk names to include.\n * @param {Array<string>} [blacklist] Chunk names to exclude.\n * @return {Object<string, Object>} Filtered asset metadata.\n *\n * @private\n */\n\n\nfunction filterAssets(assetMetadata, whitelist, blacklist) {\n  const filteredMapping = {};\n\n  var _arr = Object.entries(assetMetadata);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    const _arr$_i = (0, _slicedToArray2.default)(_arr[_i], 2),\n          file = _arr$_i[0],\n          metadata = _arr$_i[1];\n\n    const chunkName = metadata.chunkName; // This file is whitelisted if:\n    // - Trivially, if there is no whitelist defined.\n    // - There is a whitelist and our file is associated with a chunk whose name\n    // is listed.\n\n    const isWhitelisted = whitelist.length === 0 || whitelist.includes(chunkName); // This file is blacklisted if our file is associated with a chunk whose\n    // name is listed.\n\n    const isBlacklisted = blacklist.includes(chunkName); // Only include this entry in the filtered mapping if we're whitelisted and\n    // not blacklisted.\n\n    if (isWhitelisted && !isBlacklisted) {\n      filteredMapping[file] = metadata;\n    }\n  }\n\n  return filteredMapping;\n}\n/**\n * Takes in compilation.assets and compilation.chunks, and assigns metadata\n * to each file listed in assets:\n *\n * - If the asset was created by a chunk, it assigns the existing chunk name and\n * chunk hash.\n * - If the asset was created outside of a chunk, it assigns a chunk name of ''\n * and generates a hash of the asset.\n *\n * @param {Object} assets The compilation.assets\n * @param {Array<Object>} chunks The compilation.chunks\n * @return {Object<string, Object>} Mapping of asset paths to chunk name and\n * hash metadata.\n *\n * @private\n */\n\n\nfunction generateMetadataForAssets(assets, chunks) {\n  const mapping = {}; // Start out by getting metadata for all the assets associated with a chunk.\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const chunk = _step.value;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = chunk.files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          const file = _step2.value;\n          mapping[file] = {\n            chunkName: chunk.name,\n            hash: chunk.renderedHash\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } // Next, loop through the total list of assets and find anything that isn't\n    // associated with a chunk.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _arr2 = Object.entries(assets);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    const _arr2$_i = (0, _slicedToArray2.default)(_arr2[_i2], 2),\n          file = _arr2$_i[0],\n          asset = _arr2$_i[1];\n\n    if (file in mapping) {\n      continue;\n    }\n\n    mapping[file] = {\n      // Just use an empty string to denote the lack of chunk association.\n      chunkName: '',\n      hash: getAssetHash(asset)\n    };\n  }\n\n  return mapping;\n}\n/**\n * Given an assetMetadata mapping, returns a Set of all of the hashes that\n * are associated with at least one asset.\n *\n * @param {Object<string, Object>} assetMetadata Mapping of asset paths to chunk\n * name and hash metadata.\n * @return {Set} The known hashes associated with an asset.\n *\n * @private\n */\n\n\nfunction getKnownHashesFromAssets(assetMetadata) {\n  const knownHashes = new Set();\n\n  var _arr3 = Object.values(assetMetadata);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    const metadata = _arr3[_i3];\n    knownHashes.add(metadata.hash);\n  }\n\n  return knownHashes;\n}\n/**\n * Generate an array of manifest entries using webpack's compilation data.\n *\n * @param {Object} compilation webpack compilation\n * @param {Object} config\n * @return {Array<workbox.build.ManifestEntry>}\n *\n * @private\n */\n\n\nfunction getManifestEntriesFromCompilation(compilation, config) {\n  const blacklistedChunkNames = config.excludeChunks;\n  const whitelistedChunkNames = config.chunks;\n  const assets = compilation.assets,\n        chunks = compilation.chunks;\n  const publicPath = compilation.options.output.publicPath;\n  const assetMetadata = generateMetadataForAssets(assets, chunks);\n  const filteredAssetMetadata = filterAssets(assetMetadata, whitelistedChunkNames, blacklistedChunkNames);\n  const knownHashes = [compilation.hash, compilation.fullHash, ...getKnownHashesFromAssets(filteredAssetMetadata)].filter(hash => !!hash);\n  const manifestEntries = [];\n\n  var _arr4 = Object.entries(filteredAssetMetadata);\n\n  for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n    const _arr4$_i = (0, _slicedToArray2.default)(_arr4[_i4], 2),\n          file = _arr4$_i[0],\n          metadata = _arr4$_i[1]; // Filter based on test/include/exclude options set in the config,\n    // following webpack's conventions.\n    // This matches the behavior of, e.g., UglifyJS's webpack plugin.\n\n\n    if (!ModuleFilenameHelpers.matchObject(config, file)) {\n      continue;\n    }\n\n    const publicURL = resolveWebpackURL(publicPath, file);\n    const manifestEntry = getEntry(knownHashes, publicURL, metadata.hash);\n    manifestEntries.push(manifestEntry);\n  }\n\n  return manifestEntries;\n}\n\nmodule.exports = getManifestEntriesFromCompilation;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-webpack-plugin/build/lib/get-manifest-entries-from-compilation.js"],"names":["_interopRequireDefault","require","_slicedToArray2","ModuleFilenameHelpers","getAssetHash","resolveWebpackURL","getEntry","knownHashes","url","revision","some","hash","includes","filterAssets","assetMetadata","whitelist","blacklist","filteredMapping","_arr","Object","entries","_i","length","_arr$_i","default","file","metadata","chunkName","isWhitelisted","isBlacklisted","generateMetadataForAssets","assets","chunks","mapping","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","chunk","value","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","files","_step2","name","renderedHash","err","return","_arr2","_i2","_arr2$_i","asset","getKnownHashesFromAssets","Set","_arr3","values","_i3","add","getManifestEntriesFromCompilation","compilation","config","blacklistedChunkNames","excludeChunks","whitelistedChunkNames","publicPath","options","output","filteredAssetMetadata","fullHash","filter","manifestEntries","_arr4","_i4","_arr4$_i","matchObject","publicURL","manifestEntry","push","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst ModuleFilenameHelpers = require('webpack/lib/ModuleFilenameHelpers');\n\nconst getAssetHash = require('./get-asset-hash');\n\nconst resolveWebpackURL = require('./resolve-webpack-url');\n/**\n * A single manifest entry that Workbox can precache.\n * When possible, we leave out the revision information, which tells Workbox\n * that the URL contains enough info to uniquely version the asset.\n *\n * @param {Array<string>} knownHashes All of the hashes that are associated\n * with this webpack build.\n * @param {string} url webpack asset url path\n * @param {string} [revision] A revision hash for the entry\n * @return {module:workbox-build.ManifestEntry} A single manifest entry\n *\n * @private\n */\n\n\nfunction getEntry(knownHashes, url, revision) {\n  // We're assuming that if the URL contains any of the known hashes\n  // (either the short or full chunk hash or compilation hash) then it's\n  // already revisioned, and we don't need additional out-of-band revisioning.\n  if (!revision || knownHashes.some(hash => url.includes(hash))) {\n    return {\n      url\n    };\n  }\n\n  return {\n    revision,\n    url\n  };\n}\n/**\n * Filter to narrow down the asset list to chunks that:\n * - have a name.\n * - if there's a whitelist, the chunk's name is in the whitelist.\n * - if there's a blacklist, the chunk's name is not in the blacklist.\n *\n * TODO:\n *  Filter files by size:\n *    https://github.com/GoogleChrome/workbox/pull/808#discussion_r139606242\n *  Filter files that match `staticFileGlobsIgnorePatterns` (or something)\n *  but filter for [/\\.map$/, /asset-manifest\\.json$/] by default:\n *    https://github.com/GoogleChrome/workbox/pull/808#discussion_r140565156\n *\n * @param {Object<string, Object>} assetMetadata Metadata about the assets.\n * @param {Array<string>} [whitelist] Chunk names to include.\n * @param {Array<string>} [blacklist] Chunk names to exclude.\n * @return {Object<string, Object>} Filtered asset metadata.\n *\n * @private\n */\n\n\nfunction filterAssets(assetMetadata, whitelist, blacklist) {\n  const filteredMapping = {};\n\n  var _arr = Object.entries(assetMetadata);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    const _arr$_i = (0, _slicedToArray2.default)(_arr[_i], 2),\n          file = _arr$_i[0],\n          metadata = _arr$_i[1];\n\n    const chunkName = metadata.chunkName; // This file is whitelisted if:\n    // - Trivially, if there is no whitelist defined.\n    // - There is a whitelist and our file is associated with a chunk whose name\n    // is listed.\n\n    const isWhitelisted = whitelist.length === 0 || whitelist.includes(chunkName); // This file is blacklisted if our file is associated with a chunk whose\n    // name is listed.\n\n    const isBlacklisted = blacklist.includes(chunkName); // Only include this entry in the filtered mapping if we're whitelisted and\n    // not blacklisted.\n\n    if (isWhitelisted && !isBlacklisted) {\n      filteredMapping[file] = metadata;\n    }\n  }\n\n  return filteredMapping;\n}\n/**\n * Takes in compilation.assets and compilation.chunks, and assigns metadata\n * to each file listed in assets:\n *\n * - If the asset was created by a chunk, it assigns the existing chunk name and\n * chunk hash.\n * - If the asset was created outside of a chunk, it assigns a chunk name of ''\n * and generates a hash of the asset.\n *\n * @param {Object} assets The compilation.assets\n * @param {Array<Object>} chunks The compilation.chunks\n * @return {Object<string, Object>} Mapping of asset paths to chunk name and\n * hash metadata.\n *\n * @private\n */\n\n\nfunction generateMetadataForAssets(assets, chunks) {\n  const mapping = {}; // Start out by getting metadata for all the assets associated with a chunk.\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const chunk = _step.value;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = chunk.files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          const file = _step2.value;\n          mapping[file] = {\n            chunkName: chunk.name,\n            hash: chunk.renderedHash\n          };\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } // Next, loop through the total list of assets and find anything that isn't\n    // associated with a chunk.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _arr2 = Object.entries(assets);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    const _arr2$_i = (0, _slicedToArray2.default)(_arr2[_i2], 2),\n          file = _arr2$_i[0],\n          asset = _arr2$_i[1];\n\n    if (file in mapping) {\n      continue;\n    }\n\n    mapping[file] = {\n      // Just use an empty string to denote the lack of chunk association.\n      chunkName: '',\n      hash: getAssetHash(asset)\n    };\n  }\n\n  return mapping;\n}\n/**\n * Given an assetMetadata mapping, returns a Set of all of the hashes that\n * are associated with at least one asset.\n *\n * @param {Object<string, Object>} assetMetadata Mapping of asset paths to chunk\n * name and hash metadata.\n * @return {Set} The known hashes associated with an asset.\n *\n * @private\n */\n\n\nfunction getKnownHashesFromAssets(assetMetadata) {\n  const knownHashes = new Set();\n\n  var _arr3 = Object.values(assetMetadata);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    const metadata = _arr3[_i3];\n    knownHashes.add(metadata.hash);\n  }\n\n  return knownHashes;\n}\n/**\n * Generate an array of manifest entries using webpack's compilation data.\n *\n * @param {Object} compilation webpack compilation\n * @param {Object} config\n * @return {Array<workbox.build.ManifestEntry>}\n *\n * @private\n */\n\n\nfunction getManifestEntriesFromCompilation(compilation, config) {\n  const blacklistedChunkNames = config.excludeChunks;\n  const whitelistedChunkNames = config.chunks;\n  const assets = compilation.assets,\n        chunks = compilation.chunks;\n  const publicPath = compilation.options.output.publicPath;\n  const assetMetadata = generateMetadataForAssets(assets, chunks);\n  const filteredAssetMetadata = filterAssets(assetMetadata, whitelistedChunkNames, blacklistedChunkNames);\n  const knownHashes = [compilation.hash, compilation.fullHash, ...getKnownHashesFromAssets(filteredAssetMetadata)].filter(hash => !!hash);\n  const manifestEntries = [];\n\n  var _arr4 = Object.entries(filteredAssetMetadata);\n\n  for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n    const _arr4$_i = (0, _slicedToArray2.default)(_arr4[_i4], 2),\n          file = _arr4$_i[0],\n          metadata = _arr4$_i[1];\n\n    // Filter based on test/include/exclude options set in the config,\n    // following webpack's conventions.\n    // This matches the behavior of, e.g., UglifyJS's webpack plugin.\n    if (!ModuleFilenameHelpers.matchObject(config, file)) {\n      continue;\n    }\n\n    const publicURL = resolveWebpackURL(publicPath, file);\n    const manifestEntry = getEntry(knownHashes, publicURL, metadata.hash);\n    manifestEntries.push(manifestEntry);\n  }\n\n  return manifestEntries;\n}\n\nmodule.exports = getManifestEntriesFromCompilation;"]},"metadata":{},"sourceType":"script"}