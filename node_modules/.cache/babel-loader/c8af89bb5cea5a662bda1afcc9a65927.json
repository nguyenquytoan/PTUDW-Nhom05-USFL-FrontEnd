{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n/*!\n * XRegExp Unicode Base 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\n\n\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    (0, _forEach.default)(XRegExp).call(XRegExp, range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      var _context;\n\n      combined = (0, _concat.default)(_context = \"[\".concat(item.bmp, \"]\")).call(_context, item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      var _context2;\n\n      combined += (0, _concat.default)(_context2 = \"\".concat(item.astral ? '|' : '', \"[\")).call(_context2, item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = (0, _includes.default)(flags).call(flags, 'A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    var slug = normalize(match[4] || match[3]); // Token data object\n\n    var item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        var _context3;\n\n        throw new ReferenceError((0, _concat.default)(_context3 = \"\".concat(ERR_UNKNOWN_REF + match[0], \" -> \")).call(_context3, item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator2.default)(data), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        unicode[normalize(item.name)] = item;\n\n        if (item.alias) {\n          unicode[normalize(item.alias)] = item;\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/lib/addons/unicode-base.js"],"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_getIterator2","_includes","_concat","_forEach","_default","XRegExp","unicode","dec","_dec","hex","_hex","pad4","_pad4","normalize","name","replace","toLowerCase","charCode","chr","esc","exec","charCodeAt","invertBmp","range","output","lastEnd","call","m","start","concat","cacheInvertedBmp","slug","prop","bmp","buildAstral","isNegated","item","combined","isBmpLast","_context","astral","_context2","cacheAstral","addToken","match","scope","flags","ERR_DOUBLE_NEG","ERR_UNKNOWN_NAME","ERR_UNKNOWN_REF","ERR_ASTRAL_ONLY","ERR_ASTRAL_IN_CLASS","isAstralMode","SyntaxError","hasOwnProperty","inverseOf","_context3","ReferenceError","optionalFlags","leadChar","addUnicodeData","data","ERR_NO_NAME","ERR_NO_DATA","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","Error","alias","err","return","cache","flush","_getUnicodeProperty","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\n/*!\n * XRegExp Unicode Base 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    (0, _forEach.default)(XRegExp).call(XRegExp, range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      var _context;\n\n      combined = (0, _concat.default)(_context = \"[\".concat(item.bmp, \"]\")).call(_context, item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      var _context2;\n\n      combined += (0, _concat.default)(_context2 = \"\".concat(item.astral ? '|' : '', \"[\")).call(_context2, item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = (0, _includes.default)(flags).call(flags, 'A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    var slug = normalize(match[4] || match[3]); // Token data object\n\n    var item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        var _context3;\n\n        throw new ReferenceError((0, _concat.default)(_context3 = \"\".concat(ERR_UNKNOWN_REF + match[0], \" -> \")).call(_context3, item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator2.default)(data), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        unicode[normalize(item.name)] = item;\n\n        if (item.alias) {\n          unicode[normalize(item.alias)] = item;\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}