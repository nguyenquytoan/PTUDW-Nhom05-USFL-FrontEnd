{"ast":null,"code":"'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nvar parseCst = require('./parse-cst.js');\n\nrequire('./resolveSeq-4a68b39b.js');\n\nvar Document$1 = require('./Document-2cf6b08c.js');\n\nvar Schema = require('./Schema-42e9705c.js');\n\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\nexports.YAML = YAML;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/yaml/dist/index.js"],"names":["PlainValue","require","parseCst","Document$1","Schema","warnings","createNode","value","wrapScalars","tag","undefined","options","Object","assign","Document","defaults","defaultOptions","version","schema","constructor","parseAllDocuments","src","stream","prev","cstDoc","parse","doc","push","parseDocument","cst","length","errMsg","errors","unshift","YAMLSemanticError","forEach","warning","warn","toJSON","stringify","contents","String","YAML","parseCST","scalarOptions","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar parseCst = require('./parse-cst.js');\nrequire('./resolveSeq-4a68b39b.js');\nvar Document$1 = require('./Document-2cf6b08c.js');\nvar Schema = require('./Schema-42e9705c.js');\nvar warnings = require('./warnings-39684f17.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n"]},"metadata":{},"sourceType":"script"}