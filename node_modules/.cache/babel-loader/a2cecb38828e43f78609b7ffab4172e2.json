{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"sourceMap\"] = factory();else root[\"sourceMap\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /*\n       * Copyright 2009-2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE.txt or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.SourceMapGenerator = __webpack_require__(1).SourceMapGenerator;\n      exports.SourceMapConsumer = __webpack_require__(7).SourceMapConsumer;\n      exports.SourceNode = __webpack_require__(10).SourceNode;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var base64VLQ = __webpack_require__(2);\n\n      var util = __webpack_require__(4);\n\n      var ArraySet = __webpack_require__(5).ArraySet;\n\n      var MappingList = __webpack_require__(6).MappingList;\n      /**\n       * An instance of the SourceMapGenerator represents a source map which is\n       * being built incrementally. You may pass an object with the following\n       * properties:\n       *\n       *   - file: The filename of the generated source.\n       *   - sourceRoot: A root for all relative URLs in this source map.\n       */\n\n\n      function SourceMapGenerator(aArgs) {\n        if (!aArgs) {\n          aArgs = {};\n        }\n\n        this._file = util.getArg(aArgs, 'file', null);\n        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        this._mappings = new MappingList();\n        this._sourcesContents = null;\n      }\n\n      SourceMapGenerator.prototype._version = 3;\n      /**\n       * Creates a new SourceMapGenerator based on a SourceMapConsumer\n       *\n       * @param aSourceMapConsumer The SourceMap.\n       */\n\n      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n          file: aSourceMapConsumer.file,\n          sourceRoot: sourceRoot\n        });\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          var newMapping = {\n            generated: {\n              line: mapping.generatedLine,\n              column: mapping.generatedColumn\n            }\n          };\n\n          if (mapping.source != null) {\n            newMapping.source = mapping.source;\n\n            if (sourceRoot != null) {\n              newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n\n            newMapping.original = {\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            };\n\n            if (mapping.name != null) {\n              newMapping.name = mapping.name;\n            }\n          }\n\n          generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var sourceRelative = sourceFile;\n\n          if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n          }\n\n          if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n          }\n\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n          }\n        });\n        return generator;\n      };\n      /**\n       * Add a single mapping from original source line and column to the generated\n       * source's line and column for this source map being created. The mapping\n       * object should have the following properties:\n       *\n       *   - generated: An object with the generated line and column positions.\n       *   - original: An object with the original line and column positions.\n       *   - source: The original source file (relative to the sourceRoot).\n       *   - name: An optional original token name for this mapping.\n       */\n\n\n      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n        var generated = util.getArg(aArgs, 'generated');\n        var original = util.getArg(aArgs, 'original', null);\n        var source = util.getArg(aArgs, 'source', null);\n        var name = util.getArg(aArgs, 'name', null);\n\n        if (!this._skipValidation) {\n          this._validateMapping(generated, original, source, name);\n        }\n\n        if (source != null) {\n          source = String(source);\n\n          if (!this._sources.has(source)) {\n            this._sources.add(source);\n          }\n        }\n\n        if (name != null) {\n          name = String(name);\n\n          if (!this._names.has(name)) {\n            this._names.add(name);\n          }\n        }\n\n        this._mappings.add({\n          generatedLine: generated.line,\n          generatedColumn: generated.column,\n          originalLine: original != null && original.line,\n          originalColumn: original != null && original.column,\n          source: source,\n          name: name\n        });\n      };\n      /**\n       * Set the source content for a source file.\n       */\n\n\n      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n\n        if (this._sourceRoot != null) {\n          source = util.relative(this._sourceRoot, source);\n        }\n\n        if (aSourceContent != null) {\n          // Add the source content to the _sourcesContents map.\n          // Create a new _sourcesContents map if the property is null.\n          if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n          }\n\n          this._sourcesContents[util.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n          // Remove the source file from the _sourcesContents map.\n          // If the _sourcesContents map is empty, set the property to null.\n          delete this._sourcesContents[util.toSetString(source)];\n\n          if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n          }\n        }\n      };\n      /**\n       * Applies the mappings of a sub-source-map for a specific source file to the\n       * source map being generated. Each mapping to the supplied source file is\n       * rewritten using the supplied source map. Note: The resolution for the\n       * resulting mappings is the minimium of this map and the supplied map.\n       *\n       * @param aSourceMapConsumer The source map to be applied.\n       * @param aSourceFile Optional. The filename of the source file.\n       *        If omitted, SourceMapConsumer's file property will be used.\n       * @param aSourceMapPath Optional. The dirname of the path to the source map\n       *        to be applied. If relative, it is relative to the SourceMapConsumer.\n       *        This parameter is needed when the two source maps aren't in the same\n       *        directory, and the source map to be applied contains relative source\n       *        paths. If so, those relative source paths need to be rewritten\n       *        relative to the SourceMapGenerator.\n       */\n\n\n      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap\n\n        if (aSourceFile == null) {\n          if (aSourceMapConsumer.file == null) {\n            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n          }\n\n          sourceFile = aSourceMapConsumer.file;\n        }\n\n        var sourceRoot = this._sourceRoot; // Make \"sourceFile\" relative if an absolute Url is passed.\n\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        } // Applying the SourceMap can add and remove items from the sources and\n        // the names array.\n\n\n        var newSources = new ArraySet();\n        var newNames = new ArraySet(); // Find mappings for the \"sourceFile\"\n\n        this._mappings.unsortedForEach(function (mapping) {\n          if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            });\n\n            if (original.source != null) {\n              // Copy mapping\n              mapping.source = original.source;\n\n              if (aSourceMapPath != null) {\n                mapping.source = util.join(aSourceMapPath, mapping.source);\n              }\n\n              if (sourceRoot != null) {\n                mapping.source = util.relative(sourceRoot, mapping.source);\n              }\n\n              mapping.originalLine = original.line;\n              mapping.originalColumn = original.column;\n\n              if (original.name != null) {\n                mapping.name = original.name;\n              }\n            }\n          }\n\n          var source = mapping.source;\n\n          if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n          }\n\n          var name = mapping.name;\n\n          if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n          }\n        }, this);\n\n        this._sources = newSources;\n        this._names = newNames; // Copy sourcesContents of applied map.\n\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            if (aSourceMapPath != null) {\n              sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n\n            if (sourceRoot != null) {\n              sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n\n            this.setSourceContent(sourceFile, content);\n          }\n        }, this);\n      };\n      /**\n       * A mapping can have one of the three levels of data:\n       *\n       *   1. Just the generated position.\n       *   2. The Generated position, original position, and original source.\n       *   3. Generated and original position, original source, as well as a name\n       *      token.\n       *\n       * To maintain consistency, we validate that any new mapping being added falls\n       * in to one of these categories.\n       */\n\n\n      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n        // When aOriginal is truthy but has empty values for .line and .column,\n        // it is most likely a programmer error. In this case we throw a very\n        // specific error message to try to guide them the right way.\n        // For example: https://github.com/Polymer/polymer-bundler/pull/519\n        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n          throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');\n        }\n\n        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n          // Case 1.\n          return;\n        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n          // Cases 2 and 3.\n          return;\n        } else {\n          throw new Error('Invalid mapping: ' + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n          }));\n        }\n      };\n      /**\n       * Serialize the accumulated mappings in to the stream of base 64 VLQs\n       * specified by the source map format.\n       */\n\n\n      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = '';\n        var next;\n        var mapping;\n        var nameIdx;\n        var sourceIdx;\n\n        var mappings = this._mappings.toArray();\n\n        for (var i = 0, len = mappings.length; i < len; i++) {\n          mapping = mappings[i];\n          next = '';\n\n          if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n\n            while (mapping.generatedLine !== previousGeneratedLine) {\n              next += ';';\n              previousGeneratedLine++;\n            }\n          } else {\n            if (i > 0) {\n              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                continue;\n              }\n\n              next += ',';\n            }\n          }\n\n          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n          previousGeneratedColumn = mapping.generatedColumn;\n\n          if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3\n\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n\n            if (mapping.name != null) {\n              nameIdx = this._names.indexOf(mapping.name);\n              next += base64VLQ.encode(nameIdx - previousName);\n              previousName = nameIdx;\n            }\n          }\n\n          result += next;\n        }\n\n        return result;\n      };\n\n      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function (source) {\n          if (!this._sourcesContents) {\n            return null;\n          }\n\n          if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n          }\n\n          var key = util.toSetString(source);\n          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n        }, this);\n      };\n      /**\n       * Externalize the source map.\n       */\n\n\n      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n        var map = {\n          version: this._version,\n          sources: this._sources.toArray(),\n          names: this._names.toArray(),\n          mappings: this._serializeMappings()\n        };\n\n        if (this._file != null) {\n          map.file = this._file;\n        }\n\n        if (this._sourceRoot != null) {\n          map.sourceRoot = this._sourceRoot;\n        }\n\n        if (this._sourcesContents) {\n          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n\n        return map;\n      };\n      /**\n       * Render the source map being generated to a string.\n       */\n\n\n      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n        return JSON.stringify(this.toJSON());\n      };\n\n      exports.SourceMapGenerator = SourceMapGenerator;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       *\n       * Based on the Base 64 VLQ implementation in Closure Compiler:\n       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n       *\n       * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n       * Redistribution and use in source and binary forms, with or without\n       * modification, are permitted provided that the following conditions are\n       * met:\n       *\n       *  * Redistributions of source code must retain the above copyright\n       *    notice, this list of conditions and the following disclaimer.\n       *  * Redistributions in binary form must reproduce the above\n       *    copyright notice, this list of conditions and the following\n       *    disclaimer in the documentation and/or other materials provided\n       *    with the distribution.\n       *  * Neither the name of Google Inc. nor the names of its\n       *    contributors may be used to endorse or promote products derived\n       *    from this software without specific prior written permission.\n       *\n       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n       * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n      var base64 = __webpack_require__(3); // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n      // length quantities we use in the source map spec, the first bit is the sign,\n      // the next four bits are the actual value, and the 6th bit is the\n      // continuation bit. The continuation bit tells us whether there are more\n      // digits in this value following this digit.\n      //\n      //   Continuation\n      //   |    Sign\n      //   |    |\n      //   V    V\n      //   101011\n\n\n      var VLQ_BASE_SHIFT = 5; // binary: 100000\n\n      var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111\n\n      var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000\n\n      var VLQ_CONTINUATION_BIT = VLQ_BASE;\n      /**\n       * Converts from a two-complement value to a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n       */\n\n      function toVLQSigned(aValue) {\n        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n      }\n      /**\n       * Converts to a two-complement value from a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n       */\n\n\n      function fromVLQSigned(aValue) {\n        var isNegative = (aValue & 1) === 1;\n        var shifted = aValue >> 1;\n        return isNegative ? -shifted : shifted;\n      }\n      /**\n       * Returns the base 64 VLQ encoded value.\n       */\n\n\n      exports.encode = function base64VLQ_encode(aValue) {\n        var encoded = \"\";\n        var digit;\n        var vlq = toVLQSigned(aValue);\n\n        do {\n          digit = vlq & VLQ_BASE_MASK;\n          vlq >>>= VLQ_BASE_SHIFT;\n\n          if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n          }\n\n          encoded += base64.encode(digit);\n        } while (vlq > 0);\n\n        return encoded;\n      };\n      /**\n       * Decodes the next base 64 VLQ value from the given string and returns the\n       * value and the rest of the string via the out parameter.\n       */\n\n\n      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n        var strLen = aStr.length;\n        var result = 0;\n        var shift = 0;\n        var continuation, digit;\n\n        do {\n          if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n          }\n\n          digit = base64.decode(aStr.charCodeAt(aIndex++));\n\n          if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n          }\n\n          continuation = !!(digit & VLQ_CONTINUATION_BIT);\n          digit &= VLQ_BASE_MASK;\n          result = result + (digit << shift);\n          shift += VLQ_BASE_SHIFT;\n        } while (continuation);\n\n        aOutParam.value = fromVLQSigned(result);\n        aOutParam.rest = aIndex;\n      };\n      /***/\n\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n      /**\n       * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n       */\n\n      exports.encode = function (number) {\n        if (0 <= number && number < intToCharMap.length) {\n          return intToCharMap[number];\n        }\n\n        throw new TypeError(\"Must be between 0 and 63: \" + number);\n      };\n      /**\n       * Decode a single base 64 character code digit to an integer. Returns -1 on\n       * failure.\n       */\n\n\n      exports.decode = function (charCode) {\n        var bigA = 65; // 'A'\n\n        var bigZ = 90; // 'Z'\n\n        var littleA = 97; // 'a'\n\n        var littleZ = 122; // 'z'\n\n        var zero = 48; // '0'\n\n        var nine = 57; // '9'\n\n        var plus = 43; // '+'\n\n        var slash = 47; // '/'\n\n        var littleOffset = 26;\n        var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n        if (bigA <= charCode && charCode <= bigZ) {\n          return charCode - bigA;\n        } // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\n\n        if (littleA <= charCode && charCode <= littleZ) {\n          return charCode - littleA + littleOffset;\n        } // 52 - 61: 0123456789\n\n\n        if (zero <= charCode && charCode <= nine) {\n          return charCode - zero + numberOffset;\n        } // 62: +\n\n\n        if (charCode == plus) {\n          return 62;\n        } // 63: /\n\n\n        if (charCode == slash) {\n          return 63;\n        } // Invalid base64 digit.\n\n\n        return -1;\n      };\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n\n      /**\n       * This is a helper function for getting values from parameter/options\n       * objects.\n       *\n       * @param args The object we are extracting values from\n       * @param name The name of the property we are getting.\n       * @param defaultValue An optional value to return if the property is missing\n       * from the object. If this is not specified and the property is missing, an\n       * error will be thrown.\n       */\n      function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n          return aArgs[aName];\n        } else if (arguments.length === 3) {\n          return aDefaultValue;\n        } else {\n          throw new Error('\"' + aName + '\" is a required argument.');\n        }\n      }\n\n      exports.getArg = getArg;\n      var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\n      var dataUrlRegexp = /^data:.+\\,.+$/;\n\n      function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n\n        if (!match) {\n          return null;\n        }\n\n        return {\n          scheme: match[1],\n          auth: match[2],\n          host: match[3],\n          port: match[4],\n          path: match[5]\n        };\n      }\n\n      exports.urlParse = urlParse;\n\n      function urlGenerate(aParsedUrl) {\n        var url = '';\n\n        if (aParsedUrl.scheme) {\n          url += aParsedUrl.scheme + ':';\n        }\n\n        url += '//';\n\n        if (aParsedUrl.auth) {\n          url += aParsedUrl.auth + '@';\n        }\n\n        if (aParsedUrl.host) {\n          url += aParsedUrl.host;\n        }\n\n        if (aParsedUrl.port) {\n          url += \":\" + aParsedUrl.port;\n        }\n\n        if (aParsedUrl.path) {\n          url += aParsedUrl.path;\n        }\n\n        return url;\n      }\n\n      exports.urlGenerate = urlGenerate;\n      /**\n       * Normalizes a path, or the path portion of a URL:\n       *\n       * - Replaces consecutive slashes with one slash.\n       * - Removes unnecessary '.' parts.\n       * - Removes unnecessary '<dir>/..' parts.\n       *\n       * Based on code in the Node.js 'path' core module.\n       *\n       * @param aPath The path or url to normalize.\n       */\n\n      function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n\n        if (url) {\n          if (!url.path) {\n            return aPath;\n          }\n\n          path = url.path;\n        }\n\n        var isAbsolute = exports.isAbsolute(path);\n        var parts = path.split(/\\/+/);\n\n        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n          part = parts[i];\n\n          if (part === '.') {\n            parts.splice(i, 1);\n          } else if (part === '..') {\n            up++;\n          } else if (up > 0) {\n            if (part === '') {\n              // The first part is blank if the path is absolute. Trying to go\n              // above the root is a no-op. Therefore we can remove all '..' parts\n              // directly after the root.\n              parts.splice(i + 1, up);\n              up = 0;\n            } else {\n              parts.splice(i, 2);\n              up--;\n            }\n          }\n        }\n\n        path = parts.join('/');\n\n        if (path === '') {\n          path = isAbsolute ? '/' : '.';\n        }\n\n        if (url) {\n          url.path = path;\n          return urlGenerate(url);\n        }\n\n        return path;\n      }\n\n      exports.normalize = normalize;\n      /**\n       * Joins two paths/URLs.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be joined with the root.\n       *\n       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n       *   first.\n       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n       *   is updated with the result and aRoot is returned. Otherwise the result\n       *   is returned.\n       *   - If aPath is absolute, the result is aPath.\n       *   - Otherwise the two paths are joined with a slash.\n       * - Joining for example 'http://' and 'www.example.com' is also supported.\n       */\n\n      function join(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        if (aPath === \"\") {\n          aPath = \".\";\n        }\n\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n\n        if (aRootUrl) {\n          aRoot = aRootUrl.path || '/';\n        } // `join(foo, '//www.example.org')`\n\n\n        if (aPathUrl && !aPathUrl.scheme) {\n          if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n          }\n\n          return urlGenerate(aPathUrl);\n        }\n\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n          return aPath;\n        } // `join('http://', 'www.example.com')`\n\n\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n          aRootUrl.host = aPath;\n          return urlGenerate(aRootUrl);\n        }\n\n        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n        if (aRootUrl) {\n          aRootUrl.path = joined;\n          return urlGenerate(aRootUrl);\n        }\n\n        return joined;\n      }\n\n      exports.join = join;\n\n      exports.isAbsolute = function (aPath) {\n        return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n      };\n      /**\n       * Make a path relative to a URL or another path.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be made relative to aRoot.\n       */\n\n\n      function relative(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        aRoot = aRoot.replace(/\\/$/, ''); // It is possible for the path to be above the root. In this case, simply\n        // checking whether the root is a prefix of the path won't work. Instead, we\n        // need to remove components from the root one by one, until either we find\n        // a prefix that fits, or we run out of components to remove.\n\n        var level = 0;\n\n        while (aPath.indexOf(aRoot + '/') !== 0) {\n          var index = aRoot.lastIndexOf(\"/\");\n\n          if (index < 0) {\n            return aPath;\n          } // If the only part of the root that is left is the scheme (i.e. http://,\n          // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n          // have exhausted all components, so the path is not relative to the root.\n\n\n          aRoot = aRoot.slice(0, index);\n\n          if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n          }\n\n          ++level;\n        } // Make sure we add a \"../\" for each component we removed from the root.\n\n\n        return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n      }\n\n      exports.relative = relative;\n\n      var supportsNullProto = function () {\n        var obj = Object.create(null);\n        return !('__proto__' in obj);\n      }();\n\n      function identity(s) {\n        return s;\n      }\n      /**\n       * Because behavior goes wacky when you set `__proto__` on objects, we\n       * have to prefix all the strings in our set with an arbitrary character.\n       *\n       * See https://github.com/mozilla/source-map/pull/31 and\n       * https://github.com/mozilla/source-map/issues/30\n       *\n       * @param String aStr\n       */\n\n\n      function toSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return '$' + aStr;\n        }\n\n        return aStr;\n      }\n\n      exports.toSetString = supportsNullProto ? identity : toSetString;\n\n      function fromSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return aStr.slice(1);\n        }\n\n        return aStr;\n      }\n\n      exports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n      function isProtoString(s) {\n        if (!s) {\n          return false;\n        }\n\n        var length = s.length;\n\n        if (length < 9\n        /* \"__proto__\".length */\n        ) {\n            return false;\n          }\n\n        if (s.charCodeAt(length - 1) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 2) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 3) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 4) !== 116\n        /* 't' */\n        || s.charCodeAt(length - 5) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 6) !== 114\n        /* 'r' */\n        || s.charCodeAt(length - 7) !== 112\n        /* 'p' */\n        || s.charCodeAt(length - 8) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 9) !== 95\n        /* '_' */\n        ) {\n            return false;\n          }\n\n        for (var i = length - 10; i >= 0; i--) {\n          if (s.charCodeAt(i) !== 36\n          /* '$' */\n          ) {\n              return false;\n            }\n        }\n\n        return true;\n      }\n      /**\n       * Comparator between two mappings where the original positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same original source/line/column, but different generated\n       * line and column the same. Useful when searching for a mapping with a\n       * stubbed out mapping.\n       */\n\n\n      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0 || onlyCompareOriginal) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByOriginalPositions = compareByOriginalPositions;\n      /**\n       * Comparator between two mappings with deflated source and name indices where\n       * the generated positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same generated line and column, but different\n       * source/name/original line and column the same. Useful when searching for a\n       * mapping with a stubbed out mapping.\n       */\n\n      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0 || onlyCompareGenerated) {\n          return cmp;\n        }\n\n        cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n      function strcmp(aStr1, aStr2) {\n        if (aStr1 === aStr2) {\n          return 0;\n        }\n\n        if (aStr1 === null) {\n          return 1; // aStr2 !== null\n        }\n\n        if (aStr2 === null) {\n          return -1; // aStr1 !== null\n        }\n\n        if (aStr1 > aStr2) {\n          return 1;\n        }\n\n        return -1;\n      }\n      /**\n       * Comparator between two mappings with inflated source and name strings where\n       * the generated positions are compared.\n       */\n\n\n      function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n      /**\n       * Strip any JSON XSSI avoidance prefix from the string (as documented\n       * in the source maps specification), and then parse the string as\n       * JSON.\n       */\n\n      function parseSourceMapInput(str) {\n        return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n      }\n\n      exports.parseSourceMapInput = parseSourceMapInput;\n      /**\n       * Compute the URL of a source given the the source root, the source's\n       * URL, and the source map's URL.\n       */\n\n      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n        sourceURL = sourceURL || '';\n\n        if (sourceRoot) {\n          // This follows what Chrome does.\n          if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n            sourceRoot += '/';\n          } // The spec says:\n          //   Line 4: An optional source root, useful for relocating source\n          //   files on a server or removing repeated values in the\n          //   “sources” entry.  This value is prepended to the individual\n          //   entries in the “source” field.\n\n\n          sourceURL = sourceRoot + sourceURL;\n        } // Historically, SourceMapConsumer did not take the sourceMapURL as\n        // a parameter.  This mode is still somewhat supported, which is why\n        // this code block is conditional.  However, it's preferable to pass\n        // the source map URL to SourceMapConsumer, so that this function\n        // can implement the source URL resolution algorithm as outlined in\n        // the spec.  This block is basically the equivalent of:\n        //    new URL(sourceURL, sourceMapURL).toString()\n        // ... except it avoids using URL, which wasn't available in the\n        // older releases of node still supported by this library.\n        //\n        // The spec says:\n        //   If the sources are not absolute URLs after prepending of the\n        //   “sourceRoot”, the sources are resolved relative to the\n        //   SourceMap (like resolving script src in a html document).\n\n\n        if (sourceMapURL) {\n          var parsed = urlParse(sourceMapURL);\n\n          if (!parsed) {\n            throw new Error(\"sourceMapURL could not be parsed\");\n          }\n\n          if (parsed.path) {\n            // Strip the last path component, but keep the \"/\".\n            var index = parsed.path.lastIndexOf('/');\n\n            if (index >= 0) {\n              parsed.path = parsed.path.substring(0, index + 1);\n            }\n          }\n\n          sourceURL = join(urlGenerate(parsed), sourceURL);\n        }\n\n        return normalize(sourceURL);\n      }\n\n      exports.computeSourceURL = computeSourceURL;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(4);\n\n      var has = Object.prototype.hasOwnProperty;\n      var hasNativeMap = typeof Map !== \"undefined\";\n      /**\n       * A data structure which is a combination of an array and a set. Adding a new\n       * member is O(1), testing for membership is O(1), and finding the index of an\n       * element is O(1). Removing elements from the set is not supported. Only\n       * strings are supported for membership.\n       */\n\n      function ArraySet() {\n        this._array = [];\n        this._set = hasNativeMap ? new Map() : Object.create(null);\n      }\n      /**\n       * Static method for creating ArraySet instances from an existing array.\n       */\n\n\n      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet();\n\n        for (var i = 0, len = aArray.length; i < len; i++) {\n          set.add(aArray[i], aAllowDuplicates);\n        }\n\n        return set;\n      };\n      /**\n       * Return how many unique items are in this ArraySet. If duplicates have been\n       * added, than those do not count towards the size.\n       *\n       * @returns Number\n       */\n\n\n      ArraySet.prototype.size = function ArraySet_size() {\n        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n      };\n      /**\n       * Add the given string to this set.\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n        var idx = this._array.length;\n\n        if (!isDuplicate || aAllowDuplicates) {\n          this._array.push(aStr);\n        }\n\n        if (!isDuplicate) {\n          if (hasNativeMap) {\n            this._set.set(aStr, idx);\n          } else {\n            this._set[sStr] = idx;\n          }\n        }\n      };\n      /**\n       * Is the given string a member of this set?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.has = function ArraySet_has(aStr) {\n        if (hasNativeMap) {\n          return this._set.has(aStr);\n        } else {\n          var sStr = util.toSetString(aStr);\n          return has.call(this._set, sStr);\n        }\n      };\n      /**\n       * What is the index of the given string in the array?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n        if (hasNativeMap) {\n          var idx = this._set.get(aStr);\n\n          if (idx >= 0) {\n            return idx;\n          }\n        } else {\n          var sStr = util.toSetString(aStr);\n\n          if (has.call(this._set, sStr)) {\n            return this._set[sStr];\n          }\n        }\n\n        throw new Error('\"' + aStr + '\" is not in the set.');\n      };\n      /**\n       * What is the element at the given index?\n       *\n       * @param Number aIdx\n       */\n\n\n      ArraySet.prototype.at = function ArraySet_at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n          return this._array[aIdx];\n        }\n\n        throw new Error('No element indexed by ' + aIdx);\n      };\n      /**\n       * Returns the array representation of this set (which has the proper indices\n       * indicated by indexOf). Note that this is a copy of the internal array used\n       * for storing the members so that no one can mess with internal state.\n       */\n\n\n      ArraySet.prototype.toArray = function ArraySet_toArray() {\n        return this._array.slice();\n      };\n\n      exports.ArraySet = ArraySet;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2014 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(4);\n      /**\n       * Determine whether mappingB is after mappingA with respect to generated\n       * position.\n       */\n\n\n      function generatedPositionAfter(mappingA, mappingB) {\n        // Optimized for most common case\n        var lineA = mappingA.generatedLine;\n        var lineB = mappingB.generatedLine;\n        var columnA = mappingA.generatedColumn;\n        var columnB = mappingB.generatedColumn;\n        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n      }\n      /**\n       * A data structure to provide a sorted view of accumulated mappings in a\n       * performance conscious manner. It trades a neglibable overhead in general\n       * case for a large speedup in case of mappings being added in order.\n       */\n\n\n      function MappingList() {\n        this._array = [];\n        this._sorted = true; // Serves as infimum\n\n        this._last = {\n          generatedLine: -1,\n          generatedColumn: 0\n        };\n      }\n      /**\n       * Iterate through internal items. This method takes the same arguments that\n       * `Array.prototype.forEach` takes.\n       *\n       * NOTE: The order of the mappings is NOT guaranteed.\n       */\n\n\n      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n        this._array.forEach(aCallback, aThisArg);\n      };\n      /**\n       * Add the given source mapping.\n       *\n       * @param Object aMapping\n       */\n\n\n      MappingList.prototype.add = function MappingList_add(aMapping) {\n        if (generatedPositionAfter(this._last, aMapping)) {\n          this._last = aMapping;\n\n          this._array.push(aMapping);\n        } else {\n          this._sorted = false;\n\n          this._array.push(aMapping);\n        }\n      };\n      /**\n       * Returns the flat, sorted array of mappings. The mappings are sorted by\n       * generated position.\n       *\n       * WARNING: This method returns internal data without copying, for\n       * performance. The return value must NOT be mutated, and should be treated as\n       * an immutable borrow. If you want to take ownership, you must make your own\n       * copy.\n       */\n\n\n      MappingList.prototype.toArray = function MappingList_toArray() {\n        if (!this._sorted) {\n          this._array.sort(util.compareByGeneratedPositionsInflated);\n\n          this._sorted = true;\n        }\n\n        return this._array;\n      };\n\n      exports.MappingList = MappingList;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(4);\n\n      var binarySearch = __webpack_require__(8);\n\n      var ArraySet = __webpack_require__(5).ArraySet;\n\n      var base64VLQ = __webpack_require__(2);\n\n      var quickSort = __webpack_require__(9).quickSort;\n\n      function SourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n\n        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n      }\n\n      SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {\n        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the\n      // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n      // are lazily instantiated, accessed via the `_generatedMappings` and\n      // `_originalMappings` getters respectively, and we only parse the mappings\n      // and create these arrays once queried for a source location. We jump through\n      // these hoops because there can be many thousands of mappings, and parsing\n      // them is expensive, so we only want to do it if we must.\n      //\n      // Each object in the arrays is of the form:\n      //\n      //     {\n      //       generatedLine: The line number in the generated code,\n      //       generatedColumn: The column number in the generated code,\n      //       source: The path to the original source file that generated this\n      //               chunk of code,\n      //       originalLine: The line number in the original source that\n      //                     corresponds to this chunk of generated code,\n      //       originalColumn: The column number in the original source that\n      //                       corresponds to this chunk of generated code,\n      //       name: The name of the original symbol which generated this chunk of\n      //             code.\n      //     }\n      //\n      // All properties except for `generatedLine` and `generatedColumn` can be\n      // `null`.\n      //\n      // `_generatedMappings` is ordered by the generated positions.\n      //\n      // `_originalMappings` is ordered by the original positions.\n\n      SourceMapConsumer.prototype.__generatedMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n          if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__generatedMappings;\n        }\n      });\n      SourceMapConsumer.prototype.__originalMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n          if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__originalMappings;\n        }\n      });\n\n      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n        var c = aStr.charAt(index);\n        return c === \";\" || c === \",\";\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        throw new Error(\"Subclasses must implement _parseMappings\");\n      };\n\n      SourceMapConsumer.GENERATED_ORDER = 1;\n      SourceMapConsumer.ORIGINAL_ORDER = 2;\n      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n      SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n      /**\n       * Iterate over each mapping between an original source/line/column and a\n       * generated line/column in this source map.\n       *\n       * @param Function aCallback\n       *        The function that is called with each mapping.\n       * @param Object aContext\n       *        Optional. If specified, this object will be the value of `this` every\n       *        time that `aCallback` is called.\n       * @param aOrder\n       *        Either `SourceMapConsumer.GENERATED_ORDER` or\n       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n       *        iterate over the mappings sorted by the generated file's line/column\n       *        order or the original's source/line/column order, respectively. Defaults to\n       *        `SourceMapConsumer.GENERATED_ORDER`.\n       */\n\n      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function (mapping) {\n          var source = mapping.source === null ? null : this._sources.at(mapping.source);\n          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n          return {\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : this._names.at(mapping.name)\n          };\n        }, this).forEach(aCallback, context);\n      };\n      /**\n       * Returns all generated line and column information for the original source,\n       * line, and column provided. If no column is provided, returns all mappings\n       * corresponding to a either the line we are searching for or the next\n       * closest line that has any mappings. Otherwise, returns all mappings\n       * corresponding to the given line and either the column we are searching for\n       * or the next closest column that has any offsets.\n       *\n       * The only argument is an object with the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.  The line number is 1-based.\n       *   - column: Optional. the column number in the original source.\n       *    The column number is 0-based.\n       *\n       * and an array of objects is returned, each with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.  The\n       *    line number is 1-based.\n       *   - column: The column number in the generated source, or null.\n       *    The column number is 0-based.\n       */\n\n\n      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n        var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n        // returns the index of the closest mapping less than the needle. By\n        // setting needle.originalColumn to 0, we thus find the last mapping for\n        // the given line, provided such a mapping exists.\n\n        var needle = {\n          source: util.getArg(aArgs, 'source'),\n          originalLine: line,\n          originalColumn: util.getArg(aArgs, 'column', 0)\n        };\n        needle.source = this._findSourceIndex(needle.source);\n\n        if (needle.source < 0) {\n          return [];\n        }\n\n        var mappings = [];\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n\n            while (mapping && mapping.originalLine === originalLine) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          } else {\n            var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n\n            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          }\n        }\n\n        return mappings;\n      };\n\n      exports.SourceMapConsumer = SourceMapConsumer;\n      /**\n       * A BasicSourceMapConsumer instance represents a parsed source map which we can\n       * query for information about the original file positions by giving it a file\n       * position in the generated source.\n       *\n       * The first parameter is the raw source map (either as a JSON string, or\n       * already parsed to an object). According to the spec, source maps have the\n       * following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - sources: An array of URLs to the original source files.\n       *   - names: An array of identifiers which can be referrenced by individual mappings.\n       *   - sourceRoot: Optional. The URL root from which all sources are relative.\n       *   - sourcesContent: Optional. An array of contents of the original source files.\n       *   - mappings: A string of base64 VLQs which contain the actual mappings.\n       *   - file: Optional. The generated file this source map is associated with.\n       *\n       * Here is an example source map, taken from the source map spec[0]:\n       *\n       *     {\n       *       version : 3,\n       *       file: \"out.js\",\n       *       sourceRoot : \"\",\n       *       sources: [\"foo.js\", \"bar.js\"],\n       *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *       mappings: \"AA,AB;;ABCDE;\"\n       *     }\n       *\n       * The second parameter, if given, is a string whose value is the URL\n       * at which the source map was found.  This URL is used to compute the\n       * sources array.\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n       */\n\n      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n        // requires the array) to play nice here.\n\n        var names = util.getArg(sourceMap, 'names', []);\n        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n        var mappings = util.getArg(sourceMap, 'mappings');\n        var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a\n        // string rather than a number, so we use loose equality checking here.\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        if (sourceRoot) {\n          sourceRoot = util.normalize(sourceRoot);\n        }\n\n        sources = sources.map(String) // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize) // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function (source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n        }); // Pass `true` below to allow duplicate names and sources. While source maps\n        // are intended to be compressed and deduplicated, the TypeScript compiler\n        // sometimes generates source maps with duplicates in them. See Github issue\n        // #72 and bugzil.la/889492.\n\n        this._names = ArraySet.fromArray(names.map(String), true);\n        this._sources = ArraySet.fromArray(sources, true);\n        this._absoluteSources = this._sources.toArray().map(function (s) {\n          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n        });\n        this.sourceRoot = sourceRoot;\n        this.sourcesContent = sourcesContent;\n        this._mappings = mappings;\n        this._sourceMapURL = aSourceMapURL;\n        this.file = file;\n      }\n\n      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n      /**\n       * Utility function to find the index of a source.  Returns -1 if not\n       * found.\n       */\n\n      BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {\n        var relativeSource = aSource;\n\n        if (this.sourceRoot != null) {\n          relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n\n        if (this._sources.has(relativeSource)) {\n          return this._sources.indexOf(relativeSource);\n        } // Maybe aSource is an absolute URL as returned by |sources|.  In\n        // this case we can't simply undo the transform.\n\n\n        var i;\n\n        for (i = 0; i < this._absoluteSources.length; ++i) {\n          if (this._absoluteSources[i] == aSource) {\n            return i;\n          }\n        }\n\n        return -1;\n      };\n      /**\n       * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n       *\n       * @param SourceMapGenerator aSourceMap\n       *        The source map that will be consumed.\n       * @param String aSourceMapURL\n       *        The URL at which the source map can be found (optional)\n       * @returns BasicSourceMapConsumer\n       */\n\n\n      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n        var smc = Object.create(BasicSourceMapConsumer.prototype);\n        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n        smc.sourceRoot = aSourceMap._sourceRoot;\n        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n        smc.file = aSourceMap._file;\n        smc._sourceMapURL = aSourceMapURL;\n        smc._absoluteSources = smc._sources.toArray().map(function (s) {\n          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n        }); // Because we are modifying the entries (by converting string sources and\n        // names to indices into the sources and names ArraySets), we have to make\n        // a copy of the entry or else bad things happen. Shared mutable state\n        // strikes again! See github issue #191.\n\n        var generatedMappings = aSourceMap._mappings.toArray().slice();\n\n        var destGeneratedMappings = smc.__generatedMappings = [];\n        var destOriginalMappings = smc.__originalMappings = [];\n\n        for (var i = 0, length = generatedMappings.length; i < length; i++) {\n          var srcMapping = generatedMappings[i];\n          var destMapping = new Mapping();\n          destMapping.generatedLine = srcMapping.generatedLine;\n          destMapping.generatedColumn = srcMapping.generatedColumn;\n\n          if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n\n            if (srcMapping.name) {\n              destMapping.name = names.indexOf(srcMapping.name);\n            }\n\n            destOriginalMappings.push(destMapping);\n          }\n\n          destGeneratedMappings.push(destMapping);\n        }\n\n        quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n        return smc;\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      BasicSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n        get: function () {\n          return this._absoluteSources.slice();\n        }\n      });\n      /**\n       * Provide the JIT with a nice shape / hidden class.\n       */\n\n      function Mapping() {\n        this.generatedLine = 0;\n        this.generatedColumn = 0;\n        this.source = null;\n        this.originalLine = null;\n        this.originalColumn = null;\n        this.name = null;\n      }\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        var generatedLine = 1;\n        var previousGeneratedColumn = 0;\n        var previousOriginalLine = 0;\n        var previousOriginalColumn = 0;\n        var previousSource = 0;\n        var previousName = 0;\n        var length = aStr.length;\n        var index = 0;\n        var cachedSegments = {};\n        var temp = {};\n        var originalMappings = [];\n        var generatedMappings = [];\n        var mapping, str, segment, end, value;\n\n        while (index < length) {\n          if (aStr.charAt(index) === ';') {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n          } else if (aStr.charAt(index) === ',') {\n            index++;\n          } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,\n            // many segments often have the same encoding. We can exploit this\n            // fact by caching the parsed variable length fields of each segment,\n            // allowing us to avoid a second parse if we encounter the same\n            // segment again.\n\n            for (end = index; end < length; end++) {\n              if (this._charIsMappingSeparator(aStr, end)) {\n                break;\n              }\n            }\n\n            str = aStr.slice(index, end);\n            segment = cachedSegments[str];\n\n            if (segment) {\n              index += str.length;\n            } else {\n              segment = [];\n\n              while (index < end) {\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n              }\n\n              if (segment.length === 2) {\n                throw new Error('Found a source, but no line and column');\n              }\n\n              if (segment.length === 3) {\n                throw new Error('Found a source and line, but no column');\n              }\n\n              cachedSegments[str] = segment;\n            } // Generated column.\n\n\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n\n            if (segment.length > 1) {\n              // Original source.\n              mapping.source = previousSource + segment[1];\n              previousSource += segment[1]; // Original line.\n\n              mapping.originalLine = previousOriginalLine + segment[2];\n              previousOriginalLine = mapping.originalLine; // Lines are stored 0-based\n\n              mapping.originalLine += 1; // Original column.\n\n              mapping.originalColumn = previousOriginalColumn + segment[3];\n              previousOriginalColumn = mapping.originalColumn;\n\n              if (segment.length > 4) {\n                // Original name.\n                mapping.name = previousName + segment[4];\n                previousName += segment[4];\n              }\n            }\n\n            generatedMappings.push(mapping);\n\n            if (typeof mapping.originalLine === 'number') {\n              originalMappings.push(mapping);\n            }\n          }\n        }\n\n        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n        this.__generatedMappings = generatedMappings;\n        quickSort(originalMappings, util.compareByOriginalPositions);\n        this.__originalMappings = originalMappings;\n      };\n      /**\n       * Find the mapping that best matches the hypothetical \"needle\" mapping that\n       * we are searching for in the given \"haystack\" of mappings.\n       */\n\n\n      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n        // To return the position we are searching for, we must first find the\n        // mapping for the given position and then return the opposite position it\n        // points to. Because the mappings are sorted, we can use binary search to\n        // find the best mapping.\n        if (aNeedle[aLineName] <= 0) {\n          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n        }\n\n        if (aNeedle[aColumnName] < 0) {\n          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n        }\n\n        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n      };\n      /**\n       * Compute the last column for each generated mapping. The last column is\n       * inclusive.\n       */\n\n\n      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n        for (var index = 0; index < this._generatedMappings.length; ++index) {\n          var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We\n          // can come up with an optimistic estimate, however, by assuming that\n          // mappings are contiguous (i.e. given two consecutive mappings, the\n          // first mapping ends where the second one starts).\n\n          if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n              continue;\n            }\n          } // The last mapping for each line spans the entire line.\n\n\n          mapping.lastGeneratedColumn = Infinity;\n        }\n      };\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the generated source.  The column\n       *     number is 0-based.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.  The\n       *     line number is 1-based.\n       *   - column: The column number in the original source, or null.  The\n       *     column number is 0-based.\n       *   - name: The original identifier, or null.\n       */\n\n\n      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._generatedMappings[index];\n\n          if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, 'source', null);\n\n            if (source !== null) {\n              source = this._sources.at(source);\n              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n            }\n\n            var name = util.getArg(mapping, 'name', null);\n\n            if (name !== null) {\n              name = this._names.at(name);\n            }\n\n            return {\n              source: source,\n              line: util.getArg(mapping, 'originalLine', null),\n              column: util.getArg(mapping, 'originalColumn', null),\n              name: name\n            };\n          }\n        }\n\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n        if (!this.sourcesContent) {\n          return false;\n        }\n\n        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n          return sc == null;\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        if (!this.sourcesContent) {\n          return null;\n        }\n\n        var index = this._findSourceIndex(aSource);\n\n        if (index >= 0) {\n          return this.sourcesContent[index];\n        }\n\n        var relativeSource = aSource;\n\n        if (this.sourceRoot != null) {\n          relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n\n        var url;\n\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n          // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n          // many users. We can help them out when they expect file:// URIs to\n          // behave like it would if they were running a local HTTP server. See\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n          var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n\n          if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n          }\n\n          if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n          }\n        } // This function is used recursively from\n        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n        // don't want to throw if we can't find the source - we just want to\n        // return null, so we provide a flag to exit gracefully.\n\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the original source.  The column\n       *     number is 0-based.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.  The\n       *     line number is 1-based.\n       *   - column: The column number in the generated source, or null.\n       *     The column number is 0-based.\n       */\n\n\n      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n        var source = util.getArg(aArgs, 'source');\n        source = this._findSourceIndex(source);\n\n        if (source < 0) {\n          return {\n            line: null,\n            column: null,\n            lastColumn: null\n          };\n        }\n\n        var needle = {\n          source: source,\n          originalLine: util.getArg(aArgs, 'line'),\n          originalColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (mapping.source === needle.source) {\n            return {\n              line: util.getArg(mapping, 'generatedLine', null),\n              column: util.getArg(mapping, 'generatedColumn', null),\n              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            };\n          }\n        }\n\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      };\n\n      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n      /**\n       * An IndexedSourceMapConsumer instance represents a parsed source map which\n       * we can query for information. It differs from BasicSourceMapConsumer in\n       * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n       * input.\n       *\n       * The first parameter is a raw source map (either as a JSON string, or already\n       * parsed to an object). According to the spec for indexed source maps, they\n       * have the following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - file: Optional. The generated file this source map is associated with.\n       *   - sections: A list of section definitions.\n       *\n       * Each value under the \"sections\" field has two fields:\n       *   - offset: The offset into the original specified at which this section\n       *       begins to apply, defined as an object with a \"line\" and \"column\"\n       *       field.\n       *   - map: A source map definition. This source map could also be indexed,\n       *       but doesn't have to be.\n       *\n       * Instead of the \"map\" field, it's also possible to have a \"url\" field\n       * specifying a URL to retrieve a source map from, but that's currently\n       * unsupported.\n       *\n       * Here's an example source map, taken from the source map spec[0], but\n       * modified to omit a section which uses the \"url\" field.\n       *\n       *  {\n       *    version : 3,\n       *    file: \"app.js\",\n       *    sections: [{\n       *      offset: {line:100, column:10},\n       *      map: {\n       *        version : 3,\n       *        file: \"section.js\",\n       *        sources: [\"foo.js\", \"bar.js\"],\n       *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *        mappings: \"AAAA,E;;ABCDE;\"\n       *      }\n       *    }],\n       *  }\n       *\n       * The second parameter, if given, is a string whose value is the URL\n       * at which the source map was found.  This URL is used to compute the\n       * sources array.\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n       */\n\n      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sections = util.getArg(sourceMap, 'sections');\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        var lastOffset = {\n          line: -1,\n          column: 0\n        };\n        this._sections = sections.map(function (s) {\n          if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error('Support for url field in sections not implemented.');\n          }\n\n          var offset = util.getArg(s, 'offset');\n          var offsetLine = util.getArg(offset, 'line');\n          var offsetColumn = util.getArg(offset, 'column');\n\n          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error('Section offsets must be ordered and non-overlapping.');\n          }\n\n          lastOffset = offset;\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n          };\n        });\n      }\n\n      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n      IndexedSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n        get: function () {\n          var sources = [];\n\n          for (var i = 0; i < this._sections.length; i++) {\n            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n              sources.push(this._sections[i].consumer.sources[j]);\n            }\n          }\n\n          return sources;\n        }\n      });\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the generated source.  The column\n       *     number is 0-based.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.  The\n       *     line number is 1-based.\n       *   - column: The column number in the original source, or null.  The\n       *     column number is 0-based.\n       *   - name: The original identifier, or null.\n       */\n\n      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        }; // Find the section containing the generated position we're trying to map\n        // to an original position.\n\n        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {\n          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\n          if (cmp) {\n            return cmp;\n          }\n\n          return needle.generatedColumn - section.generatedOffset.generatedColumn;\n        });\n        var section = this._sections[sectionIndex];\n\n        if (!section) {\n          return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n          };\n        }\n\n        return section.consumer.originalPositionFor({\n          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n          bias: aArgs.bias\n        });\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n        return this._sections.every(function (s) {\n          return s.consumer.hasContentsOfAllSources();\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var content = section.consumer.sourceContentFor(aSource, true);\n\n          if (content) {\n            return content;\n          }\n        }\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the original source.  The column\n       *     number is 0-based.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.  The\n       *     line number is 1-based. \n       *   - column: The column number in the generated source, or null.\n       *     The column number is 0-based.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i]; // Only consider this section if the requested source is in the list of\n          // sources of the consumer.\n\n          if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n            continue;\n          }\n\n          var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\n          if (generatedPosition) {\n            var ret = {\n              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n          }\n        }\n\n        return {\n          line: null,\n          column: null\n        };\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var sectionMappings = section.consumer._generatedMappings;\n\n          for (var j = 0; j < sectionMappings.length; j++) {\n            var mapping = sectionMappings[j];\n\n            var source = section.consumer._sources.at(mapping.source);\n\n            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n\n            this._sources.add(source);\n\n            source = this._sources.indexOf(source);\n            var name = null;\n\n            if (mapping.name) {\n              name = section.consumer._names.at(mapping.name);\n\n              this._names.add(name);\n\n              name = this._names.indexOf(name);\n            } // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n\n\n            var adjustedMapping = {\n              source: source,\n              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n              originalLine: mapping.originalLine,\n              originalColumn: mapping.originalColumn,\n              name: name\n            };\n\n            this.__generatedMappings.push(adjustedMapping);\n\n            if (typeof adjustedMapping.originalLine === 'number') {\n              this.__originalMappings.push(adjustedMapping);\n            }\n          }\n        }\n\n        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n        quickSort(this.__originalMappings, util.compareByOriginalPositions);\n      };\n\n      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.GREATEST_LOWER_BOUND = 1;\n      exports.LEAST_UPPER_BOUND = 2;\n      /**\n       * Recursive implementation of binary search.\n       *\n       * @param aLow Indices here and lower do not contain the needle.\n       * @param aHigh Indices here and higher do not contain the needle.\n       * @param aNeedle The element being searched for.\n       * @param aHaystack The non-empty array being searched.\n       * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       */\n\n      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n        // This function terminates when one of the following is true:\n        //\n        //   1. We find the exact element we are looking for.\n        //\n        //   2. We did not find the exact element, but we can return the index of\n        //      the next-closest element.\n        //\n        //   3. We did not find the exact element, and there is no next-closest\n        //      element than the one we are searching for, so we return -1.\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\n        if (cmp === 0) {\n          // Found the element we are looking for.\n          return mid;\n        } else if (cmp > 0) {\n          // Our needle is greater than aHaystack[mid].\n          if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n          } // The exact needle element was not found in this haystack. Determine if\n          // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n          } else {\n            return mid;\n          }\n        } else {\n          // Our needle is less than aHaystack[mid].\n          if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n          } // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n          } else {\n            return aLow < 0 ? -1 : aLow;\n          }\n        }\n      }\n      /**\n       * This is an implementation of binary search which will always try and return\n       * the index of the closest element if there is no exact hit. This is because\n       * mappings between original and generated line/col pairs are single points,\n       * and there is an implicit region between each of them, so a miss just means\n       * that you aren't on the very start of a region.\n       *\n       * @param aNeedle The element you are looking for.\n       * @param aHaystack The array that is being searched.\n       * @param aCompare A function which takes the needle and an element in the\n       *     array and returns -1, 0, or 1 depending on whether the needle is less\n       *     than, equal to, or greater than the element, respectively.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n       */\n\n\n      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n        if (aHaystack.length === 0) {\n          return -1;\n        }\n\n        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\n        if (index < 0) {\n          return -1;\n        } // We have found either the exact element, or the next-closest element than\n        // the one we are searching for. However, there may be more than one such\n        // element. Make sure we always return the smallest of these.\n\n\n        while (index - 1 >= 0) {\n          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n          }\n\n          --index;\n        }\n\n        return index;\n      };\n      /***/\n\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      // It turns out that some (most?) JavaScript engines don't self-host\n      // `Array.prototype.sort`. This makes sense because C++ will likely remain\n      // faster than JS when doing raw CPU-intensive sorting. However, when using a\n      // custom comparator function, calling back and forth between the VM's C++ and\n      // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n      // worse generated code for the comparator function than would be optimal. In\n      // fact, when sorting with a comparator, these costs outweigh the benefits of\n      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n      // a ~3500ms mean speed-up in `bench/bench.html`.\n\n      /**\n       * Swap the elements indexed by `x` and `y` in the array `ary`.\n       *\n       * @param {Array} ary\n       *        The array.\n       * @param {Number} x\n       *        The index of the first item.\n       * @param {Number} y\n       *        The index of the second item.\n       */\n      function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n      }\n      /**\n       * Returns a random integer within the range `low .. high` inclusive.\n       *\n       * @param {Number} low\n       *        The lower bound on the range.\n       * @param {Number} high\n       *        The upper bound on the range.\n       */\n\n\n      function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n      }\n      /**\n       * The Quick Sort algorithm.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       * @param {Number} p\n       *        Start index of the array\n       * @param {Number} r\n       *        End index of the array\n       */\n\n\n      function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n          // (1) Partitioning.\n          //\n          // The partitioning chooses a pivot between `p` and `r` and moves all\n          // elements that are less than or equal to the pivot to the before it, and\n          // all the elements that are greater than it after it. The effect is that\n          // once partition is done, the pivot is in the exact place it will be when\n          // the array is put in sorted order, and it will not need to be moved\n          // again. This runs in O(n) time.\n          // Always choose a random pivot so that an input array which is reverse\n          // sorted does not cause O(n^2) running time.\n          var pivotIndex = randomIntInRange(p, r);\n          var i = p - 1;\n          swap(ary, pivotIndex, r);\n          var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold\n          // true:\n          //\n          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n          //\n          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\n          for (var j = p; j < r; j++) {\n            if (comparator(ary[j], pivot) <= 0) {\n              i += 1;\n              swap(ary, i, j);\n            }\n          }\n\n          swap(ary, i + 1, j);\n          var q = i + 1; // (2) Recurse on each half.\n\n          doQuickSort(ary, comparator, p, q - 1);\n          doQuickSort(ary, comparator, q + 1, r);\n        }\n      }\n      /**\n       * Sort the given array in-place with the given comparator function.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       */\n\n\n      exports.quickSort = function (ary, comparator) {\n        doQuickSort(ary, comparator, 0, ary.length - 1);\n      };\n      /***/\n\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var SourceMapGenerator = __webpack_require__(1).SourceMapGenerator;\n\n      var util = __webpack_require__(4); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n      // operating systems these days (capturing the result).\n\n\n      var REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\n      var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n      // the source-map library are loaded. This MUST NOT CHANGE across\n      // versions!\n\n      var isSourceNode = \"$$$isSourceNode$$$\";\n      /**\n       * SourceNodes provide a way to abstract over interpolating/concatenating\n       * snippets of generated JavaScript source code while maintaining the line and\n       * column information associated with the original source code.\n       *\n       * @param aLine The original line number.\n       * @param aColumn The original column number.\n       * @param aSource The original source's filename.\n       * @param aChunks Optional. An array of strings which are snippets of\n       *        generated JS, or other SourceNodes.\n       * @param aName The original identifier.\n       */\n\n      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n        this.children = [];\n        this.sourceContents = {};\n        this.line = aLine == null ? null : aLine;\n        this.column = aColumn == null ? null : aColumn;\n        this.source = aSource == null ? null : aSource;\n        this.name = aName == null ? null : aName;\n        this[isSourceNode] = true;\n        if (aChunks != null) this.add(aChunks);\n      }\n      /**\n       * Creates a SourceNode from generated code and a SourceMapConsumer.\n       *\n       * @param aGeneratedCode The generated code\n       * @param aSourceMapConsumer The SourceMap for the generated code\n       * @param aRelativePath Optional. The path that relative sources in the\n       *        SourceMapConsumer should be relative to.\n       */\n\n\n      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n        // The SourceNode we want to fill with the generated code\n        // and the SourceMap\n        var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n        // while all odd indices are the newlines between two adjacent lines\n        // (since `REGEX_NEWLINE` captures its match).\n        // Processed fragments are accessed by calling `shiftNextLine`.\n\n        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n        var remainingLinesIndex = 0;\n\n        var shiftNextLine = function () {\n          var lineContents = getNextLine(); // The last line of a file might not have a newline.\n\n          var newLine = getNextLine() || \"\";\n          return lineContents + newLine;\n\n          function getNextLine() {\n            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n          }\n        }; // We need to remember the position of \"remainingLines\"\n\n\n        var lastGeneratedLine = 1,\n            lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n        // To extract it current and last mapping is used.\n        // Here we store the last mapping.\n\n        var lastMapping = null;\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n              // Associate first line with \"lastMapping\"\n              addMappingWithCode(lastMapping, shiftNextLine());\n              lastGeneratedLine++;\n              lastGeneratedColumn = 0; // The remaining code is added without mapping\n            } else {\n              // There is no new line in between.\n              // Associate the code between \"lastGeneratedColumn\" and\n              // \"mapping.generatedColumn\" with \"lastMapping\"\n              var nextLine = remainingLines[remainingLinesIndex] || '';\n              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n              lastGeneratedColumn = mapping.generatedColumn;\n              addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n              lastMapping = mapping;\n              return;\n            }\n          } // We add the generated code until the first mapping\n          // to the SourceNode without any mapping.\n          // Each line is added as separate string.\n\n\n          while (lastGeneratedLine < mapping.generatedLine) {\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n          }\n\n          if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[remainingLinesIndex] || '';\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n          }\n\n          lastMapping = mapping;\n        }, this); // We have processed all mappings.\n\n        if (remainingLinesIndex < remainingLines.length) {\n          if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n          } // and add the remaining lines without any mapping\n\n\n          node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n        } // Copy sourcesContent into SourceNode\n\n\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            if (aRelativePath != null) {\n              sourceFile = util.join(aRelativePath, sourceFile);\n            }\n\n            node.setSourceContent(sourceFile, content);\n          }\n        });\n        return node;\n\n        function addMappingWithCode(mapping, code) {\n          if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n          } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n          }\n        }\n      };\n      /**\n       * Add a chunk of generated JS to this source node.\n       *\n       * @param aChunk A string snippet of generated JS code, another instance of\n       *        SourceNode, or an array where each member is one of those things.\n       */\n\n\n      SourceNode.prototype.add = function SourceNode_add(aChunk) {\n        if (Array.isArray(aChunk)) {\n          aChunk.forEach(function (chunk) {\n            this.add(chunk);\n          }, this);\n        } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n          if (aChunk) {\n            this.children.push(aChunk);\n          }\n        } else {\n          throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n        }\n\n        return this;\n      };\n      /**\n       * Add a chunk of generated JS to the beginning of this source node.\n       *\n       * @param aChunk A string snippet of generated JS code, another instance of\n       *        SourceNode, or an array where each member is one of those things.\n       */\n\n\n      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n        if (Array.isArray(aChunk)) {\n          for (var i = aChunk.length - 1; i >= 0; i--) {\n            this.prepend(aChunk[i]);\n          }\n        } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n          this.children.unshift(aChunk);\n        } else {\n          throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n        }\n\n        return this;\n      };\n      /**\n       * Walk over the tree of JS snippets in this node and its children. The\n       * walking function is called once for each snippet of JS and is passed that\n       * snippet and the its original associated source's line/column location.\n       *\n       * @param aFn The traversal function.\n       */\n\n\n      SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n        var chunk;\n\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          chunk = this.children[i];\n\n          if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n          } else {\n            if (chunk !== '') {\n              aFn(chunk, {\n                source: this.source,\n                line: this.line,\n                column: this.column,\n                name: this.name\n              });\n            }\n          }\n        }\n      };\n      /**\n       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n       * each of `this.children`.\n       *\n       * @param aSep The separator.\n       */\n\n\n      SourceNode.prototype.join = function SourceNode_join(aSep) {\n        var newChildren;\n        var i;\n        var len = this.children.length;\n\n        if (len > 0) {\n          newChildren = [];\n\n          for (i = 0; i < len - 1; i++) {\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n          }\n\n          newChildren.push(this.children[i]);\n          this.children = newChildren;\n        }\n\n        return this;\n      };\n      /**\n       * Call String.prototype.replace on the very right-most source snippet. Useful\n       * for trimming whitespace from the end of a source node, etc.\n       *\n       * @param aPattern The pattern to replace.\n       * @param aReplacement The thing to replace the pattern with.\n       */\n\n\n      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n        var lastChild = this.children[this.children.length - 1];\n\n        if (lastChild[isSourceNode]) {\n          lastChild.replaceRight(aPattern, aReplacement);\n        } else if (typeof lastChild === 'string') {\n          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n        } else {\n          this.children.push(''.replace(aPattern, aReplacement));\n        }\n\n        return this;\n      };\n      /**\n       * Set the source content for a source file. This will be added to the SourceMapGenerator\n       * in the sourcesContent field.\n       *\n       * @param aSourceFile The filename of the source file\n       * @param aSourceContent The content of the source file\n       */\n\n\n      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n      };\n      /**\n       * Walk over the tree of SourceNodes. The walking function is called for each\n       * source file content and is passed the filename and source content.\n       *\n       * @param aFn The traversal function.\n       */\n\n\n      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n          }\n        }\n\n        var sources = Object.keys(this.sourceContents);\n\n        for (var i = 0, len = sources.length; i < len; i++) {\n          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n        }\n      };\n      /**\n       * Return the string representation of this source node. Walks over the tree\n       * and concatenates all the various snippets together to one string.\n       */\n\n\n      SourceNode.prototype.toString = function SourceNode_toString() {\n        var str = \"\";\n        this.walk(function (chunk) {\n          str += chunk;\n        });\n        return str;\n      };\n      /**\n       * Returns the string representation of this source node along with a source\n       * map.\n       */\n\n\n      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n        var generated = {\n          code: \"\",\n          line: 1,\n          column: 0\n        };\n        var map = new SourceMapGenerator(aArgs);\n        var sourceMappingActive = false;\n        var lastOriginalSource = null;\n        var lastOriginalLine = null;\n        var lastOriginalColumn = null;\n        var lastOriginalName = null;\n        this.walk(function (chunk, original) {\n          generated.code += chunk;\n\n          if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              generated: {\n                line: generated.line,\n                column: generated.column\n              }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          }\n\n          for (var idx = 0, length = chunk.length; idx < length; idx++) {\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n              generated.line++;\n              generated.column = 0; // Mappings end at eol\n\n              if (idx + 1 === length) {\n                lastOriginalSource = null;\n                sourceMappingActive = false;\n              } else if (sourceMappingActive) {\n                map.addMapping({\n                  source: original.source,\n                  original: {\n                    line: original.line,\n                    column: original.column\n                  },\n                  generated: {\n                    line: generated.line,\n                    column: generated.column\n                  },\n                  name: original.name\n                });\n              }\n            } else {\n              generated.column++;\n            }\n          }\n        });\n        this.walkSourceContents(function (sourceFile, sourceContent) {\n          map.setSourceContent(sourceFile, sourceContent);\n        });\n        return {\n          code: generated.code,\n          map: map\n        };\n      };\n\n      exports.SourceNode = SourceNode;\n      /***/\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/terser/node_modules/source-map/dist/source-map.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","SourceMapGenerator","SourceMapConsumer","SourceNode","base64VLQ","util","ArraySet","MappingList","aArgs","_file","getArg","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","prototype","_version","fromSourceMap","SourceMapGenerator_fromSourceMap","aSourceMapConsumer","sourceRoot","generator","file","eachMapping","mapping","newMapping","generated","line","generatedLine","column","generatedColumn","source","relative","original","originalLine","originalColumn","name","addMapping","sources","forEach","sourceFile","sourceRelative","has","add","content","sourceContentFor","setSourceContent","SourceMapGenerator_addMapping","_validateMapping","String","SourceMapGenerator_setSourceContent","aSourceFile","aSourceContent","Object","create","toSetString","keys","length","applySourceMap","SourceMapGenerator_applySourceMap","aSourceMapPath","Error","newSources","newNames","unsortedForEach","originalPositionFor","join","SourceMapGenerator_validateMapping","aGenerated","aOriginal","aSource","aName","JSON","stringify","_serializeMappings","SourceMapGenerator_serializeMappings","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","result","next","nameIdx","sourceIdx","mappings","toArray","i","len","compareByGeneratedPositionsInflated","encode","indexOf","_generateSourcesContent","SourceMapGenerator_generateSourcesContent","aSources","aSourceRoot","map","key","hasOwnProperty","toJSON","SourceMapGenerator_toJSON","version","names","sourcesContent","toString","SourceMapGenerator_toString","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","base64VLQ_encode","encoded","digit","vlq","decode","base64VLQ_decode","aStr","aIndex","aOutParam","strLen","shift","continuation","charCodeAt","charAt","value","rest","intToCharMap","split","number","TypeError","charCode","bigA","bigZ","littleA","littleZ","zero","nine","plus","slash","littleOffset","numberOffset","aDefaultValue","arguments","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","normalize","aPath","isAbsolute","parts","part","up","splice","aRoot","aPathUrl","aRootUrl","joined","replace","test","level","index","lastIndexOf","slice","Array","substr","supportsNullProto","obj","identity","s","isProtoString","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","strcmp","compareByGeneratedPositionsDeflated","onlyCompareGenerated","aStr1","aStr2","parseSourceMapInput","str","parse","computeSourceURL","sourceURL","sourceMapURL","parsed","substring","hasNativeMap","Map","_array","_set","fromArray","ArraySet_fromArray","aArray","aAllowDuplicates","set","size","ArraySet_size","getOwnPropertyNames","ArraySet_add","sStr","isDuplicate","idx","push","ArraySet_has","ArraySet_indexOf","get","at","ArraySet_at","aIdx","ArraySet_toArray","generatedPositionAfter","lineA","lineB","columnA","columnB","_sorted","_last","MappingList_forEach","aCallback","aThisArg","MappingList_add","aMapping","MappingList_toArray","sort","binarySearch","quickSort","aSourceMap","aSourceMapURL","sourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","__generatedMappings","defineProperty","configurable","enumerable","_parseMappings","__originalMappings","_charIsMappingSeparator","SourceMapConsumer_charIsMappingSeparator","SourceMapConsumer_parseMappings","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","SourceMapConsumer_eachMapping","aContext","aOrder","context","order","_generatedMappings","_originalMappings","_sourceMapURL","allGeneratedPositionsFor","SourceMapConsumer_allGeneratedPositionsFor","needle","_findSourceIndex","_findMapping","undefined","lastColumn","_absoluteSources","consumer","relativeSource","SourceMapConsumer_fromSourceMap","smc","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","Mapping","cachedSegments","temp","originalMappings","segment","end","SourceMapConsumer_findMapping","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","SourceMapConsumer_computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","SourceMapConsumer_originalPositionFor","hasContentsOfAllSources","BasicSourceMapConsumer_hasContentsOfAllSources","some","sc","SourceMapConsumer_sourceContentFor","nullOnMissing","fileUriAbsPath","generatedPositionFor","SourceMapConsumer_generatedPositionFor","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","constructor","j","IndexedSourceMapConsumer_originalPositionFor","sectionIndex","section","bias","IndexedSourceMapConsumer_hasContentsOfAllSources","every","IndexedSourceMapConsumer_sourceContentFor","IndexedSourceMapConsumer_generatedPositionFor","generatedPosition","ret","IndexedSourceMapConsumer_parseMappings","sectionMappings","adjustedMapping","recursiveSearch","aLow","aHigh","aHaystack","aCompare","mid","Math","floor","swap","ary","x","y","randomIntInRange","low","high","round","random","doQuickSort","comparator","r","pivotIndex","pivot","q","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","aLine","aColumn","aChunks","children","sourceContents","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aRelativePath","node","remainingLines","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","lastGeneratedLine","lastMapping","addMappingWithCode","nextLine","code","SourceNode_add","aChunk","isArray","chunk","prepend","SourceNode_prepend","unshift","walk","SourceNode_walk","aFn","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","SourceNode_setSourceContent","walkSourceContents","SourceNode_walkSourceContents","SourceNode_toString","toStringWithSourceMap","SourceNode_toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sourceMap\"] = factory();\n\telse\n\t\troot[\"sourceMap\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2009-2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE.txt or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\texports.SourceMapGenerator = __webpack_require__(1).SourceMapGenerator;\n\texports.SourceMapConsumer = __webpack_require__(7).SourceMapConsumer;\n\texports.SourceNode = __webpack_require__(10).SourceNode;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar base64VLQ = __webpack_require__(2);\n\tvar util = __webpack_require__(4);\n\tvar ArraySet = __webpack_require__(5).ArraySet;\n\tvar MappingList = __webpack_require__(6).MappingList;\n\n\t/**\n\t * An instance of the SourceMapGenerator represents a source map which is\n\t * being built incrementally. You may pass an object with the following\n\t * properties:\n\t *\n\t *   - file: The filename of the generated source.\n\t *   - sourceRoot: A root for all relative URLs in this source map.\n\t */\n\tfunction SourceMapGenerator(aArgs) {\n\t  if (!aArgs) {\n\t    aArgs = {};\n\t  }\n\t  this._file = util.getArg(aArgs, 'file', null);\n\t  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n\t  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t  this._mappings = new MappingList();\n\t  this._sourcesContents = null;\n\t}\n\n\tSourceMapGenerator.prototype._version = 3;\n\n\t/**\n\t * Creates a new SourceMapGenerator based on a SourceMapConsumer\n\t *\n\t * @param aSourceMapConsumer The SourceMap.\n\t */\n\tSourceMapGenerator.fromSourceMap =\n\t  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n\t    var sourceRoot = aSourceMapConsumer.sourceRoot;\n\t    var generator = new SourceMapGenerator({\n\t      file: aSourceMapConsumer.file,\n\t      sourceRoot: sourceRoot\n\t    });\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      var newMapping = {\n\t        generated: {\n\t          line: mapping.generatedLine,\n\t          column: mapping.generatedColumn\n\t        }\n\t      };\n\n\t      if (mapping.source != null) {\n\t        newMapping.source = mapping.source;\n\t        if (sourceRoot != null) {\n\t          newMapping.source = util.relative(sourceRoot, newMapping.source);\n\t        }\n\n\t        newMapping.original = {\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        };\n\n\t        if (mapping.name != null) {\n\t          newMapping.name = mapping.name;\n\t        }\n\t      }\n\n\t      generator.addMapping(newMapping);\n\t    });\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var sourceRelative = sourceFile;\n\t      if (sourceRoot !== null) {\n\t        sourceRelative = util.relative(sourceRoot, sourceFile);\n\t      }\n\n\t      if (!generator._sources.has(sourceRelative)) {\n\t        generator._sources.add(sourceRelative);\n\t      }\n\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        generator.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t    return generator;\n\t  };\n\n\t/**\n\t * Add a single mapping from original source line and column to the generated\n\t * source's line and column for this source map being created. The mapping\n\t * object should have the following properties:\n\t *\n\t *   - generated: An object with the generated line and column positions.\n\t *   - original: An object with the original line and column positions.\n\t *   - source: The original source file (relative to the sourceRoot).\n\t *   - name: An optional original token name for this mapping.\n\t */\n\tSourceMapGenerator.prototype.addMapping =\n\t  function SourceMapGenerator_addMapping(aArgs) {\n\t    var generated = util.getArg(aArgs, 'generated');\n\t    var original = util.getArg(aArgs, 'original', null);\n\t    var source = util.getArg(aArgs, 'source', null);\n\t    var name = util.getArg(aArgs, 'name', null);\n\n\t    if (!this._skipValidation) {\n\t      this._validateMapping(generated, original, source, name);\n\t    }\n\n\t    if (source != null) {\n\t      source = String(source);\n\t      if (!this._sources.has(source)) {\n\t        this._sources.add(source);\n\t      }\n\t    }\n\n\t    if (name != null) {\n\t      name = String(name);\n\t      if (!this._names.has(name)) {\n\t        this._names.add(name);\n\t      }\n\t    }\n\n\t    this._mappings.add({\n\t      generatedLine: generated.line,\n\t      generatedColumn: generated.column,\n\t      originalLine: original != null && original.line,\n\t      originalColumn: original != null && original.column,\n\t      source: source,\n\t      name: name\n\t    });\n\t  };\n\n\t/**\n\t * Set the source content for a source file.\n\t */\n\tSourceMapGenerator.prototype.setSourceContent =\n\t  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n\t    var source = aSourceFile;\n\t    if (this._sourceRoot != null) {\n\t      source = util.relative(this._sourceRoot, source);\n\t    }\n\n\t    if (aSourceContent != null) {\n\t      // Add the source content to the _sourcesContents map.\n\t      // Create a new _sourcesContents map if the property is null.\n\t      if (!this._sourcesContents) {\n\t        this._sourcesContents = Object.create(null);\n\t      }\n\t      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n\t    } else if (this._sourcesContents) {\n\t      // Remove the source file from the _sourcesContents map.\n\t      // If the _sourcesContents map is empty, set the property to null.\n\t      delete this._sourcesContents[util.toSetString(source)];\n\t      if (Object.keys(this._sourcesContents).length === 0) {\n\t        this._sourcesContents = null;\n\t      }\n\t    }\n\t  };\n\n\t/**\n\t * Applies the mappings of a sub-source-map for a specific source file to the\n\t * source map being generated. Each mapping to the supplied source file is\n\t * rewritten using the supplied source map. Note: The resolution for the\n\t * resulting mappings is the minimium of this map and the supplied map.\n\t *\n\t * @param aSourceMapConsumer The source map to be applied.\n\t * @param aSourceFile Optional. The filename of the source file.\n\t *        If omitted, SourceMapConsumer's file property will be used.\n\t * @param aSourceMapPath Optional. The dirname of the path to the source map\n\t *        to be applied. If relative, it is relative to the SourceMapConsumer.\n\t *        This parameter is needed when the two source maps aren't in the same\n\t *        directory, and the source map to be applied contains relative source\n\t *        paths. If so, those relative source paths need to be rewritten\n\t *        relative to the SourceMapGenerator.\n\t */\n\tSourceMapGenerator.prototype.applySourceMap =\n\t  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t    var sourceFile = aSourceFile;\n\t    // If aSourceFile is omitted, we will use the file property of the SourceMap\n\t    if (aSourceFile == null) {\n\t      if (aSourceMapConsumer.file == null) {\n\t        throw new Error(\n\t          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n\t          'or the source map\\'s \"file\" property. Both were omitted.'\n\t        );\n\t      }\n\t      sourceFile = aSourceMapConsumer.file;\n\t    }\n\t    var sourceRoot = this._sourceRoot;\n\t    // Make \"sourceFile\" relative if an absolute Url is passed.\n\t    if (sourceRoot != null) {\n\t      sourceFile = util.relative(sourceRoot, sourceFile);\n\t    }\n\t    // Applying the SourceMap can add and remove items from the sources and\n\t    // the names array.\n\t    var newSources = new ArraySet();\n\t    var newNames = new ArraySet();\n\n\t    // Find mappings for the \"sourceFile\"\n\t    this._mappings.unsortedForEach(function (mapping) {\n\t      if (mapping.source === sourceFile && mapping.originalLine != null) {\n\t        // Check if it can be mapped by the source map, then update the mapping.\n\t        var original = aSourceMapConsumer.originalPositionFor({\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        });\n\t        if (original.source != null) {\n\t          // Copy mapping\n\t          mapping.source = original.source;\n\t          if (aSourceMapPath != null) {\n\t            mapping.source = util.join(aSourceMapPath, mapping.source)\n\t          }\n\t          if (sourceRoot != null) {\n\t            mapping.source = util.relative(sourceRoot, mapping.source);\n\t          }\n\t          mapping.originalLine = original.line;\n\t          mapping.originalColumn = original.column;\n\t          if (original.name != null) {\n\t            mapping.name = original.name;\n\t          }\n\t        }\n\t      }\n\n\t      var source = mapping.source;\n\t      if (source != null && !newSources.has(source)) {\n\t        newSources.add(source);\n\t      }\n\n\t      var name = mapping.name;\n\t      if (name != null && !newNames.has(name)) {\n\t        newNames.add(name);\n\t      }\n\n\t    }, this);\n\t    this._sources = newSources;\n\t    this._names = newNames;\n\n\t    // Copy sourcesContents of applied map.\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aSourceMapPath != null) {\n\t          sourceFile = util.join(aSourceMapPath, sourceFile);\n\t        }\n\t        if (sourceRoot != null) {\n\t          sourceFile = util.relative(sourceRoot, sourceFile);\n\t        }\n\t        this.setSourceContent(sourceFile, content);\n\t      }\n\t    }, this);\n\t  };\n\n\t/**\n\t * A mapping can have one of the three levels of data:\n\t *\n\t *   1. Just the generated position.\n\t *   2. The Generated position, original position, and original source.\n\t *   3. Generated and original position, original source, as well as a name\n\t *      token.\n\t *\n\t * To maintain consistency, we validate that any new mapping being added falls\n\t * in to one of these categories.\n\t */\n\tSourceMapGenerator.prototype._validateMapping =\n\t  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n\t                                              aName) {\n\t    // When aOriginal is truthy but has empty values for .line and .column,\n\t    // it is most likely a programmer error. In this case we throw a very\n\t    // specific error message to try to guide them the right way.\n\t    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n\t    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n\t        throw new Error(\n\t            'original.line and original.column are not numbers -- you probably meant to omit ' +\n\t            'the original mapping entirely and only map the generated position. If so, pass ' +\n\t            'null for the original mapping instead of an object with empty or null values.'\n\t        );\n\t    }\n\n\t    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t        && aGenerated.line > 0 && aGenerated.column >= 0\n\t        && !aOriginal && !aSource && !aName) {\n\t      // Case 1.\n\t      return;\n\t    }\n\t    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n\t             && aGenerated.line > 0 && aGenerated.column >= 0\n\t             && aOriginal.line > 0 && aOriginal.column >= 0\n\t             && aSource) {\n\t      // Cases 2 and 3.\n\t      return;\n\t    }\n\t    else {\n\t      throw new Error('Invalid mapping: ' + JSON.stringify({\n\t        generated: aGenerated,\n\t        source: aSource,\n\t        original: aOriginal,\n\t        name: aName\n\t      }));\n\t    }\n\t  };\n\n\t/**\n\t * Serialize the accumulated mappings in to the stream of base 64 VLQs\n\t * specified by the source map format.\n\t */\n\tSourceMapGenerator.prototype._serializeMappings =\n\t  function SourceMapGenerator_serializeMappings() {\n\t    var previousGeneratedColumn = 0;\n\t    var previousGeneratedLine = 1;\n\t    var previousOriginalColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousName = 0;\n\t    var previousSource = 0;\n\t    var result = '';\n\t    var next;\n\t    var mapping;\n\t    var nameIdx;\n\t    var sourceIdx;\n\n\t    var mappings = this._mappings.toArray();\n\t    for (var i = 0, len = mappings.length; i < len; i++) {\n\t      mapping = mappings[i];\n\t      next = ''\n\n\t      if (mapping.generatedLine !== previousGeneratedLine) {\n\t        previousGeneratedColumn = 0;\n\t        while (mapping.generatedLine !== previousGeneratedLine) {\n\t          next += ';';\n\t          previousGeneratedLine++;\n\t        }\n\t      }\n\t      else {\n\t        if (i > 0) {\n\t          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n\t            continue;\n\t          }\n\t          next += ',';\n\t        }\n\t      }\n\n\t      next += base64VLQ.encode(mapping.generatedColumn\n\t                                 - previousGeneratedColumn);\n\t      previousGeneratedColumn = mapping.generatedColumn;\n\n\t      if (mapping.source != null) {\n\t        sourceIdx = this._sources.indexOf(mapping.source);\n\t        next += base64VLQ.encode(sourceIdx - previousSource);\n\t        previousSource = sourceIdx;\n\n\t        // lines are stored 0-based in SourceMap spec version 3\n\t        next += base64VLQ.encode(mapping.originalLine - 1\n\t                                   - previousOriginalLine);\n\t        previousOriginalLine = mapping.originalLine - 1;\n\n\t        next += base64VLQ.encode(mapping.originalColumn\n\t                                   - previousOriginalColumn);\n\t        previousOriginalColumn = mapping.originalColumn;\n\n\t        if (mapping.name != null) {\n\t          nameIdx = this._names.indexOf(mapping.name);\n\t          next += base64VLQ.encode(nameIdx - previousName);\n\t          previousName = nameIdx;\n\t        }\n\t      }\n\n\t      result += next;\n\t    }\n\n\t    return result;\n\t  };\n\n\tSourceMapGenerator.prototype._generateSourcesContent =\n\t  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n\t    return aSources.map(function (source) {\n\t      if (!this._sourcesContents) {\n\t        return null;\n\t      }\n\t      if (aSourceRoot != null) {\n\t        source = util.relative(aSourceRoot, source);\n\t      }\n\t      var key = util.toSetString(source);\n\t      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n\t        ? this._sourcesContents[key]\n\t        : null;\n\t    }, this);\n\t  };\n\n\t/**\n\t * Externalize the source map.\n\t */\n\tSourceMapGenerator.prototype.toJSON =\n\t  function SourceMapGenerator_toJSON() {\n\t    var map = {\n\t      version: this._version,\n\t      sources: this._sources.toArray(),\n\t      names: this._names.toArray(),\n\t      mappings: this._serializeMappings()\n\t    };\n\t    if (this._file != null) {\n\t      map.file = this._file;\n\t    }\n\t    if (this._sourceRoot != null) {\n\t      map.sourceRoot = this._sourceRoot;\n\t    }\n\t    if (this._sourcesContents) {\n\t      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n\t    }\n\n\t    return map;\n\t  };\n\n\t/**\n\t * Render the source map being generated to a string.\n\t */\n\tSourceMapGenerator.prototype.toString =\n\t  function SourceMapGenerator_toString() {\n\t    return JSON.stringify(this.toJSON());\n\t  };\n\n\texports.SourceMapGenerator = SourceMapGenerator;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t *\n\t * Based on the Base 64 VLQ implementation in Closure Compiler:\n\t * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n\t *\n\t * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *  * Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t *  * Redistributions in binary form must reproduce the above\n\t *    copyright notice, this list of conditions and the following\n\t *    disclaimer in the documentation and/or other materials provided\n\t *    with the distribution.\n\t *  * Neither the name of Google Inc. nor the names of its\n\t *    contributors may be used to endorse or promote products derived\n\t *    from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\n\tvar base64 = __webpack_require__(3);\n\n\t// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n\t// length quantities we use in the source map spec, the first bit is the sign,\n\t// the next four bits are the actual value, and the 6th bit is the\n\t// continuation bit. The continuation bit tells us whether there are more\n\t// digits in this value following this digit.\n\t//\n\t//   Continuation\n\t//   |    Sign\n\t//   |    |\n\t//   V    V\n\t//   101011\n\n\tvar VLQ_BASE_SHIFT = 5;\n\n\t// binary: 100000\n\tvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n\t// binary: 011111\n\tvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n\t// binary: 100000\n\tvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n\t/**\n\t * Converts from a two-complement value to a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n\t *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n\t */\n\tfunction toVLQSigned(aValue) {\n\t  return aValue < 0\n\t    ? ((-aValue) << 1) + 1\n\t    : (aValue << 1) + 0;\n\t}\n\n\t/**\n\t * Converts to a two-complement value from a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n\t *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n\t */\n\tfunction fromVLQSigned(aValue) {\n\t  var isNegative = (aValue & 1) === 1;\n\t  var shifted = aValue >> 1;\n\t  return isNegative\n\t    ? -shifted\n\t    : shifted;\n\t}\n\n\t/**\n\t * Returns the base 64 VLQ encoded value.\n\t */\n\texports.encode = function base64VLQ_encode(aValue) {\n\t  var encoded = \"\";\n\t  var digit;\n\n\t  var vlq = toVLQSigned(aValue);\n\n\t  do {\n\t    digit = vlq & VLQ_BASE_MASK;\n\t    vlq >>>= VLQ_BASE_SHIFT;\n\t    if (vlq > 0) {\n\t      // There are still more digits in this value, so we must make sure the\n\t      // continuation bit is marked.\n\t      digit |= VLQ_CONTINUATION_BIT;\n\t    }\n\t    encoded += base64.encode(digit);\n\t  } while (vlq > 0);\n\n\t  return encoded;\n\t};\n\n\t/**\n\t * Decodes the next base 64 VLQ value from the given string and returns the\n\t * value and the rest of the string via the out parameter.\n\t */\n\texports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n\t  var strLen = aStr.length;\n\t  var result = 0;\n\t  var shift = 0;\n\t  var continuation, digit;\n\n\t  do {\n\t    if (aIndex >= strLen) {\n\t      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n\t    }\n\n\t    digit = base64.decode(aStr.charCodeAt(aIndex++));\n\t    if (digit === -1) {\n\t      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n\t    }\n\n\t    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n\t    digit &= VLQ_BASE_MASK;\n\t    result = result + (digit << shift);\n\t    shift += VLQ_BASE_SHIFT;\n\t  } while (continuation);\n\n\t  aOutParam.value = fromVLQSigned(result);\n\t  aOutParam.rest = aIndex;\n\t};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n\t/**\n\t * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n\t */\n\texports.encode = function (number) {\n\t  if (0 <= number && number < intToCharMap.length) {\n\t    return intToCharMap[number];\n\t  }\n\t  throw new TypeError(\"Must be between 0 and 63: \" + number);\n\t};\n\n\t/**\n\t * Decode a single base 64 character code digit to an integer. Returns -1 on\n\t * failure.\n\t */\n\texports.decode = function (charCode) {\n\t  var bigA = 65;     // 'A'\n\t  var bigZ = 90;     // 'Z'\n\n\t  var littleA = 97;  // 'a'\n\t  var littleZ = 122; // 'z'\n\n\t  var zero = 48;     // '0'\n\t  var nine = 57;     // '9'\n\n\t  var plus = 43;     // '+'\n\t  var slash = 47;    // '/'\n\n\t  var littleOffset = 26;\n\t  var numberOffset = 52;\n\n\t  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t  if (bigA <= charCode && charCode <= bigZ) {\n\t    return (charCode - bigA);\n\t  }\n\n\t  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\t  if (littleA <= charCode && charCode <= littleZ) {\n\t    return (charCode - littleA + littleOffset);\n\t  }\n\n\t  // 52 - 61: 0123456789\n\t  if (zero <= charCode && charCode <= nine) {\n\t    return (charCode - zero + numberOffset);\n\t  }\n\n\t  // 62: +\n\t  if (charCode == plus) {\n\t    return 62;\n\t  }\n\n\t  // 63: /\n\t  if (charCode == slash) {\n\t    return 63;\n\t  }\n\n\t  // Invalid base64 digit.\n\t  return -1;\n\t};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\t/**\n\t * This is a helper function for getting values from parameter/options\n\t * objects.\n\t *\n\t * @param args The object we are extracting values from\n\t * @param name The name of the property we are getting.\n\t * @param defaultValue An optional value to return if the property is missing\n\t * from the object. If this is not specified and the property is missing, an\n\t * error will be thrown.\n\t */\n\tfunction getArg(aArgs, aName, aDefaultValue) {\n\t  if (aName in aArgs) {\n\t    return aArgs[aName];\n\t  } else if (arguments.length === 3) {\n\t    return aDefaultValue;\n\t  } else {\n\t    throw new Error('\"' + aName + '\" is a required argument.');\n\t  }\n\t}\n\texports.getArg = getArg;\n\n\tvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\n\tvar dataUrlRegexp = /^data:.+\\,.+$/;\n\n\tfunction urlParse(aUrl) {\n\t  var match = aUrl.match(urlRegexp);\n\t  if (!match) {\n\t    return null;\n\t  }\n\t  return {\n\t    scheme: match[1],\n\t    auth: match[2],\n\t    host: match[3],\n\t    port: match[4],\n\t    path: match[5]\n\t  };\n\t}\n\texports.urlParse = urlParse;\n\n\tfunction urlGenerate(aParsedUrl) {\n\t  var url = '';\n\t  if (aParsedUrl.scheme) {\n\t    url += aParsedUrl.scheme + ':';\n\t  }\n\t  url += '//';\n\t  if (aParsedUrl.auth) {\n\t    url += aParsedUrl.auth + '@';\n\t  }\n\t  if (aParsedUrl.host) {\n\t    url += aParsedUrl.host;\n\t  }\n\t  if (aParsedUrl.port) {\n\t    url += \":\" + aParsedUrl.port\n\t  }\n\t  if (aParsedUrl.path) {\n\t    url += aParsedUrl.path;\n\t  }\n\t  return url;\n\t}\n\texports.urlGenerate = urlGenerate;\n\n\t/**\n\t * Normalizes a path, or the path portion of a URL:\n\t *\n\t * - Replaces consecutive slashes with one slash.\n\t * - Removes unnecessary '.' parts.\n\t * - Removes unnecessary '<dir>/..' parts.\n\t *\n\t * Based on code in the Node.js 'path' core module.\n\t *\n\t * @param aPath The path or url to normalize.\n\t */\n\tfunction normalize(aPath) {\n\t  var path = aPath;\n\t  var url = urlParse(aPath);\n\t  if (url) {\n\t    if (!url.path) {\n\t      return aPath;\n\t    }\n\t    path = url.path;\n\t  }\n\t  var isAbsolute = exports.isAbsolute(path);\n\n\t  var parts = path.split(/\\/+/);\n\t  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n\t    part = parts[i];\n\t    if (part === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (part === '..') {\n\t      up++;\n\t    } else if (up > 0) {\n\t      if (part === '') {\n\t        // The first part is blank if the path is absolute. Trying to go\n\t        // above the root is a no-op. Therefore we can remove all '..' parts\n\t        // directly after the root.\n\t        parts.splice(i + 1, up);\n\t        up = 0;\n\t      } else {\n\t        parts.splice(i, 2);\n\t        up--;\n\t      }\n\t    }\n\t  }\n\t  path = parts.join('/');\n\n\t  if (path === '') {\n\t    path = isAbsolute ? '/' : '.';\n\t  }\n\n\t  if (url) {\n\t    url.path = path;\n\t    return urlGenerate(url);\n\t  }\n\t  return path;\n\t}\n\texports.normalize = normalize;\n\n\t/**\n\t * Joins two paths/URLs.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be joined with the root.\n\t *\n\t * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t *   first.\n\t * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t *   is updated with the result and aRoot is returned. Otherwise the result\n\t *   is returned.\n\t *   - If aPath is absolute, the result is aPath.\n\t *   - Otherwise the two paths are joined with a slash.\n\t * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t */\n\tfunction join(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t  if (aPath === \"\") {\n\t    aPath = \".\";\n\t  }\n\t  var aPathUrl = urlParse(aPath);\n\t  var aRootUrl = urlParse(aRoot);\n\t  if (aRootUrl) {\n\t    aRoot = aRootUrl.path || '/';\n\t  }\n\n\t  // `join(foo, '//www.example.org')`\n\t  if (aPathUrl && !aPathUrl.scheme) {\n\t    if (aRootUrl) {\n\t      aPathUrl.scheme = aRootUrl.scheme;\n\t    }\n\t    return urlGenerate(aPathUrl);\n\t  }\n\n\t  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t    return aPath;\n\t  }\n\n\t  // `join('http://', 'www.example.com')`\n\t  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t    aRootUrl.host = aPath;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\n\t  var joined = aPath.charAt(0) === '/'\n\t    ? aPath\n\t    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n\t  if (aRootUrl) {\n\t    aRootUrl.path = joined;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t  return joined;\n\t}\n\texports.join = join;\n\n\texports.isAbsolute = function (aPath) {\n\t  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n\t};\n\n\t/**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */\n\tfunction relative(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\n\t  aRoot = aRoot.replace(/\\/$/, '');\n\n\t  // It is possible for the path to be above the root. In this case, simply\n\t  // checking whether the root is a prefix of the path won't work. Instead, we\n\t  // need to remove components from the root one by one, until either we find\n\t  // a prefix that fits, or we run out of components to remove.\n\t  var level = 0;\n\t  while (aPath.indexOf(aRoot + '/') !== 0) {\n\t    var index = aRoot.lastIndexOf(\"/\");\n\t    if (index < 0) {\n\t      return aPath;\n\t    }\n\n\t    // If the only part of the root that is left is the scheme (i.e. http://,\n\t    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t    // have exhausted all components, so the path is not relative to the root.\n\t    aRoot = aRoot.slice(0, index);\n\t    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t      return aPath;\n\t    }\n\n\t    ++level;\n\t  }\n\n\t  // Make sure we add a \"../\" for each component we removed from the root.\n\t  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t}\n\texports.relative = relative;\n\n\tvar supportsNullProto = (function () {\n\t  var obj = Object.create(null);\n\t  return !('__proto__' in obj);\n\t}());\n\n\tfunction identity (s) {\n\t  return s;\n\t}\n\n\t/**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */\n\tfunction toSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return '$' + aStr;\n\t  }\n\n\t  return aStr;\n\t}\n\texports.toSetString = supportsNullProto ? identity : toSetString;\n\n\tfunction fromSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return aStr.slice(1);\n\t  }\n\n\t  return aStr;\n\t}\n\texports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n\tfunction isProtoString(s) {\n\t  if (!s) {\n\t    return false;\n\t  }\n\n\t  var length = s.length;\n\n\t  if (length < 9 /* \"__proto__\".length */) {\n\t    return false;\n\t  }\n\n\t  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n\t      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n\t      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n\t      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n\t    return false;\n\t  }\n\n\t  for (var i = length - 10; i >= 0; i--) {\n\t    if (s.charCodeAt(i) !== 36 /* '$' */) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\t/**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */\n\tfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t  var cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0 || onlyCompareOriginal) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByOriginalPositions = compareByOriginalPositions;\n\n\t/**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */\n\tfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0 || onlyCompareGenerated) {\n\t    return cmp;\n\t  }\n\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n\tfunction strcmp(aStr1, aStr2) {\n\t  if (aStr1 === aStr2) {\n\t    return 0;\n\t  }\n\n\t  if (aStr1 === null) {\n\t    return 1; // aStr2 !== null\n\t  }\n\n\t  if (aStr2 === null) {\n\t    return -1; // aStr1 !== null\n\t  }\n\n\t  if (aStr1 > aStr2) {\n\t    return 1;\n\t  }\n\n\t  return -1;\n\t}\n\n\t/**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */\n\tfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\t/**\n\t * Strip any JSON XSSI avoidance prefix from the string (as documented\n\t * in the source maps specification), and then parse the string as\n\t * JSON.\n\t */\n\tfunction parseSourceMapInput(str) {\n\t  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n\t}\n\texports.parseSourceMapInput = parseSourceMapInput;\n\n\t/**\n\t * Compute the URL of a source given the the source root, the source's\n\t * URL, and the source map's URL.\n\t */\n\tfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n\t  sourceURL = sourceURL || '';\n\n\t  if (sourceRoot) {\n\t    // This follows what Chrome does.\n\t    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n\t      sourceRoot += '/';\n\t    }\n\t    // The spec says:\n\t    //   Line 4: An optional source root, useful for relocating source\n\t    //   files on a server or removing repeated values in the\n\t    //   “sources” entry.  This value is prepended to the individual\n\t    //   entries in the “source” field.\n\t    sourceURL = sourceRoot + sourceURL;\n\t  }\n\n\t  // Historically, SourceMapConsumer did not take the sourceMapURL as\n\t  // a parameter.  This mode is still somewhat supported, which is why\n\t  // this code block is conditional.  However, it's preferable to pass\n\t  // the source map URL to SourceMapConsumer, so that this function\n\t  // can implement the source URL resolution algorithm as outlined in\n\t  // the spec.  This block is basically the equivalent of:\n\t  //    new URL(sourceURL, sourceMapURL).toString()\n\t  // ... except it avoids using URL, which wasn't available in the\n\t  // older releases of node still supported by this library.\n\t  //\n\t  // The spec says:\n\t  //   If the sources are not absolute URLs after prepending of the\n\t  //   “sourceRoot”, the sources are resolved relative to the\n\t  //   SourceMap (like resolving script src in a html document).\n\t  if (sourceMapURL) {\n\t    var parsed = urlParse(sourceMapURL);\n\t    if (!parsed) {\n\t      throw new Error(\"sourceMapURL could not be parsed\");\n\t    }\n\t    if (parsed.path) {\n\t      // Strip the last path component, but keep the \"/\".\n\t      var index = parsed.path.lastIndexOf('/');\n\t      if (index >= 0) {\n\t        parsed.path = parsed.path.substring(0, index + 1);\n\t      }\n\t    }\n\t    sourceURL = join(urlGenerate(parsed), sourceURL);\n\t  }\n\n\t  return normalize(sourceURL);\n\t}\n\texports.computeSourceURL = computeSourceURL;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar util = __webpack_require__(4);\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar hasNativeMap = typeof Map !== \"undefined\";\n\n\t/**\n\t * A data structure which is a combination of an array and a set. Adding a new\n\t * member is O(1), testing for membership is O(1), and finding the index of an\n\t * element is O(1). Removing elements from the set is not supported. Only\n\t * strings are supported for membership.\n\t */\n\tfunction ArraySet() {\n\t  this._array = [];\n\t  this._set = hasNativeMap ? new Map() : Object.create(null);\n\t}\n\n\t/**\n\t * Static method for creating ArraySet instances from an existing array.\n\t */\n\tArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t  var set = new ArraySet();\n\t  for (var i = 0, len = aArray.length; i < len; i++) {\n\t    set.add(aArray[i], aAllowDuplicates);\n\t  }\n\t  return set;\n\t};\n\n\t/**\n\t * Return how many unique items are in this ArraySet. If duplicates have been\n\t * added, than those do not count towards the size.\n\t *\n\t * @returns Number\n\t */\n\tArraySet.prototype.size = function ArraySet_size() {\n\t  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n\t};\n\n\t/**\n\t * Add the given string to this set.\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n\t  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n\t  var idx = this._array.length;\n\t  if (!isDuplicate || aAllowDuplicates) {\n\t    this._array.push(aStr);\n\t  }\n\t  if (!isDuplicate) {\n\t    if (hasNativeMap) {\n\t      this._set.set(aStr, idx);\n\t    } else {\n\t      this._set[sStr] = idx;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Is the given string a member of this set?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.has = function ArraySet_has(aStr) {\n\t  if (hasNativeMap) {\n\t    return this._set.has(aStr);\n\t  } else {\n\t    var sStr = util.toSetString(aStr);\n\t    return has.call(this._set, sStr);\n\t  }\n\t};\n\n\t/**\n\t * What is the index of the given string in the array?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t  if (hasNativeMap) {\n\t    var idx = this._set.get(aStr);\n\t    if (idx >= 0) {\n\t        return idx;\n\t    }\n\t  } else {\n\t    var sStr = util.toSetString(aStr);\n\t    if (has.call(this._set, sStr)) {\n\t      return this._set[sStr];\n\t    }\n\t  }\n\n\t  throw new Error('\"' + aStr + '\" is not in the set.');\n\t};\n\n\t/**\n\t * What is the element at the given index?\n\t *\n\t * @param Number aIdx\n\t */\n\tArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t  if (aIdx >= 0 && aIdx < this._array.length) {\n\t    return this._array[aIdx];\n\t  }\n\t  throw new Error('No element indexed by ' + aIdx);\n\t};\n\n\t/**\n\t * Returns the array representation of this set (which has the proper indices\n\t * indicated by indexOf). Note that this is a copy of the internal array used\n\t * for storing the members so that no one can mess with internal state.\n\t */\n\tArraySet.prototype.toArray = function ArraySet_toArray() {\n\t  return this._array.slice();\n\t};\n\n\texports.ArraySet = ArraySet;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2014 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar util = __webpack_require__(4);\n\n\t/**\n\t * Determine whether mappingB is after mappingA with respect to generated\n\t * position.\n\t */\n\tfunction generatedPositionAfter(mappingA, mappingB) {\n\t  // Optimized for most common case\n\t  var lineA = mappingA.generatedLine;\n\t  var lineB = mappingB.generatedLine;\n\t  var columnA = mappingA.generatedColumn;\n\t  var columnB = mappingB.generatedColumn;\n\t  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n\t         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n\t}\n\n\t/**\n\t * A data structure to provide a sorted view of accumulated mappings in a\n\t * performance conscious manner. It trades a neglibable overhead in general\n\t * case for a large speedup in case of mappings being added in order.\n\t */\n\tfunction MappingList() {\n\t  this._array = [];\n\t  this._sorted = true;\n\t  // Serves as infimum\n\t  this._last = {generatedLine: -1, generatedColumn: 0};\n\t}\n\n\t/**\n\t * Iterate through internal items. This method takes the same arguments that\n\t * `Array.prototype.forEach` takes.\n\t *\n\t * NOTE: The order of the mappings is NOT guaranteed.\n\t */\n\tMappingList.prototype.unsortedForEach =\n\t  function MappingList_forEach(aCallback, aThisArg) {\n\t    this._array.forEach(aCallback, aThisArg);\n\t  };\n\n\t/**\n\t * Add the given source mapping.\n\t *\n\t * @param Object aMapping\n\t */\n\tMappingList.prototype.add = function MappingList_add(aMapping) {\n\t  if (generatedPositionAfter(this._last, aMapping)) {\n\t    this._last = aMapping;\n\t    this._array.push(aMapping);\n\t  } else {\n\t    this._sorted = false;\n\t    this._array.push(aMapping);\n\t  }\n\t};\n\n\t/**\n\t * Returns the flat, sorted array of mappings. The mappings are sorted by\n\t * generated position.\n\t *\n\t * WARNING: This method returns internal data without copying, for\n\t * performance. The return value must NOT be mutated, and should be treated as\n\t * an immutable borrow. If you want to take ownership, you must make your own\n\t * copy.\n\t */\n\tMappingList.prototype.toArray = function MappingList_toArray() {\n\t  if (!this._sorted) {\n\t    this._array.sort(util.compareByGeneratedPositionsInflated);\n\t    this._sorted = true;\n\t  }\n\t  return this._array;\n\t};\n\n\texports.MappingList = MappingList;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar util = __webpack_require__(4);\n\tvar binarySearch = __webpack_require__(8);\n\tvar ArraySet = __webpack_require__(5).ArraySet;\n\tvar base64VLQ = __webpack_require__(2);\n\tvar quickSort = __webpack_require__(9).quickSort;\n\n\tfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = util.parseSourceMapInput(aSourceMap);\n\t  }\n\n\t  return sourceMap.sections != null\n\t    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n\t    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n\t}\n\n\tSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n\t  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n\t}\n\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tSourceMapConsumer.prototype._version = 3;\n\n\t// `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t// are lazily instantiated, accessed via the `_generatedMappings` and\n\t// `_originalMappings` getters respectively, and we only parse the mappings\n\t// and create these arrays once queried for a source location. We jump through\n\t// these hoops because there can be many thousands of mappings, and parsing\n\t// them is expensive, so we only want to do it if we must.\n\t//\n\t// Each object in the arrays is of the form:\n\t//\n\t//     {\n\t//       generatedLine: The line number in the generated code,\n\t//       generatedColumn: The column number in the generated code,\n\t//       source: The path to the original source file that generated this\n\t//               chunk of code,\n\t//       originalLine: The line number in the original source that\n\t//                     corresponds to this chunk of generated code,\n\t//       originalColumn: The column number in the original source that\n\t//                       corresponds to this chunk of generated code,\n\t//       name: The name of the original symbol which generated this chunk of\n\t//             code.\n\t//     }\n\t//\n\t// All properties except for `generatedLine` and `generatedColumn` can be\n\t// `null`.\n\t//\n\t// `_generatedMappings` is ordered by the generated positions.\n\t//\n\t// `_originalMappings` is ordered by the original positions.\n\n\tSourceMapConsumer.prototype.__generatedMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.__generatedMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\n\t    return this.__generatedMappings;\n\t  }\n\t});\n\n\tSourceMapConsumer.prototype.__originalMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.__originalMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\n\t    return this.__originalMappings;\n\t  }\n\t});\n\n\tSourceMapConsumer.prototype._charIsMappingSeparator =\n\t  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t    var c = aStr.charAt(index);\n\t    return c === \";\" || c === \",\";\n\t  };\n\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    throw new Error(\"Subclasses must implement _parseMappings\");\n\t  };\n\n\tSourceMapConsumer.GENERATED_ORDER = 1;\n\tSourceMapConsumer.ORIGINAL_ORDER = 2;\n\n\tSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\tSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n\t/**\n\t * Iterate over each mapping between an original source/line/column and a\n\t * generated line/column in this source map.\n\t *\n\t * @param Function aCallback\n\t *        The function that is called with each mapping.\n\t * @param Object aContext\n\t *        Optional. If specified, this object will be the value of `this` every\n\t *        time that `aCallback` is called.\n\t * @param aOrder\n\t *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t *        iterate over the mappings sorted by the generated file's line/column\n\t *        order or the original's source/line/column order, respectively. Defaults to\n\t *        `SourceMapConsumer.GENERATED_ORDER`.\n\t */\n\tSourceMapConsumer.prototype.eachMapping =\n\t  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t    var context = aContext || null;\n\t    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n\t    var mappings;\n\t    switch (order) {\n\t    case SourceMapConsumer.GENERATED_ORDER:\n\t      mappings = this._generatedMappings;\n\t      break;\n\t    case SourceMapConsumer.ORIGINAL_ORDER:\n\t      mappings = this._originalMappings;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unknown order of iteration.\");\n\t    }\n\n\t    var sourceRoot = this.sourceRoot;\n\t    mappings.map(function (mapping) {\n\t      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n\t      return {\n\t        source: source,\n\t        generatedLine: mapping.generatedLine,\n\t        generatedColumn: mapping.generatedColumn,\n\t        originalLine: mapping.originalLine,\n\t        originalColumn: mapping.originalColumn,\n\t        name: mapping.name === null ? null : this._names.at(mapping.name)\n\t      };\n\t    }, this).forEach(aCallback, context);\n\t  };\n\n\t/**\n\t * Returns all generated line and column information for the original source,\n\t * line, and column provided. If no column is provided, returns all mappings\n\t * corresponding to a either the line we are searching for or the next\n\t * closest line that has any mappings. Otherwise, returns all mappings\n\t * corresponding to the given line and either the column we are searching for\n\t * or the next closest column that has any offsets.\n\t *\n\t * The only argument is an object with the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.  The line number is 1-based.\n\t *   - column: Optional. the column number in the original source.\n\t *    The column number is 0-based.\n\t *\n\t * and an array of objects is returned, each with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.  The\n\t *    line number is 1-based.\n\t *   - column: The column number in the generated source, or null.\n\t *    The column number is 0-based.\n\t */\n\tSourceMapConsumer.prototype.allGeneratedPositionsFor =\n\t  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n\t    var line = util.getArg(aArgs, 'line');\n\n\t    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n\t    // returns the index of the closest mapping less than the needle. By\n\t    // setting needle.originalColumn to 0, we thus find the last mapping for\n\t    // the given line, provided such a mapping exists.\n\t    var needle = {\n\t      source: util.getArg(aArgs, 'source'),\n\t      originalLine: line,\n\t      originalColumn: util.getArg(aArgs, 'column', 0)\n\t    };\n\n\t    needle.source = this._findSourceIndex(needle.source);\n\t    if (needle.source < 0) {\n\t      return [];\n\t    }\n\n\t    var mappings = [];\n\n\t    var index = this._findMapping(needle,\n\t                                  this._originalMappings,\n\t                                  \"originalLine\",\n\t                                  \"originalColumn\",\n\t                                  util.compareByOriginalPositions,\n\t                                  binarySearch.LEAST_UPPER_BOUND);\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\n\t      if (aArgs.column === undefined) {\n\t        var originalLine = mapping.originalLine;\n\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we found. Since\n\t        // mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we found.\n\t        while (mapping && mapping.originalLine === originalLine) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      } else {\n\t        var originalColumn = mapping.originalColumn;\n\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we were searching for.\n\t        // Since mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we are searching for.\n\t        while (mapping &&\n\t               mapping.originalLine === line &&\n\t               mapping.originalColumn == originalColumn) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      }\n\t    }\n\n\t    return mappings;\n\t  };\n\n\texports.SourceMapConsumer = SourceMapConsumer;\n\n\t/**\n\t * A BasicSourceMapConsumer instance represents a parsed source map which we can\n\t * query for information about the original file positions by giving it a file\n\t * position in the generated source.\n\t *\n\t * The first parameter is the raw source map (either as a JSON string, or\n\t * already parsed to an object). According to the spec, source maps have the\n\t * following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - sources: An array of URLs to the original source files.\n\t *   - names: An array of identifiers which can be referrenced by individual mappings.\n\t *   - sourceRoot: Optional. The URL root from which all sources are relative.\n\t *   - sourcesContent: Optional. An array of contents of the original source files.\n\t *   - mappings: A string of base64 VLQs which contain the actual mappings.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *\n\t * Here is an example source map, taken from the source map spec[0]:\n\t *\n\t *     {\n\t *       version : 3,\n\t *       file: \"out.js\",\n\t *       sourceRoot : \"\",\n\t *       sources: [\"foo.js\", \"bar.js\"],\n\t *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *       mappings: \"AA,AB;;ABCDE;\"\n\t *     }\n\t *\n\t * The second parameter, if given, is a string whose value is the URL\n\t * at which the source map was found.  This URL is used to compute the\n\t * sources array.\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n\t */\n\tfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = util.parseSourceMapInput(aSourceMap);\n\t  }\n\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sources = util.getArg(sourceMap, 'sources');\n\t  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n\t  // requires the array) to play nice here.\n\t  var names = util.getArg(sourceMap, 'names', []);\n\t  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n\t  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n\t  var mappings = util.getArg(sourceMap, 'mappings');\n\t  var file = util.getArg(sourceMap, 'file', null);\n\n\t  // Once again, Sass deviates from the spec and supplies the version as a\n\t  // string rather than a number, so we use loose equality checking here.\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\n\t  if (sourceRoot) {\n\t    sourceRoot = util.normalize(sourceRoot);\n\t  }\n\n\t  sources = sources\n\t    .map(String)\n\t    // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n\t    // See bugzil.la/1090768.\n\t    .map(util.normalize)\n\t    // Always ensure that absolute sources are internally stored relative to\n\t    // the source root, if the source root is absolute. Not doing this would\n\t    // be particularly problematic when the source root is a prefix of the\n\t    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n\t    .map(function (source) {\n\t      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n\t        ? util.relative(sourceRoot, source)\n\t        : source;\n\t    });\n\n\t  // Pass `true` below to allow duplicate names and sources. While source maps\n\t  // are intended to be compressed and deduplicated, the TypeScript compiler\n\t  // sometimes generates source maps with duplicates in them. See Github issue\n\t  // #72 and bugzil.la/889492.\n\t  this._names = ArraySet.fromArray(names.map(String), true);\n\t  this._sources = ArraySet.fromArray(sources, true);\n\n\t  this._absoluteSources = this._sources.toArray().map(function (s) {\n\t    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n\t  });\n\n\t  this.sourceRoot = sourceRoot;\n\t  this.sourcesContent = sourcesContent;\n\t  this._mappings = mappings;\n\t  this._sourceMapURL = aSourceMapURL;\n\t  this.file = file;\n\t}\n\n\tBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n\t/**\n\t * Utility function to find the index of a source.  Returns -1 if not\n\t * found.\n\t */\n\tBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n\t  var relativeSource = aSource;\n\t  if (this.sourceRoot != null) {\n\t    relativeSource = util.relative(this.sourceRoot, relativeSource);\n\t  }\n\n\t  if (this._sources.has(relativeSource)) {\n\t    return this._sources.indexOf(relativeSource);\n\t  }\n\n\t  // Maybe aSource is an absolute URL as returned by |sources|.  In\n\t  // this case we can't simply undo the transform.\n\t  var i;\n\t  for (i = 0; i < this._absoluteSources.length; ++i) {\n\t    if (this._absoluteSources[i] == aSource) {\n\t      return i;\n\t    }\n\t  }\n\n\t  return -1;\n\t};\n\n\t/**\n\t * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n\t *\n\t * @param SourceMapGenerator aSourceMap\n\t *        The source map that will be consumed.\n\t * @param String aSourceMapURL\n\t *        The URL at which the source map can be found (optional)\n\t * @returns BasicSourceMapConsumer\n\t */\n\tBasicSourceMapConsumer.fromSourceMap =\n\t  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n\t    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n\t    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n\t    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n\t    smc.sourceRoot = aSourceMap._sourceRoot;\n\t    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n\t                                                            smc.sourceRoot);\n\t    smc.file = aSourceMap._file;\n\t    smc._sourceMapURL = aSourceMapURL;\n\t    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n\t      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n\t    });\n\n\t    // Because we are modifying the entries (by converting string sources and\n\t    // names to indices into the sources and names ArraySets), we have to make\n\t    // a copy of the entry or else bad things happen. Shared mutable state\n\t    // strikes again! See github issue #191.\n\n\t    var generatedMappings = aSourceMap._mappings.toArray().slice();\n\t    var destGeneratedMappings = smc.__generatedMappings = [];\n\t    var destOriginalMappings = smc.__originalMappings = [];\n\n\t    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n\t      var srcMapping = generatedMappings[i];\n\t      var destMapping = new Mapping;\n\t      destMapping.generatedLine = srcMapping.generatedLine;\n\t      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n\t      if (srcMapping.source) {\n\t        destMapping.source = sources.indexOf(srcMapping.source);\n\t        destMapping.originalLine = srcMapping.originalLine;\n\t        destMapping.originalColumn = srcMapping.originalColumn;\n\n\t        if (srcMapping.name) {\n\t          destMapping.name = names.indexOf(srcMapping.name);\n\t        }\n\n\t        destOriginalMappings.push(destMapping);\n\t      }\n\n\t      destGeneratedMappings.push(destMapping);\n\t    }\n\n\t    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n\t    return smc;\n\t  };\n\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tBasicSourceMapConsumer.prototype._version = 3;\n\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    return this._absoluteSources.slice();\n\t  }\n\t});\n\n\t/**\n\t * Provide the JIT with a nice shape / hidden class.\n\t */\n\tfunction Mapping() {\n\t  this.generatedLine = 0;\n\t  this.generatedColumn = 0;\n\t  this.source = null;\n\t  this.originalLine = null;\n\t  this.originalColumn = null;\n\t  this.name = null;\n\t}\n\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tBasicSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    var generatedLine = 1;\n\t    var previousGeneratedColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousOriginalColumn = 0;\n\t    var previousSource = 0;\n\t    var previousName = 0;\n\t    var length = aStr.length;\n\t    var index = 0;\n\t    var cachedSegments = {};\n\t    var temp = {};\n\t    var originalMappings = [];\n\t    var generatedMappings = [];\n\t    var mapping, str, segment, end, value;\n\n\t    while (index < length) {\n\t      if (aStr.charAt(index) === ';') {\n\t        generatedLine++;\n\t        index++;\n\t        previousGeneratedColumn = 0;\n\t      }\n\t      else if (aStr.charAt(index) === ',') {\n\t        index++;\n\t      }\n\t      else {\n\t        mapping = new Mapping();\n\t        mapping.generatedLine = generatedLine;\n\n\t        // Because each offset is encoded relative to the previous one,\n\t        // many segments often have the same encoding. We can exploit this\n\t        // fact by caching the parsed variable length fields of each segment,\n\t        // allowing us to avoid a second parse if we encounter the same\n\t        // segment again.\n\t        for (end = index; end < length; end++) {\n\t          if (this._charIsMappingSeparator(aStr, end)) {\n\t            break;\n\t          }\n\t        }\n\t        str = aStr.slice(index, end);\n\n\t        segment = cachedSegments[str];\n\t        if (segment) {\n\t          index += str.length;\n\t        } else {\n\t          segment = [];\n\t          while (index < end) {\n\t            base64VLQ.decode(aStr, index, temp);\n\t            value = temp.value;\n\t            index = temp.rest;\n\t            segment.push(value);\n\t          }\n\n\t          if (segment.length === 2) {\n\t            throw new Error('Found a source, but no line and column');\n\t          }\n\n\t          if (segment.length === 3) {\n\t            throw new Error('Found a source and line, but no column');\n\t          }\n\n\t          cachedSegments[str] = segment;\n\t        }\n\n\t        // Generated column.\n\t        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n\t        previousGeneratedColumn = mapping.generatedColumn;\n\n\t        if (segment.length > 1) {\n\t          // Original source.\n\t          mapping.source = previousSource + segment[1];\n\t          previousSource += segment[1];\n\n\t          // Original line.\n\t          mapping.originalLine = previousOriginalLine + segment[2];\n\t          previousOriginalLine = mapping.originalLine;\n\t          // Lines are stored 0-based\n\t          mapping.originalLine += 1;\n\n\t          // Original column.\n\t          mapping.originalColumn = previousOriginalColumn + segment[3];\n\t          previousOriginalColumn = mapping.originalColumn;\n\n\t          if (segment.length > 4) {\n\t            // Original name.\n\t            mapping.name = previousName + segment[4];\n\t            previousName += segment[4];\n\t          }\n\t        }\n\n\t        generatedMappings.push(mapping);\n\t        if (typeof mapping.originalLine === 'number') {\n\t          originalMappings.push(mapping);\n\t        }\n\t      }\n\t    }\n\n\t    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    this.__generatedMappings = generatedMappings;\n\n\t    quickSort(originalMappings, util.compareByOriginalPositions);\n\t    this.__originalMappings = originalMappings;\n\t  };\n\n\t/**\n\t * Find the mapping that best matches the hypothetical \"needle\" mapping that\n\t * we are searching for in the given \"haystack\" of mappings.\n\t */\n\tBasicSourceMapConsumer.prototype._findMapping =\n\t  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n\t                                         aColumnName, aComparator, aBias) {\n\t    // To return the position we are searching for, we must first find the\n\t    // mapping for the given position and then return the opposite position it\n\t    // points to. Because the mappings are sorted, we can use binary search to\n\t    // find the best mapping.\n\n\t    if (aNeedle[aLineName] <= 0) {\n\t      throw new TypeError('Line must be greater than or equal to 1, got '\n\t                          + aNeedle[aLineName]);\n\t    }\n\t    if (aNeedle[aColumnName] < 0) {\n\t      throw new TypeError('Column must be greater than or equal to 0, got '\n\t                          + aNeedle[aColumnName]);\n\t    }\n\n\t    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n\t  };\n\n\t/**\n\t * Compute the last column for each generated mapping. The last column is\n\t * inclusive.\n\t */\n\tBasicSourceMapConsumer.prototype.computeColumnSpans =\n\t  function SourceMapConsumer_computeColumnSpans() {\n\t    for (var index = 0; index < this._generatedMappings.length; ++index) {\n\t      var mapping = this._generatedMappings[index];\n\n\t      // Mappings do not contain a field for the last generated columnt. We\n\t      // can come up with an optimistic estimate, however, by assuming that\n\t      // mappings are contiguous (i.e. given two consecutive mappings, the\n\t      // first mapping ends where the second one starts).\n\t      if (index + 1 < this._generatedMappings.length) {\n\t        var nextMapping = this._generatedMappings[index + 1];\n\n\t        if (mapping.generatedLine === nextMapping.generatedLine) {\n\t          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n\t          continue;\n\t        }\n\t      }\n\n\t      // The last mapping for each line spans the entire line.\n\t      mapping.lastGeneratedColumn = Infinity;\n\t    }\n\t  };\n\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.  The line number\n\t *     is 1-based.\n\t *   - column: The column number in the generated source.  The column\n\t *     number is 0-based.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.  The\n\t *     line number is 1-based.\n\t *   - column: The column number in the original source, or null.  The\n\t *     column number is 0-based.\n\t *   - name: The original identifier, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.originalPositionFor =\n\t  function SourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._generatedMappings,\n\t      \"generatedLine\",\n\t      \"generatedColumn\",\n\t      util.compareByGeneratedPositionsDeflated,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\n\t    if (index >= 0) {\n\t      var mapping = this._generatedMappings[index];\n\n\t      if (mapping.generatedLine === needle.generatedLine) {\n\t        var source = util.getArg(mapping, 'source', null);\n\t        if (source !== null) {\n\t          source = this._sources.at(source);\n\t          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n\t        }\n\t        var name = util.getArg(mapping, 'name', null);\n\t        if (name !== null) {\n\t          name = this._names.at(name);\n\t        }\n\t        return {\n\t          source: source,\n\t          line: util.getArg(mapping, 'originalLine', null),\n\t          column: util.getArg(mapping, 'originalColumn', null),\n\t          name: name\n\t        };\n\t      }\n\t    }\n\n\t    return {\n\t      source: null,\n\t      line: null,\n\t      column: null,\n\t      name: null\n\t    };\n\t  };\n\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n\t    if (!this.sourcesContent) {\n\t      return false;\n\t    }\n\t    return this.sourcesContent.length >= this._sources.size() &&\n\t      !this.sourcesContent.some(function (sc) { return sc == null; });\n\t  };\n\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tBasicSourceMapConsumer.prototype.sourceContentFor =\n\t  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    if (!this.sourcesContent) {\n\t      return null;\n\t    }\n\n\t    var index = this._findSourceIndex(aSource);\n\t    if (index >= 0) {\n\t      return this.sourcesContent[index];\n\t    }\n\n\t    var relativeSource = aSource;\n\t    if (this.sourceRoot != null) {\n\t      relativeSource = util.relative(this.sourceRoot, relativeSource);\n\t    }\n\n\t    var url;\n\t    if (this.sourceRoot != null\n\t        && (url = util.urlParse(this.sourceRoot))) {\n\t      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t      // many users. We can help them out when they expect file:// URIs to\n\t      // behave like it would if they were running a local HTTP server. See\n\t      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n\t      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n\t      if (url.scheme == \"file\"\n\t          && this._sources.has(fileUriAbsPath)) {\n\t        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t      }\n\n\t      if ((!url.path || url.path == \"/\")\n\t          && this._sources.has(\"/\" + relativeSource)) {\n\t        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n\t      }\n\t    }\n\n\t    // This function is used recursively from\n\t    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n\t    // don't want to throw if we can't find the source - we just want to\n\t    // return null, so we provide a flag to exit gracefully.\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.  The line number\n\t *     is 1-based.\n\t *   - column: The column number in the original source.  The column\n\t *     number is 0-based.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.  The\n\t *     line number is 1-based.\n\t *   - column: The column number in the generated source, or null.\n\t *     The column number is 0-based.\n\t */\n\tBasicSourceMapConsumer.prototype.generatedPositionFor =\n\t  function SourceMapConsumer_generatedPositionFor(aArgs) {\n\t    var source = util.getArg(aArgs, 'source');\n\t    source = this._findSourceIndex(source);\n\t    if (source < 0) {\n\t      return {\n\t        line: null,\n\t        column: null,\n\t        lastColumn: null\n\t      };\n\t    }\n\n\t    var needle = {\n\t      source: source,\n\t      originalLine: util.getArg(aArgs, 'line'),\n\t      originalColumn: util.getArg(aArgs, 'column')\n\t    };\n\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._originalMappings,\n\t      \"originalLine\",\n\t      \"originalColumn\",\n\t      util.compareByOriginalPositions,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\n\t      if (mapping.source === needle.source) {\n\t        return {\n\t          line: util.getArg(mapping, 'generatedLine', null),\n\t          column: util.getArg(mapping, 'generatedColumn', null),\n\t          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t        };\n\t      }\n\t    }\n\n\t    return {\n\t      line: null,\n\t      column: null,\n\t      lastColumn: null\n\t    };\n\t  };\n\n\texports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n\t/**\n\t * An IndexedSourceMapConsumer instance represents a parsed source map which\n\t * we can query for information. It differs from BasicSourceMapConsumer in\n\t * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n\t * input.\n\t *\n\t * The first parameter is a raw source map (either as a JSON string, or already\n\t * parsed to an object). According to the spec for indexed source maps, they\n\t * have the following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *   - sections: A list of section definitions.\n\t *\n\t * Each value under the \"sections\" field has two fields:\n\t *   - offset: The offset into the original specified at which this section\n\t *       begins to apply, defined as an object with a \"line\" and \"column\"\n\t *       field.\n\t *   - map: A source map definition. This source map could also be indexed,\n\t *       but doesn't have to be.\n\t *\n\t * Instead of the \"map\" field, it's also possible to have a \"url\" field\n\t * specifying a URL to retrieve a source map from, but that's currently\n\t * unsupported.\n\t *\n\t * Here's an example source map, taken from the source map spec[0], but\n\t * modified to omit a section which uses the \"url\" field.\n\t *\n\t *  {\n\t *    version : 3,\n\t *    file: \"app.js\",\n\t *    sections: [{\n\t *      offset: {line:100, column:10},\n\t *      map: {\n\t *        version : 3,\n\t *        file: \"section.js\",\n\t *        sources: [\"foo.js\", \"bar.js\"],\n\t *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *        mappings: \"AAAA,E;;ABCDE;\"\n\t *      }\n\t *    }],\n\t *  }\n\t *\n\t * The second parameter, if given, is a string whose value is the URL\n\t * at which the source map was found.  This URL is used to compute the\n\t * sources array.\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n\t */\n\tfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = util.parseSourceMapInput(aSourceMap);\n\t  }\n\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sections = util.getArg(sourceMap, 'sections');\n\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\n\t  var lastOffset = {\n\t    line: -1,\n\t    column: 0\n\t  };\n\t  this._sections = sections.map(function (s) {\n\t    if (s.url) {\n\t      // The url field will require support for asynchronicity.\n\t      // See https://github.com/mozilla/source-map/issues/16\n\t      throw new Error('Support for url field in sections not implemented.');\n\t    }\n\t    var offset = util.getArg(s, 'offset');\n\t    var offsetLine = util.getArg(offset, 'line');\n\t    var offsetColumn = util.getArg(offset, 'column');\n\n\t    if (offsetLine < lastOffset.line ||\n\t        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n\t      throw new Error('Section offsets must be ordered and non-overlapping.');\n\t    }\n\t    lastOffset = offset;\n\n\t    return {\n\t      generatedOffset: {\n\t        // The offset fields are 0-based, but we use 1-based indices when\n\t        // encoding/decoding from VLQ.\n\t        generatedLine: offsetLine + 1,\n\t        generatedColumn: offsetColumn + 1\n\t      },\n\t      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n\t    }\n\t  });\n\t}\n\n\tIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tIndexedSourceMapConsumer.prototype._version = 3;\n\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    var sources = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n\t        sources.push(this._sections[i].consumer.sources[j]);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\t});\n\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.  The line number\n\t *     is 1-based.\n\t *   - column: The column number in the generated source.  The column\n\t *     number is 0-based.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.  The\n\t *     line number is 1-based.\n\t *   - column: The column number in the original source, or null.  The\n\t *     column number is 0-based.\n\t *   - name: The original identifier, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.originalPositionFor =\n\t  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\n\t    // Find the section containing the generated position we're trying to map\n\t    // to an original position.\n\t    var sectionIndex = binarySearch.search(needle, this._sections,\n\t      function(needle, section) {\n\t        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\t        if (cmp) {\n\t          return cmp;\n\t        }\n\n\t        return (needle.generatedColumn -\n\t                section.generatedOffset.generatedColumn);\n\t      });\n\t    var section = this._sections[sectionIndex];\n\n\t    if (!section) {\n\t      return {\n\t        source: null,\n\t        line: null,\n\t        column: null,\n\t        name: null\n\t      };\n\t    }\n\n\t    return section.consumer.originalPositionFor({\n\t      line: needle.generatedLine -\n\t        (section.generatedOffset.generatedLine - 1),\n\t      column: needle.generatedColumn -\n\t        (section.generatedOffset.generatedLine === needle.generatedLine\n\t         ? section.generatedOffset.generatedColumn - 1\n\t         : 0),\n\t      bias: aArgs.bias\n\t    });\n\t  };\n\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n\t    return this._sections.every(function (s) {\n\t      return s.consumer.hasContentsOfAllSources();\n\t    });\n\t  };\n\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tIndexedSourceMapConsumer.prototype.sourceContentFor =\n\t  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\n\t      var content = section.consumer.sourceContentFor(aSource, true);\n\t      if (content) {\n\t        return content;\n\t      }\n\t    }\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.  The line number\n\t *     is 1-based.\n\t *   - column: The column number in the original source.  The column\n\t *     number is 0-based.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.  The\n\t *     line number is 1-based. \n\t *   - column: The column number in the generated source, or null.\n\t *     The column number is 0-based.\n\t */\n\tIndexedSourceMapConsumer.prototype.generatedPositionFor =\n\t  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\n\t      // Only consider this section if the requested source is in the list of\n\t      // sources of the consumer.\n\t      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n\t        continue;\n\t      }\n\t      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\t      if (generatedPosition) {\n\t        var ret = {\n\t          line: generatedPosition.line +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          column: generatedPosition.column +\n\t            (section.generatedOffset.generatedLine === generatedPosition.line\n\t             ? section.generatedOffset.generatedColumn - 1\n\t             : 0)\n\t        };\n\t        return ret;\n\t      }\n\t    }\n\n\t    return {\n\t      line: null,\n\t      column: null\n\t    };\n\t  };\n\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tIndexedSourceMapConsumer.prototype._parseMappings =\n\t  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    this.__generatedMappings = [];\n\t    this.__originalMappings = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t      var sectionMappings = section.consumer._generatedMappings;\n\t      for (var j = 0; j < sectionMappings.length; j++) {\n\t        var mapping = sectionMappings[j];\n\n\t        var source = section.consumer._sources.at(mapping.source);\n\t        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n\t        this._sources.add(source);\n\t        source = this._sources.indexOf(source);\n\n\t        var name = null;\n\t        if (mapping.name) {\n\t          name = section.consumer._names.at(mapping.name);\n\t          this._names.add(name);\n\t          name = this._names.indexOf(name);\n\t        }\n\n\t        // The mappings coming from the consumer for the section have\n\t        // generated positions relative to the start of the section, so we\n\t        // need to offset them to be relative to the start of the concatenated\n\t        // generated file.\n\t        var adjustedMapping = {\n\t          source: source,\n\t          generatedLine: mapping.generatedLine +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          generatedColumn: mapping.generatedColumn +\n\t            (section.generatedOffset.generatedLine === mapping.generatedLine\n\t            ? section.generatedOffset.generatedColumn - 1\n\t            : 0),\n\t          originalLine: mapping.originalLine,\n\t          originalColumn: mapping.originalColumn,\n\t          name: name\n\t        };\n\n\t        this.__generatedMappings.push(adjustedMapping);\n\t        if (typeof adjustedMapping.originalLine === 'number') {\n\t          this.__originalMappings.push(adjustedMapping);\n\t        }\n\t      }\n\t    }\n\n\t    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n\t  };\n\n\texports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\texports.GREATEST_LOWER_BOUND = 1;\n\texports.LEAST_UPPER_BOUND = 2;\n\n\t/**\n\t * Recursive implementation of binary search.\n\t *\n\t * @param aLow Indices here and lower do not contain the needle.\n\t * @param aHigh Indices here and higher do not contain the needle.\n\t * @param aNeedle The element being searched for.\n\t * @param aHaystack The non-empty array being searched.\n\t * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t */\n\tfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n\t  // This function terminates when one of the following is true:\n\t  //\n\t  //   1. We find the exact element we are looking for.\n\t  //\n\t  //   2. We did not find the exact element, but we can return the index of\n\t  //      the next-closest element.\n\t  //\n\t  //   3. We did not find the exact element, and there is no next-closest\n\t  //      element than the one we are searching for, so we return -1.\n\t  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n\t  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\t  if (cmp === 0) {\n\t    // Found the element we are looking for.\n\t    return mid;\n\t  }\n\t  else if (cmp > 0) {\n\t    // Our needle is greater than aHaystack[mid].\n\t    if (aHigh - mid > 1) {\n\t      // The element is in the upper half.\n\t      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\n\t    // The exact needle element was not found in this haystack. Determine if\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return aHigh < aHaystack.length ? aHigh : -1;\n\t    } else {\n\t      return mid;\n\t    }\n\t  }\n\t  else {\n\t    // Our needle is less than aHaystack[mid].\n\t    if (mid - aLow > 1) {\n\t      // The element is in the lower half.\n\t      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return mid;\n\t    } else {\n\t      return aLow < 0 ? -1 : aLow;\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * This is an implementation of binary search which will always try and return\n\t * the index of the closest element if there is no exact hit. This is because\n\t * mappings between original and generated line/col pairs are single points,\n\t * and there is an implicit region between each of them, so a miss just means\n\t * that you aren't on the very start of a region.\n\t *\n\t * @param aNeedle The element you are looking for.\n\t * @param aHaystack The array that is being searched.\n\t * @param aCompare A function which takes the needle and an element in the\n\t *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t *     than, equal to, or greater than the element, respectively.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t */\n\texports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n\t  if (aHaystack.length === 0) {\n\t    return -1;\n\t  }\n\n\t  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n\t                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\t  if (index < 0) {\n\t    return -1;\n\t  }\n\n\t  // We have found either the exact element, or the next-closest element than\n\t  // the one we are searching for. However, there may be more than one such\n\t  // element. Make sure we always return the smallest of these.\n\t  while (index - 1 >= 0) {\n\t    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n\t      break;\n\t    }\n\t    --index;\n\t  }\n\n\t  return index;\n\t};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\t// It turns out that some (most?) JavaScript engines don't self-host\n\t// `Array.prototype.sort`. This makes sense because C++ will likely remain\n\t// faster than JS when doing raw CPU-intensive sorting. However, when using a\n\t// custom comparator function, calling back and forth between the VM's C++ and\n\t// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n\t// worse generated code for the comparator function than would be optimal. In\n\t// fact, when sorting with a comparator, these costs outweigh the benefits of\n\t// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n\t// a ~3500ms mean speed-up in `bench/bench.html`.\n\n\t/**\n\t * Swap the elements indexed by `x` and `y` in the array `ary`.\n\t *\n\t * @param {Array} ary\n\t *        The array.\n\t * @param {Number} x\n\t *        The index of the first item.\n\t * @param {Number} y\n\t *        The index of the second item.\n\t */\n\tfunction swap(ary, x, y) {\n\t  var temp = ary[x];\n\t  ary[x] = ary[y];\n\t  ary[y] = temp;\n\t}\n\n\t/**\n\t * Returns a random integer within the range `low .. high` inclusive.\n\t *\n\t * @param {Number} low\n\t *        The lower bound on the range.\n\t * @param {Number} high\n\t *        The upper bound on the range.\n\t */\n\tfunction randomIntInRange(low, high) {\n\t  return Math.round(low + (Math.random() * (high - low)));\n\t}\n\n\t/**\n\t * The Quick Sort algorithm.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t * @param {Number} p\n\t *        Start index of the array\n\t * @param {Number} r\n\t *        End index of the array\n\t */\n\tfunction doQuickSort(ary, comparator, p, r) {\n\t  // If our lower bound is less than our upper bound, we (1) partition the\n\t  // array into two pieces and (2) recurse on each half. If it is not, this is\n\t  // the empty array and our base case.\n\n\t  if (p < r) {\n\t    // (1) Partitioning.\n\t    //\n\t    // The partitioning chooses a pivot between `p` and `r` and moves all\n\t    // elements that are less than or equal to the pivot to the before it, and\n\t    // all the elements that are greater than it after it. The effect is that\n\t    // once partition is done, the pivot is in the exact place it will be when\n\t    // the array is put in sorted order, and it will not need to be moved\n\t    // again. This runs in O(n) time.\n\n\t    // Always choose a random pivot so that an input array which is reverse\n\t    // sorted does not cause O(n^2) running time.\n\t    var pivotIndex = randomIntInRange(p, r);\n\t    var i = p - 1;\n\n\t    swap(ary, pivotIndex, r);\n\t    var pivot = ary[r];\n\n\t    // Immediately after `j` is incremented in this loop, the following hold\n\t    // true:\n\t    //\n\t    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n\t    //\n\t    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\t    for (var j = p; j < r; j++) {\n\t      if (comparator(ary[j], pivot) <= 0) {\n\t        i += 1;\n\t        swap(ary, i, j);\n\t      }\n\t    }\n\n\t    swap(ary, i + 1, j);\n\t    var q = i + 1;\n\n\t    // (2) Recurse on each half.\n\n\t    doQuickSort(ary, comparator, p, q - 1);\n\t    doQuickSort(ary, comparator, q + 1, r);\n\t  }\n\t}\n\n\t/**\n\t * Sort the given array in-place with the given comparator function.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t */\n\texports.quickSort = function (ary, comparator) {\n\t  doQuickSort(ary, comparator, 0, ary.length - 1);\n\t};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\n\tvar SourceMapGenerator = __webpack_require__(1).SourceMapGenerator;\n\tvar util = __webpack_require__(4);\n\n\t// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n\t// operating systems these days (capturing the result).\n\tvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n\t// Newline character code for charCodeAt() comparisons\n\tvar NEWLINE_CODE = 10;\n\n\t// Private symbol for identifying `SourceNode`s when multiple versions of\n\t// the source-map library are loaded. This MUST NOT CHANGE across\n\t// versions!\n\tvar isSourceNode = \"$$$isSourceNode$$$\";\n\n\t/**\n\t * SourceNodes provide a way to abstract over interpolating/concatenating\n\t * snippets of generated JavaScript source code while maintaining the line and\n\t * column information associated with the original source code.\n\t *\n\t * @param aLine The original line number.\n\t * @param aColumn The original column number.\n\t * @param aSource The original source's filename.\n\t * @param aChunks Optional. An array of strings which are snippets of\n\t *        generated JS, or other SourceNodes.\n\t * @param aName The original identifier.\n\t */\n\tfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n\t  this.children = [];\n\t  this.sourceContents = {};\n\t  this.line = aLine == null ? null : aLine;\n\t  this.column = aColumn == null ? null : aColumn;\n\t  this.source = aSource == null ? null : aSource;\n\t  this.name = aName == null ? null : aName;\n\t  this[isSourceNode] = true;\n\t  if (aChunks != null) this.add(aChunks);\n\t}\n\n\t/**\n\t * Creates a SourceNode from generated code and a SourceMapConsumer.\n\t *\n\t * @param aGeneratedCode The generated code\n\t * @param aSourceMapConsumer The SourceMap for the generated code\n\t * @param aRelativePath Optional. The path that relative sources in the\n\t *        SourceMapConsumer should be relative to.\n\t */\n\tSourceNode.fromStringWithSourceMap =\n\t  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n\t    // The SourceNode we want to fill with the generated code\n\t    // and the SourceMap\n\t    var node = new SourceNode();\n\n\t    // All even indices of this array are one line of the generated code,\n\t    // while all odd indices are the newlines between two adjacent lines\n\t    // (since `REGEX_NEWLINE` captures its match).\n\t    // Processed fragments are accessed by calling `shiftNextLine`.\n\t    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\t    var remainingLinesIndex = 0;\n\t    var shiftNextLine = function() {\n\t      var lineContents = getNextLine();\n\t      // The last line of a file might not have a newline.\n\t      var newLine = getNextLine() || \"\";\n\t      return lineContents + newLine;\n\n\t      function getNextLine() {\n\t        return remainingLinesIndex < remainingLines.length ?\n\t            remainingLines[remainingLinesIndex++] : undefined;\n\t      }\n\t    };\n\n\t    // We need to remember the position of \"remainingLines\"\n\t    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n\t    // The generate SourceNodes we need a code range.\n\t    // To extract it current and last mapping is used.\n\t    // Here we store the last mapping.\n\t    var lastMapping = null;\n\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      if (lastMapping !== null) {\n\t        // We add the code from \"lastMapping\" to \"mapping\":\n\t        // First check if there is a new line in between.\n\t        if (lastGeneratedLine < mapping.generatedLine) {\n\t          // Associate first line with \"lastMapping\"\n\t          addMappingWithCode(lastMapping, shiftNextLine());\n\t          lastGeneratedLine++;\n\t          lastGeneratedColumn = 0;\n\t          // The remaining code is added without mapping\n\t        } else {\n\t          // There is no new line in between.\n\t          // Associate the code between \"lastGeneratedColumn\" and\n\t          // \"mapping.generatedColumn\" with \"lastMapping\"\n\t          var nextLine = remainingLines[remainingLinesIndex] || '';\n\t          var code = nextLine.substr(0, mapping.generatedColumn -\n\t                                        lastGeneratedColumn);\n\t          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n\t                                              lastGeneratedColumn);\n\t          lastGeneratedColumn = mapping.generatedColumn;\n\t          addMappingWithCode(lastMapping, code);\n\t          // No more remaining code, continue\n\t          lastMapping = mapping;\n\t          return;\n\t        }\n\t      }\n\t      // We add the generated code until the first mapping\n\t      // to the SourceNode without any mapping.\n\t      // Each line is added as separate string.\n\t      while (lastGeneratedLine < mapping.generatedLine) {\n\t        node.add(shiftNextLine());\n\t        lastGeneratedLine++;\n\t      }\n\t      if (lastGeneratedColumn < mapping.generatedColumn) {\n\t        var nextLine = remainingLines[remainingLinesIndex] || '';\n\t        node.add(nextLine.substr(0, mapping.generatedColumn));\n\t        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n\t        lastGeneratedColumn = mapping.generatedColumn;\n\t      }\n\t      lastMapping = mapping;\n\t    }, this);\n\t    // We have processed all mappings.\n\t    if (remainingLinesIndex < remainingLines.length) {\n\t      if (lastMapping) {\n\t        // Associate the remaining code in the current line with \"lastMapping\"\n\t        addMappingWithCode(lastMapping, shiftNextLine());\n\t      }\n\t      // and add the remaining lines without any mapping\n\t      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n\t    }\n\n\t    // Copy sourcesContent into SourceNode\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aRelativePath != null) {\n\t          sourceFile = util.join(aRelativePath, sourceFile);\n\t        }\n\t        node.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\n\t    return node;\n\n\t    function addMappingWithCode(mapping, code) {\n\t      if (mapping === null || mapping.source === undefined) {\n\t        node.add(code);\n\t      } else {\n\t        var source = aRelativePath\n\t          ? util.join(aRelativePath, mapping.source)\n\t          : mapping.source;\n\t        node.add(new SourceNode(mapping.originalLine,\n\t                                mapping.originalColumn,\n\t                                source,\n\t                                code,\n\t                                mapping.name));\n\t      }\n\t    }\n\t  };\n\n\t/**\n\t * Add a chunk of generated JS to this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.add = function SourceNode_add(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    aChunk.forEach(function (chunk) {\n\t      this.add(chunk);\n\t    }, this);\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    if (aChunk) {\n\t      this.children.push(aChunk);\n\t    }\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Add a chunk of generated JS to the beginning of this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    for (var i = aChunk.length-1; i >= 0; i--) {\n\t      this.prepend(aChunk[i]);\n\t    }\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    this.children.unshift(aChunk);\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Walk over the tree of JS snippets in this node and its children. The\n\t * walking function is called once for each snippet of JS and is passed that\n\t * snippet and the its original associated source's line/column location.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n\t  var chunk;\n\t  for (var i = 0, len = this.children.length; i < len; i++) {\n\t    chunk = this.children[i];\n\t    if (chunk[isSourceNode]) {\n\t      chunk.walk(aFn);\n\t    }\n\t    else {\n\t      if (chunk !== '') {\n\t        aFn(chunk, { source: this.source,\n\t                     line: this.line,\n\t                     column: this.column,\n\t                     name: this.name });\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n\t * each of `this.children`.\n\t *\n\t * @param aSep The separator.\n\t */\n\tSourceNode.prototype.join = function SourceNode_join(aSep) {\n\t  var newChildren;\n\t  var i;\n\t  var len = this.children.length;\n\t  if (len > 0) {\n\t    newChildren = [];\n\t    for (i = 0; i < len-1; i++) {\n\t      newChildren.push(this.children[i]);\n\t      newChildren.push(aSep);\n\t    }\n\t    newChildren.push(this.children[i]);\n\t    this.children = newChildren;\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Call String.prototype.replace on the very right-most source snippet. Useful\n\t * for trimming whitespace from the end of a source node, etc.\n\t *\n\t * @param aPattern The pattern to replace.\n\t * @param aReplacement The thing to replace the pattern with.\n\t */\n\tSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n\t  var lastChild = this.children[this.children.length - 1];\n\t  if (lastChild[isSourceNode]) {\n\t    lastChild.replaceRight(aPattern, aReplacement);\n\t  }\n\t  else if (typeof lastChild === 'string') {\n\t    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n\t  }\n\t  else {\n\t    this.children.push(''.replace(aPattern, aReplacement));\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Set the source content for a source file. This will be added to the SourceMapGenerator\n\t * in the sourcesContent field.\n\t *\n\t * @param aSourceFile The filename of the source file\n\t * @param aSourceContent The content of the source file\n\t */\n\tSourceNode.prototype.setSourceContent =\n\t  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n\t    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n\t  };\n\n\t/**\n\t * Walk over the tree of SourceNodes. The walking function is called for each\n\t * source file content and is passed the filename and source content.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walkSourceContents =\n\t  function SourceNode_walkSourceContents(aFn) {\n\t    for (var i = 0, len = this.children.length; i < len; i++) {\n\t      if (this.children[i][isSourceNode]) {\n\t        this.children[i].walkSourceContents(aFn);\n\t      }\n\t    }\n\n\t    var sources = Object.keys(this.sourceContents);\n\t    for (var i = 0, len = sources.length; i < len; i++) {\n\t      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n\t    }\n\t  };\n\n\t/**\n\t * Return the string representation of this source node. Walks over the tree\n\t * and concatenates all the various snippets together to one string.\n\t */\n\tSourceNode.prototype.toString = function SourceNode_toString() {\n\t  var str = \"\";\n\t  this.walk(function (chunk) {\n\t    str += chunk;\n\t  });\n\t  return str;\n\t};\n\n\t/**\n\t * Returns the string representation of this source node along with a source\n\t * map.\n\t */\n\tSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n\t  var generated = {\n\t    code: \"\",\n\t    line: 1,\n\t    column: 0\n\t  };\n\t  var map = new SourceMapGenerator(aArgs);\n\t  var sourceMappingActive = false;\n\t  var lastOriginalSource = null;\n\t  var lastOriginalLine = null;\n\t  var lastOriginalColumn = null;\n\t  var lastOriginalName = null;\n\t  this.walk(function (chunk, original) {\n\t    generated.code += chunk;\n\t    if (original.source !== null\n\t        && original.line !== null\n\t        && original.column !== null) {\n\t      if(lastOriginalSource !== original.source\n\t         || lastOriginalLine !== original.line\n\t         || lastOriginalColumn !== original.column\n\t         || lastOriginalName !== original.name) {\n\t        map.addMapping({\n\t          source: original.source,\n\t          original: {\n\t            line: original.line,\n\t            column: original.column\n\t          },\n\t          generated: {\n\t            line: generated.line,\n\t            column: generated.column\n\t          },\n\t          name: original.name\n\t        });\n\t      }\n\t      lastOriginalSource = original.source;\n\t      lastOriginalLine = original.line;\n\t      lastOriginalColumn = original.column;\n\t      lastOriginalName = original.name;\n\t      sourceMappingActive = true;\n\t    } else if (sourceMappingActive) {\n\t      map.addMapping({\n\t        generated: {\n\t          line: generated.line,\n\t          column: generated.column\n\t        }\n\t      });\n\t      lastOriginalSource = null;\n\t      sourceMappingActive = false;\n\t    }\n\t    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n\t      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n\t        generated.line++;\n\t        generated.column = 0;\n\t        // Mappings end at eol\n\t        if (idx + 1 === length) {\n\t          lastOriginalSource = null;\n\t          sourceMappingActive = false;\n\t        } else if (sourceMappingActive) {\n\t          map.addMapping({\n\t            source: original.source,\n\t            original: {\n\t              line: original.line,\n\t              column: original.column\n\t            },\n\t            generated: {\n\t              line: generated.line,\n\t              column: generated.column\n\t            },\n\t            name: original.name\n\t          });\n\t        }\n\t      } else {\n\t        generated.column++;\n\t      }\n\t    }\n\t  });\n\t  this.walkSourceContents(function (sourceFile, sourceContent) {\n\t    map.setSourceContent(sourceFile, sourceContent);\n\t  });\n\n\t  return { code: generated.code, map: map };\n\t};\n\n\texports.SourceNode = SourceNode;\n\n\n/***/ })\n/******/ ])\n});\n;"]},"metadata":{},"sourceType":"script"}