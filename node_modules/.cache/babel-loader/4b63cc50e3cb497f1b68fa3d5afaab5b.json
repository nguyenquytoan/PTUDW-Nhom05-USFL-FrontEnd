{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst ol = require('common-tags').oneLine;\n\nconst errors = require('./errors');\n\nconst stringifyWithoutComments = require('./stringify-without-comments');\n/**\n * Given a set of options that configures `sw-toolbox`'s behavior, convert it\n * into a string that would configure equivalent `workbox-sw` behavior.\n *\n * @param {Object} options See\n *        https://googlechromelabs.github.io/sw-toolbox/api.html#options\n * @return {string} A JSON string representing the equivalent options.\n *\n * @private\n */\n\n\nfunction getOptionsString(options = {}) {\n  let plugins = [];\n\n  if (options.plugins) {\n    // Using libs because JSON.stringify won't handle functions.\n    plugins = options.plugins.map(stringifyWithoutComments);\n    delete options.plugins;\n  } // Pull handler-specific config from the options object, since they are\n  // not directly used to construct a Plugin instance. If set, need to be\n  // passed as options to the handler constructor instead.\n\n\n  const handlerOptionKeys = ['cacheName', 'networkTimeoutSeconds', 'fetchOptions', 'matchOptions'];\n  const handlerOptions = {};\n\n  for (const key of handlerOptionKeys) {\n    if (key in options) {\n      handlerOptions[key] = options[key];\n      delete options[key];\n    }\n  }\n\n  const pluginsMapping = {\n    backgroundSync: 'workbox.backgroundSync.Plugin',\n    broadcastUpdate: 'workbox.broadcastUpdate.Plugin',\n    expiration: 'workbox.expiration.Plugin',\n    cacheableResponse: 'workbox.cacheableResponse.Plugin'\n  };\n\n  for (const [pluginName, pluginConfig] of Object.entries(options)) {\n    // Ensure that we have some valid configuration to pass to Plugin().\n    if (Object.keys(pluginConfig).length === 0) {\n      continue;\n    }\n\n    const pluginString = pluginsMapping[pluginName];\n\n    if (!pluginString) {\n      throw new Error(`${errors['bad-runtime-caching-config']} ${pluginName}`);\n    }\n\n    let pluginCode;\n\n    switch (pluginName) {\n      // Special case logic for plugins that have a required parameter, and then\n      // an additional optional config parameter.\n      case 'backgroundSync':\n        {\n          const name = pluginConfig.name;\n          pluginCode = `new ${pluginString}(${JSON.stringify(name)}`;\n\n          if ('options' in pluginConfig) {\n            pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;\n          }\n\n          pluginCode += `)`;\n          break;\n        }\n\n      case 'broadcastUpdate':\n        {\n          const channelName = pluginConfig.channelName;\n          const opts = Object.assign({\n            channelName\n          }, pluginConfig.options);\n          pluginCode = `new ${pluginString}(${stringifyWithoutComments(opts)})`;\n          break;\n        }\n      // For plugins that just pass in an Object to the constructor, like\n      // expiration and cacheableResponse\n\n      default:\n        {\n          pluginCode = `new ${pluginString}(${stringifyWithoutComments(pluginConfig)})`;\n        }\n    }\n\n    plugins.push(pluginCode);\n  }\n\n  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {\n    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);\n    return ol`{\n      ${optionsString ? optionsString + ',' : ''}\n      plugins: [${plugins.join(', ')}]\n    }`;\n  } else {\n    return '';\n  }\n}\n\nmodule.exports = (runtimeCaching = []) => {\n  return runtimeCaching.map(entry => {\n    const method = entry.method || 'GET';\n\n    if (!entry.urlPattern) {\n      throw new Error(errors['urlPattern-is-required']);\n    }\n\n    if (!entry.handler) {\n      throw new Error(errors['handler-is-required']);\n    } // This validation logic is a bit too gnarly for joi, so it's manually\n    // implemented here.\n\n\n    if (entry.options && entry.options.networkTimeoutSeconds && entry.handler !== 'NetworkFirst') {\n      throw new Error(errors['invalid-network-timeout-seconds']);\n    } // urlPattern might be a string, a RegExp object, or a function.\n    // If it's a string, it needs to be quoted.\n\n\n    const matcher = typeof entry.urlPattern === 'string' ? JSON.stringify(entry.urlPattern) : entry.urlPattern;\n\n    if (typeof entry.handler === 'string') {\n      const optionsString = getOptionsString(entry.options || {});\n      const strategyString = `new workbox.strategies.${entry.handler}(${optionsString})`;\n      return `workbox.routing.registerRoute(` + `${matcher}, ${strategyString}, '${method}');\\n`;\n    } else if (typeof entry.handler === 'function') {\n      return `workbox.routing.registerRoute(` + `${matcher}, ${entry.handler}, '${method}');\\n`;\n    }\n  }).filter(entry => Boolean(entry)); // Remove undefined map() return values.\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-build/src/lib/runtime-caching-converter.js"],"names":["ol","require","oneLine","errors","stringifyWithoutComments","getOptionsString","options","plugins","map","handlerOptionKeys","handlerOptions","key","pluginsMapping","backgroundSync","broadcastUpdate","expiration","cacheableResponse","pluginName","pluginConfig","Object","entries","keys","length","pluginString","Error","pluginCode","name","JSON","stringify","channelName","opts","assign","push","optionsString","slice","join","module","exports","runtimeCaching","entry","method","urlPattern","handler","networkTimeoutSeconds","matcher","strategyString","filter","Boolean"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst ol = require('common-tags').oneLine;\n\nconst errors = require('./errors');\nconst stringifyWithoutComments = require('./stringify-without-comments');\n\n/**\n * Given a set of options that configures `sw-toolbox`'s behavior, convert it\n * into a string that would configure equivalent `workbox-sw` behavior.\n *\n * @param {Object} options See\n *        https://googlechromelabs.github.io/sw-toolbox/api.html#options\n * @return {string} A JSON string representing the equivalent options.\n *\n * @private\n */\nfunction getOptionsString(options = {}) {\n  let plugins = [];\n  if (options.plugins) {\n    // Using libs because JSON.stringify won't handle functions.\n    plugins = options.plugins.map(stringifyWithoutComments);\n    delete options.plugins;\n  }\n\n  // Pull handler-specific config from the options object, since they are\n  // not directly used to construct a Plugin instance. If set, need to be\n  // passed as options to the handler constructor instead.\n  const handlerOptionKeys = [\n    'cacheName',\n    'networkTimeoutSeconds',\n    'fetchOptions',\n    'matchOptions',\n  ];\n  const handlerOptions = {};\n  for (const key of handlerOptionKeys) {\n    if (key in options) {\n      handlerOptions[key] = options[key];\n      delete options[key];\n    }\n  }\n\n  const pluginsMapping = {\n    backgroundSync: 'workbox.backgroundSync.Plugin',\n    broadcastUpdate: 'workbox.broadcastUpdate.Plugin',\n    expiration: 'workbox.expiration.Plugin',\n    cacheableResponse: 'workbox.cacheableResponse.Plugin',\n  };\n\n  for (const [pluginName, pluginConfig] of Object.entries(options)) {\n    // Ensure that we have some valid configuration to pass to Plugin().\n    if (Object.keys(pluginConfig).length === 0) {\n      continue;\n    }\n\n    const pluginString = pluginsMapping[pluginName];\n    if (!pluginString) {\n      throw new Error(`${errors['bad-runtime-caching-config']} ${pluginName}`);\n    }\n\n    let pluginCode;\n    switch (pluginName) {\n    // Special case logic for plugins that have a required parameter, and then\n    // an additional optional config parameter.\n      case 'backgroundSync': {\n        const name = pluginConfig.name;\n        pluginCode = `new ${pluginString}(${JSON.stringify(name)}`;\n        if ('options' in pluginConfig) {\n          pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;\n        }\n        pluginCode += `)`;\n\n        break;\n      }\n\n      case 'broadcastUpdate': {\n        const channelName = pluginConfig.channelName;\n        const opts = Object.assign({channelName}, pluginConfig.options);\n        pluginCode = `new ${pluginString}(${stringifyWithoutComments(opts)})`;\n\n        break;\n      }\n\n      // For plugins that just pass in an Object to the constructor, like\n      // expiration and cacheableResponse\n      default: {\n        pluginCode = `new ${pluginString}(${stringifyWithoutComments(\n            pluginConfig\n        )})`;\n      }\n    }\n\n    plugins.push(pluginCode);\n  }\n\n  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {\n    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);\n    return ol`{\n      ${optionsString ? optionsString + ',' : ''}\n      plugins: [${plugins.join(', ')}]\n    }`;\n  } else {\n    return '';\n  }\n}\n\nmodule.exports = (runtimeCaching = []) => {\n  return runtimeCaching.map((entry) => {\n    const method = entry.method || 'GET';\n\n    if (!entry.urlPattern) {\n      throw new Error(errors['urlPattern-is-required']);\n    }\n\n    if (!entry.handler) {\n      throw new Error(errors['handler-is-required']);\n    }\n\n    // This validation logic is a bit too gnarly for joi, so it's manually\n    // implemented here.\n    if (entry.options && entry.options.networkTimeoutSeconds &&\n        entry.handler !== 'NetworkFirst') {\n      throw new Error(errors['invalid-network-timeout-seconds']);\n    }\n\n    // urlPattern might be a string, a RegExp object, or a function.\n    // If it's a string, it needs to be quoted.\n    const matcher = typeof entry.urlPattern === 'string' ?\n      JSON.stringify(entry.urlPattern) :\n      entry.urlPattern;\n\n    if (typeof entry.handler === 'string') {\n      const optionsString = getOptionsString(entry.options || {});\n      const strategyString =\n          `new workbox.strategies.${entry.handler}(${optionsString})`;\n\n      return `workbox.routing.registerRoute(` +\n        `${matcher}, ${strategyString}, '${method}');\\n`;\n    } else if (typeof entry.handler === 'function') {\n      return `workbox.routing.registerRoute(` +\n        `${matcher}, ${entry.handler}, '${method}');\\n`;\n    }\n  }).filter((entry) => Boolean(entry)); // Remove undefined map() return values.\n};\n"]},"metadata":{},"sourceType":"script"}