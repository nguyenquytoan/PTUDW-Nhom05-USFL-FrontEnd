{"ast":null,"code":"/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst {\n  isCommentToken\n} = require(\"eslint-utils\");\n\nconst cursors = require(\"./cursors\");\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\n\nconst utils = require(\"./utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\n\nfunction createIndexMap(tokens, comments) {\n  const map = Object.create(null);\n  let tokenIndex = 0;\n  let commentIndex = 0;\n  let nextStart = 0;\n  let range = null;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n\n    while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      tokenIndex += 1;\n    }\n\n    nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n\n    while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      commentIndex += 1;\n    }\n  }\n\n  return map;\n}\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\n\n\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let skip = 0;\n  let filter = null;\n\n  if (typeof opts === \"number\") {\n    skip = opts | 0;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    skip = opts.skip | 0;\n    filter = opts.filter || null;\n  }\n\n  assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n  assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n\n\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let count = 0;\n  let countExists = false;\n  let filter = null;\n\n  if (typeof opts === \"number\") {\n    count = opts | 0;\n    countExists = true;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    count = opts.count | 0;\n    countExists = typeof opts.count === \"number\";\n    filter = opts.filter || null;\n  }\n\n  assert(count >= 0, \"options.count should be zero or a positive integer.\");\n  assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\n\n\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n  if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n    return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n\n  if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n    return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n  }\n\n  return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\n\n\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n  const tokens = [];\n  let currentToken = cursor.getOneToken();\n\n  while (currentToken && isCommentToken(currentToken)) {\n    tokens.push(currentToken);\n    currentToken = cursor.getOneToken();\n  }\n\n  return tokens;\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\n\n\nmodule.exports = class TokenStore {\n  /**\n   * Initializes this token store.\n   * @param {Token[]} tokens The array of tokens.\n   * @param {Comment[]} comments The array of comments.\n   */\n  constructor(tokens, comments) {\n    this[TOKENS] = tokens;\n    this[COMMENTS] = comments;\n    this[INDEX_MAP] = createIndexMap(tokens, comments);\n  } //--------------------------------------------------------------------------\n  // Gets single token.\n  //--------------------------------------------------------------------------\n\n  /**\n   * Gets the token starting at the specified index.\n   * @param {number} offset Index of the start of the token's range.\n   * @param {Object} [options=0] The option object.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @returns {Token|null} The token starting at index, or null if no such token.\n   */\n\n\n  getTokenByRangeStart(offset, options) {\n    const includeComments = options && options.includeComments;\n    const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();\n\n    if (token && token.range[0] === offset) {\n      return token;\n    }\n\n    return null;\n  }\n  /**\n   * Gets the first token of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.skip=0] The count of tokens the cursor skips.\n   * @returns {Token|null} An object representing the token.\n   */\n\n\n  getFirstToken(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n  /**\n   * Gets the last token of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n\n\n  getLastToken(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n  /**\n   * Gets the token that precedes a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n\n\n  getTokenBefore(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();\n  }\n  /**\n   * Gets the token that follows a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n\n\n  getTokenAfter(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();\n  }\n  /**\n   * Gets the first token between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n\n\n  getFirstTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n  /**\n   * Gets the last token between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n   * @returns {Token|null} An object representing the token.\n   */\n\n\n  getLastTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n  /**\n   * Gets the token that precedes a given node or token in the token stream.\n   * This is defined for backward compatibility. Use `includeComments` option instead.\n   * TODO: We have a plan to remove this in a future major version.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number} [skip=0] A number of tokens to skip.\n   * @returns {Token|null} An object representing the token.\n   * @deprecated\n   */\n\n\n  getTokenOrCommentBefore(node, skip) {\n    return this.getTokenBefore(node, {\n      includeComments: true,\n      skip\n    });\n  }\n  /**\n   * Gets the token that follows a given node or token in the token stream.\n   * This is defined for backward compatibility. Use `includeComments` option instead.\n   * TODO: We have a plan to remove this in a future major version.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number} [skip=0] A number of tokens to skip.\n   * @returns {Token|null} An object representing the token.\n   * @deprecated\n   */\n\n\n  getTokenOrCommentAfter(node, skip) {\n    return this.getTokenAfter(node, {\n      includeComments: true,\n      skip\n    });\n  } //--------------------------------------------------------------------------\n  // Gets multiple tokens.\n  //--------------------------------------------------------------------------\n\n  /**\n   * Gets the first `count` tokens of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n   * @returns {Token[]} Tokens.\n   */\n\n\n  getFirstTokens(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();\n  }\n  /**\n   * Gets the last `count` tokens of the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens.\n   */\n\n\n  getLastTokens(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();\n  }\n  /**\n   * Gets the `count` tokens that precedes a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens.\n   */\n\n\n  getTokensBefore(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();\n  }\n  /**\n   * Gets the `count` tokens that follows a given node or token.\n   * @param {ASTNode|Token|Comment} node The AST node or token.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens.\n   */\n\n\n  getTokensAfter(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();\n  }\n  /**\n   * Gets the first `count` tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens between left and right.\n   */\n\n\n  getFirstTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();\n  }\n  /**\n   * Gets the last `count` tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n   * @returns {Token[]} Tokens between left and right.\n   */\n\n\n  getLastTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();\n  }\n  /**\n   * Gets all tokens that are related to the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n   * @returns {Token[]} Array of objects representing tokens.\n   */\n\n  /**\n   * Gets all tokens that are related to the given node.\n   * @param {ASTNode} node The AST node.\n   * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\n   * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\n   * @returns {Token[]} Array of objects representing tokens.\n   */\n\n\n  getTokens(node, beforeCount, afterCount) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();\n  }\n  /**\n   * Gets all of the tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n   * @returns {Token[]} Tokens between left and right.\n   */\n\n  /**\n   * Gets all of the tokens between two non-overlapping nodes.\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\n   * @param {int} [padding=0] Number of extra tokens on either side of center.\n   * @returns {Token[]} Tokens between left and right.\n   */\n\n\n  getTokensBetween(left, right, padding) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();\n  } //--------------------------------------------------------------------------\n  // Others.\n  //--------------------------------------------------------------------------\n\n  /**\n   * Checks whether any comments exist or not between the given 2 nodes.\n   * @param {ASTNode} left The node to check.\n   * @param {ASTNode} right The node to check.\n   * @returns {boolean} `true` if one or more comments exist.\n   */\n\n\n  commentsExistBetween(left, right) {\n    const index = utils.search(this[COMMENTS], left.range[1]);\n    return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];\n  }\n  /**\n   * Gets all comment tokens directly before the given node or token.\n   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n   * @returns {Array} An array of comments in occurrence order.\n   */\n\n\n  getCommentsBefore(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor).reverse();\n  }\n  /**\n   * Gets all comment tokens directly after the given node or token.\n   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n   * @returns {Array} An array of comments in occurrence order.\n   */\n\n\n  getCommentsAfter(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor);\n  }\n  /**\n   * Gets all comment tokens inside the given node.\n   * @param {ASTNode} node The AST node to get the comments for.\n   * @returns {Array} An array of comments in occurrence order.\n   */\n\n\n  getCommentsInside(node) {\n    return this.getTokens(node, {\n      includeComments: true,\n      filter: isCommentToken\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/source-code/token-store/index.js"],"names":["assert","require","isCommentToken","cursors","ForwardTokenCursor","PaddedTokenCursor","utils","TOKENS","Symbol","COMMENTS","INDEX_MAP","createIndexMap","tokens","comments","map","Object","create","tokenIndex","commentIndex","nextStart","range","length","Number","MAX_SAFE_INTEGER","createCursorWithSkip","factory","indexMap","startLoc","endLoc","opts","includeComments","skip","filter","createCursor","createCursorWithCount","count","countExists","createCursorWithPadding","beforeCount","afterCount","forward","getAdjacentCommentTokensFromCursor","cursor","currentToken","getOneToken","push","module","exports","TokenStore","constructor","getTokenByRangeStart","offset","options","token","createBaseCursor","getFirstToken","node","getLastToken","backward","getTokenBefore","getTokenAfter","getFirstTokenBetween","left","right","getLastTokenBetween","getTokenOrCommentBefore","getTokenOrCommentAfter","getFirstTokens","getAllTokens","getLastTokens","reverse","getTokensBefore","getTokensAfter","getFirstTokensBetween","getLastTokensBetween","getTokens","getTokensBetween","padding","commentsExistBetween","index","search","getCommentsBefore","nodeOrToken","getCommentsAfter","getCommentsInside"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst { isCommentToken } = require(\"eslint-utils\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart = 0;\n    let range = null;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n    const tokens = [];\n    let currentToken = cursor.getOneToken();\n\n    while (currentToken && isCommentToken(currentToken)) {\n        tokens.push(currentToken);\n        currentToken = cursor.getOneToken();\n    }\n\n    return tokens;\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     */\n    constructor(tokens, comments) {\n        this[TOKENS] = tokens;\n        this[COMMENTS] = comments;\n        this[INDEX_MAP] = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset Index of the start of the token's range.\n     * @param {Object} [options=0] The option object.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.skip=0] The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n\n    //--------------------------------------------------------------------------\n    // Others.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether any comments exist or not between the given 2 nodes.\n     * @param {ASTNode} left The node to check.\n     * @param {ASTNode} right The node to check.\n     * @returns {boolean} `true` if one or more comments exist.\n     */\n    commentsExistBetween(left, right) {\n        const index = utils.search(this[COMMENTS], left.range[1]);\n\n        return (\n            index < this[COMMENTS].length &&\n            this[COMMENTS][index].range[1] <= right.range[0]\n        );\n    }\n\n    /**\n     * Gets all comment tokens directly before the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsBefore(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            nodeOrToken.range[0],\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor).reverse();\n    }\n\n    /**\n     * Gets all comment tokens directly after the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsAfter(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            nodeOrToken.range[1],\n            -1,\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor);\n    }\n\n    /**\n     * Gets all comment tokens inside the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsInside(node) {\n        return this.getTokens(node, {\n            includeComments: true,\n            filter: isCommentToken\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}