{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nconst p = require('path');\n\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\n\nconst macrosRegex = /[./]macro(\\.js)?$/;\n\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}\n\nlet _configExplorer = null;\n\nfunction getConfigExporer() {\n  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\n\nfunction createMacro(macro, options = {}) {\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n\n    return macro(args);\n  }\n}\n\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\n\nfunction macrosPlugin(babel, _ref = {}) {\n  let {\n    require: _require = require,\n    resolvePath = nodeResolvePath,\n    isMacrosName = testMacrosRegex\n  } = _ref,\n      options = (0, _objectWithoutPropertiesLoose2.default)(_ref, [\"require\", \"resolvePath\", \"isMacrosName\"]);\n\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n\n            if (!isMacros) {\n              return;\n            }\n\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n\n        });\n      }\n\n    }\n  };\n} // eslint-disable-next-line complexity\n\n\nfunction applyMacros({\n  path,\n  imports,\n  source,\n  state,\n  babel,\n  interopRequire,\n  resolvePath,\n  options\n}) {\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, {\n    importedName,\n    localName\n  }) => {\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n\n  const config = getConfig(macro, filename, source, options);\n  let result;\n\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n\n    error.message = `${source}: ${error.message}`;\n\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace( // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n\n    throw error;\n  }\n\n  return result;\n}\n\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExporer().search(filename);\n\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return {};\n}\n\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n\n    return (0, _extends2.default)({}, optionsConfig.options, {}, fileConfig.options);\n  }\n\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n\n  return p.join(process.cwd(), filename);\n}\n\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\n\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\n\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/babel-plugin-macros/dist/index.js"],"names":["_interopRequireDefault","require","_extends2","_objectWithoutPropertiesLoose2","p","resolve","macrosRegex","testMacrosRegex","v","test","MacroError","Error","constructor","message","name","captureStackTrace","stack","_configExplorer","getConfigExporer","cosmiconfigSync","searchPlaces","packageProp","createMacro","macro","options","configName","macroWrapper","isBabelMacro","args","source","isBabelMacrosCall","nodeResolvePath","basedir","sync","paths","__dirname","macrosPlugin","babel","_ref","_require","resolvePath","isMacrosName","default","interopRequire","path","o","__esModule","visitor","Program","progPath","state","traverse","ImportDeclaration","isMacros","looksLike","node","value","imports","specifiers","map","s","localName","local","importedName","type","imported","result","applyMacros","keepImports","remove","VariableDeclaration","child","init","callee","arguments","length","get","filter","forEach","id","properties","property","key","call","file","opts","filename","hasReferences","referencePathsByImportName","reduce","byName","binding","scope","getBinding","referencePaths","Boolean","isRelative","indexOf","requirePath","dirname","getFullFilename","config","getConfig","Identifier","references","error","replace","getConfigFromFile","loaded","search","filepath","e","getConfigFromOptions","hasOwnProperty","console","fileConfig","optionsConfig","undefined","isAbsolute","join","process","cwd","a","b","Object","keys","every","bKey","bVal","aVal","isPrimitive","val","module","exports","assign"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nconst p = require('path');\n\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\n\nconst macrosRegex = /[./]macro(\\.js)?$/;\n\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}\n\nlet _configExplorer = null;\n\nfunction getConfigExporer() {\n  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\n\nfunction createMacro(macro, options = {}) {\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n\n    return macro(args);\n  }\n}\n\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\n\nfunction macrosPlugin(babel, _ref = {}) {\n  let {\n    require: _require = require,\n    resolvePath = nodeResolvePath,\n    isMacrosName = testMacrosRegex\n  } = _ref,\n      options = (0, _objectWithoutPropertiesLoose2.default)(_ref, [\"require\", \"resolvePath\", \"isMacrosName\"]);\n\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n\n            if (!isMacros) {\n              return;\n            }\n\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n\n        });\n      }\n\n    }\n  };\n} // eslint-disable-next-line complexity\n\n\nfunction applyMacros({\n  path,\n  imports,\n  source,\n  state,\n  babel,\n  interopRequire,\n  resolvePath,\n  options\n}) {\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, {\n    importedName,\n    localName\n  }) => {\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n\n  const config = getConfig(macro, filename, source, options);\n  let result;\n\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n\n    error.message = `${source}: ${error.message}`;\n\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace( // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n\n    throw error;\n  }\n\n  return result;\n}\n\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExporer().search(filename);\n\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return {};\n}\n\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n\n    return (0, _extends2.default)({}, optionsConfig.options, {}, fileConfig.options);\n  }\n\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n\n  return p.join(process.cwd(), filename);\n}\n\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\n\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\n\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});"]},"metadata":{},"sourceType":"script"}