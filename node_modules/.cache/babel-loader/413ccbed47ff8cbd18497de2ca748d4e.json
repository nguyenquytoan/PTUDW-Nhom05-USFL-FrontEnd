{"ast":null,"code":"'use strict';\n\nconst postcss = require('postcss');\n\nconst ICSSUtils = require('icss-utils');\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nlet options = {};\nlet importIndex = 0;\n\nlet createImportedName = options && options.createImportedName || ((importName\n/*, path*/\n) => `i__const_${importName.replace(/\\W/g, '_')}_${importIndex++}`);\n\nmodule.exports = postcss.plugin('postcss-modules-values', () => (css, result) => {\n  const importAliases = [];\n  const definitions = {};\n\n  const addDefinition = atRule => {\n    let matches;\n\n    while (matches = matchValueDefinition.exec(atRule.params)) {\n      let [,\n      /*match*/\n      key, value] = matches; // Add to the definitions, knowing that values can refer to each other\n\n      definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n      atRule.remove();\n    }\n  };\n\n  const addImport = atRule => {\n    const matches = matchImports.exec(atRule.params);\n\n    if (matches) {\n      let [,\n      /*match*/\n      aliases, path] = matches; // We can use constants for path names\n\n      if (definitions[path]) {\n        path = definitions[path];\n      }\n\n      const imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1').split(/\\s*,\\s*/).map(alias => {\n        const tokens = matchImport.exec(alias);\n\n        if (tokens) {\n          const [,\n          /*match*/\n          theirName, myName = theirName] = tokens;\n          const importedName = createImportedName(myName);\n          definitions[myName] = importedName;\n          return {\n            theirName,\n            importedName\n          };\n        } else {\n          throw new Error(`@import statement \"${alias}\" is invalid!`);\n        }\n      });\n      importAliases.push({\n        path,\n        imports\n      });\n      atRule.remove();\n    }\n  };\n  /* Look at all the @value statements and treat them as locals or as imports */\n\n\n  css.walkAtRules('value', atRule => {\n    if (matchImports.exec(atRule.params)) {\n      addImport(atRule);\n    } else {\n      if (atRule.params.indexOf('@value') !== -1) {\n        result.warn('Invalid value definition: ' + atRule.params);\n      }\n\n      addDefinition(atRule);\n    }\n  });\n  /* We want to export anything defined by now, but don't add it to the CSS yet or\n  it well get picked up by the replacement stuff */\n\n  const exportDeclarations = Object.keys(definitions).map(key => postcss.decl({\n    value: definitions[key],\n    prop: key,\n    raws: {\n      before: '\\n  '\n    }\n  }));\n  /* If we have no definitions, don't continue */\n\n  if (!Object.keys(definitions).length) {\n    return;\n  }\n  /* Perform replacements */\n\n\n  ICSSUtils.replaceSymbols(css, definitions);\n  /* Add export rules if any */\n\n  if (exportDeclarations.length > 0) {\n    const exportRule = postcss.rule({\n      selector: ':export',\n      raws: {\n        after: '\\n'\n      }\n    });\n    exportRule.append(exportDeclarations);\n    css.prepend(exportRule);\n  }\n  /* Add import rules */\n\n\n  importAliases.reverse().forEach(({\n    path,\n    imports\n  }) => {\n    const importRule = postcss.rule({\n      selector: `:import(${path})`,\n      raws: {\n        after: '\\n'\n      }\n    });\n    imports.forEach(({\n      theirName,\n      importedName\n    }) => {\n      importRule.append({\n        value: theirName,\n        prop: importedName,\n        raws: {\n          before: '\\n  '\n        }\n      });\n    });\n    css.prepend(importRule);\n  });\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-modules-values/src/index.js"],"names":["postcss","require","ICSSUtils","matchImports","matchValueDefinition","matchImport","options","importIndex","createImportedName","importName","replace","module","exports","plugin","css","result","importAliases","definitions","addDefinition","atRule","matches","exec","params","key","value","replaceValueSymbols","remove","addImport","aliases","path","imports","split","map","alias","tokens","theirName","myName","importedName","Error","push","walkAtRules","indexOf","warn","exportDeclarations","Object","keys","decl","prop","raws","before","length","replaceSymbols","exportRule","rule","selector","after","append","prepend","reverse","forEach","importRule"],"mappings":"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","sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst ICSSUtils = require('icss-utils');\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nlet options = {};\nlet importIndex = 0;\nlet createImportedName =\n  (options && options.createImportedName) ||\n  ((importName /*, path*/) =>\n    `i__const_${importName.replace(/\\W/g, '_')}_${importIndex++}`);\n\nmodule.exports = postcss.plugin(\n  'postcss-modules-values',\n  () => (css, result) => {\n    const importAliases = [];\n    const definitions = {};\n\n    const addDefinition = atRule => {\n      let matches;\n      while ((matches = matchValueDefinition.exec(atRule.params))) {\n        let [, /*match*/ key, value] = matches;\n        // Add to the definitions, knowing that values can refer to each other\n        definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n        atRule.remove();\n      }\n    };\n\n    const addImport = atRule => {\n      const matches = matchImports.exec(atRule.params);\n      if (matches) {\n        let [, /*match*/ aliases, path] = matches;\n        // We can use constants for path names\n        if (definitions[path]) {\n          path = definitions[path];\n        }\n        const imports = aliases\n          .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1')\n          .split(/\\s*,\\s*/)\n          .map(alias => {\n            const tokens = matchImport.exec(alias);\n            if (tokens) {\n              const [, /*match*/ theirName, myName = theirName] = tokens;\n              const importedName = createImportedName(myName);\n              definitions[myName] = importedName;\n              return { theirName, importedName };\n            } else {\n              throw new Error(`@import statement \"${alias}\" is invalid!`);\n            }\n          });\n        importAliases.push({ path, imports });\n        atRule.remove();\n      }\n    };\n\n    /* Look at all the @value statements and treat them as locals or as imports */\n    css.walkAtRules('value', atRule => {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n   it well get picked up by the replacement stuff */\n    const exportDeclarations = Object.keys(definitions).map(key =>\n      postcss.decl({\n        value: definitions[key],\n        prop: key,\n        raws: { before: '\\n  ' }\n      })\n    );\n\n    /* If we have no definitions, don't continue */\n    if (!Object.keys(definitions).length) {\n      return;\n    }\n\n    /* Perform replacements */\n    ICSSUtils.replaceSymbols(css, definitions);\n\n    /* Add export rules if any */\n    if (exportDeclarations.length > 0) {\n      const exportRule = postcss.rule({\n        selector: ':export',\n        raws: { after: '\\n' }\n      });\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n\n    /* Add import rules */\n    importAliases.reverse().forEach(({ path, imports }) => {\n      const importRule = postcss.rule({\n        selector: `:import(${path})`,\n        raws: { after: '\\n' }\n      });\n      imports.forEach(({ theirName, importedName }) => {\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: { before: '\\n  ' }\n        });\n      });\n\n      css.prepend(importRule);\n    });\n  }\n);\n"]},"metadata":{},"sourceType":"script"}