{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst maximumSizeTransform = require('./maximum-size-transform');\n\nconst modifyURLPrefixTranform = require('./modify-url-prefix-transform');\n\nconst noRevisionForURLsMatchingTransform = require('./no-revision-for-urls-matching-transform');\n/**\n * A `ManifestTransform` function can be used to modify the modify the `url` or\n * `revision` properties of some or all of the\n * {@link module:workbox-build#ManifestEntry|ManifestEntries} in the manifest.\n *\n * Deleting the `revision` property of an entry will cause\n * the corresponding `url` to be precached without cache-busting parameters\n * applied, which is to say, it implies that the URL itself contains\n * proper versioning info. If the `revision` property is present, it must be\n * set to a string.\n *\n * @example <caption>A transformation that prepended the origin of a CDN for any\n * URL starting with '/assets/' could be implemented as:</caption>\n *\n * const cdnTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const cdnOrigin = 'https://example.com';\n *     if (entry.url.startsWith('/assets/')) {\n *       entry.url = cdnOrigin + entry.url;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @example <caption>A transformation that removes the revision field when the\n * URL contains an 8-character hash surrounded by '.', indicating that it\n * already contains revision information:</caption>\n *\n * const removeRevisionTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const hashRegExp = /\\.\\w{8}\\./;\n *     if (entry.url.match(hashRegExp)) {\n *       delete entry.revision;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @callback ManifestTransform\n * @param {Array<module:workbox-build.ManifestEntry>} manifestEntries The full\n * array of entries, prior to the current transformation.\n * @return {module:workbox-build.ManifestTransformResult}\n * The array of entries with the transformation applied, and optionally, any\n * warnings that should be reported back to the build tool.\n *\n * @memberof module:workbox-build\n */\n\n\nmodule.exports = ({\n  dontCacheBustURLsMatching,\n  fileDetails,\n  manifestTransforms,\n  maximumFileSizeToCacheInBytes,\n  modifyURLPrefix\n}) => {\n  let allWarnings = []; // Take the array of fileDetail objects and convert it into an array of\n  // {url, revision, size} objects, with \\ replaced with /.\n\n  const normalizedManifest = fileDetails.map(fileDetails => {\n    return {\n      url: fileDetails.file.replace(/\\\\/g, '/'),\n      revision: fileDetails.hash,\n      size: fileDetails.size\n    };\n  });\n  let transformsToApply = [];\n\n  if (maximumFileSizeToCacheInBytes) {\n    transformsToApply.push(maximumSizeTransform(maximumFileSizeToCacheInBytes));\n  }\n\n  if (modifyURLPrefix) {\n    transformsToApply.push(modifyURLPrefixTranform(modifyURLPrefix));\n  }\n\n  if (dontCacheBustURLsMatching) {\n    transformsToApply.push(noRevisionForURLsMatchingTransform(dontCacheBustURLsMatching));\n  } // Any additional manifestTransforms that were passed will be applied last.\n\n\n  transformsToApply = transformsToApply.concat(manifestTransforms || []);\n  let transformedManifest = normalizedManifest;\n\n  for (const transform of transformsToApply) {\n    const {\n      manifest,\n      warnings\n    } = transform(transformedManifest);\n    transformedManifest = manifest;\n    allWarnings = allWarnings.concat(warnings || []);\n  } // Generate some metadata about the manifest before we clear out the size\n  // properties from each entry.\n\n\n  const count = transformedManifest.length;\n  let size = 0;\n\n  for (const manifestEntry of transformedManifest) {\n    size += manifestEntry.size;\n    delete manifestEntry.size;\n  }\n\n  return {\n    count,\n    size,\n    manifestEntries: transformedManifest,\n    warnings: allWarnings\n  };\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-build/src/lib/filter-files.js"],"names":["maximumSizeTransform","require","modifyURLPrefixTranform","noRevisionForURLsMatchingTransform","module","exports","dontCacheBustURLsMatching","fileDetails","manifestTransforms","maximumFileSizeToCacheInBytes","modifyURLPrefix","allWarnings","normalizedManifest","map","url","file","replace","revision","hash","size","transformsToApply","push","concat","transformedManifest","transform","manifest","warnings","count","length","manifestEntry","manifestEntries"],"mappings":"AAAA;;;;;;;AAQA,MAAMA,oBAAoB,GAAGC,OAAO,CAAC,0BAAD,CAApC;;AACA,MAAMC,uBAAuB,GAAGD,OAAO,CAAC,+BAAD,CAAvC;;AACA,MAAME,kCAAkC,GACtCF,OAAO,CAAC,2CAAD,CADT;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDAG,MAAM,CAACC,OAAP,GAAiB,CAAC;AAChBC,EAAAA,yBADgB;AAEhBC,EAAAA,WAFgB;AAGhBC,EAAAA,kBAHgB;AAIhBC,EAAAA,6BAJgB;AAKhBC,EAAAA;AALgB,CAAD,KAMX;AACJ,MAAIC,WAAW,GAAG,EAAlB,CADI,CAGJ;AACA;;AACA,QAAMC,kBAAkB,GAAGL,WAAW,CAACM,GAAZ,CAAiBN,WAAD,IAAiB;AAC1D,WAAO;AACLO,MAAAA,GAAG,EAAEP,WAAW,CAACQ,IAAZ,CAAiBC,OAAjB,CAAyB,KAAzB,EAAgC,GAAhC,CADA;AAELC,MAAAA,QAAQ,EAAEV,WAAW,CAACW,IAFjB;AAGLC,MAAAA,IAAI,EAAEZ,WAAW,CAACY;AAHb,KAAP;AAKD,GAN0B,CAA3B;AAQA,MAAIC,iBAAiB,GAAG,EAAxB;;AAEA,MAAIX,6BAAJ,EAAmC;AACjCW,IAAAA,iBAAiB,CAACC,IAAlB,CAAuBrB,oBAAoB,CAACS,6BAAD,CAA3C;AACD;;AAED,MAAIC,eAAJ,EAAqB;AACnBU,IAAAA,iBAAiB,CAACC,IAAlB,CAAuBnB,uBAAuB,CAACQ,eAAD,CAA9C;AACD;;AAED,MAAIJ,yBAAJ,EAA+B;AAC7Bc,IAAAA,iBAAiB,CAACC,IAAlB,CACIlB,kCAAkC,CAACG,yBAAD,CADtC;AAED,GA1BG,CA4BJ;;;AACAc,EAAAA,iBAAiB,GAAGA,iBAAiB,CAACE,MAAlB,CAAyBd,kBAAkB,IAAI,EAA/C,CAApB;AAEA,MAAIe,mBAAmB,GAAGX,kBAA1B;;AACA,OAAK,MAAMY,SAAX,IAAwBJ,iBAAxB,EAA2C;AACzC,UAAM;AAACK,MAAAA,QAAD;AAAWC,MAAAA;AAAX,QAAuBF,SAAS,CAACD,mBAAD,CAAtC;AACAA,IAAAA,mBAAmB,GAAGE,QAAtB;AACAd,IAAAA,WAAW,GAAGA,WAAW,CAACW,MAAZ,CAAmBI,QAAQ,IAAI,EAA/B,CAAd;AACD,GApCG,CAsCJ;AACA;;;AACA,QAAMC,KAAK,GAAGJ,mBAAmB,CAACK,MAAlC;AACA,MAAIT,IAAI,GAAG,CAAX;;AACA,OAAK,MAAMU,aAAX,IAA4BN,mBAA5B,EAAiD;AAC/CJ,IAAAA,IAAI,IAAIU,aAAa,CAACV,IAAtB;AACA,WAAOU,aAAa,CAACV,IAArB;AACD;;AAED,SAAO;AACLQ,IAAAA,KADK;AAELR,IAAAA,IAFK;AAGLW,IAAAA,eAAe,EAAEP,mBAHZ;AAILG,IAAAA,QAAQ,EAAEf;AAJL,GAAP;AAMD,CA3DD","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst maximumSizeTransform = require('./maximum-size-transform');\nconst modifyURLPrefixTranform = require('./modify-url-prefix-transform');\nconst noRevisionForURLsMatchingTransform =\n  require('./no-revision-for-urls-matching-transform');\n\n/**\n * A `ManifestTransform` function can be used to modify the modify the `url` or\n * `revision` properties of some or all of the\n * {@link module:workbox-build#ManifestEntry|ManifestEntries} in the manifest.\n *\n * Deleting the `revision` property of an entry will cause\n * the corresponding `url` to be precached without cache-busting parameters\n * applied, which is to say, it implies that the URL itself contains\n * proper versioning info. If the `revision` property is present, it must be\n * set to a string.\n *\n * @example <caption>A transformation that prepended the origin of a CDN for any\n * URL starting with '/assets/' could be implemented as:</caption>\n *\n * const cdnTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const cdnOrigin = 'https://example.com';\n *     if (entry.url.startsWith('/assets/')) {\n *       entry.url = cdnOrigin + entry.url;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @example <caption>A transformation that removes the revision field when the\n * URL contains an 8-character hash surrounded by '.', indicating that it\n * already contains revision information:</caption>\n *\n * const removeRevisionTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const hashRegExp = /\\.\\w{8}\\./;\n *     if (entry.url.match(hashRegExp)) {\n *       delete entry.revision;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @callback ManifestTransform\n * @param {Array<module:workbox-build.ManifestEntry>} manifestEntries The full\n * array of entries, prior to the current transformation.\n * @return {module:workbox-build.ManifestTransformResult}\n * The array of entries with the transformation applied, and optionally, any\n * warnings that should be reported back to the build tool.\n *\n * @memberof module:workbox-build\n */\n\nmodule.exports = ({\n  dontCacheBustURLsMatching,\n  fileDetails,\n  manifestTransforms,\n  maximumFileSizeToCacheInBytes,\n  modifyURLPrefix,\n}) => {\n  let allWarnings = [];\n\n  // Take the array of fileDetail objects and convert it into an array of\n  // {url, revision, size} objects, with \\ replaced with /.\n  const normalizedManifest = fileDetails.map((fileDetails) => {\n    return {\n      url: fileDetails.file.replace(/\\\\/g, '/'),\n      revision: fileDetails.hash,\n      size: fileDetails.size,\n    };\n  });\n\n  let transformsToApply = [];\n\n  if (maximumFileSizeToCacheInBytes) {\n    transformsToApply.push(maximumSizeTransform(maximumFileSizeToCacheInBytes));\n  }\n\n  if (modifyURLPrefix) {\n    transformsToApply.push(modifyURLPrefixTranform(modifyURLPrefix));\n  }\n\n  if (dontCacheBustURLsMatching) {\n    transformsToApply.push(\n        noRevisionForURLsMatchingTransform(dontCacheBustURLsMatching));\n  }\n\n  // Any additional manifestTransforms that were passed will be applied last.\n  transformsToApply = transformsToApply.concat(manifestTransforms || []);\n\n  let transformedManifest = normalizedManifest;\n  for (const transform of transformsToApply) {\n    const {manifest, warnings} = transform(transformedManifest);\n    transformedManifest = manifest;\n    allWarnings = allWarnings.concat(warnings || []);\n  }\n\n  // Generate some metadata about the manifest before we clear out the size\n  // properties from each entry.\n  const count = transformedManifest.length;\n  let size = 0;\n  for (const manifestEntry of transformedManifest) {\n    size += manifestEntry.size;\n    delete manifestEntry.size;\n  }\n\n  return {\n    count,\n    size,\n    manifestEntries: transformedManifest,\n    warnings: allWarnings,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}