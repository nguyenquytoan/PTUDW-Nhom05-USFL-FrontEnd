{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport assert from \"assert\";\nimport * as leap from \"./leap\";\nimport * as meta from \"./meta\";\nimport * as util from \"./util\";\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  assert.ok(this instanceof Emitter);\n  util.getTypes().assertIdentifier(contextId); // Used to generate unique temporary names.\n\n  this.nextTempId = 0; // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n\n  this.contextId = contextId; // An append-only list of Statements that grows each time this.emit is\n  // called.\n\n  this.listing = []; // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n\n  this.marked = [true];\n  this.insertedLocs = new Set(); // The last location will be marked when this.getDispatchLoop is\n  // called.\n\n  this.finalLoc = this.loc(); // A list of all leap.TryEntry statements emitted.\n\n  this.tryEntries = []; // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n\n  this.leapManager = new leap.LeapManager(this);\n}\n\nlet Ep = Emitter.prototype;\nexports.Emitter = Emitter; // Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n\nEp.loc = function () {\n  const l = util.getTypes().numericLiteral(-1);\n  this.insertedLocs.add(l);\n  return l;\n};\n\nEp.getInsertedLocs = function () {\n  return this.insertedLocs;\n};\n\nEp.getContextId = function () {\n  return util.getTypes().clone(this.contextId);\n}; // Sets the exact value of the given location to the offset of the next\n// Statement emitted.\n\n\nEp.mark = function (loc) {\n  util.getTypes().assertLiteral(loc);\n  let index = this.listing.length;\n\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    assert.strictEqual(loc.value, index);\n  }\n\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function (node) {\n  const t = util.getTypes();\n\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n}; // Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\n\n\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n}; // Shorthand for an assignment statement.\n\n\nEp.assign = function (lhs, rhs) {\n  const t = util.getTypes();\n  return t.expressionStatement(t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n}; // Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\n\n\nEp.contextProperty = function (name, computed) {\n  const t = util.getTypes();\n  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n}; // Shorthand for setting context.rval and jumping to `context.stop()`.\n\n\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function (valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\n\nEp.clearPendingException = function (tryLoc, assignee) {\n  const t = util.getTypes();\n  t.assertLiteral(tryLoc);\n  let catchCall = t.callExpression(this.contextProperty(\"catch\", true), [t.clone(tryLoc)]);\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n}; // Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\n\n\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n}; // Conditional jump.\n\n\nEp.jumpIf = function (test, toLoc) {\n  const t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Conditional jump, with the condition negated.\n\n\nEp.jumpIfNot = function (test, toLoc) {\n  const t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  let negatedTest;\n\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\n\n\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function (id) {\n  const t = util.getTypes();\n  return t.functionExpression(id || null\n  /*Anonymous*/\n  , [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, // Not a generator anymore!\n  false // Nor an expression.\n  );\n}; // Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\n\n\nEp.getDispatchLoop = function () {\n  const self = this;\n  const t = util.getTypes();\n  let cases = [];\n  let current; // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n\n  let alreadyEnded = false;\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  }); // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n\n  this.finalLoc.value = this.listing.length;\n  cases.push(t.switchCase(this.finalLoc, [// Intentionally fall through to the \"end\" case...\n  ]), // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [// This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\n\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  const t = util.getTypes();\n  let lastLocValue = 0;\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    let thisLocValue = tryEntry.firstLoc.value;\n    assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n    lastLocValue = thisLocValue;\n    let ce = tryEntry.catchEntry;\n    let fe = tryEntry.finallyEntry;\n    let locs = [tryEntry.firstLoc, // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n\n    return t.arrayExpression(locs.map(loc => loc && t.clone(loc)));\n  }));\n}; // All side effects must be realized in order.\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n// No destructive modification of AST nodes.\n\n\nEp.explode = function (path, ignoreResult) {\n  const t = util.getTypes();\n  let node = path.node;\n  let self = this;\n  t.assertNode(node);\n  if (t.isDeclaration(node)) throw getDeclError(node);\n  if (t.isStatement(node)) return self.explodeStatement(path);\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n\n    default:\n      throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\n\nEp.explodeStatement = function (path, labelId) {\n  const t = util.getTypes();\n  let stmt = path.node;\n  let self = this;\n  let before, after, head;\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  } // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n\n\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n\n    case \"LabeledStatement\":\n      after = this.loc(); // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n      self.mark(after);\n      break;\n\n    case \"WhileStatement\":\n      before = this.loc();\n      after = this.loc();\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n      break;\n\n    case \"DoWhileStatement\":\n      let first = this.loc();\n      let test = this.loc();\n      after = this.loc();\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n      break;\n\n    case \"ForStatement\":\n      head = this.loc();\n      let update = this.loc();\n      after = this.loc();\n\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n\n      self.mark(head);\n\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {// No test means continue unconditionally.\n      }\n\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.mark(update);\n\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n\n    case \"ForInStatement\":\n      head = this.loc();\n      after = this.loc();\n      let keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n      self.mark(head);\n      let keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier(\"done\"), false), after);\n      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier(\"value\"), false));\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n      break;\n\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n      break;\n\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      let disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n      after = this.loc();\n      let defaultLoc = this.loc();\n      let condition = defaultLoc;\n      let caseLocs = []; // If there are no cases, .cases might be undefined.\n\n      let cases = stmt.cases || [];\n\n      for (let i = cases.length - 1; i >= 0; --i) {\n        let c = cases[i];\n        t.assertSwitchCase(c);\n\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n\n      let discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          let i = casePath.key;\n          self.mark(caseLocs[i]);\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n      self.mark(after);\n\n      if (defaultLoc.value === -1) {\n        self.mark(defaultLoc);\n        assert.strictEqual(after.value, defaultLoc.value);\n      }\n\n      break;\n\n    case \"IfStatement\":\n      let elseLoc = stmt.alternate && this.loc();\n      after = this.loc();\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n      self.explodeStatement(path.get(\"consequent\"));\n\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n\n      self.mark(after);\n      break;\n\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n      break;\n\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n\n    case \"TryStatement\":\n      after = this.loc();\n      let handler = stmt.handler;\n      let catchLoc = handler && this.loc();\n      let catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n      let finallyLoc = stmt.finalizer && this.loc();\n      let finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n      let tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n\n          self.updateContextPrevLoc(self.mark(catchLoc));\n          let bodyPath = path.get(\"handler.body\");\n          let safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n          bodyPath.traverse(catchParamVisitor, {\n            getSafeParam: () => t.cloneDeep(safeParam),\n            catchParamName: handler.param.name\n          });\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n      self.mark(after);\n      break;\n\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n      break;\n\n    default:\n      throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n  }\n};\n\nlet catchParamVisitor = {\n  Identifier: function (path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n  Scope: function (path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    assert.ok(false, \"invalid completion record: \" + JSON.stringify(record));\n  }\n\n  assert.notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n  const t = util.getTypes();\n  let abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);\n    }\n  }\n\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\n\nfunction isValidCompletion(record) {\n  let type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && util.getTypes().isLiteral(record.target);\n  }\n\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n} // Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\n\n\nEp.getUnmarkedCurrentLoc = function () {\n  return util.getTypes().numericLiteral(this.listing.length);\n}; // The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\n\n\nEp.updateContextPrevLoc = function (loc) {\n  const t = util.getTypes();\n\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      assert.strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  } // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n\n\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function (path, ignoreResult) {\n  const t = util.getTypes();\n  let expr = path.node;\n\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  let self = this;\n  let result; // Used optionally by several cases below.\n\n  let after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  } // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n\n\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  } // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n\n\n  let hasLeapingChildren = meta.containsLeap.onlyChildren(expr); // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    assert.ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n    let result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {// Side effects already emitted above.\n    } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(tempVar || self.makeTempVar(), result);\n    }\n\n    return result;\n  } // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? explodeViaTempVar(null, path.get(\"property\")) : expr.property, expr.computed));\n\n    case \"CallExpression\":\n      let calleePath = path.get(\"callee\");\n      let argsPath = path.get(\"arguments\");\n      let newCallee;\n      let newArgs;\n      let hasLeapingArgs = argsPath.some(argPath => meta.containsLeap(argPath.node));\n      let injectFirstArg = null;\n\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n          let newObject = explodeViaTempVar( // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"));\n          let newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get(\"property\")) : calleePath.node.property;\n          injectFirstArg = newObject;\n          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = explodeViaTempVar(null, calleePath);\n\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);\n        }\n      }\n\n      if (hasLeapingArgs) {\n        newArgs = argsPath.map(argPath => explodeViaTempVar(null, argPath));\n        if (injectFirstArg) newArgs.unshift(injectFirstArg);\n        newArgs = newArgs.map(arg => t.cloneDeep(arg));\n      } else {\n        newArgs = path.node.arguments;\n      }\n\n      return finish(t.callExpression(newCallee, newArgs));\n\n    case \"NewExpression\":\n      return finish(t.newExpression(explodeViaTempVar(null, path.get(\"callee\")), path.get(\"arguments\").map(function (argPath) {\n        return explodeViaTempVar(null, argPath);\n      })));\n\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get(\"value\")), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        if (elemPath.isSpreadElement()) {\n          return t.spreadElement(explodeViaTempVar(null, elemPath.get(\"argument\")));\n        } else {\n          return explodeViaTempVar(null, elemPath);\n        }\n      })));\n\n    case \"SequenceExpression\":\n      let lastIndex = expr.expressions.length - 1;\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n      return result;\n\n    case \"LogicalExpression\":\n      after = this.loc();\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      let left = explodeViaTempVar(result, path.get(\"left\"));\n\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        assert.strictEqual(expr.operator, \"||\");\n        self.jumpIf(left, after);\n      }\n\n      explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"ConditionalExpression\":\n      let elseLoc = this.loc();\n      after = this.loc();\n      let test = self.explodeExpression(path.get(\"test\"));\n      self.jumpIfNot(test, elseLoc);\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n      self.jump(after);\n      self.mark(elseLoc);\n      explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator, // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get(\"left\")), explodeViaTempVar(null, path.get(\"right\"))));\n\n    case \"AssignmentExpression\":\n      if (expr.operator === \"=\") {\n        // If this is a simple assignment, the left hand side does not need\n        // to be read before the right hand side is evaluated, so we can\n        // avoid the more complicated logic below.\n        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n      }\n\n      const lhs = self.explodeExpression(path.get(\"left\"));\n      const temp = self.emitAssign(self.makeTempVar(), lhs); // For example,\n      //\n      //   x += yield y\n      //\n      // becomes\n      //\n      //   context.t0 = x\n      //   x = context.t0 += yield y\n      //\n      // so that the left-hand side expression is read before the yield.\n      // Fixes https://github.com/facebook/regenerator/issues/345.\n\n      return finish(t.assignmentExpression(\"=\", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get(\"right\")))));\n\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n\n    case \"YieldExpression\":\n      after = this.loc();\n      let arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n      if (arg && expr.delegate) {\n        let result = self.makeTempVar();\n        let ret = t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(result.property.name), after]));\n        ret.loc = expr.loc;\n        self.emit(ret);\n        self.mark(after);\n        return result;\n      }\n\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      let ret = t.returnStatement(t.cloneDeep(arg) || null); // Preserve the `yield` location so that source mappings for the statements\n      // link back to the yield properly.\n\n      ret.loc = expr.loc;\n      self.emit(ret);\n      self.mark(after);\n      return self.contextProperty(\"sent\");\n\n    default:\n      throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n  }\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/regenerator-transform/src/emit.js"],"names":["assert","leap","meta","util","hasOwn","Object","prototype","hasOwnProperty","Emitter","contextId","ok","getTypes","assertIdentifier","nextTempId","listing","marked","insertedLocs","Set","finalLoc","loc","tryEntries","leapManager","LeapManager","Ep","exports","l","numericLiteral","add","getInsertedLocs","getContextId","clone","mark","assertLiteral","index","length","value","strictEqual","emit","node","t","isExpression","expressionStatement","assertStatement","push","emitAssign","lhs","rhs","assign","assignmentExpression","cloneDeep","contextProperty","name","computed","memberExpression","stringLiteral","identifier","stop","rval","setReturnValue","jump","valuePath","assertExpression","explodeExpression","clearPendingException","tryLoc","assignee","catchCall","callExpression","toLoc","breakStatement","jumpIf","test","ifStatement","blockStatement","jumpIfNot","negatedTest","isUnaryExpression","operator","argument","unaryExpression","makeTempVar","getContextFunction","id","functionExpression","getDispatchLoop","self","cases","current","alreadyEnded","forEach","stmt","i","switchCase","isCompletionStatement","returnStatement","whileStatement","switchStatement","getTryLocsList","lastLocValue","arrayExpression","map","tryEntry","thisLocValue","firstLoc","ce","catchEntry","fe","finallyEntry","locs","afterLoc","explode","path","ignoreResult","assertNode","isDeclaration","getDeclError","isStatement","explodeStatement","type","get","Error","JSON","stringify","labelId","before","after","head","isBlockStatement","containsLeap","withEntry","LabeledEntry","label","LoopEntry","first","update","init","keyIterNextFn","runtimeProperty","keyInfoTmpVar","left","emitAbruptCompletion","target","getBreakLoc","getContinueLoc","disc","defaultLoc","condition","caseLocs","c","assertSwitchCase","conditionalExpression","binaryExpression","discriminant","replaceWithOrRemove","SwitchEntry","casePath","key","elseLoc","alternate","handler","catchLoc","CatchEntry","param","finallyLoc","finalizer","FinallyEntry","TryEntry","getUnmarkedCurrentLoc","updateContextPrevLoc","bodyPath","safeParam","traverse","catchParamVisitor","getSafeParam","catchParamName","throwStatement","Identifier","state","isReference","Scope","scope","hasOwnBinding","skip","record","isValidCompletion","notStrictEqual","abruptArgs","has","call","isLiteral","expr","result","finish","hasLeapingChildren","onlyChildren","explodeViaTempVar","tempVar","childPath","ignoreChildResult","property","calleePath","argsPath","newCallee","newArgs","hasLeapingArgs","some","argPath","injectFirstArg","isMemberExpression","newObject","newProperty","sequenceExpression","unshift","arg","arguments","newExpression","objectExpression","propPath","isObjectProperty","objectProperty","elemPath","isSpreadElement","spreadElement","lastIndex","expressions","exprPath","prefix","temp","updateExpression","delegate","ret"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport assert from \"assert\";\nimport * as leap from \"./leap\";\nimport * as meta from \"./meta\";\nimport * as util from \"./util\";\n\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  assert.ok(this instanceof Emitter);\n\n  util.getTypes().assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n\n  this.insertedLocs = new Set();\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = this.loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\n\nlet Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\nEp.loc = function() {\n  const l = util.getTypes().numericLiteral(-1)\n  this.insertedLocs.add(l);\n  return l;\n}\n\nEp.getInsertedLocs = function() {\n  return this.insertedLocs;\n}\n\nEp.getContextId = function() {\n  return util.getTypes().clone(this.contextId);\n}\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function(loc) {\n  util.getTypes().assertLiteral(loc);\n  let index = this.listing.length;\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    assert.strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function(node) {\n  const t = util.getTypes();\n\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function(lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function(lhs, rhs) {\n  const t = util.getTypes();\n  return t.expressionStatement(\n    t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function(name, computed) {\n  const t = util.getTypes();\n  return t.memberExpression(\n    this.getContextId(),\n    computed ? t.stringLiteral(name) : t.identifier(name),\n    !!computed\n  );\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function(rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function(valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n\n  this.emitAssign(\n    this.contextProperty(\"rval\"),\n    this.explodeExpression(valuePath)\n  );\n};\n\nEp.clearPendingException = function(tryLoc, assignee) {\n  const t = util.getTypes();\n\n  t.assertLiteral(tryLoc);\n\n  let catchCall = t.callExpression(\n    this.contextProperty(\"catch\", true),\n    [t.clone(tryLoc)]\n  );\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function(toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function(test, toLoc) {\n  const t = util.getTypes();\n\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  this.emit(t.ifStatement(\n    test,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function(test, toLoc) {\n  const t = util.getTypes();\n\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  let negatedTest;\n  if (t.isUnaryExpression(test) &&\n      test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(\n    negatedTest,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function() {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function(id) {\n  const t = util.getTypes();\n\n  return t.functionExpression(\n    id || null/*Anonymous*/,\n    [this.getContextId()],\n    t.blockStatement([this.getDispatchLoop()]),\n    false, // Not a generator anymore!\n    false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function() {\n  const self = this;\n  const t = util.getTypes();\n  let cases = [];\n  let current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  let alreadyEnded = false;\n\n  self.listing.forEach(function(stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(\n        t.numericLiteral(i),\n        current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt))\n        alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n\n  cases.push(\n    t.switchCase(this.finalLoc, [\n      // Intentionally fall through to the \"end\" case...\n    ]),\n\n    // So that the runtime can jump to the final location without having\n    // to know its offset, we provide the \"end\" case as a synonym.\n    t.switchCase(t.stringLiteral(\"end\"), [\n      // This will check/clear both context.thrown and context.rval.\n      t.returnStatement(\n        t.callExpression(this.contextProperty(\"stop\"), [])\n      )\n    ])\n  );\n\n  return t.whileStatement(\n    t.numericLiteral(1),\n    t.switchStatement(\n      t.assignmentExpression(\n        \"=\",\n        this.contextProperty(\"prev\"),\n        this.contextProperty(\"next\")\n      ),\n      cases\n    )\n  );\n};\n\nEp.getTryLocsList = function() {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  const t = util.getTypes();\n  let lastLocValue = 0;\n\n  return t.arrayExpression(\n    this.tryEntries.map(function(tryEntry) {\n      let thisLocValue = tryEntry.firstLoc.value;\n      assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n      lastLocValue = thisLocValue;\n\n      let ce = tryEntry.catchEntry;\n      let fe = tryEntry.finallyEntry;\n\n      let locs = [\n        tryEntry.firstLoc,\n        // The null here makes a hole in the array.\n        ce ? ce.firstLoc : null\n      ];\n\n      if (fe) {\n        locs[2] = fe.firstLoc;\n        locs[3] = fe.afterLoc;\n      }\n\n      return t.arrayExpression(locs.map(loc => loc && t.clone(loc)));\n    })\n  );\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function(path, ignoreResult) {\n  const t = util.getTypes();\n  let node = path.node;\n  let self = this;\n\n  t.assertNode(node);\n\n  if (t.isDeclaration(node))\n    throw getDeclError(node);\n\n  if (t.isStatement(node))\n    return self.explodeStatement(path);\n\n  if (t.isExpression(node))\n    return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n  case \"Program\":\n    return path.get(\"body\").map(\n      self.explodeStatement,\n      self\n    );\n\n  case \"VariableDeclarator\":\n    throw getDeclError(node);\n\n  // These node types should be handled by their parent nodes\n  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n  case \"Property\":\n  case \"SwitchCase\":\n  case \"CatchClause\":\n    throw new Error(\n      node.type + \" nodes should be handled by their parents\");\n\n  default:\n    throw new Error(\n      \"unknown Node of type \" +\n        JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\n    \"all declarations should have been transformed into \" +\n    \"assignments before the Exploder began its work: \" +\n    JSON.stringify(node));\n}\n\nEp.explodeStatement = function(path, labelId) {\n  const t = util.getTypes();\n  let stmt = path.node;\n  let self = this;\n  let before, after, head;\n\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n  case \"ExpressionStatement\":\n    self.explodeExpression(path.get(\"expression\"), true);\n    break;\n\n  case \"LabeledStatement\":\n    after = this.loc();\n\n    // Did you know you can break from any labeled block statement or\n    // control structure? Well, you can! Note: when a labeled loop is\n    // encountered, the leap.LabeledEntry created here will immediately\n    // enclose a leap.LoopEntry on the leap manager's stack, and both\n    // entries will have the same label. Though this works just fine, it\n    // may seem a bit redundant. In theory, we could check here to\n    // determine if stmt knows how to handle its own label; for example,\n    // stmt happens to be a WhileStatement and so we know it's going to\n    // establish its own LoopEntry when we explode it (below). Then this\n    // LabeledEntry would be unnecessary. Alternatively, we might be\n    // tempted not to pass stmt.label down into self.explodeStatement,\n    // because we've handled the label here, but that's a mistake because\n    // labeled loops may contain labeled continue statements, which is not\n    // something we can handle in this generic case. All in all, I think a\n    // little redundancy greatly simplifies the logic of this case, since\n    // it's clear that we handle all possible LabeledStatements correctly\n    // here, regardless of whether they interact with the leap manager\n    // themselves. Also remember that labels and break/continue-to-label\n    // statements are rare, and all of this logic happens at transform\n    // time, so it has no additional runtime cost.\n    self.leapManager.withEntry(\n      new leap.LabeledEntry(after, stmt.label),\n      function() {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      }\n    );\n\n    self.mark(after);\n\n    break;\n\n  case \"WhileStatement\":\n    before = this.loc();\n    after = this.loc();\n\n    self.mark(before);\n    self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, before, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n    self.jump(before);\n    self.mark(after);\n\n    break;\n\n  case \"DoWhileStatement\":\n    let first = this.loc();\n    let test = this.loc();\n    after = this.loc();\n\n    self.mark(first);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, test, labelId),\n      function() { self.explode(path.get(\"body\")); }\n    );\n    self.mark(test);\n    self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n    self.mark(after);\n\n    break;\n\n  case \"ForStatement\":\n    head = this.loc();\n    let update = this.loc();\n    after = this.loc();\n\n    if (stmt.init) {\n      // We pass true here to indicate that if stmt.init is an expression\n      // then we do not care about its result.\n      self.explode(path.get(\"init\"), true);\n    }\n\n    self.mark(head);\n\n    if (stmt.test) {\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    } else {\n      // No test means continue unconditionally.\n    }\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, update, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.mark(update);\n\n    if (stmt.update) {\n      // We pass true here to indicate that if stmt.update is an\n      // expression then we do not care about its result.\n      self.explode(path.get(\"update\"), true);\n    }\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"TypeCastExpression\":\n    return self.explodeExpression(path.get(\"expression\"));\n\n  case \"ForInStatement\":\n    head = this.loc();\n    after = this.loc();\n\n    let keyIterNextFn = self.makeTempVar();\n    self.emitAssign(\n      keyIterNextFn,\n      t.callExpression(\n        util.runtimeProperty(\"keys\"),\n        [self.explodeExpression(path.get(\"right\"))]\n      )\n    );\n\n    self.mark(head);\n\n    let keyInfoTmpVar = self.makeTempVar();\n    self.jumpIf(\n      t.memberExpression(\n        t.assignmentExpression(\n          \"=\",\n          keyInfoTmpVar,\n          t.callExpression(t.cloneDeep(keyIterNextFn), [])\n        ),\n        t.identifier(\"done\"),\n        false\n      ),\n      after\n    );\n\n    self.emitAssign(\n      stmt.left,\n      t.memberExpression(\n        t.cloneDeep(keyInfoTmpVar),\n        t.identifier(\"value\"),\n        false\n      )\n    );\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, head, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"BreakStatement\":\n    self.emitAbruptCompletion({\n      type: \"break\",\n      target: self.leapManager.getBreakLoc(stmt.label)\n    });\n\n    break;\n\n  case \"ContinueStatement\":\n    self.emitAbruptCompletion({\n      type: \"continue\",\n      target: self.leapManager.getContinueLoc(stmt.label)\n    });\n\n    break;\n\n  case \"SwitchStatement\":\n    // Always save the discriminant into a temporary variable in case the\n    // test expressions overwrite values like context.sent.\n    let disc = self.emitAssign(\n      self.makeTempVar(),\n      self.explodeExpression(path.get(\"discriminant\"))\n    );\n\n    after = this.loc();\n    let defaultLoc = this.loc();\n    let condition = defaultLoc;\n    let caseLocs = [];\n\n    // If there are no cases, .cases might be undefined.\n    let cases = stmt.cases || [];\n\n    for (let i = cases.length - 1; i >= 0; --i) {\n      let c = cases[i];\n      t.assertSwitchCase(c);\n\n      if (c.test) {\n        condition = t.conditionalExpression(\n          t.binaryExpression(\"===\", t.cloneDeep(disc), c.test),\n          caseLocs[i] = this.loc(),\n          condition\n        );\n      } else {\n        caseLocs[i] = defaultLoc;\n      }\n    }\n\n    let discriminant = path.get(\"discriminant\");\n    util.replaceWithOrRemove(discriminant, condition);\n    self.jump(self.explodeExpression(discriminant));\n\n    self.leapManager.withEntry(\n      new leap.SwitchEntry(after),\n      function() {\n        path.get(\"cases\").forEach(function(casePath) {\n          let i = casePath.key;\n          self.mark(caseLocs[i]);\n\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      }\n    );\n\n    self.mark(after);\n    if (defaultLoc.value === -1) {\n      self.mark(defaultLoc);\n      assert.strictEqual(after.value, defaultLoc.value);\n    }\n\n    break;\n\n  case \"IfStatement\":\n    let elseLoc = stmt.alternate && this.loc();\n    after = this.loc();\n\n    self.jumpIfNot(\n      self.explodeExpression(path.get(\"test\")),\n      elseLoc || after\n    );\n\n    self.explodeStatement(path.get(\"consequent\"));\n\n    if (elseLoc) {\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeStatement(path.get(\"alternate\"));\n    }\n\n    self.mark(after);\n\n    break;\n\n  case \"ReturnStatement\":\n    self.emitAbruptCompletion({\n      type: \"return\",\n      value: self.explodeExpression(path.get(\"argument\"))\n    });\n\n    break;\n\n  case \"WithStatement\":\n    throw new Error(\"WithStatement not supported in generator functions.\");\n\n  case \"TryStatement\":\n    after = this.loc();\n\n    let handler = stmt.handler;\n\n    let catchLoc = handler && this.loc();\n    let catchEntry = catchLoc && new leap.CatchEntry(\n      catchLoc,\n      handler.param\n    );\n\n    let finallyLoc = stmt.finalizer && this.loc();\n    let finallyEntry = finallyLoc &&\n      new leap.FinallyEntry(finallyLoc, after);\n\n    let tryEntry = new leap.TryEntry(\n      self.getUnmarkedCurrentLoc(),\n      catchEntry,\n      finallyEntry\n    );\n\n    self.tryEntries.push(tryEntry);\n    self.updateContextPrevLoc(tryEntry.firstLoc);\n\n    self.leapManager.withEntry(tryEntry, function() {\n      self.explodeStatement(path.get(\"block\"));\n\n      if (catchLoc) {\n        if (finallyLoc) {\n          // If we have both a catch block and a finally block, then\n          // because we emit the catch block first, we need to jump over\n          // it to the finally block.\n          self.jump(finallyLoc);\n\n        } else {\n          // If there is no finally block, then we need to jump over the\n          // catch block to the fall-through location.\n          self.jump(after);\n        }\n\n        self.updateContextPrevLoc(self.mark(catchLoc));\n\n        let bodyPath = path.get(\"handler.body\");\n        let safeParam = self.makeTempVar();\n        self.clearPendingException(tryEntry.firstLoc, safeParam);\n\n        bodyPath.traverse(catchParamVisitor, {\n          getSafeParam: () => t.cloneDeep(safeParam),\n          catchParamName: handler.param.name\n        });\n\n        self.leapManager.withEntry(catchEntry, function() {\n          self.explodeStatement(bodyPath);\n        });\n      }\n\n      if (finallyLoc) {\n        self.updateContextPrevLoc(self.mark(finallyLoc));\n\n        self.leapManager.withEntry(finallyEntry, function() {\n          self.explodeStatement(path.get(\"finalizer\"));\n        });\n\n        self.emit(t.returnStatement(t.callExpression(\n          self.contextProperty(\"finish\"),\n          [finallyEntry.firstLoc]\n        )));\n      }\n    });\n\n    self.mark(after);\n\n    break;\n\n  case \"ThrowStatement\":\n    self.emit(t.throwStatement(\n      self.explodeExpression(path.get(\"argument\"))\n    ));\n\n    break;\n\n  default:\n    throw new Error(\n      \"unknown Statement of type \" +\n        JSON.stringify(stmt.type));\n  }\n};\n\nlet catchParamVisitor = {\n  Identifier: function(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n\n  Scope: function(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function(record) {\n  if (!isValidCompletion(record)) {\n    assert.ok(\n      false,\n      \"invalid completion record: \" +\n        JSON.stringify(record)\n    );\n  }\n\n  assert.notStrictEqual(\n    record.type, \"normal\",\n    \"normal completions are not abrupt\"\n  );\n\n  const t = util.getTypes();\n  let abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" ||\n      record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target)\n      ? record.target\n      : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" ||\n             record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value)\n        ? record.value\n        : t.cloneDeep(record.value);\n    }\n  }\n\n  this.emit(\n    t.returnStatement(\n      t.callExpression(\n        this.contextProperty(\"abrupt\"),\n        abruptArgs\n      )\n    )\n  );\n};\n\nfunction isValidCompletion(record) {\n  let type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" ||\n      type === \"continue\") {\n    return !hasOwn.call(record, \"value\")\n        && util.getTypes().isLiteral(record.target);\n  }\n\n  if (type === \"return\" ||\n      type === \"throw\") {\n    return hasOwn.call(record, \"value\")\n        && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n}\n\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function() {\n  return util.getTypes().numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function(loc) {\n  const t = util.getTypes();\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      assert.strictEqual(loc.value, this.listing.length);\n    }\n\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function(path, ignoreResult) {\n  const t = util.getTypes();\n  let expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  let self = this;\n  let result; // Used optionally by several cases below.\n  let after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  let hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    assert.ok(\n      !ignoreChildResult || !tempVar,\n      \"Ignoring the result of a child expression but forcing it to \" +\n        \"be assigned to a temporary variable?\"\n    );\n\n    let result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {\n      // Side effects already emitted above.\n\n    } else if (tempVar || (hasLeapingChildren &&\n                           !t.isLiteral(result))) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(\n        tempVar || self.makeTempVar(),\n        result\n      );\n    }\n    return result;\n  }\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n  case \"MemberExpression\":\n    return finish(t.memberExpression(\n      self.explodeExpression(path.get(\"object\")),\n      expr.computed\n        ? explodeViaTempVar(null, path.get(\"property\"))\n        : expr.property,\n      expr.computed\n    ));\n\n  case \"CallExpression\":\n    let calleePath = path.get(\"callee\");\n    let argsPath = path.get(\"arguments\");\n\n    let newCallee;\n    let newArgs;\n\n    let hasLeapingArgs = argsPath.some(\n      argPath => meta.containsLeap(argPath.node)\n    );\n\n    let injectFirstArg = null;\n\n    if (t.isMemberExpression(calleePath.node)) {\n      if (hasLeapingArgs) {\n        // If the arguments of the CallExpression contained any yield\n        // expressions, then we need to be sure to evaluate the callee\n        // before evaluating the arguments, but if the callee was a member\n        // expression, then we must be careful that the object of the\n        // member expression still gets bound to `this` for the call.\n\n        let newObject = explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(),\n          calleePath.get(\"object\")\n        );\n\n        let newProperty = calleePath.node.computed\n          ? explodeViaTempVar(null, calleePath.get(\"property\"))\n          : calleePath.node.property;\n\n        injectFirstArg = newObject;\n\n        newCallee = t.memberExpression(\n          t.memberExpression(\n            t.cloneDeep(newObject),\n            newProperty,\n            calleePath.node.computed\n          ),\n          t.identifier(\"call\"),\n          false\n        );\n\n      } else {\n        newCallee = self.explodeExpression(calleePath);\n      }\n\n    } else {\n      newCallee = explodeViaTempVar(null, calleePath);\n\n      if (t.isMemberExpression(newCallee)) {\n        // If the callee was not previously a MemberExpression, then the\n        // CallExpression was \"unqualified,\" meaning its `this` object\n        // should be the global object. If the exploded expression has\n        // become a MemberExpression (e.g. a context property, probably a\n        // temporary variable), then we need to force it to be unqualified\n        // by using the (0, object.property)(...) trick; otherwise, it\n        // will receive the object of the MemberExpression as its `this`\n        // object.\n        newCallee = t.sequenceExpression([\n          t.numericLiteral(0),\n          t.cloneDeep(newCallee)\n        ]);\n      }\n    }\n\n    if (hasLeapingArgs) {\n      newArgs = argsPath.map(argPath => explodeViaTempVar(null, argPath));\n      if (injectFirstArg) newArgs.unshift(injectFirstArg);\n\n      newArgs = newArgs.map(arg => t.cloneDeep(arg));\n    } else {\n      newArgs = path.node.arguments;\n    }\n\n    return finish(t.callExpression(newCallee, newArgs));\n\n  case \"NewExpression\":\n    return finish(t.newExpression(\n      explodeViaTempVar(null, path.get(\"callee\")),\n      path.get(\"arguments\").map(function(argPath) {\n        return explodeViaTempVar(null, argPath);\n      })\n    ));\n\n  case \"ObjectExpression\":\n    return finish(t.objectExpression(\n      path.get(\"properties\").map(function(propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(\n            propPath.node.key,\n            explodeViaTempVar(null, propPath.get(\"value\")),\n            propPath.node.computed\n          );\n        } else {\n          return propPath.node;\n        }\n      })\n    ));\n\n  case \"ArrayExpression\":\n    return finish(t.arrayExpression(\n      path.get(\"elements\").map(function(elemPath) {\n        if (elemPath.isSpreadElement()) {\n          return t.spreadElement(\n            explodeViaTempVar(null, elemPath.get(\"argument\"))\n          );\n        } else {\n          return explodeViaTempVar(null, elemPath);\n        }\n      })\n    ));\n\n  case \"SequenceExpression\":\n    let lastIndex = expr.expressions.length - 1;\n\n    path.get(\"expressions\").forEach(function(exprPath) {\n      if (exprPath.key === lastIndex) {\n        result = self.explodeExpression(exprPath, ignoreResult);\n      } else {\n        self.explodeExpression(exprPath, true);\n      }\n    });\n\n    return result;\n\n  case \"LogicalExpression\":\n    after = this.loc();\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    let left = explodeViaTempVar(result, path.get(\"left\"));\n\n    if (expr.operator === \"&&\") {\n      self.jumpIfNot(left, after);\n    } else {\n      assert.strictEqual(expr.operator, \"||\");\n      self.jumpIf(left, after);\n    }\n\n    explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"ConditionalExpression\":\n    let elseLoc = this.loc();\n    after = this.loc();\n    let test = self.explodeExpression(path.get(\"test\"));\n\n    self.jumpIfNot(test, elseLoc);\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n    self.jump(after);\n\n    self.mark(elseLoc);\n    explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"UnaryExpression\":\n    return finish(t.unaryExpression(\n      expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")),\n      !!expr.prefix\n    ));\n\n  case \"BinaryExpression\":\n    return finish(t.binaryExpression(\n      expr.operator,\n      explodeViaTempVar(null, path.get(\"left\")),\n      explodeViaTempVar(null, path.get(\"right\"))\n    ));\n\n  case \"AssignmentExpression\":\n    if (expr.operator === \"=\") {\n      // If this is a simple assignment, the left hand side does not need\n      // to be read before the right hand side is evaluated, so we can\n      // avoid the more complicated logic below.\n      return finish(t.assignmentExpression(\n        expr.operator,\n        self.explodeExpression(path.get(\"left\")),\n        self.explodeExpression(path.get(\"right\"))\n      ));\n    }\n\n    const lhs = self.explodeExpression(path.get(\"left\"));\n    const temp = self.emitAssign(self.makeTempVar(), lhs);\n\n    // For example,\n    //\n    //   x += yield y\n    //\n    // becomes\n    //\n    //   context.t0 = x\n    //   x = context.t0 += yield y\n    //\n    // so that the left-hand side expression is read before the yield.\n    // Fixes https://github.com/facebook/regenerator/issues/345.\n\n    return finish(t.assignmentExpression(\n      \"=\",\n      t.cloneDeep(lhs),\n      t.assignmentExpression(\n        expr.operator,\n        t.cloneDeep(temp),\n        self.explodeExpression(path.get(\"right\"))\n      )\n    ));\n\n  case \"UpdateExpression\":\n    return finish(t.updateExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"argument\")),\n      expr.prefix\n    ));\n\n  case \"YieldExpression\":\n    after = this.loc();\n    let arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n    if (arg && expr.delegate) {\n      let result = self.makeTempVar();\n\n      let ret = t.returnStatement(t.callExpression(\n        self.contextProperty(\"delegateYield\"),\n        [\n          arg,\n          t.stringLiteral(result.property.name),\n          after\n        ]\n      ));\n      ret.loc = expr.loc;\n\n      self.emit(ret);\n      self.mark(after);\n\n      return result;\n    }\n\n    self.emitAssign(self.contextProperty(\"next\"), after);\n\n    let ret = t.returnStatement(t.cloneDeep(arg) || null);\n    // Preserve the `yield` location so that source mappings for the statements\n    // link back to the yield properly.\n    ret.loc = expr.loc;\n    self.emit(ret);\n    self.mark(after);\n\n    return self.contextProperty(\"sent\");\n\n  default:\n    throw new Error(\n      \"unknown Expression of type \" +\n        JSON.stringify(expr.type));\n  }\n};\n"]},"metadata":{},"sourceType":"module"}