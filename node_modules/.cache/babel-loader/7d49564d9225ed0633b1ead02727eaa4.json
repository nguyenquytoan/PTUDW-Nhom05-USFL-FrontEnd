{"ast":null,"code":"/* js-yaml 3.14.0 https://github.com/nodeca/js-yaml */\n(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.jsyaml = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      var loader = require('./js-yaml/loader');\n\n      var dumper = require('./js-yaml/dumper');\n\n      function deprecated(name) {\n        return function () {\n          throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n        };\n      }\n\n      module.exports.Type = require('./js-yaml/type');\n      module.exports.Schema = require('./js-yaml/schema');\n      module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');\n      module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');\n      module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\n      module.exports.load = loader.load;\n      module.exports.loadAll = loader.loadAll;\n      module.exports.safeLoad = loader.safeLoad;\n      module.exports.safeLoadAll = loader.safeLoadAll;\n      module.exports.dump = dumper.dump;\n      module.exports.safeDump = dumper.safeDump;\n      module.exports.YAMLException = require('./js-yaml/exception'); // Deprecated schema names from JS-YAML 2.0.x\n\n      module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full'); // Deprecated functions from JS-YAML 1.x.x\n\n      module.exports.scan = deprecated('scan');\n      module.exports.parse = deprecated('parse');\n      module.exports.compose = deprecated('compose');\n      module.exports.addConstructor = deprecated('addConstructor');\n    }, {\n      \"./js-yaml/dumper\": 3,\n      \"./js-yaml/exception\": 4,\n      \"./js-yaml/loader\": 5,\n      \"./js-yaml/schema\": 7,\n      \"./js-yaml/schema/core\": 8,\n      \"./js-yaml/schema/default_full\": 9,\n      \"./js-yaml/schema/default_safe\": 10,\n      \"./js-yaml/schema/failsafe\": 11,\n      \"./js-yaml/schema/json\": 12,\n      \"./js-yaml/type\": 13\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      function isNothing(subject) {\n        return typeof subject === 'undefined' || subject === null;\n      }\n\n      function isObject(subject) {\n        return typeof subject === 'object' && subject !== null;\n      }\n\n      function toArray(sequence) {\n        if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n        return [sequence];\n      }\n\n      function extend(target, source) {\n        var index, length, key, sourceKeys;\n\n        if (source) {\n          sourceKeys = Object.keys(source);\n\n          for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n            key = sourceKeys[index];\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function repeat(string, count) {\n        var result = '',\n            cycle;\n\n        for (cycle = 0; cycle < count; cycle += 1) {\n          result += string;\n        }\n\n        return result;\n      }\n\n      function isNegativeZero(number) {\n        return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n      }\n\n      module.exports.isNothing = isNothing;\n      module.exports.isObject = isObject;\n      module.exports.toArray = toArray;\n      module.exports.repeat = repeat;\n      module.exports.isNegativeZero = isNegativeZero;\n      module.exports.extend = extend;\n    }, {}],\n    3: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable no-use-before-define*/\n\n      var common = require('./common');\n\n      var YAMLException = require('./exception');\n\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\n      var _toString = Object.prototype.toString;\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var CHAR_TAB = 0x09;\n      /* Tab */\n\n      var CHAR_LINE_FEED = 0x0A;\n      /* LF */\n\n      var CHAR_CARRIAGE_RETURN = 0x0D;\n      /* CR */\n\n      var CHAR_SPACE = 0x20;\n      /* Space */\n\n      var CHAR_EXCLAMATION = 0x21;\n      /* ! */\n\n      var CHAR_DOUBLE_QUOTE = 0x22;\n      /* \" */\n\n      var CHAR_SHARP = 0x23;\n      /* # */\n\n      var CHAR_PERCENT = 0x25;\n      /* % */\n\n      var CHAR_AMPERSAND = 0x26;\n      /* & */\n\n      var CHAR_SINGLE_QUOTE = 0x27;\n      /* ' */\n\n      var CHAR_ASTERISK = 0x2A;\n      /* * */\n\n      var CHAR_COMMA = 0x2C;\n      /* , */\n\n      var CHAR_MINUS = 0x2D;\n      /* - */\n\n      var CHAR_COLON = 0x3A;\n      /* : */\n\n      var CHAR_EQUALS = 0x3D;\n      /* = */\n\n      var CHAR_GREATER_THAN = 0x3E;\n      /* > */\n\n      var CHAR_QUESTION = 0x3F;\n      /* ? */\n\n      var CHAR_COMMERCIAL_AT = 0x40;\n      /* @ */\n\n      var CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n      /* [ */\n\n      var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n      /* ] */\n\n      var CHAR_GRAVE_ACCENT = 0x60;\n      /* ` */\n\n      var CHAR_LEFT_CURLY_BRACKET = 0x7B;\n      /* { */\n\n      var CHAR_VERTICAL_LINE = 0x7C;\n      /* | */\n\n      var CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n      /* } */\n\n      var ESCAPE_SEQUENCES = {};\n      ESCAPE_SEQUENCES[0x00] = '\\\\0';\n      ESCAPE_SEQUENCES[0x07] = '\\\\a';\n      ESCAPE_SEQUENCES[0x08] = '\\\\b';\n      ESCAPE_SEQUENCES[0x09] = '\\\\t';\n      ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n      ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n      ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n      ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n      ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n      ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n      ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n      ESCAPE_SEQUENCES[0x85] = '\\\\N';\n      ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n      ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n      ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n      var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n\n      function compileStyleMap(schema, map) {\n        var result, keys, index, length, tag, style, type;\n        if (map === null) return {};\n        result = {};\n        keys = Object.keys(map);\n\n        for (index = 0, length = keys.length; index < length; index += 1) {\n          tag = keys[index];\n          style = String(map[tag]);\n\n          if (tag.slice(0, 2) === '!!') {\n            tag = 'tag:yaml.org,2002:' + tag.slice(2);\n          }\n\n          type = schema.compiledTypeMap['fallback'][tag];\n\n          if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n            style = type.styleAliases[style];\n          }\n\n          result[tag] = style;\n        }\n\n        return result;\n      }\n\n      function encodeHex(character) {\n        var string, handle, length;\n        string = character.toString(16).toUpperCase();\n\n        if (character <= 0xFF) {\n          handle = 'x';\n          length = 2;\n        } else if (character <= 0xFFFF) {\n          handle = 'u';\n          length = 4;\n        } else if (character <= 0xFFFFFFFF) {\n          handle = 'U';\n          length = 8;\n        } else {\n          throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n        }\n\n        return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n      }\n\n      function State(options) {\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.indent = Math.max(1, options['indent'] || 2);\n        this.noArrayIndent = options['noArrayIndent'] || false;\n        this.skipInvalid = options['skipInvalid'] || false;\n        this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n        this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n        this.sortKeys = options['sortKeys'] || false;\n        this.lineWidth = options['lineWidth'] || 80;\n        this.noRefs = options['noRefs'] || false;\n        this.noCompatMode = options['noCompatMode'] || false;\n        this.condenseFlow = options['condenseFlow'] || false;\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.explicitTypes = this.schema.compiledExplicit;\n        this.tag = null;\n        this.result = '';\n        this.duplicates = [];\n        this.usedDuplicates = null;\n      } // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\n      function indentString(string, spaces) {\n        var ind = common.repeat(' ', spaces),\n            position = 0,\n            next = -1,\n            result = '',\n            line,\n            length = string.length;\n\n        while (position < length) {\n          next = string.indexOf('\\n', position);\n\n          if (next === -1) {\n            line = string.slice(position);\n            position = length;\n          } else {\n            line = string.slice(position, next + 1);\n            position = next + 1;\n          }\n\n          if (line.length && line !== '\\n') result += ind;\n          result += line;\n        }\n\n        return result;\n      }\n\n      function generateNextLine(state, level) {\n        return '\\n' + common.repeat(' ', state.indent * level);\n      }\n\n      function testImplicitResolving(state, str) {\n        var index, length, type;\n\n        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n          type = state.implicitTypes[index];\n\n          if (type.resolve(str)) {\n            return true;\n          }\n        }\n\n        return false;\n      } // [33] s-white ::= s-space | s-tab\n\n\n      function isWhitespace(c) {\n        return c === CHAR_SPACE || c === CHAR_TAB;\n      } // Returns true if the character can be printed without escaping.\n      // From YAML 1.2: \"any allowed characters known to be non-printable\n      // should also be escaped. [However,] This isn’t mandatory\"\n      // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\n      function isPrintable(c) {\n        return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF\n        /* BOM */\n        || 0x10000 <= c && c <= 0x10FFFF;\n      } // [34] ns-char ::= nb-char - s-white\n      // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n      // [26] b-char  ::= b-line-feed | b-carriage-return\n      // [24] b-line-feed       ::=     #xA    /* LF */\n      // [25] b-carriage-return ::=     #xD    /* CR */\n      // [3]  c-byte-order-mark ::=     #xFEFF\n\n\n      function isNsChar(c) {\n        return isPrintable(c) && !isWhitespace(c) // byte-order-mark\n        && c !== 0xFEFF // b-char\n        && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n      } // Simplified test for values allowed after the first character in plain style.\n\n\n      function isPlainSafe(c, prev) {\n        // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n        // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n        return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator\n        && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - \":\" - \"#\"\n        // /* An ns-char preceding */ \"#\"\n        && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));\n      } // Simplified test for values allowed as the first character in plain style.\n\n\n      function isPlainSafeFirst(c) {\n        // Uses a subset of ns-char - c-indicator\n        // where ns-char = nb-char - s-white.\n        return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n        // - (c-indicator ::=\n        // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n        && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n        && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | “%” | “@” | “`”)\n        && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n      } // Determines whether block indentation indicator is required.\n\n\n      function needIndentIndicator(string) {\n        var leadingSpaceRe = /^\\n* /;\n        return leadingSpaceRe.test(string);\n      }\n\n      var STYLE_PLAIN = 1,\n          STYLE_SINGLE = 2,\n          STYLE_LITERAL = 3,\n          STYLE_FOLDED = 4,\n          STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n      // lineWidth = -1 => no limit.\n      // Pre-conditions: str.length > 0.\n      // Post-conditions:\n      //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n      //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n      //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\n      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n        var i;\n        var char, prev_char;\n        var hasLineBreak = false;\n        var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n        var shouldTrackWidth = lineWidth !== -1;\n        var previousLineBreak = -1; // count the first line correctly\n\n        var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n\n        if (singleLineOnly) {\n          // Case: no block styles.\n          // Check for disallowed characters to rule out plain and single.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n\n            if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          }\n        } else {\n          // Case: block styles permitted.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n\n            if (char === CHAR_LINE_FEED) {\n              hasLineBreak = true; // Check if any line can be folded.\n\n              if (shouldTrackWidth) {\n                hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n                i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n                previousLineBreak = i;\n              }\n            } else if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          } // in case the end is missing a \\n\n\n\n          hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n        } // Although every style can represent \\n without escaping, prefer block styles\n        // for multiline, since they're more readable and they don't add empty lines.\n        // Also prefer folding a super-long line.\n\n\n        if (!hasLineBreak && !hasFoldableLine) {\n          // Strings interpretable as another type have to be quoted;\n          // e.g. the string 'true' vs. the boolean true.\n          return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n        } // Edge case: block indentation indicator can only have one digit.\n\n\n        if (indentPerLevel > 9 && needIndentIndicator(string)) {\n          return STYLE_DOUBLE;\n        } // At this point we know block styles are valid.\n        // Prefer literal style unless we want to fold.\n\n\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n      } // Note: line breaking/folding is implemented for only the folded style.\n      // NB. We drop the last trailing newline (if any) of a returned block scalar\n      //  since the dumper adds its own newline. This always works:\n      //    • No ending newline => unaffected; already using strip \"-\" chomping.\n      //    • Ending newline    => removed then restored.\n      //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\n      function writeScalar(state, string, level, iskey) {\n        state.dump = function () {\n          if (string.length === 0) {\n            return \"''\";\n          }\n\n          if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n            return \"'\" + string + \"'\";\n          }\n\n          var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n          // As indentation gets deeper, let the width decrease monotonically\n          // to the lower bound min(state.lineWidth, 40).\n          // Note that this implies\n          //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n          //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n          // This behaves better than a constant minimum width which disallows narrower options,\n          // or an indent threshold which causes the width to suddenly increase.\n\n          var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n          var singleLineOnly = iskey // No block styles in flow mode.\n          || state.flowLevel > -1 && level >= state.flowLevel;\n\n          function testAmbiguity(string) {\n            return testImplicitResolving(state, string);\n          }\n\n          switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n            case STYLE_PLAIN:\n              return string;\n\n            case STYLE_SINGLE:\n              return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n            case STYLE_LITERAL:\n              return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n            case STYLE_FOLDED:\n              return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n            case STYLE_DOUBLE:\n              return '\"' + escapeString(string, lineWidth) + '\"';\n\n            default:\n              throw new YAMLException('impossible error: invalid scalar style');\n          }\n        }();\n      } // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\n      function blockHeader(string, indentPerLevel) {\n        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n        var clip = string[string.length - 1] === '\\n';\n        var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n        var chomp = keep ? '+' : clip ? '' : '-';\n        return indentIndicator + chomp + '\\n';\n      } // (See the note for writeScalar.)\n\n\n      function dropEndingNewline(string) {\n        return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n      } // Note: a long line without a suitable break point will exceed the width limit.\n      // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\n      function foldString(string, width) {\n        // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n        // unless they're before or after a more-indented line, or at the very\n        // beginning or end, in which case $k$ maps to $k$.\n        // Therefore, parse each chunk as newline(s) followed by a content line.\n        var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n        var result = function () {\n          var nextLF = string.indexOf('\\n');\n          nextLF = nextLF !== -1 ? nextLF : string.length;\n          lineRe.lastIndex = nextLF;\n          return foldLine(string.slice(0, nextLF), width);\n        }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n        var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n        var moreIndented; // rest of the lines\n\n        var match;\n\n        while (match = lineRe.exec(string)) {\n          var prefix = match[1],\n              line = match[2];\n          moreIndented = line[0] === ' ';\n          result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n          prevMoreIndented = moreIndented;\n        }\n\n        return result;\n      } // Greedy line breaking.\n      // Picks the longest line under the limit each time,\n      // otherwise settles for the shortest line over the limit.\n      // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\n      function foldLine(line, width) {\n        if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n        var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n        var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n        var start = 0,\n            end,\n            curr = 0,\n            next = 0;\n        var result = ''; // Invariants: 0 <= start <= length-1.\n        //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n        // Inside the loop:\n        //   A match implies length >= 2, so curr and next are <= length-2.\n\n        while (match = breakRe.exec(line)) {\n          next = match.index; // maintain invariant: curr - start <= width\n\n          if (next - start > width) {\n            end = curr > start ? curr : next; // derive end <= length-2\n\n            result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n            start = end + 1; // derive start <= length-1\n          }\n\n          curr = next;\n        } // By the invariants, start <= length-1, so there is something left over.\n        // It is either the whole string or a part starting from non-whitespace.\n\n\n        result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n        if (line.length - start > width && curr > start) {\n          result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n        } else {\n          result += line.slice(start);\n        }\n\n        return result.slice(1); // drop extra \\n joiner\n      } // Escapes a double-quoted string.\n\n\n      function escapeString(string) {\n        var result = '';\n        var char, nextChar;\n        var escapeSeq;\n\n        for (var i = 0; i < string.length; i++) {\n          char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n\n          if (char >= 0xD800 && char <= 0xDBFF\n          /* high surrogate */\n          ) {\n              nextChar = string.charCodeAt(i + 1);\n\n              if (nextChar >= 0xDC00 && nextChar <= 0xDFFF\n              /* low surrogate */\n              ) {\n                  // Combine the surrogate pair and store it escaped.\n                  result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.\n\n                  i++;\n                  continue;\n                }\n            }\n\n          escapeSeq = ESCAPE_SEQUENCES[char];\n          result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n        }\n\n        return result;\n      }\n\n      function writeFlowSequence(state, level, object) {\n        var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level, object[index], false, false)) {\n            if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = '[' + _result + ']';\n      }\n\n      function writeBlockSequence(state, level, object, compact) {\n        var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level + 1, object[index], true, true)) {\n            if (!compact || index !== 0) {\n              _result += generateNextLine(state, level);\n            }\n\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              _result += '-';\n            } else {\n              _result += '- ';\n            }\n\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '[]'; // Empty sequence if no valid values.\n      }\n\n      function writeFlowMapping(state, level, object) {\n        var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            pairBuffer;\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          pairBuffer = '';\n          if (index !== 0) pairBuffer += ', ';\n          if (state.condenseFlow) pairBuffer += '\"';\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level, objectKey, false, false)) {\n            continue; // Skip this pair because of invalid key;\n          }\n\n          if (state.dump.length > 1024) pairBuffer += '? ';\n          pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n          if (!writeNode(state, level, objectValue, false, false)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          pairBuffer += state.dump; // Both key and value are valid.\n\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = '{' + _result + '}';\n      }\n\n      function writeBlockMapping(state, level, object, compact) {\n        var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            explicitPair,\n            pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n        if (state.sortKeys === true) {\n          // Default sorting\n          objectKeyList.sort();\n        } else if (typeof state.sortKeys === 'function') {\n          // Custom sort function\n          objectKeyList.sort(state.sortKeys);\n        } else if (state.sortKeys) {\n          // Something is wrong\n          throw new YAMLException('sortKeys must be a boolean or a function');\n        }\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          pairBuffer = '';\n\n          if (!compact || index !== 0) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n            continue; // Skip this pair because of invalid key.\n          }\n\n          explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n          if (explicitPair) {\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              pairBuffer += '?';\n            } else {\n              pairBuffer += '? ';\n            }\n          }\n\n          pairBuffer += state.dump;\n\n          if (explicitPair) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += ':';\n          } else {\n            pairBuffer += ': ';\n          }\n\n          pairBuffer += state.dump; // Both key and value are valid.\n\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n      }\n\n      function detectType(state, object, explicit) {\n        var _result, typeList, index, length, type, style;\n\n        typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n        for (index = 0, length = typeList.length; index < length; index += 1) {\n          type = typeList[index];\n\n          if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n            state.tag = explicit ? type.tag : '?';\n\n            if (type.represent) {\n              style = state.styleMap[type.tag] || type.defaultStyle;\n\n              if (_toString.call(type.represent) === '[object Function]') {\n                _result = type.represent(object, style);\n              } else if (_hasOwnProperty.call(type.represent, style)) {\n                _result = type.represent[style](object, style);\n              } else {\n                throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n              }\n\n              state.dump = _result;\n            }\n\n            return true;\n          }\n        }\n\n        return false;\n      } // Serializes `object` and writes it to global `result`.\n      // Returns true on success, or false on invalid object.\n      //\n\n\n      function writeNode(state, level, object, block, compact, iskey) {\n        state.tag = null;\n        state.dump = object;\n\n        if (!detectType(state, object, false)) {\n          detectType(state, object, true);\n        }\n\n        var type = _toString.call(state.dump);\n\n        if (block) {\n          block = state.flowLevel < 0 || state.flowLevel > level;\n        }\n\n        var objectOrArray = type === '[object Object]' || type === '[object Array]',\n            duplicateIndex,\n            duplicate;\n\n        if (objectOrArray) {\n          duplicateIndex = state.duplicates.indexOf(object);\n          duplicate = duplicateIndex !== -1;\n        }\n\n        if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n          compact = false;\n        }\n\n        if (duplicate && state.usedDuplicates[duplicateIndex]) {\n          state.dump = '*ref_' + duplicateIndex;\n        } else {\n          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n            state.usedDuplicates[duplicateIndex] = true;\n          }\n\n          if (type === '[object Object]') {\n            if (block && Object.keys(state.dump).length !== 0) {\n              writeBlockMapping(state, level, state.dump, compact);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowMapping(state, level, state.dump);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object Array]') {\n            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n\n            if (block && state.dump.length !== 0) {\n              writeBlockSequence(state, arrayLevel, state.dump, compact);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowSequence(state, arrayLevel, state.dump);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object String]') {\n            if (state.tag !== '?') {\n              writeScalar(state, state.dump, level, iskey);\n            }\n          } else {\n            if (state.skipInvalid) return false;\n            throw new YAMLException('unacceptable kind of an object to dump ' + type);\n          }\n\n          if (state.tag !== null && state.tag !== '?') {\n            state.dump = '!<' + state.tag + '> ' + state.dump;\n          }\n        }\n\n        return true;\n      }\n\n      function getDuplicateReferences(object, state) {\n        var objects = [],\n            duplicatesIndexes = [],\n            index,\n            length;\n        inspectNode(object, objects, duplicatesIndexes);\n\n        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n          state.duplicates.push(objects[duplicatesIndexes[index]]);\n        }\n\n        state.usedDuplicates = new Array(length);\n      }\n\n      function inspectNode(object, objects, duplicatesIndexes) {\n        var objectKeyList, index, length;\n\n        if (object !== null && typeof object === 'object') {\n          index = objects.indexOf(object);\n\n          if (index !== -1) {\n            if (duplicatesIndexes.indexOf(index) === -1) {\n              duplicatesIndexes.push(index);\n            }\n          } else {\n            objects.push(object);\n\n            if (Array.isArray(object)) {\n              for (index = 0, length = object.length; index < length; index += 1) {\n                inspectNode(object[index], objects, duplicatesIndexes);\n              }\n            } else {\n              objectKeyList = Object.keys(object);\n\n              for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n              }\n            }\n          }\n        }\n      }\n\n      function dump(input, options) {\n        options = options || {};\n        var state = new State(options);\n        if (!state.noRefs) getDuplicateReferences(input, state);\n        if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n        return '';\n      }\n\n      function safeDump(input, options) {\n        return dump(input, common.extend({\n          schema: DEFAULT_SAFE_SCHEMA\n        }, options));\n      }\n\n      module.exports.dump = dump;\n      module.exports.safeDump = safeDump;\n    }, {\n      \"./common\": 2,\n      \"./exception\": 4,\n      \"./schema/default_full\": 9,\n      \"./schema/default_safe\": 10\n    }],\n    4: [function (require, module, exports) {\n      // YAML error class. http://stackoverflow.com/questions/8458984\n      //\n      'use strict';\n\n      function YAMLException(reason, mark) {\n        // Super constructor\n        Error.call(this);\n        this.name = 'YAMLException';\n        this.reason = reason;\n        this.mark = mark;\n        this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object\n\n        if (Error.captureStackTrace) {\n          // Chrome and NodeJS\n          Error.captureStackTrace(this, this.constructor);\n        } else {\n          // FF, IE 10+ and Safari 6+. Fallback for others\n          this.stack = new Error().stack || '';\n        }\n      } // Inherit from Error\n\n\n      YAMLException.prototype = Object.create(Error.prototype);\n      YAMLException.prototype.constructor = YAMLException;\n\n      YAMLException.prototype.toString = function toString(compact) {\n        var result = this.name + ': ';\n        result += this.reason || '(unknown reason)';\n\n        if (!compact && this.mark) {\n          result += ' ' + this.mark.toString();\n        }\n\n        return result;\n      };\n\n      module.exports = YAMLException;\n    }, {}],\n    5: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable max-len,no-use-before-define*/\n\n      var common = require('./common');\n\n      var YAMLException = require('./exception');\n\n      var Mark = require('./mark');\n\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var CONTEXT_FLOW_IN = 1;\n      var CONTEXT_FLOW_OUT = 2;\n      var CONTEXT_BLOCK_IN = 3;\n      var CONTEXT_BLOCK_OUT = 4;\n      var CHOMPING_CLIP = 1;\n      var CHOMPING_STRIP = 2;\n      var CHOMPING_KEEP = 3;\n      var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n      var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n      var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n      var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n      function _class(obj) {\n        return Object.prototype.toString.call(obj);\n      }\n\n      function is_EOL(c) {\n        return c === 0x0A\n        /* LF */\n        || c === 0x0D\n        /* CR */\n        ;\n      }\n\n      function is_WHITE_SPACE(c) {\n        return c === 0x09\n        /* Tab */\n        || c === 0x20\n        /* Space */\n        ;\n      }\n\n      function is_WS_OR_EOL(c) {\n        return c === 0x09\n        /* Tab */\n        || c === 0x20\n        /* Space */\n        || c === 0x0A\n        /* LF */\n        || c === 0x0D\n        /* CR */\n        ;\n      }\n\n      function is_FLOW_INDICATOR(c) {\n        return c === 0x2C\n        /* , */\n        || c === 0x5B\n        /* [ */\n        || c === 0x5D\n        /* ] */\n        || c === 0x7B\n        /* { */\n        || c === 0x7D\n        /* } */\n        ;\n      }\n\n      function fromHexCode(c) {\n        var lc;\n\n        if (0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        ) {\n          return c - 0x30;\n        }\n        /*eslint-disable no-bitwise*/\n\n\n        lc = c | 0x20;\n\n        if (0x61\n        /* a */\n        <= lc && lc <= 0x66\n        /* f */\n        ) {\n          return lc - 0x61 + 10;\n        }\n\n        return -1;\n      }\n\n      function escapedHexLen(c) {\n        if (c === 0x78\n        /* x */\n        ) {\n            return 2;\n          }\n\n        if (c === 0x75\n        /* u */\n        ) {\n            return 4;\n          }\n\n        if (c === 0x55\n        /* U */\n        ) {\n            return 8;\n          }\n\n        return 0;\n      }\n\n      function fromDecimalCode(c) {\n        if (0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        ) {\n          return c - 0x30;\n        }\n\n        return -1;\n      }\n\n      function simpleEscapeSequence(c) {\n        /* eslint-disable indent */\n        return c === 0x30\n        /* 0 */\n        ? '\\x00' : c === 0x61\n        /* a */\n        ? '\\x07' : c === 0x62\n        /* b */\n        ? '\\x08' : c === 0x74\n        /* t */\n        ? '\\x09' : c === 0x09\n        /* Tab */\n        ? '\\x09' : c === 0x6E\n        /* n */\n        ? '\\x0A' : c === 0x76\n        /* v */\n        ? '\\x0B' : c === 0x66\n        /* f */\n        ? '\\x0C' : c === 0x72\n        /* r */\n        ? '\\x0D' : c === 0x65\n        /* e */\n        ? '\\x1B' : c === 0x20\n        /* Space */\n        ? ' ' : c === 0x22\n        /* \" */\n        ? '\\x22' : c === 0x2F\n        /* / */\n        ? '/' : c === 0x5C\n        /* \\ */\n        ? '\\x5C' : c === 0x4E\n        /* N */\n        ? '\\x85' : c === 0x5F\n        /* _ */\n        ? '\\xA0' : c === 0x4C\n        /* L */\n        ? '\\u2028' : c === 0x50\n        /* P */\n        ? '\\u2029' : '';\n      }\n\n      function charFromCodepoint(c) {\n        if (c <= 0xFFFF) {\n          return String.fromCharCode(c);\n        } // Encode UTF-16 surrogate pair\n        // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n\n\n        return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n      }\n\n      var simpleEscapeCheck = new Array(256); // integer, for fast access\n\n      var simpleEscapeMap = new Array(256);\n\n      for (var i = 0; i < 256; i++) {\n        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n        simpleEscapeMap[i] = simpleEscapeSequence(i);\n      }\n\n      function State(input, options) {\n        this.input = input;\n        this.filename = options['filename'] || null;\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.onWarning = options['onWarning'] || null;\n        this.legacy = options['legacy'] || false;\n        this.json = options['json'] || false;\n        this.listener = options['listener'] || null;\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.typeMap = this.schema.compiledTypeMap;\n        this.length = input.length;\n        this.position = 0;\n        this.line = 0;\n        this.lineStart = 0;\n        this.lineIndent = 0;\n        this.documents = [];\n        /*\n        this.version;\n        this.checkLineBreaks;\n        this.tagMap;\n        this.anchorMap;\n        this.tag;\n        this.anchor;\n        this.kind;\n        this.result;*/\n      }\n\n      function generateError(state, message) {\n        return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));\n      }\n\n      function throwError(state, message) {\n        throw generateError(state, message);\n      }\n\n      function throwWarning(state, message) {\n        if (state.onWarning) {\n          state.onWarning.call(null, generateError(state, message));\n        }\n      }\n\n      var directiveHandlers = {\n        YAML: function handleYamlDirective(state, name, args) {\n          var match, major, minor;\n\n          if (state.version !== null) {\n            throwError(state, 'duplication of %YAML directive');\n          }\n\n          if (args.length !== 1) {\n            throwError(state, 'YAML directive accepts exactly one argument');\n          }\n\n          match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n          if (match === null) {\n            throwError(state, 'ill-formed argument of the YAML directive');\n          }\n\n          major = parseInt(match[1], 10);\n          minor = parseInt(match[2], 10);\n\n          if (major !== 1) {\n            throwError(state, 'unacceptable YAML version of the document');\n          }\n\n          state.version = args[0];\n          state.checkLineBreaks = minor < 2;\n\n          if (minor !== 1 && minor !== 2) {\n            throwWarning(state, 'unsupported YAML version of the document');\n          }\n        },\n        TAG: function handleTagDirective(state, name, args) {\n          var handle, prefix;\n\n          if (args.length !== 2) {\n            throwError(state, 'TAG directive accepts exactly two arguments');\n          }\n\n          handle = args[0];\n          prefix = args[1];\n\n          if (!PATTERN_TAG_HANDLE.test(handle)) {\n            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n          }\n\n          if (_hasOwnProperty.call(state.tagMap, handle)) {\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n          }\n\n          if (!PATTERN_TAG_URI.test(prefix)) {\n            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n          }\n\n          state.tagMap[handle] = prefix;\n        }\n      };\n\n      function captureSegment(state, start, end, checkJson) {\n        var _position, _length, _character, _result;\n\n        if (start < end) {\n          _result = state.input.slice(start, end);\n\n          if (checkJson) {\n            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n              _character = _result.charCodeAt(_position);\n\n              if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n                throwError(state, 'expected valid JSON character');\n              }\n            }\n          } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n            throwError(state, 'the stream contains non-printable characters');\n          }\n\n          state.result += _result;\n        }\n      }\n\n      function mergeMappings(state, destination, source, overridableKeys) {\n        var sourceKeys, key, index, quantity;\n\n        if (!common.isObject(source)) {\n          throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n        }\n\n        sourceKeys = Object.keys(source);\n\n        for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n          key = sourceKeys[index];\n\n          if (!_hasOwnProperty.call(destination, key)) {\n            destination[key] = source[key];\n            overridableKeys[key] = true;\n          }\n        }\n      }\n\n      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n        var index, quantity; // The output is a plain object here, so keys can only be strings.\n        // We need to convert keyNode to a string, but doing so can hang the process\n        // (deeply nested arrays that explode exponentially using aliases).\n\n        if (Array.isArray(keyNode)) {\n          keyNode = Array.prototype.slice.call(keyNode);\n\n          for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n            if (Array.isArray(keyNode[index])) {\n              throwError(state, 'nested arrays are not supported inside keys');\n            }\n\n            if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n              keyNode[index] = '[object Object]';\n            }\n          }\n        } // Avoid code execution in load() via toString property\n        // (still use its own toString for arrays, timestamps,\n        // and whatever user schema extensions happen to have @@toStringTag)\n\n\n        if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n          keyNode = '[object Object]';\n        }\n\n        keyNode = String(keyNode);\n\n        if (_result === null) {\n          _result = {};\n        }\n\n        if (keyTag === 'tag:yaml.org,2002:merge') {\n          if (Array.isArray(valueNode)) {\n            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n              mergeMappings(state, _result, valueNode[index], overridableKeys);\n            }\n          } else {\n            mergeMappings(state, _result, valueNode, overridableKeys);\n          }\n        } else {\n          if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {\n            state.line = startLine || state.line;\n            state.position = startPos || state.position;\n            throwError(state, 'duplicated mapping key');\n          }\n\n          _result[keyNode] = valueNode;\n          delete overridableKeys[keyNode];\n        }\n\n        return _result;\n      }\n\n      function readLineBreak(state) {\n        var ch;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x0A\n        /* LF */\n        ) {\n            state.position++;\n          } else if (ch === 0x0D\n        /* CR */\n        ) {\n            state.position++;\n\n            if (state.input.charCodeAt(state.position) === 0x0A\n            /* LF */\n            ) {\n                state.position++;\n              }\n          } else {\n          throwError(state, 'a line break is expected');\n        }\n\n        state.line += 1;\n        state.lineStart = state.position;\n      }\n\n      function skipSeparationSpace(state, allowComments, checkIndent) {\n        var lineBreaks = 0,\n            ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (allowComments && ch === 0x23\n          /* # */\n          ) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (ch !== 0x0A\n              /* LF */\n              && ch !== 0x0D\n              /* CR */\n              && ch !== 0);\n            }\n\n          if (is_EOL(ch)) {\n            readLineBreak(state);\n            ch = state.input.charCodeAt(state.position);\n            lineBreaks++;\n            state.lineIndent = 0;\n\n            while (ch === 0x20\n            /* Space */\n            ) {\n              state.lineIndent++;\n              ch = state.input.charCodeAt(++state.position);\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n          throwWarning(state, 'deficient indentation');\n        }\n\n        return lineBreaks;\n      }\n\n      function testDocumentSeparator(state) {\n        var _position = state.position,\n            ch;\n        ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested\n        // in parent on each call, for efficiency. No needs to test here again.\n\n        if ((ch === 0x2D\n        /* - */\n        || ch === 0x2E\n        /* . */\n        ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n          _position += 3;\n          ch = state.input.charCodeAt(_position);\n\n          if (ch === 0 || is_WS_OR_EOL(ch)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function writeFoldedLines(state, count) {\n        if (count === 1) {\n          state.result += ' ';\n        } else if (count > 1) {\n          state.result += common.repeat('\\n', count - 1);\n        }\n      }\n\n      function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n        var preceding,\n            following,\n            captureStart,\n            captureEnd,\n            hasPendingContent,\n            _line,\n            _lineStart,\n            _lineIndent,\n            _kind = state.kind,\n            _result = state.result,\n            ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23\n        /* # */\n        || ch === 0x26\n        /* & */\n        || ch === 0x2A\n        /* * */\n        || ch === 0x21\n        /* ! */\n        || ch === 0x7C\n        /* | */\n        || ch === 0x3E\n        /* > */\n        || ch === 0x27\n        /* ' */\n        || ch === 0x22\n        /* \" */\n        || ch === 0x25\n        /* % */\n        || ch === 0x40\n        /* @ */\n        || ch === 0x60\n        /* ` */\n        ) {\n            return false;\n          }\n\n        if (ch === 0x3F\n        /* ? */\n        || ch === 0x2D\n        /* - */\n        ) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n              return false;\n            }\n          }\n\n        state.kind = 'scalar';\n        state.result = '';\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n\n        while (ch !== 0) {\n          if (ch === 0x3A\n          /* : */\n          ) {\n              following = state.input.charCodeAt(state.position + 1);\n\n              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n                break;\n              }\n            } else if (ch === 0x23\n          /* # */\n          ) {\n              preceding = state.input.charCodeAt(state.position - 1);\n\n              if (is_WS_OR_EOL(preceding)) {\n                break;\n              }\n            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n            break;\n          } else if (is_EOL(ch)) {\n            _line = state.line;\n            _lineStart = state.lineStart;\n            _lineIndent = state.lineIndent;\n            skipSeparationSpace(state, false, -1);\n\n            if (state.lineIndent >= nodeIndent) {\n              hasPendingContent = true;\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            } else {\n              state.position = captureEnd;\n              state.line = _line;\n              state.lineStart = _lineStart;\n              state.lineIndent = _lineIndent;\n              break;\n            }\n          }\n\n          if (hasPendingContent) {\n            captureSegment(state, captureStart, captureEnd, false);\n            writeFoldedLines(state, state.line - _line);\n            captureStart = captureEnd = state.position;\n            hasPendingContent = false;\n          }\n\n          if (!is_WHITE_SPACE(ch)) {\n            captureEnd = state.position + 1;\n          }\n\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        captureSegment(state, captureStart, captureEnd, false);\n\n        if (state.result) {\n          return true;\n        }\n\n        state.kind = _kind;\n        state.result = _result;\n        return false;\n      }\n\n      function readSingleQuotedScalar(state, nodeIndent) {\n        var ch, captureStart, captureEnd;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x27\n        /* ' */\n        ) {\n            return false;\n          }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x27\n          /* ' */\n          ) {\n              captureSegment(state, captureStart, state.position, true);\n              ch = state.input.charCodeAt(++state.position);\n\n              if (ch === 0x27\n              /* ' */\n              ) {\n                  captureStart = state.position;\n                  state.position++;\n                  captureEnd = state.position;\n                } else {\n                return true;\n              }\n            } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a single quoted scalar');\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a single quoted scalar');\n      }\n\n      function readDoubleQuotedScalar(state, nodeIndent) {\n        var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x22\n        /* \" */\n        ) {\n            return false;\n          }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x22\n          /* \" */\n          ) {\n              captureSegment(state, captureStart, state.position, true);\n              state.position++;\n              return true;\n            } else if (ch === 0x5C\n          /* \\ */\n          ) {\n              captureSegment(state, captureStart, state.position, true);\n              ch = state.input.charCodeAt(++state.position);\n\n              if (is_EOL(ch)) {\n                skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?\n              } else if (ch < 256 && simpleEscapeCheck[ch]) {\n                state.result += simpleEscapeMap[ch];\n                state.position++;\n              } else if ((tmp = escapedHexLen(ch)) > 0) {\n                hexLength = tmp;\n                hexResult = 0;\n\n                for (; hexLength > 0; hexLength--) {\n                  ch = state.input.charCodeAt(++state.position);\n\n                  if ((tmp = fromHexCode(ch)) >= 0) {\n                    hexResult = (hexResult << 4) + tmp;\n                  } else {\n                    throwError(state, 'expected hexadecimal character');\n                  }\n                }\n\n                state.result += charFromCodepoint(hexResult);\n                state.position++;\n              } else {\n                throwError(state, 'unknown escape sequence');\n              }\n\n              captureStart = captureEnd = state.position;\n            } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a double quoted scalar');\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a double quoted scalar');\n      }\n\n      function readFlowCollection(state, nodeIndent) {\n        var readNext = true,\n            _line,\n            _tag = state.tag,\n            _result,\n            _anchor = state.anchor,\n            following,\n            terminator,\n            isPair,\n            isExplicitPair,\n            isMapping,\n            overridableKeys = {},\n            keyNode,\n            keyTag,\n            valueNode,\n            ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x5B\n        /* [ */\n        ) {\n            terminator = 0x5D;\n            /* ] */\n\n            isMapping = false;\n            _result = [];\n          } else if (ch === 0x7B\n        /* { */\n        ) {\n            terminator = 0x7D;\n            /* } */\n\n            isMapping = true;\n            _result = {};\n          } else {\n          return false;\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        while (ch !== 0) {\n          skipSeparationSpace(state, true, nodeIndent);\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === terminator) {\n            state.position++;\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = isMapping ? 'mapping' : 'sequence';\n            state.result = _result;\n            return true;\n          } else if (!readNext) {\n            throwError(state, 'missed comma between flow collection entries');\n          }\n\n          keyTag = keyNode = valueNode = null;\n          isPair = isExplicitPair = false;\n\n          if (ch === 0x3F\n          /* ? */\n          ) {\n              following = state.input.charCodeAt(state.position + 1);\n\n              if (is_WS_OR_EOL(following)) {\n                isPair = isExplicitPair = true;\n                state.position++;\n                skipSeparationSpace(state, true, nodeIndent);\n              }\n            }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n          keyTag = state.tag;\n          keyNode = state.result;\n          skipSeparationSpace(state, true, nodeIndent);\n          ch = state.input.charCodeAt(state.position);\n\n          if ((isExplicitPair || state.line === _line) && ch === 0x3A\n          /* : */\n          ) {\n              isPair = true;\n              ch = state.input.charCodeAt(++state.position);\n              skipSeparationSpace(state, true, nodeIndent);\n              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n              valueNode = state.result;\n            }\n\n          if (isMapping) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n          } else if (isPair) {\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n          } else {\n            _result.push(keyNode);\n          }\n\n          skipSeparationSpace(state, true, nodeIndent);\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === 0x2C\n          /* , */\n          ) {\n              readNext = true;\n              ch = state.input.charCodeAt(++state.position);\n            } else {\n            readNext = false;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a flow collection');\n      }\n\n      function readBlockScalar(state, nodeIndent) {\n        var captureStart,\n            folding,\n            chomping = CHOMPING_CLIP,\n            didReadContent = false,\n            detectedIndent = false,\n            textIndent = nodeIndent,\n            emptyLines = 0,\n            atMoreIndented = false,\n            tmp,\n            ch;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x7C\n        /* | */\n        ) {\n            folding = false;\n          } else if (ch === 0x3E\n        /* > */\n        ) {\n            folding = true;\n          } else {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n\n        while (ch !== 0) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (ch === 0x2B\n          /* + */\n          || ch === 0x2D\n          /* - */\n          ) {\n              if (CHOMPING_CLIP === chomping) {\n                chomping = ch === 0x2B\n                /* + */\n                ? CHOMPING_KEEP : CHOMPING_STRIP;\n              } else {\n                throwError(state, 'repeat of a chomping mode identifier');\n              }\n            } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n            if (tmp === 0) {\n              throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n            } else if (!detectedIndent) {\n              textIndent = nodeIndent + tmp - 1;\n              detectedIndent = true;\n            } else {\n              throwError(state, 'repeat of an indentation width identifier');\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (is_WHITE_SPACE(ch)) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (is_WHITE_SPACE(ch));\n\n          if (ch === 0x23\n          /* # */\n          ) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (!is_EOL(ch) && ch !== 0);\n            }\n        }\n\n        while (ch !== 0) {\n          readLineBreak(state);\n          state.lineIndent = 0;\n          ch = state.input.charCodeAt(state.position);\n\n          while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20\n          /* Space */\n          ) {\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (!detectedIndent && state.lineIndent > textIndent) {\n            textIndent = state.lineIndent;\n          }\n\n          if (is_EOL(ch)) {\n            emptyLines++;\n            continue;\n          } // End of the scalar.\n\n\n          if (state.lineIndent < textIndent) {\n            // Perform the chomping.\n            if (chomping === CHOMPING_KEEP) {\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n            } else if (chomping === CHOMPING_CLIP) {\n              if (didReadContent) {\n                // i.e. only if the scalar is not empty.\n                state.result += '\\n';\n              }\n            } // Break this `while` cycle and go to the funciton's epilogue.\n\n\n            break;\n          } // Folded style: use fancy rules to handle line breaks.\n\n\n          if (folding) {\n            // Lines starting with white space characters (more-indented lines) are not folded.\n            if (is_WHITE_SPACE(ch)) {\n              atMoreIndented = true; // except for the first content line (cf. Example 8.1)\n\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.\n            } else if (atMoreIndented) {\n              atMoreIndented = false;\n              state.result += common.repeat('\\n', emptyLines + 1); // Just one line break - perceive as the same line.\n            } else if (emptyLines === 0) {\n              if (didReadContent) {\n                // i.e. only if we have already read some scalar content.\n                state.result += ' ';\n              } // Several line breaks - perceive as different lines.\n\n            } else {\n              state.result += common.repeat('\\n', emptyLines);\n            } // Literal style: just add exact number of line breaks between content lines.\n\n          } else {\n            // Keep all line breaks except the header line break.\n            state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n          }\n\n          didReadContent = true;\n          detectedIndent = true;\n          emptyLines = 0;\n          captureStart = state.position;\n\n          while (!is_EOL(ch) && ch !== 0) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          captureSegment(state, captureStart, state.position, false);\n        }\n\n        return true;\n      }\n\n      function readBlockSequence(state, nodeIndent) {\n        var _line,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = [],\n            following,\n            detected = false,\n            ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          if (ch !== 0x2D\n          /* - */\n          ) {\n              break;\n            }\n\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (!is_WS_OR_EOL(following)) {\n            break;\n          }\n\n          detected = true;\n          state.position++;\n\n          if (skipSeparationSpace(state, true, -1)) {\n            if (state.lineIndent <= nodeIndent) {\n              _result.push(null);\n\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n\n          _result.push(state.result);\n\n          skipSeparationSpace(state, true, -1);\n          ch = state.input.charCodeAt(state.position);\n\n          if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n            throwError(state, 'bad indentation of a sequence entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        }\n\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'sequence';\n          state.result = _result;\n          return true;\n        }\n\n        return false;\n      }\n\n      function readBlockMapping(state, nodeIndent, flowIndent) {\n        var following,\n            allowCompact,\n            _line,\n            _pos,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = {},\n            overridableKeys = {},\n            keyTag = null,\n            keyNode = null,\n            valueNode = null,\n            atExplicitKey = false,\n            detected = false,\n            ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          following = state.input.charCodeAt(state.position + 1);\n          _line = state.line; // Save the current line.\n\n          _pos = state.position; //\n          // Explicit notation case. There are two separate blocks:\n          // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n          //\n\n          if ((ch === 0x3F\n          /* ? */\n          || ch === 0x3A\n          /* : */\n          ) && is_WS_OR_EOL(following)) {\n            if (ch === 0x3F\n            /* ? */\n            ) {\n                if (atExplicitKey) {\n                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                  keyTag = keyNode = valueNode = null;\n                }\n\n                detected = true;\n                atExplicitKey = true;\n                allowCompact = true;\n              } else if (atExplicitKey) {\n              // i.e. 0x3A/* : */ === character after the explicit key.\n              atExplicitKey = false;\n              allowCompact = true;\n            } else {\n              throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n            }\n\n            state.position += 1;\n            ch = following; //\n            // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n            //\n          } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n            if (state.line === _line) {\n              ch = state.input.charCodeAt(state.position);\n\n              while (is_WHITE_SPACE(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n\n              if (ch === 0x3A\n              /* : */\n              ) {\n                  ch = state.input.charCodeAt(++state.position);\n\n                  if (!is_WS_OR_EOL(ch)) {\n                    throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n                  }\n\n                  if (atExplicitKey) {\n                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                    keyTag = keyNode = valueNode = null;\n                  }\n\n                  detected = true;\n                  atExplicitKey = false;\n                  allowCompact = false;\n                  keyTag = state.tag;\n                  keyNode = state.result;\n                } else if (detected) {\n                throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n              } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n              }\n            } else if (detected) {\n              throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n            } else {\n              state.tag = _tag;\n              state.anchor = _anchor;\n              return true; // Keep the result of `composeNode`.\n            }\n          } else {\n              break; // Reading is done. Go to the epilogue.\n            } //\n          // Common reading code for both explicit and implicit notations.\n          //\n\n\n          if (state.line === _line || state.lineIndent > nodeIndent) {\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n              if (atExplicitKey) {\n                keyNode = state.result;\n              } else {\n                valueNode = state.result;\n              }\n            }\n\n            if (!atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n          }\n\n          if (state.lineIndent > nodeIndent && ch !== 0) {\n            throwError(state, 'bad indentation of a mapping entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        } //\n        // Epilogue.\n        //\n        // Special case: last mapping's node contains only the key in explicit notation.\n\n\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n        } // Expose the resulting mapping.\n\n\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'mapping';\n          state.result = _result;\n        }\n\n        return detected;\n      }\n\n      function readTagProperty(state) {\n        var _position,\n            isVerbatim = false,\n            isNamed = false,\n            tagHandle,\n            tagName,\n            ch;\n\n        ch = state.input.charCodeAt(state.position);\n        if (ch !== 0x21\n        /* ! */\n        ) return false;\n\n        if (state.tag !== null) {\n          throwError(state, 'duplication of a tag property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x3C\n        /* < */\n        ) {\n            isVerbatim = true;\n            ch = state.input.charCodeAt(++state.position);\n          } else if (ch === 0x21\n        /* ! */\n        ) {\n            isNamed = true;\n            tagHandle = '!!';\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n          tagHandle = '!';\n        }\n\n        _position = state.position;\n\n        if (isVerbatim) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 0 && ch !== 0x3E\n          /* > */\n          );\n\n          if (state.position < state.length) {\n            tagName = state.input.slice(_position, state.position);\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            throwError(state, 'unexpected end of the stream within a verbatim tag');\n          }\n        } else {\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            if (ch === 0x21\n            /* ! */\n            ) {\n                if (!isNamed) {\n                  tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                    throwError(state, 'named tag handle cannot contain such characters');\n                  }\n\n                  isNamed = true;\n                  _position = state.position + 1;\n                } else {\n                  throwError(state, 'tag suffix cannot contain exclamation marks');\n                }\n              }\n\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          tagName = state.input.slice(_position, state.position);\n\n          if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n            throwError(state, 'tag suffix cannot contain flow indicator characters');\n          }\n        }\n\n        if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n          throwError(state, 'tag name cannot contain such characters: ' + tagName);\n        }\n\n        if (isVerbatim) {\n          state.tag = tagName;\n        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n          state.tag = state.tagMap[tagHandle] + tagName;\n        } else if (tagHandle === '!') {\n          state.tag = '!' + tagName;\n        } else if (tagHandle === '!!') {\n          state.tag = 'tag:yaml.org,2002:' + tagName;\n        } else {\n          throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n        }\n\n        return true;\n      }\n\n      function readAnchorProperty(state) {\n        var _position, ch;\n\n        ch = state.input.charCodeAt(state.position);\n        if (ch !== 0x26\n        /* & */\n        ) return false;\n\n        if (state.anchor !== null) {\n          throwError(state, 'duplication of an anchor property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an anchor node must contain at least one character');\n        }\n\n        state.anchor = state.input.slice(_position, state.position);\n        return true;\n      }\n\n      function readAlias(state) {\n        var _position, alias, ch;\n\n        ch = state.input.charCodeAt(state.position);\n        if (ch !== 0x2A\n        /* * */\n        ) return false;\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an alias node must contain at least one character');\n        }\n\n        alias = state.input.slice(_position, state.position);\n\n        if (!state.anchorMap.hasOwnProperty(alias)) {\n          throwError(state, 'unidentified alias \"' + alias + '\"');\n        }\n\n        state.result = state.anchorMap[alias];\n        skipSeparationSpace(state, true, -1);\n        return true;\n      }\n\n      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n        var allowBlockStyles,\n            allowBlockScalars,\n            allowBlockCollections,\n            indentStatus = 1,\n            // 1: this>parent, 0: this=parent, -1: this<parent\n        atNewLine = false,\n            hasContent = false,\n            typeIndex,\n            typeQuantity,\n            type,\n            flowIndent,\n            blockIndent;\n\n        if (state.listener !== null) {\n          state.listener('open', state);\n        }\n\n        state.tag = null;\n        state.anchor = null;\n        state.kind = null;\n        state.result = null;\n        allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n\n        if (allowToSeek) {\n          if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n\n            if (state.lineIndent > parentIndent) {\n              indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n              indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n              indentStatus = -1;\n            }\n          }\n        }\n\n        if (indentStatus === 1) {\n          while (readTagProperty(state) || readAnchorProperty(state)) {\n            if (skipSeparationSpace(state, true, -1)) {\n              atNewLine = true;\n              allowBlockCollections = allowBlockStyles;\n\n              if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n              } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n              } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n              }\n            } else {\n              allowBlockCollections = false;\n            }\n          }\n        }\n\n        if (allowBlockCollections) {\n          allowBlockCollections = atNewLine || allowCompact;\n        }\n\n        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n            flowIndent = parentIndent;\n          } else {\n            flowIndent = parentIndent + 1;\n          }\n\n          blockIndent = state.position - state.lineStart;\n\n          if (indentStatus === 1) {\n            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n              hasContent = true;\n            } else {\n              if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n                hasContent = true;\n              } else if (readAlias(state)) {\n                hasContent = true;\n\n                if (state.tag !== null || state.anchor !== null) {\n                  throwError(state, 'alias node should not have any properties');\n                }\n              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                hasContent = true;\n\n                if (state.tag === null) {\n                  state.tag = '?';\n                }\n              }\n\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else if (indentStatus === 0) {\n            // Special case: block sequences are allowed to have same indentation level as the parent.\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n          }\n        }\n\n        if (state.tag !== null && state.tag !== '!') {\n          if (state.tag === '?') {\n            // Implicit resolving is not allowed for non-scalar types, and '?'\n            // non-specific tag is only automatically assigned to plain scalars.\n            //\n            // We only need to check kind conformity in case user explicitly assigns '?'\n            // tag, for example like this: \"!<?> [0]\"\n            //\n            if (state.result !== null && state.kind !== 'scalar') {\n              throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n            }\n\n            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n              type = state.implicitTypes[typeIndex];\n\n              if (type.resolve(state.result)) {\n                // `state.result` updated in resolver if matched\n                state.result = type.construct(state.result);\n                state.tag = type.tag;\n\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n\n                break;\n              }\n            }\n          } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n            type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n            if (state.result !== null && type.kind !== state.kind) {\n              throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n            }\n\n            if (!type.resolve(state.result)) {\n              // `state.result` updated in resolver if matched\n              throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n            } else {\n              state.result = type.construct(state.result);\n\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else {\n            throwError(state, 'unknown tag !<' + state.tag + '>');\n          }\n        }\n\n        if (state.listener !== null) {\n          state.listener('close', state);\n        }\n\n        return state.tag !== null || state.anchor !== null || hasContent;\n      }\n\n      function readDocument(state) {\n        var documentStart = state.position,\n            _position,\n            directiveName,\n            directiveArgs,\n            hasDirectives = false,\n            ch;\n\n        state.version = null;\n        state.checkLineBreaks = state.legacy;\n        state.tagMap = {};\n        state.anchorMap = {};\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          skipSeparationSpace(state, true, -1);\n          ch = state.input.charCodeAt(state.position);\n\n          if (state.lineIndent > 0 || ch !== 0x25\n          /* % */\n          ) {\n              break;\n            }\n\n          hasDirectives = true;\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          directiveName = state.input.slice(_position, state.position);\n          directiveArgs = [];\n\n          if (directiveName.length < 1) {\n            throwError(state, 'directive name must not be less than one character in length');\n          }\n\n          while (ch !== 0) {\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            if (ch === 0x23\n            /* # */\n            ) {\n                do {\n                  ch = state.input.charCodeAt(++state.position);\n                } while (ch !== 0 && !is_EOL(ch));\n\n                break;\n              }\n\n            if (is_EOL(ch)) break;\n            _position = state.position;\n\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            directiveArgs.push(state.input.slice(_position, state.position));\n          }\n\n          if (ch !== 0) readLineBreak(state);\n\n          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\n          } else {\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n          }\n        }\n\n        skipSeparationSpace(state, true, -1);\n\n        if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D\n        /* - */\n        && state.input.charCodeAt(state.position + 1) === 0x2D\n        /* - */\n        && state.input.charCodeAt(state.position + 2) === 0x2D\n        /* - */\n        ) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n          } else if (hasDirectives) {\n          throwError(state, 'directives end mark is expected');\n        }\n\n        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n        skipSeparationSpace(state, true, -1);\n\n        if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n          throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n        }\n\n        state.documents.push(state.result);\n\n        if (state.position === state.lineStart && testDocumentSeparator(state)) {\n          if (state.input.charCodeAt(state.position) === 0x2E\n          /* . */\n          ) {\n              state.position += 3;\n              skipSeparationSpace(state, true, -1);\n            }\n\n          return;\n        }\n\n        if (state.position < state.length - 1) {\n          throwError(state, 'end of the stream or a document separator is expected');\n        } else {\n          return;\n        }\n      }\n\n      function loadDocuments(input, options) {\n        input = String(input);\n        options = options || {};\n\n        if (input.length !== 0) {\n          // Add tailing `\\n` if not exists\n          if (input.charCodeAt(input.length - 1) !== 0x0A\n          /* LF */\n          && input.charCodeAt(input.length - 1) !== 0x0D\n          /* CR */\n          ) {\n              input += '\\n';\n            } // Strip BOM\n\n\n          if (input.charCodeAt(0) === 0xFEFF) {\n            input = input.slice(1);\n          }\n        }\n\n        var state = new State(input, options);\n        var nullpos = input.indexOf('\\0');\n\n        if (nullpos !== -1) {\n          state.position = nullpos;\n          throwError(state, 'null byte is not allowed in input');\n        } // Use 0 as string terminator. That significantly simplifies bounds check.\n\n\n        state.input += '\\0';\n\n        while (state.input.charCodeAt(state.position) === 0x20\n        /* Space */\n        ) {\n          state.lineIndent += 1;\n          state.position += 1;\n        }\n\n        while (state.position < state.length - 1) {\n          readDocument(state);\n        }\n\n        return state.documents;\n      }\n\n      function loadAll(input, iterator, options) {\n        if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        var documents = loadDocuments(input, options);\n\n        if (typeof iterator !== 'function') {\n          return documents;\n        }\n\n        for (var index = 0, length = documents.length; index < length; index += 1) {\n          iterator(documents[index]);\n        }\n      }\n\n      function load(input, options) {\n        var documents = loadDocuments(input, options);\n\n        if (documents.length === 0) {\n          /*eslint-disable no-undefined*/\n          return undefined;\n        } else if (documents.length === 1) {\n          return documents[0];\n        }\n\n        throw new YAMLException('expected a single document in the stream, but found more');\n      }\n\n      function safeLoadAll(input, iterator, options) {\n        if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        return loadAll(input, iterator, common.extend({\n          schema: DEFAULT_SAFE_SCHEMA\n        }, options));\n      }\n\n      function safeLoad(input, options) {\n        return load(input, common.extend({\n          schema: DEFAULT_SAFE_SCHEMA\n        }, options));\n      }\n\n      module.exports.loadAll = loadAll;\n      module.exports.load = load;\n      module.exports.safeLoadAll = safeLoadAll;\n      module.exports.safeLoad = safeLoad;\n    }, {\n      \"./common\": 2,\n      \"./exception\": 4,\n      \"./mark\": 6,\n      \"./schema/default_full\": 9,\n      \"./schema/default_safe\": 10\n    }],\n    6: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('./common');\n\n      function Mark(name, buffer, position, line, column) {\n        this.name = name;\n        this.buffer = buffer;\n        this.position = position;\n        this.line = line;\n        this.column = column;\n      }\n\n      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n        var head, start, tail, end, snippet;\n        if (!this.buffer) return null;\n        indent = indent || 4;\n        maxLength = maxLength || 75;\n        head = '';\n        start = this.position;\n\n        while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n          start -= 1;\n\n          if (this.position - start > maxLength / 2 - 1) {\n            head = ' ... ';\n            start += 5;\n            break;\n          }\n        }\n\n        tail = '';\n        end = this.position;\n\n        while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n          end += 1;\n\n          if (end - this.position > maxLength / 2 - 1) {\n            tail = ' ... ';\n            end -= 5;\n            break;\n          }\n        }\n\n        snippet = this.buffer.slice(start, end);\n        return common.repeat(' ', indent) + head + snippet + tail + '\\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';\n      };\n\n      Mark.prototype.toString = function toString(compact) {\n        var snippet,\n            where = '';\n\n        if (this.name) {\n          where += 'in \"' + this.name + '\" ';\n        }\n\n        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n        if (!compact) {\n          snippet = this.getSnippet();\n\n          if (snippet) {\n            where += ':\\n' + snippet;\n          }\n        }\n\n        return where;\n      };\n\n      module.exports = Mark;\n    }, {\n      \"./common\": 2\n    }],\n    7: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable max-len*/\n\n      var common = require('./common');\n\n      var YAMLException = require('./exception');\n\n      var Type = require('./type');\n\n      function compileList(schema, name, result) {\n        var exclude = [];\n        schema.include.forEach(function (includedSchema) {\n          result = compileList(includedSchema, name, result);\n        });\n        schema[name].forEach(function (currentType) {\n          result.forEach(function (previousType, previousIndex) {\n            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n              exclude.push(previousIndex);\n            }\n          });\n          result.push(currentType);\n        });\n        return result.filter(function (type, index) {\n          return exclude.indexOf(index) === -1;\n        });\n      }\n\n      function compileMap()\n      /* lists... */\n      {\n        var result = {\n          scalar: {},\n          sequence: {},\n          mapping: {},\n          fallback: {}\n        },\n            index,\n            length;\n\n        function collectType(type) {\n          result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n        }\n\n        for (index = 0, length = arguments.length; index < length; index += 1) {\n          arguments[index].forEach(collectType);\n        }\n\n        return result;\n      }\n\n      function Schema(definition) {\n        this.include = definition.include || [];\n        this.implicit = definition.implicit || [];\n        this.explicit = definition.explicit || [];\n        this.implicit.forEach(function (type) {\n          if (type.loadKind && type.loadKind !== 'scalar') {\n            throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n          }\n        });\n        this.compiledImplicit = compileList(this, 'implicit', []);\n        this.compiledExplicit = compileList(this, 'explicit', []);\n        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n      }\n\n      Schema.DEFAULT = null;\n\n      Schema.create = function createSchema() {\n        var schemas, types;\n\n        switch (arguments.length) {\n          case 1:\n            schemas = Schema.DEFAULT;\n            types = arguments[0];\n            break;\n\n          case 2:\n            schemas = arguments[0];\n            types = arguments[1];\n            break;\n\n          default:\n            throw new YAMLException('Wrong number of arguments for Schema.create function');\n        }\n\n        schemas = common.toArray(schemas);\n        types = common.toArray(types);\n\n        if (!schemas.every(function (schema) {\n          return schema instanceof Schema;\n        })) {\n          throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n        }\n\n        if (!types.every(function (type) {\n          return type instanceof Type;\n        })) {\n          throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n        }\n\n        return new Schema({\n          include: schemas,\n          explicit: types\n        });\n      };\n\n      module.exports = Schema;\n    }, {\n      \"./common\": 2,\n      \"./exception\": 4,\n      \"./type\": 13\n    }],\n    8: [function (require, module, exports) {\n      // Standard YAML's Core schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2804923\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, Core schema has no distinctions from JSON schema is JS-YAML.\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        include: [require('./json')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"./json\": 12\n    }],\n    9: [function (require, module, exports) {\n      // JS-YAML's default schema for `load` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on JS-YAML's default safe schema and includes\n      // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n      //\n      // Also this schema is used as default base schema at `Schema.create` function.\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = Schema.DEFAULT = new Schema({\n        include: [require('./default_safe')],\n        explicit: [require('../type/js/undefined'), require('../type/js/regexp'), require('../type/js/function')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/js/function\": 18,\n      \"../type/js/regexp\": 19,\n      \"../type/js/undefined\": 20,\n      \"./default_safe\": 10\n    }],\n    10: [function (require, module, exports) {\n      // JS-YAML's default schema for `safeLoad` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on standard YAML's Core schema and includes most of\n      // extra types described at YAML tag repository. (http://yaml.org/type/)\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        include: [require('./core')],\n        implicit: [require('../type/timestamp'), require('../type/merge')],\n        explicit: [require('../type/binary'), require('../type/omap'), require('../type/pairs'), require('../type/set')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/binary\": 14,\n      \"../type/merge\": 22,\n      \"../type/omap\": 24,\n      \"../type/pairs\": 25,\n      \"../type/set\": 27,\n      \"../type/timestamp\": 29,\n      \"./core\": 8\n    }],\n    11: [function (require, module, exports) {\n      // Standard YAML's Failsafe schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2802346\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        explicit: [require('../type/str'), require('../type/seq'), require('../type/map')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/map\": 21,\n      \"../type/seq\": 26,\n      \"../type/str\": 28\n    }],\n    12: [function (require, module, exports) {\n      // Standard YAML's JSON schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2803231\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, this schema is not such strict as defined in the YAML specification.\n      // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        include: [require('./failsafe')],\n        implicit: [require('../type/null'), require('../type/bool'), require('../type/int'), require('../type/float')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/bool\": 15,\n      \"../type/float\": 16,\n      \"../type/int\": 17,\n      \"../type/null\": 23,\n      \"./failsafe\": 11\n    }],\n    13: [function (require, module, exports) {\n      'use strict';\n\n      var YAMLException = require('./exception');\n\n      var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];\n      var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n\n      function compileStyleAliases(map) {\n        var result = {};\n\n        if (map !== null) {\n          Object.keys(map).forEach(function (style) {\n            map[style].forEach(function (alias) {\n              result[String(alias)] = style;\n            });\n          });\n        }\n\n        return result;\n      }\n\n      function Type(tag, options) {\n        options = options || {};\n        Object.keys(options).forEach(function (name) {\n          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n            throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n          }\n        }); // TODO: Add tag format check.\n\n        this.tag = tag;\n        this.kind = options['kind'] || null;\n\n        this.resolve = options['resolve'] || function () {\n          return true;\n        };\n\n        this.construct = options['construct'] || function (data) {\n          return data;\n        };\n\n        this.instanceOf = options['instanceOf'] || null;\n        this.predicate = options['predicate'] || null;\n        this.represent = options['represent'] || null;\n        this.defaultStyle = options['defaultStyle'] || null;\n        this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n          throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n        }\n      }\n\n      module.exports = Type;\n    }, {\n      \"./exception\": 4\n    }],\n    14: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable no-bitwise*/\n\n      var NodeBuffer;\n\n      try {\n        // A trick for browserified version, to not include `Buffer` shim\n        var _require = require;\n        NodeBuffer = _require('buffer').Buffer;\n      } catch (__) {}\n\n      var Type = require('../type'); // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\n\n      var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n      function resolveYamlBinary(data) {\n        if (data === null) return false;\n        var code,\n            idx,\n            bitlen = 0,\n            max = data.length,\n            map = BASE64_MAP; // Convert one by one.\n\n        for (idx = 0; idx < max; idx++) {\n          code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n          if (code > 64) continue; // Fail on illegal characters\n\n          if (code < 0) return false;\n          bitlen += 6;\n        } // If there are any bits left, source was corrupted\n\n\n        return bitlen % 8 === 0;\n      }\n\n      function constructYamlBinary(data) {\n        var idx,\n            tailbits,\n            input = data.replace(/[\\r\\n=]/g, ''),\n            // remove CR/LF & padding to simplify scan\n        max = input.length,\n            map = BASE64_MAP,\n            bits = 0,\n            result = []; // Collect by 6*4 bits (3 bytes)\n\n        for (idx = 0; idx < max; idx++) {\n          if (idx % 4 === 0 && idx) {\n            result.push(bits >> 16 & 0xFF);\n            result.push(bits >> 8 & 0xFF);\n            result.push(bits & 0xFF);\n          }\n\n          bits = bits << 6 | map.indexOf(input.charAt(idx));\n        } // Dump tail\n\n\n        tailbits = max % 4 * 6;\n\n        if (tailbits === 0) {\n          result.push(bits >> 16 & 0xFF);\n          result.push(bits >> 8 & 0xFF);\n          result.push(bits & 0xFF);\n        } else if (tailbits === 18) {\n          result.push(bits >> 10 & 0xFF);\n          result.push(bits >> 2 & 0xFF);\n        } else if (tailbits === 12) {\n          result.push(bits >> 4 & 0xFF);\n        } // Wrap into Buffer for NodeJS and leave Array for browser\n\n\n        if (NodeBuffer) {\n          // Support node 6.+ Buffer API when available\n          return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n        }\n\n        return result;\n      }\n\n      function representYamlBinary(object\n      /*, style*/\n      ) {\n        var result = '',\n            bits = 0,\n            idx,\n            tail,\n            max = object.length,\n            map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n        for (idx = 0; idx < max; idx++) {\n          if (idx % 3 === 0 && idx) {\n            result += map[bits >> 18 & 0x3F];\n            result += map[bits >> 12 & 0x3F];\n            result += map[bits >> 6 & 0x3F];\n            result += map[bits & 0x3F];\n          }\n\n          bits = (bits << 8) + object[idx];\n        } // Dump tail\n\n\n        tail = max % 3;\n\n        if (tail === 0) {\n          result += map[bits >> 18 & 0x3F];\n          result += map[bits >> 12 & 0x3F];\n          result += map[bits >> 6 & 0x3F];\n          result += map[bits & 0x3F];\n        } else if (tail === 2) {\n          result += map[bits >> 10 & 0x3F];\n          result += map[bits >> 4 & 0x3F];\n          result += map[bits << 2 & 0x3F];\n          result += map[64];\n        } else if (tail === 1) {\n          result += map[bits >> 2 & 0x3F];\n          result += map[bits << 4 & 0x3F];\n          result += map[64];\n          result += map[64];\n        }\n\n        return result;\n      }\n\n      function isBinary(object) {\n        return NodeBuffer && NodeBuffer.isBuffer(object);\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:binary', {\n        kind: 'scalar',\n        resolve: resolveYamlBinary,\n        construct: constructYamlBinary,\n        predicate: isBinary,\n        represent: representYamlBinary\n      });\n    }, {\n      \"../type\": 13\n    }],\n    15: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlBoolean(data) {\n        if (data === null) return false;\n        var max = data.length;\n        return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n      }\n\n      function constructYamlBoolean(data) {\n        return data === 'true' || data === 'True' || data === 'TRUE';\n      }\n\n      function isBoolean(object) {\n        return Object.prototype.toString.call(object) === '[object Boolean]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:bool', {\n        kind: 'scalar',\n        resolve: resolveYamlBoolean,\n        construct: constructYamlBoolean,\n        predicate: isBoolean,\n        represent: {\n          lowercase: function (object) {\n            return object ? 'true' : 'false';\n          },\n          uppercase: function (object) {\n            return object ? 'TRUE' : 'FALSE';\n          },\n          camelcase: function (object) {\n            return object ? 'True' : 'False';\n          }\n        },\n        defaultStyle: 'lowercase'\n      });\n    }, {\n      \"../type\": 13\n    }],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n\n      var Type = require('../type');\n\n      var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers\n      '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2\n      // special case, seems not from spec\n      '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59\n      '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' + // .inf\n      '|[-+]?\\\\.(?:inf|Inf|INF)' + // .nan\n      '|\\\\.(?:nan|NaN|NAN))$');\n\n      function resolveYamlFloat(data) {\n        if (data === null) return false;\n\n        if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n        // Probably should update regexp & check speed\n        data[data.length - 1] === '_') {\n          return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlFloat(data) {\n        var value, sign, base, digits;\n        value = data.replace(/_/g, '').toLowerCase();\n        sign = value[0] === '-' ? -1 : 1;\n        digits = [];\n\n        if ('+-'.indexOf(value[0]) >= 0) {\n          value = value.slice(1);\n        }\n\n        if (value === '.inf') {\n          return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n        } else if (value === '.nan') {\n          return NaN;\n        } else if (value.indexOf(':') >= 0) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseFloat(v, 10));\n          });\n          value = 0.0;\n          base = 1;\n          digits.forEach(function (d) {\n            value += d * base;\n            base *= 60;\n          });\n          return sign * value;\n        }\n\n        return sign * parseFloat(value, 10);\n      }\n\n      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\n      function representYamlFloat(object, style) {\n        var res;\n\n        if (isNaN(object)) {\n          switch (style) {\n            case 'lowercase':\n              return '.nan';\n\n            case 'uppercase':\n              return '.NAN';\n\n            case 'camelcase':\n              return '.NaN';\n          }\n        } else if (Number.POSITIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase':\n              return '.inf';\n\n            case 'uppercase':\n              return '.INF';\n\n            case 'camelcase':\n              return '.Inf';\n          }\n        } else if (Number.NEGATIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase':\n              return '-.inf';\n\n            case 'uppercase':\n              return '-.INF';\n\n            case 'camelcase':\n              return '-.Inf';\n          }\n        } else if (common.isNegativeZero(object)) {\n          return '-0.0';\n        }\n\n        res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,\n        // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n      }\n\n      function isFloat(object) {\n        return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:float', {\n        kind: 'scalar',\n        resolve: resolveYamlFloat,\n        construct: constructYamlFloat,\n        predicate: isFloat,\n        represent: representYamlFloat,\n        defaultStyle: 'lowercase'\n      });\n    }, {\n      \"../common\": 2,\n      \"../type\": 13\n    }],\n    17: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n\n      var Type = require('../type');\n\n      function isHexCode(c) {\n        return 0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        || 0x41\n        /* A */\n        <= c && c <= 0x46\n        /* F */\n        || 0x61\n        /* a */\n        <= c && c <= 0x66\n        /* f */\n        ;\n      }\n\n      function isOctCode(c) {\n        return 0x30\n        /* 0 */\n        <= c && c <= 0x37\n        /* 7 */\n        ;\n      }\n\n      function isDecCode(c) {\n        return 0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        ;\n      }\n\n      function resolveYamlInteger(data) {\n        if (data === null) return false;\n        var max = data.length,\n            index = 0,\n            hasDigits = false,\n            ch;\n        if (!max) return false;\n        ch = data[index]; // sign\n\n        if (ch === '-' || ch === '+') {\n          ch = data[++index];\n        }\n\n        if (ch === '0') {\n          // 0\n          if (index + 1 === max) return true;\n          ch = data[++index]; // base 2, base 8, base 16\n\n          if (ch === 'b') {\n            // base 2\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (ch !== '0' && ch !== '1') return false;\n              hasDigits = true;\n            }\n\n            return hasDigits && ch !== '_';\n          }\n\n          if (ch === 'x') {\n            // base 16\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (!isHexCode(data.charCodeAt(index))) return false;\n              hasDigits = true;\n            }\n\n            return hasDigits && ch !== '_';\n          } // base 8\n\n\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === '_') continue;\n            if (!isOctCode(data.charCodeAt(index))) return false;\n            hasDigits = true;\n          }\n\n          return hasDigits && ch !== '_';\n        } // base 10 (except 0) or base 60\n        // value should not start with `_`;\n\n\n        if (ch === '_') return false;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch === ':') break;\n\n          if (!isDecCode(data.charCodeAt(index))) {\n            return false;\n          }\n\n          hasDigits = true;\n        } // Should have digits and should not end with `_`\n\n\n        if (!hasDigits || ch === '_') return false; // if !base60 - done;\n\n        if (ch !== ':') return true; // base60 almost not used, no needs to optimize\n\n        return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n      }\n\n      function constructYamlInteger(data) {\n        var value = data,\n            sign = 1,\n            ch,\n            base,\n            digits = [];\n\n        if (value.indexOf('_') !== -1) {\n          value = value.replace(/_/g, '');\n        }\n\n        ch = value[0];\n\n        if (ch === '-' || ch === '+') {\n          if (ch === '-') sign = -1;\n          value = value.slice(1);\n          ch = value[0];\n        }\n\n        if (value === '0') return 0;\n\n        if (ch === '0') {\n          if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n          if (value[1] === 'x') return sign * parseInt(value, 16);\n          return sign * parseInt(value, 8);\n        }\n\n        if (value.indexOf(':') !== -1) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseInt(v, 10));\n          });\n          value = 0;\n          base = 1;\n          digits.forEach(function (d) {\n            value += d * base;\n            base *= 60;\n          });\n          return sign * value;\n        }\n\n        return sign * parseInt(value, 10);\n      }\n\n      function isInteger(object) {\n        return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:int', {\n        kind: 'scalar',\n        resolve: resolveYamlInteger,\n        construct: constructYamlInteger,\n        predicate: isInteger,\n        represent: {\n          binary: function (obj) {\n            return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n          },\n          octal: function (obj) {\n            return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);\n          },\n          decimal: function (obj) {\n            return obj.toString(10);\n          },\n\n          /* eslint-disable max-len */\n          hexadecimal: function (obj) {\n            return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n          }\n        },\n        defaultStyle: 'decimal',\n        styleAliases: {\n          binary: [2, 'bin'],\n          octal: [8, 'oct'],\n          decimal: [10, 'dec'],\n          hexadecimal: [16, 'hex']\n        }\n      });\n    }, {\n      \"../common\": 2,\n      \"../type\": 13\n    }],\n    18: [function (require, module, exports) {\n      'use strict';\n\n      var esprima; // Browserified version does not have esprima\n      //\n      // 1. For node.js just require module as deps\n      // 2. For browser try to require mudule via external AMD system.\n      //    If not found - try to fallback to window.esprima. If not\n      //    found too - then fail to parse.\n      //\n\n      try {\n        // workaround to exclude package from browserify list.\n        var _require = require;\n        esprima = _require('esprima');\n      } catch (_) {\n        /* eslint-disable no-redeclare */\n\n        /* global window */\n        if (typeof window !== 'undefined') esprima = window.esprima;\n      }\n\n      var Type = require('../../type');\n\n      function resolveJavascriptFunction(data) {\n        if (data === null) return false;\n\n        try {\n          var source = '(' + data + ')',\n              ast = esprima.parse(source, {\n            range: true\n          });\n\n          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n            return false;\n          }\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      }\n\n      function constructJavascriptFunction(data) {\n        /*jslint evil:true*/\n        var source = '(' + data + ')',\n            ast = esprima.parse(source, {\n          range: true\n        }),\n            params = [],\n            body;\n\n        if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n          throw new Error('Failed to resolve function');\n        }\n\n        ast.body[0].expression.params.forEach(function (param) {\n          params.push(param.name);\n        });\n        body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on\n        // function expressions. So cut them out.\n\n        if (ast.body[0].expression.body.type === 'BlockStatement') {\n          /*eslint-disable no-new-func*/\n          return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n        } // ES6 arrow functions can omit the BlockStatement. In that case, just return\n        // the body.\n\n        /*eslint-disable no-new-func*/\n\n\n        return new Function(params, 'return ' + source.slice(body[0], body[1]));\n      }\n\n      function representJavascriptFunction(object\n      /*, style*/\n      ) {\n        return object.toString();\n      }\n\n      function isFunction(object) {\n        return Object.prototype.toString.call(object) === '[object Function]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/function', {\n        kind: 'scalar',\n        resolve: resolveJavascriptFunction,\n        construct: constructJavascriptFunction,\n        predicate: isFunction,\n        represent: representJavascriptFunction\n      });\n    }, {\n      \"../../type\": 13\n    }],\n    19: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptRegExp(data) {\n        if (data === null) return false;\n        if (data.length === 0) return false;\n        var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed\n        // `/foo/gim` - modifiers tail can be maximum 3 chars\n\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n          if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated\n\n          if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n        }\n\n        return true;\n      }\n\n      function constructJavascriptRegExp(data) {\n        var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars\n\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n          regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n        }\n\n        return new RegExp(regexp, modifiers);\n      }\n\n      function representJavascriptRegExp(object\n      /*, style*/\n      ) {\n        var result = '/' + object.source + '/';\n        if (object.global) result += 'g';\n        if (object.multiline) result += 'm';\n        if (object.ignoreCase) result += 'i';\n        return result;\n      }\n\n      function isRegExp(object) {\n        return Object.prototype.toString.call(object) === '[object RegExp]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/regexp', {\n        kind: 'scalar',\n        resolve: resolveJavascriptRegExp,\n        construct: constructJavascriptRegExp,\n        predicate: isRegExp,\n        represent: representJavascriptRegExp\n      });\n    }, {\n      \"../../type\": 13\n    }],\n    20: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptUndefined() {\n        return true;\n      }\n\n      function constructJavascriptUndefined() {\n        /*eslint-disable no-undefined*/\n        return undefined;\n      }\n\n      function representJavascriptUndefined() {\n        return '';\n      }\n\n      function isUndefined(object) {\n        return typeof object === 'undefined';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/undefined', {\n        kind: 'scalar',\n        resolve: resolveJavascriptUndefined,\n        construct: constructJavascriptUndefined,\n        predicate: isUndefined,\n        represent: representJavascriptUndefined\n      });\n    }, {\n      \"../../type\": 13\n    }],\n    21: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:map', {\n        kind: 'mapping',\n        construct: function (data) {\n          return data !== null ? data : {};\n        }\n      });\n    }, {\n      \"../type\": 13\n    }],\n    22: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlMerge(data) {\n        return data === '<<' || data === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:merge', {\n        kind: 'scalar',\n        resolve: resolveYamlMerge\n      });\n    }, {\n      \"../type\": 13\n    }],\n    23: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlNull(data) {\n        if (data === null) return true;\n        var max = data.length;\n        return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n      }\n\n      function constructYamlNull() {\n        return null;\n      }\n\n      function isNull(object) {\n        return object === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:null', {\n        kind: 'scalar',\n        resolve: resolveYamlNull,\n        construct: constructYamlNull,\n        predicate: isNull,\n        represent: {\n          canonical: function () {\n            return '~';\n          },\n          lowercase: function () {\n            return 'null';\n          },\n          uppercase: function () {\n            return 'NULL';\n          },\n          camelcase: function () {\n            return 'Null';\n          }\n        },\n        defaultStyle: 'lowercase'\n      });\n    }, {\n      \"../type\": 13\n    }],\n    24: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlOmap(data) {\n        if (data === null) return true;\n        var objectKeys = [],\n            index,\n            length,\n            pair,\n            pairKey,\n            pairHasKey,\n            object = data;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          pairHasKey = false;\n          if (_toString.call(pair) !== '[object Object]') return false;\n\n          for (pairKey in pair) {\n            if (_hasOwnProperty.call(pair, pairKey)) {\n              if (!pairHasKey) pairHasKey = true;else return false;\n            }\n          }\n\n          if (!pairHasKey) return false;\n          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlOmap(data) {\n        return data !== null ? data : [];\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:omap', {\n        kind: 'sequence',\n        resolve: resolveYamlOmap,\n        construct: constructYamlOmap\n      });\n    }, {\n      \"../type\": 13\n    }],\n    25: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlPairs(data) {\n        if (data === null) return true;\n        var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          if (_toString.call(pair) !== '[object Object]') return false;\n          keys = Object.keys(pair);\n          if (keys.length !== 1) return false;\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return true;\n      }\n\n      function constructYamlPairs(data) {\n        if (data === null) return [];\n        var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          keys = Object.keys(pair);\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return result;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:pairs', {\n        kind: 'sequence',\n        resolve: resolveYamlPairs,\n        construct: constructYamlPairs\n      });\n    }, {\n      \"../type\": 13\n    }],\n    26: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:seq', {\n        kind: 'sequence',\n        construct: function (data) {\n          return data !== null ? data : [];\n        }\n      });\n    }, {\n      \"../type\": 13\n    }],\n    27: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function resolveYamlSet(data) {\n        if (data === null) return true;\n        var key,\n            object = data;\n\n        for (key in object) {\n          if (_hasOwnProperty.call(object, key)) {\n            if (object[key] !== null) return false;\n          }\n        }\n\n        return true;\n      }\n\n      function constructYamlSet(data) {\n        return data !== null ? data : {};\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:set', {\n        kind: 'mapping',\n        resolve: resolveYamlSet,\n        construct: constructYamlSet\n      });\n    }, {\n      \"../type\": 13\n    }],\n    28: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:str', {\n        kind: 'scalar',\n        construct: function (data) {\n          return data !== null ? data : '';\n        }\n      });\n    }, {\n      \"../type\": 13\n    }],\n    29: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n      '-([0-9][0-9])' + // [2] month\n      '-([0-9][0-9])$'); // [3] day\n\n      var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n      '-([0-9][0-9]?)' + // [2] month\n      '-([0-9][0-9]?)' + // [3] day\n      '(?:[Tt]|[ \\\\t]+)' + // ...\n      '([0-9][0-9]?)' + // [4] hour\n      ':([0-9][0-9])' + // [5] minute\n      ':([0-9][0-9])' + // [6] second\n      '(?:\\\\.([0-9]*))?' + // [7] fraction\n      '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n      '(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\n      function resolveYamlTimestamp(data) {\n        if (data === null) return false;\n        if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n        return false;\n      }\n\n      function constructYamlTimestamp(data) {\n        var match,\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            fraction = 0,\n            delta = null,\n            tz_hour,\n            tz_minute,\n            date;\n        match = YAML_DATE_REGEXP.exec(data);\n        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n        if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day\n\n        year = +match[1];\n        month = +match[2] - 1; // JS month starts with 0\n\n        day = +match[3];\n\n        if (!match[4]) {\n          // no hour\n          return new Date(Date.UTC(year, month, day));\n        } // match: [4] hour [5] minute [6] second [7] fraction\n\n\n        hour = +match[4];\n        minute = +match[5];\n        second = +match[6];\n\n        if (match[7]) {\n          fraction = match[7].slice(0, 3);\n\n          while (fraction.length < 3) {\n            // milli-seconds\n            fraction += '0';\n          }\n\n          fraction = +fraction;\n        } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n\n        if (match[9]) {\n          tz_hour = +match[10];\n          tz_minute = +(match[11] || 0);\n          delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n\n          if (match[9] === '-') delta = -delta;\n        }\n\n        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n        if (delta) date.setTime(date.getTime() - delta);\n        return date;\n      }\n\n      function representYamlTimestamp(object\n      /*, style*/\n      ) {\n        return object.toISOString();\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:timestamp', {\n        kind: 'scalar',\n        resolve: resolveYamlTimestamp,\n        construct: constructYamlTimestamp,\n        instanceOf: Date,\n        represent: representYamlTimestamp\n      });\n    }, {\n      \"../type\": 13\n    }],\n    \"/\": [function (require, module, exports) {\n      'use strict';\n\n      var yaml = require('./lib/js-yaml.js');\n\n      module.exports = yaml;\n    }, {\n      \"./lib/js-yaml.js\": 1\n    }]\n  }, {}, [])(\"/\");\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/js-yaml/dist/js-yaml.js"],"names":["f","exports","module","define","amd","g","window","global","self","jsyaml","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","loader","dumper","deprecated","name","Type","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SAFE_SCHEMA","DEFAULT_FULL_SCHEMA","load","loadAll","safeLoad","safeLoadAll","dump","safeDump","YAMLException","MINIMAL_SCHEMA","SAFE_SCHEMA","DEFAULT_SCHEMA","scan","parse","compose","addConstructor","isNothing","subject","isObject","toArray","sequence","Array","isArray","extend","target","source","index","key","sourceKeys","Object","keys","repeat","string","count","result","cycle","isNegativeZero","number","Number","NEGATIVE_INFINITY","common","_toString","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","compileStyleMap","schema","map","tag","style","type","String","slice","compiledTypeMap","styleAliases","encodeHex","character","handle","toUpperCase","State","options","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","isWhitespace","isPrintable","isNsChar","isPlainSafe","prev","isPlainSafeFirst","needIndentIndicator","leadingSpaceRe","test","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prev_char","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","charCodeAt","writeScalar","iskey","min","testAmbiguity","replace","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","match","exec","prefix","breakRe","start","end","curr","nextChar","escapeSeq","writeFlowSequence","object","_result","_tag","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","represent","defaultStyle","block","objectOrArray","duplicateIndex","duplicate","arrayLevel","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","input","reason","mark","message","captureStackTrace","constructor","stack","create","Mark","CONTEXT_FLOW_IN","CONTEXT_FLOW_OUT","CONTEXT_BLOCK_IN","CONTEXT_BLOCK_OUT","CHOMPING_CLIP","CHOMPING_STRIP","CHOMPING_KEEP","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","obj","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","escapedHexLen","fromDecimalCode","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","filename","onWarning","legacy","json","listener","typeMap","lineStart","lineIndent","documents","generateError","throwError","throwWarning","directiveHandlers","YAML","handleYamlDirective","args","major","minor","version","parseInt","checkLineBreaks","TAG","handleTagDirective","tagMap","captureSegment","checkJson","_position","_length","_character","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startPos","readLineBreak","ch","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readPlainScalar","nodeIndent","withinFlowCollection","preceding","following","captureStart","captureEnd","hasPendingContent","_line","_lineStart","_lineIndent","_kind","kind","readSingleQuotedScalar","readDoubleQuotedScalar","hexLength","hexResult","tmp","readFlowCollection","readNext","_anchor","anchor","terminator","isPair","isExplicitPair","isMapping","anchorMap","composeNode","readBlockScalar","folding","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockSequence","detected","readBlockMapping","flowIndent","allowCompact","_pos","atExplicitKey","readTagProperty","isVerbatim","isNamed","tagHandle","tagName","readAnchorProperty","readAlias","alias","parentIndent","nodeContext","allowToSeek","allowBlockStyles","allowBlockScalars","allowBlockCollections","indentStatus","atNewLine","hasContent","typeIndex","typeQuantity","blockIndent","construct","readDocument","documentStart","directiveName","directiveArgs","hasDirectives","loadDocuments","nullpos","iterator","undefined","buffer","column","getSnippet","maxLength","head","tail","snippet","charAt","where","compileList","exclude","include","forEach","includedSchema","currentType","previousType","previousIndex","filter","compileMap","scalar","mapping","fallback","collectType","arguments","definition","implicit","loadKind","DEFAULT","createSchema","schemas","types","every","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","compileStyleAliases","data","NodeBuffer","_require","Buffer","__","BASE64_MAP","resolveYamlBinary","idx","bitlen","constructYamlBinary","tailbits","bits","from","representYamlBinary","isBinary","isBuffer","resolveYamlBoolean","constructYamlBoolean","isBoolean","lowercase","uppercase","camelcase","YAML_FLOAT_PATTERN","RegExp","resolveYamlFloat","constructYamlFloat","value","sign","base","digits","toLowerCase","POSITIVE_INFINITY","NaN","split","v","unshift","parseFloat","d","SCIENTIFIC_WITHOUT_DOT","representYamlFloat","res","isNaN","isFloat","isHexCode","isOctCode","isDecCode","resolveYamlInteger","hasDigits","constructYamlInteger","isInteger","binary","octal","decimal","hexadecimal","esprima","_","resolveJavascriptFunction","ast","range","body","expression","err","constructJavascriptFunction","params","param","Function","representJavascriptFunction","isFunction","resolveJavascriptRegExp","regexp","modifiers","constructJavascriptRegExp","representJavascriptRegExp","multiline","ignoreCase","isRegExp","resolveJavascriptUndefined","constructJavascriptUndefined","representJavascriptUndefined","isUndefined","resolveYamlMerge","resolveYamlNull","constructYamlNull","isNull","canonical","resolveYamlOmap","objectKeys","pair","pairKey","pairHasKey","constructYamlOmap","resolveYamlPairs","constructYamlPairs","resolveYamlSet","constructYamlSet","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","resolveYamlTimestamp","constructYamlTimestamp","year","month","day","hour","minute","second","fraction","delta","tz_hour","tz_minute","date","Date","UTC","setTime","getTime","representYamlTimestamp","toISOString","yaml"],"mappings":"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","sourcesContent":["/* js-yaml 3.14.0 https://github.com/nodeca/js-yaml */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.jsyaml = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecated schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n\n},{\"./js-yaml/dumper\":3,\"./js-yaml/exception\":4,\"./js-yaml/loader\":5,\"./js-yaml/schema\":7,\"./js-yaml/schema/core\":8,\"./js-yaml/schema/default_full\":9,\"./js-yaml/schema/default_safe\":10,\"./js-yaml/schema/failsafe\":11,\"./js-yaml/schema/json\":12,\"./js-yaml/type\":13}],2:[function(require,module,exports){\n'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c)\n    // byte-order-mark\n    && c !== 0xFEFF\n    // b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    // /* An ns-char preceding */ \"#\"\n    && c !== CHAR_COLON\n    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n\n},{\"./common\":2,\"./exception\":4,\"./schema/default_full\":9,\"./schema/default_safe\":10}],4:[function(require,module,exports){\n// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    _pos = state.position;\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!state.anchorMap.hasOwnProperty(alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n\n},{\"./common\":2,\"./exception\":4,\"./mark\":6,\"./schema/default_full\":9,\"./schema/default_safe\":10}],6:[function(require,module,exports){\n'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) return null;\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n\n},{\"./common\":2}],7:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n\n},{\"./common\":2,\"./exception\":4,\"./type\":13}],8:[function(require,module,exports){\n// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n\n},{\"../schema\":7,\"./json\":12}],9:[function(require,module,exports){\n// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n\n},{\"../schema\":7,\"../type/js/function\":18,\"../type/js/regexp\":19,\"../type/js/undefined\":20,\"./default_safe\":10}],10:[function(require,module,exports){\n// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n\n},{\"../schema\":7,\"../type/binary\":14,\"../type/merge\":22,\"../type/omap\":24,\"../type/pairs\":25,\"../type/set\":27,\"../type/timestamp\":29,\"./core\":8}],11:[function(require,module,exports){\n// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n\n},{\"../schema\":7,\"../type/map\":21,\"../type/seq\":26,\"../type/str\":28}],12:[function(require,module,exports){\n// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n\n},{\"../schema\":7,\"../type/bool\":15,\"../type/float\":16,\"../type/int\":17,\"../type/null\":23,\"./failsafe\":11}],13:[function(require,module,exports){\n'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n\n},{\"./exception\":4}],14:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\n},{\"../type\":13}],15:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n},{\"../type\":13}],16:[function(require,module,exports){\n'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\n},{\"../common\":2,\"../type\":13}],17:[function(require,module,exports){\n'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n    return hasDigits && ch !== '_';\n  }\n\n  // base 10 (except 0) or base 60\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  // if !base60 - done;\n  if (ch !== ':') return true;\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\n},{\"../common\":2,\"../type\":13}],18:[function(require,module,exports){\n'use strict';\n\nvar esprima;\n\n// Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\ntry {\n  // workaround to exclude package from browserify list.\n  var _require = require;\n  esprima = _require('esprima');\n} catch (_) {\n  /* eslint-disable no-redeclare */\n  /* global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast    = esprima.parse(source, { range: true });\n\n    if (ast.type                    !== 'Program'             ||\n        ast.body.length             !== 1                     ||\n        ast.body[0].type            !== 'ExpressionStatement' ||\n        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n          ast.body[0].expression.type !== 'FunctionExpression')) {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n\n  var source = '(' + data + ')',\n      ast    = esprima.parse(source, { range: true }),\n      params = [],\n      body;\n\n  if (ast.type                    !== 'Program'             ||\n      ast.body.length             !== 1                     ||\n      ast.body[0].type            !== 'ExpressionStatement' ||\n      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n        ast.body[0].expression.type !== 'FunctionExpression')) {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n\n  body = ast.body[0].expression.body.range;\n\n  // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  }\n  // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n  /*eslint-disable no-new-func*/\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object /*, style*/) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n\n},{\"../../type\":13}],19:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n\n    if (modifiers.length > 3) return false;\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n\n},{\"../../type\":13}],20:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n\n},{\"../../type\":13}],21:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\n},{\"../type\":13}],22:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n},{\"../type\":13}],23:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n},{\"../type\":13}],24:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\n},{\"../type\":13}],25:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\n},{\"../type\":13}],26:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\n},{\"../type\":13}],27:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\n},{\"../type\":13}],28:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\n},{\"../type\":13}],29:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\n},{\"../type\":13}],\"/\":[function(require,module,exports){\n'use strict';\n\n\nvar yaml = require('./lib/js-yaml.js');\n\n\nmodule.exports = yaml;\n\n},{\"./lib/js-yaml.js\":1}]},{},[])(\"/\")\n});\n"]},"metadata":{},"sourceType":"script"}