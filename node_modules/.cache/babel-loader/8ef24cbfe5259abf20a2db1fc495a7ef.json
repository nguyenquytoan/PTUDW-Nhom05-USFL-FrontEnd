{"ast":null,"code":"'use strict';\n\nmodule.exports = adapterFactory;\n\nfunction adapterFactory(implementation) {\n  ensureImplementation(implementation);\n  var adapter = {};\n  var baseAdapter = {\n    removeSubsets: function (nodes) {\n      return removeSubsets(adapter, nodes);\n    },\n    existsOne: function (test, elems) {\n      return existsOne(adapter, test, elems);\n    },\n    getSiblings: function (elem) {\n      return getSiblings(adapter, elem);\n    },\n    hasAttrib: function (elem, name) {\n      return hasAttrib(adapter, elem, name);\n    },\n    findOne: function (test, arr) {\n      return findOne(adapter, test, arr);\n    },\n    findAll: function (test, elems) {\n      return findAll(adapter, test, elems);\n    }\n  };\n  Object.assign(adapter, baseAdapter, implementation);\n  return adapter;\n}\n\nvar expectImplemented = [\"isTag\", \"getAttributeValue\", \"getChildren\", \"getName\", \"getParent\", \"getText\"];\n\nfunction ensureImplementation(implementation) {\n  if (!implementation) throw new TypeError(\"Expected implementation\");\n  var notImplemented = expectImplemented.filter(function (fname) {\n    return typeof implementation[fname] !== \"function\";\n  });\n\n  if (notImplemented.length) {\n    var notList = \"(\" + notImplemented.join(\", \") + \")\";\n    var message = \"Expected functions \" + notList + \" to be implemented\";\n    throw new Error(message);\n  }\n}\n\nfunction removeSubsets(adapter, nodes) {\n  var idx = nodes.length,\n      node,\n      ancestor,\n      replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = adapter.getParent(ancestor);\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n}\n\nfunction existsOne(adapter, test, elems) {\n  return elems.some(function (elem) {\n    return adapter.isTag(elem) ? test(elem) || adapter.existsOne(test, adapter.getChildren(elem)) : false;\n  });\n}\n\nfunction getSiblings(adapter, elem) {\n  var parent = adapter.getParent(elem);\n  return parent && adapter.getChildren(parent);\n}\n\nfunction hasAttrib(adapter, elem, name) {\n  return adapter.getAttributeValue(elem, name) !== undefined;\n}\n\nfunction findOne(adapter, test, arr) {\n  var elem = null;\n\n  for (var i = 0, l = arr.length; i < l && !elem; i++) {\n    if (test(arr[i])) {\n      elem = arr[i];\n    } else {\n      var childs = adapter.getChildren(arr[i]);\n\n      if (childs && childs.length > 0) {\n        elem = adapter.findOne(test, childs);\n      }\n    }\n  }\n\n  return elem;\n}\n\nfunction findAll(adapter, test, elems) {\n  var result = [];\n\n  for (var i = 0, j = elems.length; i < j; i++) {\n    if (!adapter.isTag(elems[i])) continue;\n    if (test(elems[i])) result.push(elems[i]);\n    var childs = adapter.getChildren(elems[i]);\n    if (childs) result = result.concat(adapter.findAll(test, childs));\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/css-select-base-adapter/index.js"],"names":["module","exports","adapterFactory","implementation","ensureImplementation","adapter","baseAdapter","removeSubsets","nodes","existsOne","test","elems","getSiblings","elem","hasAttrib","name","findOne","arr","findAll","Object","assign","expectImplemented","TypeError","notImplemented","filter","fname","length","notList","join","message","Error","idx","node","ancestor","replace","indexOf","splice","getParent","some","isTag","getChildren","parent","getAttributeValue","undefined","i","l","childs","result","j","push","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = adapterFactory;\n\nfunction adapterFactory(implementation){\n\tensureImplementation(implementation);\n\n\tvar adapter = {}\n\n\tvar baseAdapter = {\n\t\tremoveSubsets: function (nodes){\n\t\t\treturn removeSubsets(adapter, nodes);\n\t\t},\n\t\texistsOne: function(test, elems){\n\t\t\treturn existsOne(adapter, test, elems);\n\t\t},\n\t\tgetSiblings: function(elem){\n\t\t\treturn getSiblings(adapter, elem);\n\t\t},\n\t\thasAttrib: function(elem, name){\n\t\t\treturn hasAttrib(adapter, elem, name);\n\t\t},\n\t\tfindOne: function(test, arr){\n\t\t\treturn findOne(adapter, test, arr);\n\t\t},\n\t\tfindAll: function(test, elems){\n\t\t\treturn findAll(adapter, test, elems)\n\t\t}\n\t};\n\n\tObject.assign(adapter, baseAdapter, implementation);\n\n\treturn adapter;\n}\n\nvar expectImplemented = [\n\t\"isTag\", \"getAttributeValue\", \"getChildren\", \"getName\", \"getParent\",\n\t\"getText\"\n];\n\nfunction ensureImplementation(implementation){\n\tif(!implementation)\tthrow new TypeError(\"Expected implementation\")\n\n\tvar notImplemented = expectImplemented.filter(function(fname){\n\t\treturn typeof implementation[fname] !== \"function\";\n\t});\n\n\tif(notImplemented.length){\n\t\tvar notList = \"(\" + notImplemented.join(\", \") + \")\";\n\t\tvar message = \"Expected functions \" + notList + \" to be implemented\";\n\t\tthrow new Error(message);\n\t}\n}\n\nfunction removeSubsets(adapter, nodes){\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile(--idx > -1){\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile(ancestor){\n\t\t\tif(nodes.indexOf(ancestor) > -1){\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = adapter.getParent(ancestor)\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif(replace){\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n}\n\nfunction existsOne(adapter, test, elems){\n\treturn elems.some(function(elem){\n\t\treturn adapter.isTag(elem) ?\n\t\t\ttest(elem) || adapter.existsOne(test, adapter.getChildren(elem)) :\n\t\t\tfalse;\n\t});\n}\n\nfunction getSiblings(adapter, elem){\n\tvar parent = adapter.getParent(elem);\n\treturn parent && adapter.getChildren(parent);\n}\n\n\nfunction hasAttrib(adapter, elem, name){\n\treturn adapter.getAttributeValue(elem,name) !== undefined\n}\n\nfunction findOne(adapter, test, arr){\n\tvar elem = null;\n\n\tfor(var i = 0, l = arr.length; i < l && !elem; i++){\n\t\tif(test(arr[i])){\n\t\t\telem = arr[i];\n\t\t} else {\n\t\t\tvar childs = adapter.getChildren(arr[i]);\n\t\t\tif(childs && childs.length > 0){\n\t\t\t\telem = adapter.findOne(test, childs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn elem;\n}\n\nfunction findAll(adapter, test, elems){\n\tvar result = [];\n\n\tfor(var i = 0, j = elems.length; i < j; i++){\n\t\tif(!adapter.isTag(elems[i])) continue;\n\t\tif(test(elems[i])) result.push(elems[i]);\n\t\tvar childs = adapter.getChildren(elems[i]);\n\t\tif(childs) result = result.concat(adapter.findAll(test, childs));\n\t}\n\n\treturn result;\n}\n"]},"metadata":{},"sourceType":"script"}