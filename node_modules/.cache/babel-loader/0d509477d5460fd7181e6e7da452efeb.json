{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar optionsManager = require(\"./managers/options\");\n\nvar taskManager = require(\"./managers/tasks\");\n\nvar reader_async_1 = require(\"./providers/reader-async\");\n\nvar reader_stream_1 = require(\"./providers/reader-stream\");\n\nvar reader_sync_1 = require(\"./providers/reader-sync\");\n\nvar arrayUtils = require(\"./utils/array\");\n\nvar streamUtils = require(\"./utils/stream\");\n/**\r\n * Synchronous API.\r\n */\n\n\nfunction sync(source, opts) {\n  assertPatternsInput(source);\n  var works = getWorks(source, reader_sync_1.default, opts);\n  return arrayUtils.flatten(works);\n}\n\nexports.sync = sync;\n/**\r\n * Asynchronous API.\r\n */\n\nfunction async(source, opts) {\n  try {\n    assertPatternsInput(source);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  var works = getWorks(source, reader_async_1.default, opts);\n  return Promise.all(works).then(arrayUtils.flatten);\n}\n\nexports.async = async;\n/**\r\n * Stream API.\r\n */\n\nfunction stream(source, opts) {\n  assertPatternsInput(source);\n  var works = getWorks(source, reader_stream_1.default, opts);\n  return streamUtils.merge(works);\n}\n\nexports.stream = stream;\n/**\r\n * Return a set of tasks based on provided patterns.\r\n */\n\nfunction generateTasks(source, opts) {\n  assertPatternsInput(source);\n  var patterns = [].concat(source);\n  var options = optionsManager.prepare(opts);\n  return taskManager.generate(patterns, options);\n}\n\nexports.generateTasks = generateTasks;\n/**\r\n * Returns a set of works based on provided tasks and class of the reader.\r\n */\n\nfunction getWorks(source, _Reader, opts) {\n  var patterns = [].concat(source);\n  var options = optionsManager.prepare(opts);\n  var tasks = taskManager.generate(patterns, options);\n  var reader = new _Reader(options);\n  return tasks.map(reader.read, reader);\n}\n\nfunction assertPatternsInput(source) {\n  if ([].concat(source).every(isString)) {\n    return;\n  }\n\n  throw new TypeError('Patterns must be a string or an array of strings');\n}\n\nfunction isString(source) {\n  /* tslint:disable-next-line strict-type-predicates */\n  return typeof source === 'string';\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/fast-glob/out/index.js"],"names":["Object","defineProperty","exports","value","optionsManager","require","taskManager","reader_async_1","reader_stream_1","reader_sync_1","arrayUtils","streamUtils","sync","source","opts","assertPatternsInput","works","getWorks","default","flatten","async","error","Promise","reject","all","then","stream","merge","generateTasks","patterns","concat","options","prepare","generate","_Reader","tasks","reader","map","read","every","isString","TypeError"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar optionsManager = require(\"./managers/options\");\r\nvar taskManager = require(\"./managers/tasks\");\r\nvar reader_async_1 = require(\"./providers/reader-async\");\r\nvar reader_stream_1 = require(\"./providers/reader-stream\");\r\nvar reader_sync_1 = require(\"./providers/reader-sync\");\r\nvar arrayUtils = require(\"./utils/array\");\r\nvar streamUtils = require(\"./utils/stream\");\r\n/**\r\n * Synchronous API.\r\n */\r\nfunction sync(source, opts) {\r\n    assertPatternsInput(source);\r\n    var works = getWorks(source, reader_sync_1.default, opts);\r\n    return arrayUtils.flatten(works);\r\n}\r\nexports.sync = sync;\r\n/**\r\n * Asynchronous API.\r\n */\r\nfunction async(source, opts) {\r\n    try {\r\n        assertPatternsInput(source);\r\n    }\r\n    catch (error) {\r\n        return Promise.reject(error);\r\n    }\r\n    var works = getWorks(source, reader_async_1.default, opts);\r\n    return Promise.all(works).then(arrayUtils.flatten);\r\n}\r\nexports.async = async;\r\n/**\r\n * Stream API.\r\n */\r\nfunction stream(source, opts) {\r\n    assertPatternsInput(source);\r\n    var works = getWorks(source, reader_stream_1.default, opts);\r\n    return streamUtils.merge(works);\r\n}\r\nexports.stream = stream;\r\n/**\r\n * Return a set of tasks based on provided patterns.\r\n */\r\nfunction generateTasks(source, opts) {\r\n    assertPatternsInput(source);\r\n    var patterns = [].concat(source);\r\n    var options = optionsManager.prepare(opts);\r\n    return taskManager.generate(patterns, options);\r\n}\r\nexports.generateTasks = generateTasks;\r\n/**\r\n * Returns a set of works based on provided tasks and class of the reader.\r\n */\r\nfunction getWorks(source, _Reader, opts) {\r\n    var patterns = [].concat(source);\r\n    var options = optionsManager.prepare(opts);\r\n    var tasks = taskManager.generate(patterns, options);\r\n    var reader = new _Reader(options);\r\n    return tasks.map(reader.read, reader);\r\n}\r\nfunction assertPatternsInput(source) {\r\n    if ([].concat(source).every(isString)) {\r\n        return;\r\n    }\r\n    throw new TypeError('Patterns must be a string or an array of strings');\r\n}\r\nfunction isString(source) {\r\n    /* tslint:disable-next-line strict-type-predicates */\r\n    return typeof source === 'string';\r\n}\r\n"]},"metadata":{},"sourceType":"script"}