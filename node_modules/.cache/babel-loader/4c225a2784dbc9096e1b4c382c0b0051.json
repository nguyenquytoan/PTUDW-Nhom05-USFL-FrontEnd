{"ast":null,"code":"import Literal from './Literal';\nimport JSXElement from './JSXElement';\nimport JSXExpressionContainer, { extractLiteral } from './expressions'; // Composition map of types to their extractor functions.\n\nconst TYPES = {\n  Literal,\n  JSXElement,\n  JSXExpressionContainer\n}; // Composition map of types to their extractor functions to handle literals.\n\nconst LITERAL_TYPES = { ...TYPES,\n  JSXElement: () => null,\n  JSXExpressionContainer: extractLiteral\n};\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible types.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\n\nexport default function getValue(value) {\n  return TYPES[value.type](value);\n}\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\n\nexport function getLiteralValue(value) {\n  return LITERAL_TYPES[value.type](value);\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsx-ast-utils/src/values/index.js"],"names":["Literal","JSXElement","JSXExpressionContainer","extractLiteral","TYPES","LITERAL_TYPES","getValue","value","type","getLiteralValue"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,sBAAP,IAAiCC,cAAjC,QAAuD,eAAvD,C,CAEA;;AACA,MAAMC,KAAK,GAAG;AACZJ,EAAAA,OADY;AAEZC,EAAAA,UAFY;AAGZC,EAAAA;AAHY,CAAd,C,CAMA;;AACA,MAAMG,aAAa,GAAG,EACpB,GAAGD,KADiB;AAEpBH,EAAAA,UAAU,EAAE,MAAM,IAFE;AAGpBC,EAAAA,sBAAsB,EAAEC;AAHJ,CAAtB;AAMA;;;;;;;;;;AASA,eAAe,SAASG,QAAT,CAAkBC,KAAlB,EAAyB;AACtC,SAAOH,KAAK,CAACG,KAAK,CAACC,IAAP,CAAL,CAAkBD,KAAlB,CAAP;AACD;AAED;;;;;;;;;;AASA,OAAO,SAASE,eAAT,CAAyBF,KAAzB,EAAgC;AACrC,SAAOF,aAAa,CAACE,KAAK,CAACC,IAAP,CAAb,CAA0BD,KAA1B,CAAP;AACD","sourcesContent":["import Literal from './Literal';\nimport JSXElement from './JSXElement';\nimport JSXExpressionContainer, { extractLiteral } from './expressions';\n\n// Composition map of types to their extractor functions.\nconst TYPES = {\n  Literal,\n  JSXElement,\n  JSXExpressionContainer,\n};\n\n// Composition map of types to their extractor functions to handle literals.\nconst LITERAL_TYPES = {\n  ...TYPES,\n  JSXElement: () => null,\n  JSXExpressionContainer: extractLiteral,\n};\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible types.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\nexport default function getValue(value) {\n  return TYPES[value.type](value);\n}\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param value - AST Value object on a JSX Attribute.\n */\nexport function getLiteralValue(value) {\n  return LITERAL_TYPES[value.type](value);\n}\n"]},"metadata":{},"sourceType":"module"}