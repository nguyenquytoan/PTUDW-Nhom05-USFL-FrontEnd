{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.mjs';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { messages } from './utils/messages.mjs';\nimport './_version.mjs';\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\n\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  async handle({\n    event,\n    request\n  }) {\n    return this.makeRequest({\n      event,\n      request: request || event.request\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n\n\n  async makeRequest({\n    event,\n    request\n  }) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request'\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins\n    });\n    let error;\n\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will respond with a network request.`);\n      }\n\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n\n      for (let log of logs) {\n        logger.log(log);\n      }\n\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n\n    return response;\n  }\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n\n\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins\n    }); // Keep the service worker while we put the request to the cache\n\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n\n}\n\nexport { CacheFirst };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-strategies/CacheFirst.mjs"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","getFriendlyURL","logger","WorkboxError","messages","CacheFirst","constructor","options","_cacheName","getRuntimeName","cacheName","_plugins","plugins","_fetchOptions","fetchOptions","_matchOptions","matchOptions","handle","event","request","makeRequest","logs","Request","process","env","NODE_ENV","isInstance","moduleName","className","funcName","paramName","response","match","error","push","_getFromNetwork","err","groupCollapsed","strategyStart","log","printFinalResponse","groupEnd","url","fetch","responseClone","clone","cachePutPromise","put","waitUntil","warn"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {CacheFirst};\n"]},"metadata":{},"sourceType":"module"}