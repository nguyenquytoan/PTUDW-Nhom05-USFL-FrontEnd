{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n/*!\n * XRegExp.matchRecursive 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\n\n\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _includes.default)(flags).call(flags, 'g');\n    var sticky = (0, _includes.default)(flags).call(flags, 'y'); // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat.default)(_context = (0, _concat.default)(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice.default)(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice.default)(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice.default)(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice.default)(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice.default)(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice.default)(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/lib/addons/matchrecursive.js"],"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_slice","_concat","_includes","_default","XRegExp","row","name","start","end","matchRecursive","str","left","right","flags","options","global","call","sticky","basicFlags","replace","_options","escapeChar","vN","valueNames","output","openTokens","delimStart","delimEnd","lastOuterEnd","outerStart","innerStart","leftMatch","rightMatch","esc","_context","_context2","length","Error","escape","RegExp","concat","union","conjunction","source","exec","index","push","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\n/*!\n * XRegExp.matchRecursive 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _includes.default)(flags).call(flags, 'g');\n    var sticky = (0, _includes.default)(flags).call(flags, 'y'); // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat.default)(_context = (0, _concat.default)(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice.default)(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice.default)(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice.default)(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice.default)(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice.default)(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice.default)(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}