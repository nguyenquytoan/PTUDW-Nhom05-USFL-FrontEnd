{"ast":null,"code":"/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\n\n\nfunction union(setA, setB) {\n  return new Set(function* () {\n    yield* setA;\n    yield* setB;\n  }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\n\nfunction parseRegExp(regExpText) {\n  const charList = [];\n  regExpText.split(\"\").reduce((state, char, index) => {\n    if (!state.escapeNextChar) {\n      if (char === \"\\\\\") {\n        return Object.assign(state, {\n          escapeNextChar: true\n        });\n      }\n\n      if (char === \"[\" && !state.inCharClass) {\n        return Object.assign(state, {\n          inCharClass: true,\n          startingCharClass: true\n        });\n      }\n\n      if (char === \"]\" && state.inCharClass) {\n        if (charList.length && charList[charList.length - 1].inCharClass) {\n          charList[charList.length - 1].endsCharClass = true;\n        }\n\n        return Object.assign(state, {\n          inCharClass: false,\n          startingCharClass: false\n        });\n      }\n    }\n\n    charList.push({\n      text: char,\n      index,\n      escaped: state.escapeNextChar,\n      inCharClass: state.inCharClass,\n      startsCharClass: state.startingCharClass,\n      endsCharClass: false\n    });\n    return Object.assign(state, {\n      escapeNextChar: false,\n      startingCharClass: false\n    });\n  }, {\n    escapeNextChar: false,\n    inCharClass: false,\n    startingCharClass: false\n  });\n  return charList;\n}\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary escape characters\",\n      category: \"Best Practices\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-escape\",\n      suggestion: true\n    },\n    messages: {\n      unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n      removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n      escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports a node\n     * @param {ASTNode} node The node to report\n     * @param {number} startOffset The backslash's offset from the start of the node\n     * @param {string} character The uselessly escaped character (not including the backslash)\n     * @returns {void}\n     */\n\n    function report(node, startOffset, character) {\n      const start = sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset);\n      const rangeStart = sourceCode.getIndexFromLoc(node.loc.start) + startOffset;\n      const range = [rangeStart, rangeStart + 1];\n      context.report({\n        node,\n        loc: {\n          start,\n          end: {\n            line: start.line,\n            column: start.column + 1\n          }\n        },\n        messageId: \"unnecessaryEscape\",\n        data: {\n          character\n        },\n        suggest: [{\n          messageId: \"removeEscape\",\n\n          fix(fixer) {\n            return fixer.removeRange(range);\n          }\n\n        }, {\n          messageId: \"escapeBackslash\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\\\\");\n          }\n\n        }]\n      });\n    }\n    /**\n     * Checks if the escape character in given string slice is unnecessary.\n     * @private\n     * @param {ASTNode} node node to validate.\n     * @param {string} match string slice to validate.\n     * @returns {void}\n     */\n\n\n    function validateString(node, match) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      const escapedChar = match[0][1];\n      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n      let isQuoteEscape;\n\n      if (isTemplateElement) {\n        isQuoteEscape = escapedChar === \"`\";\n\n        if (escapedChar === \"$\") {\n          // Warn if `\\$` is not followed by `{`\n          isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n        } else if (escapedChar === \"{\") {\n          /*\n           * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n           * is necessary and the rule should not warn. If preceded by `/$`, the rule\n           * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n           */\n          isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n        }\n      } else {\n        isQuoteEscape = escapedChar === node.raw[0];\n      }\n\n      if (isUnnecessaryEscape && !isQuoteEscape) {\n        report(node, match.index + 1, match[0].slice(1));\n      }\n    }\n    /**\n     * Checks if a node has an escape.\n     * @param {ASTNode} node node to check.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n\n      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === \"TaggedTemplateExpression\" && node.parent === node.parent.parent.quasi) {\n        // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n        return;\n      }\n\n      if (typeof node.value === \"string\" || isTemplateElement) {\n        /*\n         * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n         * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n         */\n        if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n          return;\n        }\n\n        const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);\n        const pattern = /\\\\[^\\d]/gu;\n        let match;\n\n        while (match = pattern.exec(value)) {\n          validateString(node, match);\n        }\n      } else if (node.regex) {\n        parseRegExp(node.regex.pattern)\n        /*\n         * The '-' character is a special case, because it's only valid to escape it if it's in a character\n         * class, and is not at either edge of the character class. To account for this, don't consider '-'\n         * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n         * character class.\n         */\n        .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n        /*\n         * The '^' character is also a special case; it must always be escaped outside of character classes, but\n         * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n         * account for this, consider it to be a valid escape character outside of character classes, and filter\n         * out '^' characters that appear at the start of a character class.\n         */\n        .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass)) // Filter out characters that aren't escaped.\n        .filter(charInfo => charInfo.escaped) // Filter out characters that are valid to escape, based on their position in the regular expression.\n        .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)) // Report all the remaining characters.\n        .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n      }\n    }\n\n    return {\n      Literal: check,\n      TemplateElement: check\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-useless-escape.js"],"names":["astUtils","require","union","setA","setB","Set","VALID_STRING_ESCAPES","LINEBREAKS","REGEX_GENERAL_ESCAPES","REGEX_NON_CHARCLASS_ESCAPES","parseRegExp","regExpText","charList","split","reduce","state","char","index","escapeNextChar","Object","assign","inCharClass","startingCharClass","length","endsCharClass","push","text","escaped","startsCharClass","module","exports","meta","type","docs","description","category","recommended","url","suggestion","messages","unnecessaryEscape","removeEscape","escapeBackslash","schema","create","context","sourceCode","getSourceCode","report","node","startOffset","character","start","getLocFromIndex","getIndexFromLoc","loc","rangeStart","range","end","line","column","messageId","data","suggest","fix","fixer","removeRange","insertTextBeforeRange","validateString","match","isTemplateElement","escapedChar","isUnnecessaryEscape","has","isQuoteEscape","input","raw","slice","check","parent","quasi","value","pattern","exec","regex","filter","charInfo","forEach","Literal","TemplateElement"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({\n            text: char,\n            index,\n            escaped: state.escapeNextChar,\n            inCharClass: state.inCharClass,\n            startsCharClass: state.startingCharClass,\n            endsCharClass: false\n        });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-useless-escape\",\n            suggestion: true\n        },\n\n        messages: {\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            const start = sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset);\n            const rangeStart = sourceCode.getIndexFromLoc(node.loc.start) + startOffset;\n            const range = [rangeStart, rangeStart + 1];\n\n            context.report({\n                node,\n                loc: {\n                    start,\n                    end: { line: start.line, column: start.column + 1 }\n                },\n                messageId: \"unnecessaryEscape\",\n                data: { character },\n                suggest: [\n                    {\n                        messageId: \"removeEscape\",\n                        fix(fixer) {\n                            return fixer.removeRange(range);\n                        }\n                    },\n                    {\n                        messageId: \"escapeBackslash\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange(range, \"\\\\\");\n                        }\n                    }\n                ]\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @param {string} match string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index + 1, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}