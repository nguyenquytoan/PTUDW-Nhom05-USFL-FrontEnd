{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction transpileEnum(path, t) {\n  const {\n    node\n  } = path;\n\n  if (node.const) {\n    throw path.buildCodeFrameError(\"'const' enums are not supported.\");\n  }\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        path.insertAfter(fill);\n\n        if (seen(path.parentPath)) {\n          path.remove();\n        } else {\n          const isGlobal = t.isProgram(path.parent);\n          path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0]);\n        }\n\n        break;\n      }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id, t, kind) {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = (0, _core.template)(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\nfunction enumFill(path, t, id) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) => buildEnumMember(t.isStringLiteral(memberValue), {\n    ENUM: t.cloneNode(id),\n    NAME: memberName,\n    VALUE: memberValue\n  }));\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments\n  });\n}\n\nfunction translateEnumValues(path, t) {\n  const seen = Object.create(null);\n  let prev = -1;\n  return path.node.members.map(member => {\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value;\n\n    if (initializer) {\n      const constValue = evaluate(initializer, seen);\n\n      if (constValue !== undefined) {\n        seen[name] = constValue;\n\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n          prev = constValue;\n        } else {\n          (0, _assert.default)(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n          prev = undefined;\n        }\n      } else {\n        value = initializer;\n        prev = undefined;\n      }\n    } else {\n      if (prev !== undefined) {\n        prev++;\n        value = t.numericLiteral(prev);\n        seen[name] = prev;\n      } else {\n        throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n      }\n    }\n\n    return [name, value];\n  });\n}\n\nfunction evaluate(expr, seen) {\n  return evalConstant(expr);\n\n  function evalConstant(expr) {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n\n      case \"NumericLiteral\":\n        return expr.value;\n\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n\n      case \"Identifier\":\n        return seen[expr.name];\n\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator\n  }) {\n    const value = evalConstant(argument);\n\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n\n      case \"-\":\n        return -value;\n\n      case \"~\":\n        return ~value;\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr) {\n    const left = evalConstant(expr.left);\n\n    if (left === undefined) {\n      return undefined;\n    }\n\n    const right = evalConstant(expr.right);\n\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n\n      case \"<<\":\n        return left << right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"*\":\n        return left * right;\n\n      case \"/\":\n        return left / right;\n\n      case \"+\":\n        return left + right;\n\n      case \"-\":\n        return left - right;\n\n      case \"%\":\n        return left % right;\n\n      default:\n        return undefined;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@babel/plugin-transform-typescript/lib/enum.js"],"names":["Object","defineProperty","exports","value","default","transpileEnum","_assert","_interopRequireDefault","require","_core","obj","__esModule","path","t","node","const","buildCodeFrameError","declare","remove","name","id","fill","enumFill","parent","type","insertAfter","seen","parentPath","isGlobal","isProgram","scope","registerDeclaration","replaceWith","makeVar","Error","isExportDeclaration","getData","setData","kind","variableDeclaration","variableDeclarator","buildEnumWrapper","template","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","x","translateEnumValues","assignments","map","memberName","memberValue","isStringLiteral","ENUM","cloneNode","NAME","VALUE","ID","ASSIGNMENTS","create","prev","members","member","isIdentifier","initializer","constValue","evaluate","undefined","numericLiteral","stringLiteral","expr","evalConstant","evalUnaryExpression","evalBinaryExpression","expression","quasis","length","cooked","argument","operator","left","right"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction transpileEnum(path, t) {\n  const {\n    node\n  } = path;\n\n  if (node.const) {\n    throw path.buildCodeFrameError(\"'const' enums are not supported.\");\n  }\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        path.insertAfter(fill);\n\n        if (seen(path.parentPath)) {\n          path.remove();\n        } else {\n          const isGlobal = t.isProgram(path.parent);\n          path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0]);\n        }\n\n        break;\n      }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id, t, kind) {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = (0, _core.template)(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\nfunction enumFill(path, t, id) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) => buildEnumMember(t.isStringLiteral(memberValue), {\n    ENUM: t.cloneNode(id),\n    NAME: memberName,\n    VALUE: memberValue\n  }));\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments\n  });\n}\n\nfunction translateEnumValues(path, t) {\n  const seen = Object.create(null);\n  let prev = -1;\n  return path.node.members.map(member => {\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value;\n\n    if (initializer) {\n      const constValue = evaluate(initializer, seen);\n\n      if (constValue !== undefined) {\n        seen[name] = constValue;\n\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n          prev = constValue;\n        } else {\n          (0, _assert.default)(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n          prev = undefined;\n        }\n      } else {\n        value = initializer;\n        prev = undefined;\n      }\n    } else {\n      if (prev !== undefined) {\n        prev++;\n        value = t.numericLiteral(prev);\n        seen[name] = prev;\n      } else {\n        throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n      }\n    }\n\n    return [name, value];\n  });\n}\n\nfunction evaluate(expr, seen) {\n  return evalConstant(expr);\n\n  function evalConstant(expr) {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n\n      case \"NumericLiteral\":\n        return expr.value;\n\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n\n      case \"Identifier\":\n        return seen[expr.name];\n\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator\n  }) {\n    const value = evalConstant(argument);\n\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n\n      case \"-\":\n        return -value;\n\n      case \"~\":\n        return ~value;\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr) {\n    const left = evalConstant(expr.left);\n\n    if (left === undefined) {\n      return undefined;\n    }\n\n    const right = evalConstant(expr.right);\n\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n\n      case \"<<\":\n        return left << right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"*\":\n        return left * right;\n\n      case \"/\":\n        return left / right;\n\n      case \"+\":\n        return left + right;\n\n      case \"-\":\n        return left - right;\n\n      case \"%\":\n        return left % right;\n\n      default:\n        return undefined;\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}