{"ast":null,"code":"/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  isCommentToken\n} = require(\"eslint-utils\"),\n      TokenStore = require(\"./token-store\"),\n      astUtils = require(\"../shared/ast-utils\"),\n      Traverser = require(\"../shared/traverser\"),\n      lodash = require(\"lodash\"); //------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\n\n\nfunction validate(ast) {\n  if (!ast.tokens) {\n    throw new Error(\"AST is missing the tokens array.\");\n  }\n\n  if (!ast.comments) {\n    throw new Error(\"AST is missing the comments array.\");\n  }\n\n  if (!ast.loc) {\n    throw new Error(\"AST is missing location information.\");\n  }\n\n  if (!ast.range) {\n    throw new Error(\"AST is missing range information\");\n  }\n}\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\n\n\nfunction looksLikeExport(astNode) {\n  return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" || astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\n\n\nfunction sortedMerge(tokens, comments) {\n  const result = [];\n  let tokenIndex = 0;\n  let commentIndex = 0;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n      result.push(tokens[tokenIndex++]);\n    } else {\n      result.push(comments[commentIndex++]);\n    }\n  }\n\n  return result;\n}\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\n\n\nfunction nodesOrTokensOverlap(first, second) {\n  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];\n}\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\n\n\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n  if (nodesOrTokensOverlap(first, second)) {\n    return false;\n  }\n\n  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];\n  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n  let currentToken = firstToken;\n\n  while (currentToken !== finalToken) {\n    const nextToken = sourceCode.getTokenAfter(currentToken, {\n      includeComments: true\n    });\n\n    if (currentToken.range[1] !== nextToken.range[0] ||\n    /*\n     * For backward compatibility, check speces in JSXText.\n     * https://github.com/eslint/eslint/issues/12614\n     */\n    checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === \"JSXText\" && /\\s/u.test(nextToken.value)) {\n      return true;\n    }\n\n    currentToken = nextToken;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nclass SourceCode extends TokenStore {\n  /**\n   * Represents parsed source code.\n   * @param {string|Object} textOrConfig The source code text or config object.\n   * @param {string} textOrConfig.text The source code text.\n   * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   * @param {Object|null} textOrConfig.parserServices The parser services.\n   * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n   * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n   * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n   */\n  constructor(textOrConfig, astIfNoConfig) {\n    let text, ast, parserServices, scopeManager, visitorKeys; // Process overloading.\n\n    if (typeof textOrConfig === \"string\") {\n      text = textOrConfig;\n      ast = astIfNoConfig;\n    } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n      text = textOrConfig.text;\n      ast = textOrConfig.ast;\n      parserServices = textOrConfig.parserServices;\n      scopeManager = textOrConfig.scopeManager;\n      visitorKeys = textOrConfig.visitorKeys;\n    }\n\n    validate(ast);\n    super(ast.tokens, ast.comments);\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type boolean\n     */\n\n    this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type string\n     */\n\n    this.text = this.hasBOM ? text.slice(1) : text;\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n\n    this.ast = ast;\n    /**\n     * The parser services of this source code.\n     * @type {Object}\n     */\n\n    this.parserServices = parserServices || {};\n    /**\n     * The scope of this source code.\n     * @type {ScopeManager|null}\n     */\n\n    this.scopeManager = scopeManager || null;\n    /**\n     * The visitor keys to traverse AST.\n     * @type {Object}\n     */\n\n    this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS; // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n\n    const shebangMatched = this.text.match(astUtils.shebangPattern);\n    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n    if (hasShebang) {\n      ast.comments[0].type = \"Shebang\";\n    }\n\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n\n    this.lines = [];\n    this.lineStartIndices = [0];\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n    /*\n     * Previously, this was implemented using a regex that\n     * matched a sequence of non-linebreak characters followed by a\n     * linebreak, then adding the lengths of the matches. However,\n     * this caused a catastrophic backtracking issue when the end\n     * of a file contained a large number of non-newline characters.\n     * To avoid this, the current implementation just matches newlines\n     * and uses match.index to get the correct line start indices.\n     */\n\n    while (match = lineEndingPattern.exec(this.text)) {\n      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n      this.lineStartIndices.push(match.index + match[0].length);\n    }\n\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1])); // Cache for comments found using getComments().\n\n    this._commentCache = new WeakMap(); // don't allow modification of this object\n\n    Object.freeze(this);\n    Object.freeze(this.lines);\n  }\n  /**\n   * Split the source code into multiple lines based on the line delimiters.\n   * @param {string} text Source code as a string.\n   * @returns {string[]} Array of source code lines.\n   * @public\n   */\n\n\n  static splitLines(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n  }\n  /**\n   * Gets the source code for the given node.\n   * @param {ASTNode} [node] The AST node to get the text for.\n   * @param {int} [beforeCount] The number of characters before the node to retrieve.\n   * @param {int} [afterCount] The number of characters after the node to retrieve.\n   * @returns {string} The text representing the AST node.\n   * @public\n   */\n\n\n  getText(node, beforeCount, afterCount) {\n    if (node) {\n      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));\n    }\n\n    return this.text;\n  }\n  /**\n   * Gets the entire source text split into an array of lines.\n   * @returns {Array} The source text as an array of lines.\n   * @public\n   */\n\n\n  getLines() {\n    return this.lines;\n  }\n  /**\n   * Retrieves an array containing all comments in the source code.\n   * @returns {ASTNode[]} An array of comment nodes.\n   * @public\n   */\n\n\n  getAllComments() {\n    return this.ast.comments;\n  }\n  /**\n   * Gets all comments for the given node.\n   * @param {ASTNode} node The AST node to get the comments for.\n   * @returns {Object} An object containing a leading and trailing array\n   *      of comments indexed by their position.\n   * @public\n   */\n\n\n  getComments(node) {\n    if (this._commentCache.has(node)) {\n      return this._commentCache.get(node);\n    }\n\n    const comments = {\n      leading: [],\n      trailing: []\n    };\n    /*\n     * Return all comments as leading comments of the Program node when\n     * there is no executable code.\n     */\n\n    if (node.type === \"Program\") {\n      if (node.body.length === 0) {\n        comments.leading = node.comments;\n      }\n    } else {\n      /*\n       * Return comments as trailing comments of nodes that only contain\n       * comments (to mimic the comment attachment behavior present in Espree).\n       */\n      if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 || node.type === \"ObjectExpression\" && node.properties.length === 0 || node.type === \"ArrayExpression\" && node.elements.length === 0 || node.type === \"SwitchStatement\" && node.cases.length === 0) {\n        comments.trailing = this.getTokens(node, {\n          includeComments: true,\n          filter: isCommentToken\n        });\n      }\n      /*\n       * Iterate over tokens before and after node and collect comment tokens.\n       * Do not include comments that exist outside of the parent node\n       * to avoid duplication.\n       */\n\n\n      let currentToken = this.getTokenBefore(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && currentToken.start < node.parent.start) {\n          break;\n        }\n\n        comments.leading.push(currentToken);\n        currentToken = this.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      }\n\n      comments.leading.reverse();\n      currentToken = this.getTokenAfter(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && currentToken.end > node.parent.end) {\n          break;\n        }\n\n        comments.trailing.push(currentToken);\n        currentToken = this.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      }\n    }\n\n    this._commentCache.set(node, comments);\n\n    return comments;\n  }\n  /**\n   * Retrieves the JSDoc comment for a given node.\n   * @param {ASTNode} node The AST node to get the comment for.\n   * @returns {Token|null} The Block comment token containing the JSDoc comment\n   *      for the given node or null if not found.\n   * @public\n   * @deprecated\n   */\n\n\n  getJSDocComment(node) {\n    /**\n     * Checks for the presence of a JSDoc comment for the given node and returns it.\n     * @param {ASTNode} astNode The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @private\n     */\n    const findJSDocComment = astNode => {\n      const tokenBefore = this.getTokenBefore(astNode, {\n        includeComments: true\n      });\n\n      if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === \"Block\" && tokenBefore.value.charAt(0) === \"*\" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {\n        return tokenBefore;\n      }\n\n      return null;\n    };\n\n    let parent = node.parent;\n\n    switch (node.type) {\n      case \"ClassDeclaration\":\n      case \"FunctionDeclaration\":\n        return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n      case \"ClassExpression\":\n        return findJSDocComment(parent.parent);\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n            parent = parent.parent;\n\n            if (!parent) {\n              break;\n            }\n          }\n\n          if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n            return findJSDocComment(parent);\n          }\n        }\n\n        return findJSDocComment(node);\n      // falls through\n\n      default:\n        return null;\n    }\n  }\n  /**\n   * Gets the deepest node containing a range index.\n   * @param {int} index Range index of the desired node.\n   * @returns {ASTNode} The node if found or null if not found.\n   * @public\n   */\n\n\n  getNodeByRangeIndex(index) {\n    let result = null;\n    Traverser.traverse(this.ast, {\n      visitorKeys: this.visitorKeys,\n\n      enter(node) {\n        if (node.range[0] <= index && index < node.range[1]) {\n          result = node;\n        } else {\n          this.skip();\n        }\n      },\n\n      leave(node) {\n        if (node === result) {\n          this.break();\n        }\n      }\n\n    });\n    return result;\n  }\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @public\n   */\n\n\n  isSpaceBetween(first, second) {\n    return isSpaceBetween(this, first, second, false);\n  }\n  /**\n   * Determines if two nodes or tokens have at least one whitespace character\n   * between them. Order does not matter. Returns false if the given nodes or\n   * tokens overlap.\n   * For backward compatibility, this method returns true if there are\n   * `JSXText` tokens that contain whitespaces between the two.\n   * @param {ASTNode|Token} first The first node or token to check between.\n   * @param {ASTNode|Token} second The second node or token to check between.\n   * @returns {boolean} True if there is a whitespace character between\n   * any of the tokens found between the two given nodes or tokens.\n   * @deprecated in favor of isSpaceBetween().\n   * @public\n   */\n\n\n  isSpaceBetweenTokens(first, second) {\n    return isSpaceBetween(this, first, second, true);\n  }\n  /**\n   * Converts a source text index into a (line, column) pair.\n   * @param {number} index The index of a character in a file\n   * @returns {Object} A {line, column} location object with a 0-indexed column\n   * @public\n   */\n\n\n  getLocFromIndex(index) {\n    if (typeof index !== \"number\") {\n      throw new TypeError(\"Expected `index` to be a number.\");\n    }\n\n    if (index < 0 || index > this.text.length) {\n      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n    }\n    /*\n     * For an argument of this.text.length, return the location one \"spot\" past the last character\n     * of the file. If the last character is a linebreak, the location will be column 0 of the next\n     * line; otherwise, the location will be in the next column on the same line.\n     *\n     * See getIndexFromLoc for the motivation for this special case.\n     */\n\n\n    if (index === this.text.length) {\n      return {\n        line: this.lines.length,\n        column: this.lines[this.lines.length - 1].length\n      };\n    }\n    /*\n     * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n     * be inserted into lineIndices to keep the list sorted.\n     */\n\n\n    const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);\n    return {\n      line: lineNumber,\n      column: index - this.lineStartIndices[lineNumber - 1]\n    };\n  }\n  /**\n   * Converts a (line, column) pair into a range index.\n   * @param {Object} loc A line/column location\n   * @param {number} loc.line The line number of the location (1-indexed)\n   * @param {number} loc.column The column number of the location (0-indexed)\n   * @returns {number} The range index of the location in the file.\n   * @public\n   */\n\n\n  getIndexFromLoc(loc) {\n    if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n      throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n    }\n\n    if (loc.line <= 0) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n    }\n\n    if (loc.line > this.lineStartIndices.length) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n    }\n\n    const lineStartIndex = this.lineStartIndices[loc.line - 1];\n    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n    const positionIndex = lineStartIndex + loc.column;\n    /*\n     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n     * the given line, provided that the line number is valid element of this.lines. Since the\n     * last element of this.lines is an empty string for files with trailing newlines, add a\n     * special case where getting the index for the first location after the end of the file\n     * will return the length of the file, rather than throwing an error. This allows rules to\n     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n     */\n\n    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {\n      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n    }\n\n    return positionIndex;\n  }\n\n}\n\nmodule.exports = SourceCode;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/source-code/source-code.js"],"names":["isCommentToken","require","TokenStore","astUtils","Traverser","lodash","validate","ast","tokens","Error","comments","loc","range","looksLikeExport","astNode","type","sortedMerge","result","tokenIndex","commentIndex","length","push","nodesOrTokensOverlap","first","second","isSpaceBetween","sourceCode","checkInsideOfJSXText","startingNodeOrToken","endingNodeOrToken","firstToken","getLastToken","finalToken","getFirstToken","currentToken","nextToken","getTokenAfter","includeComments","test","value","SourceCode","constructor","textOrConfig","astIfNoConfig","text","parserServices","scopeManager","visitorKeys","hasBOM","charCodeAt","slice","DEFAULT_VISITOR_KEYS","shebangMatched","match","shebangPattern","hasShebang","tokensAndComments","lines","lineStartIndices","lineEndingPattern","createGlobalLinebreakMatcher","exec","index","_commentCache","WeakMap","Object","freeze","splitLines","split","getText","node","beforeCount","afterCount","Math","max","getLines","getAllComments","getComments","has","get","leading","trailing","body","properties","elements","cases","getTokens","filter","getTokenBefore","parent","start","reverse","end","set","getJSDocComment","findJSDocComment","tokenBefore","charAt","line","getCommentsBefore","getNodeByRangeIndex","traverse","enter","skip","leave","break","isSpaceBetweenTokens","getLocFromIndex","TypeError","RangeError","column","lineNumber","sortedLastIndex","getIndexFromLoc","lineStartIndex","lineEndIndex","positionIndex","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    { isCommentToken } = require(\"eslint-utils\"),\n    TokenStore = require(\"./token-store\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    Traverser = require(\"../shared/traverser\"),\n    lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n    if (nodesOrTokensOverlap(first, second)) {\n        return false;\n    }\n\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\n        ? [first, second]\n        : [second, first];\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n    let currentToken = firstToken;\n\n    while (currentToken !== finalToken) {\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n\n        if (\n            currentToken.range[1] !== nextToken.range[0] ||\n\n                /*\n                 * For backward compatibility, check speces in JSXText.\n                 * https://github.com/eslint/eslint/issues/12614\n                 */\n                (\n                    checkInsideOfJSXText &&\n                    nextToken !== finalToken &&\n                    nextToken.type === \"JSXText\" &&\n                    /\\s/u.test(nextToken.value)\n                )\n        ) {\n            return true;\n        }\n\n        currentToken = nextToken;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass SourceCode extends TokenStore {\n\n    /**\n     * Represents parsed source code.\n     * @param {string|Object} textOrConfig The source code text or config object.\n     * @param {string} textOrConfig.text The source code text.\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {Object|null} textOrConfig.parserServices The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading.\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type boolean\n         */\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type string\n         */\n        this.text = (this.hasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type ASTNode\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type string[]\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n        // Cache for comments found using getComments().\n        this._commentCache = new WeakMap();\n\n        // don't allow modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode} [node] The AST node to get the text for.\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} An object containing a leading and trailing array\n     *      of comments indexed by their position.\n     * @public\n     */\n    getComments(node) {\n        if (this._commentCache.has(node)) {\n            return this._commentCache.get(node);\n        }\n\n        const comments = {\n            leading: [],\n            trailing: []\n        };\n\n        /*\n         * Return all comments as leading comments of the Program node when\n         * there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                comments.leading = node.comments;\n            }\n        } else {\n\n            /*\n             * Return comments as trailing comments of nodes that only contain\n             * comments (to mimic the comment attachment behavior present in Espree).\n             */\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\n                node.type === \"SwitchStatement\" && node.cases.length === 0\n            ) {\n                comments.trailing = this.getTokens(node, {\n                    includeComments: true,\n                    filter: isCommentToken\n                });\n            }\n\n            /*\n             * Iterate over tokens before and after node and collect comment tokens.\n             * Do not include comments that exist outside of the parent node\n             * to avoid duplication.\n             */\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && (currentToken.start < node.parent.start)) {\n                    break;\n                }\n                comments.leading.push(currentToken);\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\n            }\n\n            comments.leading.reverse();\n\n            currentToken = this.getTokenAfter(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && (currentToken.end > node.parent.end)) {\n                    break;\n                }\n                comments.trailing.push(currentToken);\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\n            }\n        }\n\n        this._commentCache.set(node, comments);\n        return comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @public\n     */\n    isSpaceBetween(first, second) {\n        return isSpaceBetween(this, first, second, false);\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespaces between the two.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween().\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        return isSpaceBetween(this, first, second, true);\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n         * be inserted into lineIndices to keep the list sorted.\n         */\n        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n}\n\nmodule.exports = SourceCode;\n"]},"metadata":{},"sourceType":"script"}