{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\n\nfunction isInitOfForStatement(node) {\n  return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\n\n\nfunction canBecomeVariableDeclaration(identifier) {\n  let node = identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  return node.type === \"VariableDeclarator\" || node.type === \"AssignmentExpression\" && node.parent.type === \"ExpressionStatement\" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);\n}\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\n\n\nfunction isOuterVariableInDestructing(name, initScope) {\n  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n    return true;\n  }\n\n  const variable = astUtils.getVariableByName(initScope, name);\n\n  if (variable !== null) {\n    return variable.defs.some(def => def.type === \"Parameter\");\n  }\n\n  return false;\n}\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\n\n\nfunction getDestructuringHost(reference) {\n  if (!reference.isWrite()) {\n    return null;\n  }\n\n  let node = reference.identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n    return null;\n  }\n\n  return node;\n}\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\n\n\nfunction hasMemberExpressionAssignment(node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      return node.properties.some(prop => {\n        if (prop) {\n          /*\n           * Spread elements have an argument property while\n           * others have a value property. Because different\n           * parsers use different node types for spread elements,\n           * we just check if there is an argument property.\n           */\n          return hasMemberExpressionAssignment(prop.argument || prop.value);\n        }\n\n        return false;\n      });\n\n    case \"ArrayPattern\":\n      return node.elements.some(element => {\n        if (element) {\n          return hasMemberExpressionAssignment(element);\n        }\n\n        return false;\n      });\n\n    case \"AssignmentPattern\":\n      return hasMemberExpressionAssignment(node.left);\n\n    case \"MemberExpression\":\n      return true;\n    // no default\n  }\n\n  return false;\n}\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\n\n\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n  if (variable.eslintUsed && variable.scope.type === \"global\") {\n    return null;\n  } // Finds the unique WriteReference.\n\n\n  let writer = null;\n  let isReadBeforeInit = false;\n  const references = variable.references;\n\n  for (let i = 0; i < references.length; ++i) {\n    const reference = references[i];\n\n    if (reference.isWrite()) {\n      const isReassigned = writer !== null && writer.identifier !== reference.identifier;\n\n      if (isReassigned) {\n        return null;\n      }\n\n      const destructuringHost = getDestructuringHost(reference);\n\n      if (destructuringHost !== null && destructuringHost.left !== void 0) {\n        const leftNode = destructuringHost.left;\n        let hasOuterVariables = false,\n            hasNonIdentifiers = false;\n\n        if (leftNode.type === \"ObjectPattern\") {\n          const properties = leftNode.properties;\n          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        } else if (leftNode.type === \"ArrayPattern\") {\n          const elements = leftNode.elements;\n          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        }\n\n        if (hasOuterVariables || hasNonIdentifiers) {\n          return null;\n        }\n      }\n\n      writer = reference;\n    } else if (reference.isRead() && writer === null) {\n      if (ignoreReadBeforeAssign) {\n        return null;\n      }\n\n      isReadBeforeInit = true;\n    }\n  }\n  /*\n   * If the assignment is from a different scope, ignore it.\n   * If the assignment cannot change to a declaration, ignore it.\n   */\n\n\n  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);\n\n  if (!shouldBeConst) {\n    return null;\n  }\n\n  if (isReadBeforeInit) {\n    return variable.defs[0].name;\n  }\n\n  return writer.identifier;\n}\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\n\n\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n  const identifierMap = new Map();\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n    const references = variable.references;\n    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n    let prevId = null;\n\n    for (let j = 0; j < references.length; ++j) {\n      const reference = references[j];\n      const id = reference.identifier;\n      /*\n       * Avoid counting a reference twice or more for default values of\n       * destructuring.\n       */\n\n      if (id === prevId) {\n        continue;\n      }\n\n      prevId = id; // Add the identifier node into the destructuring group.\n\n      const group = getDestructuringHost(reference);\n\n      if (group) {\n        if (identifierMap.has(group)) {\n          identifierMap.get(group).push(identifier);\n        } else {\n          identifierMap.set(group, [identifier]);\n        }\n      }\n    }\n  }\n\n  return identifierMap;\n}\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\n\n\nfunction findUp(node, type, shouldStop) {\n  if (!node || shouldStop(node)) {\n    return null;\n  }\n\n  if (node.type === type) {\n    return node;\n  }\n\n  return findUp(node.parent, type, shouldStop);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `const` declarations for variables that are never reassigned after declared\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-const\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        destructuring: {\n          enum: [\"any\", \"all\"],\n          default: \"any\"\n        },\n        ignoreReadBeforeAssign: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const sourceCode = context.getSourceCode();\n    const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n    const variables = [];\n    let reportCount = 0;\n    let checkedId = null;\n    let checkedName = \"\";\n    /**\n     * Reports given identifier nodes if all of the nodes should be declared\n     * as const.\n     *\n     * The argument 'nodes' is an array of Identifier nodes.\n     * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n     * nullable. In simple declaration or assignment cases, the length of\n     * the array is 1. In destructuring cases, the length of the array can\n     * be 2 or more.\n     * @param {(eslint-scope.Reference|null)[]} nodes\n     *      References which are grouped by destructuring to report.\n     * @returns {void}\n     */\n\n    function checkGroup(nodes) {\n      const nodesToReport = nodes.filter(Boolean);\n\n      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n        const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n        const isVarDecParentNull = varDeclParent === null;\n\n        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n          const firstDeclaration = varDeclParent.declarations[0];\n\n          if (firstDeclaration.init) {\n            const firstDecParent = firstDeclaration.init.parent;\n            /*\n             * First we check the declaration type and then depending on\n             * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n             * we compare the name and id from the first identifier, if the names are different\n             * we assign the new name, id and reset the count of reportCount and nodeCount in\n             * order to check each block for the number of reported errors and base our fix\n             * based on comparing nodes.length and nodesToReport.length.\n             */\n\n            if (firstDecParent.type === \"VariableDeclarator\") {\n              if (firstDecParent.id.name !== checkedName) {\n                checkedName = firstDecParent.id.name;\n                reportCount = 0;\n              }\n\n              if (firstDecParent.id.type === \"ObjectPattern\") {\n                if (firstDecParent.init.name !== checkedName) {\n                  checkedName = firstDecParent.init.name;\n                  reportCount = 0;\n                }\n              }\n\n              if (firstDecParent.id !== checkedId) {\n                checkedId = firstDecParent.id;\n                reportCount = 0;\n              }\n            }\n          }\n        }\n\n        let shouldFix = varDeclParent && ( // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n        varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations.every(declaration => declaration.init)) &&\n        /*\n         * If options.destructuring is \"all\", then this warning will not occur unless\n         * every assignment in the destructuring should be const. In that case, it's safe\n         * to apply the fix.\n         */\n        nodesToReport.length === nodes.length;\n\n        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n            /*\n             * Add nodesToReport.length to a count, then comparing the count to the length\n             * of the declarations in the current block.\n             */\n            reportCount += nodesToReport.length;\n            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;\n          }\n        }\n\n        nodesToReport.forEach(node => {\n          context.report({\n            node,\n            messageId: \"useConst\",\n            data: node,\n            fix: shouldFix ? fixer => fixer.replaceText(sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind), \"const\") : null\n          });\n        });\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n      },\n\n      VariableDeclaration(node) {\n        if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n          variables.push(...context.getDeclaredVariables(node));\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-const.js"],"names":["astUtils","require","PATTERN_TYPE","DECLARATION_HOST_TYPE","DESTRUCTURING_HOST_TYPE","isInitOfForStatement","node","parent","type","init","canBecomeVariableDeclaration","identifier","test","isOuterVariableInDestructing","name","initScope","through","find","ref","resolved","variable","getVariableByName","defs","some","def","getDestructuringHost","reference","isWrite","hasMemberExpressionAssignment","properties","prop","argument","value","elements","element","left","getIdentifierIfShouldBeConst","ignoreReadBeforeAssign","eslintUsed","scope","writer","isReadBeforeInit","references","i","length","isReassigned","destructuringHost","leftNode","hasOuterVariables","hasNonIdentifiers","filter","map","isRead","shouldBeConst","from","groupByDestructuring","variables","identifierMap","Map","prevId","j","id","group","has","get","push","set","findUp","shouldStop","module","exports","meta","docs","description","category","recommended","url","fixable","schema","destructuring","enum","default","additionalProperties","messages","useConst","create","context","options","sourceCode","getSourceCode","shouldMatchAnyDestructuredVariable","reportCount","checkedId","checkedName","checkGroup","nodes","nodesToReport","Boolean","varDeclParent","parentNode","endsWith","isVarDecParentNull","declarations","firstDeclaration","firstDecParent","shouldFix","every","declaration","forEach","report","messageId","data","fix","fixer","replaceText","getFirstToken","t","kind","VariableDeclaration","getDeclaredVariables"],"mappings":"AAAA;;;;AAKA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEA,MAAMC,YAAY,GAAG,gFAArB;AACA,MAAMC,qBAAqB,GAAG,0CAA9B;AACA,MAAMC,uBAAuB,GAAG,gDAAhC;AAEA;;;;;;AAKA,SAASC,oBAAT,CAA8BC,IAA9B,EAAoC;AAChC,SAAOA,IAAI,CAACC,MAAL,CAAYC,IAAZ,KAAqB,cAArB,IAAuCF,IAAI,CAACC,MAAL,CAAYE,IAAZ,KAAqBH,IAAnE;AACH;AAED;;;;;;;AAKA,SAASI,4BAAT,CAAsCC,UAAtC,EAAkD;AAC9C,MAAIL,IAAI,GAAGK,UAAU,CAACJ,MAAtB;;AAEA,SAAOL,YAAY,CAACU,IAAb,CAAkBN,IAAI,CAACE,IAAvB,CAAP,EAAqC;AACjCF,IAAAA,IAAI,GAAGA,IAAI,CAACC,MAAZ;AACH;;AAED,SACID,IAAI,CAACE,IAAL,KAAc,oBAAd,IAEIF,IAAI,CAACE,IAAL,KAAc,sBAAd,IACAF,IAAI,CAACC,MAAL,CAAYC,IAAZ,KAAqB,qBADrB,IAEAL,qBAAqB,CAACS,IAAtB,CAA2BN,IAAI,CAACC,MAAL,CAAYA,MAAZ,CAAmBC,IAA9C,CALR;AAQH;AAED;;;;;;;;;AAOA,SAASK,4BAAT,CAAsCC,IAAtC,EAA4CC,SAA5C,EAAuD;AAEnD,MAAIA,SAAS,CAACC,OAAV,CAAkBC,IAAlB,CAAuBC,GAAG,IAAIA,GAAG,CAACC,QAAJ,IAAgBD,GAAG,CAACC,QAAJ,CAAaL,IAAb,KAAsBA,IAApE,CAAJ,EAA+E;AAC3E,WAAO,IAAP;AACH;;AAED,QAAMM,QAAQ,GAAGpB,QAAQ,CAACqB,iBAAT,CAA2BN,SAA3B,EAAsCD,IAAtC,CAAjB;;AAEA,MAAIM,QAAQ,KAAK,IAAjB,EAAuB;AACnB,WAAOA,QAAQ,CAACE,IAAT,CAAcC,IAAd,CAAmBC,GAAG,IAAIA,GAAG,CAAChB,IAAJ,KAAa,WAAvC,CAAP;AACH;;AAED,SAAO,KAAP;AACH;AAED;;;;;;;;;;;AASA,SAASiB,oBAAT,CAA8BC,SAA9B,EAAyC;AACrC,MAAI,CAACA,SAAS,CAACC,OAAV,EAAL,EAA0B;AACtB,WAAO,IAAP;AACH;;AACD,MAAIrB,IAAI,GAAGoB,SAAS,CAACf,UAAV,CAAqBJ,MAAhC;;AAEA,SAAOL,YAAY,CAACU,IAAb,CAAkBN,IAAI,CAACE,IAAvB,CAAP,EAAqC;AACjCF,IAAAA,IAAI,GAAGA,IAAI,CAACC,MAAZ;AACH;;AAED,MAAI,CAACH,uBAAuB,CAACQ,IAAxB,CAA6BN,IAAI,CAACE,IAAlC,CAAL,EAA8C;AAC1C,WAAO,IAAP;AACH;;AACD,SAAOF,IAAP;AACH;AAED;;;;;;;;;;;AASA,SAASsB,6BAAT,CAAuCtB,IAAvC,EAA6C;AACzC,UAAQA,IAAI,CAACE,IAAb;AACI,SAAK,eAAL;AACI,aAAOF,IAAI,CAACuB,UAAL,CAAgBN,IAAhB,CAAqBO,IAAI,IAAI;AAChC,YAAIA,IAAJ,EAAU;AAEN;;;;;;AAMA,iBAAOF,6BAA6B,CAACE,IAAI,CAACC,QAAL,IAAiBD,IAAI,CAACE,KAAvB,CAApC;AACH;;AAED,eAAO,KAAP;AACH,OAbM,CAAP;;AAeJ,SAAK,cAAL;AACI,aAAO1B,IAAI,CAAC2B,QAAL,CAAcV,IAAd,CAAmBW,OAAO,IAAI;AACjC,YAAIA,OAAJ,EAAa;AACT,iBAAON,6BAA6B,CAACM,OAAD,CAApC;AACH;;AAED,eAAO,KAAP;AACH,OANM,CAAP;;AAQJ,SAAK,mBAAL;AACI,aAAON,6BAA6B,CAACtB,IAAI,CAAC6B,IAAN,CAApC;;AAEJ,SAAK,kBAAL;AACI,aAAO,IAAP;AAEJ;AAhCJ;;AAmCA,SAAO,KAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAASC,4BAAT,CAAsChB,QAAtC,EAAgDiB,sBAAhD,EAAwE;AACpE,MAAIjB,QAAQ,CAACkB,UAAT,IAAuBlB,QAAQ,CAACmB,KAAT,CAAe/B,IAAf,KAAwB,QAAnD,EAA6D;AACzD,WAAO,IAAP;AACH,GAHmE,CAKpE;;;AACA,MAAIgC,MAAM,GAAG,IAAb;AACA,MAAIC,gBAAgB,GAAG,KAAvB;AACA,QAAMC,UAAU,GAAGtB,QAAQ,CAACsB,UAA5B;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACE,MAA/B,EAAuC,EAAED,CAAzC,EAA4C;AACxC,UAAMjB,SAAS,GAAGgB,UAAU,CAACC,CAAD,CAA5B;;AAEA,QAAIjB,SAAS,CAACC,OAAV,EAAJ,EAAyB;AACrB,YAAMkB,YAAY,GACdL,MAAM,KAAK,IAAX,IACAA,MAAM,CAAC7B,UAAP,KAAsBe,SAAS,CAACf,UAFpC;;AAKA,UAAIkC,YAAJ,EAAkB;AACd,eAAO,IAAP;AACH;;AAED,YAAMC,iBAAiB,GAAGrB,oBAAoB,CAACC,SAAD,CAA9C;;AAEA,UAAIoB,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,CAACX,IAAlB,KAA2B,KAAK,CAAlE,EAAqE;AACjE,cAAMY,QAAQ,GAAGD,iBAAiB,CAACX,IAAnC;AACA,YAAIa,iBAAiB,GAAG,KAAxB;AAAA,YACIC,iBAAiB,GAAG,KADxB;;AAGA,YAAIF,QAAQ,CAACvC,IAAT,KAAkB,eAAtB,EAAuC;AACnC,gBAAMqB,UAAU,GAAGkB,QAAQ,CAAClB,UAA5B;AAEAmB,UAAAA,iBAAiB,GAAGnB,UAAU,CACzBqB,MADe,CACRpB,IAAI,IAAIA,IAAI,CAACE,KADL,EAEfmB,GAFe,CAEXrB,IAAI,IAAIA,IAAI,CAACE,KAAL,CAAWlB,IAFR,EAGfS,IAHe,CAGVT,IAAI,IAAID,4BAA4B,CAACC,IAAD,EAAOM,QAAQ,CAACmB,KAAhB,CAH1B,CAApB;AAKAU,UAAAA,iBAAiB,GAAGrB,6BAA6B,CAACmB,QAAD,CAAjD;AAEH,SAVD,MAUO,IAAIA,QAAQ,CAACvC,IAAT,KAAkB,cAAtB,EAAsC;AACzC,gBAAMyB,QAAQ,GAAGc,QAAQ,CAACd,QAA1B;AAEAe,UAAAA,iBAAiB,GAAGf,QAAQ,CACvBkB,GADe,CACXjB,OAAO,IAAIA,OAAO,IAAIA,OAAO,CAACpB,IADnB,EAEfS,IAFe,CAEVT,IAAI,IAAID,4BAA4B,CAACC,IAAD,EAAOM,QAAQ,CAACmB,KAAhB,CAF1B,CAApB;AAIAU,UAAAA,iBAAiB,GAAGrB,6BAA6B,CAACmB,QAAD,CAAjD;AACH;;AAED,YAAIC,iBAAiB,IAAIC,iBAAzB,EAA4C;AACxC,iBAAO,IAAP;AACH;AAEJ;;AAEDT,MAAAA,MAAM,GAAGd,SAAT;AAEH,KA7CD,MA6CO,IAAIA,SAAS,CAAC0B,MAAV,MAAsBZ,MAAM,KAAK,IAArC,EAA2C;AAC9C,UAAIH,sBAAJ,EAA4B;AACxB,eAAO,IAAP;AACH;;AACDI,MAAAA,gBAAgB,GAAG,IAAnB;AACH;AACJ;AAED;;;;;;AAIA,QAAMY,aAAa,GACfb,MAAM,KAAK,IAAX,IACAA,MAAM,CAACc,IAAP,KAAgBlC,QAAQ,CAACmB,KADzB,IAEA7B,4BAA4B,CAAC8B,MAAM,CAAC7B,UAAR,CAHhC;;AAMA,MAAI,CAAC0C,aAAL,EAAoB;AAChB,WAAO,IAAP;AACH;;AAED,MAAIZ,gBAAJ,EAAsB;AAClB,WAAOrB,QAAQ,CAACE,IAAT,CAAc,CAAd,EAAiBR,IAAxB;AACH;;AAED,SAAO0B,MAAM,CAAC7B,UAAd;AACH;AAED;;;;;;;;;;;;AAUA,SAAS4C,oBAAT,CAA8BC,SAA9B,EAAyCnB,sBAAzC,EAAiE;AAC7D,QAAMoB,aAAa,GAAG,IAAIC,GAAJ,EAAtB;;AAEA,OAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGa,SAAS,CAACZ,MAA9B,EAAsC,EAAED,CAAxC,EAA2C;AACvC,UAAMvB,QAAQ,GAAGoC,SAAS,CAACb,CAAD,CAA1B;AACA,UAAMD,UAAU,GAAGtB,QAAQ,CAACsB,UAA5B;AACA,UAAM/B,UAAU,GAAGyB,4BAA4B,CAAChB,QAAD,EAAWiB,sBAAX,CAA/C;AACA,QAAIsB,MAAM,GAAG,IAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,UAAU,CAACE,MAA/B,EAAuC,EAAEgB,CAAzC,EAA4C;AACxC,YAAMlC,SAAS,GAAGgB,UAAU,CAACkB,CAAD,CAA5B;AACA,YAAMC,EAAE,GAAGnC,SAAS,CAACf,UAArB;AAEA;;;;;AAIA,UAAIkD,EAAE,KAAKF,MAAX,EAAmB;AACf;AACH;;AACDA,MAAAA,MAAM,GAAGE,EAAT,CAXwC,CAaxC;;AACA,YAAMC,KAAK,GAAGrC,oBAAoB,CAACC,SAAD,CAAlC;;AAEA,UAAIoC,KAAJ,EAAW;AACP,YAAIL,aAAa,CAACM,GAAd,CAAkBD,KAAlB,CAAJ,EAA8B;AAC1BL,UAAAA,aAAa,CAACO,GAAd,CAAkBF,KAAlB,EAAyBG,IAAzB,CAA8BtD,UAA9B;AACH,SAFD,MAEO;AACH8C,UAAAA,aAAa,CAACS,GAAd,CAAkBJ,KAAlB,EAAyB,CAACnD,UAAD,CAAzB;AACH;AACJ;AACJ;AACJ;;AAED,SAAO8C,aAAP;AACH;AAED;;;;;;;;;AAOA,SAASU,MAAT,CAAgB7D,IAAhB,EAAsBE,IAAtB,EAA4B4D,UAA5B,EAAwC;AACpC,MAAI,CAAC9D,IAAD,IAAS8D,UAAU,CAAC9D,IAAD,CAAvB,EAA+B;AAC3B,WAAO,IAAP;AACH;;AACD,MAAIA,IAAI,CAACE,IAAL,KAAcA,IAAlB,EAAwB;AACpB,WAAOF,IAAP;AACH;;AACD,SAAO6D,MAAM,CAAC7D,IAAI,CAACC,MAAN,EAAcC,IAAd,EAAoB4D,UAApB,CAAb;AACH,C,CAED;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACF/D,IAAAA,IAAI,EAAE,YADJ;AAGFgE,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,qFADX;AAEFC,MAAAA,QAAQ,EAAE,cAFR;AAGFC,MAAAA,WAAW,EAAE,KAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,OAAO,EAAE,MAVP;AAYFC,IAAAA,MAAM,EAAE,CACJ;AACItE,MAAAA,IAAI,EAAE,QADV;AAEIqB,MAAAA,UAAU,EAAE;AACRkD,QAAAA,aAAa,EAAE;AAAEC,UAAAA,IAAI,EAAE,CAAC,KAAD,EAAQ,KAAR,CAAR;AAAwBC,UAAAA,OAAO,EAAE;AAAjC,SADP;AAER5C,QAAAA,sBAAsB,EAAE;AAAE7B,UAAAA,IAAI,EAAE,SAAR;AAAmByE,UAAAA,OAAO,EAAE;AAA5B;AAFhB,OAFhB;AAMIC,MAAAA,oBAAoB,EAAE;AAN1B,KADI,CAZN;AAsBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,EAAE;AADJ;AAtBR,GADO;;AA4BbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,OAAO,GAAGD,OAAO,CAACC,OAAR,CAAgB,CAAhB,KAAsB,EAAtC;AACA,UAAMC,UAAU,GAAGF,OAAO,CAACG,aAAR,EAAnB;AACA,UAAMC,kCAAkC,GAAGH,OAAO,CAACR,aAAR,KAA0B,KAArE;AACA,UAAM1C,sBAAsB,GAAGkD,OAAO,CAAClD,sBAAR,KAAmC,IAAlE;AACA,UAAMmB,SAAS,GAAG,EAAlB;AACA,QAAImC,WAAW,GAAG,CAAlB;AACA,QAAIC,SAAS,GAAG,IAAhB;AACA,QAAIC,WAAW,GAAG,EAAlB;AAGA;;;;;;;;;;;;;;AAaA,aAASC,UAAT,CAAoBC,KAApB,EAA2B;AACvB,YAAMC,aAAa,GAAGD,KAAK,CAAC7C,MAAN,CAAa+C,OAAb,CAAtB;;AAEA,UAAIF,KAAK,CAACnD,MAAN,KAAiB8C,kCAAkC,IAAIM,aAAa,CAACpD,MAAd,KAAyBmD,KAAK,CAACnD,MAAtF,CAAJ,EAAmG;AAC/F,cAAMsD,aAAa,GAAG/B,MAAM,CAAC4B,KAAK,CAAC,CAAD,CAAN,EAAW,qBAAX,EAAkCI,UAAU,IAAIA,UAAU,CAAC3F,IAAX,CAAgB4F,QAAhB,CAAyB,WAAzB,CAAhD,CAA5B;AACA,cAAMC,kBAAkB,GAAGH,aAAa,KAAK,IAA7C;;AAEA,YAAI,CAACG,kBAAD,IAAuBH,aAAa,CAACI,YAAd,CAA2B1D,MAA3B,GAAoC,CAA/D,EAAkE;AAC9D,gBAAM2D,gBAAgB,GAAGL,aAAa,CAACI,YAAd,CAA2B,CAA3B,CAAzB;;AAEA,cAAIC,gBAAgB,CAAC9F,IAArB,EAA2B;AACvB,kBAAM+F,cAAc,GAAGD,gBAAgB,CAAC9F,IAAjB,CAAsBF,MAA7C;AAEA;;;;;;;;;AASA,gBAAIiG,cAAc,CAAChG,IAAf,KAAwB,oBAA5B,EAAkD;AAE9C,kBAAIgG,cAAc,CAAC3C,EAAf,CAAkB/C,IAAlB,KAA2B+E,WAA/B,EAA4C;AACxCA,gBAAAA,WAAW,GAAGW,cAAc,CAAC3C,EAAf,CAAkB/C,IAAhC;AACA6E,gBAAAA,WAAW,GAAG,CAAd;AACH;;AAED,kBAAIa,cAAc,CAAC3C,EAAf,CAAkBrD,IAAlB,KAA2B,eAA/B,EAAgD;AAC5C,oBAAIgG,cAAc,CAAC/F,IAAf,CAAoBK,IAApB,KAA6B+E,WAAjC,EAA8C;AAC1CA,kBAAAA,WAAW,GAAGW,cAAc,CAAC/F,IAAf,CAAoBK,IAAlC;AACA6E,kBAAAA,WAAW,GAAG,CAAd;AACH;AACJ;;AAED,kBAAIa,cAAc,CAAC3C,EAAf,KAAsB+B,SAA1B,EAAqC;AACjCA,gBAAAA,SAAS,GAAGY,cAAc,CAAC3C,EAA3B;AACA8B,gBAAAA,WAAW,GAAG,CAAd;AACH;AACJ;AACJ;AACJ;;AAED,YAAIc,SAAS,GAAGP,aAAa,MAEzB;AACCA,QAAAA,aAAa,CAAC3F,MAAd,CAAqBC,IAArB,KAA8B,gBAA9B,IAAkD0F,aAAa,CAAC3F,MAAd,CAAqBC,IAArB,KAA8B,gBAAhF,IACG0F,aAAa,CAACI,YAAd,CAA2BI,KAA3B,CAAiCC,WAAW,IAAIA,WAAW,CAAClG,IAA5D,CAJqB,CAAb;AAMZ;;;;;AAKAuF,QAAAA,aAAa,CAACpD,MAAd,KAAyBmD,KAAK,CAACnD,MAXnC;;AAaA,YAAI,CAACyD,kBAAD,IAAuBH,aAAa,CAACI,YAArC,IAAqDJ,aAAa,CAACI,YAAd,CAA2B1D,MAA3B,KAAsC,CAA/F,EAAkG;AAE9F,cAAIsD,aAAa,IAAIA,aAAa,CAACI,YAA/B,IAA+CJ,aAAa,CAACI,YAAd,CAA2B1D,MAA3B,IAAqC,CAAxF,EAA2F;AAEvF;;;;AAKA+C,YAAAA,WAAW,IAAIK,aAAa,CAACpD,MAA7B;AAEA6D,YAAAA,SAAS,GAAGA,SAAS,IAAKd,WAAW,KAAKO,aAAa,CAACI,YAAd,CAA2B1D,MAArE;AACH;AACJ;;AAEDoD,QAAAA,aAAa,CAACY,OAAd,CAAsBtG,IAAI,IAAI;AAC1BgF,UAAAA,OAAO,CAACuB,MAAR,CAAe;AACXvG,YAAAA,IADW;AAEXwG,YAAAA,SAAS,EAAE,UAFA;AAGXC,YAAAA,IAAI,EAAEzG,IAHK;AAIX0G,YAAAA,GAAG,EAAEP,SAAS,GACRQ,KAAK,IAAIA,KAAK,CAACC,WAAN,CACP1B,UAAU,CAAC2B,aAAX,CAAyBjB,aAAzB,EAAwCkB,CAAC,IAAIA,CAAC,CAACpF,KAAF,KAAYkE,aAAa,CAACmB,IAAvE,CADO,EAEP,OAFO,CADD,GAKR;AATK,WAAf;AAWH,SAZD;AAaH;AACJ;;AAED,WAAO;AACH,uBAAiB;AACb9D,QAAAA,oBAAoB,CAACC,SAAD,EAAYnB,sBAAZ,CAApB,CAAwDuE,OAAxD,CAAgEd,UAAhE;AACH,OAHE;;AAKHwB,MAAAA,mBAAmB,CAAChH,IAAD,EAAO;AACtB,YAAIA,IAAI,CAAC+G,IAAL,KAAc,KAAd,IAAuB,CAAChH,oBAAoB,CAACC,IAAD,CAAhD,EAAwD;AACpDkD,UAAAA,SAAS,CAACS,IAAV,CAAe,GAAGqB,OAAO,CAACiC,oBAAR,CAA6BjH,IAA7B,CAAlB;AACH;AACJ;;AATE,KAAP;AAWH;;AAvJY,CAAjB","sourcesContent":["/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n        let reportCount = 0;\n        let checkedId = null;\n        let checkedName = \"\";\n\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         * @param {(eslint-scope.Reference|null)[]} nodes\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name and id from the first identifier, if the names are different\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== checkedName) {\n                                checkedName = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== checkedName) {\n                                    checkedName = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n\n                            if (firstDecParent.id !== checkedId) {\n                                checkedId = firstDecParent.id;\n                                reportCount = 0;\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix\n                            ? fixer => fixer.replaceText(\n                                sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind),\n                                \"const\"\n                            )\n                            : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}