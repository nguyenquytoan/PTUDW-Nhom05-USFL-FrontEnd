{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _reduce = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\"));\n/*!\n * XRegExp.build 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\n\n\nvar _default = function _default(XRegExp) {\n  var REGEX_DATA = 'xregexp';\n  var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    var leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    var trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    var flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[\"subpattern\".concat(subpatternIndex)] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? \"{{subpattern\".concat(subpatternIndex, \"}}\") : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * const h12 = /1[0-2]|0?[1-9]/;\n   * const h24 = /2[0-3]|[01][0-9]/;\n   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n   * const minutes = /^[0-5][0-9]$/;\n   * // Note that explicitly naming the 'minutes' group is required for named backreferences\n   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.tag = function (flags) {\n    return function (literals) {\n      var _context, _context2;\n\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        substitutions[_key - 1] = arguments[_key];\n      }\n\n      var subpatterns = (0, _reduce.default)(_context = (0, _map.default)(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\n      var pattern = (0, _map.default)(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\n      return XRegExp.build(pattern, subpatterns, flags);\n    };\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.build = function (pattern, subs, flags) {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    var addFlagX = (0, _includes.default)(flags).call(flags, 'x');\n    var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    var data = {};\n\n    for (var p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        var sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    var numCaps = 0;\n    var numPriorCaps;\n    var numOuterCaps = 0;\n    var outerCapsMap = [0];\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\n      var subName = $1 || $2;\n      var capName;\n      var intro;\n      var localCapIndex; // Named subpattern\n\n      if (subName) {\n        var _context3;\n\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(\"Undefined property \".concat($0));\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = \"(?<\".concat(capName || subName, \">\");\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return \"(?<\".concat(capName, \">\");\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            \"\\\\k<\".concat(data[subName].names[localCapIndex], \">\") : \"\\\\\".concat(+backref + numPriorCaps);\n          }\n\n          return match;\n        });\n        return (0, _concat.default)(_context3 = \"\".concat(intro)).call(_context3, rewrittenSubpattern, \")\");\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return \"(?<\".concat(capName, \">\");\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        \"\\\\k<\".concat(outerCapNames[localCapIndex], \">\") : \"\\\\\".concat(outerCapsMap[+$4]);\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/xregexp/lib/addons/build.js"],"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_concat","_includes","_map","_reduce","_default","XRegExp","REGEX_DATA","subParts","parts","union","conjunction","deanchor","pattern","leadingAnchor","trailingAnchor","test","replace","asXRegExp","addFlagX","flags","isRegExp","captureNames","source","interpolate","substitution","RegExp","escape","reduceToSubpatternsObject","subpatterns","interpolated","subpatternIndex","concat","embedSubpatternAfter","raw","rawLiterals","hasSubpattern","length","tag","literals","_context","_context2","_len","arguments","substitutions","Array","_key","call","join","build","subs","inlineFlags","exec","_clipDuplicates","data","p","hasOwnProperty","sub","names","patternAsRegex","numCaps","numPriorCaps","numOuterCaps","outerCapsMap","outerCapNames","output","$0","$1","$2","$3","$4","subName","capName","intro","localCapIndex","_context3","ReferenceError","rewrittenSubpattern","match","paren","backref","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _reduce = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\"));\n\n/*!\n * XRegExp.build 4.3.0\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  var REGEX_DATA = 'xregexp';\n  var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    var leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    var trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    var flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[\"subpattern\".concat(subpatternIndex)] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? \"{{subpattern\".concat(subpatternIndex, \"}}\") : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * const h12 = /1[0-2]|0?[1-9]/;\n   * const h24 = /2[0-3]|[01][0-9]/;\n   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n   * const minutes = /^[0-5][0-9]$/;\n   * // Note that explicitly naming the 'minutes' group is required for named backreferences\n   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.tag = function (flags) {\n    return function (literals) {\n      var _context, _context2;\n\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        substitutions[_key - 1] = arguments[_key];\n      }\n\n      var subpatterns = (0, _reduce.default)(_context = (0, _map.default)(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\n      var pattern = (0, _map.default)(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\n      return XRegExp.build(pattern, subpatterns, flags);\n    };\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.build = function (pattern, subs, flags) {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    var addFlagX = (0, _includes.default)(flags).call(flags, 'x');\n    var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    var data = {};\n\n    for (var p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        var sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    var numCaps = 0;\n    var numPriorCaps;\n    var numOuterCaps = 0;\n    var outerCapsMap = [0];\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\n      var subName = $1 || $2;\n      var capName;\n      var intro;\n      var localCapIndex; // Named subpattern\n\n      if (subName) {\n        var _context3;\n\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(\"Undefined property \".concat($0));\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = \"(?<\".concat(capName || subName, \">\");\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return \"(?<\".concat(capName, \">\");\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            \"\\\\k<\".concat(data[subName].names[localCapIndex], \">\") : \"\\\\\".concat(+backref + numPriorCaps);\n          }\n\n          return match;\n        });\n        return (0, _concat.default)(_context3 = \"\".concat(intro)).call(_context3, rewrittenSubpattern, \")\");\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return \"(?<\".concat(capName, \">\");\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        \"\\\\k<\".concat(outerCapNames[localCapIndex], \">\") : \"\\\\\".concat(outerCapsMap[+$4]);\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}