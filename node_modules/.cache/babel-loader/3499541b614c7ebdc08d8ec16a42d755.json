{"ast":null,"code":"/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\"use strict\"; //--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst esutils = require(\"esutils\"); //--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\n\n\nfunction isModuleExports(pattern) {\n  if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n    // module.exports\n    if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n      return true;\n    } // module[\"exports\"]\n\n\n    if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\n\n\nfunction isIdentifier(name, ecmaVersion) {\n  if (ecmaVersion >= 6) {\n    return esutils.keyword.isIdentifierES6(name);\n  }\n\n  return esutils.keyword.isIdentifierES5(name);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst alwaysOrNever = {\n  enum: [\"always\", \"never\"]\n};\nconst optionsObject = {\n  type: \"object\",\n  properties: {\n    considerPropertyDescriptor: {\n      type: \"boolean\"\n    },\n    includeCommonJSModuleExports: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require function names to match the name of the variable or property to which they are assigned\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-name-matching\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        additionalItems: false,\n        items: [alwaysOrNever, optionsObject]\n      }, {\n        type: \"array\",\n        additionalItems: false,\n        items: [optionsObject]\n      }]\n    },\n    messages: {\n      matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n      matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n      notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n      notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n    const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const considerPropertyDescriptor = options.considerPropertyDescriptor;\n    const includeModuleExports = options.includeCommonJSModuleExports;\n    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n    /**\n     * Check whether node is a certain CallExpression.\n     * @param {string} objName object name\n     * @param {string} funcName function name\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if node matches CallExpression\n     */\n\n    function isPropertyCall(objName, funcName, node) {\n      if (!node) {\n        return false;\n      }\n\n      return node.type === \"CallExpression\" && node.callee.type === \"MemberExpression\" && node.callee.object.name === objName && node.callee.property.name === funcName;\n    }\n    /**\n     * Compares identifiers based on the nameMatches option\n     * @param {string} x the first identifier\n     * @param {string} y the second identifier\n     * @returns {boolean} whether the two identifiers should warn.\n     */\n\n\n    function shouldWarn(x, y) {\n      return nameMatches === \"always\" && x !== y || nameMatches === \"never\" && x === y;\n    }\n    /**\n     * Reports\n     * @param {ASTNode} node The node to report\n     * @param {string} name The variable or property name\n     * @param {string} funcName The function name\n     * @param {boolean} isProp True if the reported node is a property assignment\n     * @returns {void}\n     */\n\n\n    function report(node, name, funcName, isProp) {\n      let messageId;\n\n      if (nameMatches === \"always\" && isProp) {\n        messageId = \"matchProperty\";\n      } else if (nameMatches === \"always\") {\n        messageId = \"matchVariable\";\n      } else if (isProp) {\n        messageId = \"notMatchProperty\";\n      } else {\n        messageId = \"notMatchVariable\";\n      }\n\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          funcName\n        }\n      });\n    }\n    /**\n     * Determines whether a given node is a string literal\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a string literal\n     */\n\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator(node) {\n        if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n          return;\n        }\n\n        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n          report(node, node.id.name, node.init.id.name, false);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.right.type !== \"FunctionExpression\" || node.left.computed && node.left.property.type !== \"Literal\" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\") {\n          return;\n        }\n\n        const isProp = node.left.type === \"MemberExpression\";\n        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n        if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n          report(node, name, node.right.id.name, isProp);\n        }\n      },\n\n      Property(node) {\n        if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n          return;\n        }\n\n        if (node.key.type === \"Identifier\") {\n          const functionName = node.value.id.name;\n          let propertyName = node.key.name;\n\n          if (considerPropertyDescriptor && propertyName === \"value\") {\n            if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n              const property = node.parent.parent.arguments[1];\n\n              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                report(node, property.value, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (shouldWarn(propertyName, functionName)) {\n              report(node, propertyName, functionName, true);\n            }\n          } else if (shouldWarn(propertyName, functionName)) {\n            report(node, propertyName, functionName, true);\n          }\n\n          return;\n        }\n\n        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {\n          report(node, node.key.value, node.value.id.name, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/func-name-matching.js"],"names":["astUtils","require","esutils","isModuleExports","pattern","type","object","name","property","value","isIdentifier","ecmaVersion","keyword","isIdentifierES6","isIdentifierES5","alwaysOrNever","enum","optionsObject","properties","considerPropertyDescriptor","includeCommonJSModuleExports","additionalProperties","module","exports","meta","docs","description","category","recommended","url","schema","anyOf","additionalItems","items","messages","matchProperty","matchVariable","notMatchProperty","notMatchVariable","create","context","options","nameMatches","includeModuleExports","parserOptions","isPropertyCall","objName","funcName","node","callee","shouldWarn","x","y","report","isProp","messageId","data","isStringLiteral","VariableDeclarator","init","id","AssignmentExpression","right","left","computed","getStaticPropertyName","Property","key","functionName","propertyName","parent","arguments"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        considerPropertyDescriptor: {\n            type: \"boolean\"\n        },\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-name-matching\"\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        },\n\n        messages: {\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Check whether node is a certain CallExpression.\n         * @param {string} objName object name\n         * @param {string} funcName function name\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if node matches CallExpression\n         */\n        function isPropertyCall(objName, funcName, node) {\n            if (!node) {\n                return false;\n            }\n            return node.type === \"CallExpression\" &&\n                node.callee.type === \"MemberExpression\" &&\n                node.callee.object.name === objName &&\n                node.callee.property.name === funcName;\n        }\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let messageId;\n\n            if (nameMatches === \"always\" && isProp) {\n                messageId = \"matchProperty\";\n            } else if (nameMatches === \"always\") {\n                messageId = \"matchVariable\";\n            } else if (isProp) {\n                messageId = \"notMatchProperty\";\n            } else {\n                messageId = \"notMatchVariable\";\n            }\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            Property(node) {\n                if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n                    return;\n                }\n\n                if (node.key.type === \"Identifier\") {\n                    const functionName = node.value.id.name;\n                    let propertyName = node.key.name;\n\n                    if (considerPropertyDescriptor && propertyName === \"value\") {\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n                            const property = node.parent.parent.arguments[1];\n\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                                report(node, property.value, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (shouldWarn(propertyName, functionName)) {\n                            report(node, propertyName, functionName, true);\n                        }\n                    } else if (shouldWarn(propertyName, functionName)) {\n                        report(node, propertyName, functionName, true);\n                    }\n                    return;\n                }\n\n                if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}