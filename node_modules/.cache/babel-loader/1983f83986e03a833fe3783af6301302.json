{"ast":null,"code":"/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\n\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\n\n\nfunction getTopConcatBinaryExpression(node) {\n  let currentNode = node;\n\n  while (isConcatenation(currentNode.parent)) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode;\n}\n/**\n * Determines whether a given node is a octal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is an octal escape sequence\n */\n\n\nfunction isOctalEscapeSequence(node) {\n  // No need to check TemplateLiterals â€“ would throw error with octal escape\n  const isStringLiteral = node.type === \"Literal\" && typeof node.value === \"string\";\n\n  if (!isStringLiteral) {\n    return false;\n  }\n\n  return astUtils.hasOctalEscapeSequence(node.raw);\n}\n/**\n * Checks whether or not a node contains a octal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node contains an octal escape sequence\n */\n\n\nfunction hasOctalEscapeSequence(node) {\n  if (isConcatenation(node)) {\n    return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);\n  }\n\n  return isOctalEscapeSequence(node);\n}\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\n\n\nfunction hasStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n  }\n\n  return astUtils.isStringLiteral(node);\n}\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\n\n\nfunction hasNonStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n  }\n\n  return !astUtils.isStringLiteral(node);\n}\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\n\n\nfunction startsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.left);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\n\n\nfunction endsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.right);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require template literals instead of string concatenation\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-template\"\n    },\n    schema: [],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let done = Object.create(null);\n    /**\n     * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n     * @param {ASTNode} node1 The first node\n     * @param {ASTNode} node2 The second node\n     * @returns {string} The text between the nodes, excluding other tokens\n     */\n\n    function getTextBetween(node1, node2) {\n      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n      const sourceText = sourceCode.getText();\n      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n    }\n    /**\n     * Returns a template literal form of the given node.\n     * @param {ASTNode} currentNode A node that should be converted to a template literal\n     * @param {string} textBeforeNode Text that should appear before the node\n     * @param {string} textAfterNode Text that should appear after the node\n     * @returns {string} A string form of this node, represented as a template literal\n     */\n\n\n    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n      if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n        /*\n         * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n         * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n         * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n         * an actual backslash character to appear before the dollar sign).\n         */\n        return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n          if (matched.lastIndexOf(\"\\\\\") % 2) {\n            return `\\\\${matched}`;\n          }\n\n          return matched; // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n        }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n      }\n\n      if (currentNode.type === \"TemplateLiteral\") {\n        return sourceCode.getText(currentNode);\n      }\n\n      if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n        const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n        const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n        if (leftEndsWithCurly) {\n          // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n          // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n        }\n\n        if (rightStartsWithCurly) {\n          // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n          // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n        }\n        /*\n         * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n         * the text between them.\n         */\n\n\n        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n      }\n\n      return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n    }\n    /**\n     * Returns a fixer object that converts a non-string binary expression to a template literal\n     * @param {SourceCodeFixer} fixer The fixer object\n     * @param {ASTNode} node A node that should be converted to a template literal\n     * @returns {Object} A fix for this binary expression\n     */\n\n\n    function fixNonStringBinaryExpression(fixer, node) {\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n      if (hasOctalEscapeSequence(topBinaryExpr)) {\n        return null;\n      }\n\n      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n    }\n    /**\n     * Reports if a given node is string concatenation with non string literals.\n     * @param {ASTNode} node A node to check.\n     * @returns {void}\n     */\n\n\n    function checkForStringConcat(node) {\n      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n        return;\n      }\n\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent); // Checks whether or not this node had been checked already.\n\n      if (done[topBinaryExpr.range[0]]) {\n        return;\n      }\n\n      done[topBinaryExpr.range[0]] = true;\n\n      if (hasNonStringLiteral(topBinaryExpr)) {\n        context.report({\n          node: topBinaryExpr,\n          message: \"Unexpected string concatenation.\",\n          fix: fixer => fixNonStringBinaryExpression(fixer, node)\n        });\n      }\n    }\n\n    return {\n      Program() {\n        done = Object.create(null);\n      },\n\n      Literal: checkForStringConcat,\n      TemplateLiteral: checkForStringConcat\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-template.js"],"names":["astUtils","require","isConcatenation","node","type","operator","getTopConcatBinaryExpression","currentNode","parent","isOctalEscapeSequence","isStringLiteral","value","hasOctalEscapeSequence","raw","left","right","hasStringLiteral","hasNonStringLiteral","startsWithTemplateCurly","expressions","length","quasis","range","endsWithTemplateCurly","module","exports","meta","docs","description","category","recommended","url","schema","fixable","create","context","sourceCode","getSourceCode","done","Object","getTextBetween","node1","node2","allTokens","concat","getTokensBetween","sourceText","getText","slice","reduce","accumulator","token","index","getTemplateLiteral","textBeforeNode","textAfterNode","replace","matched","lastIndexOf","RegExp","plusSign","getFirstTokenBetween","textBeforePlus","textAfterPlus","leftEndsWithCurly","rightStartsWithCurly","fixNonStringBinaryExpression","fixer","topBinaryExpr","replaceText","checkForStringConcat","report","message","fix","Program","Literal","TemplateLiteral"],"mappings":"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","sourcesContent":["/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    let currentNode = node;\n\n    while (isConcatenation(currentNode.parent)) {\n        currentNode = currentNode.parent;\n    }\n    return currentNode;\n}\n\n/**\n * Determines whether a given node is a octal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is an octal escape sequence\n */\nfunction isOctalEscapeSequence(node) {\n\n    // No need to check TemplateLiterals â€“ would throw error with octal escape\n    const isStringLiteral = node.type === \"Literal\" && typeof node.value === \"string\";\n\n    if (!isStringLiteral) {\n        return false;\n    }\n\n    return astUtils.hasOctalEscapeSequence(node.raw);\n}\n\n/**\n * Checks whether or not a node contains a octal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node contains an octal escape sequence\n */\nfunction hasOctalEscapeSequence(node) {\n    if (isConcatenation(node)) {\n        return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);\n    }\n\n    return isOctalEscapeSequence(node);\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-template\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n         * @param {ASTNode} node1 The first node\n         * @param {ASTNode} node2 The second node\n         * @returns {string} The text between the nodes, excluding other tokens\n         */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n         * Returns a template literal form of the given node.\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\n         * @param {string} textBeforeNode Text that should appear before the node\n         * @param {string} textAfterNode Text that should appear after the node\n         * @returns {string} A string form of this node, represented as a template literal\n         */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                /*\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                 * an actual backslash character to appear before the dollar sign).\n                 */\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                /*\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                 * the text between them.\n                 */\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Returns a fixer object that converts a non-string binary expression to a template literal\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A node that should be converted to a template literal\n         * @returns {Object} A fix for this binary expression\n         */\n        function fixNonStringBinaryExpression(fixer, node) {\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            if (hasOctalEscapeSequence(topBinaryExpr)) {\n                return null;\n            }\n\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    message: \"Unexpected string concatenation.\",\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}