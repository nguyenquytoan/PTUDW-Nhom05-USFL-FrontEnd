{"ast":null,"code":"/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst radixMap = new Map([[2, {\n  system: \"binary\",\n  literalPrefix: \"0b\"\n}], [8, {\n  system: \"octal\",\n  literalPrefix: \"0o\"\n}], [16, {\n  system: \"hexadecimal\",\n  literalPrefix: \"0x\"\n}]]);\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\n\nfunction isParseInt(calleeNode) {\n  switch (calleeNode.type) {\n    case \"Identifier\":\n      return calleeNode.name === \"parseInt\";\n\n    case \"MemberExpression\":\n      return calleeNode.object.type === \"Identifier\" && calleeNode.object.name === \"Number\" && calleeNode.property.type === \"Identifier\" && calleeNode.property.name === \"parseInt\";\n    // no default\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n    },\n    schema: [],\n    messages: {\n      useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n    },\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      \"CallExpression[arguments.length=2]\"(node) {\n        const [strNode, radixNode] = node.arguments,\n              str = strNode.value,\n              radix = radixNode.value;\n\n        if (strNode.type === \"Literal\" && radixNode.type === \"Literal\" && typeof str === \"string\" && typeof radix === \"number\" && radixMap.has(radix) && isParseInt(node.callee)) {\n          const {\n            system,\n            literalPrefix\n          } = radixMap.get(radix);\n          context.report({\n            node,\n            messageId: \"useLiteral\",\n            data: {\n              system,\n              functionName: sourceCode.getText(node.callee)\n            },\n\n            fix(fixer) {\n              if (sourceCode.getCommentsInside(node).length) {\n                return null;\n              }\n\n              const replacement = `${literalPrefix}${str}`;\n\n              if (+replacement !== parseInt(str, radix)) {\n                /*\n                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                 */\n                return null;\n              }\n\n              const tokenBefore = sourceCode.getTokenBefore(node),\n                    tokenAfter = sourceCode.getTokenAfter(node);\n              let prefix = \"\",\n                  suffix = \"\";\n\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                prefix = \" \";\n              }\n\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {\n                suffix = \" \";\n              }\n\n              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/prefer-numeric-literals.js"],"names":["astUtils","require","radixMap","Map","system","literalPrefix","isParseInt","calleeNode","type","name","object","property","module","exports","meta","docs","description","category","recommended","url","schema","messages","useLiteral","fixable","create","context","sourceCode","getSourceCode","node","strNode","radixNode","arguments","str","value","radix","has","callee","get","report","messageId","data","functionName","getText","fix","fixer","getCommentsInside","length","replacement","parseInt","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","prefix","suffix","range","canTokensBeAdjacent","replaceText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst radixMap = new Map([\n    [2, { system: \"binary\", literalPrefix: \"0b\" }],\n    [8, { system: \"octal\", literalPrefix: \"0o\" }],\n    [16, { system: \"hexadecimal\", literalPrefix: \"0x\" }]\n]);\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    switch (calleeNode.type) {\n        case \"Identifier\":\n            return calleeNode.name === \"parseInt\";\n        case \"MemberExpression\":\n            return calleeNode.object.type === \"Identifier\" &&\n                calleeNode.object.name === \"Number\" &&\n                calleeNode.property.type === \"Identifier\" &&\n                calleeNode.property.name === \"parseInt\";\n\n        // no default\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n        },\n\n        schema: [],\n\n        messages: {\n            useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            \"CallExpression[arguments.length=2]\"(node) {\n                const [strNode, radixNode] = node.arguments,\n                    str = strNode.value,\n                    radix = radixNode.value;\n\n                if (\n                    strNode.type === \"Literal\" &&\n                    radixNode.type === \"Literal\" &&\n                    typeof str === \"string\" &&\n                    typeof radix === \"number\" &&\n                    radixMap.has(radix) &&\n                    isParseInt(node.callee)\n                ) {\n\n                    const { system, literalPrefix } = radixMap.get(radix);\n\n                    context.report({\n                        node,\n                        messageId: \"useLiteral\",\n                        data: {\n                            system,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            if (sourceCode.getCommentsInside(node).length) {\n                                return null;\n                            }\n\n                            const replacement = `${literalPrefix}${str}`;\n\n                            if (+replacement !== parseInt(str, radix)) {\n\n                                /*\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                 */\n                                return null;\n                            }\n\n                            const tokenBefore = sourceCode.getTokenBefore(node),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n                            let prefix = \"\",\n                                suffix = \"\";\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(replacement, tokenAfter)\n                            ) {\n                                suffix = \" \";\n                            }\n\n                            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}