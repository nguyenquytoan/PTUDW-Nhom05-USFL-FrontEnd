{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.streams = function (exports, logger_mjs, assert_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:streams:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Takes either a Response, a ReadableStream, or a\n   * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n   * ReadableStreamReader object associated with it.\n   *\n   * @param {workbox.streams.StreamSource} source\n   * @return {ReadableStreamReader}\n   * @private\n   */\n\n\n  function _getReaderFromSource(source) {\n    if (source.body && source.body.getReader) {\n      return source.body.getReader();\n    }\n\n    if (source.getReader) {\n      return source.getReader();\n    } // TODO: This should be possible to do by constructing a ReadableStream, but\n    // I can't get it to work. As a hack, construct a new Response, and use the\n    // reader associated with its body.\n\n\n    return new Response(source).body.getReader();\n  }\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n   *\n   * Returns an object exposing a ReadableStream with each individual stream's\n   * data returned in sequence, along with a Promise which signals when the\n   * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n   * @return {Object<{done: Promise, stream: ReadableStream}>}\n   *\n   * @memberof workbox.streams\n   */\n\n\n  function concatenate(sourcePromises) {\n    {\n      assert_mjs.assert.isArray(sourcePromises, {\n        moduleName: 'workbox-streams',\n        funcName: 'concatenate',\n        paramName: 'sourcePromises'\n      });\n    }\n    const readerPromises = sourcePromises.map(sourcePromise => {\n      return Promise.resolve(sourcePromise).then(source => {\n        return _getReaderFromSource(source);\n      });\n    });\n    let fullyStreamedResolve;\n    let fullyStreamedReject;\n    const done = new Promise((resolve, reject) => {\n      fullyStreamedResolve = resolve;\n      fullyStreamedReject = reject;\n    });\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n      pull(controller) {\n        return readerPromises[i].then(reader => reader.read()).then(result => {\n          if (result.done) {\n            {\n              logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n            }\n            i++;\n\n            if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n              {\n                logger_mjs.logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n\n                for (const message of logMessages) {\n                  if (Array.isArray(message)) {\n                    logger_mjs.logger.log(...message);\n                  } else {\n                    logger_mjs.logger.log(message);\n                  }\n                }\n\n                logger_mjs.logger.log('Finished reading all sources.');\n                logger_mjs.logger.groupEnd();\n              }\n              controller.close();\n              fullyStreamedResolve();\n              return;\n            }\n\n            return this.pull(controller);\n          } else {\n            controller.enqueue(result.value);\n          }\n        }).catch(error => {\n          {\n            logger_mjs.logger.error('An error occurred:', error);\n          }\n          fullyStreamedReject(error);\n          throw error;\n        });\n      },\n\n      cancel() {\n        {\n          logger_mjs.logger.warn('The ReadableStream was cancelled.');\n        }\n        fullyStreamedResolve();\n      }\n\n    });\n    return {\n      done,\n      stream\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * is available.\n   *\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof workbox.streams\n   */\n\n\n  function createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n\n    if (!headers.has('content-type')) {\n      headers.set('content-type', 'text/html');\n    }\n\n    return headers;\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n   * along with a\n   * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n   *\n   * Returns an object exposing a Response whose body consists of each individual\n   * stream's data returned in sequence, along with a Promise which signals when\n   * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {Object<{done: Promise, response: Response}>}\n   *\n   * @memberof workbox.streams\n   */\n\n\n  function concatenateToResponse(sourcePromises, headersInit) {\n    const {\n      done,\n      stream\n    } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, {\n      headers\n    });\n    return {\n      done,\n      response\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  let cachedIsSupported = undefined;\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * can be created.\n   *\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof workbox.streams\n   */\n\n  function isSupported() {\n    if (cachedIsSupported === undefined) {\n      // See https://github.com/GoogleChrome/workbox/issues/1473\n      try {\n        new ReadableStream({\n          start() {}\n\n        });\n        cachedIsSupported = true;\n      } catch (error) {\n        cachedIsSupported = false;\n      }\n    }\n\n    return cachedIsSupported;\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n   *\n   * On browsers that do not support constructing new `ReadableStream`s, this\n   * strategy will automatically wait for all the `sourceFunctions` to complete,\n   * and create a final response that concatenates their values together.\n   *\n   * @param {\n   *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n   * Each function should return a {@link workbox.streams.StreamSource} (or a\n   * Promise which resolves to one).\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {workbox.routing.Route~handlerCallback}\n   *\n   * @memberof workbox.streams\n   */\n\n\n  function strategy(sourceFunctions, headersInit) {\n    return async ({\n      event,\n      url,\n      params\n    }) => {\n      if (isSupported()) {\n        const {\n          done,\n          response\n        } = concatenateToResponse(sourceFunctions.map(fn => fn({\n          event,\n          url,\n          params\n        })), headersInit);\n        event.waitUntil(done);\n        return response;\n      }\n\n      {\n        logger_mjs.logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n      } // Fallback to waiting for everything to finish, and concatenating the\n      // responses.\n\n      const parts = await Promise.all(sourceFunctions.map(sourceFunction => sourceFunction({\n        event,\n        url,\n        params\n      })).map(async responsePromise => {\n        const response = await responsePromise;\n\n        if (response instanceof Response) {\n          return response.blob();\n        } // Otherwise, assume it's something like a string which can be used\n        // as-is when constructing the final composite blob.\n\n\n        return response;\n      }));\n      const headers = createHeaders(headersInit); // Constructing a new Response from a Blob source is well-supported.\n      // So is constructing a new Blob from multiple source Blobs or strings.\n\n      return new Response(new Blob(parts), {\n        headers\n      });\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.concatenate = concatenate;\n  exports.concatenateToResponse = concatenateToResponse;\n  exports.isSupported = isSupported;\n  exports.strategy = strategy;\n  return exports;\n}({}, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../concatenate.mjs","../utils/createHeaders.mjs","../concatenateToResponse.mjs","../isSupported.mjs","../strategy.mjs","../index.mjs"],"names":["self","_","source","assert","moduleName","funcName","paramName","readerPromises","sourcePromise","_getReaderFromSource","done","fullyStreamedResolve","fullyStreamedReject","i","logMessages","stream","pull","reader","result","sourcePromises","logger","length","Array","controller","error","cancel","headersInit","headers","concatenate","createHeaders","response","cachedIsSupported","start","params","isSupported","concatenateToResponse","fn","event","parts","sourceFunction"],"mappings":"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","sourcesContent":["try{self['workbox:streams:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {workbox.streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n  if (source.body && source.body.getReader) {\n    return source.body.getReader();\n  }\n\n  if (source.getReader) {\n    return source.getReader();\n  }\n\n  // TODO: This should be possible to do by constructing a ReadableStream, but\n  // I can't get it to work. As a hack, construct a new Response, and use the\n  // reader associated with its body.\n  return new Response(source).body.getReader();\n}\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenate(sourcePromises) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isArray(sourcePromises, {\n      moduleName: 'workbox-streams',\n      funcName: 'concatenate',\n      paramName: 'sourcePromises',\n    });\n  }\n\n  const readerPromises = sourcePromises.map((sourcePromise) => {\n    return Promise.resolve(sourcePromise).then((source) => {\n      return _getReaderFromSource(source);\n    });\n  });\n\n  let fullyStreamedResolve;\n  let fullyStreamedReject;\n  const done = new Promise((resolve, reject) => {\n    fullyStreamedResolve = resolve;\n    fullyStreamedReject = reject;\n  });\n\n  let i = 0;\n  const logMessages = [];\n  const stream = new ReadableStream({\n    pull(controller) {\n      return readerPromises[i]\n          .then((reader) => reader.read())\n          .then((result) => {\n            if (result.done) {\n              if (process.env.NODE_ENV !== 'production') {\n                logMessages.push(['Reached the end of source:',\n                  sourcePromises[i]]);\n              }\n\n              i++;\n              if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.groupCollapsed(\n                      `Concatenating ${readerPromises.length} sources.`);\n                  for (const message of logMessages) {\n                    if (Array.isArray(message)) {\n                      logger.log(...message);\n                    } else {\n                      logger.log(message);\n                    }\n                  }\n                  logger.log('Finished reading all sources.');\n                  logger.groupEnd();\n                }\n\n                controller.close();\n                fullyStreamedResolve();\n                return;\n              }\n\n              return this.pull(controller);\n            } else {\n              controller.enqueue(result.value);\n            }\n          }).catch((error) => {\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error('An error occurred:', error);\n            }\n            fullyStreamedReject(error);\n            throw error;\n          });\n    },\n\n    cancel() {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('The ReadableStream was cancelled.');\n      }\n\n      fullyStreamedResolve();\n    },\n  });\n\n  return {done, stream};\n}\n\nexport {concatenate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox.streams\n */\nfunction createHeaders(headersInit = {}) {\n  // See https://github.com/GoogleChrome/workbox/issues/1461\n  const headers = new Headers(headersInit);\n  if (!headers.has('content-type')) {\n    headers.set('content-type', 'text/html');\n  }\n  return headers;\n}\n\nexport {createHeaders};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenate} from './concatenate.mjs';\n\nimport './_version.mjs';\n\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof workbox.streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n  const {done, stream} = concatenate(sourcePromises);\n\n  const headers = createHeaders(headersInit);\n  const response = new Response(stream, {headers});\n\n  return {done, response};\n}\n\nexport {concatenateToResponse};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\nlet cachedIsSupported = undefined;\n\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof workbox.streams\n */\nfunction isSupported() {\n  if (cachedIsSupported === undefined) {\n    // See https://github.com/GoogleChrome/workbox/issues/1473\n    try {\n      new ReadableStream({start() {}});\n      cachedIsSupported = true;\n    } catch (error) {\n      cachedIsSupported = false;\n    }\n  }\n\n  return cachedIsSupported;\n}\n\nexport {isSupported};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\n\nimport {createHeaders} from './utils/createHeaders.mjs';\nimport {concatenateToResponse} from './concatenateToResponse.mjs';\nimport {isSupported} from './isSupported.mjs';\n\nimport './_version.mjs';\n\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {\n *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n * Each function should return a {@link workbox.streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {workbox.routing.Route~handlerCallback}\n *\n * @memberof workbox.streams\n */\nexport function strategy(sourceFunctions, headersInit) {\n  return async ({event, url, params}) => {\n    if (isSupported()) {\n      const {done, response} = concatenateToResponse(sourceFunctions.map(\n          (fn) => fn({event, url, params})), headersInit);\n      event.waitUntil(done);\n      return response;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`The current browser doesn't support creating response ` +\n        `streams. Falling back to non-streaming response instead.`);\n    }\n\n    // Fallback to waiting for everything to finish, and concatenating the\n    // responses.\n    const parts = await Promise.all(\n        sourceFunctions.map(\n            (sourceFunction) => sourceFunction({event, url, params})\n        ).map(async (responsePromise) => {\n          const response = await responsePromise;\n          if (response instanceof Response) {\n            return response.blob();\n          }\n\n          // Otherwise, assume it's something like a string which can be used\n          // as-is when constructing the final composite blob.\n          return response;\n        })\n    );\n\n    const headers = createHeaders(headersInit);\n    // Constructing a new Response from a Blob source is well-supported.\n    // So is constructing a new Blob from multiple source Blobs or strings.\n    return new Response(new Blob(parts), {headers});\n  };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {concatenate} from './concatenate.mjs';\nimport {concatenateToResponse} from './concatenateToResponse.mjs';\nimport {isSupported} from './isSupported.mjs';\nimport {strategy} from './strategy.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.streams\n */\n\nexport {\n  concatenate,\n  concatenateToResponse,\n  isSupported,\n  strategy,\n};\n"]},"metadata":{},"sourceType":"script"}