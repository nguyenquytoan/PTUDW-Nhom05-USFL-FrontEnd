{"ast":null,"code":"function sortStarts(a, b) {\n  return (a.range ? a.range[0] : a.start) - (b.range ? b.range[0] : b.start);\n}\n/**\n * Returns the string value of a template literal object.\n * Tries to build it as best as it can based on the passed\n * prop. For instance `This is a ${prop}` will return 'This is a {prop}'.\n *\n * If the template literal builds to undefined (`${undefined}`), then\n * this should return \"undefined\".\n */\n\n\nexport default function extractValueFromTemplateLiteral(value) {\n  const {\n    quasis,\n    expressions\n  } = value;\n  const partitions = quasis.concat(expressions);\n  return partitions.sort(sortStarts).reduce((raw, part) => {\n    const {\n      type\n    } = part;\n\n    if (type === 'TemplateElement') {\n      return raw + part.value.raw;\n    }\n\n    if (type === 'Identifier') {\n      return part.name === 'undefined' ? `${raw}${part.name}` : `${raw}{${part.name}}`;\n    }\n\n    if (type.indexOf('Expression') > -1) {\n      return `${raw}{${type}}`;\n    }\n\n    return raw;\n  }, '');\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsx-ast-utils/src/values/expressions/TemplateLiteral.js"],"names":["sortStarts","a","b","range","start","extractValueFromTemplateLiteral","value","quasis","expressions","partitions","concat","sort","reduce","raw","part","type","name","indexOf"],"mappings":"AAAA,SAASA,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;AACxB,SAAO,CAACD,CAAC,CAACE,KAAF,GAAUF,CAAC,CAACE,KAAF,CAAQ,CAAR,CAAV,GAAuBF,CAAC,CAACG,KAA1B,KAAoCF,CAAC,CAACC,KAAF,GAAUD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAV,GAAuBD,CAAC,CAACE,KAA7D,CAAP;AACD;AAED;;;;;;;;;;AAQA,eAAe,SAASC,+BAAT,CAAyCC,KAAzC,EAAgD;AAC7D,QAAM;AACJC,IAAAA,MADI;AAEJC,IAAAA;AAFI,MAGFF,KAHJ;AAIA,QAAMG,UAAU,GAAGF,MAAM,CAACG,MAAP,CAAcF,WAAd,CAAnB;AAEA,SAAOC,UAAU,CAACE,IAAX,CAAgBX,UAAhB,EAA4BY,MAA5B,CAAmC,CAACC,GAAD,EAAMC,IAAN,KAAe;AACvD,UAAM;AACJC,MAAAA;AADI,QAEFD,IAFJ;;AAGA,QAAIC,IAAI,KAAK,iBAAb,EAAgC;AAC9B,aAAOF,GAAG,GAAGC,IAAI,CAACR,KAAL,CAAWO,GAAxB;AACD;;AAED,QAAIE,IAAI,KAAK,YAAb,EAA2B;AACzB,aAAOD,IAAI,CAACE,IAAL,KAAc,WAAd,GAA6B,GAAEH,GAAI,GAAEC,IAAI,CAACE,IAAK,EAA/C,GAAoD,GAAEH,GAAI,IAAGC,IAAI,CAACE,IAAK,GAA9E;AACD;;AAED,QAAID,IAAI,CAACE,OAAL,CAAa,YAAb,IAA6B,CAAC,CAAlC,EAAqC;AACnC,aAAQ,GAAEJ,GAAI,IAAGE,IAAK,GAAtB;AACD;;AAED,WAAOF,GAAP;AACD,GAjBM,EAiBJ,EAjBI,CAAP;AAkBD","sourcesContent":["function sortStarts(a, b) {\n  return (a.range ? a.range[0] : a.start) - (b.range ? b.range[0] : b.start);\n}\n\n/**\n * Returns the string value of a template literal object.\n * Tries to build it as best as it can based on the passed\n * prop. For instance `This is a ${prop}` will return 'This is a {prop}'.\n *\n * If the template literal builds to undefined (`${undefined}`), then\n * this should return \"undefined\".\n */\nexport default function extractValueFromTemplateLiteral(value) {\n  const {\n    quasis,\n    expressions,\n  } = value;\n  const partitions = quasis.concat(expressions);\n\n  return partitions.sort(sortStarts).reduce((raw, part) => {\n    const {\n      type,\n    } = part;\n    if (type === 'TemplateElement') {\n      return raw + part.value.raw;\n    }\n\n    if (type === 'Identifier') {\n      return part.name === 'undefined' ? `${raw}${part.name}` : `${raw}{${part.name}}`;\n    }\n\n    if (type.indexOf('Expression') > -1) {\n      return `${raw}{${type}}`;\n    }\n\n    return raw;\n  }, '');\n}\n"]},"metadata":{},"sourceType":"module"}