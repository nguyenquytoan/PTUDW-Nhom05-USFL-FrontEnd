{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar ts = _interopRequireWildcard(require(\"./typescript\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    const isPrivate = prop.isPrivate();\n    const isMethod = !prop.isProperty();\n    const isInstance = !prop.node.static;\n\n    if (isPrivate) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: !isInstance,\n        method: isMethod\n      };\n\n      if (prop.node.kind === \"get\") {\n        update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n      } else if (prop.node.kind === \"set\") {\n        update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n      } else if (prop.node.kind === \"method\") {\n        update.methodId = prop.scope.generateUidIdentifier(name);\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, loose, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    if (loose) {\n      initNodes.push(_core.template.statement.ast`\n          var ${id} = ${state.addHelper(\"classPrivateFieldLooseKey\")}(\"${name}\")\n        `);\n    } else if (isMethod && !isStatic) {\n      if (isAccessor) {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n      } else {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakSet();`);\n      }\n    } else if (!isStatic) {\n      initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n    }\n  }\n\n  return initNodes;\n}\n\nfunction privateNameVisitorFactory(visitor) {\n  const privateNameVisitor = Object.assign(Object.assign({}, visitor), {}, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      if (!redeclared.length) {\n        return;\n      }\n\n      path.get(\"body\").traverse(nestedVisitor, Object.assign(Object.assign({}, this), {}, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign(Object.assign({}, this), {}, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n\n  });\n\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor]);\n\n  return privateNameVisitor;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath);\n  }\n\n});\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!path.get(\"left\").isPrivateName()) return;\n    const {\n      loose,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    if (loose) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${id})\n      `);\n      return;\n    }\n\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(_core.template.expression.ast`${id}.has(${right})`);\n  }\n\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodSet\"), []);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id\n    } = privateNamesMap.get(name);\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: object,\n      PROP: privateNamesMap.get(name).id\n    });\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = loose ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    loose\n  });\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`${id}.set(${ref}, {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ${value},\n  })`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${id.name} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${id} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n\n  return _core.template.statement.ast`${id}.add(${ref})`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, loose = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n\n  const methodValue = _core.types.functionExpression(methodId, params, body, generator, async);\n\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      getterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(getId, methodValue)]);\n  }\n\n  if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      setterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(setId, methodValue)]);\n  }\n\n  if (isStatic && !loose) {\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.functionExpression(id, params, body, generator, async))]);\n  }\n\n  return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(methodId, methodValue)]);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nfunction replaceThisContext(path, ref, superRef, file, loose) {\n  const state = {\n    classRef: ref,\n    needsClassRef: false\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    isLoose: loose,\n    superRef,\n    file,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {\n  const staticNodes = [];\n  const instanceNodes = [];\n  let needsClassRef = false;\n\n  for (const prop of props) {\n    ts.assertFieldTransformed(prop);\n    const isStatic = prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n\n    if (isStatic || isMethod && isPrivate) {\n      const replaced = replaceThisContext(prop, ref, superRef, state, loose);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStatic && isPrivate && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n        break;\n\n      case isStatic && isPublic && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && loose:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !loose:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isMethod && loose:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPrivate && isMethod && !loose:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPublic && isField && loose:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !loose:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"],"names":["Object","defineProperty","exports","value","buildPrivateNamesMap","buildPrivateNamesNodes","transformPrivateNamesUsage","buildFieldsInitNodes","_core","require","_helperReplaceSupers","_interopRequireWildcard","_helperMemberExpressionToFunctions","_interopRequireDefault","_helperOptimiseCallExpression","ts","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","props","privateNamesMap","Map","prop","isPrivate","isMethod","isProperty","isInstance","node","static","name","id","update","scope","generateUidIdentifier","method","kind","getId","setId","methodId","loose","state","initNodes","isStatic","isAccessor","push","template","statement","ast","addHelper","privateNameVisitorFactory","visitor","privateNameVisitor","assign","Class","path","body","visiblePrivateNames","redeclared","delete","length","traverse","nestedVisitor","skipKey","visitors","merge","environmentVisitor","PrivateName","parentPath","isMemberExpression","property","isOptionalMemberExpression","includes","handle","privateInVisitor","BinaryExpression","operator","left","right","isPrivateName","replaceWith","expression","classRef","privateNameHandlerSpec","memoise","member","count","object","memo","maybeGenerateMemoised","memoiser","receiver","types","cloneNode","file","helperName","callExpression","destructureSet","memberExpression","identifier","args","optionalCall","privateNameHandlerLoose","BASE","REF","PROP","simpleSet","optionalCallExpression","ref","size","handler","buildPrivateFieldInitLoose","buildUndefinedNode","buildPrivateInstanceFieldInitSpec","buildPrivateStaticFieldInitSpec","privateName","initAdded","buildPrivateMethodInitLoose","buildPrivateInstanceMethodInitSpec","buildPublicFieldInitLoose","computed","expressionStatement","assignmentExpression","isLiteral","buildPublicFieldInitSpec","stringLiteral","buildPrivateStaticMethodInitLoose","buildPrivateMethodDeclaration","getterDeclared","setterDeclared","params","generator","async","methodValue","functionExpression","isGetter","isSetter","variableDeclaration","variableDeclarator","thisContextVisitor","ThisExpression","needsClassRef","replaceThisContext","superRef","replacer","methodPath","isLoose","getObjectRef","replace","staticNodes","instanceNodes","assertFieldTransformed","isPublic","isField","replaced","thisExpression","unshift","Error","filter","Boolean","wrapClass","remove","isClassExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar ts = _interopRequireWildcard(require(\"./typescript\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    const isPrivate = prop.isPrivate();\n    const isMethod = !prop.isProperty();\n    const isInstance = !prop.node.static;\n\n    if (isPrivate) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: !isInstance,\n        method: isMethod\n      };\n\n      if (prop.node.kind === \"get\") {\n        update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n      } else if (prop.node.kind === \"set\") {\n        update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n      } else if (prop.node.kind === \"method\") {\n        update.methodId = prop.scope.generateUidIdentifier(name);\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, loose, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    if (loose) {\n      initNodes.push(_core.template.statement.ast`\n          var ${id} = ${state.addHelper(\"classPrivateFieldLooseKey\")}(\"${name}\")\n        `);\n    } else if (isMethod && !isStatic) {\n      if (isAccessor) {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n      } else {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakSet();`);\n      }\n    } else if (!isStatic) {\n      initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n    }\n  }\n\n  return initNodes;\n}\n\nfunction privateNameVisitorFactory(visitor) {\n  const privateNameVisitor = Object.assign(Object.assign({}, visitor), {}, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      if (!redeclared.length) {\n        return;\n      }\n\n      path.get(\"body\").traverse(nestedVisitor, Object.assign(Object.assign({}, this), {}, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign(Object.assign({}, this), {}, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n\n  });\n\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor]);\n\n  return privateNameVisitor;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath);\n  }\n\n});\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!path.get(\"left\").isPrivateName()) return;\n    const {\n      loose,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    if (loose) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${id})\n      `);\n      return;\n    }\n\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(_core.template.expression.ast`${id}.has(${right})`);\n  }\n\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodSet\"), []);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id\n    } = privateNamesMap.get(name);\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: object,\n      PROP: privateNamesMap.get(name).id\n    });\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = loose ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    loose\n  });\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`${id}.set(${ref}, {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ${value},\n  })`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${id.name} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${id} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n\n  return _core.template.statement.ast`${id}.add(${ref})`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, loose = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n\n  const methodValue = _core.types.functionExpression(methodId, params, body, generator, async);\n\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      getterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(getId, methodValue)]);\n  }\n\n  if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign(Object.assign({}, privateName), {}, {\n      setterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(setId, methodValue)]);\n  }\n\n  if (isStatic && !loose) {\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.functionExpression(id, params, body, generator, async))]);\n  }\n\n  return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(methodId, methodValue)]);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nfunction replaceThisContext(path, ref, superRef, file, loose) {\n  const state = {\n    classRef: ref,\n    needsClassRef: false\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    isLoose: loose,\n    superRef,\n    file,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {\n  const staticNodes = [];\n  const instanceNodes = [];\n  let needsClassRef = false;\n\n  for (const prop of props) {\n    ts.assertFieldTransformed(prop);\n    const isStatic = prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n\n    if (isStatic || isMethod && isPrivate) {\n      const replaced = replaceThisContext(prop, ref, superRef, state, loose);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStatic && isPrivate && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n        break;\n\n      case isStatic && isPublic && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && loose:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !loose:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isMethod && loose:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPrivate && isMethod && !loose:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPublic && isField && loose:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !loose:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}"]},"metadata":{},"sourceType":"script"}