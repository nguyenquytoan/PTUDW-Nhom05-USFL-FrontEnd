{"ast":null,"code":"/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n      WHITESPACE = /\\s/gu,\n      MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\n\nconst SCHEMA_BODY = {\n  type: \"object\",\n  properties: {\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreInlineComments: {\n      type: \"boolean\"\n    },\n    ignoreConsecutiveComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst DEFAULTS = {\n  ignorePattern: \"\",\n  ignoreInlineComments: false,\n  ignoreConsecutiveComments: false\n};\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\n\nfunction getNormalizedOptions(rawOptions, which) {\n  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\n\n\nfunction getAllNormalizedOptions(rawOptions = {}) {\n  return {\n    Line: getNormalizedOptions(rawOptions, \"line\"),\n    Block: getNormalizedOptions(rawOptions, \"block\")\n  };\n}\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\n\n\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n  Object.keys(normalizedOptions).forEach(key => {\n    const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n    if (ignorePatternStr) {\n      const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n      normalizedOptions[key].ignorePatternRegExp = regExp;\n    }\n  });\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce or disallow capitalization of the first letter of a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/capitalized-comments\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      oneOf: [SCHEMA_BODY, {\n        type: \"object\",\n        properties: {\n          line: SCHEMA_BODY,\n          block: SCHEMA_BODY\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n      unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n    }\n  },\n\n  create(context) {\n    const capitalize = context.options[0] || \"always\",\n          normalizedOptions = getAllNormalizedOptions(context.options[1]),\n          sourceCode = context.getSourceCode();\n    createRegExpForIgnorePatterns(normalizedOptions); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Checks whether a comment is an inline comment.\n     *\n     * For the purpose of this rule, a comment is inline if:\n     * 1. The comment is preceded by a token on the same line; and\n     * 2. The command is followed by a token on the same line.\n     *\n     * Note that the comment itself need not be single-line!\n     *\n     * Also, it follows from this definition that only block comments can\n     * be considered as possibly inline. This is because line comments\n     * would consume any following tokens on the same line as the comment.\n     * @param {ASTNode} comment The comment node to check.\n     * @returns {boolean} True if the comment is an inline comment, false\n     * otherwise.\n     */\n\n    function isInlineComment(comment) {\n      const previousToken = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      }),\n            nextToken = sourceCode.getTokenAfter(comment, {\n        includeComments: true\n      });\n      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);\n    }\n    /**\n     * Determine if a comment follows another comment.\n     * @param {ASTNode} comment The comment to check.\n     * @returns {boolean} True if the comment follows a valid comment.\n     */\n\n\n    function isConsecutiveComment(comment) {\n      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      });\n      return Boolean(previousTokenOrComment && [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1);\n    }\n    /**\n     * Check a comment to determine if it is valid for this rule.\n     * @param {ASTNode} comment The comment node to process.\n     * @param {Object} options The options for checking this comment.\n     * @returns {boolean} True if the comment is valid, false otherwise.\n     */\n\n\n    function isCommentValid(comment, options) {\n      // 1. Check for default ignore pattern.\n      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n        return true;\n      } // 2. Check for custom ignore pattern.\n\n\n      const commentWithoutAsterisks = comment.value.replace(/\\*/gu, \"\");\n\n      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n        return true;\n      } // 3. Check for inline comments.\n\n\n      if (options.ignoreInlineComments && isInlineComment(comment)) {\n        return true;\n      } // 4. Is this a consecutive comment (and are we tolerating those)?\n\n\n      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n        return true;\n      } // 5. Does the comment start with a possible URL?\n\n\n      if (MAYBE_URL.test(commentWithoutAsterisks)) {\n        return true;\n      } // 6. Is the initial word character a letter?\n\n\n      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, \"\");\n\n      if (commentWordCharsOnly.length === 0) {\n        return true;\n      }\n\n      const firstWordChar = commentWordCharsOnly[0];\n\n      if (!LETTER_PATTERN.test(firstWordChar)) {\n        return true;\n      } // 7. Check the case of the initial word character.\n\n\n      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n            isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n      if (capitalize === \"always\" && isLowercase) {\n        return false;\n      }\n\n      if (capitalize === \"never\" && isUppercase) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Process a comment to determine if it needs to be reported.\n     * @param {ASTNode} comment The comment node to process.\n     * @returns {void}\n     */\n\n\n    function processComment(comment) {\n      const options = normalizedOptions[comment.type],\n            commentValid = isCommentValid(comment, options);\n\n      if (!commentValid) {\n        const messageId = capitalize === \"always\" ? \"unexpectedLowercaseComment\" : \"unexpectedUppercaseComment\";\n        context.report({\n          node: null,\n          // Intentionally using loc instead\n          loc: comment.loc,\n          messageId,\n\n          fix(fixer) {\n            const match = comment.value.match(LETTER_PATTERN);\n            return fixer.replaceTextRange( // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());\n          }\n\n        });\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/capitalized-comments.js"],"names":["LETTER_PATTERN","require","astUtils","DEFAULT_IGNORE_PATTERN","COMMENTS_IGNORE_PATTERN","WHITESPACE","MAYBE_URL","SCHEMA_BODY","type","properties","ignorePattern","ignoreInlineComments","ignoreConsecutiveComments","additionalProperties","DEFAULTS","getNormalizedOptions","rawOptions","which","Object","assign","getAllNormalizedOptions","Line","Block","createRegExpForIgnorePatterns","normalizedOptions","keys","forEach","key","ignorePatternStr","regExp","RegExp","ignorePatternRegExp","module","exports","meta","docs","description","category","recommended","url","fixable","schema","enum","oneOf","line","block","messages","unexpectedLowercaseComment","unexpectedUppercaseComment","create","context","capitalize","options","sourceCode","getSourceCode","isInlineComment","comment","previousToken","getTokenBefore","includeComments","nextToken","getTokenAfter","Boolean","loc","start","end","isConsecutiveComment","previousTokenOrComment","indexOf","isCommentValid","test","value","commentWithoutAsterisks","replace","commentWordCharsOnly","length","firstWordChar","isUppercase","toLocaleLowerCase","isLowercase","toLocaleUpperCase","processComment","commentValid","messageId","report","node","fix","fixer","match","replaceTextRange","range","index","Program","comments","getAllComments","filter","token"],"mappings":"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","sourcesContent":["/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/gu,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\nconst DEFAULTS = {\n    ignorePattern: \"\",\n    ignoreInlineComments: false,\n    ignoreConsecutiveComments: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions = {}) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/capitalized-comments\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n            unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n        }\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/gu, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            }\n            if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const messageId = capitalize === \"always\"\n                    ? \"unexpectedLowercaseComment\"\n                    : \"unexpectedUppercaseComment\";\n\n                context.report({\n                    node: null, // Intentionally using loc instead\n                    loc: comment.loc,\n                    messageId,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}