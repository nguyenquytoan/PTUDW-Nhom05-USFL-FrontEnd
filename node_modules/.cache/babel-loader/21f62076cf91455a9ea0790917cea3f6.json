{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.mjs';\nimport { logger } from './logger.mjs';\nimport { assert } from './assert.mjs';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.mjs';\nimport { pluginEvents } from '../models/pluginEvents.mjs';\nimport { pluginUtils } from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []\n}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n      }\n\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch'\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(plugins, pluginEvents.FETCH_DID_FAIL); // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n\n  const originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err\n    });\n  } // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n\n\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796\n\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED].call(plugin, {\n          event,\n          request: pluginFilteredRequest,\n          response: fetchResponse\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone()\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch\n};\nexport { fetchWrapper };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-core/_private/fetchWrapper.mjs"],"names":["WorkboxError","logger","assert","getFriendlyURL","pluginEvents","pluginUtils","wrappedFetch","request","fetchOptions","event","plugins","preloadResponse","possiblePreloadResponse","process","env","NODE_ENV","log","url","Request","isInstance","paramName","expectedClass","moduleName","className","funcName","failedFetchPlugins","filter","FETCH_DID_FAIL","originalRequest","length","clone","plugin","REQUEST_WILL_FETCH","call","CACHED_RESPONSE_WILL_BE_USED","isReturnValueProblem","err","thrownError","pluginFilteredRequest","fetchResponse","mode","fetch","debug","status","FETCH_DID_SUCCEED","response","Response","error","fetchWrapper"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {assert} from './assert.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport {pluginEvents} from '../models/pluginEvents.mjs';\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({\n  request,\n  fetchOptions,\n  event,\n  plugins = []}) => {\n  // We *should* be able to call `await event.preloadResponse` even if it's\n  // undefined, but for some reason, doing so leads to errors in our Node unit\n  // tests. To work around that, explicitly check preloadResponse's value first.\n  if (event && event.preloadResponse) {\n    const possiblePreloadResponse = await event.preloadResponse;\n    if (possiblePreloadResponse) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Using a preloaded navigation response for ` +\n          `'${getFriendlyURL(request.url)}'`);\n      }\n      return possiblePreloadResponse;\n    }\n  }\n\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isInstance(request, Request, {\n      paramName: request,\n      expectedClass: 'Request',\n      moduleName: 'workbox-core',\n      className: 'fetchWrapper',\n      funcName: 'wrappedFetch',\n    });\n  }\n\n  const failedFetchPlugins = pluginUtils.filter(\n      plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n          event,\n        });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (request) {\n            assert.isInstance(request, Request, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  let pluginFilteredRequest = request.clone();\n\n  try {\n    let fetchResponse;\n\n    // See https://github.com/GoogleChrome/workbox/issues/1796\n    if (request.mode === 'navigate') {\n      fetchResponse = await fetch(request);\n    } else {\n      fetchResponse = await fetch(request, fetchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${fetchResponse.status}'.`);\n    }\n\n    for (const plugin of plugins) {\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\n            .call(plugin, {\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse,\n            });\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (fetchResponse) {\n            assert.isInstance(fetchResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\n              isReturnValueProblem: true,\n            });\n          }\n        }\n      }\n    }\n\n    return fetchResponse;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\n    }\n\n    for (const plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        error,\n        event,\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw error;\n  }\n};\n\nconst fetchWrapper = {\n  fetch: wrappedFetch,\n};\n\nexport {fetchWrapper};\n"]},"metadata":{},"sourceType":"module"}