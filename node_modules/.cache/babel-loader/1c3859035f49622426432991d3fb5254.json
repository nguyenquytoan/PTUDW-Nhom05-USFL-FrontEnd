{"ast":null,"code":"'use strict';\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function _child_process() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = _interopRequireDefault(require('events'));\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = _interopRequireDefault(require('os'));\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sane() {\n  const data = _interopRequireDefault(require('sane'));\n\n  _sane = function _sane() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _invariant() {\n  const data = _interopRequireDefault(require('invariant'));\n\n  _invariant = function _invariant() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function _jestSerializer() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function _jestWorker() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _worker = require('./worker');\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./lib/WatchmanWatcher'));\n\nvar _FSEventsWatcher = _interopRequireDefault(require('./lib/FSEventsWatcher'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\n\nconst NODE_MODULES = _path().default.sep + 'node_modules' + _path().default.sep;\n\nconst PACKAGE_JSON = _path().default.sep + 'package.json'; // TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\n\nconst _require = require('../package.json'),\n      VERSION = _require.version;\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch (e) {}\n\n  return false;\n})();\n\nconst escapePathSeparator = string => _path().default.sep === '\\\\' ? string.replace(/(\\/|\\\\)/g, '\\\\\\\\') : string;\n\nconst getWhiteList = list => {\n  if (list && list.length) {\n    const newList = list.map(item => escapePathSeparator(item.replace(/(\\/)/g, _path().default.sep)));\n    return new RegExp('(' + escapePathSeparator(NODE_MODULES) + '(?:' + newList.join('|') + ')(?=$|' + escapePathSeparator(_path().default.sep) + '))', 'g');\n  }\n\n  return null;\n};\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\n/* eslint-disable-next-line no-redeclare */\n\n\nclass HasteMap extends _events().default {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_whitelist', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || _os().default.tmpdir(),\n      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      ignorePattern: options.ignorePattern,\n      mapper: options.mapper,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern && !(options.ignorePattern instanceof RegExp)) {\n      this._console.warn('jest-haste-map: the `ignorePattern` options as a function is being ' + 'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.');\n    }\n\n    const rootDirHash = _crypto().default.createHash('md5').update(options.rootDir).digest('hex');\n\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, `haste-map-${this._options.name}-${rootDirHash}`, VERSION, this._options.name, this._options.roots.map(root => fastPath.relative(options.rootDir, root)).join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash);\n    this._whitelist = getWhiteList(options.providesModuleNodeModules);\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name, ...extra) {\n    const hash = _crypto().default.createHash('md5').update(extra.join(''));\n\n    return _path().default.join(tmpdir, name.replace(/\\W/g, '-') + '-' + hash.digest('hex'));\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    var _this = this;\n\n    if (!this._buildPromise) {\n      this._buildPromise = _asyncToGenerator(function* () {\n        const data = yield _this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0) {\n          hasteMap = yield _this._buildHasteMap(data);\n\n          _this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = _this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;\n\n        yield _this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch (err) {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n\n  _buildFileMap() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let hasteMap;\n\n      try {\n        const read = _this2._options.resetCache ? _this2._createEmptyMap : _this2.read;\n        hasteMap = yield read.call(_this2);\n      } catch (_unused) {\n        hasteMap = _this2._createEmptyMap();\n      }\n\n      return _this2._crawl(hasteMap);\n    })();\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform = (0, _getPlatformExtension.default)(module[_constants.default.PATH], this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (existingModule && existingModule[_constants.default.PATH] !== module[_constants.default.PATH]) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](['jest-haste-map: Haste module naming collision: ' + id, '  The following files share their name; please adjust your hasteImpl:', '    * <rootDir>' + _path().default.sep + existingModule[_constants.default.PATH], '    * <rootDir>' + _path().default.sep + module[_constants.default.PATH], ''].join('\\n'));\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(existingModule[_constants.default.PATH], module[_constants.default.PATH]);\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([[module[_constants.default.PATH], module[_constants.default.TYPE]], [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]]]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error('jest-haste-map: File to process was not found in the haste map.');\n    }\n\n    const moduleMetadata = hasteMap.map.get(fileMetadata[_constants.default.ID]);\n    const computeSha1 = this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM) : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      } // @ts-ignore: checking error code is OK if error comes from \"fs\".\n\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n\n    if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions).getSha1({\n          computeDependencies: this._options.computeDependencies,\n          computeSha1,\n          dependencyExtractor: this._options.dependencyExtractor,\n          filePath,\n          hasteImplModulePath: this._options.hasteImplModulePath,\n          rootDir\n        }).then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n          this._console[method](['jest-haste-map: duplicate manual mock found: ' + mockPath, '  The following files share their name; please delete one of them:', '    * <rootDir>' + _path().default.sep + existingMockPath, '    * <rootDir>' + _path().default.sep + secondMockPath, ''].join('\\n'));\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions).worker({\n      computeDependencies: this._options.computeDependencies,\n      computeSha1,\n      dependencyExtractor: this._options.dependencyExtractor,\n      filePath,\n      hasteImplModulePath: this._options.hasteImplModulePath,\n      rootDir\n    }).then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const removedFiles = data.removedFiles,\n          changedFiles = data.changedFiles,\n          hasteMap = data.hasteMap; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = removedFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const _step$value = _slicedToArray(_step.value, 2),\n              relativeFilePath = _step$value[0],\n              fileMetadata = _step$value[1];\n\n        this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants.default.ID]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    const promises = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = filesToProcess.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        const relativeFilePath = _step2.value;\n\n        if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {\n          continue;\n        } // SHA-1, if requested, should already be present thanks to the crawler.\n\n\n        const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);\n\n        const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n        if (promise) {\n          promises.push(promise);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return Promise.all(promises).then(() => {\n      this._cleanup();\n\n      hasteMap.map = map;\n      hasteMap.mocks = mocks;\n      return hasteMap;\n    }, error => {\n      this._cleanup();\n\n      throw error;\n    });\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-ignore\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-ignore\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if (options && options.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-ignore: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker().default)(require.resolve('./worker'), {\n          exposedMethods: ['getSha1', 'worker'],\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers\n        });\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl = canUseWatchman && this._options.useWatchman ? _watchman.default : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      mapper: options.mapper,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn(`jest-haste-map: Watchman crawl failed. Retrying once with node ` + `crawler.\\n` + `  Usually this happens when watchman isn't running. Create an ` + `empty \\`.watchmanconfig\\` file in your project's root folder or ` + `initialize a git or hg repository in your project.\\n` + `  ` + error);\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error(`Crawler retry failed:\\n` + `  Original error: ${error.message}\\n` + `  Retry error: ${e.message}\\n`);\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher = canUseWatchman && this._options.useWatchman ? _WatchmanWatcher.default : _FSEventsWatcher.default.isSupported() ? _FSEventsWatcher.default : _sane().default.NodeWatcher;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      // @ts-ignore: TODO how? \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"\n      const watcher = new Watcher(root, {\n        dot: false,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = _path().default.join(root, (0, _normalizePathSep.default)(filePath));\n\n      if (stat && stat.isDirectory() || this._ignore(filePath) || !extensions.some(extension => filePath.endsWith(extension))) {\n        return;\n      }\n\n      changeQueue = changeQueue.then(() => {\n        // If we get duplicate events for the same file, ignore them.\n        if (eventsQueue.find(event => event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {\n          return null;\n        }\n\n        if (mustCopy) {\n          mustCopy = false;\n          hasteMap = {\n            clocks: new Map(hasteMap.clocks),\n            duplicates: new Map(hasteMap.duplicates),\n            files: new Map(hasteMap.files),\n            map: new Map(hasteMap.map),\n            mocks: new Map(hasteMap.mocks)\n          };\n        }\n\n        const add = () => {\n          eventsQueue.push({\n            filePath,\n            stat,\n            type\n          });\n          return null;\n        };\n\n        const relativeFilePath = fastPath.relative(rootDir, filePath);\n        const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n        if (fileMetadata != null) {\n          const moduleName = fileMetadata[_constants.default.ID];\n\n          const platform = (0, _getPlatformExtension.default)(filePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n          hasteMap.files.delete(relativeFilePath);\n          let moduleMap = hasteMap.map.get(moduleName);\n\n          if (moduleMap != null) {\n            // We are forced to copy the object because jest-haste-map exposes\n            // the map as an immutable entity.\n            moduleMap = copy(moduleMap);\n            delete moduleMap[platform];\n\n            if (Object.keys(moduleMap).length === 0) {\n              hasteMap.map.delete(moduleName);\n            } else {\n              hasteMap.map.set(moduleName, moduleMap);\n            }\n          }\n\n          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {\n            const mockName = (0, _getMockName.default)(filePath);\n            hasteMap.mocks.delete(mockName);\n          }\n\n          this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n        } // If the file was added or changed,\n        // parse it and update the haste map.\n\n\n        if (type === 'add' || type === 'change') {\n          (0, _invariant().default)(stat, 'since the file exists or changed, it should have stats');\n          const fileMetadata = ['', stat ? stat.mtime.getTime() : -1, stat ? stat.size : 0, 0, '', null];\n          hasteMap.files.set(relativeFilePath, fileMetadata);\n\n          const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {\n            forceInBand: true\n          }); // Cleanup\n\n\n          this._cleanup();\n\n          if (promise) {\n            return promise.then(add);\n          } else {\n            // If a file in node_modules has changed,\n            // emit an event regardless.\n            add();\n          }\n        } else {\n          add();\n        }\n\n        return null;\n      }).catch(error => {\n        this._console.error(`jest-haste-map: watch error:\\n  ${error.stack}\\n`);\n      });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(watchers => {\n      this._watchers = watchers;\n    });\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform = (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  end() {\n    // @ts-ignore: TODO TS cannot decide if `setInterval` and `clearInterval` comes from NodeJS or the DOM\n    clearInterval(this._changeInterval);\n\n    if (!this._watchers.length) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(this._watchers.map(watcher => new Promise(resolve => watcher.close(resolve)))).then(() => {\n      this._watchers = [];\n    });\n  }\n  /**\n   * Helpers\n   */\n\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);\n    return ignoreMatched || !this._options.retainAllFiles && this._isNodeModulesDir(filePath);\n  }\n\n  _isNodeModulesDir(filePath) {\n    if (!filePath.includes(NODE_MODULES)) {\n      return false;\n    }\n\n    if (this._whitelist) {\n      const whitelist = this._whitelist;\n      const match = whitelist.exec(filePath);\n      const matchEndIndex = whitelist.lastIndex;\n      whitelist.lastIndex = 0;\n\n      if (!match) {\n        return true;\n      }\n\n      const filePathInPackage = filePath.substr(matchEndIndex);\n      return filePathInPackage.startsWith(NODE_MODULES);\n    }\n\n    return true;\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n\n}\n\n_defineProperty(HasteMap, 'H', void 0);\n\n_defineProperty(HasteMap, 'DuplicateError', void 0);\n\n_defineProperty(HasteMap, 'ModuleMap', void 0);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n\n}\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n\nHasteMap.H = _constants.default;\nHasteMap.DuplicateError = DuplicateError;\nHasteMap.ModuleMap = _ModuleMap.default;\nmodule.exports = HasteMap;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-haste-map/build/index.js"],"names":["_child_process","data","require","_crypto","_interopRequireDefault","_events","_os","_path","_sane","_invariant","_jestSerializer","_jestWorker","_worker","_getMockName","_getPlatformExtension","_constants","_HasteFS","_ModuleMap","_node","_normalizePathSep","_watchman","_WatchmanWatcher","_FSEventsWatcher","fastPath","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","desc","defineProperty","getOwnPropertyDescriptor","get","set","default","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","_defineProperty","enumerable","configurable","writable","CHANGE_INTERVAL","MAX_WAIT_TIME","NODE_MODULES","sep","PACKAGE_JSON","_require","VERSION","version","canUseWatchman","execSync","stdio","e","escapePathSeparator","string","replace","getWhiteList","list","newList","map","item","RegExp","join","HasteMap","constructor","options","_options","cacheDirectory","tmpdir","computeDependencies","computeSha1","dependencyExtractor","extensions","forceNodeFilesystemAPI","hasteImplModulePath","ignorePattern","mapper","maxWorkers","mocksPattern","name","platforms","resetCache","retainAllFiles","rootDir","roots","from","Set","skipPackageJson","throwOnModuleCollision","useWatchman","watch","_console","console","global","warn","rootDirHash","createHash","update","digest","hasteImplHash","dependencyExtractorHash","hasteImpl","getCacheKey","String","_cachePath","getCacheFilePath","root","relative","toString","_whitelist","providesModuleNodeModules","_buildPromise","_watchers","extra","hash","build","_this","_buildFileMap","hasteMap","changedFiles","size","removedFiles","_buildHasteMap","_persist","hasteFS","files","moduleMap","duplicates","mocks","__hasteMapForTest","process","env","NODE_ENV","_watch","read","readFileSync","_createEmptyMap","readModuleMap","_this2","_unused","_crawl","_processFile","filePath","workerOptions","setModule","id","module","create","platform","PATH","GENERIC_PLATFORM","existingModule","method","DuplicateError","keys","delete","dupsByPlatform","Map","dups","TYPE","relativeFilePath","fileMetadata","Error","moduleMetadata","ID","SHA1","workerReply","metadata","VISITED","metadataId","metadataModule","DEPENDENCIES","dependencies","DEPENDENCY_DELIM","sha1","workerError","message","stack","includes","code","_isNodeModulesDir","_getWorker","getSha1","test","mockPath","existingMockPath","secondMockPath","moduleId","modulesByPlatform","worker","filesToProcess","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_step$value","_recoverDuplicates","return","promises","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","endsWith","promise","all","_cleanup","end","writeFileSync","forceInBand","exposedMethods","maxRetries","numWorkers","ignore","_ignore","bind","crawl","crawlerOptions","retry","catch","Watcher","isSupported","NodeWatcher","changeQueue","eventsQueue","mustCopy","createWatcher","watcher","dot","glob","extension","ignored","rejectTimeout","setTimeout","once","clearTimeout","on","onChange","emitChange","changeEvent","emit","type","stat","isDirectory","some","find","event","mtime","getTime","clocks","add","moduleName","copy","mockName","_changeInterval","setInterval","watchers","copyMap","uniqueModule","entries","dedupMap","clearInterval","close","ignoreMatched","whitelist","match","exec","matchEndIndex","lastIndex","filePathInPackage","substr","startsWith","mockPath1","mockPath2","object","assign","input","H","ModuleMap","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _child_process() {\n  const data = require('child_process');\n\n  _child_process = function _child_process() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _crypto() {\n  const data = _interopRequireDefault(require('crypto'));\n\n  _crypto = function _crypto() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _events() {\n  const data = _interopRequireDefault(require('events'));\n\n  _events = function _events() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  const data = _interopRequireDefault(require('os'));\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require('path'));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sane() {\n  const data = _interopRequireDefault(require('sane'));\n\n  _sane = function _sane() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _invariant() {\n  const data = _interopRequireDefault(require('invariant'));\n\n  _invariant = function _invariant() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSerializer() {\n  const data = _interopRequireDefault(require('jest-serializer'));\n\n  _jestSerializer = function _jestSerializer() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestWorker() {\n  const data = _interopRequireDefault(require('jest-worker'));\n\n  _jestWorker = function _jestWorker() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _worker = require('./worker');\n\nvar _getMockName = _interopRequireDefault(require('./getMockName'));\n\nvar _getPlatformExtension = _interopRequireDefault(\n  require('./lib/getPlatformExtension')\n);\n\nvar _constants = _interopRequireDefault(require('./constants'));\n\nvar _HasteFS = _interopRequireDefault(require('./HasteFS'));\n\nvar _ModuleMap = _interopRequireDefault(require('./ModuleMap'));\n\nvar _node = _interopRequireDefault(require('./crawlers/node'));\n\nvar _normalizePathSep = _interopRequireDefault(\n  require('./lib/normalizePathSep')\n);\n\nvar _watchman = _interopRequireDefault(require('./crawlers/watchman'));\n\nvar _WatchmanWatcher = _interopRequireDefault(require('./lib/WatchmanWatcher'));\n\nvar _FSEventsWatcher = _interopRequireDefault(require('./lib/FSEventsWatcher'));\n\nvar fastPath = _interopRequireWildcard(require('./lib/fast_path'));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc =\n            Object.defineProperty && Object.getOwnPropertyDescriptor\n              ? Object.getOwnPropertyDescriptor(obj, key)\n              : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()\n  );\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance');\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (\n      var _i = arr[Symbol.iterator](), _s;\n      !(_n = (_s = _i.next()).done);\n      _n = true\n    ) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i['return'] != null) _i['return']();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self = this,\n      args = arguments;\n    return new Promise(function(resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240000;\n\nconst NODE_MODULES = _path().default.sep + 'node_modules' + _path().default.sep;\n\nconst PACKAGE_JSON = _path().default.sep + 'package.json'; // TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\n\nconst _require = require('../package.json'),\n  VERSION = _require.version;\n\nconst canUseWatchman = (() => {\n  try {\n    (0, _child_process().execSync)('watchman --version', {\n      stdio: ['ignore']\n    });\n    return true;\n  } catch (e) {}\n\n  return false;\n})();\n\nconst escapePathSeparator = string =>\n  _path().default.sep === '\\\\' ? string.replace(/(\\/|\\\\)/g, '\\\\\\\\') : string;\n\nconst getWhiteList = list => {\n  if (list && list.length) {\n    const newList = list.map(item =>\n      escapePathSeparator(item.replace(/(\\/)/g, _path().default.sep))\n    );\n    return new RegExp(\n      '(' +\n        escapePathSeparator(NODE_MODULES) +\n        '(?:' +\n        newList.join('|') +\n        ')(?=$|' +\n        escapePathSeparator(_path().default.sep) +\n        '))',\n      'g'\n    );\n  }\n\n  return null;\n};\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\n\n/* eslint-disable-next-line no-redeclare */\n\nclass HasteMap extends _events().default {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, '_buildPromise', void 0);\n\n    _defineProperty(this, '_cachePath', void 0);\n\n    _defineProperty(this, '_changeInterval', void 0);\n\n    _defineProperty(this, '_console', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_watchers', void 0);\n\n    _defineProperty(this, '_whitelist', void 0);\n\n    _defineProperty(this, '_worker', void 0);\n\n    this._options = {\n      cacheDirectory: options.cacheDirectory || _os().default.tmpdir(),\n      computeDependencies:\n        options.computeDependencies === undefined\n          ? true\n          : options.computeDependencies,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      ignorePattern: options.ignorePattern,\n      mapper: options.mapper,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern\n        ? new RegExp(options.mocksPattern)\n        : null,\n      name: options.name,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: Array.from(new Set(options.roots)),\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman == null ? true : options.useWatchman,\n      watch: !!options.watch\n    };\n    this._console = options.console || global.console;\n\n    if (options.ignorePattern && !(options.ignorePattern instanceof RegExp)) {\n      this._console.warn(\n        'jest-haste-map: the `ignorePattern` options as a function is being ' +\n          'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.'\n      );\n    }\n\n    const rootDirHash = _crypto()\n      .default.createHash('md5')\n      .update(options.rootDir)\n      .digest('hex');\n\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor = require(options.dependencyExtractor);\n\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(\n      this._options.cacheDirectory,\n      `haste-map-${this._options.name}-${rootDirHash}`,\n      VERSION,\n      this._options.name,\n      this._options.roots\n        .map(root => fastPath.relative(options.rootDir, root))\n        .join(':'),\n      this._options.extensions.join(':'),\n      this._options.platforms.join(':'),\n      this._options.computeSha1.toString(),\n      options.mocksPattern || '',\n      (options.ignorePattern || '').toString(),\n      hasteImplHash,\n      dependencyExtractorHash\n    );\n    this._whitelist = getWhiteList(options.providesModuleNodeModules);\n    this._buildPromise = null;\n    this._watchers = [];\n    this._worker = null;\n  }\n\n  static getCacheFilePath(tmpdir, name, ...extra) {\n    const hash = _crypto()\n      .default.createHash('md5')\n      .update(extra.join(''));\n\n    return _path().default.join(\n      tmpdir,\n      name.replace(/\\W/g, '-') + '-' + hash.digest('hex')\n    );\n  }\n\n  getCacheFilePath() {\n    return this._cachePath;\n  }\n\n  build() {\n    var _this = this;\n\n    if (!this._buildPromise) {\n      this._buildPromise = _asyncToGenerator(function*() {\n        const data = yield _this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n\n        let hasteMap;\n\n        if (\n          data.changedFiles === undefined ||\n          data.changedFiles.size > 0 ||\n          data.removedFiles.size > 0\n        ) {\n          hasteMap = yield _this._buildHasteMap(data);\n\n          _this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = _this._options.rootDir;\n        const hasteFS = new _HasteFS.default({\n          files: hasteMap.files,\n          rootDir\n        });\n        const moduleMap = new _ModuleMap.default({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir\n        });\n\n        const __hasteMapForTest =\n          (process.env.NODE_ENV === 'test' && hasteMap) || null;\n\n        yield _this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap\n        };\n      })();\n    }\n\n    return this._buildPromise;\n  }\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n\n  read() {\n    let hasteMap;\n\n    try {\n      hasteMap = _jestSerializer().default.readFileSync(this._cachePath);\n    } catch (err) {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap() {\n    const data = this.read();\n    return new _ModuleMap.default({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir\n    });\n  }\n  /**\n   * 2. crawl the file system.\n   */\n\n  _buildFileMap() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function*() {\n      let hasteMap;\n\n      try {\n        const read = _this2._options.resetCache\n          ? _this2._createEmptyMap\n          : _this2.read;\n        hasteMap = yield read.call(_this2);\n      } catch (_unused) {\n        hasteMap = _this2._createEmptyMap();\n      }\n\n      return _this2._crawl(hasteMap);\n    })();\n  }\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n\n  _processFile(hasteMap, map, mocks, filePath, workerOptions) {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id, module) => {\n      let moduleMap = map.get(id);\n\n      if (!moduleMap) {\n        moduleMap = Object.create(null);\n        map.set(id, moduleMap);\n      }\n\n      const platform =\n        (0, _getPlatformExtension.default)(\n          module[_constants.default.PATH],\n          this._options.platforms\n        ) || _constants.default.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (\n        existingModule &&\n        existingModule[_constants.default.PATH] !==\n          module[_constants.default.PATH]\n      ) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](\n          [\n            'jest-haste-map: Haste module naming collision: ' + id,\n            '  The following files share their name; please adjust your hasteImpl:',\n            '    * <rootDir>' +\n              _path().default.sep +\n              existingModule[_constants.default.PATH],\n            '    * <rootDir>' +\n              _path().default.sep +\n              module[_constants.default.PATH],\n            ''\n          ].join('\\n')\n        );\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(\n            existingModule[_constants.default.PATH],\n            module[_constants.default.PATH]\n          );\n        } // We do NOT want consumers to use a module that is ambiguous.\n\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([\n          [module[_constants.default.PATH], module[_constants.default.TYPE]],\n          [\n            existingModule[_constants.default.PATH],\n            existingModule[_constants.default.TYPE]\n          ]\n        ]);\n        dupsByPlatform.set(platform, dups);\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n\n        if (dups != null) {\n          dups.set(\n            module[_constants.default.PATH],\n            module[_constants.default.TYPE]\n          );\n        }\n\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n    if (!fileMetadata) {\n      throw new Error(\n        'jest-haste-map: File to process was not found in the haste map.'\n      );\n    }\n\n    const moduleMetadata = hasteMap.map.get(\n      fileMetadata[_constants.default.ID]\n    );\n    const computeSha1 =\n      this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.\n\n    const workerReply = metadata => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[_constants.default.VISITED] = 1;\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[_constants.default.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies\n        ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM)\n        : '';\n\n      if (computeSha1) {\n        fileMetadata[_constants.default.SHA1] = metadata.sha1;\n      }\n    }; // Callback called when the response from the worker is an error.\n\n    const workerError = error => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      } // @ts-ignore: checking error code is OK if error comes from \"fs\".\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      } // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n\n      hasteMap.files.delete(relativeFilePath);\n    }; // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n\n    if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions)\n          .getSha1({\n            computeDependencies: this._options.computeDependencies,\n            computeSha1,\n            dependencyExtractor: this._options.dependencyExtractor,\n            filePath,\n            hasteImplModulePath: this._options.hasteImplModulePath,\n            rootDir\n          })\n          .then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (\n      this._options.mocksPattern &&\n      this._options.mocksPattern.test(filePath)\n    ) {\n      const mockPath = (0, _getMockName.default)(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision\n            ? 'error'\n            : 'warn';\n\n          this._console[method](\n            [\n              'jest-haste-map: duplicate manual mock found: ' + mockPath,\n              '  The following files share their name; please delete one of them:',\n              '    * <rootDir>' + _path().default.sep + existingMockPath,\n              '    * <rootDir>' + _path().default.sep + secondMockPath,\n              ''\n            ].join('\\n')\n          );\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[_constants.default.VISITED]) {\n      if (!fileMetadata[_constants.default.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform =\n          (0, _getPlatformExtension.default)(\n            filePath,\n            this._options.platforms\n          ) || _constants.default.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[_constants.default.ID];\n        let modulesByPlatform = map.get(moduleId);\n\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null);\n          map.set(moduleId, modulesByPlatform);\n        }\n\n        modulesByPlatform[platform] = module;\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions)\n      .worker({\n        computeDependencies: this._options.computeDependencies,\n        computeSha1,\n        dependencyExtractor: this._options.dependencyExtractor,\n        filePath,\n        hasteImplModulePath: this._options.hasteImplModulePath,\n        rootDir\n      })\n      .then(workerReply, workerError);\n  }\n\n  _buildHasteMap(data) {\n    const removedFiles = data.removedFiles,\n      changedFiles = data.changedFiles,\n      hasteMap = data.hasteMap; // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n\n    let map;\n    let mocks;\n    let filesToProcess;\n\n    if (changedFiles === undefined || removedFiles.size) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (\n        var _iterator = removedFiles[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n      ) {\n        const _step$value = _slicedToArray(_step.value, 2),\n          relativeFilePath = _step$value[0],\n          fileMetadata = _step$value[1];\n\n        this._recoverDuplicates(\n          hasteMap,\n          relativeFilePath,\n          fileMetadata[_constants.default.ID]\n        );\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    const promises = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (\n        var _iterator2 = filesToProcess.keys()[Symbol.iterator](), _step2;\n        !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);\n        _iteratorNormalCompletion2 = true\n      ) {\n        const relativeFilePath = _step2.value;\n\n        if (\n          this._options.skipPackageJson &&\n          relativeFilePath.endsWith(PACKAGE_JSON)\n        ) {\n          continue;\n        } // SHA-1, if requested, should already be present thanks to the crawler.\n\n        const filePath = fastPath.resolve(\n          this._options.rootDir,\n          relativeFilePath\n        );\n\n        const promise = this._processFile(hasteMap, map, mocks, filePath);\n\n        if (promise) {\n          promises.push(promise);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return Promise.all(promises).then(\n      () => {\n        this._cleanup();\n\n        hasteMap.map = map;\n        hasteMap.mocks = mocks;\n        return hasteMap;\n      },\n      error => {\n        this._cleanup();\n\n        throw error;\n      }\n    );\n  }\n\n  _cleanup() {\n    const worker = this._worker; // @ts-ignore\n\n    if (worker && typeof worker.end === 'function') {\n      // @ts-ignore\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n\n  _persist(hasteMap) {\n    _jestSerializer().default.writeFileSync(this._cachePath, hasteMap);\n  }\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n\n  _getWorker(options) {\n    if (!this._worker) {\n      if ((options && options.forceInBand) || this._options.maxWorkers <= 1) {\n        this._worker = {\n          getSha1: _worker.getSha1,\n          worker: _worker.worker\n        };\n      } else {\n        // @ts-ignore: assignment of a worker with custom properties.\n        this._worker = new (_jestWorker()).default(\n          require.resolve('./worker'),\n          {\n            exposedMethods: ['getSha1', 'worker'],\n            maxRetries: 3,\n            numWorkers: this._options.maxWorkers\n          }\n        );\n      }\n    }\n\n    return this._worker;\n  }\n\n  _crawl(hasteMap) {\n    const options = this._options;\n\n    const ignore = this._ignore.bind(this);\n\n    const crawl =\n      canUseWatchman && this._options.useWatchman\n        ? _watchman.default\n        : _node.default;\n    const crawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      mapper: options.mapper,\n      rootDir: options.rootDir,\n      roots: options.roots\n    };\n\n    const retry = error => {\n      if (crawl === _watchman.default) {\n        this._console.warn(\n          `jest-haste-map: Watchman crawl failed. Retrying once with node ` +\n            `crawler.\\n` +\n            `  Usually this happens when watchman isn't running. Create an ` +\n            `empty \\`.watchmanconfig\\` file in your project's root folder or ` +\n            `initialize a git or hg repository in your project.\\n` +\n            `  ` +\n            error\n        );\n\n        return (0, _node.default)(crawlerOptions).catch(e => {\n          throw new Error(\n            `Crawler retry failed:\\n` +\n              `  Original error: ${error.message}\\n` +\n              `  Retry error: ${e.message}\\n`\n          );\n        });\n      }\n\n      throw error;\n    };\n\n    try {\n      return crawl(crawlerOptions).catch(retry);\n    } catch (error) {\n      return retry(error);\n    }\n  }\n  /**\n   * Watch mode\n   */\n\n  _watch(hasteMap) {\n    if (!this._options.watch) {\n      return Promise.resolve();\n    } // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n\n    const Watcher =\n      canUseWatchman && this._options.useWatchman\n        ? _WatchmanWatcher.default\n        : _FSEventsWatcher.default.isSupported()\n        ? _FSEventsWatcher.default\n        : _sane().default.NodeWatcher;\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n    let changeQueue = Promise.resolve();\n    let eventsQueue = []; // We only need to copy the entire haste map once on every \"frame\".\n\n    let mustCopy = true;\n\n    const createWatcher = root => {\n      // @ts-ignore: TODO how? \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\"\n      const watcher = new Watcher(root, {\n        dot: false,\n        glob: extensions.map(extension => '**/*.' + extension),\n        ignored: ignorePattern\n      });\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(\n          () => reject(new Error('Failed to start watch mode.')),\n          MAX_WAIT_TIME\n        );\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length) {\n        mustCopy = true;\n        const changeEvent = {\n          eventsQueue,\n          hasteFS: new _HasteFS.default({\n            files: hasteMap.files,\n            rootDir\n          }),\n          moduleMap: new _ModuleMap.default({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir\n          })\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (type, filePath, root, stat) => {\n      filePath = _path().default.join(\n        root,\n        (0, _normalizePathSep.default)(filePath)\n      );\n\n      if (\n        (stat && stat.isDirectory()) ||\n        this._ignore(filePath) ||\n        !extensions.some(extension => filePath.endsWith(extension))\n      ) {\n        return;\n      }\n\n      changeQueue = changeQueue\n        .then(() => {\n          // If we get duplicate events for the same file, ignore them.\n          if (\n            eventsQueue.find(\n              event =>\n                event.type === type &&\n                event.filePath === filePath &&\n                ((!event.stat && !stat) ||\n                  (!!event.stat &&\n                    !!stat &&\n                    event.stat.mtime.getTime() === stat.mtime.getTime()))\n            )\n          ) {\n            return null;\n          }\n\n          if (mustCopy) {\n            mustCopy = false;\n            hasteMap = {\n              clocks: new Map(hasteMap.clocks),\n              duplicates: new Map(hasteMap.duplicates),\n              files: new Map(hasteMap.files),\n              map: new Map(hasteMap.map),\n              mocks: new Map(hasteMap.mocks)\n            };\n          }\n\n          const add = () => {\n            eventsQueue.push({\n              filePath,\n              stat,\n              type\n            });\n            return null;\n          };\n\n          const relativeFilePath = fastPath.relative(rootDir, filePath);\n          const fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata\n\n          if (fileMetadata != null) {\n            const moduleName = fileMetadata[_constants.default.ID];\n\n            const platform =\n              (0, _getPlatformExtension.default)(\n                filePath,\n                this._options.platforms\n              ) || _constants.default.GENERIC_PLATFORM;\n\n            hasteMap.files.delete(relativeFilePath);\n            let moduleMap = hasteMap.map.get(moduleName);\n\n            if (moduleMap != null) {\n              // We are forced to copy the object because jest-haste-map exposes\n              // the map as an immutable entity.\n              moduleMap = copy(moduleMap);\n              delete moduleMap[platform];\n\n              if (Object.keys(moduleMap).length === 0) {\n                hasteMap.map.delete(moduleName);\n              } else {\n                hasteMap.map.set(moduleName, moduleMap);\n              }\n            }\n\n            if (\n              this._options.mocksPattern &&\n              this._options.mocksPattern.test(filePath)\n            ) {\n              const mockName = (0, _getMockName.default)(filePath);\n              hasteMap.mocks.delete(mockName);\n            }\n\n            this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n          } // If the file was added or changed,\n          // parse it and update the haste map.\n\n          if (type === 'add' || type === 'change') {\n            (0, _invariant().default)(\n              stat,\n              'since the file exists or changed, it should have stats'\n            );\n            const fileMetadata = [\n              '',\n              stat ? stat.mtime.getTime() : -1,\n              stat ? stat.size : 0,\n              0,\n              '',\n              null\n            ];\n            hasteMap.files.set(relativeFilePath, fileMetadata);\n\n            const promise = this._processFile(\n              hasteMap,\n              hasteMap.map,\n              hasteMap.mocks,\n              filePath,\n              {\n                forceInBand: true\n              }\n            ); // Cleanup\n\n            this._cleanup();\n\n            if (promise) {\n              return promise.then(add);\n            } else {\n              // If a file in node_modules has changed,\n              // emit an event regardless.\n              add();\n            }\n          } else {\n            add();\n          }\n\n          return null;\n        })\n        .catch(error => {\n          this._console.error(\n            `jest-haste-map: watch error:\\n  ${error.stack}\\n`\n          );\n        });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(\n      watchers => {\n        this._watchers = watchers;\n      }\n    );\n  }\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n\n  _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform =\n      (0, _getPlatformExtension.default)(\n        relativeFilePath,\n        this._options.platforms\n      ) || _constants.default.GENERIC_PLATFORM;\n\n    let dups = dupsByPlatform.get(platform);\n\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (dedupMap == null) {\n      dedupMap = Object.create(null);\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  end() {\n    // @ts-ignore: TODO TS cannot decide if `setInterval` and `clearInterval` comes from NodeJS or the DOM\n    clearInterval(this._changeInterval);\n\n    if (!this._watchers.length) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(\n      this._watchers.map(\n        watcher => new Promise(resolve => watcher.close(resolve))\n      )\n    ).then(() => {\n      this._watchers = [];\n    });\n  }\n  /**\n   * Helpers\n   */\n\n  _ignore(filePath) {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched =\n      ignorePattern instanceof RegExp\n        ? ignorePattern.test(filePath)\n        : ignorePattern && ignorePattern(filePath);\n    return (\n      ignoreMatched ||\n      (!this._options.retainAllFiles && this._isNodeModulesDir(filePath))\n    );\n  }\n\n  _isNodeModulesDir(filePath) {\n    if (!filePath.includes(NODE_MODULES)) {\n      return false;\n    }\n\n    if (this._whitelist) {\n      const whitelist = this._whitelist;\n      const match = whitelist.exec(filePath);\n      const matchEndIndex = whitelist.lastIndex;\n      whitelist.lastIndex = 0;\n\n      if (!match) {\n        return true;\n      }\n\n      const filePathInPackage = filePath.substr(matchEndIndex);\n      return filePathInPackage.startsWith(NODE_MODULES);\n    }\n\n    return true;\n  }\n\n  _createEmptyMap() {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map()\n    };\n  }\n}\n\n_defineProperty(HasteMap, 'H', void 0);\n\n_defineProperty(HasteMap, 'DuplicateError', void 0);\n\n_defineProperty(HasteMap, 'ModuleMap', void 0);\n\nclass DuplicateError extends Error {\n  constructor(mockPath1, mockPath2) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    _defineProperty(this, 'mockPath1', void 0);\n\n    _defineProperty(this, 'mockPath2', void 0);\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n}\n\nfunction copy(object) {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap(input) {\n  return new Map(input);\n}\n\nHasteMap.H = _constants.default;\nHasteMap.DuplicateError = DuplicateError;\nHasteMap.ModuleMap = _ModuleMap.default;\nmodule.exports = HasteMap;\n"]},"metadata":{},"sourceType":"script"}