{"ast":null,"code":"/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require a newline after each call in a method chain\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreChainWithDepth: {\n          type: \"integer\",\n          minimum: 1,\n          maximum: 10,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected line break before `{{callee}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Get the prefix of a given MemberExpression node.\n     * If the MemberExpression node is a computed value it returns a\n     * left bracket. If not it returns a period.\n     * @param  {ASTNode} node A MemberExpression node to get\n     * @returns {string} The prefix of the node.\n     */\n\n    function getPrefix(node) {\n      return node.computed ? \"[\" : \".\";\n    }\n    /**\n     * Gets the property text of a given MemberExpression node.\n     * If the text is multiline, this returns only the first line.\n     * @param {ASTNode} node A MemberExpression node to get.\n     * @returns {string} The property text of the node.\n     */\n\n\n    function getPropertyText(node) {\n      const prefix = getPrefix(node);\n      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n      const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n      return prefix + lines[0] + suffix;\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        if (!node.callee || node.callee.type !== \"MemberExpression\") {\n          return;\n        }\n\n        const callee = node.callee;\n        let parent = callee.object;\n        let depth = 1;\n\n        while (parent && parent.callee) {\n          depth += 1;\n          parent = parent.callee.object;\n        }\n\n        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n          context.report({\n            node: callee.property,\n            loc: callee.property.loc.start,\n            messageId: \"expected\",\n            data: {\n              callee: getPropertyText(callee)\n            },\n\n            fix(fixer) {\n              const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n              return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/newline-per-chained-call.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","properties","ignoreChainWithDepth","minimum","maximum","default","additionalProperties","messages","expected","create","context","options","sourceCode","getSourceCode","getPrefix","node","computed","getPropertyText","prefix","lines","getText","property","split","LINEBREAK_MATCHER","suffix","length","callee","parent","object","depth","isTokenOnSameLine","report","loc","start","messageId","data","fix","fixer","firstTokenAfterObject","getTokenAfter","isNotClosingParenToken","insertTextBefore"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10,\n                    default: 2\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            expected: \"Expected line break before `{{callee}}`.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get the prefix of a given MemberExpression node.\n         * If the MemberExpression node is a computed value it returns a\n         * left bracket. If not it returns a period.\n         * @param  {ASTNode} node A MemberExpression node to get\n         * @returns {string} The prefix of the node.\n         */\n        function getPrefix(node) {\n            return node.computed ? \"[\" : \".\";\n        }\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         * @param {ASTNode} node A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = getPrefix(node);\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                if (!node.callee || node.callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                const callee = node.callee;\n                let parent = callee.object;\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = parent.callee.object;\n                }\n\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n                    context.report({\n                        node: callee.property,\n                        loc: callee.property.loc.start,\n                        messageId: \"expected\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        },\n                        fix(fixer) {\n                            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}