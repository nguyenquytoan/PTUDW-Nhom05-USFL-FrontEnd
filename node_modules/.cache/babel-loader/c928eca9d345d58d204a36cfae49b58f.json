{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst MS_IN_A_YEAR = 31536000000; // TODO: Copied from `jest-util` to avoid cyclic dependency. Import from `jest-util` in the next major\n\nconst setGlobal = (globalToMutate, key, value) => {\n  // @ts-ignore: no index\n  globalToMutate[key] = value;\n};\n\nclass FakeTimers {\n  constructor({\n    global,\n    moduleMocker,\n    timerConfig,\n    config,\n    maxLoops\n  }) {\n    _defineProperty(this, '_cancelledImmediates', void 0);\n\n    _defineProperty(this, '_cancelledTicks', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_disposed', void 0);\n\n    _defineProperty(this, '_fakeTimerAPIs', void 0);\n\n    _defineProperty(this, '_global', void 0);\n\n    _defineProperty(this, '_immediates', void 0);\n\n    _defineProperty(this, '_maxLoops', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_now', void 0);\n\n    _defineProperty(this, '_ticks', void 0);\n\n    _defineProperty(this, '_timerAPIs', void 0);\n\n    _defineProperty(this, '_timers', void 0);\n\n    _defineProperty(this, '_uuidCounter', void 0);\n\n    _defineProperty(this, '_timerConfig', void 0);\n\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference\n\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n\n    this._createMocks();\n  }\n\n  clearAllTimers() {\n    this._immediates.forEach(immediate => this._fakeClearImmediate(immediate.uuid));\n\n    this._timers.clear();\n  }\n\n  dispose() {\n    this._disposed = true;\n    this.clearAllTimers();\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._cancelledImmediates = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = new Map();\n  }\n\n  runAllTicks() {\n    this._checkFakeTimers(); // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' ticks, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runAllImmediates() {\n    this._checkFakeTimers(); // Only run a generous number of immediates and then bail.\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n\n      if (immediate === undefined) {\n        break;\n      }\n\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' immediates, and there are still more! Assuming ' + \"we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  _runImmediate(immediate) {\n    if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n      // Callback may throw, so update the map prior calling.\n      this._cancelledImmediates[immediate.uuid] = true;\n      immediate.callback();\n    }\n  }\n\n  runAllTimers() {\n    this._checkFakeTimers();\n\n    this.runAllTicks();\n    this.runAllImmediates(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n\n\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n\n      if (this._ticks.length) {\n        this.runAllTicks();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runOnlyPendingTimers() {\n    // We need to hold the current shape of `this._timers` because existing\n    // timers can add new ones to the map and hence would run more than necessary.\n    // See https://github.com/facebook/jest/pull/4608 for details\n    const timerEntries = Array.from(this._timers.entries());\n\n    this._checkFakeTimers();\n\n    this._immediates.forEach(this._runImmediate, this);\n\n    timerEntries.sort(([, left], [, right]) => left.expiry - right.expiry).forEach(([timerHandle]) => this._runTimerHandle(timerHandle));\n  }\n\n  advanceTimersToNextTimer(steps = 1) {\n    if (steps < 1) {\n      return;\n    }\n\n    const nextExpiry = Array.from(this._timers.values()).reduce((minExpiry, timer) => {\n      if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n      return minExpiry;\n    }, null);\n\n    if (nextExpiry !== null) {\n      this.advanceTimersByTime(nextExpiry - this._now);\n      this.advanceTimersToNextTimer(steps - 1);\n    }\n  }\n\n  advanceTimersByTime(msToRun) {\n    this._checkFakeTimers(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n      if (timerHandle === null) {\n        break;\n      }\n\n      const timerValue = this._timers.get(timerHandle);\n\n      if (timerValue === undefined) {\n        break;\n      }\n\n      const nextTimerExpiry = timerValue.expiry;\n\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= nextTimerExpiry - this._now;\n        this._now = nextTimerExpiry;\n\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const prevClearImmediate = this._global.clearImmediate;\n    const prevClearInterval = this._global.clearInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevNextTick = this._global.process.nextTick;\n    const prevSetImmediate = this._global.setImmediate;\n    const prevSetInterval = this._global.setInterval;\n    const prevSetTimeout = this._global.setTimeout;\n    this.useRealTimers();\n    let cbErr = null;\n    let errThrown = false;\n\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.clearImmediate = prevClearImmediate;\n    this._global.clearInterval = prevClearInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.process.nextTick = prevNextTick;\n    this._global.setImmediate = prevSetImmediate;\n    this._global.setInterval = prevSetInterval;\n    this._global.setTimeout = prevSetTimeout;\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const global = this._global;\n    setGlobal(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n    setGlobal(global, 'clearInterval', this._timerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n    setGlobal(global, 'setImmediate', this._timerAPIs.setImmediate);\n    setGlobal(global, 'setInterval', this._timerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._timerAPIs.setTimeout);\n    global.process.nextTick = this._timerAPIs.nextTick;\n  }\n\n  useFakeTimers() {\n    this._createMocks();\n\n    const global = this._global;\n    setGlobal(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n    setGlobal(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n    setGlobal(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n    setGlobal(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n    global.process.nextTick = this._fakeTimerAPIs.nextTick;\n  }\n\n  getTimerCount() {\n    this._checkFakeTimers();\n\n    return this._timers.size + this._immediates.length + this._ticks.length;\n  }\n\n  _checkFakeTimers() {\n    if (this._global.setTimeout !== this._fakeTimerAPIs.setTimeout) {\n      this._global.console.warn(`A function to advance timers was called but the timers API is not ` + `mocked with fake timers. Call \\`jest.useFakeTimers()\\` in this ` + `test or enable fake timers globally by setting ` + `\\`\"timers\": \"fake\"\\` in ` + `the configuration file. This warning is likely a result of a ` + `default configuration change in Jest 15.\\n\\n` + `Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n` + `Stack Trace:\\n` + (0, _jestMessageUtil().formatStackTrace)(new Error().stack, this._config, {\n        noStackTrace: false\n      }));\n    }\n  }\n\n  _createMocks() {\n    const fn = (impl // @ts-ignore TODO: figure out better typings here\n    ) => this._moduleMocker.fn().mockImplementation(impl); // TODO: add better typings; these are mocks, but typed as regular timers\n\n\n    this._fakeTimerAPIs = {\n      clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n      clearInterval: fn(this._fakeClearTimer.bind(this)),\n      clearTimeout: fn(this._fakeClearTimer.bind(this)),\n      nextTick: fn(this._fakeNextTick.bind(this)),\n      setImmediate: fn(this._fakeSetImmediate.bind(this)),\n      setInterval: fn(this._fakeSetInterval.bind(this)),\n      setTimeout: fn(this._fakeSetTimeout.bind(this))\n    };\n  }\n\n  _fakeClearTimer(timerRef) {\n    const uuid = this._timerConfig.refToId(timerRef);\n\n    if (uuid) {\n      this._timers.delete(String(uuid));\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._cancelledImmediates[uuid] = true;\n  }\n\n  _fakeNextTick(callback, ...args) {\n    if (this._disposed) {\n      return;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._ticks.push({\n      callback: function (_callback) {\n        function callback() {\n          return _callback.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      uuid\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n\n    this._timerAPIs.nextTick(() => {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._immediates.push({\n      callback: function (_callback2) {\n        function callback() {\n          return _callback2.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback2.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      uuid: String(uuid)\n    });\n\n    const cancelledImmediates = this._cancelledImmediates;\n\n    this._timerAPIs.setImmediate(() => {\n      if (!cancelledImmediates.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledImmediates[String(uuid)] = true;\n        callback.apply(null, args);\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    if (intervalDelay == null) {\n      intervalDelay = 0;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: function (_callback3) {\n        function callback() {\n          return _callback3.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback3.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n      type: 'interval'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _fakeSetTimeout(callback, delay, ...args) {\n    if (this._disposed) {\n      return null;\n    } // eslint-disable-next-line no-bitwise\n\n\n    delay = Number(delay) | 0;\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: function (_callback4) {\n        function callback() {\n          return _callback4.apply(this, arguments);\n        }\n\n        callback.toString = function () {\n          return _callback4.toString();\n        };\n\n        return callback;\n      }(() => callback.apply(null, args)),\n      expiry: this._now + delay,\n      interval: undefined,\n      type: 'timeout'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let soonestTime = MS_IN_A_YEAR;\n\n    this._timers.forEach((timer, uuid) => {\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    });\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers.get(timerHandle);\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n\n        this._timers.delete(timerHandle);\n\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + (timer.interval || 0);\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n\n}\n\nexports.default = FakeTimers;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/@jest/fake-timers/build/jestFakeTimers.js"],"names":["Object","defineProperty","exports","value","default","_jestMessageUtil","data","require","_defineProperty","obj","key","enumerable","configurable","writable","MS_IN_A_YEAR","setGlobal","globalToMutate","FakeTimers","constructor","global","moduleMocker","timerConfig","config","maxLoops","_global","_timerConfig","_config","_maxLoops","_uuidCounter","_moduleMocker","_timerAPIs","clearImmediate","clearInterval","clearTimeout","nextTick","process","setImmediate","setInterval","setTimeout","reset","_createMocks","clearAllTimers","_immediates","forEach","immediate","_fakeClearImmediate","uuid","_timers","clear","dispose","_disposed","_cancelledTicks","_cancelledImmediates","_now","_ticks","Map","runAllTicks","_checkFakeTimers","i","tick","shift","undefined","hasOwnProperty","callback","Error","runAllImmediates","_runImmediate","runAllTimers","nextTimerHandle","_getNextTimerHandle","_runTimerHandle","length","runOnlyPendingTimers","timerEntries","Array","from","entries","sort","left","right","expiry","timerHandle","advanceTimersToNextTimer","steps","nextExpiry","values","reduce","minExpiry","timer","advanceTimersByTime","msToRun","timerValue","get","nextTimerExpiry","runWithRealTimers","cb","prevClearImmediate","prevClearInterval","prevClearTimeout","prevNextTick","prevSetImmediate","prevSetInterval","prevSetTimeout","useRealTimers","cbErr","errThrown","e","useFakeTimers","_fakeTimerAPIs","getTimerCount","size","console","warn","formatStackTrace","stack","noStackTrace","fn","impl","mockImplementation","bind","_fakeClearTimer","_fakeNextTick","_fakeSetImmediate","_fakeSetInterval","_fakeSetTimeout","timerRef","refToId","delete","String","args","push","_callback","apply","arguments","toString","cancelledTicks","_callback2","cancelledImmediates","intervalDelay","set","_callback3","interval","type","idToRef","delay","Number","_callback4","soonestTime"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function _jestMessageUtil() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst MS_IN_A_YEAR = 31536000000; // TODO: Copied from `jest-util` to avoid cyclic dependency. Import from `jest-util` in the next major\n\nconst setGlobal = (globalToMutate, key, value) => {\n  // @ts-ignore: no index\n  globalToMutate[key] = value;\n};\n\nclass FakeTimers {\n  constructor({global, moduleMocker, timerConfig, config, maxLoops}) {\n    _defineProperty(this, '_cancelledImmediates', void 0);\n\n    _defineProperty(this, '_cancelledTicks', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_disposed', void 0);\n\n    _defineProperty(this, '_fakeTimerAPIs', void 0);\n\n    _defineProperty(this, '_global', void 0);\n\n    _defineProperty(this, '_immediates', void 0);\n\n    _defineProperty(this, '_maxLoops', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_now', void 0);\n\n    _defineProperty(this, '_ticks', void 0);\n\n    _defineProperty(this, '_timerAPIs', void 0);\n\n    _defineProperty(this, '_timers', void 0);\n\n    _defineProperty(this, '_uuidCounter', void 0);\n\n    _defineProperty(this, '_timerConfig', void 0);\n\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference\n\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n\n    this._createMocks();\n  }\n\n  clearAllTimers() {\n    this._immediates.forEach(immediate =>\n      this._fakeClearImmediate(immediate.uuid)\n    );\n\n    this._timers.clear();\n  }\n\n  dispose() {\n    this._disposed = true;\n    this.clearAllTimers();\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._cancelledImmediates = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = new Map();\n  }\n\n  runAllTicks() {\n    this._checkFakeTimers(); // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' ticks, and there are still more! ' +\n          \"Assuming we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  runAllImmediates() {\n    this._checkFakeTimers(); // Only run a generous number of immediates and then bail.\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n\n      if (immediate === undefined) {\n        break;\n      }\n\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' immediates, and there are still more! Assuming ' +\n          \"we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  _runImmediate(immediate) {\n    if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n      // Callback may throw, so update the map prior calling.\n      this._cancelledImmediates[immediate.uuid] = true;\n      immediate.callback();\n    }\n  }\n\n  runAllTimers() {\n    this._checkFakeTimers();\n\n    this.runAllTicks();\n    this.runAllImmediates(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n\n      if (this._ticks.length) {\n        this.runAllTicks();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' timers, and there are still more! ' +\n          \"Assuming we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  runOnlyPendingTimers() {\n    // We need to hold the current shape of `this._timers` because existing\n    // timers can add new ones to the map and hence would run more than necessary.\n    // See https://github.com/facebook/jest/pull/4608 for details\n    const timerEntries = Array.from(this._timers.entries());\n\n    this._checkFakeTimers();\n\n    this._immediates.forEach(this._runImmediate, this);\n\n    timerEntries\n      .sort(([, left], [, right]) => left.expiry - right.expiry)\n      .forEach(([timerHandle]) => this._runTimerHandle(timerHandle));\n  }\n\n  advanceTimersToNextTimer(steps = 1) {\n    if (steps < 1) {\n      return;\n    }\n\n    const nextExpiry = Array.from(this._timers.values()).reduce(\n      (minExpiry, timer) => {\n        if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n        return minExpiry;\n      },\n      null\n    );\n\n    if (nextExpiry !== null) {\n      this.advanceTimersByTime(nextExpiry - this._now);\n      this.advanceTimersToNextTimer(steps - 1);\n    }\n  }\n\n  advanceTimersByTime(msToRun) {\n    this._checkFakeTimers(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n      if (timerHandle === null) {\n        break;\n      }\n\n      const timerValue = this._timers.get(timerHandle);\n\n      if (timerValue === undefined) {\n        break;\n      }\n\n      const nextTimerExpiry = timerValue.expiry;\n\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= nextTimerExpiry - this._now;\n        this._now = nextTimerExpiry;\n\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' timers, and there are still more! ' +\n          \"Assuming we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const prevClearImmediate = this._global.clearImmediate;\n    const prevClearInterval = this._global.clearInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevNextTick = this._global.process.nextTick;\n    const prevSetImmediate = this._global.setImmediate;\n    const prevSetInterval = this._global.setInterval;\n    const prevSetTimeout = this._global.setTimeout;\n    this.useRealTimers();\n    let cbErr = null;\n    let errThrown = false;\n\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.clearImmediate = prevClearImmediate;\n    this._global.clearInterval = prevClearInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.process.nextTick = prevNextTick;\n    this._global.setImmediate = prevSetImmediate;\n    this._global.setInterval = prevSetInterval;\n    this._global.setTimeout = prevSetTimeout;\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const global = this._global;\n    setGlobal(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n    setGlobal(global, 'clearInterval', this._timerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n    setGlobal(global, 'setImmediate', this._timerAPIs.setImmediate);\n    setGlobal(global, 'setInterval', this._timerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._timerAPIs.setTimeout);\n    global.process.nextTick = this._timerAPIs.nextTick;\n  }\n\n  useFakeTimers() {\n    this._createMocks();\n\n    const global = this._global;\n    setGlobal(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n    setGlobal(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n    setGlobal(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n    setGlobal(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n    global.process.nextTick = this._fakeTimerAPIs.nextTick;\n  }\n\n  getTimerCount() {\n    this._checkFakeTimers();\n\n    return this._timers.size + this._immediates.length + this._ticks.length;\n  }\n\n  _checkFakeTimers() {\n    if (this._global.setTimeout !== this._fakeTimerAPIs.setTimeout) {\n      this._global.console.warn(\n        `A function to advance timers was called but the timers API is not ` +\n          `mocked with fake timers. Call \\`jest.useFakeTimers()\\` in this ` +\n          `test or enable fake timers globally by setting ` +\n          `\\`\"timers\": \"fake\"\\` in ` +\n          `the configuration file. This warning is likely a result of a ` +\n          `default configuration change in Jest 15.\\n\\n` +\n          `Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n` +\n          `Stack Trace:\\n` +\n          (0, _jestMessageUtil().formatStackTrace)(\n            new Error().stack,\n            this._config,\n            {\n              noStackTrace: false\n            }\n          )\n      );\n    }\n  }\n\n  _createMocks() {\n    const fn = (\n      impl // @ts-ignore TODO: figure out better typings here\n    ) => this._moduleMocker.fn().mockImplementation(impl); // TODO: add better typings; these are mocks, but typed as regular timers\n\n    this._fakeTimerAPIs = {\n      clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n      clearInterval: fn(this._fakeClearTimer.bind(this)),\n      clearTimeout: fn(this._fakeClearTimer.bind(this)),\n      nextTick: fn(this._fakeNextTick.bind(this)),\n      setImmediate: fn(this._fakeSetImmediate.bind(this)),\n      setInterval: fn(this._fakeSetInterval.bind(this)),\n      setTimeout: fn(this._fakeSetTimeout.bind(this))\n    };\n  }\n\n  _fakeClearTimer(timerRef) {\n    const uuid = this._timerConfig.refToId(timerRef);\n\n    if (uuid) {\n      this._timers.delete(String(uuid));\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._cancelledImmediates[uuid] = true;\n  }\n\n  _fakeNextTick(callback, ...args) {\n    if (this._disposed) {\n      return;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._ticks.push({\n      callback: (function(_callback) {\n        function callback() {\n          return _callback.apply(this, arguments);\n        }\n\n        callback.toString = function() {\n          return _callback.toString();\n        };\n\n        return callback;\n      })(() => callback.apply(null, args)),\n      uuid\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n\n    this._timerAPIs.nextTick(() => {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._immediates.push({\n      callback: (function(_callback2) {\n        function callback() {\n          return _callback2.apply(this, arguments);\n        }\n\n        callback.toString = function() {\n          return _callback2.toString();\n        };\n\n        return callback;\n      })(() => callback.apply(null, args)),\n      uuid: String(uuid)\n    });\n\n    const cancelledImmediates = this._cancelledImmediates;\n\n    this._timerAPIs.setImmediate(() => {\n      if (!cancelledImmediates.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledImmediates[String(uuid)] = true;\n        callback.apply(null, args);\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    if (intervalDelay == null) {\n      intervalDelay = 0;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: (function(_callback3) {\n        function callback() {\n          return _callback3.apply(this, arguments);\n        }\n\n        callback.toString = function() {\n          return _callback3.toString();\n        };\n\n        return callback;\n      })(() => callback.apply(null, args)),\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n      type: 'interval'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _fakeSetTimeout(callback, delay, ...args) {\n    if (this._disposed) {\n      return null;\n    } // eslint-disable-next-line no-bitwise\n\n    delay = Number(delay) | 0;\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: (function(_callback4) {\n        function callback() {\n          return _callback4.apply(this, arguments);\n        }\n\n        callback.toString = function() {\n          return _callback4.toString();\n        };\n\n        return callback;\n      })(() => callback.apply(null, args)),\n      expiry: this._now + delay,\n      interval: undefined,\n      type: 'timeout'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let soonestTime = MS_IN_A_YEAR;\n\n    this._timers.forEach((timer, uuid) => {\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    });\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers.get(timerHandle);\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n\n        this._timers.delete(timerHandle);\n\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + (timer.interval || 0);\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n}\n\nexports.default = FakeTimers;\n"]},"metadata":{},"sourceType":"script"}