{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.googleAnalytics = function (exports, Plugin_mjs, cacheNames_mjs, getFriendlyURL_mjs, logger_mjs, Route_mjs, Router_mjs, NetworkFirst_mjs, NetworkOnly_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:google-analytics:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const QUEUE_NAME = 'workbox-google-analytics';\n  const MAX_RETENTION_TIME = 60 * 48; // Two days in minutes\n\n  const GOOGLE_ANALYTICS_HOST = 'www.google-analytics.com';\n  const GTM_HOST = 'www.googletagmanager.com';\n  const ANALYTICS_JS_PATH = '/analytics.js';\n  const GTAG_JS_PATH = '/gtag/js';\n  const GTM_JS_PATH = '/gtm.js'; // endpoints. Most of the time the default path (/collect) is used, but\n  // occasionally an experimental endpoint is used when testing new features,\n  // (e.g. /r/collect or /j/collect)\n\n  const COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Creates the requestWillDequeue callback to be used with the background\n   * sync queue plugin. The callback takes the failed request and adds the\n   * `qt` param based on the current time, as well as applies any other\n   * user-defined hit modifications.\n   *\n   * @param {Object} config See workbox.googleAnalytics.initialize.\n   * @return {Function} The requestWillDequeu callback function.\n   *\n   * @private\n   */\n\n  const createOnSyncCallback = config => {\n    return async ({\n      queue\n    }) => {\n      let entry;\n\n      while (entry = await queue.shiftRequest()) {\n        const {\n          request,\n          timestamp\n        } = entry;\n        const url = new URL(request.url);\n\n        try {\n          // Measurement protocol requests can set their payload parameters in\n          // either the URL query string (for GET requests) or the POST body.\n          const params = request.method === 'POST' ? new URLSearchParams(await request.clone().text()) : url.searchParams; // Calculate the qt param, accounting for the fact that an existing\n          // qt param may be present and should be updated rather than replaced.\n\n          const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n          const queueTime = Date.now() - originalHitTime; // Set the qt param prior to applying hitFilter or parameterOverrides.\n\n          params.set('qt', queueTime); // Apply `paramterOverrideds`, if set.\n\n          if (config.parameterOverrides) {\n            for (const param of Object.keys(config.parameterOverrides)) {\n              const value = config.parameterOverrides[param];\n              params.set(param, value);\n            }\n          } // Apply `hitFilter`, if set.\n\n\n          if (typeof config.hitFilter === 'function') {\n            config.hitFilter.call(null, params);\n          } // Retry the fetch. Ignore URL search params from the URL as they're\n          // now in the post body.\n\n\n          await fetch(new Request(url.origin + url.pathname, {\n            body: params.toString(),\n            method: 'POST',\n            mode: 'cors',\n            credentials: 'omit',\n            headers: {\n              'Content-Type': 'text/plain'\n            }\n          }));\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(url.href)}'` + `has been replayed`);\n          }\n        } catch (err) {\n          await queue.unshiftRequest(entry);\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(url.href)}'` + `failed to replay, putting it back in the queue.`);\n          }\n          throw err;\n        }\n      }\n\n      {\n        logger_mjs.logger.log(`All Google Analytics request successfully replayed; ` + `the queue is now empty!`);\n      }\n    };\n  };\n  /**\n   * Creates GET and POST routes to catch failed Measurement Protocol hits.\n   *\n   * @param {Plugin} queuePlugin\n   * @return {Array<Route>} The created routes.\n   *\n   * @private\n   */\n\n\n  const createCollectRoutes = queuePlugin => {\n    const match = ({\n      url\n    }) => url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n\n    const handler = new NetworkOnly_mjs.NetworkOnly({\n      plugins: [queuePlugin]\n    });\n    return [new Route_mjs.Route(match, handler, 'GET'), new Route_mjs.Route(match, handler, 'POST')];\n  };\n  /**\n   * Creates a route with a network first strategy for the analytics.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createAnalyticsJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * Creates a route with a network first strategy for the gtag.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createGtagJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * Creates a route with a network first strategy for the gtm.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createGtmJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * @param {Object=} [options]\n   * @param {Object} [options.cacheName] The cache name to store and retrieve\n   *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n   * @param {Object} [options.parameterOverrides]\n   *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n   *     expressed as key/value pairs, to be added to replayed Google Analytics\n   *     requests. This can be used to, e.g., set a custom dimension indicating\n   *     that the request was replayed.\n   * @param {Function} [options.hitFilter] A function that allows you to modify\n   *     the hit parameters prior to replaying\n   *     the hit. The function is invoked with the original hit's URLSearchParams\n   *     object as its only argument.\n   *\n   * @memberof workbox.googleAnalytics\n   */\n\n\n  const initialize = (options = {}) => {\n    const cacheName = cacheNames_mjs.cacheNames.getGoogleAnalyticsName(options.cacheName);\n    const queuePlugin = new Plugin_mjs.Plugin(QUEUE_NAME, {\n      maxRetentionTime: MAX_RETENTION_TIME,\n      onSync: createOnSyncCallback(options)\n    });\n    const routes = [createGtmJsRoute(cacheName), createAnalyticsJsRoute(cacheName), createGtagJsRoute(cacheName), ...createCollectRoutes(queuePlugin)];\n    const router = new Router_mjs.Router();\n\n    for (const route of routes) {\n      router.registerRoute(route);\n    }\n\n    router.addFetchListener();\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.initialize = initialize;\n  return exports;\n}({}, workbox.backgroundSync, workbox.core._private, workbox.core._private, workbox.core._private, workbox.routing, workbox.routing, workbox.strategies, workbox.strategies);","map":{"version":3,"sources":["../_version.mjs","../utils/constants.mjs","../initialize.mjs","../index.mjs"],"names":["self","_","QUEUE_NAME","MAX_RETENTION_TIME","GOOGLE_ANALYTICS_HOST","GTM_HOST","ANALYTICS_JS_PATH","GTAG_JS_PATH","GTM_JS_PATH","COLLECT_PATHS_REGEX","createOnSyncCallback","config","queue","entry","timestamp","url","request","params","originalHitTime","Number","queueTime","Date","Object","value","fetch","body","method","mode","credentials","headers","logger","getFriendlyURL","createCollectRoutes","queuePlugin","match","handler","NetworkOnly","plugins","Route","createAnalyticsJsRoute","cacheName","NetworkFirst","createGtagJsRoute","createGtmJsRoute","initialize","options","cacheNames","Plugin","maxRetentionTime","onSync","routes","router","Router"],"mappings":";;;;;AAAA,MAAG;AAACA,IAAAA,IAAI,CAAJA,gCAAI,CAAJA,IAAwCC,CAAxCD,EAAAA;AAAJ,GAAA,CAAgD,OAAA,CAAA,EAAQ,CAAA,C,CAAA;;ACAxD;;;;;;;;AAUO,QAAME,UAAU,GAAhB,0BAAA;AACA,QAAMC,kBAAkB,GAAG,KAA3B,EAAA,C,CAAA;;AACA,QAAMC,qBAAqB,GAA3B,0BAAA;AACA,QAAMC,QAAQ,GAAd,0BAAA;AACA,QAAMC,iBAAiB,GAAvB,eAAA;AACA,QAAMC,YAAY,GAAlB,UAAA;AACA,QAAMC,WAAW,GAAjB,SAAA,C,CAIP;AACA;AACA;;AACO,QAAMC,mBAAmB,GAAzB,oBAAA;ACvBP;;;;;;;AA4BA;;;;;;;;;;;;AAWA,QAAMC,oBAAoB,GAAIC,MAAD,IAAY;AACvC,WAAO,OAAO;AAACC,MAAAA;AAAD,KAAP,KAAmB;AACxB,UAAA,KAAA;;AACA,aAAOC,KAAK,GAAG,MAAMD,KAAK,CAA1B,YAAqBA,EAArB,EAA2C;AACzC,cAAM;AAAA,UAAA,OAAA;AAAUE,UAAAA;AAAV,YAAN,KAAA;AACA,cAAMC,GAAG,GAAG,IAAA,GAAA,CAAQC,OAAO,CAA3B,GAAY,CAAZ;;AAEA,YAAI;AACF;AACA;AACA,gBAAMC,MAAM,GAAGD,OAAO,CAAPA,MAAAA,KAAAA,MAAAA,GACX,IAAA,eAAA,CAAoB,MAAMA,OAAO,CAAPA,KAAAA,GADfA,IACeA,EAA1B,CADWA,GAEXD,GAAG,CALL,YAGF,CAHE,CAAA;AAQF;;AACA,gBAAMG,eAAe,GAAGJ,SAAS,IAAIK,MAAM,CAACF,MAAM,CAANA,GAAAA,CAAPE,IAAOF,CAAD,CAANE,IAArC,CAAiC,CAAjC;AACA,gBAAMC,SAAS,GAAGC,IAAI,CAAJA,GAAAA,KAVhB,eAUF,CAVE,CAAA;;AAaFJ,UAAAA,MAAM,CAANA,GAAAA,CAAAA,IAAAA,EAbE,SAaFA,EAbE,CAAA;;AAgBF,cAAIN,MAAM,CAAV,kBAAA,EAA+B;AAC7B,iBAAK,MAAL,KAAA,IAAoBW,MAAM,CAANA,IAAAA,CAAYX,MAAM,CAAtC,kBAAoBW,CAApB,EAA4D;AAC1D,oBAAMC,KAAK,GAAGZ,MAAM,CAANA,kBAAAA,CAAd,KAAcA,CAAd;AACAM,cAAAA,MAAM,CAANA,GAAAA,CAAAA,KAAAA,EAAAA,KAAAA;AACD;AApBD,WAAA,CAAA;;;AAwBF,cAAI,OAAON,MAAM,CAAb,SAAA,KAAJ,UAAA,EAA4C;AAC1CA,YAAAA,MAAM,CAANA,SAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,MAAAA;AAzBA,WAAA,CAAA;AA6BF;;;AACA,gBAAMa,KAAK,CAAC,IAAA,OAAA,CAAYT,GAAG,CAAHA,MAAAA,GAAaA,GAAG,CAA5B,QAAA,EAAuC;AACjDU,YAAAA,IAAI,EAAER,MAAM,CADqC,QAC3CA,EAD2C;AAEjDS,YAAAA,MAAM,EAF2C,MAAA;AAGjDC,YAAAA,IAAI,EAH6C,MAAA;AAIjDC,YAAAA,WAAW,EAJsC,MAAA;AAKjDC,YAAAA,OAAO,EAAE;AAAC,8BAAgB;AAAjB;AALwC,WAAvC,CAAD,CAAX;AAS2C;AACzCC,YAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAY,gBAAeC,kBAAAA,CAAAA,cAAAA,CAAehB,GAAG,CAAJ,IAAdgB,CAAhB,GAAC,GAAZD,mBAAAA;AAED;AA1CH,SAAA,CA2CE,OAAA,GAAA,EAAY;AACZ,gBAAMlB,KAAK,CAALA,cAAAA,CAAN,KAAMA,CAAN;AAE2C;AACzCkB,YAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAY,gBAAeC,kBAAAA,CAAAA,cAAAA,CAAehB,GAAG,CAAJ,IAAdgB,CAAhB,GAAC,GAAZD,iDAAAA;AAED;AACD,gBAAA,GAAA;AACD;AACF;;AAC0C;AACzCA,QAAAA,UAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAW,sDAAC,GAAZA,yBAAAA;AAED;AA9DH,KAAA;AADF,GAAA;AAmEA;;;;;;;;;;AAQA,QAAME,mBAAmB,GAAIC,WAAD,IAAiB;AAC3C,UAAMC,KAAK,GAAG,CAAC;AAACnB,MAAAA;AAAD,KAAD,KAAWA,GAAG,CAAHA,QAAAA,KAAAA,qBAAAA,IACrBN,mBAAmB,CAAnBA,IAAAA,CAAyBM,GAAG,CADhC,QACIN,CADJ;;AAGA,UAAM0B,OAAO,GAAG,IAAIC,eAAAA,CAAJ,WAAA,CAAgB;AAC9BC,MAAAA,OAAO,EAAE,CAAA,WAAA;AADqB,KAAhB,CAAhB;AAIA,WAAO,CACL,IAAIC,SAAAA,CAAJ,KAAA,CAAA,KAAA,EAAA,OAAA,EADK,KACL,CADK,EAEL,IAAIA,SAAAA,CAAJ,KAAA,CAAA,KAAA,EAAA,OAAA,EAFF,MAEE,CAFK,CAAP;AARF,GAAA;AAcA;;;;;;;;;;AAQA,QAAMC,sBAAsB,GAAIC,SAAD,IAAe;AAC5C,UAAMN,KAAK,GAAG,CAAC;AAACnB,MAAAA;AAAD,KAAD,KAAWA,GAAG,CAAHA,QAAAA,KAAAA,qBAAAA,IACrBA,GAAG,CAAHA,QAAAA,KADJ,iBAAA;;AAEA,UAAMoB,OAAO,GAAG,IAAIM,gBAAAA,CAAJ,YAAA,CAAiB;AAACD,MAAAA;AAAD,KAAjB,CAAhB;AAEA,WAAO,IAAIF,SAAAA,CAAJ,KAAA,CAAA,KAAA,EAAA,OAAA,EAAP,KAAO,CAAP;AALF,GAAA;AAQA;;;;;;;;;;AAQA,QAAMI,iBAAiB,GAAIF,SAAD,IAAe;AACvC,UAAMN,KAAK,GAAG,CAAC;AAACnB,MAAAA;AAAD,KAAD,KAAWA,GAAG,CAAHA,QAAAA,KAAAA,QAAAA,IACrBA,GAAG,CAAHA,QAAAA,KADJ,YAAA;;AAEA,UAAMoB,OAAO,GAAG,IAAIM,gBAAAA,CAAJ,YAAA,CAAiB;AAACD,MAAAA;AAAD,KAAjB,CAAhB;AAEA,WAAO,IAAIF,SAAAA,CAAJ,KAAA,CAAA,KAAA,EAAA,OAAA,EAAP,KAAO,CAAP;AALF,GAAA;AAQA;;;;;;;;;;AAQA,QAAMK,gBAAgB,GAAIH,SAAD,IAAe;AACtC,UAAMN,KAAK,GAAG,CAAC;AAACnB,MAAAA;AAAD,KAAD,KAAWA,GAAG,CAAHA,QAAAA,KAAAA,QAAAA,IACrBA,GAAG,CAAHA,QAAAA,KADJ,WAAA;;AAEA,UAAMoB,OAAO,GAAG,IAAIM,gBAAAA,CAAJ,YAAA,CAAiB;AAACD,MAAAA;AAAD,KAAjB,CAAhB;AAEA,WAAO,IAAIF,SAAAA,CAAJ,KAAA,CAAA,KAAA,EAAA,OAAA,EAAP,KAAO,CAAP;AALF,GAAA;AAQA;;;;;;;;;;;;;;;;;;AAgBA,QAAMM,UAAU,GAAG,CAACC,OAAO,GAAR,EAAA,KAAkB;AACnC,UAAML,SAAS,GAAGM,cAAAA,CAAAA,UAAAA,CAAAA,sBAAAA,CAAkCD,OAAO,CAA3D,SAAkBC,CAAlB;AAEA,UAAMb,WAAW,GAAG,IAAIc,UAAAA,CAAJ,MAAA,CAAA,UAAA,EAAuB;AACzCC,MAAAA,gBAAgB,EADyB,kBAAA;AAEzCC,MAAAA,MAAM,EAAEvC,oBAAoB,CAAA,OAAA;AAFa,KAAvB,CAApB;AAKA,UAAMwC,MAAM,GAAG,CACbP,gBAAgB,CADH,SACG,CADH,EAEbJ,sBAAsB,CAFT,SAES,CAFT,EAGbG,iBAAiB,CAHJ,SAGI,CAHJ,EAIb,GAAGV,mBAAmB,CAJxB,WAIwB,CAJT,CAAf;AAOA,UAAMmB,MAAM,GAAG,IAAIC,UAAAA,CAAnB,MAAe,EAAf;;AACA,SAAK,MAAL,KAAA,IAAA,MAAA,EAA4B;AAC1BD,MAAAA,MAAM,CAANA,aAAAA,CAAAA,KAAAA;AACD;;AAEDA,IAAAA,MAAM,CAANA,gBAAAA;AApBF,GAAA;AChMA","sourcesContent":["try{self['workbox:google-analytics:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const QUEUE_NAME = 'workbox-google-analytics';\nexport const MAX_RETENTION_TIME = 60 * 48; // Two days in minutes\nexport const GOOGLE_ANALYTICS_HOST = 'www.google-analytics.com';\nexport const GTM_HOST = 'www.googletagmanager.com';\nexport const ANALYTICS_JS_PATH = '/analytics.js';\nexport const GTAG_JS_PATH = '/gtag/js';\nexport const GTM_JS_PATH = '/gtm.js';\nexport const COLLECT_DEFAULT_PATH = '/collect';\n\n// This RegExp matches all known Measurement Protocol single-hit collect\n// endpoints. Most of the time the default path (/collect) is used, but\n// occasionally an experimental endpoint is used when testing new features,\n// (e.g. /r/collect or /j/collect)\nexport const COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Plugin} from 'workbox-background-sync/Plugin.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from 'workbox-routing/Route.mjs';\nimport {Router} from 'workbox-routing/Router.mjs';\nimport {NetworkFirst} from 'workbox-strategies/NetworkFirst.mjs';\nimport {NetworkOnly} from 'workbox-strategies/NetworkOnly.mjs';\nimport {\n  QUEUE_NAME,\n  MAX_RETENTION_TIME,\n  GOOGLE_ANALYTICS_HOST,\n  GTM_HOST,\n  ANALYTICS_JS_PATH,\n  GTAG_JS_PATH,\n  GTM_JS_PATH,\n  COLLECT_PATHS_REGEX,\n} from './utils/constants.mjs';\nimport './_version.mjs';\n\n/**\n * Creates the requestWillDequeue callback to be used with the background\n * sync queue plugin. The callback takes the failed request and adds the\n * `qt` param based on the current time, as well as applies any other\n * user-defined hit modifications.\n *\n * @param {Object} config See workbox.googleAnalytics.initialize.\n * @return {Function} The requestWillDequeu callback function.\n *\n * @private\n */\nconst createOnSyncCallback = (config) => {\n  return async ({queue}) => {\n    let entry;\n    while (entry = await queue.shiftRequest()) {\n      const {request, timestamp} = entry;\n      const url = new URL(request.url);\n\n      try {\n        // Measurement protocol requests can set their payload parameters in\n        // either the URL query string (for GET requests) or the POST body.\n        const params = request.method === 'POST' ?\n            new URLSearchParams(await request.clone().text()) :\n            url.searchParams;\n\n        // Calculate the qt param, accounting for the fact that an existing\n        // qt param may be present and should be updated rather than replaced.\n        const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n        const queueTime = Date.now() - originalHitTime;\n\n        // Set the qt param prior to applying hitFilter or parameterOverrides.\n        params.set('qt', queueTime);\n\n        // Apply `paramterOverrideds`, if set.\n        if (config.parameterOverrides) {\n          for (const param of Object.keys(config.parameterOverrides)) {\n            const value = config.parameterOverrides[param];\n            params.set(param, value);\n          }\n        }\n\n        // Apply `hitFilter`, if set.\n        if (typeof config.hitFilter === 'function') {\n          config.hitFilter.call(null, params);\n        }\n\n        // Retry the fetch. Ignore URL search params from the URL as they're\n        // now in the post body.\n        await fetch(new Request(url.origin + url.pathname, {\n          body: params.toString(),\n          method: 'POST',\n          mode: 'cors',\n          credentials: 'omit',\n          headers: {'Content-Type': 'text/plain'},\n        }));\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(url.href)}'` +\n             `has been replayed`);\n        }\n      } catch (err) {\n        await queue.unshiftRequest(entry);\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(url.href)}'` +\n             `failed to replay, putting it back in the queue.`);\n        }\n        throw err;\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`All Google Analytics request successfully replayed; ` +\n          `the queue is now empty!`);\n    }\n  };\n};\n\n/**\n * Creates GET and POST routes to catch failed Measurement Protocol hits.\n *\n * @param {Plugin} queuePlugin\n * @return {Array<Route>} The created routes.\n *\n * @private\n */\nconst createCollectRoutes = (queuePlugin) => {\n  const match = ({url}) => url.hostname === GOOGLE_ANALYTICS_HOST &&\n      COLLECT_PATHS_REGEX.test(url.pathname);\n\n  const handler = new NetworkOnly({\n    plugins: [queuePlugin],\n  });\n\n  return [\n    new Route(match, handler, 'GET'),\n    new Route(match, handler, 'POST'),\n  ];\n};\n\n/**\n * Creates a route with a network first strategy for the analytics.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\nconst createAnalyticsJsRoute = (cacheName) => {\n  const match = ({url}) => url.hostname === GOOGLE_ANALYTICS_HOST &&\n      url.pathname === ANALYTICS_JS_PATH;\n  const handler = new NetworkFirst({cacheName});\n\n  return new Route(match, handler, 'GET');\n};\n\n/**\n * Creates a route with a network first strategy for the gtag.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\nconst createGtagJsRoute = (cacheName) => {\n  const match = ({url}) => url.hostname === GTM_HOST &&\n      url.pathname === GTAG_JS_PATH;\n  const handler = new NetworkFirst({cacheName});\n\n  return new Route(match, handler, 'GET');\n};\n\n/**\n * Creates a route with a network first strategy for the gtm.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\nconst createGtmJsRoute = (cacheName) => {\n  const match = ({url}) => url.hostname === GTM_HOST &&\n      url.pathname === GTM_JS_PATH;\n  const handler = new NetworkFirst({cacheName});\n\n  return new Route(match, handler, 'GET');\n};\n\n/**\n * @param {Object=} [options]\n * @param {Object} [options.cacheName] The cache name to store and retrieve\n *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n * @param {Object} [options.parameterOverrides]\n *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n *     expressed as key/value pairs, to be added to replayed Google Analytics\n *     requests. This can be used to, e.g., set a custom dimension indicating\n *     that the request was replayed.\n * @param {Function} [options.hitFilter] A function that allows you to modify\n *     the hit parameters prior to replaying\n *     the hit. The function is invoked with the original hit's URLSearchParams\n *     object as its only argument.\n *\n * @memberof workbox.googleAnalytics\n */\nconst initialize = (options = {}) => {\n  const cacheName = cacheNames.getGoogleAnalyticsName(options.cacheName);\n\n  const queuePlugin = new Plugin(QUEUE_NAME, {\n    maxRetentionTime: MAX_RETENTION_TIME,\n    onSync: createOnSyncCallback(options),\n  });\n\n  const routes = [\n    createGtmJsRoute(cacheName),\n    createAnalyticsJsRoute(cacheName),\n    createGtagJsRoute(cacheName),\n    ...createCollectRoutes(queuePlugin),\n  ];\n\n  const router = new Router();\n  for (const route of routes) {\n    router.registerRoute(route);\n  }\n\n  router.addFetchListener();\n};\n\nexport {\n  initialize,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {initialize} from './initialize.mjs';\nimport './_version.mjs';\n\n\n/**\n * @namespace workbox.googleAnalytics\n */\n\nexport {\n  initialize,\n};\n"]},"metadata":{},"sourceType":"script"}