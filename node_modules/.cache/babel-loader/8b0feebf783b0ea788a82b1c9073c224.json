{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Plugin } from 'workbox-background-sync/Plugin.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { Route } from 'workbox-routing/Route.mjs';\nimport { Router } from 'workbox-routing/Router.mjs';\nimport { NetworkFirst } from 'workbox-strategies/NetworkFirst.mjs';\nimport { NetworkOnly } from 'workbox-strategies/NetworkOnly.mjs';\nimport { QUEUE_NAME, MAX_RETENTION_TIME, GOOGLE_ANALYTICS_HOST, GTM_HOST, ANALYTICS_JS_PATH, GTAG_JS_PATH, GTM_JS_PATH, COLLECT_PATHS_REGEX } from './utils/constants.mjs';\nimport './_version.mjs';\n/**\n * Creates the requestWillDequeue callback to be used with the background\n * sync queue plugin. The callback takes the failed request and adds the\n * `qt` param based on the current time, as well as applies any other\n * user-defined hit modifications.\n *\n * @param {Object} config See workbox.googleAnalytics.initialize.\n * @return {Function} The requestWillDequeu callback function.\n *\n * @private\n */\n\nconst createOnSyncCallback = config => {\n  return async ({\n    queue\n  }) => {\n    let entry;\n\n    while (entry = await queue.shiftRequest()) {\n      const {\n        request,\n        timestamp\n      } = entry;\n      const url = new URL(request.url);\n\n      try {\n        // Measurement protocol requests can set their payload parameters in\n        // either the URL query string (for GET requests) or the POST body.\n        const params = request.method === 'POST' ? new URLSearchParams(await request.clone().text()) : url.searchParams; // Calculate the qt param, accounting for the fact that an existing\n        // qt param may be present and should be updated rather than replaced.\n\n        const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n        const queueTime = Date.now() - originalHitTime; // Set the qt param prior to applying hitFilter or parameterOverrides.\n\n        params.set('qt', queueTime); // Apply `paramterOverrideds`, if set.\n\n        if (config.parameterOverrides) {\n          for (const param of Object.keys(config.parameterOverrides)) {\n            const value = config.parameterOverrides[param];\n            params.set(param, value);\n          }\n        } // Apply `hitFilter`, if set.\n\n\n        if (typeof config.hitFilter === 'function') {\n          config.hitFilter.call(null, params);\n        } // Retry the fetch. Ignore URL search params from the URL as they're\n        // now in the post body.\n\n\n        await fetch(new Request(url.origin + url.pathname, {\n          body: params.toString(),\n          method: 'POST',\n          mode: 'cors',\n          credentials: 'omit',\n          headers: {\n            'Content-Type': 'text/plain'\n          }\n        }));\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(url.href)}'` + `has been replayed`);\n        }\n      } catch (err) {\n        await queue.unshiftRequest(entry);\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(url.href)}'` + `failed to replay, putting it back in the queue.`);\n        }\n\n        throw err;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`All Google Analytics request successfully replayed; ` + `the queue is now empty!`);\n    }\n  };\n};\n/**\n * Creates GET and POST routes to catch failed Measurement Protocol hits.\n *\n * @param {Plugin} queuePlugin\n * @return {Array<Route>} The created routes.\n *\n * @private\n */\n\n\nconst createCollectRoutes = queuePlugin => {\n  const match = ({\n    url\n  }) => url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n\n  const handler = new NetworkOnly({\n    plugins: [queuePlugin]\n  });\n  return [new Route(match, handler, 'GET'), new Route(match, handler, 'POST')];\n};\n/**\n * Creates a route with a network first strategy for the analytics.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\n\n\nconst createAnalyticsJsRoute = cacheName => {\n  const match = ({\n    url\n  }) => url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n\n  const handler = new NetworkFirst({\n    cacheName\n  });\n  return new Route(match, handler, 'GET');\n};\n/**\n * Creates a route with a network first strategy for the gtag.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\n\n\nconst createGtagJsRoute = cacheName => {\n  const match = ({\n    url\n  }) => url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n\n  const handler = new NetworkFirst({\n    cacheName\n  });\n  return new Route(match, handler, 'GET');\n};\n/**\n * Creates a route with a network first strategy for the gtm.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\n\n\nconst createGtmJsRoute = cacheName => {\n  const match = ({\n    url\n  }) => url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n\n  const handler = new NetworkFirst({\n    cacheName\n  });\n  return new Route(match, handler, 'GET');\n};\n/**\n * @param {Object=} [options]\n * @param {Object} [options.cacheName] The cache name to store and retrieve\n *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n * @param {Object} [options.parameterOverrides]\n *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n *     expressed as key/value pairs, to be added to replayed Google Analytics\n *     requests. This can be used to, e.g., set a custom dimension indicating\n *     that the request was replayed.\n * @param {Function} [options.hitFilter] A function that allows you to modify\n *     the hit parameters prior to replaying\n *     the hit. The function is invoked with the original hit's URLSearchParams\n *     object as its only argument.\n *\n * @memberof workbox.googleAnalytics\n */\n\n\nconst initialize = (options = {}) => {\n  const cacheName = cacheNames.getGoogleAnalyticsName(options.cacheName);\n  const queuePlugin = new Plugin(QUEUE_NAME, {\n    maxRetentionTime: MAX_RETENTION_TIME,\n    onSync: createOnSyncCallback(options)\n  });\n  const routes = [createGtmJsRoute(cacheName), createAnalyticsJsRoute(cacheName), createGtagJsRoute(cacheName), ...createCollectRoutes(queuePlugin)];\n  const router = new Router();\n\n  for (const route of routes) {\n    router.registerRoute(route);\n  }\n\n  router.addFetchListener();\n};\n\nexport { initialize };","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-google-analytics/initialize.mjs"],"names":["Plugin","cacheNames","getFriendlyURL","logger","Route","Router","NetworkFirst","NetworkOnly","QUEUE_NAME","MAX_RETENTION_TIME","GOOGLE_ANALYTICS_HOST","GTM_HOST","ANALYTICS_JS_PATH","GTAG_JS_PATH","GTM_JS_PATH","COLLECT_PATHS_REGEX","createOnSyncCallback","config","queue","entry","shiftRequest","request","timestamp","url","URL","params","method","URLSearchParams","clone","text","searchParams","originalHitTime","Number","get","queueTime","Date","now","set","parameterOverrides","param","Object","keys","value","hitFilter","call","fetch","Request","origin","pathname","body","toString","mode","credentials","headers","process","env","NODE_ENV","log","href","err","unshiftRequest","createCollectRoutes","queuePlugin","match","hostname","test","handler","plugins","createAnalyticsJsRoute","cacheName","createGtagJsRoute","createGtmJsRoute","initialize","options","getGoogleAnalyticsName","maxRetentionTime","onSync","routes","router","route","registerRoute","addFetchListener"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Plugin} from 'workbox-background-sync/Plugin.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from 'workbox-routing/Route.mjs';\nimport {Router} from 'workbox-routing/Router.mjs';\nimport {NetworkFirst} from 'workbox-strategies/NetworkFirst.mjs';\nimport {NetworkOnly} from 'workbox-strategies/NetworkOnly.mjs';\nimport {\n  QUEUE_NAME,\n  MAX_RETENTION_TIME,\n  GOOGLE_ANALYTICS_HOST,\n  GTM_HOST,\n  ANALYTICS_JS_PATH,\n  GTAG_JS_PATH,\n  GTM_JS_PATH,\n  COLLECT_PATHS_REGEX,\n} from './utils/constants.mjs';\nimport './_version.mjs';\n\n/**\n * Creates the requestWillDequeue callback to be used with the background\n * sync queue plugin. The callback takes the failed request and adds the\n * `qt` param based on the current time, as well as applies any other\n * user-defined hit modifications.\n *\n * @param {Object} config See workbox.googleAnalytics.initialize.\n * @return {Function} The requestWillDequeu callback function.\n *\n * @private\n */\nconst createOnSyncCallback = (config) => {\n  return async ({queue}) => {\n    let entry;\n    while (entry = await queue.shiftRequest()) {\n      const {request, timestamp} = entry;\n      const url = new URL(request.url);\n\n      try {\n        // Measurement protocol requests can set their payload parameters in\n        // either the URL query string (for GET requests) or the POST body.\n        const params = request.method === 'POST' ?\n            new URLSearchParams(await request.clone().text()) :\n            url.searchParams;\n\n        // Calculate the qt param, accounting for the fact that an existing\n        // qt param may be present and should be updated rather than replaced.\n        const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n        const queueTime = Date.now() - originalHitTime;\n\n        // Set the qt param prior to applying hitFilter or parameterOverrides.\n        params.set('qt', queueTime);\n\n        // Apply `paramterOverrideds`, if set.\n        if (config.parameterOverrides) {\n          for (const param of Object.keys(config.parameterOverrides)) {\n            const value = config.parameterOverrides[param];\n            params.set(param, value);\n          }\n        }\n\n        // Apply `hitFilter`, if set.\n        if (typeof config.hitFilter === 'function') {\n          config.hitFilter.call(null, params);\n        }\n\n        // Retry the fetch. Ignore URL search params from the URL as they're\n        // now in the post body.\n        await fetch(new Request(url.origin + url.pathname, {\n          body: params.toString(),\n          method: 'POST',\n          mode: 'cors',\n          credentials: 'omit',\n          headers: {'Content-Type': 'text/plain'},\n        }));\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(url.href)}'` +\n             `has been replayed`);\n        }\n      } catch (err) {\n        await queue.unshiftRequest(entry);\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Request for '${getFriendlyURL(url.href)}'` +\n             `failed to replay, putting it back in the queue.`);\n        }\n        throw err;\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`All Google Analytics request successfully replayed; ` +\n          `the queue is now empty!`);\n    }\n  };\n};\n\n/**\n * Creates GET and POST routes to catch failed Measurement Protocol hits.\n *\n * @param {Plugin} queuePlugin\n * @return {Array<Route>} The created routes.\n *\n * @private\n */\nconst createCollectRoutes = (queuePlugin) => {\n  const match = ({url}) => url.hostname === GOOGLE_ANALYTICS_HOST &&\n      COLLECT_PATHS_REGEX.test(url.pathname);\n\n  const handler = new NetworkOnly({\n    plugins: [queuePlugin],\n  });\n\n  return [\n    new Route(match, handler, 'GET'),\n    new Route(match, handler, 'POST'),\n  ];\n};\n\n/**\n * Creates a route with a network first strategy for the analytics.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\nconst createAnalyticsJsRoute = (cacheName) => {\n  const match = ({url}) => url.hostname === GOOGLE_ANALYTICS_HOST &&\n      url.pathname === ANALYTICS_JS_PATH;\n  const handler = new NetworkFirst({cacheName});\n\n  return new Route(match, handler, 'GET');\n};\n\n/**\n * Creates a route with a network first strategy for the gtag.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\nconst createGtagJsRoute = (cacheName) => {\n  const match = ({url}) => url.hostname === GTM_HOST &&\n      url.pathname === GTAG_JS_PATH;\n  const handler = new NetworkFirst({cacheName});\n\n  return new Route(match, handler, 'GET');\n};\n\n/**\n * Creates a route with a network first strategy for the gtm.js script.\n *\n * @param {string} cacheName\n * @return {Route} The created route.\n *\n * @private\n */\nconst createGtmJsRoute = (cacheName) => {\n  const match = ({url}) => url.hostname === GTM_HOST &&\n      url.pathname === GTM_JS_PATH;\n  const handler = new NetworkFirst({cacheName});\n\n  return new Route(match, handler, 'GET');\n};\n\n/**\n * @param {Object=} [options]\n * @param {Object} [options.cacheName] The cache name to store and retrieve\n *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n * @param {Object} [options.parameterOverrides]\n *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n *     expressed as key/value pairs, to be added to replayed Google Analytics\n *     requests. This can be used to, e.g., set a custom dimension indicating\n *     that the request was replayed.\n * @param {Function} [options.hitFilter] A function that allows you to modify\n *     the hit parameters prior to replaying\n *     the hit. The function is invoked with the original hit's URLSearchParams\n *     object as its only argument.\n *\n * @memberof workbox.googleAnalytics\n */\nconst initialize = (options = {}) => {\n  const cacheName = cacheNames.getGoogleAnalyticsName(options.cacheName);\n\n  const queuePlugin = new Plugin(QUEUE_NAME, {\n    maxRetentionTime: MAX_RETENTION_TIME,\n    onSync: createOnSyncCallback(options),\n  });\n\n  const routes = [\n    createGtmJsRoute(cacheName),\n    createAnalyticsJsRoute(cacheName),\n    createGtagJsRoute(cacheName),\n    ...createCollectRoutes(queuePlugin),\n  ];\n\n  const router = new Router();\n  for (const route of routes) {\n    router.registerRoute(route);\n  }\n\n  router.addFetchListener();\n};\n\nexport {\n  initialize,\n};\n"]},"metadata":{},"sourceType":"module"}