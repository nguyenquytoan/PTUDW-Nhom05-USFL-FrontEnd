{"ast":null,"code":"/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check whether a given variable is a global variable or not.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is a global variable.\n */\n\n\nfunction isGlobal(variable) {\n  return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n * @param {eslint-scope.Scope} scope The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\n\n\nfunction getEnclosingFunctionScope(scope) {\n  let currentScope = scope;\n\n  while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n    currentScope = currentScope.upper;\n  }\n\n  return currentScope;\n}\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\n\n\nfunction isReferencedInClosure(variable) {\n  const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n  return variable.references.some(reference => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n/**\n * Checks whether the given node is the assignee of a loop.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\n\n\nfunction isLoopAssignee(node) {\n  return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") && node === node.parent.left;\n}\n/**\n * Checks whether the given variable declaration is immediately initialized.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\n\n\nfunction isDeclarationInitialized(node) {\n  return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n/**\n * Gets the scope node which directly contains a given node.\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\n\nfunction getScopeNode(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n  /* istanbul ignore next : unreachable */\n\n\n  return null;\n}\n/**\n * Checks whether a given variable is redeclared or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\n\n\nfunction isRedeclared(variable) {\n  return variable.defs.length >= 2;\n}\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n * @param {ASTNode} scopeNode A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\n\n\nfunction isUsedFromOutsideOf(scopeNode) {\n  /**\n   * Checks whether a given reference is inside of the specified scope or not.\n   * @param {eslint-scope.Reference} reference A reference to check.\n   * @returns {boolean} `true` if the reference is inside of the specified\n   *      scope.\n   */\n  function isOutsideOfScope(reference) {\n    const scope = scopeNode.range;\n    const id = reference.identifier.range;\n    return id[0] < scope[0] || id[1] > scope[1];\n  }\n\n  return function (variable) {\n    return variable.references.some(isOutsideOfScope);\n  };\n}\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n * @param {ASTNode} node The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\n\n\nfunction hasReferenceInTDZ(node) {\n  const initStart = node.range[0];\n  const initEnd = node.range[1];\n  return variable => {\n    const id = variable.defs[0].name;\n    const idStart = id.range[0];\n    const defaultValue = id.parent.type === \"AssignmentPattern\" ? id.parent.right : null;\n    const defaultStart = defaultValue && defaultValue.range[0];\n    const defaultEnd = defaultValue && defaultValue.range[1];\n    return variable.references.some(reference => {\n      const start = reference.identifier.range[0];\n      const end = reference.identifier.range[1];\n      return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);\n    });\n  };\n}\n/**\n * Checks whether a given variable has name that is allowed for 'var' declarations,\n * but disallowed for `let` declarations.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable has a disallowed name.\n */\n\n\nfunction hasNameDisallowedForLetDeclarations(variable) {\n  return variable.name === \"let\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `let` or `const` instead of `var`\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-var\"\n    },\n    schema: [],\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n     * @param {ASTNode} declarator The VariableDeclarator node to check.\n     * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n     */\n\n    function hasSelfReferenceInTDZ(declarator) {\n      if (!declarator.init) {\n        return false;\n      }\n\n      const variables = context.getDeclaredVariables(declarator);\n      return variables.some(hasReferenceInTDZ(declarator.init));\n    }\n    /**\n     * Checks whether it can fix a given variable declaration or not.\n     * It cannot fix if the following cases:\n     *\n     * - A variable is a global variable.\n     * - A variable is declared on a SwitchCase node.\n     * - A variable is redeclared.\n     * - A variable is used from outside the scope.\n     * - A variable is used from a closure within a loop.\n     * - A variable might be used before it is assigned within a loop.\n     * - A variable might be used in TDZ.\n     * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n     * - A variable has name that is disallowed for `let` declarations.\n     *\n     * ## A variable is declared on a SwitchCase node.\n     *\n     * If this rule modifies 'var' declarations on a SwitchCase node, it\n     * would generate the warnings of 'no-case-declarations' rule. And the\n     * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n     * this rule doesn't modify those declarations.\n     *\n     * ## A variable is redeclared.\n     *\n     * The language spec disallows redeclarations of `let` declarations.\n     * Those variables would cause syntax errors.\n     *\n     * ## A variable is used from outside the scope.\n     *\n     * The language spec disallows accesses from outside of the scope for\n     * `let` declarations. Those variables would cause reference errors.\n     *\n     * ## A variable is used from a closure within a loop.\n     *\n     * A `var` declaration within a loop shares the same variable instance\n     * across all loop iterations, while a `let` declaration creates a new\n     * instance for each iteration. This means if a variable in a loop is\n     * referenced by any closure, changing it from `var` to `let` would\n     * change the behavior in a way that is generally unsafe.\n     *\n     * ## A variable might be used before it is assigned within a loop.\n     *\n     * Within a loop, a `let` declaration without an initializer will be\n     * initialized to null, while a `var` declaration will retain its value\n     * from the previous iteration, so it is only safe to change `var` to\n     * `let` if we can statically determine that the variable is always\n     * assigned a value before its first access in the loop body. To keep\n     * the implementation simple, we only convert `var` to `let` within\n     * loops when the variable is a loop assignee or the declaration has an\n     * initializer.\n     * @param {ASTNode} node A variable declaration node to check.\n     * @returns {boolean} `true` if it can fix the node.\n     */\n\n\n    function canFix(node) {\n      const variables = context.getDeclaredVariables(node);\n      const scopeNode = getScopeNode(node);\n\n      if (node.parent.type === \"SwitchCase\" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {\n        return false;\n      }\n\n      if (astUtils.isInLoop(node)) {\n        if (variables.some(isReferencedInClosure)) {\n          return false;\n        }\n\n        if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n          return false;\n        }\n      }\n\n      if (!isLoopAssignee(node) && !(node.parent.type === \"ForStatement\" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n        // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Reports a given variable declaration node.\n     * @param {ASTNode} node A variable declaration node to report.\n     * @returns {void}\n     */\n\n\n    function report(node) {\n      context.report({\n        node,\n        message: \"Unexpected var, use let or const instead.\",\n\n        fix(fixer) {\n          const varToken = sourceCode.getFirstToken(node, {\n            filter: t => t.value === \"var\"\n          });\n          return canFix(node) ? fixer.replaceText(varToken, \"let\") : null;\n        }\n\n      });\n    }\n\n    return {\n      \"VariableDeclaration:exit\"(node) {\n        if (node.kind === \"var\") {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-var.js"],"names":["astUtils","require","isGlobal","variable","Boolean","scope","type","getEnclosingFunctionScope","currentScope","upper","isReferencedInClosure","enclosingFunctionScope","references","some","reference","from","isLoopAssignee","node","parent","left","isDeclarationInitialized","declarations","every","declarator","init","SCOPE_NODE_TYPE","getScopeNode","currentNode","test","isRedeclared","defs","length","isUsedFromOutsideOf","scopeNode","isOutsideOfScope","range","id","identifier","hasReferenceInTDZ","initStart","initEnd","name","idStart","defaultValue","right","defaultStart","defaultEnd","start","end","hasNameDisallowedForLetDeclarations","module","exports","meta","docs","description","category","recommended","url","schema","fixable","create","context","sourceCode","getSourceCode","hasSelfReferenceInTDZ","variables","getDeclaredVariables","canFix","isInLoop","STATEMENT_LIST_PARENTS","has","report","message","fix","fixer","varToken","getFirstToken","filter","t","value","replaceText","kind"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check whether a given variable is a global variable or not.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is a global variable.\n */\nfunction isGlobal(variable) {\n    return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n * @param {eslint-scope.Scope} scope The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n    let currentScope = scope;\n\n    while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n        currentScope = currentScope.upper;\n    }\n    return currentScope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n\n    return variable.references.some(reference =>\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\n        node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n    return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n\n/**\n * Gets the scope node which directly contains a given node.\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n    return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n * @param {ASTNode} scopeNode A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n\n    /**\n     * Checks whether a given reference is inside of the specified scope or not.\n     * @param {eslint-scope.Reference} reference A reference to check.\n     * @returns {boolean} `true` if the reference is inside of the specified\n     *      scope.\n     */\n    function isOutsideOfScope(reference) {\n        const scope = scopeNode.range;\n        const id = reference.identifier.range;\n\n        return id[0] < scope[0] || id[1] > scope[1];\n    }\n\n    return function(variable) {\n        return variable.references.some(isOutsideOfScope);\n    };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n * @param {ASTNode} node The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n    const initStart = node.range[0];\n    const initEnd = node.range[1];\n\n    return variable => {\n        const id = variable.defs[0].name;\n        const idStart = id.range[0];\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\n        const defaultStart = defaultValue && defaultValue.range[0];\n        const defaultEnd = defaultValue && defaultValue.range[1];\n\n        return variable.references.some(reference => {\n            const start = reference.identifier.range[0];\n            const end = reference.identifier.range[1];\n\n            return !reference.init && (\n                start < idStart ||\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\n                (start >= initStart && end <= initEnd)\n            );\n        });\n    };\n}\n\n/**\n * Checks whether a given variable has name that is allowed for 'var' declarations,\n * but disallowed for `let` declarations.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable has a disallowed name.\n */\nfunction hasNameDisallowedForLetDeclarations(variable) {\n    return variable.name === \"let\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `let` or `const` instead of `var`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-var\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n         * @param {ASTNode} declarator The VariableDeclarator node to check.\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n         */\n        function hasSelfReferenceInTDZ(declarator) {\n            if (!declarator.init) {\n                return false;\n            }\n            const variables = context.getDeclaredVariables(declarator);\n\n            return variables.some(hasReferenceInTDZ(declarator.init));\n        }\n\n        /**\n         * Checks whether it can fix a given variable declaration or not.\n         * It cannot fix if the following cases:\n         *\n         * - A variable is a global variable.\n         * - A variable is declared on a SwitchCase node.\n         * - A variable is redeclared.\n         * - A variable is used from outside the scope.\n         * - A variable is used from a closure within a loop.\n         * - A variable might be used before it is assigned within a loop.\n         * - A variable might be used in TDZ.\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n         * - A variable has name that is disallowed for `let` declarations.\n         *\n         * ## A variable is declared on a SwitchCase node.\n         *\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\n         * would generate the warnings of 'no-case-declarations' rule. And the\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n         * this rule doesn't modify those declarations.\n         *\n         * ## A variable is redeclared.\n         *\n         * The language spec disallows redeclarations of `let` declarations.\n         * Those variables would cause syntax errors.\n         *\n         * ## A variable is used from outside the scope.\n         *\n         * The language spec disallows accesses from outside of the scope for\n         * `let` declarations. Those variables would cause reference errors.\n         *\n         * ## A variable is used from a closure within a loop.\n         *\n         * A `var` declaration within a loop shares the same variable instance\n         * across all loop iterations, while a `let` declaration creates a new\n         * instance for each iteration. This means if a variable in a loop is\n         * referenced by any closure, changing it from `var` to `let` would\n         * change the behavior in a way that is generally unsafe.\n         *\n         * ## A variable might be used before it is assigned within a loop.\n         *\n         * Within a loop, a `let` declaration without an initializer will be\n         * initialized to null, while a `var` declaration will retain its value\n         * from the previous iteration, so it is only safe to change `var` to\n         * `let` if we can statically determine that the variable is always\n         * assigned a value before its first access in the loop body. To keep\n         * the implementation simple, we only convert `var` to `let` within\n         * loops when the variable is a loop assignee or the declaration has an\n         * initializer.\n         * @param {ASTNode} node A variable declaration node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         */\n        function canFix(node) {\n            const variables = context.getDeclaredVariables(node);\n            const scopeNode = getScopeNode(node);\n\n            if (node.parent.type === \"SwitchCase\" ||\n                node.declarations.some(hasSelfReferenceInTDZ) ||\n                variables.some(isGlobal) ||\n                variables.some(isRedeclared) ||\n                variables.some(isUsedFromOutsideOf(scopeNode)) ||\n                variables.some(hasNameDisallowedForLetDeclarations)\n            ) {\n                return false;\n            }\n\n            if (astUtils.isInLoop(node)) {\n                if (variables.some(isReferencedInClosure)) {\n                    return false;\n                }\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n                    return false;\n                }\n            }\n\n            if (\n                !isLoopAssignee(node) &&\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\n            ) {\n\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Reports a given variable declaration node.\n         * @param {ASTNode} node A variable declaration node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"Unexpected var, use let or const instead.\",\n\n                fix(fixer) {\n                    const varToken = sourceCode.getFirstToken(node, { filter: t => t.value === \"var\" });\n\n                    return canFix(node)\n                        ? fixer.replaceText(varToken, \"let\")\n                        : null;\n                }\n            });\n        }\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n                if (node.kind === \"var\") {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}