{"ast":null,"code":"/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\n\n\nfunction isNaNIdentifier(node) {\n  return Boolean(node) && node.type === \"Identifier\" && node.name === \"NaN\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require calls to `isNaN()` when checking for `NaN`\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/use-isnan\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForSwitchCase: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceForIndexOf: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n      switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n      caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n      indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n    }\n  },\n\n  create(context) {\n    const enforceForSwitchCase = context.options[0] && context.options[0].enforceForSwitchCase;\n    const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n    /**\n     * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n    function checkBinaryExpression(node) {\n      if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {\n        context.report({\n          node,\n          messageId: \"comparisonWithNaN\"\n        });\n      }\n    }\n    /**\n     * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n\n    function checkSwitchStatement(node) {\n      if (isNaNIdentifier(node.discriminant)) {\n        context.report({\n          node,\n          messageId: \"switchNaN\"\n        });\n      }\n\n      for (const switchCase of node.cases) {\n        if (isNaNIdentifier(switchCase.test)) {\n          context.report({\n            node: switchCase,\n            messageId: \"caseNaN\"\n          });\n        }\n      }\n    }\n    /**\n     * Checks the the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n\n    function checkCallExpression(node) {\n      const callee = node.callee;\n\n      if (callee.type === \"MemberExpression\") {\n        const methodName = astUtils.getStaticPropertyName(callee);\n\n        if ((methodName === \"indexOf\" || methodName === \"lastIndexOf\") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {\n          context.report({\n            node,\n            messageId: \"indexOfNaN\",\n            data: {\n              methodName\n            }\n          });\n        }\n      }\n    }\n\n    const listeners = {\n      BinaryExpression: checkBinaryExpression\n    };\n\n    if (enforceForSwitchCase) {\n      listeners.SwitchStatement = checkSwitchStatement;\n    }\n\n    if (enforceForIndexOf) {\n      listeners.CallExpression = checkCallExpression;\n    }\n\n    return listeners;\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/use-isnan.js"],"names":["astUtils","require","isNaNIdentifier","node","Boolean","type","name","module","exports","meta","docs","description","category","recommended","url","schema","properties","enforceForSwitchCase","default","enforceForIndexOf","additionalProperties","messages","comparisonWithNaN","switchNaN","caseNaN","indexOfNaN","create","context","options","checkBinaryExpression","test","operator","left","right","report","messageId","checkSwitchStatement","discriminant","switchCase","cases","checkCallExpression","callee","methodName","getStaticPropertyName","arguments","length","data","listeners","BinaryExpression","SwitchStatement","CallExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\nfunction isNaNIdentifier(node) {\n    return Boolean(node) && node.type === \"Identifier\" && node.name === \"NaN\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/use-isnan\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForSwitchCase: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceForIndexOf: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n            switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n            caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n            indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n        }\n    },\n\n    create(context) {\n\n        const enforceForSwitchCase = context.options[0] && context.options[0].enforceForSwitchCase;\n        const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n\n        /**\n         * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkBinaryExpression(node) {\n            if (\n                /^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&\n                (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))\n            ) {\n                context.report({ node, messageId: \"comparisonWithNaN\" });\n            }\n        }\n\n        /**\n         * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkSwitchStatement(node) {\n            if (isNaNIdentifier(node.discriminant)) {\n                context.report({ node, messageId: \"switchNaN\" });\n            }\n\n            for (const switchCase of node.cases) {\n                if (isNaNIdentifier(switchCase.test)) {\n                    context.report({ node: switchCase, messageId: \"caseNaN\" });\n                }\n            }\n        }\n\n        /**\n         * Checks the the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkCallExpression(node) {\n            const callee = node.callee;\n\n            if (callee.type === \"MemberExpression\") {\n                const methodName = astUtils.getStaticPropertyName(callee);\n\n                if (\n                    (methodName === \"indexOf\" || methodName === \"lastIndexOf\") &&\n                    node.arguments.length === 1 &&\n                    isNaNIdentifier(node.arguments[0])\n                ) {\n                    context.report({ node, messageId: \"indexOfNaN\", data: { methodName } });\n                }\n            }\n        }\n\n        const listeners = {\n            BinaryExpression: checkBinaryExpression\n        };\n\n        if (enforceForSwitchCase) {\n            listeners.SwitchStatement = checkSwitchStatement;\n        }\n\n        if (enforceForIndexOf) {\n            listeners.CallExpression = checkCallExpression;\n        }\n\n        return listeners;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}