{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar valueParser = _interopDefault(require('postcss-values-parser'));\n\nvar fs = _interopDefault(require('fs'));\n\nvar path = _interopDefault(require('path'));\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction parse(string) {\n  return valueParser(string).parse();\n}\n\nfunction isBlockIgnored(ruleOrDeclaration) {\n  var rule = ruleOrDeclaration.selector ? ruleOrDeclaration : ruleOrDeclaration.parent;\n  return /(!\\s*)?postcss-custom-properties:\\s*off\\b/i.test(rule.toString());\n}\n\nfunction isRuleIgnored(rule) {\n  var previous = rule.prev();\n  return Boolean(isBlockIgnored(rule) || previous && previous.type === 'comment' && /(!\\s*)?postcss-custom-properties:\\s*ignore\\s+next\\b/i.test(previous.text));\n}\n\nfunction getCustomPropertiesFromRoot(root, opts) {\n  // initialize custom selectors\n  const customPropertiesFromHtmlElement = {};\n  const customPropertiesFromRootPseudo = {}; // for each html or :root rule\n\n  root.nodes.slice().forEach(rule => {\n    const customPropertiesObject = isHtmlRule(rule) ? customPropertiesFromHtmlElement : isRootRule(rule) ? customPropertiesFromRootPseudo : null; // for each custom property\n\n    if (customPropertiesObject) {\n      rule.nodes.slice().forEach(decl => {\n        if (isCustomDecl(decl) && !isBlockIgnored(decl)) {\n          const prop = decl.prop; // write the parsed value to the custom property\n\n          customPropertiesObject[prop] = parse(decl.value).nodes; // conditionally remove the custom property declaration\n\n          if (!opts.preserve) {\n            decl.remove();\n          }\n        }\n      }); // conditionally remove the empty html or :root rule\n\n      if (!opts.preserve && isEmptyParent(rule) && !isBlockIgnored(rule)) {\n        rule.remove();\n      }\n    }\n  }); // return all custom properties, preferring :root properties over html properties\n\n  return Object.assign({}, customPropertiesFromHtmlElement, customPropertiesFromRootPseudo);\n} // match html and :root rules\n\n\nconst htmlSelectorRegExp = /^html$/i;\nconst rootSelectorRegExp = /^:root$/i;\nconst customPropertyRegExp = /^--[A-z][\\w-]*$/; // whether the node is an html or :root rule\n\nconst isHtmlRule = node => node.type === 'rule' && htmlSelectorRegExp.test(node.selector) && Object(node.nodes).length;\n\nconst isRootRule = node => node.type === 'rule' && rootSelectorRegExp.test(node.selector) && Object(node.nodes).length; // whether the node is an custom property\n\n\nconst isCustomDecl = node => node.type === 'decl' && customPropertyRegExp.test(node.prop); // whether the node is a parent without children\n\n\nconst isEmptyParent = node => Object(node.nodes).length === 0;\n/* Get Custom Properties from CSS File\n/* ========================================================================== */\n\n\nfunction getCustomPropertiesFromCSSFile(_x) {\n  return _getCustomPropertiesFromCSSFile.apply(this, arguments);\n}\n/* Get Custom Properties from Object\n/* ========================================================================== */\n\n\nfunction _getCustomPropertiesFromCSSFile() {\n  _getCustomPropertiesFromCSSFile = _asyncToGenerator(function* (from) {\n    const css = yield readFile(from);\n    const root = postcss.parse(css, {\n      from\n    });\n    return getCustomPropertiesFromRoot(root, {\n      preserve: true\n    });\n  });\n  return _getCustomPropertiesFromCSSFile.apply(this, arguments);\n}\n\nfunction getCustomPropertiesFromObject(object) {\n  const customProperties = Object.assign({}, Object(object).customProperties, Object(object)['custom-properties']);\n\n  for (const key in customProperties) {\n    customProperties[key] = parse(String(customProperties[key])).nodes;\n  }\n\n  return customProperties;\n}\n/* Get Custom Properties from JSON file\n/* ========================================================================== */\n\n\nfunction getCustomPropertiesFromJSONFile(_x2) {\n  return _getCustomPropertiesFromJSONFile.apply(this, arguments);\n}\n/* Get Custom Properties from JS file\n/* ========================================================================== */\n\n\nfunction _getCustomPropertiesFromJSONFile() {\n  _getCustomPropertiesFromJSONFile = _asyncToGenerator(function* (from) {\n    const object = yield readJSON(from);\n    return getCustomPropertiesFromObject(object);\n  });\n  return _getCustomPropertiesFromJSONFile.apply(this, arguments);\n}\n\nfunction getCustomPropertiesFromJSFile(_x3) {\n  return _getCustomPropertiesFromJSFile.apply(this, arguments);\n}\n/* Get Custom Properties from Imports\n/* ========================================================================== */\n\n\nfunction _getCustomPropertiesFromJSFile() {\n  _getCustomPropertiesFromJSFile = _asyncToGenerator(function* (from) {\n    const object = yield Promise.resolve(require(from));\n    return getCustomPropertiesFromObject(object);\n  });\n  return _getCustomPropertiesFromJSFile.apply(this, arguments);\n}\n\nfunction getCustomPropertiesFromImports(sources) {\n  return sources.map(source => {\n    if (source instanceof Promise) {\n      return source;\n    } else if (source instanceof Function) {\n      return source();\n    } // read the source as an object\n\n\n    const opts = source === Object(source) ? source : {\n      from: String(source)\n    }; // skip objects with Custom Properties\n\n    if (opts.customProperties || opts['custom-properties']) {\n      return opts;\n    } // source pathname\n\n\n    const from = path.resolve(String(opts.from || '')); // type of file being read from\n\n    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n    return {\n      type,\n      from\n    };\n  }).reduce( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (customProperties, source) {\n      const _ref2 = yield source,\n            type = _ref2.type,\n            from = _ref2.from;\n\n      if (type === 'css') {\n        return Object.assign(yield customProperties, yield getCustomPropertiesFromCSSFile(from));\n      }\n\n      if (type === 'js') {\n        return Object.assign(yield customProperties, yield getCustomPropertiesFromJSFile(from));\n      }\n\n      if (type === 'json') {\n        return Object.assign(yield customProperties, yield getCustomPropertiesFromJSONFile(from));\n      }\n\n      return Object.assign(yield customProperties, yield getCustomPropertiesFromObject(yield source));\n    });\n\n    return function (_x4, _x5) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {});\n}\n/* Helper utilities\n/* ========================================================================== */\n\n\nconst readFile = from => new Promise((resolve, reject) => {\n  fs.readFile(from, 'utf8', (error, result) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst readJSON = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (from) {\n    return JSON.parse(yield readFile(from));\n  });\n\n  return function readJSON(_x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nfunction transformValueAST(root, customProperties) {\n  if (root.nodes && root.nodes.length) {\n    root.nodes.slice().forEach(child => {\n      if (isVarFunction(child)) {\n        // eslint-disable-next-line no-unused-vars\n        const _child$nodes$slice = child.nodes.slice(1, -1),\n              propertyNode = _child$nodes$slice[0],\n              comma = _child$nodes$slice[1],\n              fallbacks = _child$nodes$slice.slice(2);\n\n        const name = propertyNode.value;\n\n        if (name in Object(customProperties)) {\n          // conditionally replace a known custom property\n          const nodes = asClonedArrayWithBeforeSpacing(customProperties[name], child.raws.before);\n          child.replaceWith(...nodes);\n          retransformValueAST({\n            nodes\n          }, customProperties, name);\n        } else if (fallbacks.length) {\n          // conditionally replace a custom property with a fallback\n          const index = root.nodes.indexOf(child);\n\n          if (index !== -1) {\n            root.nodes.splice(index, 1, ...asClonedArrayWithBeforeSpacing(fallbacks, child.raws.before));\n          }\n\n          transformValueAST(root, customProperties);\n        }\n      } else {\n        transformValueAST(child, customProperties);\n      }\n    });\n  }\n\n  return root;\n} // retransform the current ast without a custom property (to prevent recursion)\n\n\nfunction retransformValueAST(root, customProperties, withoutProperty) {\n  const nextCustomProperties = Object.assign({}, customProperties);\n  delete nextCustomProperties[withoutProperty];\n  return transformValueAST(root, nextCustomProperties);\n} // match var() functions\n\n\nconst varRegExp = /^var$/i; // whether the node is a var() function\n\nconst isVarFunction = node => node.type === 'func' && varRegExp.test(node.value) && Object(node.nodes).length > 0; // return an array with its nodes cloned, preserving the raw\n\n\nconst asClonedArrayWithBeforeSpacing = (array, beforeSpacing) => {\n  const clonedArray = asClonedArray(array, null);\n\n  if (clonedArray[0]) {\n    clonedArray[0].raws.before = beforeSpacing;\n  }\n\n  return clonedArray;\n}; // return an array with its nodes cloned\n\n\nconst asClonedArray = (array, parent) => array.map(node => asClonedNode(node, parent)); // return a cloned node\n\n\nconst asClonedNode = (node, parent) => {\n  const cloneNode = new node.constructor(node);\n\n  for (const key in node) {\n    if (key === 'parent') {\n      cloneNode.parent = parent;\n    } else if (Object(node[key]).constructor === Array) {\n      cloneNode[key] = asClonedArray(node.nodes, cloneNode);\n    } else if (Object(node[key]).constructor === Object) {\n      cloneNode[key] = Object.assign({}, node[key]);\n    }\n  }\n\n  return cloneNode;\n};\n\nvar transformProperties = (root, customProperties, opts) => {\n  // walk decls that can be transformed\n  root.walkDecls(decl => {\n    if (isTransformableDecl(decl) && !isRuleIgnored(decl)) {\n      const originalValue = decl.value;\n      const valueAST = parse(originalValue);\n      const value = String(transformValueAST(valueAST, customProperties)); // conditionally transform values that have changed\n\n      if (value !== originalValue) {\n        if (opts.preserve) {\n          decl.cloneBefore({\n            value\n          });\n        } else {\n          decl.value = value;\n        }\n      }\n    }\n  });\n}; // match custom properties\n\n\nconst customPropertyRegExp$1 = /^--[A-z][\\w-]*$/; // match custom property inclusions\n\nconst customPropertiesRegExp = /(^|[^\\w-])var\\([\\W\\w]+\\)/; // whether the declaration should be potentially transformed\n\nconst isTransformableDecl = decl => !customPropertyRegExp$1.test(decl.prop) && customPropertiesRegExp.test(decl.value);\n/* Write Custom Properties to CSS File\n/* ========================================================================== */\n\n\nfunction writeCustomPropertiesToCssFile(_x, _x2) {\n  return _writeCustomPropertiesToCssFile.apply(this, arguments);\n}\n/* Write Custom Properties to JSON file\n/* ========================================================================== */\n\n\nfunction _writeCustomPropertiesToCssFile() {\n  _writeCustomPropertiesToCssFile = _asyncToGenerator(function* (to, customProperties) {\n    const cssContent = Object.keys(customProperties).reduce((cssLines, name) => {\n      cssLines.push(`\\t${name}: ${customProperties[name]};`);\n      return cssLines;\n    }, []).join('\\n');\n    const css = `:root {\\n${cssContent}\\n}\\n`;\n    yield writeFile(to, css);\n  });\n  return _writeCustomPropertiesToCssFile.apply(this, arguments);\n}\n\nfunction writeCustomPropertiesToJsonFile(_x3, _x4) {\n  return _writeCustomPropertiesToJsonFile.apply(this, arguments);\n}\n/* Write Custom Properties to Common JS file\n/* ========================================================================== */\n\n\nfunction _writeCustomPropertiesToJsonFile() {\n  _writeCustomPropertiesToJsonFile = _asyncToGenerator(function* (to, customProperties) {\n    const jsonContent = JSON.stringify({\n      'custom-properties': customProperties\n    }, null, '  ');\n    const json = `${jsonContent}\\n`;\n    yield writeFile(to, json);\n  });\n  return _writeCustomPropertiesToJsonFile.apply(this, arguments);\n}\n\nfunction writeCustomPropertiesToCjsFile(_x5, _x6) {\n  return _writeCustomPropertiesToCjsFile.apply(this, arguments);\n}\n/* Write Custom Properties to Module JS file\n/* ========================================================================== */\n\n\nfunction _writeCustomPropertiesToCjsFile() {\n  _writeCustomPropertiesToCjsFile = _asyncToGenerator(function* (to, customProperties) {\n    const jsContents = Object.keys(customProperties).reduce((jsLines, name) => {\n      jsLines.push(`\\t\\t'${escapeForJS(name)}': '${escapeForJS(customProperties[name])}'`);\n      return jsLines;\n    }, []).join(',\\n');\n    const js = `module.exports = {\\n\\tcustomProperties: {\\n${jsContents}\\n\\t}\\n};\\n`;\n    yield writeFile(to, js);\n  });\n  return _writeCustomPropertiesToCjsFile.apply(this, arguments);\n}\n\nfunction writeCustomPropertiesToMjsFile(_x7, _x8) {\n  return _writeCustomPropertiesToMjsFile.apply(this, arguments);\n}\n/* Write Custom Properties to Exports\n/* ========================================================================== */\n\n\nfunction _writeCustomPropertiesToMjsFile() {\n  _writeCustomPropertiesToMjsFile = _asyncToGenerator(function* (to, customProperties) {\n    const mjsContents = Object.keys(customProperties).reduce((mjsLines, name) => {\n      mjsLines.push(`\\t'${escapeForJS(name)}': '${escapeForJS(customProperties[name])}'`);\n      return mjsLines;\n    }, []).join(',\\n');\n    const mjs = `export const customProperties = {\\n${mjsContents}\\n};\\n`;\n    yield writeFile(to, mjs);\n  });\n  return _writeCustomPropertiesToMjsFile.apply(this, arguments);\n}\n\nfunction writeCustomPropertiesToExports(customProperties, destinations) {\n  return Promise.all(destinations.map( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (destination) {\n      if (destination instanceof Function) {\n        yield destination(defaultCustomPropertiesToJSON(customProperties));\n      } else {\n        // read the destination as an object\n        const opts = destination === Object(destination) ? destination : {\n          to: String(destination)\n        }; // transformer for Custom Properties into a JSON-compatible object\n\n        const toJSON = opts.toJSON || defaultCustomPropertiesToJSON;\n\n        if ('customProperties' in opts) {\n          // write directly to an object as customProperties\n          opts.customProperties = toJSON(customProperties);\n        } else if ('custom-properties' in opts) {\n          // write directly to an object as custom-properties\n          opts['custom-properties'] = toJSON(customProperties);\n        } else {\n          // destination pathname\n          const to = String(opts.to || ''); // type of file being written to\n\n          const type = (opts.type || path.extname(opts.to).slice(1)).toLowerCase(); // transformed Custom Properties\n\n          const customPropertiesJSON = toJSON(customProperties);\n\n          if (type === 'css') {\n            yield writeCustomPropertiesToCssFile(to, customPropertiesJSON);\n          }\n\n          if (type === 'js') {\n            yield writeCustomPropertiesToCjsFile(to, customPropertiesJSON);\n          }\n\n          if (type === 'json') {\n            yield writeCustomPropertiesToJsonFile(to, customPropertiesJSON);\n          }\n\n          if (type === 'mjs') {\n            yield writeCustomPropertiesToMjsFile(to, customPropertiesJSON);\n          }\n        }\n      }\n    });\n\n    return function (_x9) {\n      return _ref.apply(this, arguments);\n    };\n  }()));\n}\n/* Helper utilities\n/* ========================================================================== */\n\n\nconst defaultCustomPropertiesToJSON = customProperties => {\n  return Object.keys(customProperties).reduce((customPropertiesJSON, key) => {\n    customPropertiesJSON[key] = String(customProperties[key]);\n    return customPropertiesJSON;\n  }, {});\n};\n\nconst writeFile = (to, text) => new Promise((resolve, reject) => {\n  fs.writeFile(to, text, error => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve();\n    }\n  });\n});\n\nconst escapeForJS = string => string.replace(/\\\\([\\s\\S])|(')/g, '\\\\$1$2').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n\nvar index = postcss.plugin('postcss-custom-properties', opts => {\n  // whether to preserve custom selectors and rules using them\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true; // sources to import custom selectors from\n\n  const importFrom = [].concat(Object(opts).importFrom || []); // destinations to export custom selectors to\n\n  const exportTo = [].concat(Object(opts).exportTo || []); // promise any custom selectors are imported\n\n  const customPropertiesPromise = getCustomPropertiesFromImports(importFrom); // synchronous transform\n\n  const syncTransform = root => {\n    const customProperties = getCustomPropertiesFromRoot(root, {\n      preserve\n    });\n    transformProperties(root, customProperties, {\n      preserve\n    });\n  }; // asynchronous transform\n\n\n  const asyncTransform = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (root) {\n      const customProperties = Object.assign({}, yield customPropertiesPromise, getCustomPropertiesFromRoot(root, {\n        preserve\n      }));\n      yield writeCustomPropertiesToExports(customProperties, exportTo);\n      transformProperties(root, customProperties, {\n        preserve\n      });\n    });\n\n    return function asyncTransform(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(); // whether to return synchronous function if no asynchronous operations are requested\n\n\n  const canReturnSyncFunction = importFrom.length === 0 && exportTo.length === 0;\n  return canReturnSyncFunction ? syncTransform : asyncTransform;\n});\nmodule.exports = index;","map":{"version":3,"sources":["src/lib/postcss-values-parser.js","src/lib/is-ignored.js","src/lib/get-custom-properties-from-root.js","src/lib/get-custom-properties-from-imports.js","src/lib/transform-value-ast.js","src/lib/transform-properties.js","src/lib/write-custom-properties-to-exports.js","src/index.js"],"names":["valueParser","rule","ruleOrDeclaration","previous","Boolean","isBlockIgnored","customPropertiesFromHtmlElement","customPropertiesFromRootPseudo","root","customPropertiesObject","isHtmlRule","isRootRule","decl","isCustomDecl","prop","parse","opts","isEmptyParent","htmlSelectorRegExp","rootSelectorRegExp","customPropertyRegExp","node","Object","getCustomPropertiesFromCSSFile","css","readFile","from","getCustomPropertiesFromRoot","preserve","customProperties","String","getCustomPropertiesFromJSONFile","object","readJSON","getCustomPropertiesFromObject","getCustomPropertiesFromJSFile","source","path","type","fs","reject","resolve","JSON","child","isVarFunction","propertyNode","comma","fallbacks","name","nodes","asClonedArrayWithBeforeSpacing","retransformValueAST","index","transformValueAST","nextCustomProperties","varRegExp","clonedArray","asClonedArray","array","asClonedNode","cloneNode","key","isTransformableDecl","isRuleIgnored","originalValue","valueAST","value","customPropertiesRegExp","writeCustomPropertiesToCssFile","cssContent","cssLines","writeFile","writeCustomPropertiesToJsonFile","jsonContent","json","writeCustomPropertiesToCjsFile","jsContents","jsLines","escapeForJS","js","writeCustomPropertiesToMjsFile","mjsContents","mjsLines","mjs","destination","defaultCustomPropertiesToJSON","to","toJSON","customPropertiesJSON","error","string","importFrom","exportTo","customPropertiesPromise","getCustomPropertiesFromImports","syncTransform","transformProperties","asyncTransform","writeCustomPropertiesToExports","canReturnSyncFunction"],"mappings":"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","sourcesContent":["import valueParser from 'postcss-values-parser';\n\nexport function parse (string) {\n\treturn valueParser(string).parse();\n}\n","function isBlockIgnored(ruleOrDeclaration) {\n\tvar rule = ruleOrDeclaration.selector ?\n\t\truleOrDeclaration : ruleOrDeclaration.parent;\n\n\treturn /(!\\s*)?postcss-custom-properties:\\s*off\\b/i.test(rule.toString())\n}\n\nfunction isRuleIgnored(rule) {\n\tvar previous = rule.prev();\n\n\treturn Boolean(isBlockIgnored(rule) ||\n\t\tprevious &&\n\t\tprevious.type === 'comment' &&\n\t\t/(!\\s*)?postcss-custom-properties:\\s*ignore\\s+next\\b/i.test(previous.text));\n}\n\nexport {\n\tisBlockIgnored,\n\tisRuleIgnored\n}\n","import { parse } from './postcss-values-parser';\nimport { isBlockIgnored } from './is-ignored';\n\n// return custom selectors from the css root, conditionally removing them\nexport default function getCustomPropertiesFromRoot(root, opts) {\n\t// initialize custom selectors\n\tconst customPropertiesFromHtmlElement = {};\n\tconst customPropertiesFromRootPseudo = {};\n\n\t// for each html or :root rule\n\troot.nodes.slice().forEach(rule => {\n\t\tconst customPropertiesObject = isHtmlRule(rule)\n\t\t\t? customPropertiesFromHtmlElement\n\t\t: isRootRule(rule)\n\t\t\t? customPropertiesFromRootPseudo\n\t\t: null;\n\n\t\t// for each custom property\n\t\tif (customPropertiesObject) {\n\t\t\trule.nodes.slice().forEach(decl => {\n\t\t\t\tif (isCustomDecl(decl) && !isBlockIgnored(decl)) {\n\t\t\t\t\tconst { prop } = decl;\n\n\t\t\t\t\t// write the parsed value to the custom property\n\t\t\t\t\tcustomPropertiesObject[prop] = parse(decl.value).nodes;\n\n\t\t\t\t\t// conditionally remove the custom property declaration\n\t\t\t\t\tif (!opts.preserve) {\n\t\t\t\t\t\tdecl.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// conditionally remove the empty html or :root rule\n\t\t\tif (!opts.preserve && isEmptyParent(rule) && !isBlockIgnored(rule)) {\n\t\t\t\trule.remove();\n\t\t\t}\n\t\t}\n\t});\n\n\t// return all custom properties, preferring :root properties over html properties\n\treturn { ...customPropertiesFromHtmlElement, ...customPropertiesFromRootPseudo };\n}\n\n// match html and :root rules\nconst htmlSelectorRegExp = /^html$/i;\nconst rootSelectorRegExp = /^:root$/i;\nconst customPropertyRegExp = /^--[A-z][\\w-]*$/;\n\n// whether the node is an html or :root rule\nconst isHtmlRule = node => node.type === 'rule' && htmlSelectorRegExp.test(node.selector) && Object(node.nodes).length;\nconst isRootRule = node => node.type === 'rule' && rootSelectorRegExp.test(node.selector) && Object(node.nodes).length;\n\n// whether the node is an custom property\nconst isCustomDecl = node => node.type === 'decl' && customPropertyRegExp.test(node.prop);\n\n// whether the node is a parent without children\nconst isEmptyParent = node => Object(node.nodes).length === 0;\n","import fs from 'fs';\nimport path from 'path';\nimport postcss from 'postcss';\nimport { parse } from './postcss-values-parser';\nimport getCustomPropertiesFromRoot from './get-custom-properties-from-root';\n\n/* Get Custom Properties from CSS File\n/* ========================================================================== */\n\nasync function getCustomPropertiesFromCSSFile(from) {\n\tconst css = await readFile(from);\n\tconst root = postcss.parse(css, { from });\n\n\treturn getCustomPropertiesFromRoot(root, { preserve: true });\n}\n\n/* Get Custom Properties from Object\n/* ========================================================================== */\n\nfunction getCustomPropertiesFromObject(object) {\n\tconst customProperties = Object.assign(\n\t\t{},\n\t\tObject(object).customProperties,\n\t\tObject(object)['custom-properties']\n\t);\n\n\tfor (const key in customProperties) {\n\t\tcustomProperties[key] = parse(String(customProperties[key])).nodes;\n\t}\n\n\treturn customProperties;\n}\n\n/* Get Custom Properties from JSON file\n/* ========================================================================== */\n\nasync function getCustomPropertiesFromJSONFile(from) {\n\tconst object = await readJSON(from);\n\n\treturn getCustomPropertiesFromObject(object);\n}\n\n/* Get Custom Properties from JS file\n/* ========================================================================== */\n\nasync function getCustomPropertiesFromJSFile(from) {\n\tconst object = await import(from);\n\n\treturn getCustomPropertiesFromObject(object);\n}\n\n/* Get Custom Properties from Imports\n/* ========================================================================== */\n\nexport default function getCustomPropertiesFromImports(sources) {\n\treturn sources.map(source => {\n\t\tif (source instanceof Promise) {\n\t\t\treturn source;\n\t\t} else if (source instanceof Function) {\n\t\t\treturn source();\n\t\t}\n\n\t\t// read the source as an object\n\t\tconst opts = source === Object(source) ? source : { from: String(source) };\n\n\t\t// skip objects with Custom Properties\n\t\tif (opts.customProperties || opts['custom-properties']) {\n\t\t\treturn opts\n\t\t}\n\n\t\t// source pathname\n\t\tconst from = path.resolve(String(opts.from || ''));\n\n\t\t// type of file being read from\n\t\tconst type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n\n\t\treturn { type, from };\n\t}).reduce(async (customProperties, source) => {\n\t\tconst { type, from } = await source;\n\n\t\tif (type === 'css') {\n\t\t\treturn Object.assign(await customProperties, await getCustomPropertiesFromCSSFile(from));\n\t\t}\n\n\t\tif (type === 'js') {\n\t\t\treturn Object.assign(await customProperties, await getCustomPropertiesFromJSFile(from));\n\t\t}\n\n\t\tif (type === 'json') {\n\t\t\treturn Object.assign(await customProperties, await getCustomPropertiesFromJSONFile(from));\n\t\t}\n\n\t\treturn Object.assign(await customProperties, await getCustomPropertiesFromObject(await source));\n\t}, {});\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst readFile = from => new Promise((resolve, reject) => {\n\tfs.readFile(from, 'utf8', (error, result) => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n});\n\nconst readJSON = async from => JSON.parse(await readFile(from));\n","export default function transformValueAST(root, customProperties) {\n\tif (root.nodes && root.nodes.length) {\n\t\troot.nodes.slice().forEach(child => {\n\t\t\tif (isVarFunction(child)) {\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\tconst [propertyNode, comma, ...fallbacks] = child.nodes.slice(1, -1);\n\t\t\t\tconst { value: name } = propertyNode;\n\n\t\t\t\tif (name in Object(customProperties)) {\n\t\t\t\t\t// conditionally replace a known custom property\n\t\t\t\t\tconst nodes = asClonedArrayWithBeforeSpacing(customProperties[name], child.raws.before);\n\n\t\t\t\t\tchild.replaceWith(...nodes);\n\n\t\t\t\t\tretransformValueAST({ nodes }, customProperties, name);\n\t\t\t\t} else if (fallbacks.length) {\n\t\t\t\t\t// conditionally replace a custom property with a fallback\n\t\t\t\t\tconst index = root.nodes.indexOf(child);\n\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\troot.nodes.splice(index, 1, ...asClonedArrayWithBeforeSpacing(fallbacks, child.raws.before));\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformValueAST(root, customProperties);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransformValueAST(child, customProperties);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn root;\n}\n\n// retransform the current ast without a custom property (to prevent recursion)\nfunction retransformValueAST(root, customProperties, withoutProperty) {\n\tconst nextCustomProperties = Object.assign({}, customProperties);\n\n\tdelete nextCustomProperties[withoutProperty];\n\n\treturn transformValueAST(root, nextCustomProperties);\n}\n\n// match var() functions\nconst varRegExp = /^var$/i;\n\n// whether the node is a var() function\nconst isVarFunction = node => node.type === 'func' && varRegExp.test(node.value) && Object(node.nodes).length > 0;\n\n// return an array with its nodes cloned, preserving the raw\nconst asClonedArrayWithBeforeSpacing = (array, beforeSpacing) => {\n\tconst clonedArray = asClonedArray(array, null);\n\n\tif (clonedArray[0]) {\n\t\tclonedArray[0].raws.before = beforeSpacing;\n\t}\n\n\treturn clonedArray;\n};\n\n// return an array with its nodes cloned\nconst asClonedArray = (array, parent) => array.map(node => asClonedNode(node, parent));\n\n// return a cloned node\nconst asClonedNode = (node, parent) => {\n\tconst cloneNode = new node.constructor(node);\n\n\tfor (const key in node) {\n\t\tif (key === 'parent') {\n\t\t\tcloneNode.parent = parent;\n\t\t} else if (Object(node[key]).constructor === Array) {\n\t\t\tcloneNode[key] = asClonedArray(node.nodes, cloneNode);\n\t\t} else if (Object(node[key]).constructor === Object) {\n\t\t\tcloneNode[key] = Object.assign({}, node[key]);\n\t\t}\n\t}\n\n\treturn cloneNode;\n};\n","import { parse } from './postcss-values-parser';\nimport transformValueAST from './transform-value-ast';\nimport { isRuleIgnored } from './is-ignored';\n\n// transform custom pseudo selectors with custom selectors\nexport default (root, customProperties, opts) => {\n\t// walk decls that can be transformed\n\troot.walkDecls(decl => {\n\t\tif (isTransformableDecl(decl) && !isRuleIgnored(decl)) {\n\t\t\tconst originalValue = decl.value;\n\t\t\tconst valueAST = parse(originalValue);\n\t\t\tconst value = String(transformValueAST(valueAST, customProperties));\n\n\t\t\t// conditionally transform values that have changed\n\t\t\tif (value !== originalValue) {\n\t\t\t\tif (opts.preserve) {\n\t\t\t\t\tdecl.cloneBefore({ value });\n\t\t\t\t} else {\n\t\t\t\t\tdecl.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n};\n\n// match custom properties\nconst customPropertyRegExp = /^--[A-z][\\w-]*$/;\n\n// match custom property inclusions\nconst customPropertiesRegExp = /(^|[^\\w-])var\\([\\W\\w]+\\)/;\n\n// whether the declaration should be potentially transformed\nconst isTransformableDecl = decl => !customPropertyRegExp.test(decl.prop) && customPropertiesRegExp.test(decl.value);\n","import fs from 'fs';\nimport path from 'path';\n\n/* Write Custom Properties to CSS File\n/* ========================================================================== */\n\nasync function writeCustomPropertiesToCssFile(to, customProperties) {\n\tconst cssContent = Object.keys(customProperties).reduce((cssLines, name) => {\n\t\tcssLines.push(`\\t${name}: ${customProperties[name]};`);\n\n\t\treturn cssLines;\n\t}, []).join('\\n');\n\tconst css = `:root {\\n${cssContent}\\n}\\n`;\n\n\tawait writeFile(to, css);\n}\n\n/* Write Custom Properties to JSON file\n/* ========================================================================== */\n\nasync function writeCustomPropertiesToJsonFile(to, customProperties) {\n\tconst jsonContent = JSON.stringify({\n\t\t'custom-properties': customProperties\n\t}, null, '  ');\n\tconst json = `${jsonContent}\\n`;\n\n\tawait writeFile(to, json);\n}\n\n/* Write Custom Properties to Common JS file\n/* ========================================================================== */\n\nasync function writeCustomPropertiesToCjsFile(to, customProperties) {\n\tconst jsContents = Object.keys(customProperties).reduce((jsLines, name) => {\n\t\tjsLines.push(`\\t\\t'${escapeForJS(name)}': '${escapeForJS(customProperties[name])}'`);\n\n\t\treturn jsLines;\n\t}, []).join(',\\n');\n\tconst js = `module.exports = {\\n\\tcustomProperties: {\\n${jsContents}\\n\\t}\\n};\\n`;\n\n\tawait writeFile(to, js);\n}\n\n/* Write Custom Properties to Module JS file\n/* ========================================================================== */\n\nasync function writeCustomPropertiesToMjsFile(to, customProperties) {\n\tconst mjsContents = Object.keys(customProperties).reduce((mjsLines, name) => {\n\t\tmjsLines.push(`\\t'${escapeForJS(name)}': '${escapeForJS(customProperties[name])}'`);\n\n\t\treturn mjsLines;\n\t}, []).join(',\\n');\n\tconst mjs = `export const customProperties = {\\n${mjsContents}\\n};\\n`;\n\n\tawait writeFile(to, mjs);\n}\n\n/* Write Custom Properties to Exports\n/* ========================================================================== */\n\nexport default function writeCustomPropertiesToExports(customProperties, destinations) {\n\treturn Promise.all(destinations.map(async destination => {\n\t\tif (destination instanceof Function) {\n\t\t\tawait destination(defaultCustomPropertiesToJSON(customProperties));\n\t\t} else {\n\t\t\t// read the destination as an object\n\t\t\tconst opts = destination === Object(destination) ? destination : { to: String(destination) };\n\n\t\t\t// transformer for Custom Properties into a JSON-compatible object\n\t\t\tconst toJSON = opts.toJSON || defaultCustomPropertiesToJSON;\n\n\t\t\tif ('customProperties' in opts) {\n\t\t\t\t// write directly to an object as customProperties\n\t\t\t\topts.customProperties = toJSON(customProperties);\n\t\t\t} else if ('custom-properties' in opts) {\n\t\t\t\t// write directly to an object as custom-properties\n\t\t\t\topts['custom-properties'] = toJSON(customProperties);\n\t\t\t} else {\n\t\t\t\t// destination pathname\n\t\t\t\tconst to = String(opts.to || '');\n\n\t\t\t\t// type of file being written to\n\t\t\t\tconst type = (opts.type || path.extname(opts.to).slice(1)).toLowerCase();\n\n\t\t\t\t// transformed Custom Properties\n\t\t\t\tconst customPropertiesJSON = toJSON(customProperties);\n\n\t\t\t\tif (type === 'css') {\n\t\t\t\t\tawait writeCustomPropertiesToCssFile(to, customPropertiesJSON);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'js') {\n\t\t\t\t\tawait writeCustomPropertiesToCjsFile(to, customPropertiesJSON);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'json') {\n\t\t\t\t\tawait writeCustomPropertiesToJsonFile(to, customPropertiesJSON);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'mjs') {\n\t\t\t\t\tawait writeCustomPropertiesToMjsFile(to, customPropertiesJSON);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}));\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst defaultCustomPropertiesToJSON = customProperties => {\n\treturn Object.keys(customProperties).reduce((customPropertiesJSON, key) => {\n\t\tcustomPropertiesJSON[key] = String(customProperties[key]);\n\n\t\treturn customPropertiesJSON;\n\t}, {});\n};\n\nconst writeFile = (to, text) => new Promise((resolve, reject) => {\n\tfs.writeFile(to, text, error => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve();\n\t\t}\n\t});\n});\n\nconst escapeForJS = string => string.replace(/\\\\([\\s\\S])|(')/g, '\\\\$1$2').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n","import postcss from 'postcss';\nimport getCustomPropertiesFromRoot from './lib/get-custom-properties-from-root';\nimport getCustomPropertiesFromImports from './lib/get-custom-properties-from-imports';\nimport transformProperties from './lib/transform-properties';\nimport writeCustomPropertiesToExports from './lib/write-custom-properties-to-exports';\n\nexport default postcss.plugin('postcss-custom-properties', opts => {\n\t// whether to preserve custom selectors and rules using them\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;\n\n\t// sources to import custom selectors from\n\tconst importFrom = [].concat(Object(opts).importFrom || []);\n\n\t// destinations to export custom selectors to\n\tconst exportTo = [].concat(Object(opts).exportTo || []);\n\n\t// promise any custom selectors are imported\n\tconst customPropertiesPromise = getCustomPropertiesFromImports(importFrom);\n\n\t// synchronous transform\n\tconst syncTransform = root => {\n\t\tconst customProperties = getCustomPropertiesFromRoot(root, { preserve });\n\n\t\ttransformProperties(root, customProperties, { preserve });\n\t};\n\n\t// asynchronous transform\n\tconst asyncTransform = async root => {\n\t\tconst customProperties = Object.assign(\n\t\t\t{},\n\t\t\tawait customPropertiesPromise,\n\t\t\tgetCustomPropertiesFromRoot(root, { preserve })\n\t\t);\n\n\t\tawait writeCustomPropertiesToExports(customProperties, exportTo);\n\n\t\ttransformProperties(root, customProperties, { preserve });\n\t};\n\n\t// whether to return synchronous function if no asynchronous operations are requested\n\tconst canReturnSyncFunction = importFrom.length === 0 && exportTo.length === 0;\n\n\treturn canReturnSyncFunction ? syncTransform : asyncTransform;\n});\n"]},"metadata":{},"sourceType":"script"}