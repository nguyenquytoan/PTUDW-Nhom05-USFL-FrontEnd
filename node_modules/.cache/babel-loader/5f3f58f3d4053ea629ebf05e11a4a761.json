{"ast":null,"code":"/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\n\n\nfunction escape(s) {\n  return `(?:${lodash.escapeRegExp(s)})`;\n}\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\n\n\nfunction escapeAndRepeat(s) {\n  return `${escape(s)}+`;\n}\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\n\n\nfunction parseMarkersOption(markers) {\n  // `*` is a marker for JSDoc comments.\n  if (markers.indexOf(\"*\") === -1) {\n    return markers.concat(\"*\");\n  }\n\n  return markers;\n}\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\n\n\nfunction createExceptionsPattern(exceptions) {\n  let pattern = \"\";\n  /*\n   * A space or an exception pattern sequence.\n   * []                 ==> \"\\s\"\n   * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n   * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n   * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n   */\n\n  if (exceptions.length === 0) {\n    // a space.\n    pattern += \"\\\\s\";\n  } else {\n    // a space or...\n    pattern += \"(?:\\\\s|\";\n\n    if (exceptions.length === 1) {\n      // a sequence of the exception pattern.\n      pattern += escapeAndRepeat(exceptions[0]);\n    } else {\n      // a sequence of one of the exception patterns.\n      pattern += \"(?:\";\n      pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n      pattern += \")\";\n    }\n\n    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n  }\n\n  return pattern;\n}\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\n\n\nfunction createAlwaysStylePattern(markers, exceptions) {\n  let pattern = \"^\";\n  /*\n   * A marker or nothing.\n   * [\"*\"]            ==> \"\\*?\"\n   * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n   * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n   */\n\n  if (markers.length === 1) {\n    // the marker.\n    pattern += escape(markers[0]);\n  } else {\n    // one of markers.\n    pattern += \"(?:\";\n    pattern += markers.map(escape).join(\"|\");\n    pattern += \")\";\n  }\n\n  pattern += \"?\"; // or nothing.\n\n  pattern += createExceptionsPattern(exceptions);\n  return new RegExp(pattern, \"u\");\n}\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\n\n\nfunction createNeverStylePattern(markers) {\n  const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n  return new RegExp(pattern, \"u\");\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/spaced-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        markers: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        line: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            }\n          },\n          additionalProperties: false\n        },\n        block: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            balanced: {\n              type: \"boolean\",\n              default: false\n            }\n          },\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Unless the first option is never, require a space\n\n    const requireSpace = context.options[0] !== \"never\";\n    /*\n     * Parse the second options.\n     * If markers don't include `\"*\"`, it's added automatically for JSDoc\n     * comments.\n     */\n\n    const config = context.options[1] || {};\n    const balanced = config.block && config.block.balanced;\n    const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n      const endNeverPattern = \"[ \\t]+$\"; // Create RegExp object for valid patterns.\n\n      rule[type] = {\n        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n        hasExceptions: exceptions.length > 0,\n        captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n        markers: new Set(markers)\n      };\n      return rule;\n    }, {});\n    /**\n     * Reports a beginning spacing error with an appropriate message.\n     * @param {ASTNode} node A comment node to check.\n     * @param {string} message An error message to report.\n     * @param {Array} match An array of match results for markers.\n     * @param {string} refChar Character used for reference in the error message.\n     * @returns {void}\n     */\n\n    function reportBegin(node, message, match, refChar) {\n      const type = node.type.toLowerCase(),\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n      context.report({\n        node,\n\n        fix(fixer) {\n          const start = node.range[0];\n          let end = start + 2;\n\n          if (requireSpace) {\n            if (match) {\n              end += match[0].length;\n            }\n\n            return fixer.insertTextAfterRange([start, end], \" \");\n          }\n\n          end += match[0].length;\n          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n        },\n\n        message,\n        data: {\n          refChar\n        }\n      });\n    }\n    /**\n     * Reports an ending spacing error with an appropriate message.\n     * @param {ASTNode} node A comment node to check.\n     * @param {string} message An error message to report.\n     * @param {string} match An array of the matched whitespace characters.\n     * @returns {void}\n     */\n\n\n    function reportEnd(node, message, match) {\n      context.report({\n        node,\n\n        fix(fixer) {\n          if (requireSpace) {\n            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n          }\n\n          const end = node.range[1] - 2,\n                start = end - match[0].length;\n          return fixer.replaceTextRange([start, end], \"\");\n        },\n\n        message\n      });\n    }\n    /**\n     * Reports a given comment if it's invalid.\n     * @param {ASTNode} node a comment node to check.\n     * @returns {void}\n     */\n\n\n    function checkCommentForSpace(node) {\n      const type = node.type.toLowerCase(),\n            rule = styleRules[type],\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\"; // Ignores empty comments and comments that consist only of a marker.\n\n      if (node.value.length === 0 || rule.markers.has(node.value)) {\n        return;\n      }\n\n      const beginMatch = rule.beginRegex.exec(node.value);\n      const endMatch = rule.endRegex.exec(node.value); // Checks.\n\n      if (requireSpace) {\n        if (!beginMatch) {\n          const hasMarker = rule.captureMarker.exec(node.value);\n          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n          if (rule.hasExceptions) {\n            reportBegin(node, \"Expected exception block, space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n          } else {\n            reportBegin(node, \"Expected space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n          }\n        }\n\n        if (balanced && type === \"block\" && !endMatch) {\n          reportEnd(node, \"Expected space or tab before '*/' in comment.\");\n        }\n      } else {\n        if (beginMatch) {\n          if (!beginMatch[1]) {\n            reportBegin(node, \"Unexpected space or tab after '{{refChar}}' in comment.\", beginMatch, commentIdentifier);\n          } else {\n            reportBegin(node, \"Unexpected space or tab after marker ({{refChar}}) in comment.\", beginMatch, beginMatch[1]);\n          }\n        }\n\n        if (balanced && type === \"block\" && endMatch) {\n          reportEnd(node, \"Unexpected space or tab before '*/' in comment.\", endMatch);\n        }\n      }\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/spaced-comment.js"],"names":["lodash","require","astUtils","escape","s","escapeRegExp","escapeAndRepeat","parseMarkersOption","markers","indexOf","concat","createExceptionsPattern","exceptions","pattern","length","map","join","Array","from","LINEBREAKS","createAlwaysStylePattern","RegExp","createNeverStylePattern","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","enum","properties","items","line","additionalProperties","block","balanced","default","create","context","sourceCode","getSourceCode","requireSpace","options","config","styleRules","reduce","rule","endNeverPattern","beginRegex","endRegex","hasExceptions","captureMarker","Set","reportBegin","node","message","match","refChar","toLowerCase","commentIdentifier","report","fix","fixer","start","range","end","insertTextAfterRange","replaceTextRange","data","reportEnd","checkCommentForSpace","value","has","beginMatch","exec","endMatch","hasMarker","marker","Program","comments","getAllComments","filter","token","forEach"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    return `(?:${lodash.escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        return markers.concat(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern, \"u\");\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern, \"u\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/spaced-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n                hasExceptions: exceptions.length > 0,\n                captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n                markers: new Set(markers)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} message An error message to report.\n         * @param {Array} match An array of match results for markers.\n         * @param {string} refChar Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, message, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                message,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} message An error message to report.\n         * @param {string} match An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, message, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                message\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments and comments that consist only of a marker.\n            if (node.value.length === 0 || rule.markers.has(node.value)) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.captureMarker.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"Expected exception block, space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"Expected space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"Expected space or tab before '*/' in comment.\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"Unexpected space or tab after '{{refChar}}' in comment.\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"Unexpected space or tab after marker ({{refChar}}) in comment.\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"Unexpected space or tab before '*/' in comment.\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}