{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar parser = _interopDefault(require('postcss-values-parser'));\n\nvar fs = _interopDefault(require('fs'));\n\nvar path = _interopDefault(require('path'));\n\nvar postcss = _interopDefault(require('postcss'));\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst dashedMatch = /^--/; // returns the value of a css function as a string\n\nvar getFnValue = node => {\n  const value = String(node.nodes.slice(1, -1));\n  return dashedMatch.test(value) ? value : undefined;\n};\n\nvar updateEnvValue = (node, variables) => {\n  // get the value of a css function as a string\n  const value = getFnValue(node);\n\n  if (typeof value === 'string' && value in variables) {\n    node.replaceWith(...asClonedArrayWithBeforeSpacing(variables[value], node.raws.before));\n  }\n}; // return an array with its nodes cloned, preserving the raw\n\n\nconst asClonedArrayWithBeforeSpacing = (array, beforeSpacing) => {\n  const clonedArray = asClonedArray(array, null);\n\n  if (clonedArray[0]) {\n    clonedArray[0].raws.before = beforeSpacing;\n  }\n\n  return clonedArray;\n}; // return an array with its nodes cloned\n\n\nconst asClonedArray = (array, parent) => array.map(node => asClonedNode(node, parent)); // return a cloned node\n\n\nconst asClonedNode = (node, parent) => {\n  const cloneNode = new node.constructor(node);\n\n  for (const key in node) {\n    if (key === 'parent') {\n      cloneNode.parent = parent;\n    } else if (Object(node[key]).constructor === Array) {\n      cloneNode[key] = asClonedArray(node.nodes, cloneNode);\n    } else if (Object(node[key]).constructor === Object) {\n      cloneNode[key] = Object.assign({}, node[key]);\n    }\n  }\n\n  return cloneNode;\n}; // returns whether a node is a css env() function\n\n\nvar isEnvFunc = node => node && node.type === 'func' && node.value === 'env';\n\nfunction walk(node, fn) {\n  node.nodes.slice(0).forEach(childNode => {\n    if (childNode.nodes) {\n      walk(childNode, fn);\n    }\n\n    if (isEnvFunc(childNode)) {\n      fn(childNode);\n    }\n  });\n}\n\nvar getReplacedValue = (originalValue, variables) => {\n  // get the ast of the original value\n  const ast = parser(originalValue).parse(); // walk all of the css env() functions\n\n  walk(ast, node => {\n    // update the environment value for the css env() function\n    updateEnvValue(node, variables);\n  }); // return the stringified ast\n\n  return String(ast);\n}; // returns whether a node is an at-rule\n\n\nvar isAtrule = node => node && node.type === 'atrule'; // returns whether a node is a declaration\n\n\nvar isDecl = node => node && node.type === 'decl';\n\nvar getSupportedValue = node => isAtrule(node) && node.params || isDecl(node) && node.value;\n\nfunction setSupportedValue(node, value) {\n  if (isAtrule(node)) {\n    node.params = value;\n  }\n\n  if (isDecl(node)) {\n    node.value = value;\n  }\n}\n/* Import Custom Properties from Object\n/* ========================================================================== */\n\n\nfunction importEnvironmentVariablesFromObject(object) {\n  const environmentVariables = Object.assign({}, Object(object).environmentVariables || Object(object)['environment-variables']);\n\n  for (const key in environmentVariables) {\n    environmentVariables[key] = parser(environmentVariables[key]).parse().nodes;\n  }\n\n  return environmentVariables;\n}\n/* Import Custom Properties from JSON file\n/* ========================================================================== */\n\n\nfunction importEnvironmentVariablesFromJSONFile(_x) {\n  return _importEnvironmentVariablesFromJSONFile.apply(this, arguments);\n}\n/* Import Custom Properties from JS file\n/* ========================================================================== */\n\n\nfunction _importEnvironmentVariablesFromJSONFile() {\n  _importEnvironmentVariablesFromJSONFile = _asyncToGenerator(function* (from) {\n    const object = yield readJSON(path.resolve(from));\n    return importEnvironmentVariablesFromObject(object);\n  });\n  return _importEnvironmentVariablesFromJSONFile.apply(this, arguments);\n}\n\nfunction importEnvironmentVariablesFromJSFile(_x2) {\n  return _importEnvironmentVariablesFromJSFile.apply(this, arguments);\n}\n/* Import Custom Properties from Sources\n/* ========================================================================== */\n\n\nfunction _importEnvironmentVariablesFromJSFile() {\n  _importEnvironmentVariablesFromJSFile = _asyncToGenerator(function* (from) {\n    const object = yield Promise.resolve(require(path.resolve(from)));\n    return importEnvironmentVariablesFromObject(object);\n  });\n  return _importEnvironmentVariablesFromJSFile.apply(this, arguments);\n}\n\nfunction importEnvironmentVariablesFromSources(sources) {\n  return sources.map(source => {\n    if (source instanceof Promise) {\n      return source;\n    } else if (source instanceof Function) {\n      return source();\n    } // read the source as an object\n\n\n    const opts = source === Object(source) ? source : {\n      from: String(source)\n    }; // skip objects with Custom Properties\n\n    if (opts.environmentVariables || opts['environment-variables']) {\n      return opts;\n    } // source pathname\n\n\n    const from = String(opts.from || ''); // type of file being read from\n\n    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n    return {\n      type,\n      from\n    };\n  }).reduce( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (environmentVariables, source) {\n      const _ref2 = yield source,\n            type = _ref2.type,\n            from = _ref2.from;\n\n      if (type === 'js') {\n        return Object.assign(environmentVariables, yield importEnvironmentVariablesFromJSFile(from));\n      }\n\n      if (type === 'json') {\n        return Object.assign(environmentVariables, yield importEnvironmentVariablesFromJSONFile(from));\n      }\n\n      return Object.assign(environmentVariables, importEnvironmentVariablesFromObject(yield source));\n    });\n\n    return function (_x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {});\n}\n/* Helper utilities\n/* ========================================================================== */\n\n\nconst readFile = from => new Promise((resolve, reject) => {\n  fs.readFile(from, 'utf8', (error, result) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst readJSON = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (from) {\n    return JSON.parse(yield readFile(from));\n  });\n\n  return function readJSON(_x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar index = postcss.plugin('postcss-env-fn', opts => {\n  // sources to import environment variables from\n  const importFrom = [].concat(Object(opts).importFrom || []); // promise any environment variables are imported\n\n  const environmentVariablesPromise = importEnvironmentVariablesFromSources(importFrom);\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (root) {\n      const environmentVariables = yield environmentVariablesPromise;\n      root.walk(node => {\n        const supportedValue = getSupportedValue(node);\n\n        if (supportedValue) {\n          const replacedValue = getReplacedValue(supportedValue, environmentVariables);\n\n          if (replacedValue !== supportedValue) {\n            setSupportedValue(node, replacedValue);\n          }\n        }\n      });\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n});\nmodule.exports = index;","map":{"version":3,"sources":["lib/get-fn-value.js","lib/update-env-value.js","lib/is-env-func.js","lib/walk-env-funcs.js","lib/get-replaced-value.js","lib/is-atrule.js","lib/is-decl.js","lib/get-supported-value.js","lib/set-supported-value.js","lib/import-from.js","index.js"],"names":["dashedMatch","node","value","String","getFnValue","asClonedArrayWithBeforeSpacing","variables","clonedArray","asClonedArray","array","asClonedNode","cloneNode","key","Object","childNode","walk","isEnvFunc","fn","ast","parser","walkEnvFuncs","updateEnvValue","isAtrule","isDecl","environmentVariables","valueParser","importEnvironmentVariablesFromJSONFile","object","readJSON","path","importEnvironmentVariablesFromObject","importEnvironmentVariablesFromJSFile","source","opts","from","type","readFile","fs","reject","resolve","JSON","importFrom","environmentVariablesPromise","importEnvironmentVariablesFromSources","root","supportedValue","getSupportedValue","replacedValue","getReplacedValue","setSupportedValue"],"mappings":"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","sourcesContent":["const dashedMatch = /^--/;\n\n// returns the value of a css function as a string\nexport default (node) => {\n\tconst value = String(node.nodes.slice(1, -1));\n\n\treturn dashedMatch.test(value) ? value : undefined;\n};\n","import getFnValue from './get-fn-value';\n\n// update a node with an environment value\nexport default (node, variables) => {\n\t// get the value of a css function as a string\n\tconst value = getFnValue(node);\n\n\tif (typeof value === 'string' && value in variables) {\n\t\tnode.replaceWith(\n\t\t\t...asClonedArrayWithBeforeSpacing(variables[value], node.raws.before)\n\t\t);\n\t}\n};\n\n// return an array with its nodes cloned, preserving the raw\nconst asClonedArrayWithBeforeSpacing = (array, beforeSpacing) => {\n\tconst clonedArray = asClonedArray(array, null);\n\n\tif (clonedArray[0]) {\n\t\tclonedArray[0].raws.before = beforeSpacing;\n\t}\n\n\treturn clonedArray;\n};\n\n// return an array with its nodes cloned\nconst asClonedArray = (array, parent) => array.map(node => asClonedNode(node, parent));\n\n// return a cloned node\nconst asClonedNode = (node, parent) => {\n\tconst cloneNode = new node.constructor(node);\n\n\tfor (const key in node) {\n\t\tif (key === 'parent') {\n\t\t\tcloneNode.parent = parent;\n\t\t} else if (Object(node[key]).constructor === Array) {\n\t\t\tcloneNode[key] = asClonedArray(node.nodes, cloneNode);\n\t\t} else if (Object(node[key]).constructor === Object) {\n\t\t\tcloneNode[key] = Object.assign({}, node[key]);\n\t\t}\n\t}\n\n\treturn cloneNode;\n};\n","// returns whether a node is a css env() function\nexport default (node) => node && node.type === 'func' && node.value === 'env';\n","import isEnvFunc from './is-env-func';\n\n// walks a node recursively and runs a function using its children\nexport default function walk(node, fn) {\n\tnode.nodes.slice(0).forEach(childNode => {\n\t\tif (childNode.nodes) {\n\t\t\twalk(childNode, fn);\n\t\t}\n\n\t\tif (isEnvFunc(childNode)) {\n\t\t\tfn(childNode);\n\t\t}\n\t});\n}\n","import parser from 'postcss-values-parser';\nimport updateEnvValue from './update-env-value';\nimport walkEnvFuncs from './walk-env-funcs';\n\n// returns a value replaced with environment variables\nexport default (originalValue, variables) => {\n\t// get the ast of the original value\n\tconst ast = parser(originalValue).parse();\n\n\t// walk all of the css env() functions\n\twalkEnvFuncs(ast, node => {\n\t\t// update the environment value for the css env() function\n\t\tupdateEnvValue(node, variables);\n\t});\n\n\t// return the stringified ast\n\treturn String(ast);\n};\n","// returns whether a node is an at-rule\nexport default (node) => node && node.type === 'atrule';\n","// returns whether a node is a declaration\nexport default (node) => node && node.type === 'decl';\n","import isAtrule from './is-atrule';\nimport isDecl from './is-decl';\n\n// returns a value from an at-rule or declaration\nexport default (node) => isAtrule(node) && node.params || isDecl(node) && node.value;\n","import isAtrule from './is-atrule';\nimport isDecl from './is-decl';\n\n// assigns a value to an at-rule or declaration\nexport default function (node, value) {\n\tif (isAtrule(node)) {\n\t\tnode.params = value;\n\t}\n\n\tif (isDecl(node)) {\n\t\tnode.value = value;\n\t}\n}\n","import fs from 'fs';\nimport path from 'path';\nimport valueParser from 'postcss-values-parser';\n\n/* Import Custom Properties from Object\n/* ========================================================================== */\n\nfunction importEnvironmentVariablesFromObject(object) {\n\tconst environmentVariables = Object.assign(\n\t\t{},\n\t\tObject(object).environmentVariables || Object(object)['environment-variables']\n\t);\n\n\tfor (const key in environmentVariables) {\n\t\tenvironmentVariables[key] = valueParser(environmentVariables[key]).parse().nodes;\n\t}\n\n\treturn environmentVariables;\n}\n\n/* Import Custom Properties from JSON file\n/* ========================================================================== */\n\nasync function importEnvironmentVariablesFromJSONFile(from) {\n\tconst object = await readJSON(path.resolve(from));\n\n\treturn importEnvironmentVariablesFromObject(object);\n}\n\n/* Import Custom Properties from JS file\n/* ========================================================================== */\n\nasync function importEnvironmentVariablesFromJSFile(from) {\n\tconst object = await import(path.resolve(from));\n\n\treturn importEnvironmentVariablesFromObject(object);\n}\n\n/* Import Custom Properties from Sources\n/* ========================================================================== */\n\nexport default function importEnvironmentVariablesFromSources(sources) {\n\treturn sources.map(source => {\n\t\tif (source instanceof Promise) {\n\t\t\treturn source;\n\t\t} else if (source instanceof Function) {\n\t\t\treturn source();\n\t\t}\n\n\t\t// read the source as an object\n\t\tconst opts = source === Object(source) ? source : { from: String(source) };\n\n\t\t// skip objects with Custom Properties\n\t\tif (opts.environmentVariables || opts['environment-variables']) {\n\t\t\treturn opts\n\t\t}\n\n\t\t// source pathname\n\t\tconst from = String(opts.from || '');\n\n\t\t// type of file being read from\n\t\tconst type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n\n\t\treturn { type, from };\n\t}).reduce(async (environmentVariables, source) => {\n\t\tconst { type, from } = await source;\n\n\t\tif (type === 'js') {\n\t\t\treturn Object.assign(environmentVariables, await importEnvironmentVariablesFromJSFile(from));\n\t\t}\n\n\t\tif (type === 'json') {\n\t\t\treturn Object.assign(environmentVariables, await importEnvironmentVariablesFromJSONFile(from));\n\t\t}\n\n\t\treturn Object.assign(environmentVariables, importEnvironmentVariablesFromObject(await source));\n\t}, {});\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst readFile = from => new Promise((resolve, reject) => {\n\tfs.readFile(from, 'utf8', (error, result) => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n});\n\nconst readJSON = async from => JSON.parse(await readFile(from));\n","import postcss from 'postcss';\nimport getReplacedValue from './lib/get-replaced-value';\nimport getSupportedValue from './lib/get-supported-value';\nimport setSupportedValue from './lib/set-supported-value';\nimport importEnvironmentVariablesFromSources from './lib/import-from';\n\nexport default postcss.plugin('postcss-env-fn', opts => {\n\t// sources to import environment variables from\n\tconst importFrom = [].concat(Object(opts).importFrom || []);\n\n\t// promise any environment variables are imported\n\tconst environmentVariablesPromise = importEnvironmentVariablesFromSources(importFrom);\n\n\treturn async root => {\n\t\tconst environmentVariables = await environmentVariablesPromise;\n\n\t\troot.walk(node => {\n\t\t\tconst supportedValue = getSupportedValue(node);\n\n\t\t\tif (supportedValue) {\n\t\t\t\tconst replacedValue = getReplacedValue(supportedValue, environmentVariables);\n\n\t\t\t\tif (replacedValue !== supportedValue) {\n\t\t\t\t\tsetSupportedValue(node, replacedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n"]},"metadata":{},"sourceType":"script"}