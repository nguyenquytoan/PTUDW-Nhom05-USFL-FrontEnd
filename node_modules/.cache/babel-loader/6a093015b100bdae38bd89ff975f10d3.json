{"ast":null,"code":"/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst globals = require(\"globals\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst propertyDefinitionMethods = new Set([\"defineProperty\", \"defineProperties\"]); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow extending native types\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extend-native\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const exceptions = new Set(config.exceptions || []);\n    const modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));\n    /**\n     * Reports a lint error for the given node.\n     * @param {ASTNode} node The node to report.\n     * @param {string} builtin The name of the native builtin being extended.\n     * @returns {void}\n     */\n\n    function reportNode(node, builtin) {\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        data: {\n          builtin\n        }\n      });\n    }\n    /**\n     * Check to see if the `prototype` property of the given object\n     * identifier node is being accessed.\n     * @param {ASTNode} identifierNode The Identifier representing the object\n     * to check.\n     * @returns {boolean} True if the identifier is the object of a\n     * MemberExpression and its `prototype` property is being accessed,\n     * false otherwise.\n     */\n\n\n    function isPrototypePropertyAccessed(identifierNode) {\n      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === \"MemberExpression\" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\");\n    }\n    /**\n     * Checks that an identifier is an object of a prototype whose member\n     * is being assigned in an AssignmentExpression.\n     * Example: Object.prototype.foo = \"bar\"\n     * @param {ASTNode} identifierNode The identifier to check.\n     * @returns {boolean} True if the identifier's prototype is modified.\n     */\n\n\n    function isInPrototypePropertyAssignment(identifierNode) {\n      return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === \"MemberExpression\" && identifierNode.parent.parent.parent.type === \"AssignmentExpression\" && identifierNode.parent.parent.parent.left === identifierNode.parent.parent);\n    }\n    /**\n     * Checks that an identifier is an object of a prototype whose member\n     * is being extended via the Object.defineProperty() or\n     * Object.defineProperties() methods.\n     * Example: Object.defineProperty(Array.prototype, \"foo\", ...)\n     * Example: Object.defineProperties(Array.prototype, ...)\n     * @param {ASTNode} identifierNode The identifier to check.\n     * @returns {boolean} True if the identifier's prototype is modified.\n     */\n\n\n    function isInDefinePropertyCall(identifierNode) {\n      return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === \"CallExpression\" && identifierNode.parent.parent.arguments[0] === identifierNode.parent && identifierNode.parent.parent.callee.type === \"MemberExpression\" && identifierNode.parent.parent.callee.object.type === \"Identifier\" && identifierNode.parent.parent.callee.object.name === \"Object\" && identifierNode.parent.parent.callee.property.type === \"Identifier\" && propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name));\n    }\n    /**\n     * Check to see if object prototype access is part of a prototype\n     * extension. There are three ways a prototype can be extended:\n     * 1. Assignment to prototype property (Object.prototype.foo = 1)\n     * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n     * If prototype extension is detected, report the AssignmentExpression\n     * or CallExpression node.\n     * @param {ASTNode} identifierNode The Identifier representing the object\n     * which prototype is being accessed and possibly extended.\n     * @returns {void}\n     */\n\n\n    function checkAndReportPrototypeExtension(identifierNode) {\n      if (isInPrototypePropertyAssignment(identifierNode)) {\n        // Identifier --> MemberExpression --> MemberExpression --> AssignmentExpression\n        reportNode(identifierNode.parent.parent.parent, identifierNode.name);\n      } else if (isInDefinePropertyCall(identifierNode)) {\n        // Identifier --> MemberExpression --> CallExpression\n        reportNode(identifierNode.parent.parent, identifierNode.name);\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        modifiedBuiltins.forEach(builtin => {\n          const builtinVar = globalScope.set.get(builtin);\n\n          if (builtinVar && builtinVar.references) {\n            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);\n          }\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-extend-native.js"],"names":["astUtils","require","globals","propertyDefinitionMethods","Set","module","exports","meta","type","docs","description","category","recommended","url","schema","properties","exceptions","items","uniqueItems","additionalProperties","messages","unexpected","create","context","config","options","modifiedBuiltins","Object","keys","builtin","filter","toUpperCase","has","reportNode","node","report","messageId","data","isPrototypePropertyAccessed","identifierNode","Boolean","parent","object","getStaticPropertyName","isInPrototypePropertyAssignment","left","isInDefinePropertyCall","arguments","callee","name","property","checkAndReportPrototypeExtension","globalScope","getScope","forEach","builtinVar","set","get","references","map","ref","identifier"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst propertyDefinitionMethods = new Set([\"defineProperty\", \"defineProperties\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extend-native\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = new Set(config.exceptions || []);\n        const modifiedBuiltins = new Set(\n            Object.keys(globals.builtin)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Checks that an identifier is an object of a prototype whose member\n         * is being assigned in an AssignmentExpression.\n         * Example: Object.prototype.foo = \"bar\"\n         * @param {ASTNode} identifierNode The identifier to check.\n         * @returns {boolean} True if the identifier's prototype is modified.\n         */\n        function isInPrototypePropertyAssignment(identifierNode) {\n            return Boolean(\n                isPrototypePropertyAccessed(identifierNode) &&\n                identifierNode.parent.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.parent.parent.type === \"AssignmentExpression\" &&\n                identifierNode.parent.parent.parent.left === identifierNode.parent.parent\n            );\n        }\n\n        /**\n         * Checks that an identifier is an object of a prototype whose member\n         * is being extended via the Object.defineProperty() or\n         * Object.defineProperties() methods.\n         * Example: Object.defineProperty(Array.prototype, \"foo\", ...)\n         * Example: Object.defineProperties(Array.prototype, ...)\n         * @param {ASTNode} identifierNode The identifier to check.\n         * @returns {boolean} True if the identifier's prototype is modified.\n         */\n        function isInDefinePropertyCall(identifierNode) {\n            return Boolean(\n                isPrototypePropertyAccessed(identifierNode) &&\n                identifierNode.parent.parent.type === \"CallExpression\" &&\n                identifierNode.parent.parent.arguments[0] === identifierNode.parent &&\n                identifierNode.parent.parent.callee.type === \"MemberExpression\" &&\n                identifierNode.parent.parent.callee.object.type === \"Identifier\" &&\n                identifierNode.parent.parent.callee.object.name === \"Object\" &&\n                identifierNode.parent.parent.callee.property.type === \"Identifier\" &&\n                propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (isInPrototypePropertyAssignment(identifierNode)) {\n\n                // Identifier --> MemberExpression --> MemberExpression --> AssignmentExpression\n                reportNode(identifierNode.parent.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(identifierNode)) {\n\n                // Identifier --> MemberExpression --> CallExpression\n                reportNode(identifierNode.parent.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}