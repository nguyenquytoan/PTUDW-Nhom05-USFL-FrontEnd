{"ast":null,"code":"/**\n * @fileoverview Validates newlines before and after dots\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent newlines before and after dots\",\n      category: \"Best Practices\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-location\"\n    },\n    schema: [{\n      enum: [\"object\", \"property\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      expectedDotAfterObject: \"Expected dot to be on same line as object.\",\n      expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0]; // default to onObject if no preference is passed\n\n    const onObject = config === \"object\" || !config;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Reports if the dot between object and property is on the correct loccation.\n     * @param {ASTNode} node The `MemberExpression` node.\n     * @returns {void}\n     */\n\n    function checkDotLocation(node) {\n      const property = node.property;\n      const dot = sourceCode.getTokenBefore(property); // `obj` expression can be parenthesized, but those paren tokens are not a part of the `obj` node.\n\n      const tokenBeforeDot = sourceCode.getTokenBefore(dot);\n      const textBeforeDot = sourceCode.getText().slice(tokenBeforeDot.range[1], dot.range[0]);\n      const textAfterDot = sourceCode.getText().slice(dot.range[1], property.range[0]);\n\n      if (onObject) {\n        if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dot)) {\n          const neededTextAfterToken = astUtils.isDecimalIntegerNumericToken(tokenBeforeDot) ? \" \" : \"\";\n          context.report({\n            node,\n            loc: dot.loc,\n            messageId: \"expectedDotAfterObject\",\n            fix: fixer => fixer.replaceTextRange([tokenBeforeDot.range[1], property.range[0]], `${neededTextAfterToken}.${textBeforeDot}${textAfterDot}`)\n          });\n        }\n      } else if (!astUtils.isTokenOnSameLine(dot, property)) {\n        context.report({\n          node,\n          loc: dot.loc,\n          messageId: \"expectedDotBeforeProperty\",\n          fix: fixer => fixer.replaceTextRange([tokenBeforeDot.range[1], property.range[0]], `${textBeforeDot}${textAfterDot}.`)\n        });\n      }\n    }\n    /**\n     * Checks the spacing of the dot within a member expression.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n\n    function checkNode(node) {\n      if (!node.computed) {\n        checkDotLocation(node);\n      }\n    }\n\n    return {\n      MemberExpression: checkNode\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/dot-location.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","enum","fixable","messages","expectedDotAfterObject","expectedDotBeforeProperty","create","context","config","options","onObject","sourceCode","getSourceCode","checkDotLocation","node","property","dot","getTokenBefore","tokenBeforeDot","textBeforeDot","getText","slice","range","textAfterDot","isTokenOnSameLine","neededTextAfterToken","isDecimalIntegerNumericToken","report","loc","messageId","fix","fixer","replaceTextRange","checkNode","computed","MemberExpression"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Validates newlines before and after dots\n * @author Greg Cochard\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent newlines before and after dots\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-location\"\n        },\n\n        schema: [\n            {\n                enum: [\"object\", \"property\"]\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            expectedDotAfterObject: \"Expected dot to be on same line as object.\",\n            expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n\n        // default to onObject if no preference is passed\n        const onObject = config === \"object\" || !config;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if the dot between object and property is on the correct loccation.\n         * @param {ASTNode} node The `MemberExpression` node.\n         * @returns {void}\n         */\n        function checkDotLocation(node) {\n            const property = node.property;\n            const dot = sourceCode.getTokenBefore(property);\n\n            // `obj` expression can be parenthesized, but those paren tokens are not a part of the `obj` node.\n            const tokenBeforeDot = sourceCode.getTokenBefore(dot);\n\n            const textBeforeDot = sourceCode.getText().slice(tokenBeforeDot.range[1], dot.range[0]);\n            const textAfterDot = sourceCode.getText().slice(dot.range[1], property.range[0]);\n\n            if (onObject) {\n                if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dot)) {\n                    const neededTextAfterToken = astUtils.isDecimalIntegerNumericToken(tokenBeforeDot) ? \" \" : \"\";\n\n                    context.report({\n                        node,\n                        loc: dot.loc,\n                        messageId: \"expectedDotAfterObject\",\n                        fix: fixer => fixer.replaceTextRange([tokenBeforeDot.range[1], property.range[0]], `${neededTextAfterToken}.${textBeforeDot}${textAfterDot}`)\n                    });\n                }\n            } else if (!astUtils.isTokenOnSameLine(dot, property)) {\n                context.report({\n                    node,\n                    loc: dot.loc,\n                    messageId: \"expectedDotBeforeProperty\",\n                    fix: fixer => fixer.replaceTextRange([tokenBeforeDot.range[1], property.range[0]], `${textBeforeDot}${textAfterDot}.`)\n                });\n            }\n        }\n\n        /**\n         * Checks the spacing of the dot within a member expression.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            if (!node.computed) {\n                checkDotLocation(node);\n            }\n        }\n\n        return {\n            MemberExpression: checkNode\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}