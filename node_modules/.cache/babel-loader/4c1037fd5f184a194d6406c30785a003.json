{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { DBWrapper } from 'workbox-core/_private/DBWrapper.mjs';\nimport '../_version.mjs';\nconst DB_VERSION = 3;\nconst DB_NAME = 'workbox-background-sync';\nconst OBJECT_STORE_NAME = 'requests';\nconst INDEXED_PROP = 'queueName';\n/**\n * A class to manage storing requests from a Queue in IndexedbDB,\n * indexed by their queue name for easier access.\n *\n * @private\n */\n\nexport class QueueStore {\n  /**\n   * Associates this instance with a Queue instance, so entries added can be\n   * identified by their queue name.\n   *\n   * @param {string} queueName\n   * @private\n   */\n  constructor(queueName) {\n    this._queueName = queueName;\n    this._db = new DBWrapper(DB_NAME, DB_VERSION, {\n      onupgradeneeded: this._upgradeDb\n    });\n  }\n  /**\n   * Append an entry last in the queue.\n   *\n   * @param {Object} entry\n   * @param {Object} entry.requestData\n   * @param {number} [entry.timestamp]\n   * @param {Object} [entry.metadata]\n   * @private\n   */\n\n\n  async pushEntry(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'pushEntry',\n        paramName: 'entry'\n      });\n      assert.isType(entry.requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'pushEntry',\n        paramName: 'entry.requestData'\n      });\n    } // Don't specify an ID since one is automatically generated.\n\n\n    delete entry.id;\n    entry.queueName = this._queueName;\n    await this._db.add(OBJECT_STORE_NAME, entry);\n  }\n  /**\n   * Preppend an entry first in the queue.\n   *\n   * @param {Object} entry\n   * @param {Object} entry.requestData\n   * @param {number} [entry.timestamp]\n   * @param {Object} [entry.metadata]\n   * @private\n   */\n\n\n  async unshiftEntry(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'unshiftEntry',\n        paramName: 'entry'\n      });\n      assert.isType(entry.requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'unshiftEntry',\n        paramName: 'entry.requestData'\n      });\n    }\n\n    const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      count: 1\n    });\n\n    if (firstEntry) {\n      // Pick an ID one less than the lowest ID in the object store.\n      entry.id = firstEntry.id - 1;\n    } else {\n      // Otherwise let the auto-incrementor assign the ID.\n      delete entry.id;\n    }\n\n    entry.queueName = this._queueName;\n    await this._db.add(OBJECT_STORE_NAME, entry);\n  }\n  /**\n   * Removes and returns the last entry in the queue matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n\n\n  async popEntry() {\n    return this._removeEntry({\n      direction: 'prev'\n    });\n  }\n  /**\n   * Removes and returns the first entry in the queue matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n\n\n  async shiftEntry() {\n    return this._removeEntry({\n      direction: 'next'\n    });\n  }\n  /**\n   * Returns all entries in the store matching the `queueName`.\n   *\n   * @param {Object} options See workbox.backgroundSync.Queue~getAll}\n   * @return {Promise<Array<Object>>}\n   * @private\n   */\n\n\n  async getAll() {\n    return await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      index: INDEXED_PROP,\n      query: IDBKeyRange.only(this._queueName)\n    });\n  }\n  /**\n   * Deletes the entry for the given ID.\n   *\n   * WARNING: this method does not ensure the deleted enry belongs to this\n   * queue (i.e. matches the `queueName`). But this limitation is acceptable\n   * as this class is not publicly exposed. An additional check would make\n   * this method slower than it needs to be.\n   *\n   * @private\n   * @param {number} id\n   */\n\n\n  async deleteEntry(id) {\n    await this._db.delete(OBJECT_STORE_NAME, id);\n  }\n  /**\n   * Removes and returns the first or last entry in the queue (based on the\n   * `direction` argument) matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n\n\n  async _removeEntry({\n    direction\n  }) {\n    const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      direction,\n      index: INDEXED_PROP,\n      query: IDBKeyRange.only(this._queueName),\n      count: 1\n    });\n\n    if (entry) {\n      await this.deleteEntry(entry.id);\n      return entry;\n    }\n  }\n  /**\n   * Upgrades the database given an `upgradeneeded` event.\n   *\n   * @param {Event} event\n   * @private\n   */\n\n\n  _upgradeDb(event) {\n    const db = event.target.result;\n\n    if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {\n      if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {\n        db.deleteObjectStore(OBJECT_STORE_NAME);\n      }\n    }\n\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n      autoIncrement: true,\n      keyPath: 'id'\n    });\n    objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {\n      unique: false\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/workbox-background-sync/lib/QueueStore.mjs"],"names":["assert","DBWrapper","DB_VERSION","DB_NAME","OBJECT_STORE_NAME","INDEXED_PROP","QueueStore","constructor","queueName","_queueName","_db","onupgradeneeded","_upgradeDb","pushEntry","entry","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","requestData","id","add","unshiftEntry","firstEntry","getAllMatching","count","popEntry","_removeEntry","direction","shiftEntry","getAll","index","query","IDBKeyRange","only","deleteEntry","delete","event","db","target","result","oldVersion","objectStoreNames","contains","deleteObjectStore","objStore","createObjectStore","autoIncrement","keyPath","createIndex","unique"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport '../_version.mjs';\n\n\nconst DB_VERSION = 3;\nconst DB_NAME = 'workbox-background-sync';\nconst OBJECT_STORE_NAME = 'requests';\nconst INDEXED_PROP = 'queueName';\n\n/**\n * A class to manage storing requests from a Queue in IndexedbDB,\n * indexed by their queue name for easier access.\n *\n * @private\n */\nexport class QueueStore {\n  /**\n   * Associates this instance with a Queue instance, so entries added can be\n   * identified by their queue name.\n   *\n   * @param {string} queueName\n   * @private\n   */\n  constructor(queueName) {\n    this._queueName = queueName;\n    this._db = new DBWrapper(DB_NAME, DB_VERSION, {\n      onupgradeneeded: this._upgradeDb,\n    });\n  }\n\n  /**\n   * Append an entry last in the queue.\n   *\n   * @param {Object} entry\n   * @param {Object} entry.requestData\n   * @param {number} [entry.timestamp]\n   * @param {Object} [entry.metadata]\n   * @private\n   */\n  async pushEntry(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'pushEntry',\n        paramName: 'entry',\n      });\n      assert.isType(entry.requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'pushEntry',\n        paramName: 'entry.requestData',\n      });\n    }\n\n    // Don't specify an ID since one is automatically generated.\n    delete entry.id;\n    entry.queueName = this._queueName;\n\n    await this._db.add(OBJECT_STORE_NAME, entry);\n  }\n\n  /**\n   * Preppend an entry first in the queue.\n   *\n   * @param {Object} entry\n   * @param {Object} entry.requestData\n   * @param {number} [entry.timestamp]\n   * @param {Object} [entry.metadata]\n   * @private\n   */\n  async unshiftEntry(entry) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(entry, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'unshiftEntry',\n        paramName: 'entry',\n      });\n      assert.isType(entry.requestData, 'object', {\n        moduleName: 'workbox-background-sync',\n        className: 'QueueStore',\n        funcName: 'unshiftEntry',\n        paramName: 'entry.requestData',\n      });\n    }\n\n    const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      count: 1,\n    });\n\n    if (firstEntry) {\n      // Pick an ID one less than the lowest ID in the object store.\n      entry.id = firstEntry.id - 1;\n    } else {\n      // Otherwise let the auto-incrementor assign the ID.\n      delete entry.id;\n    }\n    entry.queueName = this._queueName;\n\n    await this._db.add(OBJECT_STORE_NAME, entry);\n  }\n\n  /**\n   * Removes and returns the last entry in the queue matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async popEntry() {\n    return this._removeEntry({direction: 'prev'});\n  }\n\n  /**\n   * Removes and returns the first entry in the queue matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async shiftEntry() {\n    return this._removeEntry({direction: 'next'});\n  }\n\n  /**\n   * Returns all entries in the store matching the `queueName`.\n   *\n   * @param {Object} options See workbox.backgroundSync.Queue~getAll}\n   * @return {Promise<Array<Object>>}\n   * @private\n   */\n  async getAll() {\n    return await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      index: INDEXED_PROP,\n      query: IDBKeyRange.only(this._queueName),\n    });\n  }\n\n  /**\n   * Deletes the entry for the given ID.\n   *\n   * WARNING: this method does not ensure the deleted enry belongs to this\n   * queue (i.e. matches the `queueName`). But this limitation is acceptable\n   * as this class is not publicly exposed. An additional check would make\n   * this method slower than it needs to be.\n   *\n   * @private\n   * @param {number} id\n   */\n  async deleteEntry(id) {\n    await this._db.delete(OBJECT_STORE_NAME, id);\n  }\n\n  /**\n   * Removes and returns the first or last entry in the queue (based on the\n   * `direction` argument) matching the `queueName`.\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async _removeEntry({direction}) {\n    const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n      direction,\n      index: INDEXED_PROP,\n      query: IDBKeyRange.only(this._queueName),\n      count: 1,\n    });\n\n    if (entry) {\n      await this.deleteEntry(entry.id);\n      return entry;\n    }\n  }\n\n  /**\n   * Upgrades the database given an `upgradeneeded` event.\n   *\n   * @param {Event} event\n   * @private\n   */\n  _upgradeDb(event) {\n    const db = event.target.result;\n\n    if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {\n      if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {\n        db.deleteObjectStore(OBJECT_STORE_NAME);\n      }\n    }\n\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n      autoIncrement: true,\n      keyPath: 'id',\n    });\n    objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {unique: false});\n  }\n}\n"]},"metadata":{},"sourceType":"module"}