{"ast":null,"code":"/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto RodrÃ­guez\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require braces around arrow function bodies\",\n      category: \"ECMAScript 6\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-body-style\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            requireReturnForObjectLiteral: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n      unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n      unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n      unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n      expectedBlock: \"Expected block statement surrounding arrow body.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options;\n    const always = options[0] === \"always\";\n    const asNeeded = !options[0] || options[0] === \"as-needed\";\n    const never = options[0] === \"never\";\n    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Checks whether the given node has ASI problem or not.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n     */\n\n    function hasASIProblem(token) {\n      return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n    }\n    /**\n     * Gets the closing parenthesis which is the pair of the given opening parenthesis.\n     * @param {Token} token The opening parenthesis token to get.\n     * @returns {Token} The found closing parenthesis token.\n     */\n\n\n    function findClosingParen(token) {\n      let node = sourceCode.getNodeByRangeIndex(token.range[1]);\n\n      while (!astUtils.isParenthesised(sourceCode, node)) {\n        node = node.parent;\n      }\n\n      return sourceCode.getTokenAfter(node);\n    }\n    /**\n     * Determines whether a arrow function body needs braces\n     * @param {ASTNode} node The arrow function node.\n     * @returns {void}\n     */\n\n\n    function validate(node) {\n      const arrowBody = node.body;\n\n      if (arrowBody.type === \"BlockStatement\") {\n        const blockBody = arrowBody.body;\n\n        if (blockBody.length !== 1 && !never) {\n          return;\n        }\n\n        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" && blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n          return;\n        }\n\n        if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n          let messageId;\n\n          if (blockBody.length === 0) {\n            messageId = \"unexpectedEmptyBlock\";\n          } else if (blockBody.length > 1) {\n            messageId = \"unexpectedOtherBlock\";\n          } else if (blockBody[0].argument === null) {\n            messageId = \"unexpectedSingleBlock\";\n          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {\n            skip: 1\n          }))) {\n            messageId = \"unexpectedObjectBlock\";\n          } else {\n            messageId = \"unexpectedSingleBlock\";\n          }\n\n          context.report({\n            node,\n            loc: arrowBody.loc.start,\n            messageId,\n\n            fix(fixer) {\n              const fixes = [];\n\n              if (blockBody.length !== 1 || blockBody[0].type !== \"ReturnStatement\" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {\n                return fixes;\n              }\n\n              const openingBrace = sourceCode.getFirstToken(arrowBody);\n              const closingBrace = sourceCode.getLastToken(arrowBody);\n              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n              const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n              /*\n               * Remove tokens around the return value.\n               * If comments don't exist, remove extra spaces as well.\n               */\n\n              if (commentsExist) {\n                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                );\n              } else {\n                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));\n              }\n              /*\n               * If the first token of the reutrn value is `{` or the return value is a sequence expression,\n               * enclose the return value by parentheses to avoid syntax error.\n               */\n\n\n              if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\") {\n                fixes.push(fixer.insertTextBefore(firstValueToken, \"(\"), fixer.insertTextAfter(lastValueToken, \")\"));\n              }\n              /*\n               * If the last token of the return statement is semicolon, remove it.\n               * Non-block arrow body is an expression, not a statement.\n               */\n\n\n              if (astUtils.isSemicolonToken(lastValueToken)) {\n                fixes.push(fixer.remove(lastValueToken));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      } else {\n        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\") {\n          context.report({\n            node,\n            loc: arrowBody.loc.start,\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const fixes = [];\n              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n              const firstBodyToken = sourceCode.getTokenAfter(arrowToken);\n              const lastBodyToken = sourceCode.getLastToken(node);\n              const isParenthesisedObjectLiteral = astUtils.isOpeningParenToken(firstBodyToken) && astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken)); // Wrap the value by a block and a return statement.\n\n              fixes.push(fixer.insertTextBefore(firstBodyToken, \"{return \"), fixer.insertTextAfter(lastBodyToken, \"}\")); // If the value is object literal, remove parentheses which were forced by syntax.\n\n              if (isParenthesisedObjectLiteral) {\n                fixes.push(fixer.remove(firstBodyToken), fixer.remove(findClosingParen(firstBodyToken)));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      \"ArrowFunctionExpression:exit\": validate\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/arrow-body-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","requireReturnForObjectLiteral","additionalProperties","fixable","messages","unexpectedOtherBlock","unexpectedEmptyBlock","unexpectedObjectBlock","unexpectedSingleBlock","expectedBlock","create","context","options","always","asNeeded","never","sourceCode","getSourceCode","hasASIProblem","token","test","value","findClosingParen","node","getNodeByRangeIndex","range","isParenthesised","parent","getTokenAfter","validate","arrowBody","body","blockBody","length","argument","messageId","isOpeningBraceToken","getFirstToken","skip","report","loc","start","fix","fixer","fixes","openingBrace","closingBrace","getLastToken","firstValueToken","lastValueToken","commentsExist","commentsExistBetween","push","remove","removeRange","insertTextBefore","insertTextAfter","isSemicolonToken","arrowToken","getTokenBefore","isArrowToken","firstBodyToken","lastBodyToken","isParenthesisedObjectLiteral","isOpeningParenToken"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-body-style\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis which is the pair of the given opening parenthesis.\n         * @param {Token} token The opening parenthesis token to get.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(token) {\n            let node = sourceCode.getNodeByRangeIndex(token.range[1]);\n\n            while (!astUtils.isParenthesised(sourceCode, node)) {\n                node = node.parent;\n            }\n            return sourceCode.getTokenAfter(node);\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    let messageId;\n\n                    if (blockBody.length === 0) {\n                        messageId = \"unexpectedEmptyBlock\";\n                    } else if (blockBody.length > 1) {\n                        messageId = \"unexpectedOtherBlock\";\n                    } else if (blockBody[0].argument === null) {\n                        messageId = \"unexpectedSingleBlock\";\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\n                        messageId = \"unexpectedObjectBlock\";\n                    } else {\n                        messageId = \"unexpectedSingleBlock\";\n                    }\n\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        messageId,\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            /*\n                             * Remove tokens around the return value.\n                             * If comments don't exist, remove extra spaces as well.\n                             */\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            /*\n                             * If the first token of the reutrn value is `{` or the return value is a sequence expression,\n                             * enclose the return value by parentheses to avoid syntax error.\n                             */\n                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\") {\n                                fixes.push(\n                                    fixer.insertTextBefore(firstValueToken, \"(\"),\n                                    fixer.insertTextAfter(lastValueToken, \")\")\n                                );\n                            }\n\n                            /*\n                             * If the last token of the return statement is semicolon, remove it.\n                             * Non-block arrow body is an expression, not a statement.\n                             */\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const firstBodyToken = sourceCode.getTokenAfter(arrowToken);\n                            const lastBodyToken = sourceCode.getLastToken(node);\n                            const isParenthesisedObjectLiteral =\n                                astUtils.isOpeningParenToken(firstBodyToken) &&\n                                astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));\n\n                            // Wrap the value by a block and a return statement.\n                            fixes.push(\n                                fixer.insertTextBefore(firstBodyToken, \"{return \"),\n                                fixer.insertTextAfter(lastBodyToken, \"}\")\n                            );\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (isParenthesisedObjectLiteral) {\n                                fixes.push(\n                                    fixer.remove(firstBodyToken),\n                                    fixer.remove(findClosingParen(firstBodyToken))\n                                );\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": validate\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}