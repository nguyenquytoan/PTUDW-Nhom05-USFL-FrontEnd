{"ast":null,"code":"/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provies three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  ExtractedConfig\n} = require(\"./extracted-config\");\n\nconst {\n  IgnorePattern\n} = require(\"./ignore-pattern\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n// Define types for VSCode IntelliSense.\n\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\n\n\nconst internalSlotsMap = new class extends WeakMap {\n  get(key) {\n    let value = super.get(key);\n\n    if (!value) {\n      value = {\n        cache: new Map(),\n        envMap: null,\n        processorMap: null,\n        ruleMap: null\n      };\n      super.set(key, value);\n    }\n\n    return value;\n  }\n\n}();\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\n\nfunction getMatchedIndices(elements, filePath) {\n  const indices = [];\n\n  for (let i = elements.length - 1; i >= 0; --i) {\n    const element = elements[i];\n\n    if (!element.criteria || element.criteria.test(filePath)) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n}\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\n\n\nfunction isNonNullObject(x) {\n  return typeof x === \"object\" && x !== null;\n}\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\n\n\nfunction mergeWithoutOverwrite(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    if (isNonNullObject(target[key])) {\n      mergeWithoutOverwrite(target[key], source[key]);\n    } else if (target[key] === void 0) {\n      if (isNonNullObject(source[key])) {\n        target[key] = Array.isArray(source[key]) ? [] : {};\n        mergeWithoutOverwrite(target[key], source[key]);\n      } else if (source[key] !== void 0) {\n        target[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\n\n\nfunction mergePlugins(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    const targetValue = target[key];\n    const sourceValue = source[key]; // Adopt the plugin which was found at first.\n\n    if (targetValue === void 0) {\n      if (sourceValue.error) {\n        throw sourceValue.error;\n      }\n\n      target[key] = sourceValue;\n    }\n  }\n}\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\n\n\nfunction mergeRuleConfigs(target, source) {\n  if (!isNonNullObject(source)) {\n    return;\n  }\n\n  for (const key of Object.keys(source)) {\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    const targetDef = target[key];\n    const sourceDef = source[key]; // Adopt the rule config which was found at first.\n\n    if (targetDef === void 0) {\n      if (Array.isArray(sourceDef)) {\n        target[key] = [...sourceDef];\n      } else {\n        target[key] = [sourceDef];\n      }\n      /*\n       * If the first found rule config is severity only and the current rule\n       * config has options, merge the severity and the options.\n       */\n\n    } else if (targetDef.length === 1 && Array.isArray(sourceDef) && sourceDef.length >= 2) {\n      targetDef.push(...sourceDef.slice(1));\n    }\n  }\n}\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\n\n\nfunction createConfig(instance, indices) {\n  const config = new ExtractedConfig();\n  const ignorePatterns = []; // Merge elements.\n\n  for (const index of indices) {\n    const element = instance[index]; // Adopt the parser which was found at first.\n\n    if (!config.parser && element.parser) {\n      if (element.parser.error) {\n        throw element.parser.error;\n      }\n\n      config.parser = element.parser;\n    } // Adopt the processor which was found at first.\n\n\n    if (!config.processor && element.processor) {\n      config.processor = element.processor;\n    } // Adopt the noInlineConfig which was found at first.\n\n\n    if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n      config.noInlineConfig = element.noInlineConfig;\n      config.configNameOfNoInlineConfig = element.name;\n    } // Adopt the reportUnusedDisableDirectives which was found at first.\n\n\n    if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n      config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n    } // Collect ignorePatterns\n\n\n    if (element.ignorePattern) {\n      ignorePatterns.push(element.ignorePattern);\n    } // Merge others.\n\n\n    mergeWithoutOverwrite(config.env, element.env);\n    mergeWithoutOverwrite(config.globals, element.globals);\n    mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n    mergeWithoutOverwrite(config.settings, element.settings);\n    mergePlugins(config.plugins, element.plugins);\n    mergeRuleConfigs(config.rules, element.rules);\n  } // Create the predicate function for ignore patterns.\n\n\n  if (ignorePatterns.length > 0) {\n    config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n  }\n\n  return config;\n}\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\n\n\nfunction collect(pluginId, defs, map, normalize) {\n  if (defs) {\n    const prefix = pluginId && `${pluginId}/`;\n\n    for (const [key, value] of Object.entries(defs)) {\n      map.set(`${prefix}${key}`, normalize ? normalize(value) : value);\n    }\n  }\n}\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\n\n\nfunction normalizePluginRule(rule) {\n  return typeof rule === \"function\" ? {\n    create: rule\n  } : rule;\n}\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\n\n\nfunction deleteMutationMethods(map) {\n  Object.defineProperties(map, {\n    clear: {\n      configurable: true,\n      value: void 0\n    },\n    delete: {\n      configurable: true,\n      value: void 0\n    },\n    set: {\n      configurable: true,\n      value: void 0\n    }\n  });\n}\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\n\n\nfunction initPluginMemberMaps(elements, slots) {\n  const processed = new Set();\n  slots.envMap = new Map();\n  slots.processorMap = new Map();\n  slots.ruleMap = new Map();\n\n  for (const element of elements) {\n    if (!element.plugins) {\n      continue;\n    }\n\n    for (const [pluginId, value] of Object.entries(element.plugins)) {\n      const plugin = value.definition;\n\n      if (!plugin || processed.has(pluginId)) {\n        continue;\n      }\n\n      processed.add(pluginId);\n      collect(pluginId, plugin.environments, slots.envMap);\n      collect(pluginId, plugin.processors, slots.processorMap);\n      collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n    }\n  }\n\n  deleteMutationMethods(slots.envMap);\n  deleteMutationMethods(slots.processorMap);\n  deleteMutationMethods(slots.ruleMap);\n}\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\n\n\nfunction ensurePluginMemberMaps(instance) {\n  const slots = internalSlotsMap.get(instance);\n\n  if (!slots.ruleMap) {\n    initPluginMemberMaps(instance, slots);\n  }\n\n  return slots;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\n\n\nclass ConfigArray extends Array {\n  /**\n   * Get the plugin environments.\n   * The returned map cannot be mutated.\n   * @type {ReadonlyMap<string, Environment>} The plugin environments.\n   */\n  get pluginEnvironments() {\n    return ensurePluginMemberMaps(this).envMap;\n  }\n  /**\n   * Get the plugin processors.\n   * The returned map cannot be mutated.\n   * @type {ReadonlyMap<string, Processor>} The plugin processors.\n   */\n\n\n  get pluginProcessors() {\n    return ensurePluginMemberMaps(this).processorMap;\n  }\n  /**\n   * Get the plugin rules.\n   * The returned map cannot be mutated.\n   * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n   */\n\n\n  get pluginRules() {\n    return ensurePluginMemberMaps(this).ruleMap;\n  }\n  /**\n   * Check if this config has `root` flag.\n   * @returns {boolean} `true` if this config array is root.\n   */\n\n\n  isRoot() {\n    for (let i = this.length - 1; i >= 0; --i) {\n      const root = this[i].root;\n\n      if (typeof root === \"boolean\") {\n        return root;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Extract the config data which is related to a given file.\n   * @param {string} filePath The absolute path to the target file.\n   * @returns {ExtractedConfig} The extracted config data.\n   */\n\n\n  extractConfig(filePath) {\n    const {\n      cache\n    } = internalSlotsMap.get(this);\n    const indices = getMatchedIndices(this, filePath);\n    const cacheKey = indices.join(\",\");\n\n    if (!cache.has(cacheKey)) {\n      cache.set(cacheKey, createConfig(this, indices));\n    }\n\n    return cache.get(cacheKey);\n  }\n\n}\n\nconst exportObject = {\n  ConfigArray,\n\n  /**\n   * Get the used extracted configs.\n   * CLIEngine will use this method to collect used deprecated rules.\n   * @param {ConfigArray} instance The config array object to get.\n   * @returns {ExtractedConfig[]} The used extracted configs.\n   * @private\n   */\n  getUsedExtractedConfigs(instance) {\n    const {\n      cache\n    } = internalSlotsMap.get(instance);\n    return Array.from(cache.values());\n  }\n\n};\nmodule.exports = exportObject;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/cli-engine/config-array/config-array.js"],"names":["ExtractedConfig","require","IgnorePattern","internalSlotsMap","WeakMap","get","key","value","cache","Map","envMap","processorMap","ruleMap","set","getMatchedIndices","elements","filePath","indices","i","length","element","criteria","test","push","isNonNullObject","x","mergeWithoutOverwrite","target","source","Object","keys","Array","isArray","mergePlugins","targetValue","sourceValue","error","mergeRuleConfigs","targetDef","sourceDef","slice","createConfig","instance","config","ignorePatterns","index","parser","processor","noInlineConfig","configNameOfNoInlineConfig","name","reportUnusedDisableDirectives","ignorePattern","env","globals","parserOptions","settings","plugins","rules","ignores","createIgnore","reverse","collect","pluginId","defs","map","normalize","prefix","entries","normalizePluginRule","rule","create","deleteMutationMethods","defineProperties","clear","configurable","delete","initPluginMemberMaps","slots","processed","Set","plugin","definition","has","add","environments","processors","ensurePluginMemberMaps","ConfigArray","pluginEnvironments","pluginProcessors","pluginRules","isRoot","root","extractConfig","cacheKey","join","exportObject","getUsedExtractedConfigs","from","values","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provies three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { ExtractedConfig } = require(\"./extracted-config\");\nconst { IgnorePattern } = require(\"./ignore-pattern\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n    get(key) {\n        let value = super.get(key);\n\n        if (!value) {\n            value = {\n                cache: new Map(),\n                envMap: null,\n                processorMap: null,\n                ruleMap: null\n            };\n            super.set(key, value);\n        }\n\n        return value;\n    }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n    const indices = [];\n\n    for (let i = elements.length - 1; i >= 0; --i) {\n        const element = elements[i];\n\n        if (!element.criteria || element.criteria.test(filePath)) {\n            indices.push(i);\n        }\n    }\n\n    return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n    return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        if (isNonNullObject(target[key])) {\n            mergeWithoutOverwrite(target[key], source[key]);\n        } else if (target[key] === void 0) {\n            if (isNonNullObject(source[key])) {\n                target[key] = Array.isArray(source[key]) ? [] : {};\n                mergeWithoutOverwrite(target[key], source[key]);\n            } else if (source[key] !== void 0) {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergePlugins(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetValue = target[key];\n        const sourceValue = source[key];\n\n        // Adopt the plugin which was found at first.\n        if (targetValue === void 0) {\n            if (sourceValue.error) {\n                throw sourceValue.error;\n            }\n            target[key] = sourceValue;\n        }\n    }\n}\n\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeRuleConfigs(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetDef = target[key];\n        const sourceDef = source[key];\n\n        // Adopt the rule config which was found at first.\n        if (targetDef === void 0) {\n            if (Array.isArray(sourceDef)) {\n                target[key] = [...sourceDef];\n            } else {\n                target[key] = [sourceDef];\n            }\n\n        /*\n         * If the first found rule config is severity only and the current rule\n         * config has options, merge the severity and the options.\n         */\n        } else if (\n            targetDef.length === 1 &&\n            Array.isArray(sourceDef) &&\n            sourceDef.length >= 2\n        ) {\n            targetDef.push(...sourceDef.slice(1));\n        }\n    }\n}\n\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\nfunction createConfig(instance, indices) {\n    const config = new ExtractedConfig();\n    const ignorePatterns = [];\n\n    // Merge elements.\n    for (const index of indices) {\n        const element = instance[index];\n\n        // Adopt the parser which was found at first.\n        if (!config.parser && element.parser) {\n            if (element.parser.error) {\n                throw element.parser.error;\n            }\n            config.parser = element.parser;\n        }\n\n        // Adopt the processor which was found at first.\n        if (!config.processor && element.processor) {\n            config.processor = element.processor;\n        }\n\n        // Adopt the noInlineConfig which was found at first.\n        if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n            config.noInlineConfig = element.noInlineConfig;\n            config.configNameOfNoInlineConfig = element.name;\n        }\n\n        // Adopt the reportUnusedDisableDirectives which was found at first.\n        if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n            config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n        }\n\n        // Collect ignorePatterns\n        if (element.ignorePattern) {\n            ignorePatterns.push(element.ignorePattern);\n        }\n\n        // Merge others.\n        mergeWithoutOverwrite(config.env, element.env);\n        mergeWithoutOverwrite(config.globals, element.globals);\n        mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n        mergeWithoutOverwrite(config.settings, element.settings);\n        mergePlugins(config.plugins, element.plugins);\n        mergeRuleConfigs(config.rules, element.rules);\n    }\n\n    // Create the predicate function for ignore patterns.\n    if (ignorePatterns.length > 0) {\n        config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n    }\n\n    return config;\n}\n\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\nfunction collect(pluginId, defs, map, normalize) {\n    if (defs) {\n        const prefix = pluginId && `${pluginId}/`;\n\n        for (const [key, value] of Object.entries(defs)) {\n            map.set(\n                `${prefix}${key}`,\n                normalize ? normalize(value) : value\n            );\n        }\n    }\n}\n\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\nfunction normalizePluginRule(rule) {\n    return typeof rule === \"function\" ? { create: rule } : rule;\n}\n\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\nfunction deleteMutationMethods(map) {\n    Object.defineProperties(map, {\n        clear: { configurable: true, value: void 0 },\n        delete: { configurable: true, value: void 0 },\n        set: { configurable: true, value: void 0 }\n    });\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\nfunction initPluginMemberMaps(elements, slots) {\n    const processed = new Set();\n\n    slots.envMap = new Map();\n    slots.processorMap = new Map();\n    slots.ruleMap = new Map();\n\n    for (const element of elements) {\n        if (!element.plugins) {\n            continue;\n        }\n\n        for (const [pluginId, value] of Object.entries(element.plugins)) {\n            const plugin = value.definition;\n\n            if (!plugin || processed.has(pluginId)) {\n                continue;\n            }\n            processed.add(pluginId);\n\n            collect(pluginId, plugin.environments, slots.envMap);\n            collect(pluginId, plugin.processors, slots.processorMap);\n            collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n        }\n    }\n\n    deleteMutationMethods(slots.envMap);\n    deleteMutationMethods(slots.processorMap);\n    deleteMutationMethods(slots.ruleMap);\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\nfunction ensurePluginMemberMaps(instance) {\n    const slots = internalSlotsMap.get(instance);\n\n    if (!slots.ruleMap) {\n        initPluginMemberMaps(instance, slots);\n    }\n\n    return slots;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\nclass ConfigArray extends Array {\n\n    /**\n     * Get the plugin environments.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Environment>} The plugin environments.\n     */\n    get pluginEnvironments() {\n        return ensurePluginMemberMaps(this).envMap;\n    }\n\n    /**\n     * Get the plugin processors.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Processor>} The plugin processors.\n     */\n    get pluginProcessors() {\n        return ensurePluginMemberMaps(this).processorMap;\n    }\n\n    /**\n     * Get the plugin rules.\n     * The returned map cannot be mutated.\n     * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n     */\n    get pluginRules() {\n        return ensurePluginMemberMaps(this).ruleMap;\n    }\n\n    /**\n     * Check if this config has `root` flag.\n     * @returns {boolean} `true` if this config array is root.\n     */\n    isRoot() {\n        for (let i = this.length - 1; i >= 0; --i) {\n            const root = this[i].root;\n\n            if (typeof root === \"boolean\") {\n                return root;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Extract the config data which is related to a given file.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {ExtractedConfig} The extracted config data.\n     */\n    extractConfig(filePath) {\n        const { cache } = internalSlotsMap.get(this);\n        const indices = getMatchedIndices(this, filePath);\n        const cacheKey = indices.join(\",\");\n\n        if (!cache.has(cacheKey)) {\n            cache.set(cacheKey, createConfig(this, indices));\n        }\n\n        return cache.get(cacheKey);\n    }\n}\n\nconst exportObject = {\n    ConfigArray,\n\n    /**\n     * Get the used extracted configs.\n     * CLIEngine will use this method to collect used deprecated rules.\n     * @param {ConfigArray} instance The config array object to get.\n     * @returns {ExtractedConfig[]} The used extracted configs.\n     * @private\n     */\n    getUsedExtractedConfigs(instance) {\n        const { cache } = internalSlotsMap.get(instance);\n\n        return Array.from(cache.values());\n    }\n};\n\nmodule.exports = exportObject;\n"]},"metadata":{},"sourceType":"script"}