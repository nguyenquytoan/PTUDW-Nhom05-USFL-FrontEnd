{"ast":null,"code":"/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\n\n\nfunction isInOrInstanceOfOperator(op) {\n  return op === \"in\" || op === \"instanceof\";\n}\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\n\n\nfunction isOrderingRelationalOperator(op) {\n  return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\n\n\nfunction isNegation(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"!\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow negating the left operand of relational operators\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-negation\",\n      suggestion: true\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForOrderingRelations: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n      suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n      suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n    return {\n      BinaryExpression(node) {\n        const operator = node.operator;\n        const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n        if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {\n          context.report({\n            node,\n            loc: node.left.loc,\n            messageId: \"unexpected\",\n            data: {\n              operator\n            },\n            suggest: [{\n              messageId: \"suggestNegatedExpression\",\n              data: {\n                operator\n              },\n\n              fix(fixer) {\n                const negationToken = sourceCode.getFirstToken(node.left);\n                const fixRange = [negationToken.range[1], node.range[1]];\n                const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n                return fixer.replaceTextRange(fixRange, `(${text})`);\n              }\n\n            }, {\n              messageId: \"suggestParenthesisedNegation\",\n\n              fix(fixer) {\n                return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n              }\n\n            }]\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-unsafe-negation.js"],"names":["astUtils","require","isInOrInstanceOfOperator","op","isOrderingRelationalOperator","isNegation","node","type","operator","module","exports","meta","docs","description","category","recommended","url","suggestion","schema","properties","enforceForOrderingRelations","default","additionalProperties","fixable","messages","unexpected","suggestNegatedExpression","suggestParenthesisedNegation","create","context","sourceCode","getSourceCode","options","BinaryExpression","orderingRelationRuleApplies","left","isParenthesised","report","loc","messageId","data","suggest","fix","fixer","negationToken","getFirstToken","fixRange","range","text","slice","replaceTextRange","replaceText","getText"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\nfunction isInOrInstanceOfOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\nfunction isOrderingRelationalOperator(op) {\n    return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow negating the left operand of relational operators\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-negation\",\n            suggestion: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForOrderingRelations: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: null,\n\n        messages: {\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n            suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n            suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n\n        return {\n            BinaryExpression(node) {\n                const operator = node.operator;\n                const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n                if (\n                    (isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        messageId: \"unexpected\",\n                        data: { operator },\n                        suggest: [\n                            {\n                                messageId: \"suggestNegatedExpression\",\n                                data: { operator },\n                                fix(fixer) {\n                                    const negationToken = sourceCode.getFirstToken(node.left);\n                                    const fixRange = [negationToken.range[1], node.range[1]];\n                                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                                    return fixer.replaceTextRange(fixRange, `(${text})`);\n                                }\n                            },\n                            {\n                                messageId: \"suggestParenthesisedNegation\",\n                                fix(fixer) {\n                                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n                                }\n                            }\n                        ]\n                    });\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}