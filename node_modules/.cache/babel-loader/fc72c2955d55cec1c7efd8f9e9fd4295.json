{"ast":null,"code":"const postcss = require('postcss');\n\nconst topologicalSort = require('./topologicalSort');\n\nconst declWhitelist = ['composes'];\nconst declFilter = new RegExp(`^(${declWhitelist.join('|')})$`);\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\nconst VISITED_MARKER = 1;\n\nfunction createParentName(rule, root) {\n  return `__${root.index(rule.parent)}_${rule.selector}`;\n}\n\nfunction serializeImports(imports) {\n  return imports.map(importPath => '`' + importPath + '`').join(', ');\n}\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\n\n\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + '_' + 'siblings';\n  const visitedId = parentId + '_' + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = [];\n    const siblings = visited[siblingsId];\n    if (Array.isArray(graph[importId])) graph[importId] = graph[importId].concat(siblings);else graph[importId] = siblings.slice();\n    visited[visitedId] = VISITED_MARKER;\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function (options = {}) {\n  const failOnWrongOrder = options.failOnWrongOrder;\n  return css => {\n    const graph = {};\n    const visited = {};\n    const existingImports = {};\n    const importDecls = {};\n    const imports = {};\n    let importIndex = 0;\n    const createImportedName = typeof options.createImportedName !== 'function' ? (importName\n    /*, path*/\n    ) => `i__imported_${importName.replace(/\\W/g, '_')}_${importIndex++}` : options.createImportedName; // Check the existing imports order and save refs\n\n    css.walkRules(rule => {\n      const matches = icssImport.exec(rule.selector);\n\n      if (matches) {\n        const [,\n        /*match*/\n        doubleQuotePath, singleQuotePath] = matches;\n        const importPath = doubleQuotePath || singleQuotePath;\n        addImportToGraph(importPath, 'root', graph, visited);\n        existingImports[importPath] = rule;\n      }\n    }); // Find any declaration that supports imports\n\n    css.walkDecls(declFilter, decl => {\n      let matches = decl.value.match(matchImports);\n      let tmpSymbols;\n\n      if (matches) {\n        let [,\n        /*match*/\n        symbols, doubleQuotePath, singleQuotePath, global] = matches;\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`);\n        } else {\n          const importPath = doubleQuotePath || singleQuotePath;\n          const parentRule = createParentName(decl.parent, css);\n          addImportToGraph(importPath, parentRule, graph, visited);\n          importDecls[importPath] = decl;\n          imports[importPath] = imports[importPath] || {};\n          tmpSymbols = symbols.split(/\\s+/).map(s => {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath);\n            }\n\n            return imports[importPath][s];\n          });\n        }\n\n        decl.value = tmpSymbols.join(' ');\n      }\n    });\n    const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n    if (importsOrder instanceof Error) {\n      const importPath = importsOrder.nodes.find(importPath => importDecls.hasOwnProperty(importPath));\n      const decl = importDecls[importPath];\n      const errMsg = 'Failed to resolve order of composed modules ' + serializeImports(importsOrder.nodes) + '.';\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      });\n    }\n\n    let lastImportRule;\n    importsOrder.forEach(path => {\n      const importedSymbols = imports[path];\n      let rule = existingImports[path];\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: `:import(\"${path}\")`,\n          raws: {\n            after: '\\n'\n          }\n        });\n        if (lastImportRule) css.insertAfter(lastImportRule, rule);else css.prepend(rule);\n      }\n\n      lastImportRule = rule;\n      if (!importedSymbols) return;\n      Object.keys(importedSymbols).forEach(importedSymbol => {\n        rule.append(postcss.decl({\n          value: importedSymbol,\n          prop: importedSymbols[importedSymbol],\n          raws: {\n            before: '\\n  '\n          }\n        }));\n      });\n    });\n  };\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/postcss-modules-extract-imports/src/index.js"],"names":["postcss","require","topologicalSort","declWhitelist","declFilter","RegExp","join","matchImports","icssImport","VISITED_MARKER","createParentName","rule","root","index","parent","selector","serializeImports","imports","map","importPath","addImportToGraph","importId","parentId","graph","visited","siblingsId","visitedId","Array","isArray","siblings","concat","slice","push","module","exports","plugin","options","failOnWrongOrder","css","existingImports","importDecls","importIndex","createImportedName","importName","replace","walkRules","matches","exec","doubleQuotePath","singleQuotePath","walkDecls","decl","value","match","tmpSymbols","symbols","global","split","s","parentRule","importsOrder","Error","nodes","find","hasOwnProperty","errMsg","error","word","lastImportRule","forEach","path","importedSymbols","raws","after","insertAfter","prepend","Object","keys","importedSymbol","append","prop","before"],"mappings":"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","sourcesContent":["const postcss = require('postcss')\nconst topologicalSort = require('./topologicalSort')\n\nconst declWhitelist = ['composes']\nconst declFilter = new RegExp(`^(${declWhitelist.join('|')})$`)\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/\n\nconst VISITED_MARKER = 1\n\nfunction createParentName(rule, root) {\n  return `__${root.index(rule.parent)}_${rule.selector}`\n}\n\nfunction serializeImports(imports) {\n  return imports.map(importPath => '`' + importPath + '`').join(', ')\n}\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + '_' + 'siblings'\n  const visitedId = parentId + '_' + importId\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = []\n\n    const siblings = visited[siblingsId]\n\n    if (Array.isArray(graph[importId]))\n      graph[importId] = graph[importId].concat(siblings)\n    else graph[importId] = siblings.slice()\n\n    visited[visitedId] = VISITED_MARKER\n    siblings.push(importId)\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function(\n  options = {}\n) {\n  const failOnWrongOrder = options.failOnWrongOrder\n\n  return css => {\n    const graph = {}\n    const visited = {}\n\n    const existingImports = {}\n    const importDecls = {}\n    const imports = {}\n\n    let importIndex = 0\n\n    const createImportedName = typeof options.createImportedName !== 'function'\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, '_')}_${importIndex++}`\n      : options.createImportedName\n\n    // Check the existing imports order and save refs\n    css.walkRules(rule => {\n      const matches = icssImport.exec(rule.selector)\n\n      if (matches) {\n        const [, /*match*/ doubleQuotePath, singleQuotePath] = matches\n        const importPath = doubleQuotePath || singleQuotePath\n\n        addImportToGraph(importPath, 'root', graph, visited)\n\n        existingImports[importPath] = rule\n      }\n    })\n\n    // Find any declaration that supports imports\n    css.walkDecls(declFilter, decl => {\n      let matches = decl.value.match(matchImports)\n      let tmpSymbols\n\n      if (matches) {\n        let [\n          ,\n          /*match*/ symbols,\n          doubleQuotePath,\n          singleQuotePath,\n          global\n        ] = matches\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`)\n        } else {\n          const importPath = doubleQuotePath || singleQuotePath\n          const parentRule = createParentName(decl.parent, css)\n\n          addImportToGraph(importPath, parentRule, graph, visited)\n\n          importDecls[importPath] = decl\n          imports[importPath] = imports[importPath] || {}\n\n          tmpSymbols = symbols.split(/\\s+/).map(s => {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath)\n            }\n\n            return imports[importPath][s]\n          })\n        }\n\n        decl.value = tmpSymbols.join(' ')\n      }\n    })\n\n    const importsOrder = topologicalSort(graph, failOnWrongOrder)\n\n    if (importsOrder instanceof Error) {\n      const importPath = importsOrder.nodes.find(importPath =>\n        importDecls.hasOwnProperty(importPath)\n      )\n      const decl = importDecls[importPath]\n\n      const errMsg =\n        'Failed to resolve order of composed modules ' +\n        serializeImports(importsOrder.nodes) +\n        '.'\n\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      })\n    }\n\n    let lastImportRule\n    importsOrder.forEach(path => {\n      const importedSymbols = imports[path]\n      let rule = existingImports[path]\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: `:import(\"${path}\")`,\n          raws: { after: '\\n' }\n        })\n\n        if (lastImportRule) css.insertAfter(lastImportRule, rule)\n        else css.prepend(rule)\n      }\n\n      lastImportRule = rule\n\n      if (!importedSymbols) return\n\n      Object.keys(importedSymbols).forEach(importedSymbol => {\n        rule.append(\n          postcss.decl({\n            value: importedSymbol,\n            prop: importedSymbols[importedSymbol],\n            raws: { before: '\\n  ' }\n          })\n        )\n      })\n    })\n  }\n})\n"]},"metadata":{},"sourceType":"script"}