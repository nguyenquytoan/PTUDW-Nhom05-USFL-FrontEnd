{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _CallTracker = _interopRequireDefault(require('./CallTracker'));\n\nvar _createSpy = _interopRequireDefault(require('./createSpy'));\n\nvar _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst formatErrorMsg = (domain, usage) => {\n  const usageDefinition = usage ? '\\nUsage: ' + usage : '';\n  return msg => domain + ' : ' + msg + usageDefinition;\n};\n\nfunction isSpy(putativeSpy) {\n  if (!putativeSpy) {\n    return false;\n  }\n\n  return putativeSpy.and instanceof _SpyStrategy.default && putativeSpy.calls instanceof _CallTracker.default;\n}\n\nconst getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\nclass SpyRegistry {\n  constructor({\n    currentSpies = () => []\n  } = {}) {\n    _defineProperty(this, 'allowRespy', void 0);\n\n    _defineProperty(this, 'spyOn', void 0);\n\n    _defineProperty(this, 'clearSpies', void 0);\n\n    _defineProperty(this, 'respy', void 0);\n\n    _defineProperty(this, '_spyOnProperty', void 0);\n\n    this.allowRespy = function (allow) {\n      this.respy = allow;\n    };\n\n    this.spyOn = (obj, methodName, accessType) => {\n      if (accessType) {\n        return this._spyOnProperty(obj, methodName, accessType);\n      }\n\n      if (obj === void 0) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\n      }\n\n      if (methodName === void 0) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (obj[methodName] === void 0) {\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\n      }\n\n      if (obj[methodName] && isSpy(obj[methodName])) {\n        if (this.respy) {\n          return obj[methodName];\n        } else {\n          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\n        }\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch (e) {// IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\n      }\n\n      const originalMethod = obj[methodName];\n      const spiedMethod = (0, _createSpy.default)(methodName, originalMethod);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\n        restoreStrategy = function restoreStrategy() {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function restoreStrategy() {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      obj[methodName] = spiedMethod;\n      return spiedMethod;\n    };\n\n    this._spyOnProperty = function (obj, propertyName, accessType = 'get') {\n      if (!obj) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + propertyName));\n      }\n\n      if (!propertyName) {\n        throw new Error(getErrorMsg('No property name supplied'));\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      } catch (e) {// IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (!descriptor) {\n        throw new Error(getErrorMsg(propertyName + ' property does not exist'));\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(getErrorMsg(propertyName + ' is not declared configurable'));\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error(getErrorMsg('Property ' + propertyName + ' does not have access type ' + accessType));\n      }\n\n      if (obj[propertyName] && isSpy(obj[propertyName])) {\n        if (this.respy) {\n          return obj[propertyName];\n        } else {\n          throw new Error(getErrorMsg(propertyName + ' has already been spied upon'));\n        }\n      }\n\n      const originalDescriptor = descriptor;\n      const spiedProperty = (0, _createSpy.default)(propertyName, descriptor[accessType]);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function restoreStrategy() {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function restoreStrategy() {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n\n      const spiedDescriptor = _objectSpread({}, descriptor, {\n        [accessType]: spiedProperty\n      });\n\n      Object.defineProperty(obj, propertyName, spiedDescriptor);\n      return spiedProperty;\n    };\n\n    this.clearSpies = function () {\n      const spies = currentSpies();\n\n      for (let i = spies.length - 1; i >= 0; i--) {\n        const spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState();\n      }\n    };\n  }\n\n}\n\nexports.default = SpyRegistry;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jest-jasmine2/build/jasmine/spyRegistry.js"],"names":["Object","defineProperty","exports","value","default","_CallTracker","_interopRequireDefault","require","_createSpy","_SpyStrategy","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","formatErrorMsg","domain","usage","usageDefinition","msg","isSpy","putativeSpy","and","calls","getErrorMsg","SpyRegistry","constructor","currentSpies","allowRespy","allow","respy","spyOn","methodName","accessType","_spyOnProperty","Error","descriptor","e","set","originalMethod","spiedMethod","restoreStrategy","prototype","hasOwnProperty","call","push","restoreObjectToOriginalState","propertyName","originalDescriptor","spiedProperty","spiedDescriptor","clearSpies","spies","spyEntry"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _CallTracker = _interopRequireDefault(require('./CallTracker'));\n\nvar _createSpy = _interopRequireDefault(require('./createSpy'));\n\nvar _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst formatErrorMsg = (domain, usage) => {\n  const usageDefinition = usage ? '\\nUsage: ' + usage : '';\n  return msg => domain + ' : ' + msg + usageDefinition;\n};\n\nfunction isSpy(putativeSpy) {\n  if (!putativeSpy) {\n    return false;\n  }\n\n  return (\n    putativeSpy.and instanceof _SpyStrategy.default &&\n    putativeSpy.calls instanceof _CallTracker.default\n  );\n}\n\nconst getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\nclass SpyRegistry {\n  constructor({currentSpies = () => []} = {}) {\n    _defineProperty(this, 'allowRespy', void 0);\n\n    _defineProperty(this, 'spyOn', void 0);\n\n    _defineProperty(this, 'clearSpies', void 0);\n\n    _defineProperty(this, 'respy', void 0);\n\n    _defineProperty(this, '_spyOnProperty', void 0);\n\n    this.allowRespy = function(allow) {\n      this.respy = allow;\n    };\n\n    this.spyOn = (obj, methodName, accessType) => {\n      if (accessType) {\n        return this._spyOnProperty(obj, methodName, accessType);\n      }\n\n      if (obj === void 0) {\n        throw new Error(\n          getErrorMsg(\n            'could not find an object to spy upon for ' + methodName + '()'\n          )\n        );\n      }\n\n      if (methodName === void 0) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (obj[methodName] === void 0) {\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\n      }\n\n      if (obj[methodName] && isSpy(obj[methodName])) {\n        if (this.respy) {\n          return obj[methodName];\n        } else {\n          throw new Error(\n            getErrorMsg(methodName + ' has already been spied upon')\n          );\n        }\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch (e) {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(\n          getErrorMsg(methodName + ' is not declared writable or has no setter')\n        );\n      }\n\n      const originalMethod = obj[methodName];\n      const spiedMethod = (0, _createSpy.default)(methodName, originalMethod);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\n        restoreStrategy = function restoreStrategy() {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function restoreStrategy() {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      obj[methodName] = spiedMethod;\n      return spiedMethod;\n    };\n\n    this._spyOnProperty = function(obj, propertyName, accessType = 'get') {\n      if (!obj) {\n        throw new Error(\n          getErrorMsg(\n            'could not find an object to spy upon for ' + propertyName\n          )\n        );\n      }\n\n      if (!propertyName) {\n        throw new Error(getErrorMsg('No property name supplied'));\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      } catch (e) {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (!descriptor) {\n        throw new Error(getErrorMsg(propertyName + ' property does not exist'));\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(\n          getErrorMsg(propertyName + ' is not declared configurable')\n        );\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error(\n          getErrorMsg(\n            'Property ' +\n              propertyName +\n              ' does not have access type ' +\n              accessType\n          )\n        );\n      }\n\n      if (obj[propertyName] && isSpy(obj[propertyName])) {\n        if (this.respy) {\n          return obj[propertyName];\n        } else {\n          throw new Error(\n            getErrorMsg(propertyName + ' has already been spied upon')\n          );\n        }\n      }\n\n      const originalDescriptor = descriptor;\n      const spiedProperty = (0, _createSpy.default)(\n        propertyName,\n        descriptor[accessType]\n      );\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function restoreStrategy() {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function restoreStrategy() {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n\n      const spiedDescriptor = _objectSpread({}, descriptor, {\n        [accessType]: spiedProperty\n      });\n\n      Object.defineProperty(obj, propertyName, spiedDescriptor);\n      return spiedProperty;\n    };\n\n    this.clearSpies = function() {\n      const spies = currentSpies();\n\n      for (let i = spies.length - 1; i >= 0; i--) {\n        const spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState();\n      }\n    };\n  }\n}\n\nexports.default = SpyRegistry;\n"]},"metadata":{},"sourceType":"script"}