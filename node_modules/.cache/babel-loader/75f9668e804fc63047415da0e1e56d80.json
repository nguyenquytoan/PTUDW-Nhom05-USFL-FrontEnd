{"ast":null,"code":"/**\n * HTTP client-side implementation that uses forge.net sockets.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\n\nrequire('./debug');\n\nrequire('./tls');\n\nrequire('./util'); // define http namespace\n\n\nvar http = module.exports = forge.http = forge.http || {}; // logging category\n\nvar cat = 'forge.http'; // add array of clients to debug storage\n\nif (forge.debug) {\n  forge.debug.set('forge.http', 'clients', []);\n} // normalizes an http header field name\n\n\nvar _normalize = function (name) {\n  return name.toLowerCase().replace(/(^.)|(-.)/g, function (a) {\n    return a.toUpperCase();\n  });\n};\n/**\n * Gets the local storage ID for the given client.\n *\n * @param client the client to get the local storage ID for.\n *\n * @return the local storage ID to use.\n */\n\n\nvar _getStorageId = function (client) {\n  // TODO: include browser in ID to avoid sharing cookies between\n  // browsers (if this is undesirable)\n  // navigator.userAgent\n  return 'forge.http.' + client.url.scheme + '.' + client.url.host + '.' + client.url.port;\n};\n/**\n * Loads persistent cookies from disk for the given client.\n *\n * @param client the client.\n */\n\n\nvar _loadCookies = function (client) {\n  if (client.persistCookies) {\n    try {\n      var cookies = forge.util.getItem(client.socketPool.flashApi, _getStorageId(client), 'cookies');\n      client.cookies = cookies || {};\n    } catch (ex) {// no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n/**\n * Saves persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\n\n\nvar _saveCookies = function (client) {\n  if (client.persistCookies) {\n    try {\n      forge.util.setItem(client.socketPool.flashApi, _getStorageId(client), 'cookies', client.cookies);\n    } catch (ex) {// no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  } // FIXME: remove me\n\n\n  _loadCookies(client);\n};\n/**\n * Clears persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\n\n\nvar _clearCookies = function (client) {\n  if (client.persistCookies) {\n    try {\n      // only thing stored is 'cookies', so clear whole storage\n      forge.util.clearItems(client.socketPool.flashApi, _getStorageId(client));\n    } catch (ex) {// no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n/**\n * Connects and sends a request.\n *\n * @param client the http client.\n * @param socket the socket to use.\n */\n\n\nvar _doRequest = function (client, socket) {\n  if (socket.isConnected()) {\n    // already connected\n    socket.options.request.connectTime = +new Date();\n    socket.connected({\n      type: 'connect',\n      id: socket.id\n    });\n  } else {\n    // connect\n    socket.options.request.connectTime = +new Date();\n    socket.connect({\n      host: client.url.host,\n      port: client.url.port,\n      policyPort: client.policyPort,\n      policyUrl: client.policyUrl\n    });\n  }\n};\n/**\n * Handles the next request or marks a socket as idle.\n *\n * @param client the http client.\n * @param socket the socket.\n */\n\n\nvar _handleNextRequest = function (client, socket) {\n  // clear buffer\n  socket.buffer.clear(); // get pending request\n\n  var pending = null;\n\n  while (pending === null && client.requests.length > 0) {\n    pending = client.requests.shift();\n\n    if (pending.request.aborted) {\n      pending = null;\n    }\n  } // mark socket idle if no pending requests\n\n\n  if (pending === null) {\n    if (socket.options !== null) {\n      socket.options = null;\n    }\n\n    client.idle.push(socket);\n  } else {\n    // handle pending request, allow 1 retry\n    socket.retries = 1;\n    socket.options = pending;\n\n    _doRequest(client, socket);\n  }\n};\n/**\n * Sets up a socket for use with an http client.\n *\n * @param client the parent http client.\n * @param socket the socket to set up.\n * @param tlsOptions if the socket must use TLS, the TLS options.\n */\n\n\nvar _initSocket = function (client, socket, tlsOptions) {\n  // no socket options yet\n  socket.options = null; // set up handlers\n\n  socket.connected = function (e) {\n    // socket primed by caching TLS session, handle next request\n    if (socket.options === null) {\n      _handleNextRequest(client, socket);\n    } else {\n      // socket in use\n      var request = socket.options.request;\n      request.connectTime = +new Date() - request.connectTime;\n      e.socket = socket;\n      socket.options.connected(e);\n\n      if (request.aborted) {\n        socket.close();\n      } else {\n        var out = request.toString();\n\n        if (request.body) {\n          out += request.body;\n        }\n\n        request.time = +new Date();\n        socket.send(out);\n        request.time = +new Date() - request.time;\n        socket.options.response.time = +new Date();\n        socket.sending = true;\n      }\n    }\n  };\n\n  socket.closed = function (e) {\n    if (socket.sending) {\n      socket.sending = false;\n\n      if (socket.retries > 0) {\n        --socket.retries;\n\n        _doRequest(client, socket);\n      } else {\n        // error, closed during send\n        socket.error({\n          id: socket.id,\n          type: 'ioError',\n          message: 'Connection closed during send. Broken pipe.',\n          bytesAvailable: 0\n        });\n      }\n    } else {\n      // handle unspecified content-length transfer\n      var response = socket.options.response;\n\n      if (response.readBodyUntilClose) {\n        response.time = +new Date() - response.time;\n        response.bodyReceived = true;\n        socket.options.bodyReady({\n          request: socket.options.request,\n          response: response,\n          socket: socket\n        });\n      }\n\n      socket.options.closed(e);\n\n      _handleNextRequest(client, socket);\n    }\n  };\n\n  socket.data = function (e) {\n    socket.sending = false;\n    var request = socket.options.request;\n\n    if (request.aborted) {\n      socket.close();\n    } else {\n      // receive all bytes available\n      var response = socket.options.response;\n      var bytes = socket.receive(e.bytesAvailable);\n\n      if (bytes !== null) {\n        // receive header and then body\n        socket.buffer.putBytes(bytes);\n\n        if (!response.headerReceived) {\n          response.readHeader(socket.buffer);\n\n          if (response.headerReceived) {\n            socket.options.headerReady({\n              request: socket.options.request,\n              response: response,\n              socket: socket\n            });\n          }\n        }\n\n        if (response.headerReceived && !response.bodyReceived) {\n          response.readBody(socket.buffer);\n        }\n\n        if (response.bodyReceived) {\n          socket.options.bodyReady({\n            request: socket.options.request,\n            response: response,\n            socket: socket\n          }); // close connection if requested or by default on http/1.0\n\n          var value = response.getField('Connection') || '';\n\n          if (value.indexOf('close') != -1 || response.version === 'HTTP/1.0' && response.getField('Keep-Alive') === null) {\n            socket.close();\n          } else {\n            _handleNextRequest(client, socket);\n          }\n        }\n      }\n    }\n  };\n\n  socket.error = function (e) {\n    // do error callback, include request\n    socket.options.error({\n      type: e.type,\n      message: e.message,\n      request: socket.options.request,\n      response: socket.options.response,\n      socket: socket\n    });\n    socket.close();\n  }; // wrap socket for TLS\n\n\n  if (tlsOptions) {\n    socket = forge.tls.wrapSocket({\n      sessionId: null,\n      sessionCache: {},\n      caStore: tlsOptions.caStore,\n      cipherSuites: tlsOptions.cipherSuites,\n      socket: socket,\n      virtualHost: tlsOptions.virtualHost,\n      verify: tlsOptions.verify,\n      getCertificate: tlsOptions.getCertificate,\n      getPrivateKey: tlsOptions.getPrivateKey,\n      getSignature: tlsOptions.getSignature,\n      deflate: tlsOptions.deflate || null,\n      inflate: tlsOptions.inflate || null\n    });\n    socket.options = null;\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n\n    if (tlsOptions.prime) {\n      // prime socket by connecting and caching TLS session, will do\n      // next request from there\n      socket.connect({\n        host: client.url.host,\n        port: client.url.port,\n        policyPort: client.policyPort,\n        policyUrl: client.policyUrl\n      });\n    } else {\n      // do not prime socket, just add as idle\n      client.idle.push(socket);\n    }\n  } else {\n    // no need to prime non-TLS sockets\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    client.idle.push(socket);\n  }\n};\n/**\n * Checks to see if the given cookie has expired. If the cookie's max-age\n * plus its created time is less than the time now, it has expired, unless\n * its max-age is set to -1 which indicates it will never expire.\n *\n * @param cookie the cookie to check.\n *\n * @return true if it has expired, false if not.\n */\n\n\nvar _hasCookieExpired = function (cookie) {\n  var rval = false;\n\n  if (cookie.maxAge !== -1) {\n    var now = _getUtcTime(new Date());\n\n    var expires = cookie.created + cookie.maxAge;\n\n    if (expires <= now) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n/**\n * Adds cookies in the given client to the given request.\n *\n * @param client the client.\n * @param request the request.\n */\n\n\nvar _writeCookies = function (client, request) {\n  var expired = [];\n  var url = client.url;\n  var cookies = client.cookies;\n\n  for (var name in cookies) {\n    // get cookie paths\n    var paths = cookies[name];\n\n    for (var p in paths) {\n      var cookie = paths[p];\n\n      if (_hasCookieExpired(cookie)) {\n        // store for clean up\n        expired.push(cookie);\n      } else if (request.path.indexOf(cookie.path) === 0) {\n        // path or path's ancestor must match cookie.path\n        request.addCookie(cookie);\n      }\n    }\n  } // clean up expired cookies\n\n\n  for (var i = 0; i < expired.length; ++i) {\n    var cookie = expired[i];\n    client.removeCookie(cookie.name, cookie.path);\n  }\n};\n/**\n * Gets cookies from the given response and adds the to the given client.\n *\n * @param client the client.\n * @param response the response.\n */\n\n\nvar _readCookies = function (client, response) {\n  var cookies = response.getCookies();\n\n  for (var i = 0; i < cookies.length; ++i) {\n    try {\n      client.setCookie(cookies[i]);\n    } catch (ex) {// ignore failure to add other-domain, etc. cookies\n    }\n  }\n};\n/**\n * Creates an http client that uses forge.net sockets as a backend and\n * forge.tls for security.\n *\n * @param options:\n *   url: the url to connect to (scheme://host:port).\n *     socketPool: the flash socket pool to use.\n *   policyPort: the flash policy port to use (if other than the\n *     socket pool default), use 0 for flash default.\n *   policyUrl: the flash policy file URL to use (if provided will\n *     be used instead of a policy port).\n *   connections: number of connections to use to handle requests.\n *   caCerts: an array of certificates to trust for TLS, certs may\n *     be PEM-formatted or cert objects produced via forge.pki.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   virtualHost: the virtual server name to use in a TLS SNI\n *     extension, if not provided the url host will be used.\n *   verify: a custom TLS certificate verify callback to use.\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side\n *     private key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side\n *     signature (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local\n *     storage, false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on\n *     their creation so that they will cache TLS sessions for reuse.\n *\n * @return the client.\n */\n\n\nhttp.createClient = function (options) {\n  // create CA store to share with all TLS connections\n  var caStore = null;\n\n  if (options.caCerts) {\n    caStore = forge.pki.createCaStore(options.caCerts);\n  } // get scheme, host, and port from url\n\n\n  options.url = options.url || window.location.protocol + '//' + window.location.host;\n  var url = http.parseUrl(options.url);\n\n  if (!url) {\n    var error = new Error('Invalid url.');\n    error.details = {\n      url: options.url\n    };\n    throw error;\n  } // default to 1 connection\n\n\n  options.connections = options.connections || 1; // create client\n\n  var sp = options.socketPool;\n  var client = {\n    // url\n    url: url,\n    // socket pool\n    socketPool: sp,\n    // the policy port to use\n    policyPort: options.policyPort,\n    // policy url to use\n    policyUrl: options.policyUrl,\n    // queue of requests to service\n    requests: [],\n    // all sockets\n    sockets: [],\n    // idle sockets\n    idle: [],\n    // whether or not the connections are secure\n    secure: url.scheme === 'https',\n    // cookie jar (key'd off of name and then path, there is only 1 domain\n    // and one setting for secure per client so name+path is unique)\n    cookies: {},\n    // default to flash storage of cookies\n    persistCookies: typeof options.persistCookies === 'undefined' ? true : options.persistCookies\n  }; // add client to debug storage\n\n  if (forge.debug) {\n    forge.debug.get('forge.http', 'clients').push(client);\n  } // load cookies from disk\n\n\n  _loadCookies(client);\n  /**\n   * A default certificate verify function that checks a certificate common\n   * name against the client's URL host.\n   *\n   * @param c the TLS connection.\n   * @param verified true if cert is verified, otherwise alert number.\n   * @param depth the chain depth.\n   * @param certs the cert chain.\n   *\n   * @return true if verified and the common name matches the host, error\n   *         otherwise.\n   */\n\n\n  var _defaultCertificateVerify = function (c, verified, depth, certs) {\n    if (depth === 0 && verified === true) {\n      // compare common name to url host\n      var cn = certs[depth].subject.getField('CN');\n\n      if (cn === null || client.url.host !== cn.value) {\n        verified = {\n          message: 'Certificate common name does not match url host.'\n        };\n      }\n    }\n\n    return verified;\n  }; // determine if TLS is used\n\n\n  var tlsOptions = null;\n\n  if (client.secure) {\n    tlsOptions = {\n      caStore: caStore,\n      cipherSuites: options.cipherSuites || null,\n      virtualHost: options.virtualHost || url.host,\n      verify: options.verify || _defaultCertificateVerify,\n      getCertificate: options.getCertificate || null,\n      getPrivateKey: options.getPrivateKey || null,\n      getSignature: options.getSignature || null,\n      prime: options.primeTlsSockets || false\n    }; // if socket pool uses a flash api, then add deflate support to TLS\n\n    if (sp.flashApi !== null) {\n      tlsOptions.deflate = function (bytes) {\n        // strip 2 byte zlib header and 4 byte trailer\n        return forge.util.deflate(sp.flashApi, bytes, true);\n      };\n\n      tlsOptions.inflate = function (bytes) {\n        return forge.util.inflate(sp.flashApi, bytes, true);\n      };\n    }\n  } // create and initialize sockets\n\n\n  for (var i = 0; i < options.connections; ++i) {\n    _initSocket(client, sp.createSocket(), tlsOptions);\n  }\n  /**\n   * Sends a request. A method 'abort' will be set on the request that\n   * can be called to attempt to abort the request.\n   *\n   * @param options:\n   *          request: the request to send.\n   *          connected: a callback for when the connection is open.\n   *          closed: a callback for when the connection is closed.\n   *          headerReady: a callback for when the response header arrives.\n   *          bodyReady: a callback for when the response body arrives.\n   *          error: a callback for if an error occurs.\n   */\n\n\n  client.send = function (options) {\n    // add host header if not set\n    if (options.request.getField('Host') === null) {\n      options.request.setField('Host', client.url.fullHost);\n    } // set default dummy handlers\n\n\n    var opts = {};\n    opts.request = options.request;\n\n    opts.connected = options.connected || function () {};\n\n    opts.closed = options.close || function () {};\n\n    opts.headerReady = function (e) {\n      // read cookies\n      _readCookies(client, e.response);\n\n      if (options.headerReady) {\n        options.headerReady(e);\n      }\n    };\n\n    opts.bodyReady = options.bodyReady || function () {};\n\n    opts.error = options.error || function () {}; // create response\n\n\n    opts.response = http.createResponse();\n    opts.response.time = 0;\n    opts.response.flashApi = client.socketPool.flashApi;\n    opts.request.flashApi = client.socketPool.flashApi; // create abort function\n\n    opts.request.abort = function () {\n      // set aborted, clear handlers\n      opts.request.aborted = true;\n\n      opts.connected = function () {};\n\n      opts.closed = function () {};\n\n      opts.headerReady = function () {};\n\n      opts.bodyReady = function () {};\n\n      opts.error = function () {};\n    }; // add cookies to request\n\n\n    _writeCookies(client, opts.request); // queue request options if there are no idle sockets\n\n\n    if (client.idle.length === 0) {\n      client.requests.push(opts);\n    } else {\n      // use an idle socket, prefer an idle *connected* socket first\n      var socket = null;\n      var len = client.idle.length;\n\n      for (var i = 0; socket === null && i < len; ++i) {\n        socket = client.idle[i];\n\n        if (socket.isConnected()) {\n          client.idle.splice(i, 1);\n        } else {\n          socket = null;\n        }\n      } // no connected socket available, get unconnected socket\n\n\n      if (socket === null) {\n        socket = client.idle.pop();\n      }\n\n      socket.options = opts;\n\n      _doRequest(client, socket);\n    }\n  };\n  /**\n   * Destroys this client.\n   */\n\n\n  client.destroy = function () {\n    // clear pending requests, close and destroy sockets\n    client.requests = [];\n\n    for (var i = 0; i < client.sockets.length; ++i) {\n      client.sockets[i].close();\n      client.sockets[i].destroy();\n    }\n\n    client.socketPool = null;\n    client.sockets = [];\n    client.idle = [];\n  };\n  /**\n   * Sets a cookie for use with all connections made by this client. Any\n   * cookie with the same name will be replaced. If the cookie's value\n   * is undefined, null, or the blank string, the cookie will be removed.\n   *\n   * If the cookie's domain doesn't match this client's url host or the\n   * cookie's secure flag doesn't match this client's url scheme, then\n   * setting the cookie will fail with an exception.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n\n\n  client.setCookie = function (cookie) {\n    var rval;\n\n    if (typeof cookie.name !== 'undefined') {\n      if (cookie.value === null || typeof cookie.value === 'undefined' || cookie.value === '') {\n        // remove cookie\n        rval = client.removeCookie(cookie.name, cookie.path);\n      } else {\n        // set cookie defaults\n        cookie.comment = cookie.comment || '';\n        cookie.maxAge = cookie.maxAge || 0;\n        cookie.secure = typeof cookie.secure === 'undefined' ? true : cookie.secure;\n        cookie.httpOnly = cookie.httpOnly || true;\n        cookie.path = cookie.path || '/';\n        cookie.domain = cookie.domain || null;\n        cookie.version = cookie.version || null;\n        cookie.created = _getUtcTime(new Date()); // do secure check\n\n        if (cookie.secure !== client.secure) {\n          var error = new Error('Http client url scheme is incompatible ' + 'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        } // make sure url host is within cookie.domain\n\n\n        if (!http.withinCookieDomain(client.url, cookie)) {\n          var error = new Error('Http client url scheme is incompatible ' + 'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        } // add new cookie\n\n\n        if (!(cookie.name in client.cookies)) {\n          client.cookies[cookie.name] = {};\n        }\n\n        client.cookies[cookie.name][cookie.path] = cookie;\n        rval = true; // save cookies\n\n        _saveCookies(client);\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Gets a cookie by its name.\n   *\n   * @param name the name of the cookie to retrieve.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return the cookie or null if not found.\n   */\n\n\n  client.getCookie = function (name, path) {\n    var rval = null;\n\n    if (name in client.cookies) {\n      var paths = client.cookies[name]; // get path-specific cookie\n\n      if (path) {\n        if (path in paths) {\n          rval = paths[path];\n        }\n      } else {\n        // get first cookie\n        for (var p in paths) {\n          rval = paths[p];\n          break;\n        }\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie to remove.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n\n\n  client.removeCookie = function (name, path) {\n    var rval = false;\n\n    if (name in client.cookies) {\n      // delete the specific path\n      if (path) {\n        var paths = client.cookies[name];\n\n        if (path in paths) {\n          rval = true;\n          delete client.cookies[name][path]; // clean up entry if empty\n\n          var empty = true;\n\n          for (var i in client.cookies[name]) {\n            empty = false;\n            break;\n          }\n\n          if (empty) {\n            delete client.cookies[name];\n          }\n        }\n      } else {\n        // delete all cookies with the given name\n        rval = true;\n        delete client.cookies[name];\n      }\n    }\n\n    if (rval) {\n      // save cookies\n      _saveCookies(client);\n    }\n\n    return rval;\n  };\n  /**\n   * Clears all cookies stored in this client.\n   */\n\n\n  client.clearCookies = function () {\n    client.cookies = {};\n\n    _clearCookies(client);\n  };\n\n  if (forge.log) {\n    forge.log.debug('forge.http', 'created client', options);\n  }\n\n  return client;\n};\n/**\n * Trims the whitespace off of the beginning and end of a string.\n *\n * @param str the string to trim.\n *\n * @return the trimmed string.\n */\n\n\nvar _trimString = function (str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n};\n/**\n * Creates an http header object.\n *\n * @return the http header object.\n */\n\n\nvar _createHeader = function () {\n  var header = {\n    fields: {},\n    setField: function (name, value) {\n      // normalize field name, trim value\n      header.fields[_normalize(name)] = [_trimString('' + value)];\n    },\n    appendField: function (name, value) {\n      name = _normalize(name);\n\n      if (!(name in header.fields)) {\n        header.fields[name] = [];\n      }\n\n      header.fields[name].push(_trimString('' + value));\n    },\n    getField: function (name, index) {\n      var rval = null;\n      name = _normalize(name);\n\n      if (name in header.fields) {\n        index = index || 0;\n        rval = header.fields[name][index];\n      }\n\n      return rval;\n    }\n  };\n  return header;\n};\n/**\n * Gets the time in utc seconds given a date.\n *\n * @param d the date to use.\n *\n * @return the time in utc seconds.\n */\n\n\nvar _getUtcTime = function (d) {\n  var utc = +d + d.getTimezoneOffset() * 60000;\n  return Math.floor(+new Date() / 1000);\n};\n/**\n * Creates an http request.\n *\n * @param options:\n *          version: the version.\n *          method: the method.\n *          path: the path.\n *          body: the body.\n *          headers: custom header fields to add,\n *            eg: [{'Content-Length': 0}].\n *\n * @return the http request.\n */\n\n\nhttp.createRequest = function (options) {\n  options = options || {};\n\n  var request = _createHeader();\n\n  request.version = options.version || 'HTTP/1.1';\n  request.method = options.method || null;\n  request.path = options.path || null;\n  request.body = options.body || null;\n  request.bodyDeflated = false;\n  request.flashApi = null; // add custom headers\n\n  var headers = options.headers || [];\n\n  if (!forge.util.isArray(headers)) {\n    headers = [headers];\n  }\n\n  for (var i = 0; i < headers.length; ++i) {\n    for (var name in headers[i]) {\n      request.appendField(name, headers[i][name]);\n    }\n  }\n  /**\n   * Adds a cookie to the request 'Cookie' header.\n   *\n   * @param cookie a cookie to add.\n   */\n\n\n  request.addCookie = function (cookie) {\n    var value = '';\n    var field = request.getField('Cookie');\n\n    if (field !== null) {\n      // separate cookies by semi-colons\n      value = field + '; ';\n    } // get current time in utc seconds\n\n\n    var now = _getUtcTime(new Date()); // output cookie name and value\n\n\n    value += cookie.name + '=' + cookie.value;\n    request.setField('Cookie', value);\n  };\n  /**\n   * Converts an http request into a string that can be sent as an\n   * HTTP request. Does not include any data.\n   *\n   * @return the string representation of the request.\n   */\n\n\n  request.toString = function () {\n    /* Sample request header:\n      GET /some/path/?query HTTP/1.1\n      Host: www.someurl.com\n      Connection: close\n      Accept-Encoding: deflate\n      Accept: image/gif, text/html\n      User-Agent: Mozilla 4.0\n     */\n    // set default headers\n    if (request.getField('User-Agent') === null) {\n      request.setField('User-Agent', 'forge.http 1.0');\n    }\n\n    if (request.getField('Accept') === null) {\n      request.setField('Accept', '*/*');\n    }\n\n    if (request.getField('Connection') === null) {\n      request.setField('Connection', 'keep-alive');\n      request.setField('Keep-Alive', '115');\n    } // add Accept-Encoding if not specified\n\n\n    if (request.flashApi !== null && request.getField('Accept-Encoding') === null) {\n      request.setField('Accept-Encoding', 'deflate');\n    } // if the body isn't null, deflate it if its larger than 100 bytes\n\n\n    if (request.flashApi !== null && request.body !== null && request.getField('Content-Encoding') === null && !request.bodyDeflated && request.body.length > 100) {\n      // use flash to compress data\n      request.body = forge.util.deflate(request.flashApi, request.body);\n      request.bodyDeflated = true;\n      request.setField('Content-Encoding', 'deflate');\n      request.setField('Content-Length', request.body.length);\n    } else if (request.body !== null) {\n      // set content length for body\n      request.setField('Content-Length', request.body.length);\n    } // build start line\n\n\n    var rval = request.method.toUpperCase() + ' ' + request.path + ' ' + request.version + '\\r\\n'; // add each header\n\n    for (var name in request.fields) {\n      var fields = request.fields[name];\n\n      for (var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    } // final terminating CRLF\n\n\n    rval += '\\r\\n';\n    return rval;\n  };\n\n  return request;\n};\n/**\n * Creates an empty http response header.\n *\n * @return the empty http response header.\n */\n\n\nhttp.createResponse = function () {\n  // private vars\n  var _first = true;\n  var _chunkSize = 0;\n  var _chunksFinished = false; // create response\n\n  var response = _createHeader();\n\n  response.version = null;\n  response.code = 0;\n  response.message = null;\n  response.body = null;\n  response.headerReceived = false;\n  response.bodyReceived = false;\n  response.flashApi = null;\n  /**\n   * Reads a line that ends in CRLF from a byte buffer.\n   *\n   * @param b the byte buffer.\n   *\n   * @return the line or null if none was found.\n   */\n\n  var _readCrlf = function (b) {\n    var line = null;\n    var i = b.data.indexOf('\\r\\n', b.read);\n\n    if (i != -1) {\n      // read line, skip CRLF\n      line = b.getBytes(i - b.read);\n      b.getBytes(2);\n    }\n\n    return line;\n  };\n  /**\n   * Parses a header field and appends it to the response.\n   *\n   * @param line the header field line.\n   */\n\n\n  var _parseHeader = function (line) {\n    var tmp = line.indexOf(':');\n    var name = line.substring(0, tmp++);\n    response.appendField(name, tmp < line.length ? line.substring(tmp) : '');\n  };\n  /**\n   * Reads an http response header from a buffer of bytes.\n   *\n   * @param b the byte buffer to parse the header from.\n   *\n   * @return true if the whole header was read, false if not.\n   */\n\n\n  response.readHeader = function (b) {\n    // read header lines (each ends in CRLF)\n    var line = '';\n\n    while (!response.headerReceived && line !== null) {\n      line = _readCrlf(b);\n\n      if (line !== null) {\n        // parse first line\n        if (_first) {\n          _first = false;\n          var tmp = line.split(' ');\n\n          if (tmp.length >= 3) {\n            response.version = tmp[0];\n            response.code = parseInt(tmp[1], 10);\n            response.message = tmp.slice(2).join(' ');\n          } else {\n            // invalid header\n            var error = new Error('Invalid http response header.');\n            error.details = {\n              'line': line\n            };\n            throw error;\n          }\n        } else if (line.length === 0) {\n          // handle final line, end of header\n          response.headerReceived = true;\n        } else {\n          _parseHeader(line);\n        }\n      }\n    }\n\n    return response.headerReceived;\n  };\n  /**\n   * Reads some chunked http response entity-body from the given buffer of\n   * bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n\n\n  var _readChunkedBody = function (b) {\n    /* Chunked transfer-encoding sends data in a series of chunks,\n      followed by a set of 0-N http trailers.\n      The format is as follows:\n       chunk-size (in hex) CRLF\n      chunk data (with \"chunk-size\" many bytes) CRLF\n      ... (N many chunks)\n      chunk-size (of 0 indicating the last chunk) CRLF\n      N many http trailers followed by CRLF\n      blank line + CRLF (terminates the trailers)\n       If there are no http trailers, then after the chunk-size of 0,\n      there is still a single CRLF (indicating the blank line + CRLF\n      that terminates the trailers). In other words, you always terminate\n      the trailers with blank line + CRLF, regardless of 0-N trailers. */\n\n    /* From RFC-2616, section 3.6.1, here is the pseudo-code for\n    implementing chunked transfer-encoding:\n     length := 0\n    read chunk-size, chunk-extension (if any) and CRLF\n    while (chunk-size > 0) {\n      read chunk-data and CRLF\n      append chunk-data to entity-body\n      length := length + chunk-size\n      read chunk-size and CRLF\n    }\n    read entity-header\n    while (entity-header not empty) {\n      append entity-header to existing header fields\n      read entity-header\n    }\n    Content-Length := length\n    Remove \"chunked\" from Transfer-Encoding\n    */\n    var line = '';\n\n    while (line !== null && b.length() > 0) {\n      // if in the process of reading a chunk\n      if (_chunkSize > 0) {\n        // if there are not enough bytes to read chunk and its\n        // trailing CRLF,  we must wait for more data to be received\n        if (_chunkSize + 2 > b.length()) {\n          break;\n        } // read chunk data, skip CRLF\n\n\n        response.body += b.getBytes(_chunkSize);\n        b.getBytes(2);\n        _chunkSize = 0;\n      } else if (!_chunksFinished) {\n        // more chunks, read next chunk-size line\n        line = _readCrlf(b);\n\n        if (line !== null) {\n          // parse chunk-size (ignore any chunk extension)\n          _chunkSize = parseInt(line.split(';', 1)[0], 16);\n          _chunksFinished = _chunkSize === 0;\n        }\n      } else {\n        // chunks finished, read next trailer\n        line = _readCrlf(b);\n\n        while (line !== null) {\n          if (line.length > 0) {\n            // parse trailer\n            _parseHeader(line); // read next trailer\n\n\n            line = _readCrlf(b);\n          } else {\n            // body received\n            response.bodyReceived = true;\n            line = null;\n          }\n        }\n      }\n    }\n\n    return response.bodyReceived;\n  };\n  /**\n   * Reads an http response body from a buffer of bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n\n\n  response.readBody = function (b) {\n    var contentLength = response.getField('Content-Length');\n    var transferEncoding = response.getField('Transfer-Encoding');\n\n    if (contentLength !== null) {\n      contentLength = parseInt(contentLength);\n    } // read specified length\n\n\n    if (contentLength !== null && contentLength >= 0) {\n      response.body = response.body || '';\n      response.body += b.getBytes(contentLength);\n      response.bodyReceived = response.body.length === contentLength;\n    } else if (transferEncoding !== null) {\n      // read chunked encoding\n      if (transferEncoding.indexOf('chunked') != -1) {\n        response.body = response.body || '';\n\n        _readChunkedBody(b);\n      } else {\n        var error = new Error('Unknown Transfer-Encoding.');\n        error.details = {\n          'transferEncoding': transferEncoding\n        };\n        throw error;\n      }\n    } else if (contentLength !== null && contentLength < 0 || contentLength === null && response.getField('Content-Type') !== null) {\n      // read all data in the buffer\n      response.body = response.body || '';\n      response.body += b.getBytes();\n      response.readBodyUntilClose = true;\n    } else {\n      // no body\n      response.body = null;\n      response.bodyReceived = true;\n    }\n\n    if (response.bodyReceived) {\n      response.time = +new Date() - response.time;\n    }\n\n    if (response.flashApi !== null && response.bodyReceived && response.body !== null && response.getField('Content-Encoding') === 'deflate') {\n      // inflate using flash api\n      response.body = forge.util.inflate(response.flashApi, response.body);\n    }\n\n    return response.bodyReceived;\n  };\n  /**\n   * Parses an array of cookies from the 'Set-Cookie' field, if present.\n   *\n   * @return the array of cookies.\n   */\n\n\n  response.getCookies = function () {\n    var rval = []; // get Set-Cookie field\n\n    if ('Set-Cookie' in response.fields) {\n      var field = response.fields['Set-Cookie']; // get current local time in seconds\n\n      var now = +new Date() / 1000; // regex for parsing 'name1=value1; name2=value2; name3'\n\n      var regex = /\\s*([^=]*)=?([^;]*)(;|$)/g; // examples:\n      // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/\n      // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/\n\n      for (var i = 0; i < field.length; ++i) {\n        var fv = field[i];\n        var m;\n        regex.lastIndex = 0;\n        var first = true;\n        var cookie = {};\n\n        do {\n          m = regex.exec(fv);\n\n          if (m !== null) {\n            var name = _trimString(m[1]);\n\n            var value = _trimString(m[2]); // cookie_name=value\n\n\n            if (first) {\n              cookie.name = name;\n              cookie.value = value;\n              first = false;\n            } else {\n              // property_name=value\n              name = name.toLowerCase();\n\n              switch (name) {\n                case 'expires':\n                  // replace hyphens w/spaces so date will parse\n                  value = value.replace(/-/g, ' ');\n                  var secs = Date.parse(value) / 1000;\n                  cookie.maxAge = Math.max(0, secs - now);\n                  break;\n\n                case 'max-age':\n                  cookie.maxAge = parseInt(value, 10);\n                  break;\n\n                case 'secure':\n                  cookie.secure = true;\n                  break;\n\n                case 'httponly':\n                  cookie.httpOnly = true;\n                  break;\n\n                default:\n                  if (name !== '') {\n                    cookie[name] = value;\n                  }\n\n              }\n            }\n          }\n        } while (m !== null && m[0] !== '');\n\n        rval.push(cookie);\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Converts an http response into a string that can be sent as an\n   * HTTP response. Does not include any data.\n   *\n   * @return the string representation of the response.\n   */\n\n\n  response.toString = function () {\n    /* Sample response header:\n      HTTP/1.0 200 OK\n      Host: www.someurl.com\n      Connection: close\n     */\n    // build start line\n    var rval = response.version + ' ' + response.code + ' ' + response.message + '\\r\\n'; // add each header\n\n    for (var name in response.fields) {\n      var fields = response.fields[name];\n\n      for (var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    } // final terminating CRLF\n\n\n    rval += '\\r\\n';\n    return rval;\n  };\n\n  return response;\n};\n/**\n * Parses the scheme, host, and port from an http(s) url.\n *\n * @param str the url string.\n *\n * @return the parsed url object or null if the url is invalid.\n */\n\n\nhttp.parseUrl = forge.util.parseUrl;\n/**\n * Returns true if the given url is within the given cookie's domain.\n *\n * @param url the url to check.\n * @param cookie the cookie or cookie domain to check.\n */\n\nhttp.withinCookieDomain = function (url, cookie) {\n  var rval = false; // cookie may be null, a cookie object, or a domain string\n\n  var domain = cookie === null || typeof cookie === 'string' ? cookie : cookie.domain; // any domain will do\n\n  if (domain === null) {\n    rval = true;\n  } else if (domain.charAt(0) === '.') {\n    // ensure domain starts with a '.'\n    // parse URL as necessary\n    if (typeof url === 'string') {\n      url = http.parseUrl(url);\n    } // add '.' to front of URL host to match against domain\n\n\n    var host = '.' + url.host; // if the host ends with domain then it falls within it\n\n    var idx = host.lastIndexOf(domain);\n\n    if (idx !== -1 && idx + domain.length === host.length) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/node-forge/lib/http.js"],"names":["forge","require","http","module","exports","cat","debug","set","_normalize","name","toLowerCase","replace","a","toUpperCase","_getStorageId","client","url","scheme","host","port","_loadCookies","persistCookies","cookies","util","getItem","socketPool","flashApi","ex","_saveCookies","setItem","_clearCookies","clearItems","_doRequest","socket","isConnected","options","request","connectTime","Date","connected","type","id","connect","policyPort","policyUrl","_handleNextRequest","buffer","clear","pending","requests","length","shift","aborted","idle","push","retries","_initSocket","tlsOptions","e","close","out","toString","body","time","send","response","sending","closed","error","message","bytesAvailable","readBodyUntilClose","bodyReceived","bodyReady","data","bytes","receive","putBytes","headerReceived","readHeader","headerReady","readBody","value","getField","indexOf","version","tls","wrapSocket","sessionId","sessionCache","caStore","cipherSuites","virtualHost","verify","getCertificate","getPrivateKey","getSignature","deflate","inflate","createBuffer","sockets","prime","_hasCookieExpired","cookie","rval","maxAge","now","_getUtcTime","expires","created","_writeCookies","expired","paths","p","path","addCookie","i","removeCookie","_readCookies","getCookies","setCookie","createClient","caCerts","pki","createCaStore","window","location","protocol","parseUrl","Error","details","connections","sp","secure","get","_defaultCertificateVerify","c","verified","depth","certs","cn","subject","primeTlsSockets","createSocket","setField","fullHost","opts","createResponse","abort","len","splice","pop","destroy","comment","httpOnly","domain","withinCookieDomain","getCookie","empty","clearCookies","log","_trimString","str","_createHeader","header","fields","appendField","index","d","utc","getTimezoneOffset","Math","floor","createRequest","method","bodyDeflated","headers","isArray","field","_first","_chunkSize","_chunksFinished","code","_readCrlf","b","line","read","getBytes","_parseHeader","tmp","substring","split","parseInt","slice","join","_readChunkedBody","contentLength","transferEncoding","regex","fv","m","lastIndex","first","exec","secs","parse","max","charAt","idx","lastIndexOf"],"mappings":"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","sourcesContent":["/**\n * HTTP client-side implementation that uses forge.net sockets.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\nrequire('./debug');\nrequire('./tls');\nrequire('./util');\n\n// define http namespace\nvar http = module.exports = forge.http = forge.http || {};\n\n// logging category\nvar cat = 'forge.http';\n\n// add array of clients to debug storage\nif(forge.debug) {\n  forge.debug.set('forge.http', 'clients', []);\n}\n\n// normalizes an http header field name\nvar _normalize = function(name) {\n  return name.toLowerCase().replace(/(^.)|(-.)/g,\n    function(a) {return a.toUpperCase();});\n};\n\n/**\n * Gets the local storage ID for the given client.\n *\n * @param client the client to get the local storage ID for.\n *\n * @return the local storage ID to use.\n */\nvar _getStorageId = function(client) {\n  // TODO: include browser in ID to avoid sharing cookies between\n  // browsers (if this is undesirable)\n  // navigator.userAgent\n  return 'forge.http.' +\n    client.url.scheme + '.' +\n    client.url.host + '.' +\n    client.url.port;\n};\n\n/**\n * Loads persistent cookies from disk for the given client.\n *\n * @param client the client.\n */\nvar _loadCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      var cookies = forge.util.getItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies');\n      client.cookies = cookies || {};\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Saves persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _saveCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      forge.util.setItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies', client.cookies);\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n\n  // FIXME: remove me\n  _loadCookies(client);\n};\n\n/**\n * Clears persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _clearCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      // only thing stored is 'cookies', so clear whole storage\n      forge.util.clearItems(\n        client.socketPool.flashApi,\n        _getStorageId(client));\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Connects and sends a request.\n *\n * @param client the http client.\n * @param socket the socket to use.\n */\nvar _doRequest = function(client, socket) {\n  if(socket.isConnected()) {\n    // already connected\n    socket.options.request.connectTime = +new Date();\n    socket.connected({\n      type: 'connect',\n      id: socket.id\n    });\n  } else {\n    // connect\n    socket.options.request.connectTime = +new Date();\n    socket.connect({\n      host: client.url.host,\n      port: client.url.port,\n      policyPort: client.policyPort,\n      policyUrl: client.policyUrl\n    });\n  }\n};\n\n/**\n * Handles the next request or marks a socket as idle.\n *\n * @param client the http client.\n * @param socket the socket.\n */\nvar _handleNextRequest = function(client, socket) {\n  // clear buffer\n  socket.buffer.clear();\n\n  // get pending request\n  var pending = null;\n  while(pending === null && client.requests.length > 0) {\n    pending = client.requests.shift();\n    if(pending.request.aborted) {\n      pending = null;\n    }\n  }\n\n  // mark socket idle if no pending requests\n  if(pending === null) {\n    if(socket.options !== null) {\n      socket.options = null;\n    }\n    client.idle.push(socket);\n  } else {\n    // handle pending request, allow 1 retry\n    socket.retries = 1;\n    socket.options = pending;\n    _doRequest(client, socket);\n  }\n};\n\n/**\n * Sets up a socket for use with an http client.\n *\n * @param client the parent http client.\n * @param socket the socket to set up.\n * @param tlsOptions if the socket must use TLS, the TLS options.\n */\nvar _initSocket = function(client, socket, tlsOptions) {\n  // no socket options yet\n  socket.options = null;\n\n  // set up handlers\n  socket.connected = function(e) {\n    // socket primed by caching TLS session, handle next request\n    if(socket.options === null) {\n      _handleNextRequest(client, socket);\n    } else {\n      // socket in use\n      var request = socket.options.request;\n      request.connectTime = +new Date() - request.connectTime;\n      e.socket = socket;\n      socket.options.connected(e);\n      if(request.aborted) {\n        socket.close();\n      } else {\n        var out = request.toString();\n        if(request.body) {\n          out += request.body;\n        }\n        request.time = +new Date();\n        socket.send(out);\n        request.time = +new Date() - request.time;\n        socket.options.response.time = +new Date();\n        socket.sending = true;\n      }\n    }\n  };\n  socket.closed = function(e) {\n    if(socket.sending) {\n      socket.sending = false;\n      if(socket.retries > 0) {\n        --socket.retries;\n        _doRequest(client, socket);\n      } else {\n        // error, closed during send\n        socket.error({\n          id: socket.id,\n          type: 'ioError',\n          message: 'Connection closed during send. Broken pipe.',\n          bytesAvailable: 0\n        });\n      }\n    } else {\n      // handle unspecified content-length transfer\n      var response = socket.options.response;\n      if(response.readBodyUntilClose) {\n        response.time = +new Date() - response.time;\n        response.bodyReceived = true;\n        socket.options.bodyReady({\n          request: socket.options.request,\n          response: response,\n          socket: socket\n        });\n      }\n      socket.options.closed(e);\n      _handleNextRequest(client, socket);\n    }\n  };\n  socket.data = function(e) {\n    socket.sending = false;\n    var request = socket.options.request;\n    if(request.aborted) {\n      socket.close();\n    } else {\n      // receive all bytes available\n      var response = socket.options.response;\n      var bytes = socket.receive(e.bytesAvailable);\n      if(bytes !== null) {\n        // receive header and then body\n        socket.buffer.putBytes(bytes);\n        if(!response.headerReceived) {\n          response.readHeader(socket.buffer);\n          if(response.headerReceived) {\n            socket.options.headerReady({\n              request: socket.options.request,\n              response: response,\n              socket: socket\n            });\n          }\n        }\n        if(response.headerReceived && !response.bodyReceived) {\n          response.readBody(socket.buffer);\n        }\n        if(response.bodyReceived) {\n          socket.options.bodyReady({\n            request: socket.options.request,\n            response: response,\n            socket: socket\n          });\n          // close connection if requested or by default on http/1.0\n          var value = response.getField('Connection') || '';\n          if(value.indexOf('close') != -1 ||\n            (response.version === 'HTTP/1.0' &&\n            response.getField('Keep-Alive') === null)) {\n            socket.close();\n          } else {\n            _handleNextRequest(client, socket);\n          }\n        }\n      }\n    }\n  };\n  socket.error = function(e) {\n    // do error callback, include request\n    socket.options.error({\n      type: e.type,\n      message: e.message,\n      request: socket.options.request,\n      response: socket.options.response,\n      socket: socket\n    });\n    socket.close();\n  };\n\n  // wrap socket for TLS\n  if(tlsOptions) {\n    socket = forge.tls.wrapSocket({\n      sessionId: null,\n      sessionCache: {},\n      caStore: tlsOptions.caStore,\n      cipherSuites: tlsOptions.cipherSuites,\n      socket: socket,\n      virtualHost: tlsOptions.virtualHost,\n      verify: tlsOptions.verify,\n      getCertificate: tlsOptions.getCertificate,\n      getPrivateKey: tlsOptions.getPrivateKey,\n      getSignature: tlsOptions.getSignature,\n      deflate: tlsOptions.deflate || null,\n      inflate: tlsOptions.inflate || null\n    });\n\n    socket.options = null;\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    if(tlsOptions.prime) {\n      // prime socket by connecting and caching TLS session, will do\n      // next request from there\n      socket.connect({\n        host: client.url.host,\n        port: client.url.port,\n        policyPort: client.policyPort,\n        policyUrl: client.policyUrl\n      });\n    } else {\n      // do not prime socket, just add as idle\n      client.idle.push(socket);\n    }\n  } else {\n    // no need to prime non-TLS sockets\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    client.idle.push(socket);\n  }\n};\n\n/**\n * Checks to see if the given cookie has expired. If the cookie's max-age\n * plus its created time is less than the time now, it has expired, unless\n * its max-age is set to -1 which indicates it will never expire.\n *\n * @param cookie the cookie to check.\n *\n * @return true if it has expired, false if not.\n */\nvar _hasCookieExpired = function(cookie) {\n  var rval = false;\n\n  if(cookie.maxAge !== -1) {\n    var now = _getUtcTime(new Date());\n    var expires = cookie.created + cookie.maxAge;\n    if(expires <= now) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Adds cookies in the given client to the given request.\n *\n * @param client the client.\n * @param request the request.\n */\nvar _writeCookies = function(client, request) {\n  var expired = [];\n  var url = client.url;\n  var cookies = client.cookies;\n  for(var name in cookies) {\n    // get cookie paths\n    var paths = cookies[name];\n    for(var p in paths) {\n      var cookie = paths[p];\n      if(_hasCookieExpired(cookie)) {\n        // store for clean up\n        expired.push(cookie);\n      } else if(request.path.indexOf(cookie.path) === 0) {\n        // path or path's ancestor must match cookie.path\n        request.addCookie(cookie);\n      }\n    }\n  }\n\n  // clean up expired cookies\n  for(var i = 0; i < expired.length; ++i) {\n    var cookie = expired[i];\n    client.removeCookie(cookie.name, cookie.path);\n  }\n};\n\n/**\n * Gets cookies from the given response and adds the to the given client.\n *\n * @param client the client.\n * @param response the response.\n */\nvar _readCookies = function(client, response) {\n  var cookies = response.getCookies();\n  for(var i = 0; i < cookies.length; ++i) {\n    try {\n      client.setCookie(cookies[i]);\n    } catch(ex) {\n      // ignore failure to add other-domain, etc. cookies\n    }\n  }\n};\n\n/**\n * Creates an http client that uses forge.net sockets as a backend and\n * forge.tls for security.\n *\n * @param options:\n *   url: the url to connect to (scheme://host:port).\n *     socketPool: the flash socket pool to use.\n *   policyPort: the flash policy port to use (if other than the\n *     socket pool default), use 0 for flash default.\n *   policyUrl: the flash policy file URL to use (if provided will\n *     be used instead of a policy port).\n *   connections: number of connections to use to handle requests.\n *   caCerts: an array of certificates to trust for TLS, certs may\n *     be PEM-formatted or cert objects produced via forge.pki.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   virtualHost: the virtual server name to use in a TLS SNI\n *     extension, if not provided the url host will be used.\n *   verify: a custom TLS certificate verify callback to use.\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side\n *     private key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side\n *     signature (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local\n *     storage, false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on\n *     their creation so that they will cache TLS sessions for reuse.\n *\n * @return the client.\n */\nhttp.createClient = function(options) {\n  // create CA store to share with all TLS connections\n  var caStore = null;\n  if(options.caCerts) {\n    caStore = forge.pki.createCaStore(options.caCerts);\n  }\n\n  // get scheme, host, and port from url\n  options.url = (options.url ||\n    window.location.protocol + '//' + window.location.host);\n  var url = http.parseUrl(options.url);\n  if(!url) {\n    var error = new Error('Invalid url.');\n    error.details = {url: options.url};\n    throw error;\n  }\n\n  // default to 1 connection\n  options.connections = options.connections || 1;\n\n  // create client\n  var sp = options.socketPool;\n  var client = {\n    // url\n    url: url,\n    // socket pool\n    socketPool: sp,\n    // the policy port to use\n    policyPort: options.policyPort,\n    // policy url to use\n    policyUrl: options.policyUrl,\n    // queue of requests to service\n    requests: [],\n    // all sockets\n    sockets: [],\n    // idle sockets\n    idle: [],\n    // whether or not the connections are secure\n    secure: (url.scheme === 'https'),\n    // cookie jar (key'd off of name and then path, there is only 1 domain\n    // and one setting for secure per client so name+path is unique)\n    cookies: {},\n    // default to flash storage of cookies\n    persistCookies: (typeof(options.persistCookies) === 'undefined') ?\n      true : options.persistCookies\n  };\n\n  // add client to debug storage\n  if(forge.debug) {\n    forge.debug.get('forge.http', 'clients').push(client);\n  }\n\n  // load cookies from disk\n  _loadCookies(client);\n\n  /**\n   * A default certificate verify function that checks a certificate common\n   * name against the client's URL host.\n   *\n   * @param c the TLS connection.\n   * @param verified true if cert is verified, otherwise alert number.\n   * @param depth the chain depth.\n   * @param certs the cert chain.\n   *\n   * @return true if verified and the common name matches the host, error\n   *         otherwise.\n   */\n  var _defaultCertificateVerify = function(c, verified, depth, certs) {\n    if(depth === 0 && verified === true) {\n      // compare common name to url host\n      var cn = certs[depth].subject.getField('CN');\n      if(cn === null || client.url.host !== cn.value) {\n        verified = {\n          message: 'Certificate common name does not match url host.'\n        };\n      }\n    }\n    return verified;\n  };\n\n  // determine if TLS is used\n  var tlsOptions = null;\n  if(client.secure) {\n    tlsOptions = {\n      caStore: caStore,\n      cipherSuites: options.cipherSuites || null,\n      virtualHost: options.virtualHost || url.host,\n      verify: options.verify || _defaultCertificateVerify,\n      getCertificate: options.getCertificate || null,\n      getPrivateKey: options.getPrivateKey || null,\n      getSignature: options.getSignature || null,\n      prime: options.primeTlsSockets || false\n    };\n\n    // if socket pool uses a flash api, then add deflate support to TLS\n    if(sp.flashApi !== null) {\n      tlsOptions.deflate = function(bytes) {\n        // strip 2 byte zlib header and 4 byte trailer\n        return forge.util.deflate(sp.flashApi, bytes, true);\n      };\n      tlsOptions.inflate = function(bytes) {\n        return forge.util.inflate(sp.flashApi, bytes, true);\n      };\n    }\n  }\n\n  // create and initialize sockets\n  for(var i = 0; i < options.connections; ++i) {\n    _initSocket(client, sp.createSocket(), tlsOptions);\n  }\n\n  /**\n   * Sends a request. A method 'abort' will be set on the request that\n   * can be called to attempt to abort the request.\n   *\n   * @param options:\n   *          request: the request to send.\n   *          connected: a callback for when the connection is open.\n   *          closed: a callback for when the connection is closed.\n   *          headerReady: a callback for when the response header arrives.\n   *          bodyReady: a callback for when the response body arrives.\n   *          error: a callback for if an error occurs.\n   */\n  client.send = function(options) {\n    // add host header if not set\n    if(options.request.getField('Host') === null) {\n      options.request.setField('Host', client.url.fullHost);\n    }\n\n    // set default dummy handlers\n    var opts = {};\n    opts.request = options.request;\n    opts.connected = options.connected || function() {};\n    opts.closed = options.close || function() {};\n    opts.headerReady = function(e) {\n      // read cookies\n      _readCookies(client, e.response);\n      if(options.headerReady) {\n        options.headerReady(e);\n      }\n    };\n    opts.bodyReady = options.bodyReady || function() {};\n    opts.error = options.error || function() {};\n\n    // create response\n    opts.response = http.createResponse();\n    opts.response.time = 0;\n    opts.response.flashApi = client.socketPool.flashApi;\n    opts.request.flashApi = client.socketPool.flashApi;\n\n    // create abort function\n    opts.request.abort = function() {\n      // set aborted, clear handlers\n      opts.request.aborted = true;\n      opts.connected = function() {};\n      opts.closed = function() {};\n      opts.headerReady = function() {};\n      opts.bodyReady = function() {};\n      opts.error = function() {};\n    };\n\n    // add cookies to request\n    _writeCookies(client, opts.request);\n\n    // queue request options if there are no idle sockets\n    if(client.idle.length === 0) {\n      client.requests.push(opts);\n    } else {\n      // use an idle socket, prefer an idle *connected* socket first\n      var socket = null;\n      var len = client.idle.length;\n      for(var i = 0; socket === null && i < len; ++i) {\n        socket = client.idle[i];\n        if(socket.isConnected()) {\n          client.idle.splice(i, 1);\n        } else {\n          socket = null;\n        }\n      }\n      // no connected socket available, get unconnected socket\n      if(socket === null) {\n        socket = client.idle.pop();\n      }\n      socket.options = opts;\n      _doRequest(client, socket);\n    }\n  };\n\n  /**\n   * Destroys this client.\n   */\n  client.destroy = function() {\n    // clear pending requests, close and destroy sockets\n    client.requests = [];\n    for(var i = 0; i < client.sockets.length; ++i) {\n      client.sockets[i].close();\n      client.sockets[i].destroy();\n    }\n    client.socketPool = null;\n    client.sockets = [];\n    client.idle = [];\n  };\n\n  /**\n   * Sets a cookie for use with all connections made by this client. Any\n   * cookie with the same name will be replaced. If the cookie's value\n   * is undefined, null, or the blank string, the cookie will be removed.\n   *\n   * If the cookie's domain doesn't match this client's url host or the\n   * cookie's secure flag doesn't match this client's url scheme, then\n   * setting the cookie will fail with an exception.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n  client.setCookie = function(cookie) {\n    var rval;\n    if(typeof(cookie.name) !== 'undefined') {\n      if(cookie.value === null || typeof(cookie.value) === 'undefined' ||\n        cookie.value === '') {\n        // remove cookie\n        rval = client.removeCookie(cookie.name, cookie.path);\n      } else {\n        // set cookie defaults\n        cookie.comment = cookie.comment || '';\n        cookie.maxAge = cookie.maxAge || 0;\n        cookie.secure = (typeof(cookie.secure) === 'undefined') ?\n          true : cookie.secure;\n        cookie.httpOnly = cookie.httpOnly || true;\n        cookie.path = cookie.path || '/';\n        cookie.domain = cookie.domain || null;\n        cookie.version = cookie.version || null;\n        cookie.created = _getUtcTime(new Date());\n\n        // do secure check\n        if(cookie.secure !== client.secure) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n        // make sure url host is within cookie.domain\n        if(!http.withinCookieDomain(client.url, cookie)) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n\n        // add new cookie\n        if(!(cookie.name in client.cookies)) {\n          client.cookies[cookie.name] = {};\n        }\n        client.cookies[cookie.name][cookie.path] = cookie;\n        rval = true;\n\n        // save cookies\n        _saveCookies(client);\n      }\n    }\n\n    return rval;\n  };\n\n  /**\n   * Gets a cookie by its name.\n   *\n   * @param name the name of the cookie to retrieve.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return the cookie or null if not found.\n   */\n  client.getCookie = function(name, path) {\n    var rval = null;\n    if(name in client.cookies) {\n      var paths = client.cookies[name];\n\n      // get path-specific cookie\n      if(path) {\n        if(path in paths) {\n          rval = paths[path];\n        }\n      } else {\n        // get first cookie\n        for(var p in paths) {\n          rval = paths[p];\n          break;\n        }\n      }\n    }\n    return rval;\n  };\n\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie to remove.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n  client.removeCookie = function(name, path) {\n    var rval = false;\n    if(name in client.cookies) {\n      // delete the specific path\n      if(path) {\n        var paths = client.cookies[name];\n        if(path in paths) {\n          rval = true;\n          delete client.cookies[name][path];\n          // clean up entry if empty\n          var empty = true;\n          for(var i in client.cookies[name]) {\n            empty = false;\n            break;\n          }\n          if(empty) {\n            delete client.cookies[name];\n          }\n        }\n      } else {\n        // delete all cookies with the given name\n        rval = true;\n        delete client.cookies[name];\n      }\n    }\n    if(rval) {\n      // save cookies\n      _saveCookies(client);\n    }\n    return rval;\n  };\n\n  /**\n   * Clears all cookies stored in this client.\n   */\n  client.clearCookies = function() {\n    client.cookies = {};\n    _clearCookies(client);\n  };\n\n  if(forge.log) {\n    forge.log.debug('forge.http', 'created client', options);\n  }\n\n  return client;\n};\n\n/**\n * Trims the whitespace off of the beginning and end of a string.\n *\n * @param str the string to trim.\n *\n * @return the trimmed string.\n */\nvar _trimString = function(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n};\n\n/**\n * Creates an http header object.\n *\n * @return the http header object.\n */\nvar _createHeader = function() {\n  var header = {\n    fields: {},\n    setField: function(name, value) {\n      // normalize field name, trim value\n      header.fields[_normalize(name)] = [_trimString('' + value)];\n    },\n    appendField: function(name, value) {\n      name = _normalize(name);\n      if(!(name in header.fields)) {\n        header.fields[name] = [];\n      }\n      header.fields[name].push(_trimString('' + value));\n    },\n    getField: function(name, index) {\n      var rval = null;\n      name = _normalize(name);\n      if(name in header.fields) {\n        index = index || 0;\n        rval = header.fields[name][index];\n      }\n      return rval;\n    }\n  };\n  return header;\n};\n\n/**\n * Gets the time in utc seconds given a date.\n *\n * @param d the date to use.\n *\n * @return the time in utc seconds.\n */\nvar _getUtcTime = function(d) {\n  var utc = +d + d.getTimezoneOffset() * 60000;\n  return Math.floor(+new Date() / 1000);\n};\n\n/**\n * Creates an http request.\n *\n * @param options:\n *          version: the version.\n *          method: the method.\n *          path: the path.\n *          body: the body.\n *          headers: custom header fields to add,\n *            eg: [{'Content-Length': 0}].\n *\n * @return the http request.\n */\nhttp.createRequest = function(options) {\n  options = options || {};\n  var request = _createHeader();\n  request.version = options.version || 'HTTP/1.1';\n  request.method = options.method || null;\n  request.path = options.path || null;\n  request.body = options.body || null;\n  request.bodyDeflated = false;\n  request.flashApi = null;\n\n  // add custom headers\n  var headers = options.headers || [];\n  if(!forge.util.isArray(headers)) {\n    headers = [headers];\n  }\n  for(var i = 0; i < headers.length; ++i) {\n    for(var name in headers[i]) {\n      request.appendField(name, headers[i][name]);\n    }\n  }\n\n  /**\n   * Adds a cookie to the request 'Cookie' header.\n   *\n   * @param cookie a cookie to add.\n   */\n  request.addCookie = function(cookie) {\n    var value = '';\n    var field = request.getField('Cookie');\n    if(field !== null) {\n      // separate cookies by semi-colons\n      value = field + '; ';\n    }\n\n    // get current time in utc seconds\n    var now = _getUtcTime(new Date());\n\n    // output cookie name and value\n    value += cookie.name + '=' + cookie.value;\n    request.setField('Cookie', value);\n  };\n\n  /**\n   * Converts an http request into a string that can be sent as an\n   * HTTP request. Does not include any data.\n   *\n   * @return the string representation of the request.\n   */\n  request.toString = function() {\n    /* Sample request header:\n      GET /some/path/?query HTTP/1.1\n      Host: www.someurl.com\n      Connection: close\n      Accept-Encoding: deflate\n      Accept: image/gif, text/html\n      User-Agent: Mozilla 4.0\n     */\n\n    // set default headers\n    if(request.getField('User-Agent') === null) {\n      request.setField('User-Agent', 'forge.http 1.0');\n    }\n    if(request.getField('Accept') === null) {\n      request.setField('Accept', '*/*');\n    }\n    if(request.getField('Connection') === null) {\n      request.setField('Connection', 'keep-alive');\n      request.setField('Keep-Alive', '115');\n    }\n\n    // add Accept-Encoding if not specified\n    if(request.flashApi !== null &&\n      request.getField('Accept-Encoding') === null) {\n      request.setField('Accept-Encoding', 'deflate');\n    }\n\n    // if the body isn't null, deflate it if its larger than 100 bytes\n    if(request.flashApi !== null && request.body !== null &&\n      request.getField('Content-Encoding') === null &&\n      !request.bodyDeflated && request.body.length > 100) {\n      // use flash to compress data\n      request.body = forge.util.deflate(request.flashApi, request.body);\n      request.bodyDeflated = true;\n      request.setField('Content-Encoding', 'deflate');\n      request.setField('Content-Length', request.body.length);\n    } else if(request.body !== null) {\n      // set content length for body\n      request.setField('Content-Length', request.body.length);\n    }\n\n    // build start line\n    var rval =\n      request.method.toUpperCase() + ' ' + request.path + ' ' +\n      request.version + '\\r\\n';\n\n    // add each header\n    for(var name in request.fields) {\n      var fields = request.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return request;\n};\n\n/**\n * Creates an empty http response header.\n *\n * @return the empty http response header.\n */\nhttp.createResponse = function() {\n  // private vars\n  var _first = true;\n  var _chunkSize = 0;\n  var _chunksFinished = false;\n\n  // create response\n  var response = _createHeader();\n  response.version = null;\n  response.code = 0;\n  response.message = null;\n  response.body = null;\n  response.headerReceived = false;\n  response.bodyReceived = false;\n  response.flashApi = null;\n\n  /**\n   * Reads a line that ends in CRLF from a byte buffer.\n   *\n   * @param b the byte buffer.\n   *\n   * @return the line or null if none was found.\n   */\n  var _readCrlf = function(b) {\n    var line = null;\n    var i = b.data.indexOf('\\r\\n', b.read);\n    if(i != -1) {\n      // read line, skip CRLF\n      line = b.getBytes(i - b.read);\n      b.getBytes(2);\n    }\n    return line;\n  };\n\n  /**\n   * Parses a header field and appends it to the response.\n   *\n   * @param line the header field line.\n   */\n  var _parseHeader = function(line) {\n    var tmp = line.indexOf(':');\n    var name = line.substring(0, tmp++);\n    response.appendField(\n      name, (tmp < line.length) ? line.substring(tmp) : '');\n  };\n\n  /**\n   * Reads an http response header from a buffer of bytes.\n   *\n   * @param b the byte buffer to parse the header from.\n   *\n   * @return true if the whole header was read, false if not.\n   */\n  response.readHeader = function(b) {\n    // read header lines (each ends in CRLF)\n    var line = '';\n    while(!response.headerReceived && line !== null) {\n      line = _readCrlf(b);\n      if(line !== null) {\n        // parse first line\n        if(_first) {\n          _first = false;\n          var tmp = line.split(' ');\n          if(tmp.length >= 3) {\n            response.version = tmp[0];\n            response.code = parseInt(tmp[1], 10);\n            response.message = tmp.slice(2).join(' ');\n          } else {\n            // invalid header\n            var error = new Error('Invalid http response header.');\n            error.details = {'line': line};\n            throw error;\n          }\n        } else if(line.length === 0) {\n          // handle final line, end of header\n          response.headerReceived = true;\n        } else {\n          _parseHeader(line);\n        }\n      }\n    }\n\n    return response.headerReceived;\n  };\n\n  /**\n   * Reads some chunked http response entity-body from the given buffer of\n   * bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  var _readChunkedBody = function(b) {\n    /* Chunked transfer-encoding sends data in a series of chunks,\n      followed by a set of 0-N http trailers.\n      The format is as follows:\n\n      chunk-size (in hex) CRLF\n      chunk data (with \"chunk-size\" many bytes) CRLF\n      ... (N many chunks)\n      chunk-size (of 0 indicating the last chunk) CRLF\n      N many http trailers followed by CRLF\n      blank line + CRLF (terminates the trailers)\n\n      If there are no http trailers, then after the chunk-size of 0,\n      there is still a single CRLF (indicating the blank line + CRLF\n      that terminates the trailers). In other words, you always terminate\n      the trailers with blank line + CRLF, regardless of 0-N trailers. */\n\n      /* From RFC-2616, section 3.6.1, here is the pseudo-code for\n      implementing chunked transfer-encoding:\n\n      length := 0\n      read chunk-size, chunk-extension (if any) and CRLF\n      while (chunk-size > 0) {\n        read chunk-data and CRLF\n        append chunk-data to entity-body\n        length := length + chunk-size\n        read chunk-size and CRLF\n      }\n      read entity-header\n      while (entity-header not empty) {\n        append entity-header to existing header fields\n        read entity-header\n      }\n      Content-Length := length\n      Remove \"chunked\" from Transfer-Encoding\n    */\n\n    var line = '';\n    while(line !== null && b.length() > 0) {\n      // if in the process of reading a chunk\n      if(_chunkSize > 0) {\n        // if there are not enough bytes to read chunk and its\n        // trailing CRLF,  we must wait for more data to be received\n        if(_chunkSize + 2 > b.length()) {\n          break;\n        }\n\n        // read chunk data, skip CRLF\n        response.body += b.getBytes(_chunkSize);\n        b.getBytes(2);\n        _chunkSize = 0;\n      } else if(!_chunksFinished) {\n        // more chunks, read next chunk-size line\n        line = _readCrlf(b);\n        if(line !== null) {\n          // parse chunk-size (ignore any chunk extension)\n          _chunkSize = parseInt(line.split(';', 1)[0], 16);\n          _chunksFinished = (_chunkSize === 0);\n        }\n      } else {\n        // chunks finished, read next trailer\n        line = _readCrlf(b);\n        while(line !== null) {\n          if(line.length > 0) {\n            // parse trailer\n            _parseHeader(line);\n            // read next trailer\n            line = _readCrlf(b);\n          } else {\n            // body received\n            response.bodyReceived = true;\n            line = null;\n          }\n        }\n      }\n    }\n\n    return response.bodyReceived;\n  };\n\n  /**\n   * Reads an http response body from a buffer of bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  response.readBody = function(b) {\n    var contentLength = response.getField('Content-Length');\n    var transferEncoding = response.getField('Transfer-Encoding');\n    if(contentLength !== null) {\n      contentLength = parseInt(contentLength);\n    }\n\n    // read specified length\n    if(contentLength !== null && contentLength >= 0) {\n      response.body = response.body || '';\n      response.body += b.getBytes(contentLength);\n      response.bodyReceived = (response.body.length === contentLength);\n    } else if(transferEncoding !== null) {\n      // read chunked encoding\n      if(transferEncoding.indexOf('chunked') != -1) {\n        response.body = response.body || '';\n        _readChunkedBody(b);\n      } else {\n        var error = new Error('Unknown Transfer-Encoding.');\n        error.details = {'transferEncoding': transferEncoding};\n        throw error;\n      }\n    } else if((contentLength !== null && contentLength < 0) ||\n      (contentLength === null &&\n      response.getField('Content-Type') !== null)) {\n      // read all data in the buffer\n      response.body = response.body || '';\n      response.body += b.getBytes();\n      response.readBodyUntilClose = true;\n    } else {\n      // no body\n      response.body = null;\n      response.bodyReceived = true;\n    }\n\n    if(response.bodyReceived) {\n      response.time = +new Date() - response.time;\n    }\n\n    if(response.flashApi !== null &&\n      response.bodyReceived && response.body !== null &&\n      response.getField('Content-Encoding') === 'deflate') {\n      // inflate using flash api\n      response.body = forge.util.inflate(\n        response.flashApi, response.body);\n    }\n\n    return response.bodyReceived;\n  };\n\n   /**\n    * Parses an array of cookies from the 'Set-Cookie' field, if present.\n    *\n    * @return the array of cookies.\n    */\n   response.getCookies = function() {\n     var rval = [];\n\n     // get Set-Cookie field\n     if('Set-Cookie' in response.fields) {\n       var field = response.fields['Set-Cookie'];\n\n       // get current local time in seconds\n       var now = +new Date() / 1000;\n\n       // regex for parsing 'name1=value1; name2=value2; name3'\n       var regex = /\\s*([^=]*)=?([^;]*)(;|$)/g;\n\n       // examples:\n       // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/\n       // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/\n       for(var i = 0; i < field.length; ++i) {\n         var fv = field[i];\n         var m;\n         regex.lastIndex = 0;\n         var first = true;\n         var cookie = {};\n         do {\n           m = regex.exec(fv);\n           if(m !== null) {\n             var name = _trimString(m[1]);\n             var value = _trimString(m[2]);\n\n             // cookie_name=value\n             if(first) {\n               cookie.name = name;\n               cookie.value = value;\n               first = false;\n             } else {\n               // property_name=value\n               name = name.toLowerCase();\n               switch(name) {\n               case 'expires':\n                 // replace hyphens w/spaces so date will parse\n                 value = value.replace(/-/g, ' ');\n                 var secs = Date.parse(value) / 1000;\n                 cookie.maxAge = Math.max(0, secs - now);\n                 break;\n               case 'max-age':\n                 cookie.maxAge = parseInt(value, 10);\n                 break;\n               case 'secure':\n                 cookie.secure = true;\n                 break;\n               case 'httponly':\n                 cookie.httpOnly = true;\n                 break;\n               default:\n                 if(name !== '') {\n                   cookie[name] = value;\n                 }\n               }\n             }\n           }\n         } while(m !== null && m[0] !== '');\n         rval.push(cookie);\n       }\n     }\n\n     return rval;\n  };\n\n  /**\n   * Converts an http response into a string that can be sent as an\n   * HTTP response. Does not include any data.\n   *\n   * @return the string representation of the response.\n   */\n  response.toString = function() {\n    /* Sample response header:\n      HTTP/1.0 200 OK\n      Host: www.someurl.com\n      Connection: close\n     */\n\n    // build start line\n    var rval =\n      response.version + ' ' + response.code + ' ' + response.message + '\\r\\n';\n\n    // add each header\n    for(var name in response.fields) {\n      var fields = response.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return response;\n};\n\n/**\n * Parses the scheme, host, and port from an http(s) url.\n *\n * @param str the url string.\n *\n * @return the parsed url object or null if the url is invalid.\n */\nhttp.parseUrl = forge.util.parseUrl;\n\n/**\n * Returns true if the given url is within the given cookie's domain.\n *\n * @param url the url to check.\n * @param cookie the cookie or cookie domain to check.\n */\nhttp.withinCookieDomain = function(url, cookie) {\n  var rval = false;\n\n  // cookie may be null, a cookie object, or a domain string\n  var domain = (cookie === null || typeof cookie === 'string') ?\n    cookie : cookie.domain;\n\n  // any domain will do\n  if(domain === null) {\n    rval = true;\n  } else if(domain.charAt(0) === '.') {\n    // ensure domain starts with a '.'\n    // parse URL as necessary\n    if(typeof url === 'string') {\n      url = http.parseUrl(url);\n    }\n\n    // add '.' to front of URL host to match against domain\n    var host = '.' + url.host;\n\n    // if the host ends with domain then it falls within it\n    var idx = host.lastIndexOf(domain);\n    if(idx !== -1 && (idx + domain.length === host.length)) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n"]},"metadata":{},"sourceType":"script"}