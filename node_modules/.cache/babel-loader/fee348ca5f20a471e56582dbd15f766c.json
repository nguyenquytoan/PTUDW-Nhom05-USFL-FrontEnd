{"ast":null,"code":"/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow variable or `function` declarations in nested blocks\",\n      category: \"Possible Errors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-inner-declarations\"\n    },\n    schema: [{\n      enum: [\"functions\", \"both\"]\n    }]\n  },\n\n  create(context) {\n    /**\n     * Find the nearest Program or Function ancestor node.\n     * @returns {Object} Ancestor's type and distance from node.\n     */\n    function nearestBody() {\n      const ancestors = context.getAncestors();\n      let ancestor = ancestors.pop(),\n          generation = 1;\n\n      while (ancestor && [\"Program\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(ancestor.type) < 0) {\n        generation += 1;\n        ancestor = ancestors.pop();\n      }\n\n      return {\n        // Type of containing ancestor\n        type: ancestor.type,\n        // Separation between ancestor and node\n        distance: generation\n      };\n    }\n    /**\n     * Ensure that a given node is at a program or function body's root.\n     * @param {ASTNode} node Declaration node to check.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const body = nearestBody(),\n            valid = body.type === \"Program\" && body.distance === 1 || body.distance === 2;\n\n      if (!valid) {\n        context.report({\n          node,\n          message: \"Move {{type}} declaration to {{body}} root.\",\n          data: {\n            type: node.type === \"FunctionDeclaration\" ? \"function\" : \"variable\",\n            body: body.type === \"Program\" ? \"program\" : \"function body\"\n          }\n        });\n      }\n    }\n\n    return {\n      FunctionDeclaration: check,\n\n      VariableDeclaration(node) {\n        if (context.options[0] === \"both\" && node.kind === \"var\") {\n          check(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/no-inner-declarations.js"],"names":["module","exports","meta","type","docs","description","category","recommended","url","schema","enum","create","context","nearestBody","ancestors","getAncestors","ancestor","pop","generation","indexOf","distance","check","node","body","valid","report","message","data","FunctionDeclaration","VariableDeclaration","options","kind"],"mappings":"AAAA;;;;AAKA,a,CAEA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,SADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,+DADX;AAEFC,MAAAA,QAAQ,EAAE,iBAFR;AAGFC,MAAAA,WAAW,EAAE,IAHX;AAIFC,MAAAA,GAAG,EAAE;AAJH,KAHJ;AAUFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,WAAD,EAAc,MAAd;AADV,KADI;AAVN,GADO;;AAkBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ;;;;AAIA,aAASC,WAAT,GAAuB;AACnB,YAAMC,SAAS,GAAGF,OAAO,CAACG,YAAR,EAAlB;AACA,UAAIC,QAAQ,GAAGF,SAAS,CAACG,GAAV,EAAf;AAAA,UACIC,UAAU,GAAG,CADjB;;AAGA,aAAOF,QAAQ,IAAI,CAAC,SAAD,EAAY,qBAAZ,EACf,oBADe,EACO,yBADP,EAEjBG,OAFiB,CAETH,QAAQ,CAACb,IAFA,IAEQ,CAF3B,EAE8B;AAC1Be,QAAAA,UAAU,IAAI,CAAd;AACAF,QAAAA,QAAQ,GAAGF,SAAS,CAACG,GAAV,EAAX;AACH;;AAED,aAAO;AAEH;AACAd,QAAAA,IAAI,EAAEa,QAAQ,CAACb,IAHZ;AAKH;AACAiB,QAAAA,QAAQ,EAAEF;AANP,OAAP;AAQH;AAED;;;;;;;AAKA,aAASG,KAAT,CAAeC,IAAf,EAAqB;AACjB,YAAMC,IAAI,GAAGV,WAAW,EAAxB;AAAA,YACIW,KAAK,GAAKD,IAAI,CAACpB,IAAL,KAAc,SAAd,IAA2BoB,IAAI,CAACH,QAAL,KAAkB,CAA9C,IACLG,IAAI,CAACH,QAAL,KAAkB,CAF1B;;AAIA,UAAI,CAACI,KAAL,EAAY;AACRZ,QAAAA,OAAO,CAACa,MAAR,CAAe;AACXH,UAAAA,IADW;AAEXI,UAAAA,OAAO,EAAE,6CAFE;AAGXC,UAAAA,IAAI,EAAE;AACFxB,YAAAA,IAAI,EAAGmB,IAAI,CAACnB,IAAL,KAAc,qBAAd,GAAsC,UAAtC,GAAmD,UADxD;AAEFoB,YAAAA,IAAI,EAAGA,IAAI,CAACpB,IAAL,KAAc,SAAd,GAA0B,SAA1B,GAAsC;AAF3C;AAHK,SAAf;AAQH;AACJ;;AAED,WAAO;AAEHyB,MAAAA,mBAAmB,EAAEP,KAFlB;;AAGHQ,MAAAA,mBAAmB,CAACP,IAAD,EAAO;AACtB,YAAIV,OAAO,CAACkB,OAAR,CAAgB,CAAhB,MAAuB,MAAvB,IAAiCR,IAAI,CAACS,IAAL,KAAc,KAAnD,EAA0D;AACtDV,UAAAA,KAAK,CAACC,IAAD,CAAL;AACH;AACJ;;AAPE,KAAP;AAWH;;AA/EY,CAAjB","sourcesContent":["/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow variable or `function` declarations in nested blocks\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-inner-declarations\"\n        },\n\n        schema: [\n            {\n                enum: [\"functions\", \"both\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Find the nearest Program or Function ancestor node.\n         * @returns {Object} Ancestor's type and distance from node.\n         */\n        function nearestBody() {\n            const ancestors = context.getAncestors();\n            let ancestor = ancestors.pop(),\n                generation = 1;\n\n            while (ancestor && [\"Program\", \"FunctionDeclaration\",\n                \"FunctionExpression\", \"ArrowFunctionExpression\"\n            ].indexOf(ancestor.type) < 0) {\n                generation += 1;\n                ancestor = ancestors.pop();\n            }\n\n            return {\n\n                // Type of containing ancestor\n                type: ancestor.type,\n\n                // Separation between ancestor and node\n                distance: generation\n            };\n        }\n\n        /**\n         * Ensure that a given node is at a program or function body's root.\n         * @param {ASTNode} node Declaration node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const body = nearestBody(),\n                valid = ((body.type === \"Program\" && body.distance === 1) ||\n                    body.distance === 2);\n\n            if (!valid) {\n                context.report({\n                    node,\n                    message: \"Move {{type}} declaration to {{body}} root.\",\n                    data: {\n                        type: (node.type === \"FunctionDeclaration\" ? \"function\" : \"variable\"),\n                        body: (body.type === \"Program\" ? \"program\" : \"function body\")\n                    }\n                });\n            }\n        }\n\n        return {\n\n            FunctionDeclaration: check,\n            VariableDeclaration(node) {\n                if (context.options[0] === \"both\" && node.kind === \"var\") {\n                    check(node);\n                }\n            }\n\n        };\n\n    }\n};\n"]},"metadata":{},"sourceType":"script"}