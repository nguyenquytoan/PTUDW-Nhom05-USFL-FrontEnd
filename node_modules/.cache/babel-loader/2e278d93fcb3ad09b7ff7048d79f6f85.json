{"ast":null,"code":"/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks after each array element\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-element-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\"]\n      }, {\n        type: \"object\",\n        properties: {\n          multiline: {\n            type: \"boolean\"\n          },\n          minItems: {\n            type: [\"integer\", \"null\"],\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedLineBreak: \"There should be no linebreak here.\",\n      missingLineBreak: \"There should be a linebreak after this element.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} providedOption An option value to parse.\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n     */\n\n    function normalizeOptionValue(providedOption) {\n      let consistent = false;\n      let multiline = false;\n      let minItems;\n      const option = providedOption || \"always\";\n\n      if (!option || option === \"always\" || option.minItems === 0) {\n        minItems = 0;\n      } else if (option === \"never\") {\n        minItems = Number.POSITIVE_INFINITY;\n      } else if (option === \"consistent\") {\n        consistent = true;\n        minItems = Number.POSITIVE_INFINITY;\n      } else {\n        multiline = Boolean(option.multiline);\n        minItems = option.minItems || Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n    /**\n     * Normalizes a given option value.\n     * @param {string|Object|undefined} options An option value to parse.\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n     */\n\n\n    function normalizeOptions(options) {\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n    /**\n     * Reports that there shouldn't be a line break after the first token\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportNoLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedLineBreak\",\n\n        fix(fixer) {\n          if (astUtils.isCommentToken(tokenBefore)) {\n            return null;\n          }\n\n          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n          }\n          /*\n           * This will check if the comma is on the same line as the next element\n           * Following array:\n           * [\n           *     1\n           *     , 2\n           *     , 3\n           * ]\n           *\n           * will be fixed to:\n           * [\n           *     1, 2, 3\n           * ]\n           */\n\n\n          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(twoTokensBefore)) {\n            return null;\n          }\n\n          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n        }\n\n      });\n    }\n    /**\n     * Reports that there should be a line break after the first token\n     * @param {Token} token The token to use for the report.\n     * @returns {void}\n     */\n\n\n    function reportRequiredLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"missingLineBreak\",\n\n        fix(fixer) {\n          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n        }\n\n      });\n    }\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n     * @returns {void}\n     */\n\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n      let elementBreak = false;\n      /*\n       * MULTILINE: true\n       * loop through every element and check\n       * if at least one element has linebreaks inside\n       * this ensures that following is not valid (due to elements are on the same line):\n       *\n       * [\n       *      1,\n       *      2,\n       *      3\n       * ]\n       */\n\n      if (options.multiline) {\n        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);\n      }\n\n      const linebreaksCount = node.elements.map((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return false;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n      }).filter(isBreak => isBreak === true).length;\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;\n      elements.forEach((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n        if (needsLinebreaks) {\n          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportRequiredLineBreak(firstTokenOfCurrentElement);\n          }\n        } else {\n          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportNoLineBreak(firstTokenOfCurrentElement);\n          }\n        }\n      });\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/array-element-newline.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","providedOption","consistent","option","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","value","ArrayExpression","ArrayPattern","reportNoLineBreak","token","tokenBefore","getTokenBefore","includeComments","report","loc","start","end","messageId","fix","fixer","isCommentToken","isTokenOnSameLine","replaceTextRange","range","twoTokensBefore","reportRequiredLineBreak","check","node","elements","normalizedOptions","elementBreak","filter","element","some","line","linebreaksCount","map","i","previousElement","commaToken","getFirstTokenBetween","isCommaToken","lastTokenOfPreviousElement","firstTokenOfCurrentElement","getTokenAfter","isBreak","length","needsLinebreaks","forEach"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks after each array element\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-element-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLineBreak: \"There should be no linebreak here.\",\n            missingLineBreak: \"There should be a linebreak after this element.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} providedOption An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(providedOption) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            const option = providedOption || \"always\";\n\n            if (!option || option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else if (option === \"consistent\") {\n                consistent = true;\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"missingLineBreak\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            const linebreaksCount = node.elements.map((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return false;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n            }).filter(isBreak => isBreak === true).length;\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                ) ||\n                (\n                    options.consistent &&\n                    linebreaksCount > 0 &&\n                    linebreaksCount < node.elements.length\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}