{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.strategies = function (exports, logger_mjs, assert_mjs, cacheNames_mjs, cacheWrapper_mjs, fetchWrapper_mjs, getFriendlyURL_mjs, WorkboxError_mjs) {\n  'use strict';\n\n  try {\n    self['workbox:strategies:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const getFriendlyURL = url => {\n    const urlObj = new URL(url, location);\n\n    if (urlObj.origin === location.origin) {\n      return urlObj.pathname;\n    }\n\n    return urlObj.href;\n  };\n\n  const messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to ` + `respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: response => {\n      if (response) {\n        logger_mjs.logger.groupCollapsed(`View the final response here.`);\n        logger_mjs.logger.log(response);\n        logger_mjs.logger.groupEnd();\n      }\n    }\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n   * request strategy.\n   *\n   * A cache first strategy is useful for assets that have been revisioned,\n   * such as URLs like `/styles/example.a8f5f1.css`, since they\n   * can be cached for long periods of time.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._fetchOptions = options.fetchOptions || null;\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n           be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'CacheFirst',\n          funcName: 'makeRequest',\n          paramName: 'request'\n        });\n      }\n      let response = await cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      let error;\n\n      if (!response) {\n        {\n          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will respond with a network request.`);\n        }\n\n        try {\n          response = await this._getFromNetwork(request, event);\n        } catch (err) {\n          error = err;\n        }\n\n        {\n          if (response) {\n            logs.push(`Got response from network.`);\n          } else {\n            logs.push(`Unable to get a response from the network.`);\n          }\n        }\n      } else {\n        {\n          logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n        }\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n\n        for (let log of logs) {\n          logger_mjs.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {FetchEvent} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getFromNetwork(request, event) {\n      const response = await fetchWrapper_mjs.fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins\n      }); // Keep the service worker while we put the request to the cache\n\n      const responseClone = response.clone();\n      const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: responseClone,\n        event,\n        plugins: this._plugins\n      });\n\n      if (event) {\n        try {\n          event.waitUntil(cachePutPromise);\n        } catch (error) {\n          {\n            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n   * request strategy.\n   *\n   * This class is useful if you want to take advantage of any\n   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n   *\n   * If there is no cache match, this will throw a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n\n  class CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'CacheOnly',\n          funcName: 'makeRequest',\n          paramName: 'request'\n        });\n      }\n      const response = await cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n\n        if (response) {\n          logger_mjs.logger.log(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n          messages.printFinalResponse(response);\n        } else {\n          logger_mjs.logger.log(`No response found in the '${this._cacheName}' cache.`);\n        }\n\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: ({\n      response\n    }) => {\n      if (response.status === 200 || response.status === 0) {\n        return response;\n      }\n\n      return null;\n    }\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n   * request strategy.\n   *\n   * By default, this strategy will cache responses with a 200 status code as\n   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n   * Opaque responses are are cross-origin requests where the response doesn't\n   * support [CORS]{@link https://enable-cors.org/}.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n\n      if (options.plugins) {\n        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n      } else {\n        // No plugins passed in, use the default plugin.\n        this._plugins = [cacheOkAndOpaquePlugin];\n      }\n\n      this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n      {\n        if (this._networkTimeoutSeconds) {\n          assert_mjs.assert.isType(this._networkTimeoutSeconds, 'number', {\n            moduleName: 'workbox-strategies',\n            className: 'NetworkFirst',\n            funcName: 'constructor',\n            paramName: 'networkTimeoutSeconds'\n          });\n        }\n      }\n      this._fetchOptions = options.fetchOptions || null;\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'handle',\n          paramName: 'makeRequest'\n        });\n      }\n      const promises = [];\n      let timeoutId;\n\n      if (this._networkTimeoutSeconds) {\n        const {\n          id,\n          promise\n        } = this._getTimeoutPromise({\n          request,\n          event,\n          logs\n        });\n\n        timeoutId = id;\n        promises.push(promise);\n      }\n\n      const networkPromise = this._getNetworkPromise({\n        timeoutId,\n        request,\n        event,\n        logs\n      });\n\n      promises.push(networkPromise); // Promise.race() will resolve as soon as the first promise resolves.\n\n      let response = await Promise.race(promises); // If Promise.race() resolved with null, it might be due to a network\n      // timeout + a cache miss. If that were to happen, we'd rather wait until\n      // the networkPromise resolves instead of returning null.\n      // Note that it's fine to await an already-resolved promise, so we don't\n      // have to check to see if it's still \"in flight\".\n\n      if (!response) {\n        response = await networkPromise;\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n\n        for (let log of logs) {\n          logger_mjs.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n\n      return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    _getTimeoutPromise({\n      request,\n      logs,\n      event\n    }) {\n      let timeoutId;\n      const timeoutPromise = new Promise(resolve => {\n        const onNetworkTimeout = async () => {\n          {\n            logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);\n          }\n          resolve(await this._respondFromCache({\n            request,\n            event\n          }));\n        };\n\n        timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n      });\n      return {\n        promise: timeoutPromise,\n        id: timeoutId\n      };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getNetworkPromise({\n      timeoutId,\n      request,\n      logs,\n      event\n    }) {\n      let error;\n      let response;\n\n      try {\n        response = await fetchWrapper_mjs.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n      } catch (err) {\n        error = err;\n      }\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);\n        }\n      }\n\n      if (error || !response) {\n        response = await this._respondFromCache({\n          request,\n          event\n        });\n        {\n          if (response) {\n            logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n          } else {\n            logs.push(`No response found in the '${this._cacheName}' cache.`);\n          }\n        }\n      } else {\n        // Keep the service worker alive while we put the request in the cache\n        const responseClone = response.clone();\n        const cachePut = cacheWrapper_mjs.cacheWrapper.put({\n          cacheName: this._cacheName,\n          request,\n          response: responseClone,\n          event,\n          plugins: this._plugins\n        });\n\n        if (event) {\n          try {\n            // The event has been responded to so we can keep the SW alive to\n            // respond to the request\n            event.waitUntil(cachePut);\n          } catch (err) {\n            {\n              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n            }\n          }\n        }\n      }\n\n      return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n\n\n    _respondFromCache({\n      event,\n      request\n    }) {\n      return cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n   * request strategy.\n   *\n   * This class is useful if you want to take advantage of any\n   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n   *\n   * If the network request fails, this will throw a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n\n  class NetworkOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._fetchOptions = options.fetchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkOnly',\n          funcName: 'handle',\n          paramName: 'request'\n        });\n      }\n      let error;\n      let response;\n\n      try {\n        response = await fetchWrapper_mjs.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n      } catch (err) {\n        error = err;\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n\n        if (response) {\n          logger_mjs.logger.log(`Got response from network.`);\n        } else {\n          logger_mjs.logger.log(`Unable to get a response from the network.`);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n   * request strategy.\n   *\n   * Resources are requested from both the cache and the network in parallel.\n   * The strategy will respond with the cached version if available, otherwise\n   * wait for the network response. The cache is updated with the network response\n   * with each successful request.\n   *\n   * By default, this strategy will cache responses with a 200 status code as\n   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n   * Opaque responses are are cross-origin requests where the response doesn't\n   * support [CORS]{@link https://enable-cors.org/}.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n\n  class StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n\n      if (options.plugins) {\n        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n      } else {\n        // No plugins passed in, use the default plugin.\n        this._plugins = [cacheOkAndOpaquePlugin];\n      }\n\n      this._fetchOptions = options.fetchOptions || null;\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'StaleWhileRevalidate',\n          funcName: 'handle',\n          paramName: 'request'\n        });\n      }\n\n      const fetchAndCachePromise = this._getFromNetwork({\n        request,\n        event\n      });\n\n      let response = await cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      let error;\n\n      if (response) {\n        {\n          logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache. Will update with the network response in the background.`);\n        }\n\n        if (event) {\n          try {\n            event.waitUntil(fetchAndCachePromise);\n          } catch (error) {\n            {\n              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n            }\n          }\n        }\n      } else {\n        {\n          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will wait for the network response.`);\n        }\n\n        try {\n          response = await fetchAndCachePromise;\n        } catch (err) {\n          error = err;\n        }\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n\n        for (let log of logs) {\n          logger_mjs.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getFromNetwork({\n      request,\n      event\n    }) {\n      const response = await fetchWrapper_mjs.fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins\n      });\n      const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: response.clone(),\n        event,\n        plugins: this._plugins\n      });\n\n      if (event) {\n        try {\n          event.waitUntil(cachePutPromise);\n        } catch (error) {\n          {\n            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const mapping = {\n    cacheFirst: CacheFirst,\n    cacheOnly: CacheOnly,\n    networkFirst: NetworkFirst,\n    networkOnly: NetworkOnly,\n    staleWhileRevalidate: StaleWhileRevalidate\n  };\n\n  const deprecate = strategy => {\n    const StrategyCtr = mapping[strategy];\n    return options => {\n      {\n        const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\n        logger_mjs.logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` + `deprecated and will be removed in a future version of Workbox.\\n` + `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\n      }\n      return new StrategyCtr(options);\n    };\n  };\n  /**\n   * @function workbox.strategies.cacheFirst\n   * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n   * constructor for more info.\n   * @deprecated since v4.0.0\n   */\n\n\n  const cacheFirst = deprecate('cacheFirst');\n  /**\n   * @function workbox.strategies.cacheOnly\n   * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n   * constructor for more info.\n   * @deprecated since v4.0.0\n   */\n\n  const cacheOnly = deprecate('cacheOnly');\n  /**\n   * @function workbox.strategies.networkFirst\n   * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n   * constructor for more info.\n   * @deprecated since v4.0.0\n   */\n\n  const networkFirst = deprecate('networkFirst');\n  /**\n   * @function workbox.strategies.networkOnly\n   * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n   * constructor for more info.\n   * @deprecated since v4.0.0\n   */\n\n  const networkOnly = deprecate('networkOnly');\n  /**\n   * @function workbox.strategies.staleWhileRevalidate\n   * @param {Object} options See the\n   * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n   * @deprecated since v4.0.0\n   */\n\n  const staleWhileRevalidate = deprecate('staleWhileRevalidate');\n  exports.CacheFirst = CacheFirst;\n  exports.CacheOnly = CacheOnly;\n  exports.NetworkFirst = NetworkFirst;\n  exports.NetworkOnly = NetworkOnly;\n  exports.StaleWhileRevalidate = StaleWhileRevalidate;\n  exports.cacheFirst = cacheFirst;\n  exports.cacheOnly = cacheOnly;\n  exports.networkFirst = networkFirst;\n  exports.networkOnly = networkOnly;\n  exports.staleWhileRevalidate = staleWhileRevalidate;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.mjs","../utils/messages.mjs","../CacheFirst.mjs","../CacheOnly.mjs","../plugins/cacheOkAndOpaquePlugin.mjs","../NetworkFirst.mjs","../NetworkOnly.mjs","../StaleWhileRevalidate.mjs","../index.mjs"],"names":["self","_","getFriendlyURL","url","urlObj","location","messages","strategyStart","strategyName","request","printFinalResponse","response","logger","constructor","options","cacheNames","event","logs","assert","moduleName","className","funcName","paramName","cacheName","matchOptions","plugins","_plugins","_cacheName","error","WorkboxError","fetchOptions","responseClone","cachePutPromise","cacheOkAndOpaquePlugin","cacheWillUpdate","isUsingCacheWillUpdate","plugin","promises","promise","timeoutId","networkPromise","Promise","_getTimeoutPromise","timeoutPromise","resolve","onNetworkTimeout","_networkTimeoutSeconds","setTimeout","id","clearTimeout","cachePut","_respondFromCache","fetchAndCachePromise","mapping","cacheFirst","cacheOnly","networkFirst","networkOnly","staleWhileRevalidate","StaleWhileRevalidate","deprecate","strategy","StrategyCtr","strategyCtrName"],"mappings":"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","sourcesContent":["try{self['workbox:strategies:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport const messages = {\n  strategyStart: (strategyName, request) => `Using ${strategyName} to ` +\n    `respond to '${getFriendlyURL(request.url)}'`,\n  printFinalResponse: (response) => {\n    if (response) {\n      logger.groupCollapsed(`View the final response here.`);\n      logger.log(response);\n      logger.groupEnd();\n    }\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n         be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheFirst',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    let error;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `No response found in the '${this._cacheName}' cache. ` +\n          `Will respond with a network request.`);\n      }\n      try {\n        response = await this._getFromNetwork(request, event);\n      } catch (err) {\n        error = err;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(\n            `Found a cached response in the '${this._cacheName}' cache.`);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * Handles the network and cache part of CacheFirst.\n   *\n   * @param {Request} request\n   * @param {FetchEvent} [event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork(request, event) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    // Keep the service worker while we put the request to the cache\n    const responseClone = response.clone();\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: responseClone,\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {CacheFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheOnly {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'CacheOnly',\n        funcName: 'makeRequest',\n        paramName: 'request',\n      });\n    }\n\n    const response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('CacheOnly', request));\n      if (response) {\n        logger.log(`Found a cached response in the '${this._cacheName}'` +\n          ` cache.`);\n        messages.printFinalResponse(response);\n      } else {\n        logger.log(`No response found in the '${this._cacheName}' cache.`);\n      }\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url});\n    }\n    return response;\n  }\n}\n\nexport {CacheOnly};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\nexport const cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: ({response}) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkFirst {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   * @param {number} options.networkTimeoutSeconds If set, any network requests\n   * that fail to respond within the timeout will fallback to the cache.\n   *\n   * This option can be used to combat\n   * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n   * scenarios.\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._networkTimeoutSeconds) {\n        assert.isType(this._networkTimeoutSeconds, 'number', {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'constructor',\n          paramName: 'networkTimeoutSeconds',\n        });\n      }\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'NetworkFirst',\n        funcName: 'handle',\n        paramName: 'makeRequest',\n      });\n    }\n\n    const promises = [];\n    let timeoutId;\n\n    if (this._networkTimeoutSeconds) {\n      const {id, promise} = this._getTimeoutPromise({request, event, logs});\n      timeoutId = id;\n      promises.push(promise);\n    }\n\n    const networkPromise =\n        this._getNetworkPromise({timeoutId, request, event, logs});\n    promises.push(networkPromise);\n\n    // Promise.race() will resolve as soon as the first promise resolves.\n    let response = await Promise.race(promises);\n    // If Promise.race() resolved with null, it might be due to a network\n    // timeout + a cache miss. If that were to happen, we'd rather wait until\n    // the networkPromise resolves instead of returning null.\n    // Note that it's fine to await an already-resolved promise, so we don't\n    // have to check to see if it's still \"in flight\".\n    if (!response) {\n      response = await networkPromise;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('NetworkFirst', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs array\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  _getTimeoutPromise({request, logs, event}) {\n    let timeoutId;\n    const timeoutPromise = new Promise((resolve) => {\n      const onNetworkTimeout = async () => {\n        if (process.env.NODE_ENV !== 'production') {\n          logs.push(`Timing out the network response at ` +\n            `${this._networkTimeoutSeconds} seconds.`);\n        }\n\n        resolve(await this._respondFromCache({request, event}));\n      };\n\n      timeoutId = setTimeout(\n          onNetworkTimeout,\n          this._networkTimeoutSeconds * 1000,\n      );\n    });\n\n    return {\n      promise: timeoutPromise,\n      id: timeoutId,\n    };\n  }\n\n  /**\n   * @param {Object} options\n   * @param {number|undefined} options.timeoutId\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs Array.\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getNetworkPromise({timeoutId, request, logs, event}) {\n    let error;\n    let response;\n    try {\n      response = await fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins,\n      });\n    } catch (err) {\n      error = err;\n    }\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (response) {\n        logs.push(`Got response from network.`);\n      } else {\n        logs.push(`Unable to get a response from the network. Will respond ` +\n          `with a cached response.`);\n      }\n    }\n\n    if (error || !response) {\n      response = await this._respondFromCache({request, event});\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Found a cached response in the '${this._cacheName}'` +\n            ` cache.`);\n        } else {\n          logs.push(`No response found in the '${this._cacheName}' cache.`);\n        }\n      }\n    } else {\n      // Keep the service worker alive while we put the request in the cache\n      const responseClone = response.clone();\n      const cachePut = cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: responseClone,\n        event,\n        plugins: this._plugins,\n      });\n\n      if (event) {\n        try {\n          // The event has been responded to so we can keep the SW alive to\n          // respond to the request\n          event.waitUntil(cachePut);\n        } catch (err) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * Used if the network timeouts or fails to make the request.\n   *\n   * @param {Object} options\n   * @param {Request} request The request to match in the cache\n   * @param {Event} [options.event]\n   * @return {Promise<Object>}\n   *\n   * @private\n   */\n  _respondFromCache({event, request}) {\n    return cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n  }\n}\n\nexport {NetworkFirst};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass NetworkOnly {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n    this._fetchOptions = options.fetchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'NetworkOnly',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    let error;\n    let response;\n    try {\n      response = await fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins,\n      });\n    } catch (err) {\n      error = err;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('NetworkOnly', request));\n      if (response) {\n        logger.log(`Got response from network.`);\n      } else {\n        logger.log(`Unable to get a response from the network.`);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n}\n\nexport {NetworkOnly};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\n\nimport {messages} from './utils/messages.mjs';\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass StaleWhileRevalidate {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n    this._plugins = options.plugins || [];\n\n    if (options.plugins) {\n      let isUsingCacheWillUpdate =\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n      this._plugins = isUsingCacheWillUpdate ?\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to run this strategy for.\n   * @param {Event} [options.event] The event that triggered the request.\n   * @return {Promise<Response>}\n   */\n  async handle({event, request}) {\n    return this.makeRequest({\n      event,\n      request: request || event.request,\n    });\n  }\n  /**\n   * This method can be used to perform a make a standalone request outside the\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n   * for more usage information.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request Either a\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n   *     object, or a string URL, corresponding to the request to be made.\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n   *     be called automatically to extend the service worker's lifetime.\n   * @return {Promise<Response>}\n   */\n  async makeRequest({event, request}) {\n    const logs = [];\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: 'StaleWhileRevalidate',\n        funcName: 'handle',\n        paramName: 'request',\n      });\n    }\n\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\n\n    let response = await cacheWrapper.match({\n      cacheName: this._cacheName,\n      request,\n      event,\n      matchOptions: this._matchOptions,\n      plugins: this._plugins,\n    });\n    let error;\n    if (response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\n          ` cache. Will update with the network response in the background.`);\n      }\n\n      if (event) {\n        try {\n          event.waitUntil(fetchAndCachePromise);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to ensure service worker stays alive when ` +\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\n          `Will wait for the network response.`);\n      }\n      try {\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(\n          messages.strategyStart('StaleWhileRevalidate', request));\n      for (let log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n\n    if (!response) {\n      throw new WorkboxError('no-response', {url: request.url, error});\n    }\n    return response;\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Event} [options.event]\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n  async _getFromNetwork({request, event}) {\n    const response = await fetchWrapper.fetch({\n      request,\n      event,\n      fetchOptions: this._fetchOptions,\n      plugins: this._plugins,\n    });\n\n    const cachePutPromise = cacheWrapper.put({\n      cacheName: this._cacheName,\n      request,\n      response: response.clone(),\n      event,\n      plugins: this._plugins,\n    });\n\n    if (event) {\n      try {\n        event.waitUntil(cachePutPromise);\n      } catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn(`Unable to ensure service worker stays alive when ` +\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\nexport {StaleWhileRevalidate};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {CacheFirst} from './CacheFirst.mjs';\nimport {CacheOnly} from './CacheOnly.mjs';\nimport {NetworkFirst} from './NetworkFirst.mjs';\nimport {NetworkOnly} from './NetworkOnly.mjs';\nimport {StaleWhileRevalidate} from './StaleWhileRevalidate.mjs';\nimport './_version.mjs';\n\n\nconst mapping = {\n  cacheFirst: CacheFirst,\n  cacheOnly: CacheOnly,\n  networkFirst: NetworkFirst,\n  networkOnly: NetworkOnly,\n  staleWhileRevalidate: StaleWhileRevalidate,\n};\n\nconst deprecate = (strategy) => {\n  const StrategyCtr = mapping[strategy];\n\n  return (options) => {\n    if (process.env.NODE_ENV !== 'production') {\n      const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\n      logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` +\n          `deprecated and will be removed in a future version of Workbox.\\n` +\n          `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\n    }\n    return new StrategyCtr(options);\n  };\n};\n\n/**\n * @function workbox.strategies.cacheFirst\n * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheFirst = deprecate('cacheFirst');\n\n/**\n * @function workbox.strategies.cacheOnly\n * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst cacheOnly = deprecate('cacheOnly');\n\n/**\n * @function workbox.strategies.networkFirst\n * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkFirst = deprecate('networkFirst');\n\n/**\n * @function workbox.strategies.networkOnly\n * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n * constructor for more info.\n * @deprecated since v4.0.0\n */\nconst networkOnly = deprecate('networkOnly');\n\n/**\n * @function workbox.strategies.staleWhileRevalidate\n * @param {Object} options See the\n * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n * @deprecated since v4.0.0\n */\nconst staleWhileRevalidate = deprecate('staleWhileRevalidate');\n\n/**\n * There are common caching strategies that most service workers will need\n * and use. This module provides simple implementations of these strategies.\n *\n * @namespace workbox.strategies\n */\n\nexport {\n  CacheFirst,\n  CacheOnly,\n  NetworkFirst,\n  NetworkOnly,\n  StaleWhileRevalidate,\n\n  // Deprecated...\n  cacheFirst,\n  cacheOnly,\n  networkFirst,\n  networkOnly,\n  staleWhileRevalidate,\n};\n\n"]},"metadata":{},"sourceType":"script"}