{"ast":null,"code":"/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks inside function parentheses\",\n      category: \"Stylistic Issues\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-paren-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n      }, {\n        type: \"object\",\n        properties: {\n          minItems: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      expectedBefore: \"Expected newline before ')'.\",\n      expectedAfter: \"Expected newline after '('.\",\n      expectedBetween: \"Expected newline between arguments/params.\",\n      unexpectedBefore: \"Unexpected newline before ')'.\",\n      unexpectedAfter: \"Unexpected newline after '('.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const rawOption = context.options[0] || \"multiline\";\n    const multilineOption = rawOption === \"multiline\";\n    const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n    const consistentOption = rawOption === \"consistent\";\n    let minItems;\n\n    if (typeof rawOption === \"object\") {\n      minItems = rawOption.minItems;\n    } else if (rawOption === \"always\") {\n      minItems = 0;\n    } else if (rawOption === \"never\") {\n      minItems = Infinity;\n    } else {\n      minItems = null;\n    } //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\n     * Determines whether there should be newlines inside function parens\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n     * @returns {boolean} `true` if there should be newlines inside the function parens\n     */\n\n\n    function shouldHaveNewlines(elements, hasLeftNewline) {\n      if (multilineArgumentsOption && elements.length === 1) {\n        return hasLeftNewline;\n      }\n\n      if (multilineOption || multilineArgumentsOption) {\n        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n      }\n\n      if (consistentOption) {\n        return hasLeftNewline;\n      }\n\n      return elements.length >= minItems;\n    }\n    /**\n     * Validates parens\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @returns {void}\n     */\n\n\n    function validateParens(parens, elements) {\n      const leftParen = parens.leftParen;\n      const rightParen = parens.rightParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"unexpectedAfter\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() // If there is a comment between the ( and the first element, don't do a fix.\n            ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n          }\n\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"expectedAfter\",\n          fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"unexpectedBefore\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() // If there is a comment between the last element and the ), don't do a fix.\n            ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n          }\n\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"expectedBefore\",\n          fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n        });\n      }\n    }\n    /**\n     * Validates a list of arguments or parameters\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode[]} elements The arguments or parameters in the list\n     * @returns {void}\n     */\n\n\n    function validateArguments(parens, elements) {\n      const leftParen = parens.leftParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      for (let i = 0; i <= elements.length - 2; i++) {\n        const currentElement = elements[i];\n        const nextElement = elements[i + 1];\n        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n        if (!hasNewLine && needsNewlines) {\n          context.report({\n            node: currentElement,\n            messageId: \"expectedBetween\",\n            fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n          });\n        }\n      }\n    }\n    /**\n     * Gets the left paren and right paren tokens of a node.\n     * @param {ASTNode} node The node with parens\n     * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n     * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n     * with a single parameter)\n     */\n\n\n    function getParenTokens(node) {\n      switch (node.type) {\n        case \"NewExpression\":\n          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {\n            skip: 1\n          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {\n            // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n            return null;\n          }\n\n        // falls through\n\n        case \"CallExpression\":\n          return {\n            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n            rightParen: sourceCode.getLastToken(node)\n          };\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        case \"ArrowFunctionExpression\":\n          {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            if (!astUtils.isOpeningParenToken(firstToken)) {\n              // If the ArrowFunctionExpression has a single param without parens, return null.\n              return null;\n            }\n\n            return {\n              leftParen: firstToken,\n              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n            };\n          }\n\n        case \"ImportExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, 1);\n            const rightParen = sourceCode.getLastToken(node);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        default:\n          throw new TypeError(`unexpected node with type ${node.type}`);\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      [[\"ArrowFunctionExpression\", \"CallExpression\", \"FunctionDeclaration\", \"FunctionExpression\", \"ImportExpression\", \"NewExpression\"]](node) {\n        const parens = getParenTokens(node);\n        let params;\n\n        if (node.type === \"ImportExpression\") {\n          params = [node.source];\n        } else if (astUtils.isFunction(node)) {\n          params = node.params;\n        } else {\n          params = node.arguments;\n        }\n\n        if (parens) {\n          validateParens(parens, params);\n\n          if (multilineArgumentsOption) {\n            validateArguments(parens, params);\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rules/function-paren-newline.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","minItems","minimum","additionalProperties","messages","expectedBefore","expectedAfter","expectedBetween","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","rawOption","options","multilineOption","multilineArgumentsOption","consistentOption","Infinity","shouldHaveNewlines","elements","hasLeftNewline","length","some","element","index","loc","end","line","start","validateParens","parens","leftParen","rightParen","tokenAfterLeftParen","getTokenAfter","tokenBeforeRightParen","getTokenBefore","isTokenOnSameLine","hasRightNewline","needsNewlines","report","node","messageId","fix","fixer","getText","slice","range","trim","removeRange","insertTextAfter","insertTextBefore","validateArguments","i","currentElement","nextElement","hasNewLine","getParenTokens","arguments","isOpeningParenToken","getLastToken","skip","isClosingParenToken","callee","getFirstToken","params","firstToken","body","TypeError","source","isFunction"],"mappings":"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","sourcesContent":["/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside function parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-paren-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            minItems: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Expected newline before ')'.\",\n            expectedAfter: \"Expected newline after '('.\",\n            expectedBetween: \"Expected newline between arguments/params.\",\n            unexpectedBefore: \"Unexpected newline before ')'.\",\n            unexpectedAfter: \"Unexpected newline after '('.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const rawOption = context.options[0] || \"multiline\";\n        const multilineOption = rawOption === \"multiline\";\n        const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n        const consistentOption = rawOption === \"consistent\";\n        let minItems;\n\n        if (typeof rawOption === \"object\") {\n            minItems = rawOption.minItems;\n        } else if (rawOption === \"always\") {\n            minItems = 0;\n        } else if (rawOption === \"never\") {\n            minItems = Infinity;\n        } else {\n            minItems = null;\n        }\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Determines whether there should be newlines inside function parens\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n         * @returns {boolean} `true` if there should be newlines inside the function parens\n         */\n        function shouldHaveNewlines(elements, hasLeftNewline) {\n            if (multilineArgumentsOption && elements.length === 1) {\n                return hasLeftNewline;\n            }\n            if (multilineOption || multilineArgumentsOption) {\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n            }\n            if (consistentOption) {\n                return hasLeftNewline;\n            }\n            return elements.length >= minItems;\n        }\n\n        /**\n         * Validates parens\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateParens(parens, elements) {\n            const leftParen = parens.leftParen;\n            const rightParen = parens.rightParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            if (hasLeftNewline && !needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"unexpectedAfter\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n                            // If there is a comment between the ( and the first element, don't do a fix.\n                            ? null\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n                    }\n                });\n            } else if (!hasLeftNewline && needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"expectedAfter\",\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n                });\n            }\n\n            if (hasRightNewline && !needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"unexpectedBefore\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n                            // If there is a comment between the last element and the ), don't do a fix.\n                            ? null\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n                    }\n                });\n            } else if (!hasRightNewline && needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"expectedBefore\",\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates a list of arguments or parameters\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateArguments(parens, elements) {\n            const leftParen = parens.leftParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            for (let i = 0; i <= elements.length - 2; i++) {\n                const currentElement = elements[i];\n                const nextElement = elements[i + 1];\n                const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n                if (!hasNewLine && needsNewlines) {\n                    context.report({\n                        node: currentElement,\n                        messageId: \"expectedBetween\",\n                        fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n                    });\n                }\n            }\n        }\n\n        /**\n         * Gets the left paren and right paren tokens of a node.\n         * @param {ASTNode} node The node with parens\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n         * with a single parameter)\n         */\n        function getParenTokens(node) {\n            switch (node.type) {\n                case \"NewExpression\":\n                    if (!node.arguments.length && !(\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\n                    )) {\n\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n                        return null;\n                    }\n\n                    // falls through\n\n                case \"CallExpression\":\n                    return {\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n                        rightParen: sourceCode.getLastToken(node)\n                    };\n\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n                    const rightParen = node.params.length\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\n                        : sourceCode.getTokenAfter(leftParen);\n\n                    return { leftParen, rightParen };\n                }\n\n                case \"ArrowFunctionExpression\": {\n                    const firstToken = sourceCode.getFirstToken(node);\n\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\n\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\n                        return null;\n                    }\n\n                    return {\n                        leftParen: firstToken,\n                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n                    };\n                }\n\n                case \"ImportExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, 1);\n                    const rightParen = sourceCode.getLastToken(node);\n\n                    return { leftParen, rightParen };\n                }\n\n                default:\n                    throw new TypeError(`unexpected node with type ${node.type}`);\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            [[\n                \"ArrowFunctionExpression\",\n                \"CallExpression\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ImportExpression\",\n                \"NewExpression\"\n            ]](node) {\n                const parens = getParenTokens(node);\n                let params;\n\n                if (node.type === \"ImportExpression\") {\n                    params = [node.source];\n                } else if (astUtils.isFunction(node)) {\n                    params = node.params;\n                } else {\n                    params = node.arguments;\n                }\n\n                if (parens) {\n                    validateParens(parens, params);\n\n                    if (multilineArgumentsOption) {\n                        validateArguments(parens, params);\n                    }\n                }\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}