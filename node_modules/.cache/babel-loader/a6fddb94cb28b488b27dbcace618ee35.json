{"ast":null,"code":"function _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar postcss = _interopDefault(require('postcss'));\n\nvar postcssBrowserComments = _interopDefault(require('postcss-browser-comments'));\n\nvar Module = _interopDefault(require('module'));\n\nvar path = _interopDefault(require('path'));\n\nvar fs = _interopDefault(require('fs'));\n\nconst assign = (...objects) => Object.assign(...objects);\n\nconst create = (...objects) => assign(Object.create(null), ...objects);\n\nconst currentFilename = __filename;\nconst currentDirname = path.dirname(currentFilename); // get resolved filenames for css libraries\n\nconst normalizeCSS = resolve('@csstools/normalize.css');\nconst normalizeOpinionatedCSS = resolve('@csstools/normalize.css/opinionated.css');\nconst sanitizeCSS = resolve('sanitize.css');\nconst sanitizeFormsCSS = resolve('sanitize.css/forms.css');\nconst sanitizePageCSS = resolve('sanitize.css/page.css');\nconst sanitizeTypographyCSS = resolve('sanitize.css/typography.css'); // export a hashmap of css library filenames\n\nconst parsableFilenames = create({\n  [normalizeCSS]: true,\n  [normalizeOpinionatedCSS]: true,\n  [sanitizeCSS]: true,\n  [sanitizeFormsCSS]: true,\n  [sanitizePageCSS]: true,\n  [sanitizeTypographyCSS]: true\n}); // export a hashmap of css library filenames by id\n\nconst resolvedFilenamesById = create({\n  'normalize': [normalizeCSS],\n  'normalize/opinionated': [normalizeOpinionatedCSS],\n  'normalize/*': [normalizeOpinionatedCSS],\n  'sanitize': [sanitizeCSS],\n  'sanitize/forms': [sanitizeCSS, sanitizeFormsCSS],\n  'sanitize/page': [sanitizeCSS, sanitizePageCSS],\n  'sanitize/typography': [sanitizeCSS, sanitizeTypographyCSS],\n  'sanitize/*': [sanitizeCSS, sanitizeFormsCSS, sanitizePageCSS, sanitizeTypographyCSS]\n}); // get the resolved filename of a package/module\n\nfunction resolve(id) {\n  return resolve[id] = resolve[id] || Module._resolveFilename(id, {\n    id: currentFilename,\n    filename: currentFilename,\n    paths: Module._nodeModulePaths(currentDirname)\n  });\n}\n\nconst cache = create();\n\nasync function readFile(filename) {\n  filename = path.resolve(filename);\n  cache[filename] = cache[filename] || create();\n  return new Promise((resolve, reject) => fs.stat(filename, (statsError, {\n    mtime\n  }) => statsError ? reject(statsError) : mtime === cache[filename].mtime ? resolve(cache[filename].data) : fs.readFile(filename, 'utf8', (readFileError, data) => readFileError ? reject(readFileError) : resolve((cache[filename] = {\n    data,\n    mtime\n  }).data))));\n}\n\nconst cache$1 = create(null);\n\nvar parse = (filename, transformer) => readFile(filename).then( // cache the parsed css root\ncss => cache$1[css] = cache$1[css] || postcss.parse(css, {\n  from: filename\n})).then( // clone the cached root\nroot => root.clone()).then( // transform the cloned root\nclone => Promise.resolve(transformer(clone)).then( // resolve the cloned root\n() => clone));\n\nvar postcssImportNormalize = commentsTransformer => opts => {\n  opts = create(opts); // return an postcss-import configuration\n\n  return create({\n    load(filename, importOptions) {\n      return filename in parsableFilenames // parse the file (the file and css are conservatively cached)\n      ? parse(filename, commentsTransformer).then(root => root.toResult({\n        to: filename,\n        map: true\n      }).css) : typeof opts.load === 'function' // otherwise, use the override loader\n      ? opts.load.call(null, filename, importOptions) // otherwise, return the (conservatively cached) contents of the file\n      : readFile(filename);\n    },\n\n    resolve(id, basedir, importOptions) {\n      // get the css id by removing css extensions\n      const cssId = id.replace(cssExtRegExp, '');\n      return cssId in resolvedFilenamesById // return the known resolved path for the css id\n      ? resolvedFilenamesById[cssId] : typeof opts.resolve === 'function' // otherwise, use the override resolver\n      ? opts.resolve.call(null, id, basedir, importOptions) // otherwise, return the id to be resolved by postcss-import\n      : id;\n    }\n\n  });\n};\n\nconst cssExtRegExp = /\\.css\\b/g;\n\nconst postcssPlugin = (commentsTransformer, opts) => root => {\n  const promises = [];\n  const insertedFilenames = {}; // use @import insertion point\n\n  root.walkAtRules(importRegExp, atrule => {\n    // get name as a fallback value for the library (e.g. @import-normalize is like @import \"normalize.css\")\n    const name = atrule.name.match(importRegExp)[1]; // get url from \"library\", 'library', url(\"library\"), url('library'), or the fallback value\n\n    const url = (atrule.params.match(paramsRegExp) || []).slice(1).find(part => part) || name;\n\n    if (url) {\n      // get the css id by removing css extensions\n      const cssId = url.replace(cssExtRegExp$1, '');\n\n      if (cssId in resolvedFilenamesById) {\n        // promise the library import is replaced with its contents\n        promises.push(Promise.all(resolvedFilenamesById[cssId].filter( // ignore filenames that have already been inserted\n        filename => insertedFilenames[filename] = opts.allowDuplicates || !(filename in insertedFilenames)).map( // parse the file (the file and css are conservatively cached)\n        filename => parse(filename, commentsTransformer))).then(roots => {\n          if (roots.length) {\n            // combine all the library nodes returned by the parsed files\n            const nodes = roots.reduce((all, root) => all.concat(root.nodes), []); // replace the import with all the library nodes\n\n            atrule.replaceWith(...nodes);\n          }\n        }));\n      }\n    }\n  });\n  return Promise.all([].concat( // promise the library imports are replaced with their contents\n  promises, // promise certain libraries are prepended\n  Promise.all([].concat(opts.forceImport || []).reduce( // filter the id to be a known id or boolean true\n  (all, id) => {\n    if (id === true) {\n      all.push(...resolvedFilenamesById.normalize);\n    } else if (typeof id === 'string') {\n      const cssId = id.replace(cssExtRegExp$1, '');\n\n      if (cssId in resolvedFilenamesById) {\n        all.push(...resolvedFilenamesById[cssId]);\n      }\n    }\n\n    return all;\n  }, []).filter( // ignore filenames that have already been inserted\n  filename => insertedFilenames[filename] = opts.allowDuplicates || !(filename in insertedFilenames)).map( // parse the file (the file and css are conservatively cached)\n  filename => parse(filename, commentsTransformer))).then(roots => {\n    if (roots.length) {\n      // combine all the library nodes returned by the parsed files\n      const nodes = roots.reduce((all, root) => all.concat(root.nodes), []); // prepend the stylesheet with all the library nodes\n\n      root.prepend(...nodes);\n    }\n  })));\n};\n\nconst cssExtRegExp$1 = /\\.css\\b/g;\nconst importRegExp = /^import(?:-(normalize|sanitize))?$/;\nconst paramsRegExp = /^\\s*(?:url\\((?:\"(.+)\"|'(.+)')\\)|\"(.+)\"|'(.+)')[\\W\\w]*$/;\nvar index = postcss.plugin('postcss-normalize', opts => {\n  opts = create(opts);\n  const commentsTransformer = postcssBrowserComments(opts);\n  const normalizeTransformer = postcssPlugin(commentsTransformer, opts);\n  const postcssImportConfig = postcssImportNormalize(commentsTransformer);\n  return assign(normalizeTransformer, {\n    postcssImport: postcssImportConfig\n  });\n});\nmodule.exports = index;","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar postcss = _interopDefault(require('postcss'));\nvar postcssBrowserComments = _interopDefault(require('postcss-browser-comments'));\nvar Module = _interopDefault(require('module'));\nvar path = _interopDefault(require('path'));\n\nvar fs = _interopDefault(require('fs'));\n\nconst assign = (...objects) => Object.assign(...objects);\nconst create = (...objects) => assign(Object.create(null), ...objects);\n\nconst currentFilename = __filename;\nconst currentDirname = path.dirname(currentFilename); // get resolved filenames for css libraries\n\nconst normalizeCSS = resolve('@csstools/normalize.css');\nconst normalizeOpinionatedCSS = resolve('@csstools/normalize.css/opinionated.css');\nconst sanitizeCSS = resolve('sanitize.css');\nconst sanitizeFormsCSS = resolve('sanitize.css/forms.css');\nconst sanitizePageCSS = resolve('sanitize.css/page.css');\nconst sanitizeTypographyCSS = resolve('sanitize.css/typography.css'); // export a hashmap of css library filenames\n\nconst parsableFilenames = create({\n  [normalizeCSS]: true,\n  [normalizeOpinionatedCSS]: true,\n  [sanitizeCSS]: true,\n  [sanitizeFormsCSS]: true,\n  [sanitizePageCSS]: true,\n  [sanitizeTypographyCSS]: true\n}); // export a hashmap of css library filenames by id\n\nconst resolvedFilenamesById = create({\n  'normalize': [normalizeCSS],\n  'normalize/opinionated': [normalizeOpinionatedCSS],\n  'normalize/*': [normalizeOpinionatedCSS],\n  'sanitize': [sanitizeCSS],\n  'sanitize/forms': [sanitizeCSS, sanitizeFormsCSS],\n  'sanitize/page': [sanitizeCSS, sanitizePageCSS],\n  'sanitize/typography': [sanitizeCSS, sanitizeTypographyCSS],\n  'sanitize/*': [sanitizeCSS, sanitizeFormsCSS, sanitizePageCSS, sanitizeTypographyCSS]\n}); // get the resolved filename of a package/module\n\nfunction resolve(id) {\n  return resolve[id] = resolve[id] || Module._resolveFilename(id, {\n    id: currentFilename,\n    filename: currentFilename,\n    paths: Module._nodeModulePaths(currentDirname)\n  });\n}\n\nconst cache = create();\nasync function readFile(filename) {\n  filename = path.resolve(filename);\n  cache[filename] = cache[filename] || create();\n  return new Promise((resolve, reject) => fs.stat(filename, (statsError, {\n    mtime\n  }) => statsError ? reject(statsError) : mtime === cache[filename].mtime ? resolve(cache[filename].data) : fs.readFile(filename, 'utf8', (readFileError, data) => readFileError ? reject(readFileError) : resolve((cache[filename] = {\n    data,\n    mtime\n  }).data))));\n}\n\nconst cache$1 = create(null);\nvar parse = ((filename, transformer) => readFile(filename).then( // cache the parsed css root\ncss => cache$1[css] = cache$1[css] || postcss.parse(css, {\n  from: filename\n})).then( // clone the cached root\nroot => root.clone()).then( // transform the cloned root\nclone => Promise.resolve(transformer(clone)).then( // resolve the cloned root\n() => clone)));\n\nvar postcssImportNormalize = (commentsTransformer => opts => {\n  opts = create(opts); // return an postcss-import configuration\n\n  return create({\n    load(filename, importOptions) {\n      return filename in parsableFilenames // parse the file (the file and css are conservatively cached)\n      ? parse(filename, commentsTransformer).then(root => root.toResult({\n        to: filename,\n        map: true\n      }).css) : typeof opts.load === 'function' // otherwise, use the override loader\n      ? opts.load.call(null, filename, importOptions) // otherwise, return the (conservatively cached) contents of the file\n      : readFile(filename);\n    },\n\n    resolve(id, basedir, importOptions) {\n      // get the css id by removing css extensions\n      const cssId = id.replace(cssExtRegExp, '');\n      return cssId in resolvedFilenamesById // return the known resolved path for the css id\n      ? resolvedFilenamesById[cssId] : typeof opts.resolve === 'function' // otherwise, use the override resolver\n      ? opts.resolve.call(null, id, basedir, importOptions) // otherwise, return the id to be resolved by postcss-import\n      : id;\n    }\n\n  });\n});\nconst cssExtRegExp = /\\.css\\b/g;\n\nconst postcssPlugin = (commentsTransformer, opts) => root => {\n  const promises = [];\n  const insertedFilenames = {}; // use @import insertion point\n\n  root.walkAtRules(importRegExp, atrule => {\n    // get name as a fallback value for the library (e.g. @import-normalize is like @import \"normalize.css\")\n    const name = atrule.name.match(importRegExp)[1]; // get url from \"library\", 'library', url(\"library\"), url('library'), or the fallback value\n\n    const url = (atrule.params.match(paramsRegExp) || []).slice(1).find(part => part) || name;\n\n    if (url) {\n      // get the css id by removing css extensions\n      const cssId = url.replace(cssExtRegExp$1, '');\n\n      if (cssId in resolvedFilenamesById) {\n        // promise the library import is replaced with its contents\n        promises.push(Promise.all(resolvedFilenamesById[cssId].filter( // ignore filenames that have already been inserted\n        filename => insertedFilenames[filename] = opts.allowDuplicates || !(filename in insertedFilenames)).map( // parse the file (the file and css are conservatively cached)\n        filename => parse(filename, commentsTransformer))).then(roots => {\n          if (roots.length) {\n            // combine all the library nodes returned by the parsed files\n            const nodes = roots.reduce((all, root) => all.concat(root.nodes), []); // replace the import with all the library nodes\n\n            atrule.replaceWith(...nodes);\n          }\n        }));\n      }\n    }\n  });\n  return Promise.all([].concat( // promise the library imports are replaced with their contents\n  promises, // promise certain libraries are prepended\n  Promise.all([].concat(opts.forceImport || []).reduce( // filter the id to be a known id or boolean true\n  (all, id) => {\n    if (id === true) {\n      all.push(...resolvedFilenamesById.normalize);\n    } else if (typeof id === 'string') {\n      const cssId = id.replace(cssExtRegExp$1, '');\n\n      if (cssId in resolvedFilenamesById) {\n        all.push(...resolvedFilenamesById[cssId]);\n      }\n    }\n\n    return all;\n  }, []).filter( // ignore filenames that have already been inserted\n  filename => insertedFilenames[filename] = opts.allowDuplicates || !(filename in insertedFilenames)).map( // parse the file (the file and css are conservatively cached)\n  filename => parse(filename, commentsTransformer))).then(roots => {\n    if (roots.length) {\n      // combine all the library nodes returned by the parsed files\n      const nodes = roots.reduce((all, root) => all.concat(root.nodes), []); // prepend the stylesheet with all the library nodes\n\n      root.prepend(...nodes);\n    }\n  })));\n};\n\nconst cssExtRegExp$1 = /\\.css\\b/g;\nconst importRegExp = /^import(?:-(normalize|sanitize))?$/;\nconst paramsRegExp = /^\\s*(?:url\\((?:\"(.+)\"|'(.+)')\\)|\"(.+)\"|'(.+)')[\\W\\w]*$/;\n\nvar index = postcss.plugin('postcss-normalize', opts => {\n  opts = create(opts);\n  const commentsTransformer = postcssBrowserComments(opts);\n  const normalizeTransformer = postcssPlugin(commentsTransformer, opts);\n  const postcssImportConfig = postcssImportNormalize(commentsTransformer);\n  return assign(normalizeTransformer, {\n    postcssImport: postcssImportConfig\n  });\n});\n\nmodule.exports = index;\n//# sourceMappingURL=index.cjs.js.map\n"]},"metadata":{},"sourceType":"script"}