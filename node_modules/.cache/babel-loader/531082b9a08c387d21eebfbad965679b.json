{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = readInitialCoverage;\n\nvar _parser = require(\"@babel/parser\");\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _constants = require(\"./constants\");\n\nvar _instrumenter = require(\"./instrumenter\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction readInitialCoverage(code) {\n  if (typeof code !== 'string') {\n    throw new Error('Code must be a string');\n  } // Parse as leniently as possible\n\n\n  const ast = (0, _parser.parse)(code, {\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: 'script',\n    plugins: (0, _instrumenter.defaultOpts)().plugins\n  });\n  let covScope;\n  (0, _traverse.default)(ast, {\n    ObjectProperty(path) {\n      const node = path.node;\n\n      if (!node.computed && t.isIdentifier(node.key) && node.key.name === _constants.MAGIC_KEY) {\n        const magicValue = path.get('value').evaluate();\n\n        if (!magicValue.confident || magicValue.value !== _constants.MAGIC_VALUE) {\n          return;\n        }\n\n        covScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        path.stop();\n      }\n    }\n\n  });\n\n  if (!covScope) {\n    return null;\n  }\n\n  const result = {};\n\n  for (var _i = 0, _arr = ['path', 'hash', 'gcv', 'coverageData']; _i < _arr.length; _i++) {\n    const key = _arr[_i];\n    const binding = covScope.getOwnBinding(key);\n\n    if (!binding) {\n      return null;\n    }\n\n    const valuePath = binding.path.get('init');\n    const value = valuePath.evaluate();\n\n    if (!value.confident) {\n      return null;\n    }\n\n    result[key] = value.value;\n  }\n\n  delete result.coverageData[_constants.MAGIC_KEY];\n  return result;\n}","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/istanbul-lib-instrument/dist/read-coverage.js"],"names":["Object","defineProperty","exports","value","default","readInitialCoverage","_parser","require","_traverse","_interopRequireDefault","t","_interopRequireWildcard","_constants","_instrumenter","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","code","Error","ast","parse","allowImportExportEverywhere","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","plugins","defaultOpts","covScope","ObjectProperty","path","node","computed","isIdentifier","name","MAGIC_KEY","magicValue","evaluate","confident","MAGIC_VALUE","scope","getFunctionParent","getProgramParent","stop","result","_i","_arr","length","binding","getOwnBinding","valuePath","coverageData"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = readInitialCoverage;\n\nvar _parser = require(\"@babel/parser\");\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _constants = require(\"./constants\");\n\nvar _instrumenter = require(\"./instrumenter\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction readInitialCoverage(code) {\n  if (typeof code !== 'string') {\n    throw new Error('Code must be a string');\n  } // Parse as leniently as possible\n\n\n  const ast = (0, _parser.parse)(code, {\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: 'script',\n    plugins: (0, _instrumenter.defaultOpts)().plugins\n  });\n  let covScope;\n  (0, _traverse.default)(ast, {\n    ObjectProperty(path) {\n      const node = path.node;\n\n      if (!node.computed && t.isIdentifier(node.key) && node.key.name === _constants.MAGIC_KEY) {\n        const magicValue = path.get('value').evaluate();\n\n        if (!magicValue.confident || magicValue.value !== _constants.MAGIC_VALUE) {\n          return;\n        }\n\n        covScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        path.stop();\n      }\n    }\n\n  });\n\n  if (!covScope) {\n    return null;\n  }\n\n  const result = {};\n\n  for (var _i = 0, _arr = ['path', 'hash', 'gcv', 'coverageData']; _i < _arr.length; _i++) {\n    const key = _arr[_i];\n    const binding = covScope.getOwnBinding(key);\n\n    if (!binding) {\n      return null;\n    }\n\n    const valuePath = binding.path.get('init');\n    const value = valuePath.evaluate();\n\n    if (!value.confident) {\n      return null;\n    }\n\n    result[key] = value.value;\n  }\n\n  delete result.coverageData[_constants.MAGIC_KEY];\n  return result;\n}"]},"metadata":{},"sourceType":"script"}