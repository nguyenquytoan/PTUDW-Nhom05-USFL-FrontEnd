{"ast":null,"code":"/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n/* global describe, it */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.run(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      path = require(\"path\"),\n      util = require(\"util\"),\n      lodash = require(\"lodash\"),\n      {\n  getRuleOptionsSchema,\n  validate\n} = require(\"../shared/config-validator\"),\n      {\n  Linter,\n  SourceCodeFixer,\n  interpolate\n} = require(\"../linter\");\n\nconst ajv = require(\"../shared/ajv\")({\n  strictDefaults: true\n}); //------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\n\n\nconst testerDefaultConfig = {\n  rules: {}\n};\nlet defaultConfig = {\n  rules: {}\n};\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\n\nconst RuleTesterParameters = [\"code\", \"filename\", \"options\", \"errors\", \"output\"];\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\n\nfunction cloneDeeplyExcludesParent(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      return x.map(cloneDeeplyExcludesParent);\n    }\n\n    const retv = {};\n\n    for (const key in x) {\n      if (key !== \"parent\" && hasOwnProperty(x, key)) {\n        retv[key] = cloneDeeplyExcludesParent(x[key]);\n      }\n    }\n\n    return retv;\n  }\n\n  return x;\n}\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\n\n\nfunction freezeDeeply(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      x.forEach(freezeDeeply);\n    } else {\n      for (const key in x) {\n        if (key !== \"parent\" && hasOwnProperty(x, key)) {\n          freezeDeeply(x[key]);\n        }\n      }\n    }\n\n    Object.freeze(x);\n  }\n}\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\n\n\nfunction sanitize(text) {\n  return text.replace(/[\\u0000-\\u0009|\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex\n  c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`);\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n// default separators for testing\n\n\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\n\nfunction itDefaultHandler(text, method) {\n  try {\n    return method.call(this);\n  } catch (err) {\n    if (err instanceof assert.AssertionError) {\n      err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n    }\n\n    throw err;\n  }\n}\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\n\n\nfunction describeDefaultHandler(text, method) {\n  return method.call(this);\n}\n\nclass RuleTester {\n  /**\n   * Creates a new instance of RuleTester.\n   * @param {Object} [testerConfig] Optional, extra configuration for the tester\n   */\n  constructor(testerConfig) {\n    /**\n     * The configuration to use for this tester. Combination of the tester\n     * configuration and the default configuration.\n     * @type {Object}\n     */\n    this.testerConfig = lodash.merge( // we have to clone because merge uses the first argument for recipient\n    lodash.cloneDeep(defaultConfig), testerConfig, {\n      rules: {\n        \"rule-tester/validate-ast\": \"error\"\n      }\n    });\n    /**\n     * Rule definitions to define before tests.\n     * @type {Object}\n     */\n\n    this.rules = {};\n    this.linter = new Linter();\n  }\n  /**\n   * Set the configuration to use for all future tests\n   * @param {Object} config the configuration to use.\n   * @returns {void}\n   */\n\n\n  static setDefaultConfig(config) {\n    if (typeof config !== \"object\") {\n      throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n    }\n\n    defaultConfig = config; // Make sure the rules object exists since it is assumed to exist later\n\n    defaultConfig.rules = defaultConfig.rules || {};\n  }\n  /**\n   * Get the current configuration used for all tests\n   * @returns {Object} the current configuration\n   */\n\n\n  static getDefaultConfig() {\n    return defaultConfig;\n  }\n  /**\n   * Reset the configuration to the initial configuration of the tester removing\n   * any changes made until now.\n   * @returns {void}\n   */\n\n\n  static resetDefaultConfig() {\n    defaultConfig = lodash.cloneDeep(testerDefaultConfig);\n  }\n  /*\n   * If people use `mocha test.js --watch` command, `describe` and `it` function\n   * instances are different for each execution. So `describe` and `it` should get fresh instance\n   * always.\n   */\n\n\n  static get describe() {\n    return this[DESCRIBE] || (typeof describe === \"function\" ? describe : describeDefaultHandler);\n  }\n\n  static set describe(value) {\n    this[DESCRIBE] = value;\n  }\n\n  static get it() {\n    return this[IT] || (typeof it === \"function\" ? it : itDefaultHandler);\n  }\n\n  static set it(value) {\n    this[IT] = value;\n  }\n  /**\n   * Define a rule for one particular run of tests.\n   * @param {string} name The name of the rule to define.\n   * @param {Function} rule The rule definition.\n   * @returns {void}\n   */\n\n\n  defineRule(name, rule) {\n    this.rules[name] = rule;\n  }\n  /**\n   * Adds a new rule test to execute.\n   * @param {string} ruleName The name of the rule to run.\n   * @param {Function} rule The rule to test.\n   * @param {Object} test The collection of tests to run.\n   * @returns {void}\n   */\n\n\n  run(ruleName, rule, test) {\n    const testerConfig = this.testerConfig,\n          requiredScenarios = [\"valid\", \"invalid\"],\n          scenarioErrors = [],\n          linter = this.linter;\n\n    if (lodash.isNil(test) || typeof test !== \"object\") {\n      throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n    }\n\n    requiredScenarios.forEach(scenarioType => {\n      if (lodash.isNil(test[scenarioType])) {\n        scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n      }\n    });\n\n    if (scenarioErrors.length > 0) {\n      throw new Error([`Test Scenarios for rule ${ruleName} is invalid:`].concat(scenarioErrors).join(\"\\n\"));\n    }\n\n    linter.defineRule(ruleName, Object.assign({}, rule, {\n      // Create a wrapper rule that freezes the `context` properties.\n      create(context) {\n        freezeDeeply(context.options);\n        freezeDeeply(context.settings);\n        freezeDeeply(context.parserOptions);\n        return (typeof rule === \"function\" ? rule : rule.create)(context);\n      }\n\n    }));\n    linter.defineRules(this.rules);\n    /**\n     * Run the rule for the given item\n     * @param {string|Object} item Item to run the rule against\n     * @returns {Object} Eslint run result\n     * @private\n     */\n\n    function runRuleForItem(item) {\n      let config = lodash.cloneDeep(testerConfig),\n          code,\n          filename,\n          output,\n          beforeAST,\n          afterAST;\n\n      if (typeof item === \"string\") {\n        code = item;\n      } else {\n        code = item.code;\n        /*\n         * Assumes everything on the item is a config except for the\n         * parameters used by this tester\n         */\n\n        const itemConfig = lodash.omit(item, RuleTesterParameters);\n        /*\n         * Create the config object from the tester config and this item\n         * specific configurations.\n         */\n\n        config = lodash.merge(config, itemConfig);\n      }\n\n      if (item.filename) {\n        filename = item.filename;\n      }\n\n      if (hasOwnProperty(item, \"options\")) {\n        assert(Array.isArray(item.options), \"options must be an array\");\n        config.rules[ruleName] = [1].concat(item.options);\n      } else {\n        config.rules[ruleName] = 1;\n      }\n\n      const schema = getRuleOptionsSchema(rule);\n      /*\n       * Setup AST getters.\n       * The goal is to check whether or not AST was modified when\n       * running the rule under test.\n       */\n\n      linter.defineRule(\"rule-tester/validate-ast\", () => ({\n        Program(node) {\n          beforeAST = cloneDeeplyExcludesParent(node);\n        },\n\n        \"Program:exit\"(node) {\n          afterAST = node;\n        }\n\n      }));\n\n      if (typeof config.parser === \"string\") {\n        assert(path.isAbsolute(config.parser), \"Parsers provided as strings to RuleTester must be absolute paths\");\n        linter.defineParser(config.parser, require(config.parser));\n      }\n\n      if (schema) {\n        ajv.validateSchema(schema);\n\n        if (ajv.errors) {\n          const errors = ajv.errors.map(error => {\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n            return `\\t${field}: ${error.message}`;\n          }).join(\"\\n\");\n          throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n        }\n        /*\n         * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n         * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n         * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n         * the schema is compiled here separately from checking for `validateSchema` errors.\n         */\n\n\n        try {\n          ajv.compile(schema);\n        } catch (err) {\n          throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n        }\n      }\n\n      validate(config, \"rule-tester\", id => id === ruleName ? rule : null); // Verify the code.\n\n      const messages = linter.verify(code, config, filename); // Ignore syntax errors for backward compatibility if `errors` is a number.\n\n      if (typeof item.errors !== \"number\") {\n        const errorMessage = messages.find(m => m.fatal);\n        assert(!errorMessage, `A fatal parsing error occurred: ${errorMessage && errorMessage.message}`);\n      } // Verify if autofix makes a syntax error or not.\n\n\n      if (messages.some(m => m.fix)) {\n        output = SourceCodeFixer.applyFixes(code, messages).output;\n        const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);\n        assert(!errorMessageInFix, `A fatal parsing error occurred in autofix: ${errorMessageInFix && errorMessageInFix.message}`);\n      } else {\n        output = code;\n      }\n\n      return {\n        messages,\n        output,\n        beforeAST,\n        afterAST: cloneDeeplyExcludesParent(afterAST)\n      };\n    }\n    /**\n     * Check if the AST was changed\n     * @param {ASTNode} beforeAST AST node before running\n     * @param {ASTNode} afterAST AST node after running\n     * @returns {void}\n     * @private\n     */\n\n\n    function assertASTDidntChange(beforeAST, afterAST) {\n      if (!lodash.isEqual(beforeAST, afterAST)) {\n        assert.fail(\"Rule should not modify AST.\");\n      }\n    }\n    /**\n     * Check if the template is valid or not\n     * all valid cases go through this\n     * @param {string|Object} item Item to run the rule against\n     * @returns {void}\n     * @private\n     */\n\n\n    function testValidTemplate(item) {\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n      assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\", messages.length, util.inspect(messages)));\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n    /**\n     * Asserts that the message matches its expected value. If the expected\n     * value is a regular expression, it is checked against the actual\n     * value.\n     * @param {string} actual Actual value\n     * @param {string|RegExp} expected Expected value\n     * @returns {void}\n     * @private\n     */\n\n\n    function assertMessageMatches(actual, expected) {\n      if (expected instanceof RegExp) {\n        // assert.js doesn't have a built-in RegExp match function\n        assert.ok(expected.test(actual), `Expected '${actual}' to match ${expected}`);\n      } else {\n        assert.strictEqual(actual, expected);\n      }\n    }\n    /**\n     * Check if the template is invalid or not\n     * all invalid cases go through this.\n     * @param {string|Object} item Item to run the rule against\n     * @returns {void}\n     * @private\n     */\n\n\n    function testInvalidTemplate(item) {\n      assert.ok(item.errors || item.errors === 0, `Did not specify errors for an invalid test of ${ruleName}`);\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n\n      if (typeof item.errors === \"number\") {\n        assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\", item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n      } else {\n        assert.strictEqual(messages.length, item.errors.length, util.format(\"Should have %d error%s but had %d: %s\", item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n        const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\n\n        for (let i = 0, l = item.errors.length; i < l; i++) {\n          const error = item.errors[i];\n          const message = messages[i];\n          assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n          if (typeof error === \"string\" || error instanceof RegExp) {\n            // Just an error message.\n            assertMessageMatches(message.message, error);\n          } else if (typeof error === \"object\") {\n            /*\n             * Error object.\n             * This may have a message, messageId, data, node type, line, and/or\n             * column.\n             */\n            if (hasOwnProperty(error, \"message\")) {\n              assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n              assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n              assertMessageMatches(message.message, error.message);\n            } else if (hasOwnProperty(error, \"messageId\")) {\n              assert.ok(hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\"), \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\");\n\n              if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                const friendlyIDList = `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]`;\n                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n              }\n\n              assert.strictEqual(message.messageId, error.messageId, `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`);\n\n              if (hasOwnProperty(error, \"data\")) {\n                /*\n                 *  if data was provided, then directly compare the returned message to a synthetic\n                 *  interpolated message using the same message ID and data provided in the test.\n                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                 */\n                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n                assert.strictEqual(message.message, rehydratedMessage, `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`);\n              }\n            }\n\n            assert.ok(hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true, \"Error must specify 'messageId' if 'data' is used.\");\n\n            if (error.type) {\n              assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n            }\n\n            if (hasOwnProperty(error, \"line\")) {\n              assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n            }\n\n            if (hasOwnProperty(error, \"column\")) {\n              assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n            }\n\n            if (hasOwnProperty(error, \"endLine\")) {\n              assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n            }\n\n            if (hasOwnProperty(error, \"endColumn\")) {\n              assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n            }\n\n            if (hasOwnProperty(error, \"suggestions\")) {\n              // Support asserting there are no suggestions\n              if (!error.suggestions || Array.isArray(error.suggestions) && error.suggestions.length === 0) {\n                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                  assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                }\n              } else {\n                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n                error.suggestions.forEach((expectedSuggestion, index) => {\n                  const actualSuggestion = message.suggestions[index];\n                  /**\n                   * Tests equality of a suggestion key if that key is defined in the expected output.\n                   * @param {string} key Key to validate from the suggestion object\n                   * @returns {void}\n                   */\n\n                  function assertSuggestionKeyEquals(key) {\n                    if (hasOwnProperty(expectedSuggestion, key)) {\n                      assert.deepStrictEqual(actualSuggestion[key], expectedSuggestion[key], `Error suggestion at index: ${index} should have desc of: \"${actualSuggestion[key]}\"`);\n                    }\n                  }\n\n                  assertSuggestionKeyEquals(\"desc\");\n                  assertSuggestionKeyEquals(\"messageId\");\n\n                  if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                    const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n                    assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                  }\n                });\n              }\n            }\n          } else {\n            // Message was an unexpected type\n            assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n          }\n        }\n      }\n\n      if (hasOwnProperty(item, \"output\")) {\n        if (item.output === null) {\n          assert.strictEqual(result.output, item.code, \"Expected no autofixes to be suggested\");\n        } else {\n          assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n        }\n      }\n\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n    /*\n     * This creates a mocha test suite and pipes all supplied info through\n     * one of the templates above.\n     */\n\n\n    RuleTester.describe(ruleName, () => {\n      RuleTester.describe(\"valid\", () => {\n        test.valid.forEach(valid => {\n          RuleTester.it(sanitize(typeof valid === \"object\" ? valid.code : valid), () => {\n            testValidTemplate(valid);\n          });\n        });\n      });\n      RuleTester.describe(\"invalid\", () => {\n        test.invalid.forEach(invalid => {\n          RuleTester.it(sanitize(invalid.code), () => {\n            testInvalidTemplate(invalid);\n          });\n        });\n      });\n    });\n  }\n\n}\n\nRuleTester[DESCRIBE] = RuleTester[IT] = null;\nmodule.exports = RuleTester;","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/rule-tester/rule-tester.js"],"names":["assert","require","path","util","lodash","getRuleOptionsSchema","validate","Linter","SourceCodeFixer","interpolate","ajv","strictDefaults","testerDefaultConfig","rules","defaultConfig","RuleTesterParameters","hasOwnProperty","Function","call","bind","Object","cloneDeeplyExcludesParent","x","Array","isArray","map","retv","key","freezeDeeply","forEach","freeze","sanitize","text","replace","c","codePointAt","toString","padStart","DESCRIBE","Symbol","IT","itDefaultHandler","method","err","AssertionError","message","inspect","actual","operator","expected","describeDefaultHandler","RuleTester","constructor","testerConfig","merge","cloneDeep","linter","setDefaultConfig","config","TypeError","getDefaultConfig","resetDefaultConfig","describe","value","it","defineRule","name","rule","run","ruleName","test","requiredScenarios","scenarioErrors","isNil","scenarioType","push","length","Error","concat","join","assign","create","context","options","settings","parserOptions","defineRules","runRuleForItem","item","code","filename","output","beforeAST","afterAST","itemConfig","omit","schema","Program","node","parser","isAbsolute","defineParser","validateSchema","errors","error","field","dataPath","slice","compile","id","messages","verify","errorMessage","find","m","fatal","some","fix","applyFixes","errorMessageInFix","assertASTDidntChange","isEqual","fail","testValidTemplate","result","strictEqual","format","assertMessageMatches","RegExp","ok","testInvalidTemplate","hasMessageOfThisRule","ruleId","i","l","meta","messageId","friendlyIDList","keys","unformattedOriginalMessage","rehydratedMessage","data","type","nodeType","line","column","endLine","endColumn","suggestions","expectedSuggestion","index","actualSuggestion","assertSuggestionKeyEquals","deepStrictEqual","codeWithAppliedSuggestion","valid","invalid","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* global describe, it */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.run(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    assert = require(\"assert\"),\n    path = require(\"path\"),\n    util = require(\"util\"),\n    lodash = require(\"lodash\"),\n    { getRuleOptionsSchema, validate } = require(\"../shared/config-validator\"),\n    { Linter, SourceCodeFixer, interpolate } = require(\"../linter\");\n\nconst ajv = require(\"../shared/ajv\")({ strictDefaults: true });\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\nlet defaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"errors\",\n    \"output\"\n];\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\nfunction sanitize(text) {\n    return text.replace(\n        /[\\u0000-\\u0009|\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex\n        c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`\n    );\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\n\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction itDefaultHandler(text, method) {\n    try {\n        return method.call(this);\n    } catch (err) {\n        if (err instanceof assert.AssertionError) {\n            err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n        }\n        throw err;\n    }\n}\n\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction describeDefaultHandler(text, method) {\n    return method.call(this);\n}\n\nclass RuleTester {\n\n    /**\n     * Creates a new instance of RuleTester.\n     * @param {Object} [testerConfig] Optional, extra configuration for the tester\n     */\n    constructor(testerConfig) {\n\n        /**\n         * The configuration to use for this tester. Combination of the tester\n         * configuration and the default configuration.\n         * @type {Object}\n         */\n        this.testerConfig = lodash.merge(\n\n            // we have to clone because merge uses the first argument for recipient\n            lodash.cloneDeep(defaultConfig),\n            testerConfig,\n            { rules: { \"rule-tester/validate-ast\": \"error\" } }\n        );\n\n        /**\n         * Rule definitions to define before tests.\n         * @type {Object}\n         */\n        this.rules = {};\n        this.linter = new Linter();\n    }\n\n    /**\n     * Set the configuration to use for all future tests\n     * @param {Object} config the configuration to use.\n     * @returns {void}\n     */\n    static setDefaultConfig(config) {\n        if (typeof config !== \"object\") {\n            throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n        }\n        defaultConfig = config;\n\n        // Make sure the rules object exists since it is assumed to exist later\n        defaultConfig.rules = defaultConfig.rules || {};\n    }\n\n    /**\n     * Get the current configuration used for all tests\n     * @returns {Object} the current configuration\n     */\n    static getDefaultConfig() {\n        return defaultConfig;\n    }\n\n    /**\n     * Reset the configuration to the initial configuration of the tester removing\n     * any changes made until now.\n     * @returns {void}\n     */\n    static resetDefaultConfig() {\n        defaultConfig = lodash.cloneDeep(testerDefaultConfig);\n    }\n\n\n    /*\n     * If people use `mocha test.js --watch` command, `describe` and `it` function\n     * instances are different for each execution. So `describe` and `it` should get fresh instance\n     * always.\n     */\n    static get describe() {\n        return (\n            this[DESCRIBE] ||\n            (typeof describe === \"function\" ? describe : describeDefaultHandler)\n        );\n    }\n\n    static set describe(value) {\n        this[DESCRIBE] = value;\n    }\n\n    static get it() {\n        return (\n            this[IT] ||\n            (typeof it === \"function\" ? it : itDefaultHandler)\n        );\n    }\n\n    static set it(value) {\n        this[IT] = value;\n    }\n\n    /**\n     * Define a rule for one particular run of tests.\n     * @param {string} name The name of the rule to define.\n     * @param {Function} rule The rule definition.\n     * @returns {void}\n     */\n    defineRule(name, rule) {\n        this.rules[name] = rule;\n    }\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Function} rule The rule to test.\n     * @param {Object} test The collection of tests to run.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            linter = this.linter;\n\n        if (lodash.isNil(test) || typeof test !== \"object\") {\n            throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (lodash.isNil(test[scenarioType])) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n\n        linter.defineRule(ruleName, Object.assign({}, rule, {\n\n            // Create a wrapper rule that freezes the `context` properties.\n            create(context) {\n                freezeDeeply(context.options);\n                freezeDeeply(context.settings);\n                freezeDeeply(context.parserOptions);\n\n                return (typeof rule === \"function\" ? rule : rule.create)(context);\n            }\n        }));\n\n        linter.defineRules(this.rules);\n\n        /**\n         * Run the rule for the given item\n         * @param {string|Object} item Item to run the rule against\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(item) {\n            let config = lodash.cloneDeep(testerConfig),\n                code, filename, output, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                /*\n                 * Assumes everything on the item is a config except for the\n                 * parameters used by this tester\n                 */\n                const itemConfig = lodash.omit(item, RuleTesterParameters);\n\n                /*\n                 * Create the config object from the tester config and this item\n                 * specific configurations.\n                 */\n                config = lodash.merge(\n                    config,\n                    itemConfig\n                );\n            }\n\n            if (item.filename) {\n                filename = item.filename;\n            }\n\n            if (hasOwnProperty(item, \"options\")) {\n                assert(Array.isArray(item.options), \"options must be an array\");\n                config.rules[ruleName] = [1].concat(item.options);\n            } else {\n                config.rules[ruleName] = 1;\n            }\n\n            const schema = getRuleOptionsSchema(rule);\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            linter.defineRule(\"rule-tester/validate-ast\", () => ({\n                Program(node) {\n                    beforeAST = cloneDeeplyExcludesParent(node);\n                },\n                \"Program:exit\"(node) {\n                    afterAST = node;\n                }\n            }));\n\n            if (typeof config.parser === \"string\") {\n                assert(path.isAbsolute(config.parser), \"Parsers provided as strings to RuleTester must be absolute paths\");\n                linter.defineParser(config.parser, require(config.parser));\n            }\n\n            if (schema) {\n                ajv.validateSchema(schema);\n\n                if (ajv.errors) {\n                    const errors = ajv.errors.map(error => {\n                        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n                        return `\\t${field}: ${error.message}`;\n                    }).join(\"\\n\");\n\n                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n                }\n\n                /*\n                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n                 * the schema is compiled here separately from checking for `validateSchema` errors.\n                 */\n                try {\n                    ajv.compile(schema);\n                } catch (err) {\n                    throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n                }\n            }\n\n            validate(config, \"rule-tester\", id => (id === ruleName ? rule : null));\n\n            // Verify the code.\n            const messages = linter.verify(code, config, filename);\n\n            // Ignore syntax errors for backward compatibility if `errors` is a number.\n            if (typeof item.errors !== \"number\") {\n                const errorMessage = messages.find(m => m.fatal);\n\n                assert(!errorMessage, `A fatal parsing error occurred: ${errorMessage && errorMessage.message}`);\n            }\n\n            // Verify if autofix makes a syntax error or not.\n            if (messages.some(m => m.fix)) {\n                output = SourceCodeFixer.applyFixes(code, messages).output;\n                const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);\n\n                assert(!errorMessageInFix, `A fatal parsing error occurred in autofix: ${errorMessageInFix && errorMessageInFix.message}`);\n            } else {\n                output = code;\n            }\n\n            return {\n                messages,\n                output,\n                beforeAST,\n                afterAST: cloneDeeplyExcludesParent(afterAST)\n            };\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!lodash.isEqual(beforeAST, afterAST)) {\n                assert.fail(\"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(item) {\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                messages.length, util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.strictEqual(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(item) {\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n\n            if (typeof item.errors === \"number\") {\n                assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n            } else {\n                assert.strictEqual(\n                    messages.length, item.errors.length,\n                    util.format(\n                        \"Should have %d error%s but had %d: %s\",\n                        item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)\n                    )\n                );\n\n                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    const error = item.errors[i];\n                    const message = messages[i];\n\n                    assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof error === \"string\" || error instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(message.message, error);\n                    } else if (typeof error === \"object\") {\n\n                        /*\n                         * Error object.\n                         * This may have a message, messageId, data, node type, line, and/or\n                         * column.\n                         */\n                        if (hasOwnProperty(error, \"message\")) {\n                            assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n                            assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n                            assertMessageMatches(message.message, error.message);\n                        } else if (hasOwnProperty(error, \"messageId\")) {\n                            assert.ok(\n                                hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\"),\n                                \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\"\n                            );\n                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                                const friendlyIDList = `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]`;\n\n                                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n                            }\n                            assert.strictEqual(\n                                message.messageId,\n                                error.messageId,\n                                `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`\n                            );\n                            if (hasOwnProperty(error, \"data\")) {\n\n                                /*\n                                 *  if data was provided, then directly compare the returned message to a synthetic\n                                 *  interpolated message using the same message ID and data provided in the test.\n                                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                                 */\n                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n\n                                assert.strictEqual(\n                                    message.message,\n                                    rehydratedMessage,\n                                    `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`\n                                );\n                            }\n                        }\n\n                        assert.ok(\n                            hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true,\n                            \"Error must specify 'messageId' if 'data' is used.\"\n                        );\n\n                        if (error.type) {\n                            assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n                        }\n\n                        if (hasOwnProperty(error, \"line\")) {\n                            assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n                        }\n\n                        if (hasOwnProperty(error, \"column\")) {\n                            assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endLine\")) {\n                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endColumn\")) {\n                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n                        }\n\n                        if (hasOwnProperty(error, \"suggestions\")) {\n\n                            // Support asserting there are no suggestions\n                            if (!error.suggestions || (Array.isArray(error.suggestions) && error.suggestions.length === 0)) {\n                                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                                    assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                                }\n                            } else {\n                                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n\n                                error.suggestions.forEach((expectedSuggestion, index) => {\n                                    const actualSuggestion = message.suggestions[index];\n\n                                    /**\n                                     * Tests equality of a suggestion key if that key is defined in the expected output.\n                                     * @param {string} key Key to validate from the suggestion object\n                                     * @returns {void}\n                                     */\n                                    function assertSuggestionKeyEquals(key) {\n                                        if (hasOwnProperty(expectedSuggestion, key)) {\n                                            assert.deepStrictEqual(actualSuggestion[key], expectedSuggestion[key], `Error suggestion at index: ${index} should have desc of: \"${actualSuggestion[key]}\"`);\n                                        }\n                                    }\n                                    assertSuggestionKeyEquals(\"desc\");\n                                    assertSuggestionKeyEquals(\"messageId\");\n\n                                    if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                                        const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n\n                                        assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                                    }\n                                });\n                            }\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n                    }\n                }\n            }\n\n            if (hasOwnProperty(item, \"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        result.output,\n                        item.code,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n                }\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         */\n        RuleTester.describe(ruleName, () => {\n            RuleTester.describe(\"valid\", () => {\n                test.valid.forEach(valid => {\n                    RuleTester.it(sanitize(typeof valid === \"object\" ? valid.code : valid), () => {\n                        testValidTemplate(valid);\n                    });\n                });\n            });\n\n            RuleTester.describe(\"invalid\", () => {\n                test.invalid.forEach(invalid => {\n                    RuleTester.it(sanitize(invalid.code), () => {\n                        testInvalidTemplate(invalid);\n                    });\n                });\n            });\n        });\n    }\n}\n\nRuleTester[DESCRIBE] = RuleTester[IT] = null;\n\nmodule.exports = RuleTester;\n"]},"metadata":{},"sourceType":"script"}