{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.workbox = {}));\n})(this, function (exports) {\n  'use strict';\n\n  try {\n    self['workbox:window:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Sends a data object to a service worker via `postMessage` and resolves with\n   * a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will not\n   * resolve.\n   *\n   * @param {ServiceWorker} sw The service worker to send the message to.\n   * @param {Object} data An object to send to the service worker.\n   * @return {Promise<Object|undefined>}\n   *\n   * @memberof module:workbox-window\n   */\n\n\n  var messageSW = function messageSW(sw, data) {\n    return new Promise(function (resolve) {\n      var messageChannel = new MessageChannel();\n\n      messageChannel.port1.onmessage = function (evt) {\n        return resolve(evt.data);\n      };\n\n      sw.postMessage(data, [messageChannel.port2]);\n    });\n  };\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  try {\n    self['workbox:core:4.3.1'] && _();\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * The Deferred class composes Promises in a way that allows for them to be\n   * resolved or rejected from outside the constructor. In most cases promises\n   * should be used directly, but Deferreds can be necessary when the logic to\n   * resolve a promise must be separate.\n   *\n   * @private\n   */\n\n\n  var Deferred =\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  function Deferred() {\n    var _this = this;\n\n    this.promise = new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    });\n  };\n  /*\n    Copyright 2019 Google LLC\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  var logger = function () {\n    var inGroup = false;\n    var methodToColorMap = {\n      debug: \"#7f8c8d\",\n      // Gray\n      log: \"#2ecc71\",\n      // Green\n      warn: \"#f39c12\",\n      // Yellow\n      error: \"#c0392b\",\n      // Red\n      groupCollapsed: \"#3498db\",\n      // Blue\n      groupEnd: null // No colored prefix on groupEnd\n\n    };\n\n    var print = function print(method, args) {\n      var _console2;\n\n      if (method === 'groupCollapsed') {\n        // Safari doesn't print all console.groupCollapsed() arguments:\n        // https://bugs.webkit.org/show_bug.cgi?id=182754\n        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n          var _console;\n\n          (_console = console)[method].apply(_console, args);\n\n          return;\n        }\n      }\n\n      var styles = [\"background: \" + methodToColorMap[method], \"border-radius: 0.5em\", \"color: white\", \"font-weight: bold\", \"padding: 2px 0.5em\"]; // When in a group, the workbox prefix is not displayed.\n\n      var logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n      (_console2 = console)[method].apply(_console2, logPrefix.concat(args));\n\n      if (method === 'groupCollapsed') {\n        inGroup = true;\n      }\n\n      if (method === 'groupEnd') {\n        inGroup = false;\n      }\n    };\n\n    var api = {};\n\n    var _arr = Object.keys(methodToColorMap);\n\n    var _loop = function _loop() {\n      var method = _arr[_i];\n\n      api[method] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        print(method, args);\n      };\n    };\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      _loop();\n    }\n\n    return api;\n  }();\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * A minimal `EventTarget` shim.\n   * This is necessary because not all browsers support constructable\n   * `EventTarget`, so using a real `EventTarget` will error.\n   * @private\n   */\n\n\n  var EventTargetShim = /*#__PURE__*/function () {\n    /**\n     * Creates an event listener registry\n     *\n     * @private\n     */\n    function EventTargetShim() {\n      // A registry of event types to listeners.\n      this._eventListenerRegistry = {};\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n\n\n    var _proto = EventTargetShim.prototype;\n\n    _proto.addEventListener = function addEventListener(type, listener) {\n      this._getEventListenersByType(type).add(listener);\n    };\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n\n\n    _proto.removeEventListener = function removeEventListener(type, listener) {\n      this._getEventListenersByType(type).delete(listener);\n    };\n    /**\n     * @param {Event} event\n     * @private\n     */\n\n\n    _proto.dispatchEvent = function dispatchEvent(event) {\n      event.target = this;\n\n      this._getEventListenersByType(event.type).forEach(function (listener) {\n        return listener(event);\n      });\n    };\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set} An array of handler functions.\n     * @private\n     */\n\n\n    _proto._getEventListenersByType = function _getEventListenersByType(type) {\n      return this._eventListenerRegistry[type] = this._eventListenerRegistry[type] || new Set();\n    };\n\n    return EventTargetShim;\n  }();\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Returns true if two URLs have the same `.href` property. The URLS can be\n   * relative, and if they are the current location href is used to resolve URLs.\n   *\n   * @private\n   * @param {string} url1\n   * @param {string} url2\n   * @return {boolean}\n   */\n\n\n  var urlsMatch = function urlsMatch(url1, url2) {\n    return new URL(url1, location).href === new URL(url2, location).href;\n  };\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * A minimal `Event` subclass shim.\n   * This doesn't *actually* subclass `Event` because not all browsers support\n   * constructable `EventTarget`, and using a real `Event` will error.\n   * @private\n   */\n\n\n  var WorkboxEvent =\n  /**\n   * @param {string} type\n   * @param {Object} props\n   */\n  function WorkboxEvent(type, props) {\n    Object.assign(this, props, {\n      type: type\n    });\n  };\n\n  function _catch(body, recover) {\n    try {\n      var result = body();\n    } catch (e) {\n      return recover(e);\n    }\n\n    if (result && result.then) {\n      return result.then(void 0, recover);\n    }\n\n    return result;\n  }\n\n  function _async(f) {\n    return function () {\n      for (var args = [], i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      try {\n        return Promise.resolve(f.apply(this, args));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n  }\n\n  function _invoke(body, then) {\n    var result = body();\n\n    if (result && result.then) {\n      return result.then(then);\n    }\n\n    return then(result);\n  }\n\n  function _await(value, then, direct) {\n    if (direct) {\n      return then ? then(value) : value;\n    }\n\n    if (!value || !value.then) {\n      value = Promise.resolve(value);\n    }\n\n    return then ? value.then(then) : value;\n  }\n\n  function _awaitIgnored(value, direct) {\n    if (!direct) {\n      return value && value.then ? value.then(_empty) : Promise.resolve();\n    }\n  }\n\n  function _empty() {} // `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n  // chosen, but it seems to avoid false positives in my testing.\n\n\n  var WAITING_TIMEOUT_DURATION = 200; // The amount of time after a registration that we can reasonably conclude\n  // that the registration didn't trigger an update.\n\n  var REGISTRATION_TIMEOUT_DURATION = 60000;\n  /**\n   * A class to aid in handling service worker registration, updates, and\n   * reacting to service worker lifecycle events.\n   *\n   * @fires [message]{@link module:workbox-window.Workbox#message}\n   * @fires [installed]{@link module:workbox-window.Workbox#installed}\n   * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n   * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n   * @fires [activated]{@link module:workbox-window.Workbox#activated}\n   * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n   * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n   * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n   * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n   *\n   * @memberof module:workbox-window\n   */\n\n  var Workbox = /*#__PURE__*/function (_EventTargetShim) {\n    _inheritsLoose(Workbox, _EventTargetShim);\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n     *\n     * @param {string} scriptURL The service worker script associated with this\n     *     instance.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n\n\n    function Workbox(scriptURL, registerOptions) {\n      var _this;\n\n      if (registerOptions === void 0) {\n        registerOptions = {};\n      }\n\n      _this = _EventTargetShim.call(this) || this;\n      _this._scriptURL = scriptURL;\n      _this._registerOptions = registerOptions;\n      _this._updateFoundCount = 0; // Deferreds we can resolve later.\n\n      _this._swDeferred = new Deferred();\n      _this._activeDeferred = new Deferred();\n      _this._controllingDeferred = new Deferred(); // Bind event handler callbacks.\n\n      _this._onMessage = _this._onMessage.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      _this._onStateChange = _this._onStateChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      _this._onUpdateFound = _this._onUpdateFound.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      _this._onControllerChange = _this._onControllerChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      return _this;\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n\n\n    var _proto = Workbox.prototype;\n    _proto.register = _async(function (_temp) {\n      var _this2 = this;\n\n      var _ref = _temp === void 0 ? {} : _temp,\n          _ref$immediate = _ref.immediate,\n          immediate = _ref$immediate === void 0 ? false : _ref$immediate;\n\n      {\n        if (_this2._registrationTime) {\n          logger.error('Cannot re-register a Workbox instance after it has ' + 'been registered. Create a new instance instead.');\n          return;\n        }\n      }\n      return _invoke(function () {\n        if (!immediate && document.readyState !== 'complete') {\n          return _awaitIgnored(new Promise(function (res) {\n            return addEventListener('load', res);\n          }));\n        }\n      }, function () {\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        _this2._isUpdate = Boolean(navigator.serviceWorker.controller); // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n\n        _this2._compatibleControllingSW = _this2._getControllingSWIfCompatible();\n        return _await(_this2._registerScript(), function (_this2$_registerScrip) {\n          _this2._registration = _this2$_registerScrip; // If we have a compatible controller, store the controller as the \"own\"\n          // SW, resolve active/controlling deferreds and add necessary listeners.\n\n          if (_this2._compatibleControllingSW) {\n            _this2._sw = _this2._compatibleControllingSW;\n\n            _this2._activeDeferred.resolve(_this2._compatibleControllingSW);\n\n            _this2._controllingDeferred.resolve(_this2._compatibleControllingSW);\n\n            _this2._reportWindowReady(_this2._compatibleControllingSW);\n\n            _this2._compatibleControllingSW.addEventListener('statechange', _this2._onStateChange, {\n              once: true\n            });\n          } // If there's a waiting service worker with a matching URL before the\n          // `updatefound` event fires, it likely means that this site is open\n          // in another tab, or the user refreshed the page (and thus the prevoius\n          // page wasn't fully unloaded before this page started loading).\n          // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n\n\n          var waitingSW = _this2._registration.waiting;\n\n          if (waitingSW && urlsMatch(waitingSW.scriptURL, _this2._scriptURL)) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            _this2._sw = waitingSW; // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n\n            Promise.resolve().then(function () {\n              _this2.dispatchEvent(new WorkboxEvent('waiting', {\n                sw: waitingSW,\n                wasWaitingBeforeRegister: true\n              }));\n\n              {\n                logger.warn('A service worker was already waiting to activate ' + 'before this script was registered...');\n              }\n            });\n          } // If an \"own\" SW is already set, resolve the deferred.\n\n\n          if (_this2._sw) {\n            _this2._swDeferred.resolve(_this2._sw);\n          }\n\n          {\n            logger.log('Successfully registered service worker.', _this2._scriptURL);\n\n            if (navigator.serviceWorker.controller) {\n              if (_this2._compatibleControllingSW) {\n                logger.debug('A service worker with the same script URL ' + 'is already controlling this page.');\n              } else {\n                logger.debug('A service worker with a different script URL is ' + 'currently controlling the page. The browser is now fetching ' + 'the new script now...');\n              }\n            }\n\n            var currentPageIsOutOfScope = function currentPageIsOutOfScope() {\n              var scopeURL = new URL(_this2._registerOptions.scope || _this2._scriptURL, document.baseURI);\n              var scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n              return !location.pathname.startsWith(scopeURLBasePath);\n            };\n\n            if (currentPageIsOutOfScope()) {\n              logger.warn('The current page is not in scope for the registered ' + 'service worker. Was this a mistake?');\n            }\n          }\n\n          _this2._registration.addEventListener('updatefound', _this2._onUpdateFound);\n\n          navigator.serviceWorker.addEventListener('controllerchange', _this2._onControllerChange, {\n            once: true\n          }); // Add message listeners.\n\n          if ('BroadcastChannel' in self) {\n            _this2._broadcastChannel = new BroadcastChannel('workbox');\n\n            _this2._broadcastChannel.addEventListener('message', _this2._onMessage);\n          }\n\n          navigator.serviceWorker.addEventListener('message', _this2._onMessage);\n          return _this2._registration;\n        });\n      });\n    });\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n\n    _proto.getSW = _async(function () {\n      var _this3 = this; // If `this._sw` is set, resolve with that as we want `getSW()` to\n      // return the correct (new) service worker if an update is found.\n\n\n      return _this3._sw || _this3._swDeferred.promise;\n    });\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n\n    _proto.messageSW = _async(function (data) {\n      var _this4 = this;\n\n      return _await(_this4.getSW(), function (sw) {\n        return messageSW(sw, data);\n      });\n    });\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matchs.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n\n    _proto._getControllingSWIfCompatible = function _getControllingSWIfCompatible() {\n      var controller = navigator.serviceWorker.controller;\n\n      if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n        return controller;\n      }\n    };\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n\n\n    _proto._registerScript = _async(function () {\n      var _this5 = this;\n\n      return _catch(function () {\n        return _await(navigator.serviceWorker.register(_this5._scriptURL, _this5._registerOptions), function (reg) {\n          // Keep track of when registration happened, so it can be used in the\n          // `this._onUpdateFound` heuristic. Also use the presence of this\n          // property as a way to see if `.register()` has been called.\n          _this5._registrationTime = performance.now();\n          return reg;\n        });\n      }, function (error) {\n        {\n          logger.error(error);\n        } // Re-throw the error.\n\n        throw error;\n      });\n    });\n    /**\n     * Sends a message to the passed service worker that the window is ready.\n     *\n     * @param {ServiceWorker} sw\n     * @private\n     */\n\n    _proto._reportWindowReady = function _reportWindowReady(sw) {\n      messageSW(sw, {\n        type: 'WINDOW_READY',\n        meta: 'workbox-window'\n      });\n    };\n    /**\n     * @private\n     */\n\n\n    _proto._onUpdateFound = function _onUpdateFound() {\n      var installingSW = this._registration.installing; // If the script URL passed to `navigator.serviceWorker.register()` is\n      // different from the current controlling SW's script URL, we know any\n      // successful registration calls will trigger an `updatefound` event.\n      // But if the registered script URL is the same as the current controlling\n      // SW's script URL, we'll only get an `updatefound` event if the file\n      // changed since it was last registered. This can be a problem if the user\n      // opens up the same page in a different tab, and that page registers\n      // a SW that triggers an update. It's a problem because this page has no\n      // good way of knowing whether the `updatefound` event came from the SW\n      // script it registered or from a registration attempt made by a newer\n      // version of the page running in another tab.\n      // To minimize the possibility of a false positive, we use the logic here:\n\n      var updateLikelyTriggeredExternally = // Since we enforce only calling `register()` once, and since we don't\n      // add the `updatefound` event listener until the `register()` call, if\n      // `_updateFoundCount` is > 0 then it means this method has already\n      // been called, thus this SW must be external\n      this._updateFoundCount > 0 || // If the script URL of the installing SW is different from this\n      // instance's script URL, we know it's definitely not from our\n      // registration.\n      !urlsMatch(installingSW.scriptURL, this._scriptURL) || // If all of the above are false, then we use a time-based heuristic:\n      // Any `updatefound` event that occurs long after our registration is\n      // assumed to be external.\n      performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION ? // If any of the above are not true, we assume the update was\n      // triggered by this instance.\n      true : false;\n\n      if (updateLikelyTriggeredExternally) {\n        this._externalSW = installingSW;\n\n        this._registration.removeEventListener('updatefound', this._onUpdateFound);\n      } else {\n        // If the update was not triggered externally we know the installing\n        // SW is the one we registered, so we set it.\n        this._sw = installingSW;\n\n        this._swDeferred.resolve(installingSW); // The `installing` state isn't something we have a dedicated\n        // callback for, but we do log messages for it in development.\n\n\n        {\n          if (navigator.serviceWorker.controller) {\n            logger.log('Updated service worker found. Installing now...');\n          } else {\n            logger.log('Service worker is installing...');\n          }\n        }\n      } // Increment the `updatefound` count, so future invocations of this\n      // method can be sure they were triggered externally.\n\n\n      ++this._updateFoundCount; // Add a `statechange` listener regardless of whether this update was\n      // triggered externally, since we have callbacks for both.\n\n      installingSW.addEventListener('statechange', this._onStateChange);\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    _proto._onStateChange = function _onStateChange(originalEvent) {\n      var _this6 = this;\n\n      var sw = originalEvent.target;\n      var state = sw.state;\n      var isExternal = sw === this._externalSW;\n      var eventPrefix = isExternal ? 'external' : '';\n      var eventProps = {\n        sw: sw,\n        originalEvent: originalEvent\n      };\n\n      if (!isExternal && this._isUpdate) {\n        eventProps.isUpdate = true;\n      }\n\n      this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n\n      if (state === 'installed') {\n        // This timeout is used to ignore cases where the service worker calls\n        // `skipWaiting()` in the install event, thus moving it directly in the\n        // activating state. (Since all service workers *must* go through the\n        // waiting phase, the only way to detect `skipWaiting()` called in the\n        // install event is to observe that the time spent in the waiting phase\n        // is very short.)\n        // NOTE: we don't need separate timeouts for the own and external SWs\n        // since they can't go through these phases at the same time.\n        this._waitingTimeout = setTimeout(function () {\n          // Ensure the SW is still waiting (it may now be redundant).\n          if (state === 'installed' && _this6._registration.waiting === sw) {\n            _this6.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n\n            {\n              if (isExternal) {\n                logger.warn('An external service worker has installed but is ' + 'waiting for this client to close before activating...');\n              } else {\n                logger.warn('The service worker has installed but is waiting ' + 'for existing clients to close before activating...');\n              }\n            }\n          }\n        }, WAITING_TIMEOUT_DURATION);\n      } else if (state === 'activating') {\n        clearTimeout(this._waitingTimeout);\n\n        if (!isExternal) {\n          this._activeDeferred.resolve(sw);\n        }\n      }\n\n      {\n        switch (state) {\n          case 'installed':\n            if (isExternal) {\n              logger.warn('An external service worker has installed. ' + 'You may want to suggest users reload this page.');\n            } else {\n              logger.log('Registered service worker installed.');\n            }\n\n            break;\n\n          case 'activated':\n            if (isExternal) {\n              logger.warn('An external service worker has activated.');\n            } else {\n              logger.log('Registered service worker activated.');\n\n              if (sw !== navigator.serviceWorker.controller) {\n                logger.warn('The registered service worker is active but ' + 'not yet controlling the page. Reload or run ' + '`clients.claim()` in the service worker.');\n              }\n            }\n\n            break;\n\n          case 'redundant':\n            if (sw === this._compatibleControllingSW) {\n              logger.log('Previously controlling service worker now redundant!');\n            } else if (!isExternal) {\n              logger.log('Registered service worker now redundant!');\n            }\n\n            break;\n        }\n      }\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    _proto._onControllerChange = function _onControllerChange(originalEvent) {\n      var sw = this._sw;\n\n      if (sw === navigator.serviceWorker.controller) {\n        this.dispatchEvent(new WorkboxEvent('controlling', {\n          sw: sw,\n          originalEvent: originalEvent\n        }));\n        {\n          logger.log('Registered service worker now controlling this page.');\n        }\n\n        this._controllingDeferred.resolve(sw);\n      }\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    _proto._onMessage = function _onMessage(originalEvent) {\n      var data = originalEvent.data;\n      this.dispatchEvent(new WorkboxEvent('message', {\n        data: data,\n        originalEvent: originalEvent\n      }));\n    };\n\n    _createClass(Workbox, [{\n      key: \"active\",\n      get: function get() {\n        return this._activeDeferred.promise;\n      }\n      /**\n       * Resolves to the service worker registered by this instance as soon as it\n       * is controlling the page. If a service worker was already controlling at\n       * registration time then it will resolve to that if the script URLs (and\n       * optionally script versions) match, otherwise it will wait until an update\n       * is found and starts controlling the page.\n       * Note: the first time a service worker is installed it will active but\n       * not start controlling the page unless `clients.claim()` is called in the\n       * service worker.\n       *\n       * @return {Promise<ServiceWorker>}\n       */\n\n    }, {\n      key: \"controlling\",\n      get: function get() {\n        return this._controllingDeferred.promise;\n      }\n    }]);\n\n    return Workbox;\n  }(EventTargetShim); // The jsdoc comments below outline the events this instance may dispatch:\n\n  /*\n    Copyright 2019 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  exports.Workbox = Workbox;\n  exports.messageSW = messageSW;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../_version.mjs","../messageSW.mjs","../../workbox-core/_version.mjs","../../workbox-core/_private/Deferred.mjs","../../workbox-core/_private/logger.mjs","../utils/EventTargetShim.mjs","../utils/urlsMatch.mjs","../utils/WorkboxEvent.mjs","../Workbox.mjs","../index.mjs"],"names":["self","_","messageSW","messageChannel","resolve","evt","sw","Deferred","logger","inGroup","methodToColorMap","debug","log","warn","error","groupCollapsed","groupEnd","print","method","navigator","styles","logPrefix","api","Object","args","EventTargetShim","addEventListener","type","listener","removeEventListener","dispatchEvent","event","_getEventListenersByType","urlsMatch","WorkboxEvent","WAITING_TIMEOUT_DURATION","REGISTRATION_TIMEOUT_DURATION","Workbox","registerOptions","i","arguments","Promise","f","register","immediate","then","value","document","Boolean","once","waitingSW","wasWaitingBeforeRegister","currentPageIsOutOfScope","scopeURL","scopeURLBasePath","location","getSW","data","_getControllingSWIfCompatible","controller","_registerScript","performance","_reportWindowReady","meta","_onUpdateFound","installingSW","updateLikelyTriggeredExternally","_onStateChange","originalEvent","state","isExternal","eventPrefix","eventProps","setTimeout","clearTimeout","_onControllerChange","_onMessage","result","body","recover"],"mappings":";;;;;AAAA,MAAG;AAACA,IAAAA,IAAI,CAAJA,sBAAI,CAAJA,IAA8BC,CAA9BD,EAAAA;AAAJ,GAAA,CAAsC,OAAA,CAAA,EAAQ,CAAA,C,CAAA;;ACA9C;;;;;;;AAWA;;;;;;;;;;;;;;;;;AAeA,MAAME,SAAS,GAAG,SAAZA,SAAY,CAAA,EAAA,EAAA,IAAA,EAAc;AAC9B,WAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAa;AAC9B,UAAIC,cAAc,GAAG,IAArB,cAAqB,EAArB;;AACAA,MAAAA,cAAc,CAAdA,KAAAA,CAAAA,SAAAA,GAAiC,UAAA,GAAA,EAAA;AAAA,eAASC,OAAO,CAACC,GAAG,CAApB,IAAgB,CAAhB;AAAjCF,OAAAA;;AACAG,MAAAA,EAAE,CAAFA,WAAAA,CAAAA,IAAAA,EAAqB,CAACH,cAAc,CAApCG,KAAqB,CAArBA;AAHF,KAAO,CAAP;AADF,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA,MAAG;AAACN,IAAAA,IAAI,CAAJA,oBAAI,CAAJA,IAA4BC,CAA5BD,EAAAA;AAAJ,GAAA,CAAoC,OAAA,CAAA,EAAQ,CAAA,C,CAAA;;ACA5C;;;;;;;AAWA;;;;;;;;;;AAQA,MAAaO,QAAb;AACE;;;AAGA,WAAA,QAAA,GAAc;AAAA,QAAA,KAAA,GAAA,IAAA;;AACZ,SAAA,OAAA,GAAe,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC9C,MAAA,KAAI,CAAJ,OAAA,GAAA,OAAA;AACA,MAAA,KAAI,CAAJ,MAAA,GAAA,MAAA;AAFF,KAAe,CAAf;AALJ,GAAA;ACnBA;;;;;;;;AAUA,MAAMC,MAAM,GAAmD,YAAM;AACnE,QAAIC,OAAO,GAAX,KAAA;AAEA,QAAMC,gBAAgB,GAAG;AACvBC,MAAAA,KAAK,EADkB,SAAA;AACL;AAClBC,MAAAA,GAAG,EAFoB,SAAA;AAEP;AAChBC,MAAAA,IAAI,EAHmB,SAAA;AAGN;AACjBC,MAAAA,KAAK,EAJkB,SAAA;AAIL;AAClBC,MAAAA,cAAc,EALS,SAAA;AAKI;AAC3BC,MAAAA,QAAQ,EANe,IAAA,CAAA;;AAAA,KAAzB;;AASA,QAAMC,KAAK,GAAG,SAARA,KAAQ,CAAA,MAAA,EAAA,IAAA,EAAuB;AAAA,UAAA,SAAA;;AACnC,UAAIC,MAAM,KAAV,gBAAA,EAAiC;AAC/B;AACA;AACA,YAAI,iCAAA,IAAA,CAAsCC,SAAS,CAAnD,SAAI,CAAJ,EAAgE;AAAA,cAAA,QAAA;;AAC9D,WAAA,QAAA,GAAA,OAAA,EAAA,MAAA,EAAA,KAAA,CAAA,QAAA,EAAA,IAAA;;AACA;AACD;AACF;;AAED,UAAMC,MAAM,GAAG,CAAA,iBACEV,gBAAgB,CADlB,MACkB,CADlB,EAAA,sBAAA,EAAA,cAAA,EAAA,mBAAA,EAVoB,oBAUpB,CAAf,CAVmC,CAAA;;AAmBnC,UAAMW,SAAS,GAAGZ,OAAO,GAAA,EAAA,GAAQ,CAAA,WAAA,EAAcW,MAAM,CAANA,IAAAA,CAA/C,GAA+CA,CAAd,CAAjC;;AAEA,OAAA,SAAA,GAAA,OAAA,EAAA,MAAA,EAAA,KAAA,CAAA,SAAA,EAAmBC,SAAnB,CAAA,MAAmBA,CAAnB,IAAmBA,CAAnB;;AAEA,UAAIH,MAAM,KAAV,gBAAA,EAAiC;AAC/BT,QAAAA,OAAO,GAAPA,IAAAA;AACD;;AACD,UAAIS,MAAM,KAAV,UAAA,EAA2B;AACzBT,QAAAA,OAAO,GAAPA,KAAAA;AACD;AA5BH,KAAA;;AA+BA,QAAMa,GAAG,GAAT,EAAA;;AA3CmE,QAAA,IAAA,GA4C9CC,MAAM,CAANA,IAAAA,CA5C8C,gBA4C9CA,CA5C8C;;AAAA,QAAA,KAAA,GAAA,SAAA,KAAA,GAAA;AA4C9D,UAAML,MAAM,GAAA,IAAA,CAAZ,EAAY,CAAZ;;AACHI,MAAAA,GAAG,CAAHA,MAAG,CAAHA,GAAc,YAAa;AAAA,aAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAATE,IAAS,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAATA,UAAAA,IAAS,CAAA,IAAA,CAATA,GAAS,SAAA,CAAA,IAAA,CAATA;AAAS;;AACzBP,QAAAA,KAAK,CAAA,MAAA,EAALA,IAAK,CAALA;AADFK,OAAAA;AA7CiE,KAAA;;AA4CnE,SAAA,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,IAAA,CAAA,MAAA,EAAA,EAAA,EAAA,EAAoD;AAAA,MAAA,KAAA;AAInD;;AAED,WAAA,GAAA;AAlDF,GAA+D,EAA/D;ACVA;;;;;;;AAWA;;;;;;;;MAMMG,eAAAA,G;AACJ;;;;;AAKA,aAAA,eAAA,GAAc;AACZ;AACA,WAAA,sBAAA,GAAA,EAAA;AACD;AACD;;;;;;;;;WAKAC,gB,GAAAA,SAAAA,gBAAAA,CAAiBC,IAAjBD,EAAuBE,QAAvBF,EAAiC;AAC/B,WAAA,wBAAA,CAAA,IAAA,EAAA,GAAA,CAAA,QAAA;AACD,K;AAED;;;;;;;WAKAG,mB,GAAAA,SAAAA,mBAAAA,CAAoBF,IAApBE,EAA0BD,QAA1BC,EAAoC;AAClC,WAAA,wBAAA,CAAA,IAAA,EAAA,MAAA,CAAA,QAAA;AACD,K;AAED;;;;;;WAIAC,a,GAAAA,SAAAA,aAAAA,CAAcC,KAAdD,EAAqB;AACnBC,MAAAA,KAAK,CAALA,MAAAA,GAAAA,IAAAA;;AACA,WAAA,wBAAA,CAA8BA,KAAK,CAAnC,IAAA,EAAA,OAAA,CACI,UAAA,QAAA,EAAA;AAAA,eAAcH,QAAQ,CAAtB,KAAsB,CAAtB;AADJ,OAAA;AAED,K;AAED;;;;;;;;;;WAQAI,wB,GAAAA,SAAAA,wBAAAA,CAAyBL,IAAzBK,EAA+B;AAC7B,aAAO,KAAA,sBAAA,CAAA,IAAA,IACF,KAAA,sBAAA,CAAA,IAAA,KAAqC,IAD1C,GAC0C,EAD1C;AAED,K;;;;AClEH;;;;;;;AAWA;;;;;;;;;;;AASA,MAAMC,SAAS,GAAG,SAAZA,SAAY,CAAA,IAAA,EAAA,IAAA,EAAgB;AAChC,WAAO,IAAA,GAAA,CAAA,IAAA,EAAA,QAAA,EAAA,IAAA,KAAiC,IAAA,GAAA,CAAA,IAAA,EAAA,QAAA,EAAxC,IAAA;AADF,GAAA;ACpBA;;;;;;;AAUA;;;;;;;;MAMMC,YAAAA;AACJ;;;;AAIA,WAAA,YAAA,CAAA,IAAA,EAAA,KAAA,EAAyB;AACvBX,IAAAA,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAA2B;AAACI,MAAAA,IAAI,EAAJA;AAAD,KAA3BJ;AACD,G;;AC6hBI,WAAA,MAAA,CAAA,IAAA,EAAA,OAAA,EAA+B;AACrC,QAAI;AACH,UAAIsD,MAAM,GAAGC,IAAb,EAAA;AADD,KAAA,CAEE,OAAA,CAAA,EAAS;AACV,aAAOC,OAAO,CAAd,CAAc,CAAd;AACA;;AACD,QAAIF,MAAM,IAAIA,MAAM,CAApB,IAAA,EAA2B;AAC1B,aAAOA,MAAM,CAANA,IAAAA,CAAY,KAAZA,CAAAA,EAAP,OAAOA,CAAP;AACA;;AACD,WAAA,MAAA;AACA;;AAxfM,WAAA,MAAA,CAAA,CAAA,EAAmB;AACzB,WAAO,YAAW;AACjB,WAAK,IAAIrD,IAAI,GAAR,EAAA,EAAee,CAAC,GAArB,CAAA,EAA2BA,CAAC,GAAGC,SAAS,CAAxC,MAAA,EAAiDD,CAAjD,EAAA,EAAsD;AACrDf,QAAAA,IAAI,CAAJA,CAAI,CAAJA,GAAUgB,SAAS,CAAnBhB,CAAmB,CAAnBA;AACA;;AACD,UAAI;AACH,eAAOiB,OAAO,CAAPA,OAAAA,CAAgBC,CAAC,CAADA,KAAAA,CAAAA,IAAAA,EAAvB,IAAuBA,CAAhBD,CAAP;AADD,OAAA,CAEE,OAAA,CAAA,EAAS;AACV,eAAOA,OAAO,CAAPA,MAAAA,CAAP,CAAOA,CAAP;AACA;AARF,KAAA;AAUA;;AAkdM,WAAA,OAAA,CAAA,IAAA,EAAA,IAAA,EAA6B;AACnC,QAAIoC,MAAM,GAAGC,IAAb,EAAA;;AACA,QAAID,MAAM,IAAIA,MAAM,CAApB,IAAA,EAA2B;AAC1B,aAAOA,MAAM,CAANA,IAAAA,CAAP,IAAOA,CAAP;AACA;;AACD,WAAOhC,IAAI,CAAX,MAAW,CAAX;AACA;;AArdM,WAAA,MAAA,CAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAqC;AAC3C,QAAA,MAAA,EAAY;AACX,aAAOA,IAAI,GAAGA,IAAI,CAAP,KAAO,CAAP,GAAX,KAAA;AACA;;AACD,QAAI,CAAA,KAAA,IAAU,CAACC,KAAK,CAApB,IAAA,EAA2B;AAC1BA,MAAAA,KAAK,GAAGL,OAAO,CAAPA,OAAAA,CAARK,KAAQL,CAARK;AACA;;AACD,WAAOD,IAAI,GAAGC,KAAK,CAALA,IAAAA,CAAH,IAAGA,CAAH,GAAX,KAAA;AACA;;AAGM,WAAA,aAAA,CAAA,KAAA,EAAA,MAAA,EAAsC;AAC5C,QAAI,CAAJ,MAAA,EAAa;AACZ,aAAOA,KAAK,IAAIA,KAAK,CAAdA,IAAAA,GAAsBA,KAAK,CAALA,IAAAA,CAAtBA,MAAsBA,CAAtBA,GAA2CL,OAAO,CAAzD,OAAkDA,EAAlD;AACA;AACD;;AA+fM,WAAA,MAAA,GAAkB,CAAA,C,CAhlBzB;AACA;;;AACA,MAAMN,wBAAwB,GAA9B,GAAA,C,CAAA;AAGA;;AACA,MAAMC,6BAA6B,GAAnC,KAAA;AAEA;;;;;;;;;;;;;;;;;MAgBMC,OAAAA,G;;AACJ;;;;;;;;;;;;;AAWA,aAAA,OAAA,CAAA,SAAA,EAAA,eAAA,EAA6C;AAAA,UAAA,KAAA;;AAAA,UAAtBC,eAAsB,KAAA,KAAA,CAAA,EAAA;AAAtBA,QAAAA,eAAsB,GAAJ,EAAlBA;AAAsB;;AAC3C,MAAA,KAAA,GAAA,gBAAA,CAAA,IAAA,CAAA,IAAA,KAAA,IAAA;AAEA,MAAA,KAAA,CAAA,UAAA,GAAA,SAAA;AACA,MAAA,KAAA,CAAA,gBAAA,GAAA,eAAA;AACA,MAAA,KAAA,CAAA,iBAAA,GAL2C,CAK3C,CAL2C,CAAA;;AAQ3C,MAAA,KAAA,CAAA,WAAA,GAAmB,IAAnB,QAAmB,EAAnB;AACA,MAAA,KAAA,CAAA,eAAA,GAAuB,IAAvB,QAAuB,EAAvB;AACA,MAAA,KAAA,CAAA,oBAAA,GAA4B,IAVe,QAUf,EAA5B,CAV2C,CAAA;;AAa3C,MAAA,KAAA,CAAA,UAAA,GAAkB,KAAA,CAAA,UAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,sBAAA,CAAlB,KAAkB,CAAA,CAAA,CAAlB;AACA,MAAA,KAAA,CAAA,cAAA,GAAsB,KAAA,CAAA,cAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,sBAAA,CAAtB,KAAsB,CAAA,CAAA,CAAtB;AACA,MAAA,KAAA,CAAA,cAAA,GAAsB,KAAA,CAAA,cAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,sBAAA,CAAtB,KAAsB,CAAA,CAAA,CAAtB;AACA,MAAA,KAAA,CAAA,mBAAA,GAA2B,KAAA,CAAA,mBAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,sBAAA,CAA3B,KAA2B,CAAA,CAAA,CAA3B;AAhB2C,aAAA,KAAA;AAiB5C;AAED;;;;;;;;;;;;;WAUMK,Q,GAAAA,MAAAA,CAAAA,UAAAA,KAAAA,EAAmC;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,UAAA,IAAA,GAAA,KAAA,KAAA,KAAA,CAAA,GAAJ,EAAI,GAAA,KAAA;AAAA,UAAA,cAAA,GAAA,IAAA,CAAzBC,SAAyB;AAAA,UAAzBA,SAAyB,GAAA,cAAA,KAAA,KAAA,CAAA,GAAb,KAAa,GAAA,cAAA;;AACI;AACzC,YAAI,MAAA,CAAJ,iBAAA,EAA4B;AAC1BpC,UAAAA,MAAM,CAANA,KAAAA,CAAa,wDAAbA,iDAAAA;AAEA;AACD;AACF;AAPsC,aAAA,OAAA,CAAA,YAAA;AAAA,YASnC,CAAA,SAAA,IAAcuC,QAAQ,CAARA,UAAAA,KATqB,UAAA,EAAA;AAAA,iBAAA,aAAA,CAU/B,IAAA,OAAA,CAAY,UAAA,GAAA,EAAA;AAAA,mBAASrB,gBAAgB,CAAA,MAAA,EAAzB,GAAyB,CAAzB;AAVmB,WAU/B,CAV+B,CAAA;AAAA;AAAA,OAAA,EAAA,YAAA;AAavC;AACA;AACA,QAAA,MAAA,CAAA,SAAA,GAAiBsB,OAAO,CAAC7B,SAAS,CAATA,aAAAA,CAfc,UAef,CAAxB,CAfuC,CAAA;AAkBvC;AACA;;AACA,QAAA,MAAA,CAAA,wBAAA,GAAgC,MAAA,CAAhC,6BAAgC,EAAhC;AApBuC,eAAA,MAAA,CAsBZ,MAAA,CAtBY,eAsBZ,EAtBY,EAAA,UAAA,qBAAA,EAAA;AAsBvC,UAAA,MAAA,CAAA,aAAA,GAAA,qBAAA,CAtBuC,CAwBvC;AACA;;AACA,cAAI,MAAA,CAAJ,wBAAA,EAAmC;AACjC,YAAA,MAAA,CAAA,GAAA,GAAW,MAAA,CAAX,wBAAA;;AACA,YAAA,MAAA,CAAA,eAAA,CAAA,OAAA,CAA6B,MAAA,CAA7B,wBAAA;;AACA,YAAA,MAAA,CAAA,oBAAA,CAAA,OAAA,CAAkC,MAAA,CAAlC,wBAAA;;AAEA,YAAA,MAAA,CAAA,kBAAA,CAAwB,MAAA,CAAxB,wBAAA;;AACA,YAAA,MAAA,CAAA,wBAAA,CAAA,gBAAA,CAAA,aAAA,EACmB,MAAA,CADnB,cAAA,EACwC;AAAC8B,cAAAA,IAAI,EAAE;AAAP,aADxC;AAhCqC,WAAA,CAAA;AAqCvC;AACA;AACA;AACA;;;AACA,cAAMC,SAAS,GAAG,MAAA,CAAA,aAAA,CAAlB,OAAA;;AACA,cAAIA,SAAS,IAAIjB,SAAS,CAACiB,SAAS,CAAV,SAAA,EAAsB,MAAA,CAAhD,UAA0B,CAA1B,EAAkE;AAChE;AACA;AACA,YAAA,MAAA,CAAA,GAAA,GAHgE,SAGhE,CAHgE,CAAA;AAMhE;;AACAT,YAAAA,OAAO,CAAPA,OAAAA,GAAAA,IAAAA,CAAuB,YAAM;AAC3B,cAAA,MAAA,CAAA,aAAA,CAAmB,IAAA,YAAA,CAAA,SAAA,EAA4B;AAC7CnC,gBAAAA,EAAE,EAD2C,SAAA;AAE7C6C,gBAAAA,wBAAwB,EAAE;AAFmB,eAA5B,CAAnB;;AAI2C;AACzC3C,gBAAAA,MAAM,CAANA,IAAAA,CAAY,sDAAZA,sCAAAA;AAED;AARHiC,aAAAA;AAjDqC,WAAA,CAAA;;;AA8DvC,cAAI,MAAA,CAAJ,GAAA,EAAc;AACZ,YAAA,MAAA,CAAA,WAAA,CAAA,OAAA,CAAyB,MAAA,CAAzB,GAAA;AACD;;AAE0C;AACzCjC,YAAAA,MAAM,CAANA,GAAAA,CAAAA,yCAAAA,EAAsD,MAAA,CAAtDA,UAAAA;;AAEA,gBAAIW,SAAS,CAATA,aAAAA,CAAJ,UAAA,EAAwC;AACtC,kBAAI,MAAA,CAAJ,wBAAA,EAAmC;AACjCX,gBAAAA,MAAM,CAANA,KAAAA,CAAa,+CAAbA,mCAAAA;AADF,eAAA,MAGO;AACLA,gBAAAA,MAAM,CAANA,KAAAA,CAAa,qDAAA,8DAAA,GAAbA,uBAAAA;AAGD;AACF;;AAED,gBAAM4C,uBAAuB,GAAG,SAA1BA,uBAA0B,GAAM;AACpC,kBAAMC,QAAQ,GAAG,IAAA,GAAA,CACb,MAAA,CAAA,gBAAA,CAAA,KAAA,IAA+B,MAAA,CADlB,UAAA,EACmCN,QAAQ,CAD5D,OAAiB,CAAjB;AAEA,kBAAMO,gBAAgB,GAAG,IAAA,GAAA,CAAA,IAAA,EAAcD,QAAQ,CAAtB,IAAA,EAAzB,QAAA;AACA,qBAAO,CAACE,QAAQ,CAARA,QAAAA,CAAAA,UAAAA,CAAR,gBAAQA,CAAR;AAJF,aAAA;;AAMA,gBAAIH,uBAAJ,EAAA,EAA+B;AAC7B5C,cAAAA,MAAM,CAANA,IAAAA,CAAY,yDAAZA,qCAAAA;AAED;AACF;;AAED,UAAA,MAAA,CAAA,aAAA,CAAA,gBAAA,CAAA,aAAA,EAAmD,MAAA,CAAnD,cAAA;;AACAW,UAAAA,SAAS,CAATA,aAAAA,CAAAA,gBAAAA,CAAAA,kBAAAA,EACwB,MAAA,CADxBA,mBAAAA,EACkD;AAAC8B,YAAAA,IAAI,EAAE;AAAP,WADlD9B,EA7FuC,CAAA;;AAiGvC,cAAI,sBAAJ,IAAA,EAAgC;AAC9B,YAAA,MAAA,CAAA,iBAAA,GAAyB,IAAA,gBAAA,CAAzB,SAAyB,CAAzB;;AACA,YAAA,MAAA,CAAA,iBAAA,CAAA,gBAAA,CAAA,SAAA,EAAmD,MAAA,CAAnD,UAAA;AACD;;AACDA,UAAAA,SAAS,CAATA,aAAAA,CAAAA,gBAAAA,CAAAA,SAAAA,EAAoD,MAAA,CAApDA,UAAAA;AAEA,iBAAO,MAAA,CAAP,aAAA;AAvGuC,SAAA,CAAA;AAAA,OAAA,CAAA;AAwGxC,KAxGKwB,C;AA0GN;;;;;;;;;;AA6BA;;;;;;;;;;;;;;;;WAeMa,K,GAAAA,MAAAA,CAAAA,YAAQ;AAAA,UAAA,MAAA,GAAA,IAAA,CAAA,CACZ;AACA;;;AACA,aAAO,MAAA,CAAA,GAAA,IAAY,MAAA,CAAA,WAAA,CAAnB,OAAA;AACD,KAJKA,C;AAMN;;;;;;;;;;;;;;WAaMtD,S,GAAAA,MAAAA,CAAAA,UAAUuD,IAAVvD,EAAgB;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,aAAA,MAAA,CACH,MAAA,CADG,KACH,EADG,EAAA,UAAA,EAAA,EAAA;AAEpB,eAAOA,SAAS,CAAA,EAAA,EAAhB,IAAgB,CAAhB;AAFoB,OAAA,CAAA;AAGrB,KAHKA,C;AAKN;;;;;;;;WAOAwD,6B,GAAAA,SAAAA,6BAAAA,GAAgC;AAC9B,UAAMC,UAAU,GAAGxC,SAAS,CAATA,aAAAA,CAAnB,UAAA;;AACA,UAAIwC,UAAU,IAAI1B,SAAS,CAAC0B,UAAU,CAAX,SAAA,EAAuB,KAAlD,UAA2B,CAA3B,EAAoE;AAClE,eAAA,UAAA;AACD;AACF,K;AAED;;;;;;;;WAMMC,e,GAAAA,MAAAA,CAAAA,YAAkB;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,aAAA,MAAA,CAAA,YAClB;AAAA,eAAA,MAAA,CACgBzC,SAAS,CAATA,aAAAA,CAAAA,QAAAA,CACd,MAAA,CADcA,UAAAA,EACG,MAAA,CAFnB,gBACgBA,CADhB,EAAA,UAAA,GAAA,EAAA;AAIF;AACA;AACA;AACA,UAAA,MAAA,CAAA,iBAAA,GAAyB0C,WAAW,CAApC,GAAyBA,EAAzB;AAEA,iBAAA,GAAA;AATE,SAAA,CAAA;AADkB,OAAA,EAAA,UAAA,KAAA,EAWN;AAC6B;AACzCrD,UAAAA,MAAM,CAANA,KAAAA,CAAAA,KAAAA;AAFY,SAAA,CAAA;;AAKd,cAAA,KAAA;AAhBoB,OAAA,CAAA;AAkBvB,KAlBKoD,C;AAqBN;;;;;;;WAMAE,kB,GAAAA,SAAAA,kBAAAA,CAAmBxD,EAAnBwD,EAAuB;AACrB5D,MAAAA,SAAS,CAAA,EAAA,EAAK;AACZyB,QAAAA,IAAI,EADQ,cAAA;AAEZoC,QAAAA,IAAI,EAAE;AAFM,OAAL,CAAT7D;AAID,K;AAED;;;;;WAGA8D,c,GAAAA,SAAAA,cAAAA,GAAiB;AACf,UAAMC,YAAY,GAAG,KAAA,aAAA,CADN,UACf,CADe,CAAA;AAIf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAIC,+BAA+B,GAAA;AAE/B;AACA;AACA;AACA,WAAA,iBAAA,GAAA,CAAA,IAAA;AAEA;AACA;AACA,OAACjC,SAAS,CAACgC,YAAY,CAAb,SAAA,EAAyB,KAJnC,UAIU,CAJV,IAAA;AAMA;AACA;AACCJ,MAAAA,WAAW,CAAXA,GAAAA,KACG,KAAA,iBAAA,GATJ,6BAAA,GAAA;AAWQ;AAXR,UAAA,GALJ,KAAA;;AAmBA,UAAA,+BAAA,EAAqC;AACnC,aAAA,WAAA,GAAA,YAAA;;AACA,aAAA,aAAA,CAAA,mBAAA,CAAA,aAAA,EACmB,KADnB,cAAA;AAFF,OAAA,MAIO;AACL;AACA;AACA,aAAA,GAAA,GAAA,YAAA;;AACA,aAAA,WAAA,CAAA,OAAA,CAJK,YAIL,EAJK,CAAA;AAOL;;;AAC2C;AACzC,cAAI1C,SAAS,CAATA,aAAAA,CAAJ,UAAA,EAAwC;AACtCX,YAAAA,MAAM,CAANA,GAAAA,CAAAA,iDAAAA;AADF,WAAA,MAEO;AACLA,YAAAA,MAAM,CAANA,GAAAA,CAAAA,iCAAAA;AACD;AACF;AApDY,OAAA,CAAA;AAwDf;;;AACA,QAAE,KAzDa,iBAyDf,CAzDe,CAAA;AA4Df;;AACAyD,MAAAA,YAAY,CAAZA,gBAAAA,CAAAA,aAAAA,EAA6C,KAA7CA,cAAAA;AACD,K;AAED;;;;;;WAIAE,c,GAAAA,SAAAA,cAAAA,CAAeC,aAAfD,EAA8B;AAAA,UAAA,MAAA,GAAA,IAAA;;AAC5B,UAAM7D,EAAE,GAAG8D,aAAa,CAAxB,MAAA;AAD4B,UAErBC,KAFqB,GAEZ/D,EAFY,CAAA,KAAA;AAG5B,UAAMgE,UAAU,GAAGhE,EAAE,KAAK,KAA1B,WAAA;AACA,UAAMiE,WAAW,GAAGD,UAAU,GAAA,UAAA,GAA9B,EAAA;AAEA,UAAME,UAAU,GAAG;AAAClE,QAAAA,EAAE,EAAH,EAAA;AAAK8D,QAAAA,aAAa,EAAbA;AAAL,OAAnB;;AACA,UAAI,CAAA,UAAA,IAAe,KAAnB,SAAA,EAAmC;AACjCI,QAAAA,UAAU,CAAVA,QAAAA,GAAAA,IAAAA;AACD;;AAED,WAAA,aAAA,CAAmB,IAAA,YAAA,CACfD,WAAW,GADI,KAAA,EAAnB,UAAmB,CAAnB;;AAGA,UAAIF,KAAK,KAAT,WAAA,EAA2B;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,eAAA,GAAuBI,UAAU,CAAC,YAAM;AACtC;AACA,cAAIJ,KAAK,KAALA,WAAAA,IAAyB,MAAI,CAAJ,aAAA,CAAA,OAAA,KAA7B,EAAA,EAAgE;AAC9D,YAAA,MAAI,CAAJ,aAAA,CAAmB,IAAA,YAAA,CACfE,WAAW,GADI,SAAA,EAAnB,UAAmB,CAAnB;;AAG2C;AACzC,kBAAA,UAAA,EAAgB;AACd/D,gBAAAA,MAAM,CAANA,IAAAA,CAAY,qDAAZA,uDAAAA;AADF,eAAA,MAGO;AACLA,gBAAAA,MAAM,CAANA,IAAAA,CAAY,qDAAZA,oDAAAA;AAED;AACF;AACF;AAf8B,SAAA,EAAjC,wBAAiC,CAAjC;AATF,OAAA,MA0BO,IAAI6D,KAAK,KAAT,YAAA,EAA4B;AACjCK,QAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;;AACA,YAAI,CAAJ,UAAA,EAAiB;AACf,eAAA,eAAA,CAAA,OAAA,CAAA,EAAA;AACD;AACF;;AAE0C;AACzC,gBAAA,KAAA;AACE,eAAA,WAAA;AACE,gBAAA,UAAA,EAAgB;AACdlE,cAAAA,MAAM,CAANA,IAAAA,CAAY,+CAAZA,iDAAAA;AADF,aAAA,MAGO;AACLA,cAAAA,MAAM,CAANA,GAAAA,CAAAA,sCAAAA;AACD;;AACD;;AACF,eAAA,WAAA;AACE,gBAAA,UAAA,EAAgB;AACdA,cAAAA,MAAM,CAANA,IAAAA,CAAAA,2CAAAA;AADF,aAAA,MAEO;AACLA,cAAAA,MAAM,CAANA,GAAAA,CAAAA,sCAAAA;;AACA,kBAAIF,EAAE,KAAKa,SAAS,CAATA,aAAAA,CAAX,UAAA,EAA+C;AAC7CX,gBAAAA,MAAM,CAANA,IAAAA,CAAY,iDAAA,8CAAA,GAAZA,0CAAAA;AAGD;AACF;;AACD;;AACF,eAAA,WAAA;AACE,gBAAIF,EAAE,KAAK,KAAX,wBAAA,EAA0C;AACxCE,cAAAA,MAAM,CAANA,GAAAA,CAAAA,sDAAAA;AADF,aAAA,MAEO,IAAI,CAAJ,UAAA,EAAiB;AACtBA,cAAAA,MAAM,CAANA,GAAAA,CAAAA,0CAAAA;AACD;;AACD;AA3BJ;AA6BD;AACF,K;AAED;;;;;;WAIAmE,mB,GAAAA,SAAAA,mBAAAA,CAAoBP,aAApBO,EAAmC;AACjC,UAAMrE,EAAE,GAAG,KAAX,GAAA;;AACA,UAAIA,EAAE,KAAKa,SAAS,CAATA,aAAAA,CAAX,UAAA,EAA+C;AAC7C,aAAA,aAAA,CAAmB,IAAA,YAAA,CAAA,aAAA,EAAgC;AAACb,UAAAA,EAAE,EAAH,EAAA;AAAK8D,UAAAA,aAAa,EAAbA;AAAL,SAAhC,CAAnB;AAC2C;AACzC5D,UAAAA,MAAM,CAANA,GAAAA,CAAAA,sDAAAA;AACD;;AACD,aAAA,oBAAA,CAAA,OAAA,CAAA,EAAA;AACD;AACF,K;AAED;;;;;;WAIAoE,U,GAAAA,SAAAA,UAAAA,CAAWR,aAAXQ,EAA0B;AAAA,UACjBnB,IADiB,GACTW,aADS,CAAA,IAAA;AAExB,WAAA,aAAA,CAAmB,IAAA,YAAA,CAAA,SAAA,EAA4B;AAACX,QAAAA,IAAI,EAAL,IAAA;AAAOW,QAAAA,aAAa,EAAbA;AAAP,OAA5B,CAAnB;AACD,K;;;;0BA9RY;AACX,eAAO,KAAA,eAAA,CAAP,OAAA;AACD;AAED;;;;;;;;;;;;;;;0BAYkB;AAChB,eAAO,KAAA,oBAAA,CAAP,OAAA;AACD;;;;IA9KmB3C,e,GAAAA;;AC1CtB","sourcesContent":["try{self['workbox:window:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n *\n * @memberof module:workbox-window\n */\nconst messageSW = (sw, data) => {\n  return new Promise((resolve) => {\n    let messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = (evt) => resolve(evt.data);\n    sw.postMessage(data, [messageChannel.port2]);\n  });\n};\n\nexport {messageSW};\n","try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\nexport {logger};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nclass EventTargetShim {\n  /**\n   * Creates an event listener registry\n   *\n   * @private\n   */\n  constructor() {\n    // A registry of event types to listeners.\n    this._eventListenerRegistry = {};\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  addEventListener(type, listener) {\n    this._getEventListenersByType(type).add(listener);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  removeEventListener(type, listener) {\n    this._getEventListenersByType(type).delete(listener);\n  }\n\n  /**\n   * @param {Event} event\n   * @private\n   */\n  dispatchEvent(event) {\n    event.target = this;\n    this._getEventListenersByType(event.type).forEach(\n        (listener) => listener(event));\n  }\n\n  /**\n   * Returns a Set of listeners associated with the passed event type.\n   * If no handlers have been registered, an empty Set is returned.\n   *\n   * @param {string} type The event type.\n   * @return {Set} An array of handler functions.\n   * @private\n   */\n  _getEventListenersByType(type) {\n    return this._eventListenerRegistry[type] =\n        (this._eventListenerRegistry[type] || new Set());\n  }\n}\n\nexport {EventTargetShim};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nconst urlsMatch = (url1, url2) => {\n  return new URL(url1, location).href === new URL(url2, location).href;\n};\n\nexport {urlsMatch};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nclass WorkboxEvent {\n  /**\n   * @param {string} type\n   * @param {Object} props\n   */\n  constructor(type, props) {\n    Object.assign(this, props, {type});\n  }\n}\n\nexport {WorkboxEvent};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {messageSW} from './messageSW.mjs';\nimport {EventTargetShim} from './utils/EventTargetShim.mjs';\nimport {urlsMatch} from './utils/urlsMatch.mjs';\nimport {WorkboxEvent} from './utils/WorkboxEvent.mjs';\nimport './_version.mjs';\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n *\n * @memberof module:workbox-window\n */\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0;\n\n    // Deferreds we can resolve later.\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n\n    // Bind event handler callbacks.\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n  async register({immediate = false} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' +\n            'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise((res) => addEventListener('load', res));\n    }\n\n    // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n    this._isUpdate = Boolean(navigator.serviceWorker.controller);\n\n    // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n\n    this._registration = await this._registerScript();\n\n    // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n      this._compatibleControllingSW.addEventListener(\n          'statechange', this._onStateChange, {once: true});\n    }\n\n    // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the prevoius\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n    const waitingSW = this._registration.waiting;\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW;\n\n      // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true,\n        }));\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' +\n              'before this script was registered...');\n        }\n      });\n    }\n\n    // If an \"own\" SW is already set, resolve the deferred.\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' +\n              'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' +\n              'currently controlling the page. The browser is now fetching ' +\n              'the new script now...');\n        }\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(\n            this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' +\n            'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n    navigator.serviceWorker.addEventListener(\n        'controllerchange', this._onControllerChange, {once: true});\n\n    // Add message listeners.\n    if ('BroadcastChannel' in self) {\n      this._broadcastChannel = new BroadcastChannel('workbox');\n      this._broadcastChannel.addEventListener('message', this._onMessage);\n    }\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n\n    return this._registration;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get active() {\n    return this._activeDeferred.promise;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  async getSW() {\n    // If `this._sw` is set, resolve with that as we want `getSW()` to\n    // return the correct (new) service worker if an update is found.\n    return this._sw || this._swDeferred.promise;\n  }\n\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return messageSW(sw, data);\n  }\n\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matchs.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    }\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(\n          this._scriptURL, this._registerOptions);\n\n      // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n      this._registrationTime = performance.now();\n\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      }\n      // Re-throw the error.\n      throw error;\n    }\n  }\n\n\n  /**\n   * Sends a message to the passed service worker that the window is ready.\n   *\n   * @param {ServiceWorker} sw\n   * @private\n   */\n  _reportWindowReady(sw) {\n    messageSW(sw, {\n      type: 'WINDOW_READY',\n      meta: 'workbox-window',\n    });\n  }\n\n  /**\n   * @private\n   */\n  _onUpdateFound() {\n    const installingSW = this._registration.installing;\n\n    // If the script URL passed to `navigator.serviceWorker.register()` is\n    // different from the current controlling SW's script URL, we know any\n    // successful registration calls will trigger an `updatefound` event.\n    // But if the registered script URL is the same as the current controlling\n    // SW's script URL, we'll only get an `updatefound` event if the file\n    // changed since it was last registered. This can be a problem if the user\n    // opens up the same page in a different tab, and that page registers\n    // a SW that triggers an update. It's a problem because this page has no\n    // good way of knowing whether the `updatefound` event came from the SW\n    // script it registered or from a registration attempt made by a newer\n    // version of the page running in another tab.\n    // To minimize the possibility of a false positive, we use the logic here:\n    let updateLikelyTriggeredExternally =\n        // Since we enforce only calling `register()` once, and since we don't\n        // add the `updatefound` event listener until the `register()` call, if\n        // `_updateFoundCount` is > 0 then it means this method has already\n        // been called, thus this SW must be external\n        this._updateFoundCount > 0 ||\n        // If the script URL of the installing SW is different from this\n        // instance's script URL, we know it's definitely not from our\n        // registration.\n        !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n        // If all of the above are false, then we use a time-based heuristic:\n        // Any `updatefound` event that occurs long after our registration is\n        // assumed to be external.\n        (performance.now() >\n            this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n\n    if (updateLikelyTriggeredExternally) {\n      this._externalSW = installingSW;\n      this._registration.removeEventListener(\n          'updatefound', this._onUpdateFound);\n    } else {\n      // If the update was not triggered externally we know the installing\n      // SW is the one we registered, so we set it.\n      this._sw = installingSW;\n      this._swDeferred.resolve(installingSW);\n\n      // The `installing` state isn't something we have a dedicated\n      // callback for, but we do log messages for it in development.\n      if (process.env.NODE_ENV !== 'production') {\n        if (navigator.serviceWorker.controller) {\n          logger.log('Updated service worker found. Installing now...');\n        } else {\n          logger.log('Service worker is installing...');\n        }\n      }\n    }\n\n    // Increment the `updatefound` count, so future invocations of this\n    // method can be sure they were triggered externally.\n    ++this._updateFoundCount;\n\n    // Add a `statechange` listener regardless of whether this update was\n    // triggered externally, since we have callbacks for both.\n    installingSW.addEventListener('statechange', this._onStateChange);\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onStateChange(originalEvent) {\n    const sw = originalEvent.target;\n    const {state} = sw;\n    const isExternal = sw === this._externalSW;\n    const eventPrefix = isExternal ? 'external' : '';\n\n    const eventProps = {sw, originalEvent};\n    if (!isExternal && this._isUpdate) {\n      eventProps.isUpdate = true;\n    }\n\n    this.dispatchEvent(new WorkboxEvent(\n        eventPrefix + state, eventProps));\n\n    if (state === 'installed') {\n      // This timeout is used to ignore cases where the service worker calls\n      // `skipWaiting()` in the install event, thus moving it directly in the\n      // activating state. (Since all service workers *must* go through the\n      // waiting phase, the only way to detect `skipWaiting()` called in the\n      // install event is to observe that the time spent in the waiting phase\n      // is very short.)\n      // NOTE: we don't need separate timeouts for the own and external SWs\n      // since they can't go through these phases at the same time.\n      this._waitingTimeout = setTimeout(() => {\n        // Ensure the SW is still waiting (it may now be redundant).\n        if (state === 'installed' && this._registration.waiting === sw) {\n          this.dispatchEvent(new WorkboxEvent(\n              eventPrefix + 'waiting', eventProps));\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (isExternal) {\n              logger.warn('An external service worker has installed but is ' +\n                  'waiting for this client to close before activating...');\n            } else {\n              logger.warn('The service worker has installed but is waiting ' +\n                  'for existing clients to close before activating...');\n            }\n          }\n        }\n      }, WAITING_TIMEOUT_DURATION);\n    } else if (state === 'activating') {\n      clearTimeout(this._waitingTimeout);\n      if (!isExternal) {\n        this._activeDeferred.resolve(sw);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      switch (state) {\n        case 'installed':\n          if (isExternal) {\n            logger.warn('An external service worker has installed. ' +\n                'You may want to suggest users reload this page.');\n          } else {\n            logger.log('Registered service worker installed.');\n          }\n          break;\n        case 'activated':\n          if (isExternal) {\n            logger.warn('An external service worker has activated.');\n          } else {\n            logger.log('Registered service worker activated.');\n            if (sw !== navigator.serviceWorker.controller) {\n              logger.warn('The registered service worker is active but ' +\n                  'not yet controlling the page. Reload or run ' +\n                  '`clients.claim()` in the service worker.');\n            }\n          }\n          break;\n        case 'redundant':\n          if (sw === this._compatibleControllingSW) {\n            logger.log('Previously controlling service worker now redundant!');\n          } else if (!isExternal) {\n            logger.log('Registered service worker now redundant!');\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onControllerChange(originalEvent) {\n    const sw = this._sw;\n    if (sw === navigator.serviceWorker.controller) {\n      this.dispatchEvent(new WorkboxEvent('controlling', {sw, originalEvent}));\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered service worker now controlling this page.');\n      }\n      this._controllingDeferred.resolve(sw);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onMessage(originalEvent) {\n    const {data} = originalEvent;\n    this.dispatchEvent(new WorkboxEvent('message', {data, originalEvent}));\n  }\n}\n\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` (or a\n * `BroadcastChannel` message with the `workbox` channel name) is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The native `controllerchange` event\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-external-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\nexport {Workbox};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {messageSW} from './messageSW.mjs';\nimport {Workbox} from './Workbox.mjs';\nimport './_version.mjs';\n\n\n/**\n * @module workbox-window\n */\nexport {\n  Workbox,\n  messageSW,\n};\n"]},"metadata":{},"sourceType":"script"}