{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.acorn = {});\n})(this, function (exports) {\n  'use strict'; // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  }; // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n  var keywordRelationalOperator = /^in(stanceof)?$/; // ## Character categories\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n  // eslint-disable-next-line comma-spacing\n\n  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541]; // eslint-disable-next-line comma-spacing\n\n  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n\n      if (pos > code) {\n        return false;\n      }\n\n      pos += set[i + 1];\n\n      if (pos >= code) {\n        return true;\n      }\n    }\n  } // Test whether a given character code starts an identifier.\n\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) {\n      return code === 36;\n    }\n\n    if (code < 91) {\n      return true;\n    }\n\n    if (code < 97) {\n      return code === 95;\n    }\n\n    if (code < 123) {\n      return true;\n    }\n\n    if (code <= 0xffff) {\n      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    }\n\n    if (astral === false) {\n      return false;\n    }\n\n    return isInAstralSet(code, astralIdentifierStartCodes);\n  } // Test whether a given character is part of an identifier.\n\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) {\n      return code === 36;\n    }\n\n    if (code < 58) {\n      return true;\n    }\n\n    if (code < 65) {\n      return false;\n    }\n\n    if (code < 91) {\n      return true;\n    }\n\n    if (code < 97) {\n      return code === 95;\n    }\n\n    if (code < 123) {\n      return true;\n    }\n\n    if (code <= 0xffff) {\n      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    }\n\n    if (astral === false) {\n      return false;\n    }\n\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n  } // ## Token types\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n\n  var TokenType = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {\n      beforeExpr: true,\n      binop: prec\n    });\n  }\n\n  var beforeExpr = {\n    beforeExpr: true\n  };\n  var startsExpr = {\n    startsExpr: true\n  }; // Map keyword names to token types.\n\n  var keywords$1 = {}; // Succinct definitions of keyword token types\n\n  function kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options);\n  }\n\n  var types = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new TokenType(\"=\", {\n      beforeExpr: true,\n      isAssign: true\n    }),\n    assign: new TokenType(\"_=\", {\n      beforeExpr: true,\n      isAssign: true\n    }),\n    incDec: new TokenType(\"++/--\", {\n      prefix: true,\n      postfix: true,\n      startsExpr: true\n    }),\n    prefix: new TokenType(\"!/~\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {\n      beforeExpr: true,\n      binop: 9,\n      prefix: true,\n      startsExpr: true\n    }),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {\n      beforeExpr: true\n    }),\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {\n      isLoop: true,\n      beforeExpr: true\n    }),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {\n      isLoop: true\n    }),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {\n      isLoop: true\n    }),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\"),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {\n      beforeExpr: true,\n      binop: 7\n    }),\n    _instanceof: kw(\"instanceof\", {\n      beforeExpr: true,\n      binop: 7\n    }),\n    _typeof: kw(\"typeof\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    _void: kw(\"void\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    _delete: kw(\"delete\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    })\n  }; // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code, ecma2019String) {\n    return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString; // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return hasOwnProperty.call(obj, propName);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return toString.call(obj) === \"[object Array]\";\n  }; // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n\n    if (p.sourceFile !== null) {\n      this.source = p.sourceFile;\n    }\n  }; // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur);\n      }\n    }\n  } // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n    // for strict mode, the set of reserved words, and support for\n    // new syntax features. The default is 7.\n    ecmaVersion: 7,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // th position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false,\n    plugins: {}\n  }; // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions) {\n      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];\n    }\n\n    if (options.ecmaVersion >= 2015) {\n      options.ecmaVersion -= 2009;\n    }\n\n    if (options.allowReserved == null) {\n      options.allowReserved = options.ecmaVersion < 5;\n    }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n\n      options.onToken = function (token) {\n        return tokens.push(token);\n      };\n    }\n\n    if (isArray(options.onComment)) {\n      options.onComment = pushComment(options, options.onComment);\n    }\n\n    return options;\n  }\n\n  function pushComment(options, array) {\n    return function (block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n\n      if (options.locations) {\n        comment.loc = new SourceLocation(this, startLoc, endLoc);\n      }\n\n      if (options.ranges) {\n        comment.range = [start, end];\n      }\n\n      array.push(comment);\n    };\n  } // Registered plugins\n\n\n  var plugins = {};\n\n  function keywordRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\");\n  }\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n    var reserved = \"\";\n\n    if (!options.allowReserved) {\n      for (var v = options.ecmaVersion;; v--) {\n        if (reserved = reservedWords[v]) {\n          break;\n        }\n      }\n\n      if (options.sourceType === \"module\") {\n        reserved += \" await\";\n      }\n    }\n\n    this.reservedWords = keywordRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = keywordRegexp(reservedStrict);\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input); // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n\n    this.containsEsc = false; // Load plugins\n\n    this.loadPlugins(options.plugins); // Set up token state\n    // The current position of the tokenizer in the input.\n\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    } // Properties of the current token:\n    // Its type\n\n\n    this.type = types.eof; // For tokens that include more information than their type, the value\n\n    this.value = null; // Its start and end offset\n\n    this.start = this.end = this.pos; // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n\n    this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token\n\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n\n    this.context = this.initialContext();\n    this.exprAllowed = true; // Figure out if it's a module code.\n\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function\n\n    this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator, an async function.\n\n    this.inFunction = this.inGenerator = this.inAsync = false; // Positions to delayed-check that yield/await does not exist in default parameters.\n\n    this.yieldPos = this.awaitPos = 0; // Labels in scope.\n\n    this.labels = []; // If enabled, skip leading hashbang line.\n\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n      this.skipLineComment(2);\n    } // Scope tracking for duplicate variable names (see scope.js)\n\n\n    this.scopeStack = [];\n    this.enterFunctionScope(); // For RegExp validation\n\n    this.regexpState = null;\n  }; // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n\n\n  Parser.prototype.isKeyword = function isKeyword(word) {\n    return this.keywords.test(word);\n  };\n\n  Parser.prototype.isReservedWord = function isReservedWord(word) {\n    return this.reservedWords.test(word);\n  };\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n    var this$1 = this;\n\n    for (var name in pluginConfigs) {\n      var plugin = plugins[name];\n\n      if (!plugin) {\n        throw new Error(\"Plugin '\" + name + \"' not found\");\n      }\n\n      plugin(this$1, pluginConfigs[name]);\n    }\n  };\n\n  Parser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n  };\n\n  var pp = Parser.prototype; // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\n\n  pp.strictDirective = function (start) {\n    var this$1 = this;\n\n    for (;;) {\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this$1.input)[0].length;\n      var match = literal.exec(this$1.input.slice(start));\n\n      if (!match) {\n        return false;\n      }\n\n      if ((match[1] || match[2]) === \"use strict\") {\n        return true;\n      }\n\n      start += match[0].length;\n    }\n  }; // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n\n  pp.eat = function (type) {\n    if (this.type === type) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }; // Tests whether parsed token is a contextual keyword.\n\n\n  pp.isContextual = function (name) {\n    return this.type === types.name && this.value === name && !this.containsEsc;\n  }; // Consumes contextual keyword if possible.\n\n\n  pp.eatContextual = function (name) {\n    if (!this.isContextual(name)) {\n      return false;\n    }\n\n    this.next();\n    return true;\n  }; // Asserts that following token is given contextual keyword.\n\n\n  pp.expectContextual = function (name) {\n    if (!this.eatContextual(name)) {\n      this.unexpected();\n    }\n  }; // Test whether a semicolon can be inserted at the current position.\n\n\n  pp.canInsertSemicolon = function () {\n    return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  };\n\n  pp.insertSemicolon = function () {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon) {\n        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n      }\n\n      return true;\n    }\n  }; // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n\n  pp.semicolon = function () {\n    if (!this.eat(types.semi) && !this.insertSemicolon()) {\n      this.unexpected();\n    }\n  };\n\n  pp.afterTrailingComma = function (tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma) {\n        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n      }\n\n      if (!notNext) {\n        this.next();\n      }\n\n      return true;\n    }\n  }; // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n\n  pp.expect = function (type) {\n    this.eat(type) || this.unexpected();\n  }; // Raise an unexpected token error.\n\n\n  pp.unexpected = function (pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  function DestructuringErrors() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n  }\n\n  pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) {\n      return;\n    }\n\n    if (refDestructuringErrors.trailingComma > -1) {\n      this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n    }\n\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n\n    if (parens > -1) {\n      this.raiseRecoverable(parens, \"Parenthesized pattern\");\n    }\n  };\n\n  pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) {\n      return false;\n    }\n\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n\n    if (!andThrow) {\n      return shorthandAssign >= 0 || doubleProto >= 0;\n    }\n\n    if (shorthandAssign >= 0) {\n      this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n    }\n\n    if (doubleProto >= 0) {\n      this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n    }\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function () {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n      this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n    }\n\n    if (this.awaitPos) {\n      this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n    }\n  };\n\n  pp.isSimpleAssignTarget = function (expr) {\n    if (expr.type === \"ParenthesizedExpression\") {\n      return this.isSimpleAssignTarget(expr.expression);\n    }\n\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n  };\n\n  var pp$1 = Parser.prototype; // ### Statement parsing\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function (node) {\n    var this$1 = this;\n    var exports = {};\n\n    if (!node.body) {\n      node.body = [];\n    }\n\n    while (this.type !== types.eof) {\n      var stmt = this$1.parseStatement(true, true, exports);\n      node.body.push(stmt);\n    }\n\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType;\n    }\n\n    return this.finishNode(node, \"Program\");\n  };\n\n  var loopLabel = {\n    kind: \"loop\"\n  };\n  var switchLabel = {\n    kind: \"switch\"\n  };\n\n  pp$1.isLet = function () {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n      return false;\n    }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length,\n        nextCh = this.input.charCodeAt(next);\n\n    if (nextCh === 91 || nextCh === 123) {\n      return true;\n    } // '{' and '['\n\n\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) {\n        ++pos;\n      }\n\n      var ident = this.input.slice(next, pos);\n\n      if (!keywordRelationalOperator.test(ident)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n\n\n  pp$1.isAsyncFunction = function () {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n      return false;\n    }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));\n  }; // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n\n  pp$1.parseStatement = function (declaration, topLevel, exports) {\n    var starttype = this.type,\n        node = this.startNode(),\n        kind;\n\n    if (this.isLet()) {\n      starttype = types._var;\n      kind = \"let\";\n    } // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (!declaration && this.options.ecmaVersion >= 6) {\n          this.unexpected();\n        }\n\n        return this.parseFunctionStatement(node, false);\n\n      case types._class:\n        if (!declaration) {\n          this.unexpected();\n        }\n\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.value;\n\n        if (!declaration && kind !== \"var\") {\n          this.unexpected();\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._export:\n      case types._import:\n        if (!this.options.allowImportExportEverywhere) {\n          if (!topLevel) {\n            this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n          }\n\n          if (!this.inModule) {\n            this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n          }\n        }\n\n        return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n      default:\n        if (this.isAsyncFunction()) {\n          if (!declaration) {\n            this.unexpected();\n          }\n\n          this.next();\n          return this.parseFunctionStatement(node, true);\n        }\n\n        var maybeName = this.value,\n            expr = this.parseExpression();\n\n        if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n          return this.parseLabeledStatement(node, maybeName, expr);\n        } else {\n          return this.parseExpressionStatement(node, expr);\n        }\n\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function (node, keyword) {\n    var this$1 = this;\n    var isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.eat(types.semi) || this.insertSemicolon()) {\n      node.label = null;\n    } else if (this.type !== types.name) {\n      this.unexpected();\n    } else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    } // Verify that there is an actual destination to break or\n    // continue to.\n\n\n    var i = 0;\n\n    for (; i < this.labels.length; ++i) {\n      var lab = this$1.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n          break;\n        }\n\n        if (node.label && isBreak) {\n          break;\n        }\n      }\n    }\n\n    if (i === this.labels.length) {\n      this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  };\n\n  pp$1.parseDebuggerStatement = function (node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  };\n\n  pp$1.parseDoStatement = function (node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n\n    if (this.options.ecmaVersion >= 6) {\n      this.eat(types.semi);\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"DoWhileStatement\");\n  }; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n\n  pp$1.parseForStatement = function (node) {\n    this.next();\n    var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterLexicalScope();\n    this.expect(types.parenL);\n\n    if (this.type === types.semi) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    var isLet = this.isLet();\n\n    if (this.type === types._var || this.type === types._const || isLet) {\n      var init$1 = this.startNode(),\n          kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n\n      if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1 && !(kind !== \"var\" && init$1.declarations[0].init)) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types._in) {\n            if (awaitAt > -1) {\n              this.unexpected(awaitAt);\n            }\n          } else {\n            node.await = awaitAt > -1;\n          }\n        }\n\n        return this.parseForIn(node, init$1);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init$1);\n    }\n\n    var refDestructuringErrors = new DestructuringErrors();\n    var init = this.parseExpression(true, refDestructuringErrors);\n\n    if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n          }\n        } else {\n          node.await = awaitAt > -1;\n        }\n      }\n\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLVal(init);\n      return this.parseForIn(node, init);\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  };\n\n  pp$1.parseFunctionStatement = function (node, isAsync) {\n    this.next();\n    return this.parseFunction(node, true, false, isAsync);\n  };\n\n  pp$1.parseIfStatement = function (node) {\n    this.next();\n    node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode\n\n    node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n    node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n    return this.finishNode(node, \"IfStatement\");\n  };\n\n  pp$1.parseReturnStatement = function (node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.start, \"'return' outside of function\");\n    }\n\n    this.next(); // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types.semi) || this.insertSemicolon()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  };\n\n  pp$1.parseSwitchStatement = function (node) {\n    var this$1 = this;\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types.braceL);\n    this.labels.push(switchLabel);\n    this.enterLexicalScope(); // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n\n    for (var sawDefault = false; this.type !== types.braceR;) {\n      if (this$1.type === types._case || this$1.type === types._default) {\n        var isCase = this$1.type === types._case;\n\n        if (cur) {\n          this$1.finishNode(cur, \"SwitchCase\");\n        }\n\n        node.cases.push(cur = this$1.startNode());\n        cur.consequent = [];\n        this$1.next();\n\n        if (isCase) {\n          cur.test = this$1.parseExpression();\n        } else {\n          if (sawDefault) {\n            this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\");\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this$1.expect(types.colon);\n      } else {\n        if (!cur) {\n          this$1.unexpected();\n        }\n\n        cur.consequent.push(this$1.parseStatement(true));\n      }\n    }\n\n    this.exitLexicalScope();\n\n    if (cur) {\n      this.finishNode(cur, \"SwitchCase\");\n    }\n\n    this.next(); // Closing brace\n\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  };\n\n  pp$1.parseThrowStatement = function (node) {\n    this.next();\n\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n      this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }; // Reused empty array added for node fields that are always empty.\n\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function (node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.type === types._catch) {\n      var clause = this.startNode();\n      this.next();\n\n      if (this.eat(types.parenL)) {\n        clause.param = this.parseBindingAtom();\n        this.enterLexicalScope();\n        this.checkLVal(clause.param, \"let\");\n        this.expect(types.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) {\n          this.unexpected();\n        }\n\n        clause.param = null;\n        this.enterLexicalScope();\n      }\n\n      clause.body = this.parseBlock(false);\n      this.exitLexicalScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, \"Missing catch or finally clause\");\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  };\n\n  pp$1.parseVarStatement = function (node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  };\n\n  pp$1.parseWhileStatement = function (node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  };\n\n  pp$1.parseWithStatement = function (node) {\n    if (this.strict) {\n      this.raise(this.start, \"'with' in strict mode\");\n    }\n\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(false);\n    return this.finishNode(node, \"WithStatement\");\n  };\n\n  pp$1.parseEmptyStatement = function (node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  };\n\n  pp$1.parseLabeledStatement = function (node, maybeName, expr) {\n    var this$1 = this;\n\n    for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {\n      var label = list[i$1];\n\n      if (label.name === maybeName) {\n        this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n      }\n    }\n\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this$1.labels[i];\n\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this$1.start;\n        label$1.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.start\n    });\n    node.body = this.parseStatement(true);\n\n    if (node.body.type === \"ClassDeclaration\" || node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" || node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async)) {\n      this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\");\n    }\n\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  };\n\n  pp$1.parseExpressionStatement = function (node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }; // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n\n  pp$1.parseBlock = function (createNewLexicalScope) {\n    var this$1 = this;\n    if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n    var node = this.startNode();\n    node.body = [];\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.enterLexicalScope();\n    }\n\n    while (!this.eat(types.braceR)) {\n      var stmt = this$1.parseStatement(true);\n      node.body.push(stmt);\n    }\n\n    if (createNewLexicalScope) {\n      this.exitLexicalScope();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }; // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n\n  pp$1.parseFor = function (node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.type === types.semi ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.type === types.parenR ? null : this.parseExpression();\n    this.expect(types.parenR);\n    this.exitLexicalScope();\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }; // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n\n  pp$1.parseForIn = function (node, init) {\n    var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n\n    if (type === \"ForInStatement\") {\n      if (init.type === \"AssignmentPattern\" || init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (this.strict || init.declarations[0].id.type !== \"Identifier\")) {\n        this.raise(init.start, \"Invalid assignment in for-in loop head\");\n      }\n    }\n\n    node.left = init;\n    node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    this.exitLexicalScope();\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, type);\n  }; // Parse a list of variable declarations.\n\n\n  pp$1.parseVar = function (node, isFor, kind) {\n    var this$1 = this;\n    node.declarations = [];\n    node.kind = kind;\n\n    for (;;) {\n      var decl = this$1.startNode();\n      this$1.parseVarId(decl, kind);\n\n      if (this$1.eat(types.eq)) {\n        decl.init = this$1.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\"))) {\n        this$1.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n        this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n\n      node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n\n      if (!this$1.eat(types.comma)) {\n        break;\n      }\n    }\n\n    return node;\n  };\n\n  pp$1.parseVarId = function (decl, kind) {\n    decl.id = this.parseBindingAtom(kind);\n    this.checkLVal(decl.id, kind, false);\n  }; // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      node.generator = this.eat(types.star);\n    }\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n\n    if (isStatement) {\n      node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n\n      if (node.id) {\n        this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n      }\n    }\n\n    var oldInGen = this.inGenerator,\n        oldInAsync = this.inAsync,\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldInFunc = this.inFunction;\n    this.inGenerator = node.generator;\n    this.inAsync = node.async;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.inFunction = true;\n    this.enterFunctionScope();\n\n    if (!isStatement) {\n      node.id = this.type === types.name ? this.parseIdent() : null;\n    }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody);\n    this.inGenerator = oldInGen;\n    this.inAsync = oldInAsync;\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.inFunction = oldInFunc;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  };\n\n  pp$1.parseFunctionParams = function (node) {\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  }; // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  pp$1.parseClass = function (node, isStatement) {\n    var this$1 = this;\n    this.next();\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      var member = this$1.parseClassMember(classBody);\n\n      if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n        if (hadConstructor) {\n          this$1.raise(member.start, \"Duplicate constructor in the same class\");\n        }\n\n        hadConstructor = true;\n      }\n    }\n\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  };\n\n  pp$1.parseClassMember = function (classBody) {\n    var this$1 = this;\n\n    if (this.eat(types.semi)) {\n      return null;\n    }\n\n    var method = this.startNode();\n\n    var tryContextual = function (k, noLineBreak) {\n      if (noLineBreak === void 0) noLineBreak = false;\n      var start = this$1.start,\n          startLoc = this$1.startLoc;\n\n      if (!this$1.eatContextual(k)) {\n        return false;\n      }\n\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {\n        return true;\n      }\n\n      if (method.key) {\n        this$1.unexpected();\n      }\n\n      method.computed = false;\n      method.key = this$1.startNodeAt(start, startLoc);\n      method.key.name = k;\n      this$1.finishNode(method.key, \"Identifier\");\n      return false;\n    };\n\n    method.kind = \"method\";\n    method.static = tryContextual(\"static\");\n    var isGenerator = this.eat(types.star);\n    var isAsync = false;\n\n    if (!isGenerator) {\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      } else if (tryContextual(\"get\")) {\n        method.kind = \"get\";\n      } else if (tryContextual(\"set\")) {\n        method.kind = \"set\";\n      }\n    }\n\n    if (!method.key) {\n      this.parsePropertyName(method);\n    }\n\n    var key = method.key;\n\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n      if (method.kind !== \"method\") {\n        this.raise(key.start, \"Constructor can't have get/set modifier\");\n      }\n\n      if (isGenerator) {\n        this.raise(key.start, \"Constructor can't be a generator\");\n      }\n\n      if (isAsync) {\n        this.raise(key.start, \"Constructor can't be an async method\");\n      }\n\n      method.kind = \"constructor\";\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n\n    this.parseClassMethod(classBody, method, isGenerator, isAsync);\n\n    if (method.kind === \"get\" && method.value.params.length !== 0) {\n      this.raiseRecoverable(method.value.start, \"getter should have no params\");\n    }\n\n    if (method.kind === \"set\" && method.value.params.length !== 1) {\n      this.raiseRecoverable(method.value.start, \"setter should have exactly one param\");\n    }\n\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") {\n      this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\");\n    }\n\n    return method;\n  };\n\n  pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {\n    method.value = this.parseMethod(isGenerator, isAsync);\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n  };\n\n  pp$1.parseClassId = function (node, isStatement) {\n    node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n  };\n\n  pp$1.parseClassSuper = function (node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }; // Parses module export declaration.\n\n\n  pp$1.parseExport = function (node, exports) {\n    var this$1 = this;\n    this.next(); // export * from '...'\n\n    if (this.eat(types.star)) {\n      this.expectContextual(\"from\");\n\n      if (this.type !== types.string) {\n        this.unexpected();\n      }\n\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n\n        if (isAsync) {\n          this.next();\n        }\n\n        node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n      } else if (this.type === types._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    } // export var|const|let|function|class ...\n\n\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(true);\n\n      if (node.declaration.type === \"VariableDeclaration\") {\n        this.checkVariableExport(exports, node.declaration.declarations);\n      } else {\n        this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n      }\n\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n      } else {\n        // check for keywords used as local names\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          var spec = list[i];\n          this$1.checkUnreserved(spec.local);\n        }\n\n        node.source = null;\n      }\n\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n  };\n\n  pp$1.checkExport = function (exports, name, pos) {\n    if (!exports) {\n      return;\n    }\n\n    if (has(exports, name)) {\n      this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n    }\n\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function (exports, pat) {\n    var this$1 = this;\n    var type = pat.type;\n\n    if (type === \"Identifier\") {\n      this.checkExport(exports, pat.name, pat.start);\n    } else if (type === \"ObjectPattern\") {\n      for (var i = 0, list = pat.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        this$1.checkPatternExport(exports, prop);\n      }\n    } else if (type === \"ArrayPattern\") {\n      for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n        if (elt) {\n          this$1.checkPatternExport(exports, elt);\n        }\n      }\n    } else if (type === \"Property\") {\n      this.checkPatternExport(exports, pat.value);\n    } else if (type === \"AssignmentPattern\") {\n      this.checkPatternExport(exports, pat.left);\n    } else if (type === \"RestElement\") {\n      this.checkPatternExport(exports, pat.argument);\n    } else if (type === \"ParenthesizedExpression\") {\n      this.checkPatternExport(exports, pat.expression);\n    }\n  };\n\n  pp$1.checkVariableExport = function (exports, decls) {\n    var this$1 = this;\n\n    if (!exports) {\n      return;\n    }\n\n    for (var i = 0, list = decls; i < list.length; i += 1) {\n      var decl = list[i];\n      this$1.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$1.shouldParseExportStatement = function () {\n    return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n  }; // Parses a comma-separated list of module exports.\n\n\n  pp$1.parseExportSpecifiers = function (exports) {\n    var this$1 = this;\n    var nodes = [],\n        first = true; // export { x, y as z } [from '...']\n\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this$1.expect(types.comma);\n\n        if (this$1.afterTrailingComma(types.braceR)) {\n          break;\n        }\n      } else {\n        first = false;\n      }\n\n      var node = this$1.startNode();\n      node.local = this$1.parseIdent(true);\n      node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n      this$1.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }; // Parses import declaration.\n\n\n  pp$1.parseImport = function (node) {\n    this.next(); // import '...'\n\n    if (this.type === types.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }; // Parses a comma-separated list of module imports.\n\n\n  pp$1.parseImportSpecifiers = function () {\n    var this$1 = this;\n    var nodes = [],\n        first = true;\n\n    if (this.type === types.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, \"let\");\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n\n      if (!this.eat(types.comma)) {\n        return nodes;\n      }\n    }\n\n    if (this.type === types.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, \"let\");\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes;\n    }\n\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this$1.expect(types.comma);\n\n        if (this$1.afterTrailingComma(types.braceR)) {\n          break;\n        }\n      } else {\n        first = false;\n      }\n\n      var node$2 = this$1.startNode();\n      node$2.imported = this$1.parseIdent(true);\n\n      if (this$1.eatContextual(\"as\")) {\n        node$2.local = this$1.parseIdent();\n      } else {\n        this$1.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n\n      this$1.checkLVal(node$2.local, \"let\");\n      nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n    }\n\n    return nodes;\n  }; // Set `ExpressionStatement#directive` property for directive prologues.\n\n\n  pp$1.adaptDirectivePrologue = function (statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n\n  pp$1.isDirectiveCandidate = function (statement) {\n    return statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && ( // Reject parenthesized strings.\n    this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\");\n  };\n\n  var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {\n    var this$1 = this;\n\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n        case \"Identifier\":\n          if (this.inAsync && node.name === \"await\") {\n            this.raise(node.start, \"Can not use 'await' as identifier inside an async function\");\n          }\n\n          break;\n\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n          break;\n\n        case \"ObjectExpression\":\n          node.type = \"ObjectPattern\";\n\n          if (refDestructuringErrors) {\n            this.checkPatternErrors(refDestructuringErrors, true);\n          }\n\n          for (var i = 0, list = node.properties; i < list.length; i += 1) {\n            var prop = list[i];\n            this$1.toAssignable(prop, isBinding); // Early error:\n            //   AssignmentRestProperty[Yield, Await] :\n            //     `...` DestructuringAssignmentTarget[Yield, Await]\n            //\n            //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n\n            if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n              this$1.raise(prop.argument.start, \"Unexpected token\");\n            }\n          }\n\n          break;\n\n        case \"Property\":\n          // AssignmentProperty has type === \"Property\"\n          if (node.kind !== \"init\") {\n            this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n          }\n\n          this.toAssignable(node.value, isBinding);\n          break;\n\n        case \"ArrayExpression\":\n          node.type = \"ArrayPattern\";\n\n          if (refDestructuringErrors) {\n            this.checkPatternErrors(refDestructuringErrors, true);\n          }\n\n          this.toAssignableList(node.elements, isBinding);\n          break;\n\n        case \"SpreadElement\":\n          node.type = \"RestElement\";\n          this.toAssignable(node.argument, isBinding);\n\n          if (node.argument.type === \"AssignmentPattern\") {\n            this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n          }\n\n          break;\n\n        case \"AssignmentExpression\":\n          if (node.operator !== \"=\") {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n          }\n\n          node.type = \"AssignmentPattern\";\n          delete node.operator;\n          this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n\n        case \"AssignmentPattern\":\n          break;\n\n        case \"ParenthesizedExpression\":\n          this.toAssignable(node.expression, isBinding);\n          break;\n\n        case \"MemberExpression\":\n          if (!isBinding) {\n            break;\n          }\n\n        default:\n          this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) {\n      this.checkPatternErrors(refDestructuringErrors, true);\n    }\n\n    return node;\n  }; // Convert list of expression atoms to binding list.\n\n\n  pp$2.toAssignableList = function (exprList, isBinding) {\n    var this$1 = this;\n    var end = exprList.length;\n\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n\n      if (elt) {\n        this$1.toAssignable(elt, isBinding);\n      }\n    }\n\n    if (end) {\n      var last = exprList[end - 1];\n\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n        this.unexpected(last.argument.start);\n      }\n    }\n\n    return exprList;\n  }; // Parses spread element.\n\n\n  pp$2.parseSpread = function (refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n  };\n\n  pp$2.parseRestBinding = function () {\n    var node = this.startNode();\n    this.next(); // RestElement inside of a function parameter must be an identifier\n\n    if (this.options.ecmaVersion === 6 && this.type !== types.name) {\n      this.unexpected();\n    }\n\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }; // Parses lvalue (assignable) atom.\n\n\n  pp$2.parseBindingAtom = function () {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n        case types.bracketL:\n          var node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, true, true);\n          return this.finishNode(node, \"ArrayPattern\");\n\n        case types.braceL:\n          return this.parseObj(true);\n      }\n    }\n\n    return this.parseIdent();\n  };\n\n  pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {\n    var this$1 = this;\n    var elts = [],\n        first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this$1.expect(types.comma);\n      }\n\n      if (allowEmpty && this$1.type === types.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n        break;\n      } else if (this$1.type === types.ellipsis) {\n        var rest = this$1.parseRestBinding();\n        this$1.parseBindingListItem(rest);\n        elts.push(rest);\n\n        if (this$1.type === types.comma) {\n          this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n        }\n\n        this$1.expect(close);\n        break;\n      } else {\n        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n        this$1.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n\n    return elts;\n  };\n\n  pp$2.parseBindingListItem = function (param) {\n    return param;\n  }; // Parses assignment pattern around given atom if possible.\n\n\n  pp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {\n      return left;\n    }\n\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }; // Verify that a node is an lval — something that can be assigned\n  // to.\n  // bindingType can be either:\n  // 'var' indicating that the lval creates a 'var' binding\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n\n  pp$2.checkLVal = function (expr, bindingType, checkClashes) {\n    var this$1 = this;\n\n    switch (expr.type) {\n      case \"Identifier\":\n        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n          this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n        }\n\n        if (checkClashes) {\n          if (has(checkClashes, expr.name)) {\n            this.raiseRecoverable(expr.start, \"Argument name clash\");\n          }\n\n          checkClashes[expr.name] = true;\n        }\n\n        if (bindingType && bindingType !== \"none\") {\n          if (bindingType === \"var\" && !this.canDeclareVarName(expr.name) || bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)) {\n            this.raiseRecoverable(expr.start, \"Identifier '\" + expr.name + \"' has already been declared\");\n          }\n\n          if (bindingType === \"var\") {\n            this.declareVarName(expr.name);\n          } else {\n            this.declareLexicalName(expr.name);\n          }\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (bindingType) {\n          this.raiseRecoverable(expr.start, \"Binding member expression\");\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n          var prop = list[i];\n          this$1.checkLVal(prop, bindingType, checkClashes);\n        }\n\n        break;\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        this.checkLVal(expr.value, bindingType, checkClashes);\n        break;\n\n      case \"ArrayPattern\":\n        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n          var elem = list$1[i$1];\n\n          if (elem) {\n            this$1.checkLVal(elem, bindingType, checkClashes);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, bindingType, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, bindingType, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, bindingType, checkClashes);\n        break;\n\n      default:\n        this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  }; // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts — that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\n  var pp$3 = Parser.prototype; // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n      return;\n    }\n\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n      return;\n    }\n\n    var key = prop.key;\n    var name;\n\n    switch (key.type) {\n      case \"Identifier\":\n        name = key.name;\n        break;\n\n      case \"Literal\":\n        name = String(key.value);\n        break;\n\n      default:\n        return;\n    }\n\n    var kind = prop.kind;\n\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {\n            refDestructuringErrors.doubleProto = key.start;\n          } // Backwards-compat kludge. Can be removed in version 6.0\n          else {\n              this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n            }\n        }\n\n        propHash.proto = true;\n      }\n\n      return;\n    }\n\n    name = \"$\" + name;\n    var other = propHash[name];\n\n    if (other) {\n      var redefinition;\n\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n\n      if (redefinition) {\n        this.raiseRecoverable(key.start, \"Redefinition of property\");\n      }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n\n    other[kind] = true;\n  }; // ### Expression parsing\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n\n  pp$3.parseExpression = function (noIn, refDestructuringErrors) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n\n    if (this.type === types.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));\n      }\n\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }; // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n\n  pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.inGenerator && this.isContextual(\"yield\")) {\n      return this.parseYield();\n    }\n\n    var ownDestructuringErrors = false,\n        oldParenAssign = -1,\n        oldTrailingComma = -1;\n\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors();\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start,\n        startLoc = this.startLoc;\n\n    if (this.type === types.parenL || this.type === types.name) {\n      this.potentialArrowAt = this.start;\n    }\n\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n\n      if (!ownDestructuringErrors) {\n        DestructuringErrors.call(refDestructuringErrors);\n      }\n\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else {\n      if (ownDestructuringErrors) {\n        this.checkExpressionErrors(refDestructuringErrors, true);\n      }\n    }\n\n    if (oldParenAssign > -1) {\n      refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n    }\n\n    if (oldTrailingComma > -1) {\n      refDestructuringErrors.trailingComma = oldTrailingComma;\n    }\n\n    return left;\n  }; // Parse a ternary conditional (`?:`) operator.\n\n\n  pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n      return expr;\n    }\n\n    if (this.eat(types.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }; // Start the precedence parser.\n\n\n  pp$3.parseExprOps = function (noIn, refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n      return expr;\n    }\n\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }; // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n\n  pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n\n    if (prec != null && (!noIn || this.type !== types._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  };\n\n  pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n  }; // Parse unary operators, both prefix and postfix.\n\n\n  pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc,\n        expr;\n\n    if (this.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(),\n          update = this.type === types.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n\n      if (update) {\n        this.checkLVal(node.argument);\n      } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n        this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n      } else {\n        sawUnary = true;\n      }\n\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n\n      if (this.checkExpressionErrors(refDestructuringErrors)) {\n        return expr;\n      }\n\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\n        node$1.operator = this$1.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this$1.checkLVal(expr);\n        this$1.next();\n        expr = this$1.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(types.starstar)) {\n      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false);\n    } else {\n      return expr;\n    }\n  }; // Parse call, dot, and `[]`-subscript expressions.\n\n\n  pp$3.parseExprSubscripts = function (refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {\n      return expr;\n    }\n\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n        refDestructuringErrors.parenthesizedAssign = -1;\n      }\n\n      if (refDestructuringErrors.parenthesizedBind >= result.start) {\n        refDestructuringErrors.parenthesizedBind = -1;\n      }\n    }\n\n    return result;\n  };\n\n  pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n    var this$1 = this;\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n\n    for (var computed = void 0;;) {\n      if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n        var node = this$1.startNodeAt(startPos, startLoc);\n        node.object = base;\n        node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n        node.computed = !!computed;\n\n        if (computed) {\n          this$1.expect(types.bracketR);\n        }\n\n        base = this$1.finishNode(node, \"MemberExpression\");\n      } else if (!noCalls && this$1.eat(types.parenL)) {\n        var refDestructuringErrors = new DestructuringErrors(),\n            oldYieldPos = this$1.yieldPos,\n            oldAwaitPos = this$1.awaitPos;\n        this$1.yieldPos = 0;\n        this$1.awaitPos = 0;\n        var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n\n        if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n          this$1.checkPatternErrors(refDestructuringErrors, false);\n          this$1.checkYieldAwaitInDefaultParams();\n          this$1.yieldPos = oldYieldPos;\n          this$1.awaitPos = oldAwaitPos;\n          return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);\n        }\n\n        this$1.checkExpressionErrors(refDestructuringErrors, true);\n        this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n        this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\n        node$1.callee = base;\n        node$1.arguments = exprList;\n        base = this$1.finishNode(node$1, \"CallExpression\");\n      } else if (this$1.type === types.backQuote) {\n        var node$2 = this$1.startNodeAt(startPos, startLoc);\n        node$2.tag = base;\n        node$2.quasi = this$1.parseTemplate({\n          isTagged: true\n        });\n        base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n      } else {\n        return base;\n      }\n    }\n  }; // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n\n  pp$3.parseExprAtom = function (refDestructuringErrors) {\n    var node,\n        canBeArrow = this.potentialArrowAt === this.start;\n\n    switch (this.type) {\n      case types._super:\n        if (!this.inFunction) {\n          this.raise(this.start, \"'super' outside of function or class\");\n        }\n\n        node = this.startNode();\n        this.next(); // The `super` keyword can appear at below:\n        // SuperProperty:\n        //     super [ Expression ]\n        //     super . IdentifierName\n        // SuperCall:\n        //     super Arguments\n\n        if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {\n          this.unexpected();\n        }\n\n        return this.finishNode(node, \"Super\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        var startPos = this.start,\n            startLoc = this.startLoc,\n            containsEsc = this.containsEsc;\n        var id = this.parseIdent(this.type !== types.name);\n\n        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function)) {\n          return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);\n        }\n\n        if (canBeArrow && !this.canInsertSemicolon()) {\n          if (this.eat(types.arrow)) {\n            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);\n          }\n\n          if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n            id = this.parseIdent();\n\n            if (this.canInsertSemicolon() || !this.eat(types.arrow)) {\n              this.unexpected();\n            }\n\n            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);\n          }\n        }\n\n        return id;\n\n      case types.regexp:\n        var value = this.value;\n        node = this.parseLiteral(value.value);\n        node.regex = {\n          pattern: value.pattern,\n          flags: value.flags\n        };\n        return node;\n\n      case types.num:\n      case types.string:\n        return this.parseLiteral(this.value);\n\n      case types._null:\n      case types._true:\n      case types._false:\n        node = this.startNode();\n        node.value = this.type === types._null ? null : this.type === types._true;\n        node.raw = this.type.keyword;\n        this.next();\n        return this.finishNode(node, \"Literal\");\n\n      case types.parenL:\n        var start = this.start,\n            expr = this.parseParenAndDistinguishExpression(canBeArrow);\n\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n            refDestructuringErrors.parenthesizedAssign = start;\n          }\n\n          if (refDestructuringErrors.parenthesizedBind < 0) {\n            refDestructuringErrors.parenthesizedBind = start;\n          }\n        }\n\n        return expr;\n\n      case types.bracketL:\n        node = this.startNode();\n        this.next();\n        node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n        return this.finishNode(node, \"ArrayExpression\");\n\n      case types.braceL:\n        return this.parseObj(false, refDestructuringErrors);\n\n      case types._function:\n        node = this.startNode();\n        this.next();\n        return this.parseFunction(node, false);\n\n      case types._class:\n        return this.parseClass(this.startNode(), false);\n\n      case types._new:\n        return this.parseNew();\n\n      case types.backQuote:\n        return this.parseTemplate();\n\n      default:\n        this.unexpected();\n    }\n  };\n\n  pp$3.parseLiteral = function (value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    this.next();\n    return this.finishNode(node, \"Literal\");\n  };\n\n  pp$3.parseParenExpression = function () {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc,\n        val,\n        allowTrailingComma = this.options.ecmaVersion >= 8;\n\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n      var innerStartPos = this.start,\n          innerStartLoc = this.startLoc;\n      var exprList = [],\n          first = true,\n          lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors(),\n          oldYieldPos = this.yieldPos,\n          oldAwaitPos = this.awaitPos,\n          spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n\n      while (this.type !== types.parenR) {\n        first ? first = false : this$1.expect(types.comma);\n\n        if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n          lastIsComma = true;\n          break;\n        } else if (this$1.type === types.ellipsis) {\n          spreadStart = this$1.start;\n          exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n\n          if (this$1.type === types.comma) {\n            this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n          }\n\n          break;\n        } else {\n          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n        }\n      }\n\n      var innerEndPos = this.start,\n          innerEndLoc = this.startLoc;\n      this.expect(types.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList);\n      }\n\n      if (!exprList.length || lastIsComma) {\n        this.unexpected(this.lastTokStart);\n      }\n\n      if (spreadStart) {\n        this.unexpected(spreadStart);\n      }\n\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\");\n    } else {\n      return val;\n    }\n  };\n\n  pp$3.parseParenItem = function (item) {\n    return item;\n  };\n\n  pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n  }; // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function () {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n\n      if (node.property.name !== \"target\" || containsEsc) {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\");\n      }\n\n      if (!this.inFunction) {\n        this.raiseRecoverable(node.start, \"new.target can only be used in functions\");\n      }\n\n      return this.finishNode(node, \"MetaProperty\");\n    }\n\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n\n    if (this.eat(types.parenL)) {\n      node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);\n    } else {\n      node.arguments = empty$1;\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }; // Parse template expression.\n\n\n  pp$3.parseTemplateElement = function (ref) {\n    var isTagged = ref.isTagged;\n    var elem = this.startNode();\n\n    if (this.type === types.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n\n    this.next();\n    elem.tail = this.type === types.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n  };\n\n  pp$3.parseTemplate = function (ref) {\n    var this$1 = this;\n    if (ref === void 0) ref = {};\n    var isTagged = ref.isTagged;\n    if (isTagged === void 0) isTagged = false;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({\n      isTagged: isTagged\n    });\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      if (this$1.type === types.eof) {\n        this$1.raise(this$1.pos, \"Unterminated template literal\");\n      }\n\n      this$1.expect(types.dollarBraceL);\n      node.expressions.push(this$1.parseExpression());\n      this$1.expect(types.braceR);\n      node.quasis.push(curElt = this$1.parseTemplateElement({\n        isTagged: isTagged\n      }));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  };\n\n  pp$3.isAsyncProp = function (prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  }; // Parse an object literal or binding pattern.\n\n\n  pp$3.parseObj = function (isPattern, refDestructuringErrors) {\n    var this$1 = this;\n    var node = this.startNode(),\n        first = true,\n        propHash = {};\n    node.properties = [];\n    this.next();\n\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this$1.expect(types.comma);\n\n        if (this$1.afterTrailingComma(types.braceR)) {\n          break;\n        }\n      } else {\n        first = false;\n      }\n\n      var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n\n      if (!isPattern) {\n        this$1.checkPropClash(prop, propHash, refDestructuringErrors);\n      }\n\n      node.properties.push(prop);\n    }\n\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n  };\n\n  pp$3.parseProperty = function (isPattern, refDestructuringErrors) {\n    var prop = this.startNode(),\n        isGenerator,\n        isAsync,\n        startPos,\n        startLoc;\n\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n\n        return this.finishNode(prop, \"RestElement\");\n      } // To disallow parenthesized identifier via `this.toAssignable()`.\n\n\n      if (this.type === types.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      } // Parse argument.\n\n\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors); // To disallow trailing comma via `this.toAssignable()`.\n\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      } // Finish\n\n\n      return this.finishNode(prop, \"SpreadElement\");\n    }\n\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n\n      if (!isPattern) {\n        isGenerator = this.eat(types.star);\n      }\n    }\n\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\");\n  };\n\n  pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types.colon) {\n      this.unexpected();\n    }\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n      if (isPattern) {\n        this.unexpected();\n      }\n\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types.comma && this.type !== types.braceR) {\n      if (isGenerator || isAsync) {\n        this.unexpected();\n      }\n\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n\n        if (prop.kind === \"get\") {\n          this.raiseRecoverable(start, \"getter should have no params\");\n        } else {\n          this.raiseRecoverable(start, \"setter should have exactly one param\");\n        }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n          this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n        }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      this.checkUnreserved(prop.key);\n      prop.kind = \"init\";\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === types.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0) {\n          refDestructuringErrors.shorthandAssign = this.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n\n      prop.shorthand = true;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  pp$3.parsePropertyName = function (prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types.bracketR);\n        return prop.key;\n      } else {\n        prop.computed = false;\n      }\n    }\n\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);\n  }; // Initialize empty function node.\n\n\n  pp$3.initFunction = function (node) {\n    node.id = null;\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = false;\n    }\n  }; // Parse object or class method.\n\n\n  pp$3.parseMethod = function (isGenerator, isAsync) {\n    var node = this.startNode(),\n        oldInGen = this.inGenerator,\n        oldInAsync = this.inAsync,\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldInFunc = this.inFunction;\n    this.initFunction(node);\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = isGenerator;\n    }\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n\n    this.inGenerator = node.generator;\n    this.inAsync = node.async;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.inFunction = true;\n    this.enterFunctionScope();\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false);\n    this.inGenerator = oldInGen;\n    this.inAsync = oldInAsync;\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.inFunction = oldInFunc;\n    return this.finishNode(node, \"FunctionExpression\");\n  }; // Parse arrow function expression with given parameters.\n\n\n  pp$3.parseArrowExpression = function (node, params, isAsync) {\n    var oldInGen = this.inGenerator,\n        oldInAsync = this.inAsync,\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldInFunc = this.inFunction;\n    this.enterFunctionScope();\n    this.initFunction(node);\n\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n\n    this.inGenerator = false;\n    this.inAsync = node.async;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true);\n    this.inGenerator = oldInGen;\n    this.inAsync = oldInAsync;\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.inFunction = oldInFunc;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }; // Parse function body and check parameters.\n\n\n  pp$3.parseFunctionBody = function (node, isArrowFunction) {\n    var isExpression = isArrowFunction && this.type !== types.braceL;\n    var oldStrict = this.strict,\n        useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n\n        if (useStrict && nonSimple) {\n          this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n        }\n      } // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n\n\n      var oldLabels = this.labels;\n      this.labels = [];\n\n      if (useStrict) {\n        this.strict = true;\n      } // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n\n\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n      node.body = this.parseBlock(false);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n\n    this.exitFunctionScope();\n\n    if (this.strict && node.id) {\n      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n      this.checkLVal(node.id, \"none\");\n    }\n\n    this.strict = oldStrict;\n  };\n\n  pp$3.isSimpleParamList = function (params) {\n    for (var i = 0, list = params; i < list.length; i += 1) {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") {\n        return false;\n      }\n    }\n\n    return true;\n  }; // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n\n  pp$3.checkParams = function (node, allowDuplicates) {\n    var this$1 = this;\n    var nameHash = {};\n\n    for (var i = 0, list = node.params; i < list.length; i += 1) {\n      var param = list[i];\n      this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n    }\n  }; // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n\n  pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var this$1 = this;\n    var elts = [],\n        first = true;\n\n    while (!this.eat(close)) {\n      if (!first) {\n        this$1.expect(types.comma);\n\n        if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n          break;\n        }\n      } else {\n        first = false;\n      }\n\n      var elt = void 0;\n\n      if (allowEmpty && this$1.type === types.comma) {\n        elt = null;\n      } else if (this$1.type === types.ellipsis) {\n        elt = this$1.parseSpread(refDestructuringErrors);\n\n        if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {\n          refDestructuringErrors.trailingComma = this$1.start;\n        }\n      } else {\n        elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n      }\n\n      elts.push(elt);\n    }\n\n    return elts;\n  };\n\n  pp$3.checkUnreserved = function (ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\") {\n      this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\");\n    }\n\n    if (this.inAsync && name === \"await\") {\n      this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\");\n    }\n\n    if (this.isKeyword(name)) {\n      this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n    }\n\n    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n      return;\n    }\n\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\") {\n        this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\");\n      }\n\n      this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n    }\n  }; // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n\n  pp$3.parseIdent = function (liberal, isBinding) {\n    var node = this.startNode();\n\n    if (liberal && this.options.allowReserved === \"never\") {\n      liberal = false;\n    }\n\n    if (this.type === types.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword; // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n\n      if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    this.finishNode(node, \"Identifier\");\n\n    if (!liberal) {\n      this.checkUnreserved(node);\n    }\n\n    return node;\n  }; // Parses yield expression inside generator.\n\n\n  pp$3.parseYield = function () {\n    if (!this.yieldPos) {\n      this.yieldPos = this.start;\n    }\n\n    var node = this.startNode();\n    this.next();\n\n    if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  };\n\n  pp$3.parseAwait = function () {\n    if (!this.awaitPos) {\n      this.awaitPos = this.start;\n    }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\");\n  };\n\n  var pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function (pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function () {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart);\n    }\n  };\n\n  var pp$5 = Parser.prototype; // Object.assign polyfill\n\n  var assign = Object.assign || function (target) {\n    var sources = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) sources[len] = arguments[len + 1];\n\n    for (var i = 0, list = sources; i < list.length; i += 1) {\n      var source = list[i];\n\n      for (var key in source) {\n        if (has(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }; // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n\n  pp$5.enterFunctionScope = function () {\n    // var: a hash of var-declared names in the current lexical scope\n    // lexical: a hash of lexically-declared names in the current lexical scope\n    // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n    // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n    this.scopeStack.push({\n      var: {},\n      lexical: {},\n      childVar: {},\n      parentLexical: {}\n    });\n  };\n\n  pp$5.exitFunctionScope = function () {\n    this.scopeStack.pop();\n  };\n\n  pp$5.enterLexicalScope = function () {\n    var parentScope = this.scopeStack[this.scopeStack.length - 1];\n    var childScope = {\n      var: {},\n      lexical: {},\n      childVar: {},\n      parentLexical: {}\n    };\n    this.scopeStack.push(childScope);\n    assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n  };\n\n  pp$5.exitLexicalScope = function () {\n    var childScope = this.scopeStack.pop();\n    var parentScope = this.scopeStack[this.scopeStack.length - 1];\n    assign(parentScope.childVar, childScope.var, childScope.childVar);\n  };\n  /**\n   * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n   * in the current lexical scope or any of the parent lexical scopes in this function.\n   */\n\n\n  pp$5.canDeclareVarName = function (name) {\n    var currentScope = this.scopeStack[this.scopeStack.length - 1];\n    return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);\n  };\n  /**\n   * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n   * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n   * any child lexical scopes in this function.\n   */\n\n\n  pp$5.canDeclareLexicalName = function (name) {\n    var currentScope = this.scopeStack[this.scopeStack.length - 1];\n    return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);\n  };\n\n  pp$5.declareVarName = function (name) {\n    this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n  };\n\n  pp$5.declareLexicalName = function (name) {\n    this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n\n    if (parser.options.locations) {\n      this.loc = new SourceLocation(parser, loc);\n    }\n\n    if (parser.options.directSourceFile) {\n      this.sourceFile = parser.options.directSourceFile;\n    }\n\n    if (parser.options.ranges) {\n      this.range = [pos, 0];\n    }\n  }; // Start an AST node, attaching a start offset.\n\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.startNode = function () {\n    return new Node(this, this.start, this.startLoc);\n  };\n\n  pp$6.startNodeAt = function (pos, loc) {\n    return new Node(this, pos, loc);\n  }; // Finish an AST node, adding `type` and `end` properties.\n\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n\n    if (this.options.locations) {\n      node.loc.end = loc;\n    }\n\n    if (this.options.ranges) {\n      node.range[1] = pos;\n    }\n\n    return node;\n  }\n\n  pp$6.finishNode = function (node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n  }; // Finish node at given position\n\n\n  pp$6.finishNodeAt = function (node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc);\n  }; // The algorithm used to determine whether a regexp can appear at a\n  // given point in the program is loosely based on sweet.js' approach.\n  // See https://github.com/mozilla/sweet.js/wiki/design\n\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types$1 = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) {\n      return p.tryReadTemplateToken();\n    }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n  var pp$7 = Parser.prototype;\n\n  pp$7.initialContext = function () {\n    return [types$1.b_stat];\n  };\n\n  pp$7.braceIsBlock = function (prevType) {\n    var parent = this.curContext();\n\n    if (parent === types$1.f_expr || parent === types$1.f_stat) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {\n      return !parent.isExpr;\n    } // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n\n\n    if (prevType === types._return || prevType === types.name && this.exprAllowed) {\n      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.b_stat;\n    }\n\n    if (prevType === types._var || prevType === types.name) {\n      return false;\n    }\n\n    return !this.exprAllowed;\n  };\n\n  pp$7.inGeneratorContext = function () {\n    var this$1 = this;\n\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this$1.context[i];\n\n      if (context.token === \"function\") {\n        return context.generator;\n      }\n    }\n\n    return false;\n  };\n\n  pp$7.updateContext = function (prevType) {\n    var update,\n        type = this.type;\n\n    if (type.keyword && prevType === types.dot) {\n      this.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.exprAllowed = type.beforeExpr;\n    }\n  }; // Token-specific context update code\n\n\n  types.parenR.updateContext = types.braceR.updateContext = function () {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return;\n    }\n\n    var out = this.context.pop();\n\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types.braceL.updateContext = function (prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types.dollarBraceL.updateContext = function () {\n    this.context.push(types$1.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types.parenL.updateContext = function (prevType) {\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types.incDec.updateContext = function () {// tokExprAllowed stays unchanged\n  };\n\n  types._function.updateContext = types._class.updateContext = function (prevType) {\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n      this.context.push(types$1.f_expr);\n    } else {\n      this.context.push(types$1.f_stat);\n    }\n\n    this.exprAllowed = false;\n  };\n\n  types.backQuote.updateContext = function () {\n    if (this.curContext() === types$1.q_tmpl) {\n      this.context.pop();\n    } else {\n      this.context.push(types$1.q_tmpl);\n    }\n\n    this.exprAllowed = false;\n  };\n\n  types.star.updateContext = function (prevType) {\n    if (prevType === types._function) {\n      var index = this.context.length - 1;\n\n      if (this.context[index] === types$1.f_expr) {\n        this.context[index] = types$1.f_expr_gen;\n      } else {\n        this.context[index] = types$1.f_gen;\n      }\n    }\n\n    this.exprAllowed = true;\n  };\n\n  types.name.updateContext = function (prevType) {\n    var allowed = false;\n\n    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n      if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n        allowed = true;\n      }\n    }\n\n    this.exprAllowed = allowed;\n  };\n\n  var data = {\n    \"$LONE\": [\"ASCII\", \"ASCII_Hex_Digit\", \"AHex\", \"Alphabetic\", \"Alpha\", \"Any\", \"Assigned\", \"Bidi_Control\", \"Bidi_C\", \"Bidi_Mirrored\", \"Bidi_M\", \"Case_Ignorable\", \"CI\", \"Cased\", \"Changes_When_Casefolded\", \"CWCF\", \"Changes_When_Casemapped\", \"CWCM\", \"Changes_When_Lowercased\", \"CWL\", \"Changes_When_NFKC_Casefolded\", \"CWKCF\", \"Changes_When_Titlecased\", \"CWT\", \"Changes_When_Uppercased\", \"CWU\", \"Dash\", \"Default_Ignorable_Code_Point\", \"DI\", \"Deprecated\", \"Dep\", \"Diacritic\", \"Dia\", \"Emoji\", \"Emoji_Component\", \"Emoji_Modifier\", \"Emoji_Modifier_Base\", \"Emoji_Presentation\", \"Extender\", \"Ext\", \"Grapheme_Base\", \"Gr_Base\", \"Grapheme_Extend\", \"Gr_Ext\", \"Hex_Digit\", \"Hex\", \"IDS_Binary_Operator\", \"IDSB\", \"IDS_Trinary_Operator\", \"IDST\", \"ID_Continue\", \"IDC\", \"ID_Start\", \"IDS\", \"Ideographic\", \"Ideo\", \"Join_Control\", \"Join_C\", \"Logical_Order_Exception\", \"LOE\", \"Lowercase\", \"Lower\", \"Math\", \"Noncharacter_Code_Point\", \"NChar\", \"Pattern_Syntax\", \"Pat_Syn\", \"Pattern_White_Space\", \"Pat_WS\", \"Quotation_Mark\", \"QMark\", \"Radical\", \"Regional_Indicator\", \"RI\", \"Sentence_Terminal\", \"STerm\", \"Soft_Dotted\", \"SD\", \"Terminal_Punctuation\", \"Term\", \"Unified_Ideograph\", \"UIdeo\", \"Uppercase\", \"Upper\", \"Variation_Selector\", \"VS\", \"White_Space\", \"space\", \"XID_Continue\", \"XIDC\", \"XID_Start\", \"XIDS\"],\n    \"General_Category\": [\"Cased_Letter\", \"LC\", \"Close_Punctuation\", \"Pe\", \"Connector_Punctuation\", \"Pc\", \"Control\", \"Cc\", \"cntrl\", \"Currency_Symbol\", \"Sc\", \"Dash_Punctuation\", \"Pd\", \"Decimal_Number\", \"Nd\", \"digit\", \"Enclosing_Mark\", \"Me\", \"Final_Punctuation\", \"Pf\", \"Format\", \"Cf\", \"Initial_Punctuation\", \"Pi\", \"Letter\", \"L\", \"Letter_Number\", \"Nl\", \"Line_Separator\", \"Zl\", \"Lowercase_Letter\", \"Ll\", \"Mark\", \"M\", \"Combining_Mark\", \"Math_Symbol\", \"Sm\", \"Modifier_Letter\", \"Lm\", \"Modifier_Symbol\", \"Sk\", \"Nonspacing_Mark\", \"Mn\", \"Number\", \"N\", \"Open_Punctuation\", \"Ps\", \"Other\", \"C\", \"Other_Letter\", \"Lo\", \"Other_Number\", \"No\", \"Other_Punctuation\", \"Po\", \"Other_Symbol\", \"So\", \"Paragraph_Separator\", \"Zp\", \"Private_Use\", \"Co\", \"Punctuation\", \"P\", \"punct\", \"Separator\", \"Z\", \"Space_Separator\", \"Zs\", \"Spacing_Mark\", \"Mc\", \"Surrogate\", \"Cs\", \"Symbol\", \"S\", \"Titlecase_Letter\", \"Lt\", \"Unassigned\", \"Cn\", \"Uppercase_Letter\", \"Lu\"],\n    \"Script\": [\"Adlam\", \"Adlm\", \"Ahom\", \"Anatolian_Hieroglyphs\", \"Hluw\", \"Arabic\", \"Arab\", \"Armenian\", \"Armn\", \"Avestan\", \"Avst\", \"Balinese\", \"Bali\", \"Bamum\", \"Bamu\", \"Bassa_Vah\", \"Bass\", \"Batak\", \"Batk\", \"Bengali\", \"Beng\", \"Bhaiksuki\", \"Bhks\", \"Bopomofo\", \"Bopo\", \"Brahmi\", \"Brah\", \"Braille\", \"Brai\", \"Buginese\", \"Bugi\", \"Buhid\", \"Buhd\", \"Canadian_Aboriginal\", \"Cans\", \"Carian\", \"Cari\", \"Caucasian_Albanian\", \"Aghb\", \"Chakma\", \"Cakm\", \"Cham\", \"Cherokee\", \"Cher\", \"Common\", \"Zyyy\", \"Coptic\", \"Copt\", \"Qaac\", \"Cuneiform\", \"Xsux\", \"Cypriot\", \"Cprt\", \"Cyrillic\", \"Cyrl\", \"Deseret\", \"Dsrt\", \"Devanagari\", \"Deva\", \"Duployan\", \"Dupl\", \"Egyptian_Hieroglyphs\", \"Egyp\", \"Elbasan\", \"Elba\", \"Ethiopic\", \"Ethi\", \"Georgian\", \"Geor\", \"Glagolitic\", \"Glag\", \"Gothic\", \"Goth\", \"Grantha\", \"Gran\", \"Greek\", \"Grek\", \"Gujarati\", \"Gujr\", \"Gurmukhi\", \"Guru\", \"Han\", \"Hani\", \"Hangul\", \"Hang\", \"Hanunoo\", \"Hano\", \"Hatran\", \"Hatr\", \"Hebrew\", \"Hebr\", \"Hiragana\", \"Hira\", \"Imperial_Aramaic\", \"Armi\", \"Inherited\", \"Zinh\", \"Qaai\", \"Inscriptional_Pahlavi\", \"Phli\", \"Inscriptional_Parthian\", \"Prti\", \"Javanese\", \"Java\", \"Kaithi\", \"Kthi\", \"Kannada\", \"Knda\", \"Katakana\", \"Kana\", \"Kayah_Li\", \"Kali\", \"Kharoshthi\", \"Khar\", \"Khmer\", \"Khmr\", \"Khojki\", \"Khoj\", \"Khudawadi\", \"Sind\", \"Lao\", \"Laoo\", \"Latin\", \"Latn\", \"Lepcha\", \"Lepc\", \"Limbu\", \"Limb\", \"Linear_A\", \"Lina\", \"Linear_B\", \"Linb\", \"Lisu\", \"Lycian\", \"Lyci\", \"Lydian\", \"Lydi\", \"Mahajani\", \"Mahj\", \"Malayalam\", \"Mlym\", \"Mandaic\", \"Mand\", \"Manichaean\", \"Mani\", \"Marchen\", \"Marc\", \"Masaram_Gondi\", \"Gonm\", \"Meetei_Mayek\", \"Mtei\", \"Mende_Kikakui\", \"Mend\", \"Meroitic_Cursive\", \"Merc\", \"Meroitic_Hieroglyphs\", \"Mero\", \"Miao\", \"Plrd\", \"Modi\", \"Mongolian\", \"Mong\", \"Mro\", \"Mroo\", \"Multani\", \"Mult\", \"Myanmar\", \"Mymr\", \"Nabataean\", \"Nbat\", \"New_Tai_Lue\", \"Talu\", \"Newa\", \"Nko\", \"Nkoo\", \"Nushu\", \"Nshu\", \"Ogham\", \"Ogam\", \"Ol_Chiki\", \"Olck\", \"Old_Hungarian\", \"Hung\", \"Old_Italic\", \"Ital\", \"Old_North_Arabian\", \"Narb\", \"Old_Permic\", \"Perm\", \"Old_Persian\", \"Xpeo\", \"Old_South_Arabian\", \"Sarb\", \"Old_Turkic\", \"Orkh\", \"Oriya\", \"Orya\", \"Osage\", \"Osge\", \"Osmanya\", \"Osma\", \"Pahawh_Hmong\", \"Hmng\", \"Palmyrene\", \"Palm\", \"Pau_Cin_Hau\", \"Pauc\", \"Phags_Pa\", \"Phag\", \"Phoenician\", \"Phnx\", \"Psalter_Pahlavi\", \"Phlp\", \"Rejang\", \"Rjng\", \"Runic\", \"Runr\", \"Samaritan\", \"Samr\", \"Saurashtra\", \"Saur\", \"Sharada\", \"Shrd\", \"Shavian\", \"Shaw\", \"Siddham\", \"Sidd\", \"SignWriting\", \"Sgnw\", \"Sinhala\", \"Sinh\", \"Sora_Sompeng\", \"Sora\", \"Soyombo\", \"Soyo\", \"Sundanese\", \"Sund\", \"Syloti_Nagri\", \"Sylo\", \"Syriac\", \"Syrc\", \"Tagalog\", \"Tglg\", \"Tagbanwa\", \"Tagb\", \"Tai_Le\", \"Tale\", \"Tai_Tham\", \"Lana\", \"Tai_Viet\", \"Tavt\", \"Takri\", \"Takr\", \"Tamil\", \"Taml\", \"Tangut\", \"Tang\", \"Telugu\", \"Telu\", \"Thaana\", \"Thaa\", \"Thai\", \"Tibetan\", \"Tibt\", \"Tifinagh\", \"Tfng\", \"Tirhuta\", \"Tirh\", \"Ugaritic\", \"Ugar\", \"Vai\", \"Vaii\", \"Warang_Citi\", \"Wara\", \"Yi\", \"Yiii\", \"Zanabazar_Square\", \"Zanb\"]\n  };\n  Array.prototype.push.apply(data.$LONE, data.General_Category);\n  data.gc = data.General_Category;\n  data.sc = data.Script_Extensions = data.scx = data.Script;\n  var pp$9 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise(message) {\n    this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n  }; // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n\n\n  RegExpValidationState.prototype.at = function at(i) {\n    var s = this.source;\n    var l = s.length;\n\n    if (i >= l) {\n      return -1;\n    }\n\n    var c = s.charCodeAt(i);\n\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c;\n    }\n\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex(i) {\n    var s = this.source;\n    var l = s.length;\n\n    if (i >= l) {\n      return l;\n    }\n\n    var c = s.charCodeAt(i),\n        next;\n\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n      return i + 1;\n    }\n\n    return i + 2;\n  };\n\n  RegExpValidationState.prototype.current = function current() {\n    return this.at(this.pos);\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead() {\n    return this.at(this.nextIndex(this.pos));\n  };\n\n  RegExpValidationState.prototype.advance = function advance() {\n    this.pos = this.nextIndex(this.pos);\n  };\n\n  RegExpValidationState.prototype.eat = function eat(ch) {\n    if (this.current() === ch) {\n      this.advance();\n      return true;\n    }\n\n    return false;\n  };\n\n  function codePointToString$1(ch) {\n    if (ch <= 0xFFFF) {\n      return String.fromCharCode(ch);\n    }\n\n    ch -= 0x10000;\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);\n  }\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n\n\n  pp$9.validateRegExpFlags = function (state) {\n    var this$1 = this;\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n\n      if (validFlags.indexOf(flag) === -1) {\n        this$1.raise(state.start, \"Invalid regular expression flag\");\n      }\n\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this$1.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n\n\n  pp$9.validateRegExpPattern = function (state) {\n    this.regexp_pattern(state); // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n\n\n  pp$9.regexp_pattern = function (state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29\n      /* ) */\n      )) {\n        state.raise(\"Unmatched ')'\");\n      }\n\n      if (state.eat(0x5D\n      /* [ */\n      ) || state.eat(0x7D\n      /* } */\n      )) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n\n\n  pp$9.regexp_disjunction = function (state) {\n    var this$1 = this;\n    this.regexp_alternative(state);\n\n    while (state.eat(0x7C\n    /* | */\n    )) {\n      this$1.regexp_alternative(state);\n    } // Make the same message as V8.\n\n\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n\n    if (state.eat(0x7B\n    /* { */\n    )) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n\n\n  pp$9.regexp_alternative = function (state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n\n\n  pp$9.regexp_eatTerm = function (state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n\n      return true;\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n\n\n  pp$9.regexp_eatAssertion = function (state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false; // ^, $\n\n    if (state.eat(0x5E\n    /* ^ */\n    ) || state.eat(0x24\n    /* $ */\n    )) {\n      return true;\n    } // \\b \\B\n\n\n    if (state.eat(0x5C\n    /* \\ */\n    )) {\n      if (state.eat(0x42\n      /* B */\n      ) || state.eat(0x62\n      /* b */\n      )) {\n        return true;\n      }\n\n      state.pos = start;\n    } // Lookahead / Lookbehind\n\n\n    if (state.eat(0x28\n    /* ( */\n    ) && state.eat(0x3F\n    /* ? */\n    )) {\n      var lookbehind = false;\n\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C\n        /* < */\n        );\n      }\n\n      if (state.eat(0x3D\n      /* = */\n      ) || state.eat(0x21\n      /* ! */\n      )) {\n        this.regexp_disjunction(state);\n\n        if (!state.eat(0x29\n        /* ) */\n        )) {\n          state.raise(\"Unterminated group\");\n        }\n\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true;\n      }\n    }\n\n    state.pos = start;\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n\n\n  pp$9.regexp_eatQuantifier = function (state, noError) {\n    if (noError === void 0) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F\n      /* ? */\n      );\n      return true;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n\n\n  pp$9.regexp_eatQuantifierPrefix = function (state, noError) {\n    return state.eat(0x2A\n    /* * */\n    ) || state.eat(0x2B\n    /* + */\n    ) || state.eat(0x3F\n    /* ? */\n    ) || this.regexp_eatBracedQuantifier(state, noError);\n  };\n\n  pp$9.regexp_eatBracedQuantifier = function (state, noError) {\n    var start = state.pos;\n\n    if (state.eat(0x7B\n    /* { */\n    )) {\n      var min = 0,\n          max = -1;\n\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n\n        if (state.eat(0x2C\n        /* , */\n        ) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n\n        if (state.eat(0x7D\n        /* } */\n        )) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n\n          return true;\n        }\n      }\n\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n\n\n  pp$9.regexp_eatAtom = function (state) {\n    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E\n    /* . */\n    ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n  };\n\n  pp$9.regexp_eatReverseSolidusAtomEscape = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C\n    /* \\ */\n    )) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true;\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  };\n\n  pp$9.regexp_eatUncapturingGroup = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x28\n    /* ( */\n    )) {\n      if (state.eat(0x3F\n      /* ? */\n      ) && state.eat(0x3A\n      /* : */\n      )) {\n        this.regexp_disjunction(state);\n\n        if (state.eat(0x29\n        /* ) */\n        )) {\n          return true;\n        }\n\n        state.raise(\"Unterminated group\");\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  };\n\n  pp$9.regexp_eatCapturingGroup = function (state) {\n    if (state.eat(0x28\n    /* ( */\n    )) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F\n      /* ? */\n      ) {\n          state.raise(\"Invalid group\");\n        }\n\n      this.regexp_disjunction(state);\n\n      if (state.eat(0x29\n      /* ) */\n      )) {\n        state.numCapturingParens += 1;\n        return true;\n      }\n\n      state.raise(\"Unterminated group\");\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n\n\n  pp$9.regexp_eatExtendedAtom = function (state) {\n    return state.eat(0x2E\n    /* . */\n    ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n\n\n  pp$9.regexp_eatInvalidBracedQuantifier = function (state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n\n\n  pp$9.regexp_eatSyntaxCharacter = function (state) {\n    var ch = state.current();\n\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true;\n    }\n\n    return false;\n  };\n\n  function isSyntaxCharacter(ch) {\n    return ch === 0x24\n    /* $ */\n    || ch >= 0x28\n    /* ( */\n    && ch <= 0x2B\n    /* + */\n    || ch === 0x2E\n    /* . */\n    || ch === 0x3F\n    /* ? */\n    || ch >= 0x5B\n    /* [ */\n    && ch <= 0x5E\n    /* ^ */\n    || ch >= 0x7B\n    /* { */\n    && ch <= 0x7D\n    /* } */\n    ;\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n\n\n  pp$9.regexp_eatPatternCharacters = function (state) {\n    var start = state.pos;\n    var ch = 0;\n\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n\n    return state.pos !== start;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n\n\n  pp$9.regexp_eatExtendedPatternCharacter = function (state) {\n    var ch = state.current();\n\n    if (ch !== -1 && ch !== 0x24\n    /* $ */\n    && !(ch >= 0x28\n    /* ( */\n    && ch <= 0x2B\n    /* + */\n    ) && ch !== 0x2E\n    /* . */\n    && ch !== 0x3F\n    /* ? */\n    && ch !== 0x5B\n    /* [ */\n    && ch !== 0x5E\n    /* ^ */\n    && ch !== 0x7C\n    /* | */\n    ) {\n        state.advance();\n        return true;\n      }\n\n    return false;\n  }; // GroupSpecifier[U] ::\n  //   [empty]\n  //   `?` GroupName[?U]\n\n\n  pp$9.regexp_groupSpecifier = function (state) {\n    if (state.eat(0x3F\n    /* ? */\n    )) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n\n        state.groupNames.push(state.lastStringValue);\n        return;\n      }\n\n      state.raise(\"Invalid group\");\n    }\n  }; // GroupName[U] ::\n  //   `<` RegExpIdentifierName[?U] `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n\n\n  pp$9.regexp_eatGroupName = function (state) {\n    state.lastStringValue = \"\";\n\n    if (state.eat(0x3C\n    /* < */\n    )) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E\n      /* > */\n      )) {\n        return true;\n      }\n\n      state.raise(\"Invalid capture group name\");\n    }\n\n    return false;\n  }; // RegExpIdentifierName[U] ::\n  //   RegExpIdentifierStart[?U]\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n\n\n  pp$9.regexp_eatRegExpIdentifierName = function (state) {\n    state.lastStringValue = \"\";\n\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString$1(state.lastIntValue);\n      }\n\n      return true;\n    }\n\n    return false;\n  }; // RegExpIdentifierStart[U] ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n\n\n  pp$9.regexp_eatRegExpIdentifierStart = function (state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C\n    /* \\ */\n    && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true;\n    }\n\n    state.pos = start;\n    return false;\n  };\n\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24\n    /* $ */\n    || ch === 0x5F;\n    /* _ */\n  } // RegExpIdentifierPart[U] ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  //   <ZWNJ>\n  //   <ZWJ>\n\n\n  pp$9.regexp_eatRegExpIdentifierPart = function (state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C\n    /* \\ */\n    && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true;\n    }\n\n    state.pos = start;\n    return false;\n  };\n\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24\n    /* $ */\n    || ch === 0x5F\n    /* _ */\n    || ch === 0x200C\n    /* <ZWNJ> */\n    || ch === 0x200D;\n    /* <ZWJ> */\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n\n\n  pp$9.regexp_eatAtomEscape = function (state) {\n    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63\n      /* c */\n      ) {\n          state.raise(\"Invalid unicode escape\");\n        }\n\n      state.raise(\"Invalid escape\");\n    }\n\n    return false;\n  };\n\n  pp$9.regexp_eatBackReference = function (state) {\n    var start = state.pos;\n\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n\n        return true;\n      }\n\n      if (n <= state.numCapturingParens) {\n        return true;\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  };\n\n  pp$9.regexp_eatKGroupName = function (state) {\n    if (state.eat(0x6B\n    /* k */\n    )) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true;\n      }\n\n      state.raise(\"Invalid named reference\");\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n\n\n  pp$9.regexp_eatCharacterEscape = function (state) {\n    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n  };\n\n  pp$9.regexp_eatCControlLetter = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x63\n    /* c */\n    )) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true;\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  };\n\n  pp$9.regexp_eatZero = function (state) {\n    if (state.current() === 0x30\n    /* 0 */\n    && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n\n\n  pp$9.regexp_eatControlEscape = function (state) {\n    var ch = state.current();\n\n    if (ch === 0x74\n    /* t */\n    ) {\n        state.lastIntValue = 0x09;\n        /* \\t */\n\n        state.advance();\n        return true;\n      }\n\n    if (ch === 0x6E\n    /* n */\n    ) {\n        state.lastIntValue = 0x0A;\n        /* \\n */\n\n        state.advance();\n        return true;\n      }\n\n    if (ch === 0x76\n    /* v */\n    ) {\n        state.lastIntValue = 0x0B;\n        /* \\v */\n\n        state.advance();\n        return true;\n      }\n\n    if (ch === 0x66\n    /* f */\n    ) {\n        state.lastIntValue = 0x0C;\n        /* \\f */\n\n        state.advance();\n        return true;\n      }\n\n    if (ch === 0x72\n    /* r */\n    ) {\n        state.lastIntValue = 0x0D;\n        /* \\r */\n\n        state.advance();\n        return true;\n      }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n\n\n  pp$9.regexp_eatControlLetter = function (state) {\n    var ch = state.current();\n\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true;\n    }\n\n    return false;\n  };\n\n  function isControlLetter(ch) {\n    return ch >= 0x41\n    /* A */\n    && ch <= 0x5A\n    /* Z */\n    || ch >= 0x61\n    /* a */\n    && ch <= 0x7A\n    /* z */\n    ;\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n\n\n  pp$9.regexp_eatRegExpUnicodeEscapeSequence = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x75\n    /* u */\n    )) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n\n          if (state.eat(0x5C\n          /* \\ */\n          ) && state.eat(0x75\n          /* u */\n          ) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true;\n            }\n          }\n\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n\n        return true;\n      }\n\n      if (state.switchU && state.eat(0x7B\n      /* { */\n      ) && this.regexp_eatHexDigits(state) && state.eat(0x7D\n      /* } */\n      ) && isValidUnicode(state.lastIntValue)) {\n        return true;\n      }\n\n      if (state.switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  };\n\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF;\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n\n\n  pp$9.regexp_eatIdentityEscape = function (state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true;\n      }\n\n      if (state.eat(0x2F\n      /* / */\n      )) {\n        state.lastIntValue = 0x2F;\n        /* / */\n\n        return true;\n      }\n\n      return false;\n    }\n\n    var ch = state.current();\n\n    if (ch !== 0x63\n    /* c */\n    && (!state.switchN || ch !== 0x6B\n    /* k */\n    )) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n\n\n  pp$9.regexp_eatDecimalEscape = function (state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n\n    if (ch >= 0x31\n    /* 1 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        do {\n          state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30\n          /* 0 */\n          );\n          state.advance();\n        } while ((ch = state.current()) >= 0x30\n        /* 0 */\n        && ch <= 0x39\n        /* 9 */\n        );\n\n        return true;\n      }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n\n\n  pp$9.regexp_eatCharacterClassEscape = function (state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true;\n    }\n\n    if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50\n    /* P */\n    || ch === 0x70\n    /* p */\n    )) {\n      state.lastIntValue = -1;\n      state.advance();\n\n      if (state.eat(0x7B\n      /* { */\n      ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D\n      /* } */\n      )) {\n        return true;\n      }\n\n      state.raise(\"Invalid property name\");\n    }\n\n    return false;\n  };\n\n  function isCharacterClassEscape(ch) {\n    return ch === 0x64\n    /* d */\n    || ch === 0x44\n    /* D */\n    || ch === 0x73\n    /* s */\n    || ch === 0x53\n    /* S */\n    || ch === 0x77\n    /* w */\n    || ch === 0x57\n    /* W */\n    ;\n  } // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n\n\n  pp$9.regexp_eatUnicodePropertyValueExpression = function (state) {\n    var start = state.pos; // UnicodePropertyName `=` UnicodePropertyValue\n\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D\n    /* = */\n    )) {\n      var name = state.lastStringValue;\n\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true;\n      }\n    }\n\n    state.pos = start; // LoneUnicodePropertyNameOrValue\n\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true;\n    }\n\n    return false;\n  };\n\n  pp$9.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {\n    if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n      state.raise(\"Invalid property name\");\n    }\n  };\n\n  pp$9.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {\n    if (data.$LONE.indexOf(nameOrValue) === -1) {\n      state.raise(\"Invalid property name\");\n    }\n  }; // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n\n\n  pp$9.regexp_eatUnicodePropertyName = function (state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString$1(ch);\n      state.advance();\n    }\n\n    return state.lastStringValue !== \"\";\n  };\n\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F;\n    /* _ */\n  } // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n\n\n  pp$9.regexp_eatUnicodePropertyValue = function (state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString$1(ch);\n      state.advance();\n    }\n\n    return state.lastStringValue !== \"\";\n  };\n\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n  } // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n\n\n  pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {\n    return this.regexp_eatUnicodePropertyValue(state);\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n\n\n  pp$9.regexp_eatCharacterClass = function (state) {\n    if (state.eat(0x5B\n    /* [ */\n    )) {\n      state.eat(0x5E\n      /* ^ */\n      );\n      this.regexp_classRanges(state);\n\n      if (state.eat(0x5D\n      /* [ */\n      )) {\n        return true;\n      } // Unreachable since it threw \"unterminated regular expression\" error before.\n\n\n      state.raise(\"Unterminated character class\");\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n\n\n  pp$9.regexp_classRanges = function (state) {\n    var this$1 = this;\n\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n\n      if (state.eat(0x2D\n      /* - */\n      ) && this$1.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n\n\n  pp$9.regexp_eatClassAtom = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C\n    /* \\ */\n    )) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true;\n      }\n\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n\n        if (ch$1 === 0x63\n        /* c */\n        || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n\n        state.raise(\"Invalid escape\");\n      }\n\n      state.pos = start;\n    }\n\n    var ch = state.current();\n\n    if (ch !== 0x5D\n    /* [ */\n    ) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n      }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n\n\n  pp$9.regexp_eatClassEscape = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x62\n    /* b */\n    )) {\n      state.lastIntValue = 0x08;\n      /* <BS> */\n\n      return true;\n    }\n\n    if (state.switchU && state.eat(0x2D\n    /* - */\n    )) {\n      state.lastIntValue = 0x2D;\n      /* - */\n\n      return true;\n    }\n\n    if (!state.switchU && state.eat(0x63\n    /* c */\n    )) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true;\n      }\n\n      state.pos = start;\n    }\n\n    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n\n\n  pp$9.regexp_eatClassControlLetter = function (state) {\n    var ch = state.current();\n\n    if (isDecimalDigit(ch) || ch === 0x5F\n    /* _ */\n    ) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n      }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\n\n  pp$9.regexp_eatHexEscapeSequence = function (state) {\n    var start = state.pos;\n\n    if (state.eat(0x78\n    /* x */\n    )) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true;\n      }\n\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n\n      state.pos = start;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n\n\n  pp$9.regexp_eatDecimalDigits = function (state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30\n      /* 0 */\n      );\n      state.advance();\n    }\n\n    return state.pos !== start;\n  };\n\n  function isDecimalDigit(ch) {\n    return ch >= 0x30\n    /* 0 */\n    && ch <= 0x39;\n    /* 9 */\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n\n\n  pp$9.regexp_eatHexDigits = function (state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n\n    return state.pos !== start;\n  };\n\n  function isHexDigit(ch) {\n    return ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    || ch >= 0x41\n    /* A */\n    && ch <= 0x46\n    /* F */\n    || ch >= 0x61\n    /* a */\n    && ch <= 0x66\n    /* f */\n    ;\n  }\n\n  function hexToInt(ch) {\n    if (ch >= 0x41\n    /* A */\n    && ch <= 0x46\n    /* F */\n    ) {\n        return 10 + (ch - 0x41\n        /* A */\n        );\n      }\n\n    if (ch >= 0x61\n    /* a */\n    && ch <= 0x66\n    /* f */\n    ) {\n        return 10 + (ch - 0x61\n        /* a */\n        );\n      }\n\n    return ch - 0x30;\n    /* 0 */\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n\n\n  pp$9.regexp_eatLegacyOctalEscapeSequence = function (state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n\n      return true;\n    }\n\n    return false;\n  }; // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n\n\n  pp$9.regexp_eatOctalDigit = function (state) {\n    var ch = state.current();\n\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30;\n      /* 0 */\n\n      state.advance();\n      return true;\n    }\n\n    state.lastIntValue = 0;\n    return false;\n  };\n\n  function isOctalDigit(ch) {\n    return ch >= 0x30\n    /* 0 */\n    && ch <= 0x37;\n    /* 7 */\n  } // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\n\n  pp$9.regexp_eatFixedHexDigits = function (state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false;\n      }\n\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n\n    return true;\n  }; // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n\n    if (p.options.locations) {\n      this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n    }\n\n    if (p.options.ranges) {\n      this.range = [p.start, p.end];\n    }\n  }; // ## Tokenizer\n\n\n  var pp$8 = Parser.prototype; // Move to the next token\n\n  pp$8.next = function () {\n    if (this.options.onToken) {\n      this.options.onToken(new Token(this));\n    }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$8.getToken = function () {\n    this.next();\n    return new Token(this);\n  }; // If we're in an ES6 environment, make parsers iterable\n\n\n  if (typeof Symbol !== \"undefined\") {\n    pp$8[Symbol.iterator] = function () {\n      var this$1 = this;\n      return {\n        next: function () {\n          var token = this$1.getToken();\n          return {\n            done: token.type === types.eof,\n            value: token\n          };\n        }\n      };\n    };\n  } // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n\n  pp$8.curContext = function () {\n    return this.context[this.context.length - 1];\n  }; // Read a single token, updating the parser object's token-related\n  // properties.\n\n\n  pp$8.nextToken = function () {\n    var curContext = this.curContext();\n\n    if (!curContext || !curContext.preserveSpace) {\n      this.skipSpace();\n    }\n\n    this.start = this.pos;\n\n    if (this.options.locations) {\n      this.startLoc = this.curPosition();\n    }\n\n    if (this.pos >= this.input.length) {\n      return this.finishToken(types.eof);\n    }\n\n    if (curContext.override) {\n      return curContext.override(this);\n    } else {\n      this.readToken(this.fullCharCodeAtPos());\n    }\n  };\n\n  pp$8.readToken = function (code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92\n    /* '\\' */\n    ) {\n        return this.readWord();\n      }\n\n    return this.getTokenFromCode(code);\n  };\n\n  pp$8.fullCharCodeAtPos = function () {\n    var code = this.input.charCodeAt(this.pos);\n\n    if (code <= 0xd7ff || code >= 0xe000) {\n      return code;\n    }\n\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  pp$8.skipBlockComment = function () {\n    var this$1 = this;\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos,\n        end = this.input.indexOf(\"*/\", this.pos += 2);\n\n    if (end === -1) {\n      this.raise(this.pos - 2, \"Unterminated comment\");\n    }\n\n    this.pos = end + 2;\n\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this$1.curLine;\n        this$1.lineStart = match.index + match[0].length;\n      }\n    }\n\n    if (this.options.onComment) {\n      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n    }\n  };\n\n  pp$8.skipLineComment = function (startSkip) {\n    var this$1 = this;\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this$1.input.charCodeAt(++this$1.pos);\n    }\n\n    if (this.options.onComment) {\n      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n    }\n  }; // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n\n  pp$8.skipSpace = function () {\n    var this$1 = this;\n\n    loop: while (this.pos < this.input.length) {\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n          // ' '\n          ++this$1.pos;\n          break;\n\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n            ++this$1.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this$1.pos;\n\n          if (this$1.options.locations) {\n            ++this$1.curLine;\n            this$1.lineStart = this$1.pos;\n          }\n\n          break;\n\n        case 47:\n          // '/'\n          switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n            case 42:\n              // '*'\n              this$1.skipBlockComment();\n              break;\n\n            case 47:\n              this$1.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this$1.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }; // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n\n  pp$8.finishToken = function (type, val) {\n    this.end = this.pos;\n\n    if (this.options.locations) {\n      this.endLoc = this.curPosition();\n    }\n\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n  }; // ### Token reading\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n\n\n  pp$8.readToken_dot = function () {\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      return this.readNumber(true);\n    }\n\n    var next2 = this.input.charCodeAt(this.pos + 2);\n\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n      // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types.ellipsis);\n    } else {\n      ++this.pos;\n      return this.finishToken(types.dot);\n    }\n  };\n\n  pp$8.readToken_slash = function () {\n    // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (this.exprAllowed) {\n      ++this.pos;\n      return this.readRegexp();\n    }\n\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    }\n\n    return this.finishOp(types.slash, 1);\n  };\n\n  pp$8.readToken_mult_modulo_exp = function (code) {\n    // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types.star : types.modulo; // exponentiation operator ** and **=\n\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) {\n      return this.finishOp(types.assign, size + 1);\n    }\n\n    return this.finishOp(tokentype, size);\n  };\n\n  pp$8.readToken_pipe_amp = function (code) {\n    // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next === code) {\n      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n    }\n\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    }\n\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  };\n\n  pp$8.readToken_caret = function () {\n    // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    }\n\n    return this.finishOp(types.bitwiseXOR, 1);\n  };\n\n  pp$8.readToken_plus_min = function (code) {\n    // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken();\n      }\n\n      return this.finishOp(types.incDec, 2);\n    }\n\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    }\n\n    return this.finishOp(types.plusMin, 1);\n  };\n\n  pp$8.readToken_lt_gt = function (code) {\n    // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.pos + size) === 61) {\n        return this.finishOp(types.assign, size + 1);\n      }\n\n      return this.finishOp(types.bitShift, size);\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    return this.finishOp(types.relational, size);\n  };\n\n  pp$8.readToken_eq_excl = function (code) {\n    // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next === 61) {\n      return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n    }\n\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n      // '=>'\n      this.pos += 2;\n      return this.finishToken(types.arrow);\n    }\n\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);\n  };\n\n  pp$8.getTokenFromCode = function (code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n      case 46:\n        // '.'\n        return this.readToken_dot();\n      // Punctuation tokens.\n\n      case 40:\n        ++this.pos;\n        return this.finishToken(types.parenL);\n\n      case 41:\n        ++this.pos;\n        return this.finishToken(types.parenR);\n\n      case 59:\n        ++this.pos;\n        return this.finishToken(types.semi);\n\n      case 44:\n        ++this.pos;\n        return this.finishToken(types.comma);\n\n      case 91:\n        ++this.pos;\n        return this.finishToken(types.bracketL);\n\n      case 93:\n        ++this.pos;\n        return this.finishToken(types.bracketR);\n\n      case 123:\n        ++this.pos;\n        return this.finishToken(types.braceL);\n\n      case 125:\n        ++this.pos;\n        return this.finishToken(types.braceR);\n\n      case 58:\n        ++this.pos;\n        return this.finishToken(types.colon);\n\n      case 63:\n        ++this.pos;\n        return this.finishToken(types.question);\n\n      case 96:\n        // '`'\n        if (this.options.ecmaVersion < 6) {\n          break;\n        }\n\n        ++this.pos;\n        return this.finishToken(types.backQuote);\n\n      case 48:\n        // '0'\n        var next = this.input.charCodeAt(this.pos + 1);\n\n        if (next === 120 || next === 88) {\n          return this.readRadixNumber(16);\n        } // '0x', '0X' - hex number\n\n\n        if (this.options.ecmaVersion >= 6) {\n          if (next === 111 || next === 79) {\n            return this.readRadixNumber(8);\n          } // '0o', '0O' - octal number\n\n\n          if (next === 98 || next === 66) {\n            return this.readRadixNumber(2);\n          } // '0b', '0B' - binary number\n\n        }\n\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        // 1-9\n        return this.readNumber(false);\n      // Quotes produce strings.\n\n      case 34:\n      case 39:\n        // '\"', \"'\"\n        return this.readString(code);\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return this.readToken_slash();\n\n      case 37:\n      case 42:\n        // '%*'\n        return this.readToken_mult_modulo_exp(code);\n\n      case 124:\n      case 38:\n        // '|&'\n        return this.readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return this.readToken_caret();\n\n      case 43:\n      case 45:\n        // '+-'\n        return this.readToken_plus_min(code);\n\n      case 60:\n      case 62:\n        // '<>'\n        return this.readToken_lt_gt(code);\n\n      case 61:\n      case 33:\n        // '=!'\n        return this.readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return this.finishOp(types.prefix, 1);\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp$8.finishOp = function (type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n  };\n\n  pp$8.readRegexp = function () {\n    var this$1 = this;\n    var escaped,\n        inClass,\n        start = this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) {\n        this$1.raise(start, \"Unterminated regular expression\");\n      }\n\n      var ch = this$1.input.charAt(this$1.pos);\n\n      if (lineBreak.test(ch)) {\n        this$1.raise(start, \"Unterminated regular expression\");\n      }\n\n      if (!escaped) {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      } else {\n        escaped = false;\n      }\n\n      ++this$1.pos;\n    }\n\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n\n    if (this.containsEsc) {\n      this.unexpected(flagsStart);\n    } // Validate pattern\n\n\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state); // Create Literal#value property value.\n\n    var value = null;\n\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {// ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types.regexp, {\n      pattern: pattern,\n      flags: flags,\n      value: value\n    });\n  }; // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n\n  pp$8.readInt = function (radix, len) {\n    var this$1 = this;\n    var start = this.pos,\n        total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this$1.input.charCodeAt(this$1.pos),\n          val = void 0;\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } // a\n      else if (code >= 65) {\n          val = code - 65 + 10;\n        } // A\n        else if (code >= 48 && code <= 57) {\n            val = code - 48;\n          } // 0-9\n          else {\n              val = Infinity;\n            }\n\n      if (val >= radix) {\n        break;\n      }\n\n      ++this$1.pos;\n      total = total * radix + val;\n    }\n\n    if (this.pos === start || len != null && this.pos - start !== len) {\n      return null;\n    }\n\n    return total;\n  };\n\n  pp$8.readRadixNumber = function (radix) {\n    this.pos += 2; // 0x\n\n    var val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.pos, \"Identifier directly after number\");\n    }\n\n    return this.finishToken(types.num, val);\n  }; // Read an integer, octal integer, or floating-point number.\n\n\n  pp$8.readNumber = function (startsWithDot) {\n    var start = this.pos;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (octal && this.strict) {\n      this.raise(start, \"Invalid number\");\n    }\n\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n      octal = false;\n    }\n\n    var next = this.input.charCodeAt(this.pos);\n\n    if (next === 46 && !octal) {\n      // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.pos;\n      } // '+-'\n\n\n      if (this.readInt(10) === null) {\n        this.raise(start, \"Invalid number\");\n      }\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.pos, \"Identifier directly after number\");\n    }\n\n    var str = this.input.slice(start, this.pos);\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\n    return this.finishToken(types.num, val);\n  }; // Read a string value, interpreting backslash-escapes.\n\n\n  pp$8.readCodePoint = function () {\n    var ch = this.input.charCodeAt(this.pos),\n        code;\n\n    if (ch === 123) {\n      // '{'\n      if (this.options.ecmaVersion < 6) {\n        this.unexpected();\n      }\n\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n\n      if (code > 0x10FFFF) {\n        this.invalidStringToken(codePos, \"Code point out of bounds\");\n      }\n    } else {\n      code = this.readHexChar(4);\n    }\n\n    return code;\n  };\n\n  function codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) {\n      return String.fromCharCode(code);\n    }\n\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n  }\n\n  pp$8.readString = function (quote) {\n    var this$1 = this;\n    var out = \"\",\n        chunkStart = ++this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) {\n        this$1.raise(this$1.start, \"Unterminated string constant\");\n      }\n\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      if (ch === quote) {\n        break;\n      }\n\n      if (ch === 92) {\n        // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        out += this$1.readEscapedChar(false);\n        chunkStart = this$1.pos;\n      } else {\n        if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) {\n          this$1.raise(this$1.start, \"Unterminated string constant\");\n        }\n\n        ++this$1.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types.string, out);\n  }; // Reads template string tokens.\n\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp$8.tryReadTemplateToken = function () {\n    this.inTemplateElement = true;\n\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err;\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp$8.invalidStringToken = function (position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR;\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp$8.readTmplToken = function () {\n    var this$1 = this;\n    var out = \"\",\n        chunkStart = this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) {\n        this$1.raise(this$1.start, \"Unterminated template\");\n      }\n\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {\n        // '`', '${'\n        if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n          if (ch === 36) {\n            this$1.pos += 2;\n            return this$1.finishToken(types.dollarBraceL);\n          } else {\n            ++this$1.pos;\n            return this$1.finishToken(types.backQuote);\n          }\n        }\n\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        return this$1.finishToken(types.template, out);\n      }\n\n      if (ch === 92) {\n        // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        out += this$1.readEscapedChar(true);\n        chunkStart = this$1.pos;\n      } else if (isNewLine(ch)) {\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        ++this$1.pos;\n\n        switch (ch) {\n          case 13:\n            if (this$1.input.charCodeAt(this$1.pos) === 10) {\n              ++this$1.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        if (this$1.options.locations) {\n          ++this$1.curLine;\n          this$1.lineStart = this$1.pos;\n        }\n\n        chunkStart = this$1.pos;\n      } else {\n        ++this$1.pos;\n      }\n    }\n  }; // Reads a template token to search for the end, without validating any escape sequences\n\n\n  pp$8.readInvalidTemplateToken = function () {\n    var this$1 = this;\n\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this$1.input[this$1.pos]) {\n        case \"\\\\\":\n          ++this$1.pos;\n          break;\n\n        case \"$\":\n          if (this$1.input[this$1.pos + 1] !== \"{\") {\n            break;\n          }\n\n        // falls through\n\n        case \"`\":\n          return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));\n        // no default\n      }\n    }\n\n    this.raise(this.start, \"Unterminated template\");\n  }; // Used to read escaped characters\n\n\n  pp$8.readEscapedChar = function (inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n      // 'n' -> '\\n'\n\n      case 114:\n        return \"\\r\";\n      // 'r' -> '\\r'\n\n      case 120:\n        return String.fromCharCode(this.readHexChar(2));\n      // 'x'\n\n      case 117:\n        return codePointToString(this.readCodePoint());\n      // 'u'\n\n      case 116:\n        return \"\\t\";\n      // 't' -> '\\t'\n\n      case 98:\n        return \"\\b\";\n      // 'b' -> '\\b'\n\n      case 118:\n        return \"\\u000b\";\n      // 'v' -> '\\u000b'\n\n      case 102:\n        return \"\\f\";\n      // 'f' -> '\\f'\n\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) {\n          ++this.pos;\n        }\n\n      // '\\r\\n'\n\n      case 10:\n        // ' \\n'\n        if (this.options.locations) {\n          this.lineStart = this.pos;\n          ++this.curLine;\n        }\n\n        return \"\";\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.pos += octalStr.length - 1;\n          ch = this.input.charCodeAt(this.pos);\n\n          if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n            this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }; // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\n  pp$8.readHexChar = function (len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n\n    if (n === null) {\n      this.invalidStringToken(codePos, \"Bad character escape sequence\");\n    }\n\n    return n;\n  }; // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n\n  pp$8.readWord1 = function () {\n    var this$1 = this;\n    this.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n\n    while (this.pos < this.input.length) {\n      var ch = this$1.fullCharCodeAtPos();\n\n      if (isIdentifierChar(ch, astral)) {\n        this$1.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        // \"\\\"\n        this$1.containsEsc = true;\n        word += this$1.input.slice(chunkStart, this$1.pos);\n        var escStart = this$1.pos;\n\n        if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\n          {\n            this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n          }\n\n        ++this$1.pos;\n        var esc = this$1.readCodePoint();\n\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n          this$1.invalidStringToken(escStart, \"Invalid Unicode escape\");\n        }\n\n        word += codePointToString(esc);\n        chunkStart = this$1.pos;\n      } else {\n        break;\n      }\n\n      first = false;\n    }\n\n    return word + this.input.slice(chunkStart, this.pos);\n  }; // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n\n  pp$8.readWord = function () {\n    var word = this.readWord1();\n    var type = types.name;\n\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) {\n        this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word);\n      }\n\n      type = keywords$1[word];\n    }\n\n    return this.finishToken(type, word);\n  }; // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n  //\n  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n  // various contributors and released under an MIT license.\n  //\n  // Git repositories for Acorn are available at\n  //\n  //     http://marijnhaverbeke.nl/git/acorn\n  //     https://github.com/acornjs/acorn.git\n  //\n  // Please use the [github bug tracker][ghbt] to report issues.\n  //\n  // [ghbt]: https://github.com/acornjs/acorn/issues\n  //\n  // This file defines the main parser interface. The library also comes\n  // with a [error-tolerant parser][dammit] and an\n  // [abstract syntax tree walker][walk], defined in other files.\n  //\n  // [dammit]: acorn_loose.js\n  // [walk]: util/walk.js\n\n\n  var version = \"5.7.3\"; // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return new Parser(options, input).parse();\n  } // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n\n  function parseExpressionAt(input, pos, options) {\n    var p = new Parser(options, input, pos);\n    p.nextToken();\n    return p.parseExpression();\n  } // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n\n  function tokenizer(input, options) {\n    return new Parser(options, input);\n  } // This is a terrible kludge to support the existing, pre-ES6\n  // interface where the loose parser module retroactively adds exports\n  // to this module.\n  // eslint-disable-line camelcase\n\n\n  function addLooseExports(parse, Parser$$1, plugins$$1) {\n    exports.parse_dammit = parse; // eslint-disable-line camelcase\n\n    exports.LooseParser = Parser$$1;\n    exports.pluginsLoose = plugins$$1;\n  }\n\n  exports.version = version;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokenizer = tokenizer;\n  exports.addLooseExports = addLooseExports;\n  exports.Parser = Parser;\n  exports.plugins = plugins;\n  exports.defaultOptions = defaultOptions;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.getLineInfo = getLineInfo;\n  exports.Node = Node;\n  exports.TokenType = TokenType;\n  exports.tokTypes = types;\n  exports.keywordTypes = keywords$1;\n  exports.TokContext = TokContext;\n  exports.tokContexts = types$1;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.Token = Token;\n  exports.isNewLine = isNewLine;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/jsdom/node_modules/acorn/dist/acorn.js"],"names":["global","factory","exports","module","define","amd","acorn","reservedWords","strict","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","test","String","fromCharCode","isIdentifierChar","TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywords$1","kw","options","types","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","source","isNewLine","ecma2019String","nonASCIIwhitespace","skipWhiteSpace","ref","Object","prototype","hasOwnProperty","toString","has","obj","propName","call","isArray","Array","Position","line","col","column","offset","n","SourceLocation","p","start","end","sourceFile","getLineInfo","input","cur","lastIndex","match","exec","index","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","locations","onToken","onComment","ranges","program","directSourceFile","preserveParens","plugins","getOptions","opts","opt","tokens","token","push","pushComment","array","block","text","startLoc","endLoc","comment","type","value","loc","range","keywordRegexp","words","replace","Parser","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","regexpState","isKeyword","word","isReservedWord","extend","f","pluginConfigs","this$1","plugin","Error","parse","node","startNode","nextToken","parseTopLevel","pp","literal","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","body","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","awaitAt","enterLexicalScope","parseFor","init$1","parseVar","declarations","init","await","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","list","label$1","statementStart","generator","async","createNewLexicalScope","update","id","left","right","parseMaybeAssign","isFor","decl","parseVarId","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","member","parseClassMember","method","tryContextual","k","noLineBreak","key","computed","startNodeAt","static","isGenerator","parsePropertyName","parseClassMethod","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","prop","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","raw","statement","pp$2","isBinding","toAssignableList","operator","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","redefinition","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","parseLiteral","regex","pattern","flags","parseParenAndDistinguishExpression","parseNew","val","innerStartPos","innerStartLoc","lastIsComma","spreadStart","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","re","liberal","delegate","pp$4","message","err","SyntaxError","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","parser","pp$6","TokContext","isExpr","preserveSpace","override","types$1","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","data","apply","$LONE","General_Category","gc","sc","Script_Extensions","scx","Script","pp$9","RegExpValidationState","validFlags","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","reset","unicode","at","s","l","c","nextIndex","current","lookahead","advance","ch","codePointToString$1","validateRegExpFlags","state","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","isSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","isDecimalDigit","isControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isValidUnicode","isCharacterClassEscape","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","isOctalDigit","regexp_eatClassControlLetter","isHexDigit","hexToInt","regexp_eatOctalDigit","n1","n2","Token","pp$8","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","codePointToString","str","escaped","inClass","flagsStart","readWord1","e","readInt","radix","total","Infinity","startsWithDot","octal","parseInt","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","substr","escStart","esc","version","parseExpressionAt","tokenizer","addLooseExports","Parser$$1","plugins$$1","parse_dammit","LooseParser","pluginsLoose","tokTypes","keywordTypes","tokContexts","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.acorn = {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (!declaration) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init)) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      this.enterLexicalScope();\n      this.checkLVal(clause.param, \"let\");\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterLexicalScope();\n    }\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type === \"ClassDeclaration\" ||\n      node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n      node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  if (type === \"ForInStatement\") {\n    if (init.type === \"AssignmentPattern\" ||\n      (init.type === \"VariableDeclaration\" && init.declarations[0].init != null &&\n       (this.strict || init.declarations[0].id.type !== \"Identifier\")))\n      { this.raise(init.start, \"Invalid assignment in for-in loop head\"); }\n  }\n  node.left = init;\n  node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var member = this$1.parseClassMember(classBody);\n    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n      hadConstructor = true;\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMember = function(classBody) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this$1.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this$1.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n    node = this.startNode();\n    this.next();\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super Arguments\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc)\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this$1.type === types.eof) { this$1.raise(this$1.pos, \"Unterminated template literal\"); }\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved === \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\nvar data = {\n  \"$LONE\": [\n    \"ASCII\",\n    \"ASCII_Hex_Digit\",\n    \"AHex\",\n    \"Alphabetic\",\n    \"Alpha\",\n    \"Any\",\n    \"Assigned\",\n    \"Bidi_Control\",\n    \"Bidi_C\",\n    \"Bidi_Mirrored\",\n    \"Bidi_M\",\n    \"Case_Ignorable\",\n    \"CI\",\n    \"Cased\",\n    \"Changes_When_Casefolded\",\n    \"CWCF\",\n    \"Changes_When_Casemapped\",\n    \"CWCM\",\n    \"Changes_When_Lowercased\",\n    \"CWL\",\n    \"Changes_When_NFKC_Casefolded\",\n    \"CWKCF\",\n    \"Changes_When_Titlecased\",\n    \"CWT\",\n    \"Changes_When_Uppercased\",\n    \"CWU\",\n    \"Dash\",\n    \"Default_Ignorable_Code_Point\",\n    \"DI\",\n    \"Deprecated\",\n    \"Dep\",\n    \"Diacritic\",\n    \"Dia\",\n    \"Emoji\",\n    \"Emoji_Component\",\n    \"Emoji_Modifier\",\n    \"Emoji_Modifier_Base\",\n    \"Emoji_Presentation\",\n    \"Extender\",\n    \"Ext\",\n    \"Grapheme_Base\",\n    \"Gr_Base\",\n    \"Grapheme_Extend\",\n    \"Gr_Ext\",\n    \"Hex_Digit\",\n    \"Hex\",\n    \"IDS_Binary_Operator\",\n    \"IDSB\",\n    \"IDS_Trinary_Operator\",\n    \"IDST\",\n    \"ID_Continue\",\n    \"IDC\",\n    \"ID_Start\",\n    \"IDS\",\n    \"Ideographic\",\n    \"Ideo\",\n    \"Join_Control\",\n    \"Join_C\",\n    \"Logical_Order_Exception\",\n    \"LOE\",\n    \"Lowercase\",\n    \"Lower\",\n    \"Math\",\n    \"Noncharacter_Code_Point\",\n    \"NChar\",\n    \"Pattern_Syntax\",\n    \"Pat_Syn\",\n    \"Pattern_White_Space\",\n    \"Pat_WS\",\n    \"Quotation_Mark\",\n    \"QMark\",\n    \"Radical\",\n    \"Regional_Indicator\",\n    \"RI\",\n    \"Sentence_Terminal\",\n    \"STerm\",\n    \"Soft_Dotted\",\n    \"SD\",\n    \"Terminal_Punctuation\",\n    \"Term\",\n    \"Unified_Ideograph\",\n    \"UIdeo\",\n    \"Uppercase\",\n    \"Upper\",\n    \"Variation_Selector\",\n    \"VS\",\n    \"White_Space\",\n    \"space\",\n    \"XID_Continue\",\n    \"XIDC\",\n    \"XID_Start\",\n    \"XIDS\"\n  ],\n  \"General_Category\": [\n    \"Cased_Letter\",\n    \"LC\",\n    \"Close_Punctuation\",\n    \"Pe\",\n    \"Connector_Punctuation\",\n    \"Pc\",\n    \"Control\",\n    \"Cc\",\n    \"cntrl\",\n    \"Currency_Symbol\",\n    \"Sc\",\n    \"Dash_Punctuation\",\n    \"Pd\",\n    \"Decimal_Number\",\n    \"Nd\",\n    \"digit\",\n    \"Enclosing_Mark\",\n    \"Me\",\n    \"Final_Punctuation\",\n    \"Pf\",\n    \"Format\",\n    \"Cf\",\n    \"Initial_Punctuation\",\n    \"Pi\",\n    \"Letter\",\n    \"L\",\n    \"Letter_Number\",\n    \"Nl\",\n    \"Line_Separator\",\n    \"Zl\",\n    \"Lowercase_Letter\",\n    \"Ll\",\n    \"Mark\",\n    \"M\",\n    \"Combining_Mark\",\n    \"Math_Symbol\",\n    \"Sm\",\n    \"Modifier_Letter\",\n    \"Lm\",\n    \"Modifier_Symbol\",\n    \"Sk\",\n    \"Nonspacing_Mark\",\n    \"Mn\",\n    \"Number\",\n    \"N\",\n    \"Open_Punctuation\",\n    \"Ps\",\n    \"Other\",\n    \"C\",\n    \"Other_Letter\",\n    \"Lo\",\n    \"Other_Number\",\n    \"No\",\n    \"Other_Punctuation\",\n    \"Po\",\n    \"Other_Symbol\",\n    \"So\",\n    \"Paragraph_Separator\",\n    \"Zp\",\n    \"Private_Use\",\n    \"Co\",\n    \"Punctuation\",\n    \"P\",\n    \"punct\",\n    \"Separator\",\n    \"Z\",\n    \"Space_Separator\",\n    \"Zs\",\n    \"Spacing_Mark\",\n    \"Mc\",\n    \"Surrogate\",\n    \"Cs\",\n    \"Symbol\",\n    \"S\",\n    \"Titlecase_Letter\",\n    \"Lt\",\n    \"Unassigned\",\n    \"Cn\",\n    \"Uppercase_Letter\",\n    \"Lu\"\n  ],\n  \"Script\": [\n    \"Adlam\",\n    \"Adlm\",\n    \"Ahom\",\n    \"Anatolian_Hieroglyphs\",\n    \"Hluw\",\n    \"Arabic\",\n    \"Arab\",\n    \"Armenian\",\n    \"Armn\",\n    \"Avestan\",\n    \"Avst\",\n    \"Balinese\",\n    \"Bali\",\n    \"Bamum\",\n    \"Bamu\",\n    \"Bassa_Vah\",\n    \"Bass\",\n    \"Batak\",\n    \"Batk\",\n    \"Bengali\",\n    \"Beng\",\n    \"Bhaiksuki\",\n    \"Bhks\",\n    \"Bopomofo\",\n    \"Bopo\",\n    \"Brahmi\",\n    \"Brah\",\n    \"Braille\",\n    \"Brai\",\n    \"Buginese\",\n    \"Bugi\",\n    \"Buhid\",\n    \"Buhd\",\n    \"Canadian_Aboriginal\",\n    \"Cans\",\n    \"Carian\",\n    \"Cari\",\n    \"Caucasian_Albanian\",\n    \"Aghb\",\n    \"Chakma\",\n    \"Cakm\",\n    \"Cham\",\n    \"Cherokee\",\n    \"Cher\",\n    \"Common\",\n    \"Zyyy\",\n    \"Coptic\",\n    \"Copt\",\n    \"Qaac\",\n    \"Cuneiform\",\n    \"Xsux\",\n    \"Cypriot\",\n    \"Cprt\",\n    \"Cyrillic\",\n    \"Cyrl\",\n    \"Deseret\",\n    \"Dsrt\",\n    \"Devanagari\",\n    \"Deva\",\n    \"Duployan\",\n    \"Dupl\",\n    \"Egyptian_Hieroglyphs\",\n    \"Egyp\",\n    \"Elbasan\",\n    \"Elba\",\n    \"Ethiopic\",\n    \"Ethi\",\n    \"Georgian\",\n    \"Geor\",\n    \"Glagolitic\",\n    \"Glag\",\n    \"Gothic\",\n    \"Goth\",\n    \"Grantha\",\n    \"Gran\",\n    \"Greek\",\n    \"Grek\",\n    \"Gujarati\",\n    \"Gujr\",\n    \"Gurmukhi\",\n    \"Guru\",\n    \"Han\",\n    \"Hani\",\n    \"Hangul\",\n    \"Hang\",\n    \"Hanunoo\",\n    \"Hano\",\n    \"Hatran\",\n    \"Hatr\",\n    \"Hebrew\",\n    \"Hebr\",\n    \"Hiragana\",\n    \"Hira\",\n    \"Imperial_Aramaic\",\n    \"Armi\",\n    \"Inherited\",\n    \"Zinh\",\n    \"Qaai\",\n    \"Inscriptional_Pahlavi\",\n    \"Phli\",\n    \"Inscriptional_Parthian\",\n    \"Prti\",\n    \"Javanese\",\n    \"Java\",\n    \"Kaithi\",\n    \"Kthi\",\n    \"Kannada\",\n    \"Knda\",\n    \"Katakana\",\n    \"Kana\",\n    \"Kayah_Li\",\n    \"Kali\",\n    \"Kharoshthi\",\n    \"Khar\",\n    \"Khmer\",\n    \"Khmr\",\n    \"Khojki\",\n    \"Khoj\",\n    \"Khudawadi\",\n    \"Sind\",\n    \"Lao\",\n    \"Laoo\",\n    \"Latin\",\n    \"Latn\",\n    \"Lepcha\",\n    \"Lepc\",\n    \"Limbu\",\n    \"Limb\",\n    \"Linear_A\",\n    \"Lina\",\n    \"Linear_B\",\n    \"Linb\",\n    \"Lisu\",\n    \"Lycian\",\n    \"Lyci\",\n    \"Lydian\",\n    \"Lydi\",\n    \"Mahajani\",\n    \"Mahj\",\n    \"Malayalam\",\n    \"Mlym\",\n    \"Mandaic\",\n    \"Mand\",\n    \"Manichaean\",\n    \"Mani\",\n    \"Marchen\",\n    \"Marc\",\n    \"Masaram_Gondi\",\n    \"Gonm\",\n    \"Meetei_Mayek\",\n    \"Mtei\",\n    \"Mende_Kikakui\",\n    \"Mend\",\n    \"Meroitic_Cursive\",\n    \"Merc\",\n    \"Meroitic_Hieroglyphs\",\n    \"Mero\",\n    \"Miao\",\n    \"Plrd\",\n    \"Modi\",\n    \"Mongolian\",\n    \"Mong\",\n    \"Mro\",\n    \"Mroo\",\n    \"Multani\",\n    \"Mult\",\n    \"Myanmar\",\n    \"Mymr\",\n    \"Nabataean\",\n    \"Nbat\",\n    \"New_Tai_Lue\",\n    \"Talu\",\n    \"Newa\",\n    \"Nko\",\n    \"Nkoo\",\n    \"Nushu\",\n    \"Nshu\",\n    \"Ogham\",\n    \"Ogam\",\n    \"Ol_Chiki\",\n    \"Olck\",\n    \"Old_Hungarian\",\n    \"Hung\",\n    \"Old_Italic\",\n    \"Ital\",\n    \"Old_North_Arabian\",\n    \"Narb\",\n    \"Old_Permic\",\n    \"Perm\",\n    \"Old_Persian\",\n    \"Xpeo\",\n    \"Old_South_Arabian\",\n    \"Sarb\",\n    \"Old_Turkic\",\n    \"Orkh\",\n    \"Oriya\",\n    \"Orya\",\n    \"Osage\",\n    \"Osge\",\n    \"Osmanya\",\n    \"Osma\",\n    \"Pahawh_Hmong\",\n    \"Hmng\",\n    \"Palmyrene\",\n    \"Palm\",\n    \"Pau_Cin_Hau\",\n    \"Pauc\",\n    \"Phags_Pa\",\n    \"Phag\",\n    \"Phoenician\",\n    \"Phnx\",\n    \"Psalter_Pahlavi\",\n    \"Phlp\",\n    \"Rejang\",\n    \"Rjng\",\n    \"Runic\",\n    \"Runr\",\n    \"Samaritan\",\n    \"Samr\",\n    \"Saurashtra\",\n    \"Saur\",\n    \"Sharada\",\n    \"Shrd\",\n    \"Shavian\",\n    \"Shaw\",\n    \"Siddham\",\n    \"Sidd\",\n    \"SignWriting\",\n    \"Sgnw\",\n    \"Sinhala\",\n    \"Sinh\",\n    \"Sora_Sompeng\",\n    \"Sora\",\n    \"Soyombo\",\n    \"Soyo\",\n    \"Sundanese\",\n    \"Sund\",\n    \"Syloti_Nagri\",\n    \"Sylo\",\n    \"Syriac\",\n    \"Syrc\",\n    \"Tagalog\",\n    \"Tglg\",\n    \"Tagbanwa\",\n    \"Tagb\",\n    \"Tai_Le\",\n    \"Tale\",\n    \"Tai_Tham\",\n    \"Lana\",\n    \"Tai_Viet\",\n    \"Tavt\",\n    \"Takri\",\n    \"Takr\",\n    \"Tamil\",\n    \"Taml\",\n    \"Tangut\",\n    \"Tang\",\n    \"Telugu\",\n    \"Telu\",\n    \"Thaana\",\n    \"Thaa\",\n    \"Thai\",\n    \"Tibetan\",\n    \"Tibt\",\n    \"Tifinagh\",\n    \"Tfng\",\n    \"Tirhuta\",\n    \"Tirh\",\n    \"Ugaritic\",\n    \"Ugar\",\n    \"Vai\",\n    \"Vaii\",\n    \"Warang_Citi\",\n    \"Wara\",\n    \"Yi\",\n    \"Yiii\",\n    \"Zanabazar_Square\",\n    \"Zanb\"\n  ]\n};\nArray.prototype.push.apply(data.$LONE, data.General_Category);\ndata.gc = data.General_Category;\ndata.sc = data.Script_Extensions = data.scx = data.Script;\n\nvar pp$9 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current () {\n  return this.at(this.pos)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead () {\n  return this.at(this.nextIndex(this.pos))\n};\n\nRegExpValidationState.prototype.advance = function advance () {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true\n  }\n  return false\n};\n\nfunction codePointToString$1(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpFlags = function(state) {\n  var this$1 = this;\n\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this$1.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this$1.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$9.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$9.regexp_disjunction = function(state) {\n  var this$1 = this;\n\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this$1.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$9.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    {  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$9.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$9.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$9.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$9.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$9.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$9.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$9.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$9.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$9.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$9.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$9.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$9.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$9.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString$1(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$9.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$9.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$9.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$9.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$9.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$9.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$9.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$9.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      state.switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$9.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$9.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$9.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\npp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (data.$LONE.indexOf(nameOrValue) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$9.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$9.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$9.regexp_classRanges = function(state) {\n  var this$1 = this;\n\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$9.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$9.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$9.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$9.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$9.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$9.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.7.3\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\n // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  exports.parse_dammit = parse; // eslint-disable-line camelcase\n  exports.LooseParser = Parser$$1;\n  exports.pluginsLoose = plugins$$1;\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = types;\nexports.keywordTypes = keywords$1;\nexports.TokContext = TokContext;\nexports.tokContexts = types$1;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\nexports.nonASCIIwhitespace = nonASCIIwhitespace;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}