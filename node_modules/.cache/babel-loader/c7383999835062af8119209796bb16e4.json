{"ast":null,"code":"/**\n * @fileoverview Define utilify functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n * @param {Node|Token|Comment} token The token to get.\n * @returns {number} The start location.\n * @private\n */\n\n\nfunction getStartLocation(token) {\n  return token.range[0];\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Binary-searches the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\n\n\nexports.search = function search(tokens, location) {\n  return lodash.sortedIndexBy(tokens, {\n    range: [location]\n  }, getStartLocation);\n};\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\n\n\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n  if (startLoc in indexMap) {\n    return indexMap[startLoc];\n  }\n\n  if (startLoc - 1 in indexMap) {\n    const index = indexMap[startLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n    /*\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n     * In that case, +1 is unnecessary.\n     */\n\n    if (token && token.range[0] >= startLoc) {\n      return index;\n    }\n\n    return index + 1;\n  }\n\n  return 0;\n};\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\n\n\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n  if (endLoc in indexMap) {\n    return indexMap[endLoc] - 1;\n  }\n\n  if (endLoc - 1 in indexMap) {\n    const index = indexMap[endLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n    /*\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n     * In that case, -1 is necessary.\n     */\n\n    if (token && token.range[1] > endLoc) {\n      return index - 1;\n    }\n\n    return index;\n  }\n\n  return tokens.length - 1;\n};","map":{"version":3,"sources":["/Users/nguyenquytoan/Desktop/PTUDW-17TN-Nhom05-USFL/react-usfl/PTUDW-17TN-Nhom05/node_modules/eslint/lib/source-code/token-store/utils.js"],"names":["lodash","require","getStartLocation","token","range","exports","search","tokens","location","sortedIndexBy","getFirstIndex","indexMap","startLoc","index","length","getLastIndex","endLoc"],"mappings":"AAAA;;;;AAIA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB,C,CAEA;AACA;AACA;;AAEA;;;;;;;;AAMA,SAASC,gBAAT,CAA0BC,KAA1B,EAAiC;AAC7B,SAAOA,KAAK,CAACC,KAAN,CAAY,CAAZ,CAAP;AACH,C,CAED;AACA;AACA;;AAEA;;;;;;;;;AAOAC,OAAO,CAACC,MAAR,GAAiB,SAASA,MAAT,CAAgBC,MAAhB,EAAwBC,QAAxB,EAAkC;AAC/C,SAAOR,MAAM,CAACS,aAAP,CACHF,MADG,EAEH;AAAEH,IAAAA,KAAK,EAAE,CAACI,QAAD;AAAT,GAFG,EAGHN,gBAHG,CAAP;AAKH,CAND;AAQA;;;;;;;;;;AAQAG,OAAO,CAACK,aAAR,GAAwB,SAASA,aAAT,CAAuBH,MAAvB,EAA+BI,QAA/B,EAAyCC,QAAzC,EAAmD;AACvE,MAAIA,QAAQ,IAAID,QAAhB,EAA0B;AACtB,WAAOA,QAAQ,CAACC,QAAD,CAAf;AACH;;AACD,MAAKA,QAAQ,GAAG,CAAZ,IAAkBD,QAAtB,EAAgC;AAC5B,UAAME,KAAK,GAAGF,QAAQ,CAACC,QAAQ,GAAG,CAAZ,CAAtB;AACA,UAAMT,KAAK,GAAIU,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAGN,MAAM,CAACO,MAA9B,GAAwCP,MAAM,CAACM,KAAD,CAA9C,GAAwD,IAAtE;AAEA;;;;;AAIA,QAAIV,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAY,CAAZ,KAAkBQ,QAA/B,EAAyC;AACrC,aAAOC,KAAP;AACH;;AACD,WAAOA,KAAK,GAAG,CAAf;AACH;;AACD,SAAO,CAAP;AACH,CAlBD;AAoBA;;;;;;;;;;AAQAR,OAAO,CAACU,YAAR,GAAuB,SAASA,YAAT,CAAsBR,MAAtB,EAA8BI,QAA9B,EAAwCK,MAAxC,EAAgD;AACnE,MAAIA,MAAM,IAAIL,QAAd,EAAwB;AACpB,WAAOA,QAAQ,CAACK,MAAD,CAAR,GAAmB,CAA1B;AACH;;AACD,MAAKA,MAAM,GAAG,CAAV,IAAgBL,QAApB,EAA8B;AAC1B,UAAME,KAAK,GAAGF,QAAQ,CAACK,MAAM,GAAG,CAAV,CAAtB;AACA,UAAMb,KAAK,GAAIU,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAGN,MAAM,CAACO,MAA9B,GAAwCP,MAAM,CAACM,KAAD,CAA9C,GAAwD,IAAtE;AAEA;;;;;AAIA,QAAIV,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAY,CAAZ,IAAiBY,MAA9B,EAAsC;AAClC,aAAOH,KAAK,GAAG,CAAf;AACH;;AACD,WAAOA,KAAP;AACH;;AACD,SAAON,MAAM,CAACO,MAAP,GAAgB,CAAvB;AACH,CAlBD","sourcesContent":["/**\n * @fileoverview Define utilify functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n * @param {Node|Token|Comment} token The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n    return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Binary-searches the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    return lodash.sortedIndexBy(\n        tokens,\n        { range: [location] },\n        getStartLocation\n    );\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, +1 is unnecessary.\n         */\n        if (token && token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, -1 is necessary.\n         */\n        if (token && token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n"]},"metadata":{},"sourceType":"script"}